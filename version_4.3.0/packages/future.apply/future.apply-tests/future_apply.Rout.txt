
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:39:19.752] plan(): Setting new future strategy stack:
[17:39:19.752] List of future strategies:
[17:39:19.752] 1. sequential:
[17:39:19.752]    - args: function (..., envir = parent.frame())
[17:39:19.752]    - tweaked: FALSE
[17:39:19.752]    - call: future::plan("sequential")
[17:39:19.762] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:39:19.823] plan(): Setting new future strategy stack:
[17:39:19.823] List of future strategies:
[17:39:19.823] 1. sequential:
[17:39:19.823]    - args: function (..., envir = parent.frame())
[17:39:19.823]    - tweaked: FALSE
[17:39:19.823]    - call: plan(strategy)
[17:39:19.834] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[17:39:19.835] getGlobalsAndPackagesXApply() ...
[17:39:19.835]  - future.globals: TRUE
[17:39:19.836] getGlobalsAndPackages() ...
[17:39:19.836] Searching for globals...
[17:39:19.877] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:39:19.877] Searching for globals ... DONE
[17:39:19.878] Resolving globals: FALSE
[17:39:19.880] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:39:19.880] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:39:19.880] - globals: [1] ‘FUN’
[17:39:19.881] 
[17:39:19.881] getGlobalsAndPackages() ... DONE
[17:39:19.881]  - globals found/used: [n=1] ‘FUN’
[17:39:19.881]  - needed namespaces: [n=0] 
[17:39:19.881] Finding globals ... DONE
[17:39:19.881]  - use_args: TRUE
[17:39:19.881]  - Getting '...' globals ...
[17:39:19.882] resolve() on list ...
[17:39:19.882]  recursive: 0
[17:39:19.882]  length: 1
[17:39:19.882]  elements: ‘...’
[17:39:19.883]  length: 0 (resolved future 1)
[17:39:19.883] resolve() on list ... DONE
[17:39:19.883]    - '...' content: [n=0] 
[17:39:19.883] List of 1
[17:39:19.883]  $ ...: list()
[17:39:19.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:19.883]  - attr(*, "where")=List of 1
[17:39:19.883]   ..$ ...:<environment: 0x55c79705d218> 
[17:39:19.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:19.883]  - attr(*, "resolved")= logi TRUE
[17:39:19.883]  - attr(*, "total_size")= num NA
[17:39:19.888]  - Getting '...' globals ... DONE
[17:39:19.888] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:19.888] List of 2
[17:39:19.888]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:19.888]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:19.888]  $ ...          : list()
[17:39:19.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:19.888]  - attr(*, "where")=List of 2
[17:39:19.888]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:19.888]   ..$ ...          :<environment: 0x55c79705d218> 
[17:39:19.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:19.888]  - attr(*, "resolved")= logi FALSE
[17:39:19.888]  - attr(*, "total_size")= num 354224
[17:39:19.891] Packages to be attached in all futures: [n=0] 
[17:39:19.891] getGlobalsAndPackagesXApply() ... DONE
[17:39:19.891] future_lapply() ...
[17:39:19.924] Number of chunks: 1
[17:39:19.924] getGlobalsAndPackagesXApply() ...
[17:39:19.924]  - future.globals: <name-value list> with names ‘list()’
[17:39:19.925]  - use_args: TRUE
[17:39:19.925] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:19.925] List of 2
[17:39:19.925]  $ ...          : list()
[17:39:19.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:19.925]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:19.925]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:19.925]  - attr(*, "where")=List of 2
[17:39:19.925]   ..$ ...          :<environment: 0x55c79705d218> 
[17:39:19.925]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:19.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:19.925]  - attr(*, "resolved")= logi FALSE
[17:39:19.925]  - attr(*, "total_size")= num NA
[17:39:19.928] Packages to be attached in all futures: [n=0] 
[17:39:19.928] getGlobalsAndPackagesXApply() ... DONE
[17:39:19.928] Number of futures (= number of chunks): 1
[17:39:19.929] Launching 1 futures (chunks) ...
[17:39:19.929] Chunk #1 of 1 ...
[17:39:19.929]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:39:19.929]  - seeds: <none>
[17:39:19.929] getGlobalsAndPackages() ...
[17:39:19.929] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:19.930] Resolving globals: FALSE
[17:39:19.930] Tweak future expression to call with '...' arguments ...
[17:39:19.930] {
[17:39:19.930]     do.call(function(...) {
[17:39:19.930]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:19.930]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:19.930]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:19.930]             on.exit(options(oopts), add = TRUE)
[17:39:19.930]         }
[17:39:19.930]         {
[17:39:19.930]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:19.930]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:19.930]                 ...future.FUN(...future.X_jj, ...)
[17:39:19.930]             })
[17:39:19.930]         }
[17:39:19.930]     }, args = future.call.arguments)
[17:39:19.930] }
[17:39:19.930] Tweak future expression to call with '...' arguments ... DONE
[17:39:19.930] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:19.931] 
[17:39:19.931] getGlobalsAndPackages() ... DONE
[17:39:19.931] run() for ‘Future’ ...
[17:39:19.932] - state: ‘created’
[17:39:19.932] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:19.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:19.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:19.932]   - Field: ‘label’
[17:39:19.932]   - Field: ‘local’
[17:39:19.932]   - Field: ‘owner’
[17:39:19.933]   - Field: ‘envir’
[17:39:19.933]   - Field: ‘packages’
[17:39:19.933]   - Field: ‘gc’
[17:39:19.933]   - Field: ‘conditions’
[17:39:19.933]   - Field: ‘expr’
[17:39:19.933]   - Field: ‘uuid’
[17:39:19.933]   - Field: ‘seed’
[17:39:19.933]   - Field: ‘version’
[17:39:19.933]   - Field: ‘result’
[17:39:19.933]   - Field: ‘asynchronous’
[17:39:19.933]   - Field: ‘calls’
[17:39:19.934]   - Field: ‘globals’
[17:39:19.934]   - Field: ‘stdout’
[17:39:19.934]   - Field: ‘earlySignal’
[17:39:19.934]   - Field: ‘lazy’
[17:39:19.934]   - Field: ‘state’
[17:39:19.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:19.934] - Launch lazy future ...
[17:39:19.935] Packages needed by the future expression (n = 0): <none>
[17:39:19.935] Packages needed by future strategies (n = 0): <none>
[17:39:19.936] {
[17:39:19.936]     {
[17:39:19.936]         {
[17:39:19.936]             ...future.startTime <- base::Sys.time()
[17:39:19.936]             {
[17:39:19.936]                 {
[17:39:19.936]                   {
[17:39:19.936]                     base::local({
[17:39:19.936]                       has_future <- base::requireNamespace("future", 
[17:39:19.936]                         quietly = TRUE)
[17:39:19.936]                       if (has_future) {
[17:39:19.936]                         ns <- base::getNamespace("future")
[17:39:19.936]                         version <- ns[[".package"]][["version"]]
[17:39:19.936]                         if (is.null(version)) 
[17:39:19.936]                           version <- utils::packageVersion("future")
[17:39:19.936]                       }
[17:39:19.936]                       else {
[17:39:19.936]                         version <- NULL
[17:39:19.936]                       }
[17:39:19.936]                       if (!has_future || version < "1.8.0") {
[17:39:19.936]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:19.936]                           "", base::R.version$version.string), 
[17:39:19.936]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:19.936]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:19.936]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:19.936]                             "release", "version")], collapse = " "), 
[17:39:19.936]                           hostname = base::Sys.info()[["nodename"]])
[17:39:19.936]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:19.936]                           info)
[17:39:19.936]                         info <- base::paste(info, collapse = "; ")
[17:39:19.936]                         if (!has_future) {
[17:39:19.936]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:19.936]                             info)
[17:39:19.936]                         }
[17:39:19.936]                         else {
[17:39:19.936]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:19.936]                             info, version)
[17:39:19.936]                         }
[17:39:19.936]                         base::stop(msg)
[17:39:19.936]                       }
[17:39:19.936]                     })
[17:39:19.936]                   }
[17:39:19.936]                   options(future.plan = NULL)
[17:39:19.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:19.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:19.936]                 }
[17:39:19.936]                 ...future.workdir <- getwd()
[17:39:19.936]             }
[17:39:19.936]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:19.936]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:19.936]         }
[17:39:19.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:19.936]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:19.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:19.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:19.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:19.936]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:19.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:19.936]             base::names(...future.oldOptions))
[17:39:19.936]     }
[17:39:19.936]     if (FALSE) {
[17:39:19.936]     }
[17:39:19.936]     else {
[17:39:19.936]         if (TRUE) {
[17:39:19.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:19.936]                 open = "w")
[17:39:19.936]         }
[17:39:19.936]         else {
[17:39:19.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:19.936]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:19.936]         }
[17:39:19.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:19.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:19.936]             base::sink(type = "output", split = FALSE)
[17:39:19.936]             base::close(...future.stdout)
[17:39:19.936]         }, add = TRUE)
[17:39:19.936]     }
[17:39:19.936]     ...future.frame <- base::sys.nframe()
[17:39:19.936]     ...future.conditions <- base::list()
[17:39:19.936]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:19.936]     if (FALSE) {
[17:39:19.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:19.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:19.936]     }
[17:39:19.936]     ...future.result <- base::tryCatch({
[17:39:19.936]         base::withCallingHandlers({
[17:39:19.936]             ...future.value <- base::withVisible(base::local({
[17:39:19.936]                 do.call(function(...) {
[17:39:19.936]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:19.936]                   if (!identical(...future.globals.maxSize.org, 
[17:39:19.936]                     ...future.globals.maxSize)) {
[17:39:19.936]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:19.936]                     on.exit(options(oopts), add = TRUE)
[17:39:19.936]                   }
[17:39:19.936]                   {
[17:39:19.936]                     lapply(seq_along(...future.elements_ii), 
[17:39:19.936]                       FUN = function(jj) {
[17:39:19.936]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:19.936]                         ...future.FUN(...future.X_jj, ...)
[17:39:19.936]                       })
[17:39:19.936]                   }
[17:39:19.936]                 }, args = future.call.arguments)
[17:39:19.936]             }))
[17:39:19.936]             future::FutureResult(value = ...future.value$value, 
[17:39:19.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:19.936]                   ...future.rng), globalenv = if (FALSE) 
[17:39:19.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:19.936]                     ...future.globalenv.names))
[17:39:19.936]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:19.936]         }, condition = base::local({
[17:39:19.936]             c <- base::c
[17:39:19.936]             inherits <- base::inherits
[17:39:19.936]             invokeRestart <- base::invokeRestart
[17:39:19.936]             length <- base::length
[17:39:19.936]             list <- base::list
[17:39:19.936]             seq.int <- base::seq.int
[17:39:19.936]             signalCondition <- base::signalCondition
[17:39:19.936]             sys.calls <- base::sys.calls
[17:39:19.936]             `[[` <- base::`[[`
[17:39:19.936]             `+` <- base::`+`
[17:39:19.936]             `<<-` <- base::`<<-`
[17:39:19.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:19.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:19.936]                   3L)]
[17:39:19.936]             }
[17:39:19.936]             function(cond) {
[17:39:19.936]                 is_error <- inherits(cond, "error")
[17:39:19.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:19.936]                   NULL)
[17:39:19.936]                 if (is_error) {
[17:39:19.936]                   sessionInformation <- function() {
[17:39:19.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:19.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:19.936]                       search = base::search(), system = base::Sys.info())
[17:39:19.936]                   }
[17:39:19.936]                   ...future.conditions[[length(...future.conditions) + 
[17:39:19.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:19.936]                     cond$call), session = sessionInformation(), 
[17:39:19.936]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:19.936]                   signalCondition(cond)
[17:39:19.936]                 }
[17:39:19.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:19.936]                 "immediateCondition"))) {
[17:39:19.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:19.936]                   ...future.conditions[[length(...future.conditions) + 
[17:39:19.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:19.936]                   if (TRUE && !signal) {
[17:39:19.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:19.936]                     {
[17:39:19.936]                       inherits <- base::inherits
[17:39:19.936]                       invokeRestart <- base::invokeRestart
[17:39:19.936]                       is.null <- base::is.null
[17:39:19.936]                       muffled <- FALSE
[17:39:19.936]                       if (inherits(cond, "message")) {
[17:39:19.936]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:19.936]                         if (muffled) 
[17:39:19.936]                           invokeRestart("muffleMessage")
[17:39:19.936]                       }
[17:39:19.936]                       else if (inherits(cond, "warning")) {
[17:39:19.936]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:19.936]                         if (muffled) 
[17:39:19.936]                           invokeRestart("muffleWarning")
[17:39:19.936]                       }
[17:39:19.936]                       else if (inherits(cond, "condition")) {
[17:39:19.936]                         if (!is.null(pattern)) {
[17:39:19.936]                           computeRestarts <- base::computeRestarts
[17:39:19.936]                           grepl <- base::grepl
[17:39:19.936]                           restarts <- computeRestarts(cond)
[17:39:19.936]                           for (restart in restarts) {
[17:39:19.936]                             name <- restart$name
[17:39:19.936]                             if (is.null(name)) 
[17:39:19.936]                               next
[17:39:19.936]                             if (!grepl(pattern, name)) 
[17:39:19.936]                               next
[17:39:19.936]                             invokeRestart(restart)
[17:39:19.936]                             muffled <- TRUE
[17:39:19.936]                             break
[17:39:19.936]                           }
[17:39:19.936]                         }
[17:39:19.936]                       }
[17:39:19.936]                       invisible(muffled)
[17:39:19.936]                     }
[17:39:19.936]                     muffleCondition(cond, pattern = "^muffle")
[17:39:19.936]                   }
[17:39:19.936]                 }
[17:39:19.936]                 else {
[17:39:19.936]                   if (TRUE) {
[17:39:19.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:19.936]                     {
[17:39:19.936]                       inherits <- base::inherits
[17:39:19.936]                       invokeRestart <- base::invokeRestart
[17:39:19.936]                       is.null <- base::is.null
[17:39:19.936]                       muffled <- FALSE
[17:39:19.936]                       if (inherits(cond, "message")) {
[17:39:19.936]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:19.936]                         if (muffled) 
[17:39:19.936]                           invokeRestart("muffleMessage")
[17:39:19.936]                       }
[17:39:19.936]                       else if (inherits(cond, "warning")) {
[17:39:19.936]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:19.936]                         if (muffled) 
[17:39:19.936]                           invokeRestart("muffleWarning")
[17:39:19.936]                       }
[17:39:19.936]                       else if (inherits(cond, "condition")) {
[17:39:19.936]                         if (!is.null(pattern)) {
[17:39:19.936]                           computeRestarts <- base::computeRestarts
[17:39:19.936]                           grepl <- base::grepl
[17:39:19.936]                           restarts <- computeRestarts(cond)
[17:39:19.936]                           for (restart in restarts) {
[17:39:19.936]                             name <- restart$name
[17:39:19.936]                             if (is.null(name)) 
[17:39:19.936]                               next
[17:39:19.936]                             if (!grepl(pattern, name)) 
[17:39:19.936]                               next
[17:39:19.936]                             invokeRestart(restart)
[17:39:19.936]                             muffled <- TRUE
[17:39:19.936]                             break
[17:39:19.936]                           }
[17:39:19.936]                         }
[17:39:19.936]                       }
[17:39:19.936]                       invisible(muffled)
[17:39:19.936]                     }
[17:39:19.936]                     muffleCondition(cond, pattern = "^muffle")
[17:39:19.936]                   }
[17:39:19.936]                 }
[17:39:19.936]             }
[17:39:19.936]         }))
[17:39:19.936]     }, error = function(ex) {
[17:39:19.936]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:19.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:19.936]                 ...future.rng), started = ...future.startTime, 
[17:39:19.936]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:19.936]             version = "1.8"), class = "FutureResult")
[17:39:19.936]     }, finally = {
[17:39:19.936]         if (!identical(...future.workdir, getwd())) 
[17:39:19.936]             setwd(...future.workdir)
[17:39:19.936]         {
[17:39:19.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:19.936]                 ...future.oldOptions$nwarnings <- NULL
[17:39:19.936]             }
[17:39:19.936]             base::options(...future.oldOptions)
[17:39:19.936]             if (.Platform$OS.type == "windows") {
[17:39:19.936]                 old_names <- names(...future.oldEnvVars)
[17:39:19.936]                 envs <- base::Sys.getenv()
[17:39:19.936]                 names <- names(envs)
[17:39:19.936]                 common <- intersect(names, old_names)
[17:39:19.936]                 added <- setdiff(names, old_names)
[17:39:19.936]                 removed <- setdiff(old_names, names)
[17:39:19.936]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:19.936]                   envs[common]]
[17:39:19.936]                 NAMES <- toupper(changed)
[17:39:19.936]                 args <- list()
[17:39:19.936]                 for (kk in seq_along(NAMES)) {
[17:39:19.936]                   name <- changed[[kk]]
[17:39:19.936]                   NAME <- NAMES[[kk]]
[17:39:19.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:19.936]                     next
[17:39:19.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:19.936]                 }
[17:39:19.936]                 NAMES <- toupper(added)
[17:39:19.936]                 for (kk in seq_along(NAMES)) {
[17:39:19.936]                   name <- added[[kk]]
[17:39:19.936]                   NAME <- NAMES[[kk]]
[17:39:19.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:19.936]                     next
[17:39:19.936]                   args[[name]] <- ""
[17:39:19.936]                 }
[17:39:19.936]                 NAMES <- toupper(removed)
[17:39:19.936]                 for (kk in seq_along(NAMES)) {
[17:39:19.936]                   name <- removed[[kk]]
[17:39:19.936]                   NAME <- NAMES[[kk]]
[17:39:19.936]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:19.936]                     next
[17:39:19.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:19.936]                 }
[17:39:19.936]                 if (length(args) > 0) 
[17:39:19.936]                   base::do.call(base::Sys.setenv, args = args)
[17:39:19.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:19.936]             }
[17:39:19.936]             else {
[17:39:19.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:19.936]             }
[17:39:19.936]             {
[17:39:19.936]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:19.936]                   0L) {
[17:39:19.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:19.936]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:19.936]                   base::options(opts)
[17:39:19.936]                 }
[17:39:19.936]                 {
[17:39:19.936]                   {
[17:39:19.936]                     NULL
[17:39:19.936]                     RNGkind("Mersenne-Twister")
[17:39:19.936]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:19.936]                       inherits = FALSE)
[17:39:19.936]                   }
[17:39:19.936]                   options(future.plan = NULL)
[17:39:19.936]                   if (is.na(NA_character_)) 
[17:39:19.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:19.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:19.936]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:19.936]                   {
[17:39:19.936]                     future <- SequentialFuture(..., envir = envir)
[17:39:19.936]                     if (!future$lazy) 
[17:39:19.936]                       future <- run(future)
[17:39:19.936]                     invisible(future)
[17:39:19.936]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:19.936]                 }
[17:39:19.936]             }
[17:39:19.936]         }
[17:39:19.936]     })
[17:39:19.936]     if (TRUE) {
[17:39:19.936]         base::sink(type = "output", split = FALSE)
[17:39:19.936]         if (TRUE) {
[17:39:19.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:19.936]         }
[17:39:19.936]         else {
[17:39:19.936]             ...future.result["stdout"] <- base::list(NULL)
[17:39:19.936]         }
[17:39:19.936]         base::close(...future.stdout)
[17:39:19.936]         ...future.stdout <- NULL
[17:39:19.936]     }
[17:39:19.936]     ...future.result$conditions <- ...future.conditions
[17:39:19.936]     ...future.result$finished <- base::Sys.time()
[17:39:19.936]     ...future.result
[17:39:19.936] }
[17:39:19.938] assign_globals() ...
[17:39:19.938] List of 5
[17:39:19.938]  $ future.call.arguments    : list()
[17:39:19.938]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:19.938]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:19.938]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:19.938]  $ ...future.elements_ii    :List of 2
[17:39:19.938]   ..$ : num [1:4] 1 3 1 7
[17:39:19.938]   ..$ : num [1:4] 2 4 6 8
[17:39:19.938]  $ ...future.seeds_ii       : NULL
[17:39:19.938]  $ ...future.globals.maxSize: num Inf
[17:39:19.938]  - attr(*, "resolved")= logi FALSE
[17:39:19.938]  - attr(*, "total_size")= num NA
[17:39:19.938]  - attr(*, "where")=List of 5
[17:39:19.938]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:19.938]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:19.938]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:19.938]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:19.938]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:19.938]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:19.938]  - attr(*, "already-done")= logi TRUE
[17:39:19.944] - copied ‘future.call.arguments’ to environment
[17:39:19.944] - copied ‘...future.FUN’ to environment
[17:39:19.944] - copied ‘...future.elements_ii’ to environment
[17:39:19.944] - copied ‘...future.seeds_ii’ to environment
[17:39:19.944] - copied ‘...future.globals.maxSize’ to environment
[17:39:19.944] assign_globals() ... done
[17:39:19.945] plan(): Setting new future strategy stack:
[17:39:19.945] List of future strategies:
[17:39:19.945] 1. sequential:
[17:39:19.945]    - args: function (..., envir = parent.frame())
[17:39:19.945]    - tweaked: FALSE
[17:39:19.945]    - call: NULL
[17:39:19.945] plan(): nbrOfWorkers() = 1
[17:39:19.946] plan(): Setting new future strategy stack:
[17:39:19.947] List of future strategies:
[17:39:19.947] 1. sequential:
[17:39:19.947]    - args: function (..., envir = parent.frame())
[17:39:19.947]    - tweaked: FALSE
[17:39:19.947]    - call: plan(strategy)
[17:39:19.947] plan(): nbrOfWorkers() = 1
[17:39:19.947] SequentialFuture started (and completed)
[17:39:19.948] - Launch lazy future ... done
[17:39:19.948] run() for ‘SequentialFuture’ ... done
[17:39:19.948] Created future:
[17:39:19.948] SequentialFuture:
[17:39:19.948] Label: ‘future_apply-1’
[17:39:19.948] Expression:
[17:39:19.948] {
[17:39:19.948]     do.call(function(...) {
[17:39:19.948]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:19.948]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:19.948]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:19.948]             on.exit(options(oopts), add = TRUE)
[17:39:19.948]         }
[17:39:19.948]         {
[17:39:19.948]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:19.948]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:19.948]                 ...future.FUN(...future.X_jj, ...)
[17:39:19.948]             })
[17:39:19.948]         }
[17:39:19.948]     }, args = future.call.arguments)
[17:39:19.948] }
[17:39:19.948] Lazy evaluation: FALSE
[17:39:19.948] Asynchronous evaluation: FALSE
[17:39:19.948] Local evaluation: TRUE
[17:39:19.948] Environment: R_GlobalEnv
[17:39:19.948] Capture standard output: TRUE
[17:39:19.948] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:19.948] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:19.948] Packages: <none>
[17:39:19.948] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:19.948] Resolved: TRUE
[17:39:19.948] Value: 2.21 KiB of class ‘list’
[17:39:19.948] Early signaling: FALSE
[17:39:19.948] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:19.948] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:19.949] Chunk #1 of 1 ... DONE
[17:39:19.950] Launching 1 futures (chunks) ... DONE
[17:39:19.950] Resolving 1 futures (chunks) ...
[17:39:19.950] resolve() on list ...
[17:39:19.950]  recursive: 0
[17:39:19.950]  length: 1
[17:39:19.950] 
[17:39:19.950] resolved() for ‘SequentialFuture’ ...
[17:39:19.950] - state: ‘finished’
[17:39:19.950] - run: TRUE
[17:39:19.951] - result: ‘FutureResult’
[17:39:19.951] resolved() for ‘SequentialFuture’ ... done
[17:39:19.951] Future #1
[17:39:19.951] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:19.951] - nx: 1
[17:39:19.951] - relay: TRUE
[17:39:19.951] - stdout: TRUE
[17:39:19.952] - signal: TRUE
[17:39:19.952] - resignal: FALSE
[17:39:19.952] - force: TRUE
[17:39:19.952] - relayed: [n=1] FALSE
[17:39:19.952] - queued futures: [n=1] FALSE
[17:39:19.952]  - until=1
[17:39:19.952]  - relaying element #1
[17:39:19.952] - relayed: [n=1] TRUE
[17:39:19.952] - queued futures: [n=1] TRUE
[17:39:19.952] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:19.953]  length: 0 (resolved future 1)
[17:39:19.953] Relaying remaining futures
[17:39:19.953] signalConditionsASAP(NULL, pos=0) ...
[17:39:19.953] - nx: 1
[17:39:19.953] - relay: TRUE
[17:39:19.953] - stdout: TRUE
[17:39:19.953] - signal: TRUE
[17:39:19.953] - resignal: FALSE
[17:39:19.953] - force: TRUE
[17:39:19.953] - relayed: [n=1] TRUE
[17:39:19.953] - queued futures: [n=1] TRUE
 - flush all
[17:39:19.954] - relayed: [n=1] TRUE
[17:39:19.954] - queued futures: [n=1] TRUE
[17:39:19.954] signalConditionsASAP(NULL, pos=0) ... done
[17:39:19.954] resolve() on list ... DONE
[17:39:19.954]  - Number of value chunks collected: 1
[17:39:19.954] Resolving 1 futures (chunks) ... DONE
[17:39:19.954] Reducing values from 1 chunks ...
[17:39:19.954]  - Number of values collected after concatenation: 2
[17:39:19.954]  - Number of values expected: 2
[17:39:19.955] Reducing values from 1 chunks ... DONE
[17:39:19.955] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:39:19.956] getGlobalsAndPackagesXApply() ...
[17:39:19.956]  - future.globals: TRUE
[17:39:19.956] getGlobalsAndPackages() ...
[17:39:19.956] Searching for globals...
[17:39:19.989] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:39:19.989] Searching for globals ... DONE
[17:39:19.989] Resolving globals: FALSE
[17:39:19.991] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:39:19.991] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:39:19.991] - globals: [1] ‘FUN’
[17:39:19.991] 
[17:39:19.991] getGlobalsAndPackages() ... DONE
[17:39:19.992]  - globals found/used: [n=1] ‘FUN’
[17:39:19.992]  - needed namespaces: [n=0] 
[17:39:19.992] Finding globals ... DONE
[17:39:19.992]  - use_args: TRUE
[17:39:19.992]  - Getting '...' globals ...
[17:39:19.992] resolve() on list ...
[17:39:19.992]  recursive: 0
[17:39:19.992]  length: 1
[17:39:19.993]  elements: ‘...’
[17:39:19.993]  length: 0 (resolved future 1)
[17:39:19.993] resolve() on list ... DONE
[17:39:19.993]    - '...' content: [n=0] 
[17:39:19.993] List of 1
[17:39:19.993]  $ ...: list()
[17:39:19.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:19.993]  - attr(*, "where")=List of 1
[17:39:19.993]   ..$ ...:<environment: 0x55c796a3db50> 
[17:39:19.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:19.993]  - attr(*, "resolved")= logi TRUE
[17:39:19.993]  - attr(*, "total_size")= num NA
[17:39:19.995]  - Getting '...' globals ... DONE
[17:39:19.996] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:19.996] List of 2
[17:39:19.996]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:19.996]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:19.996]  $ ...          : list()
[17:39:19.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:19.996]  - attr(*, "where")=List of 2
[17:39:19.996]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:19.996]   ..$ ...          :<environment: 0x55c796a3db50> 
[17:39:19.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:19.996]  - attr(*, "resolved")= logi FALSE
[17:39:19.996]  - attr(*, "total_size")= num 354224
[17:39:19.998] Packages to be attached in all futures: [n=0] 
[17:39:19.998] getGlobalsAndPackagesXApply() ... DONE
[17:39:19.998] future_lapply() ...
[17:39:20.029] Number of chunks: 1
[17:39:20.030] getGlobalsAndPackagesXApply() ...
[17:39:20.030]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.030]  - use_args: TRUE
[17:39:20.030] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.030] List of 2
[17:39:20.030]  $ ...          : list()
[17:39:20.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.030]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.030]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.030]  - attr(*, "where")=List of 2
[17:39:20.030]   ..$ ...          :<environment: 0x55c796a3db50> 
[17:39:20.030]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.030]  - attr(*, "resolved")= logi FALSE
[17:39:20.030]  - attr(*, "total_size")= num NA
[17:39:20.033] Packages to be attached in all futures: [n=0] 
[17:39:20.033] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.034] Number of futures (= number of chunks): 1
[17:39:20.034] Launching 1 futures (chunks) ...
[17:39:20.034] Chunk #1 of 1 ...
[17:39:20.034]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:39:20.034]  - seeds: <none>
[17:39:20.034] getGlobalsAndPackages() ...
[17:39:20.034] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.034] Resolving globals: FALSE
[17:39:20.034] Tweak future expression to call with '...' arguments ...
[17:39:20.035] {
[17:39:20.035]     do.call(function(...) {
[17:39:20.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.035]             on.exit(options(oopts), add = TRUE)
[17:39:20.035]         }
[17:39:20.035]         {
[17:39:20.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.035]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.035]             })
[17:39:20.035]         }
[17:39:20.035]     }, args = future.call.arguments)
[17:39:20.035] }
[17:39:20.035] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.035] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.035] 
[17:39:20.035] getGlobalsAndPackages() ... DONE
[17:39:20.036] run() for ‘Future’ ...
[17:39:20.036] - state: ‘created’
[17:39:20.036] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.036] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.036] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.036]   - Field: ‘label’
[17:39:20.036]   - Field: ‘local’
[17:39:20.037]   - Field: ‘owner’
[17:39:20.037]   - Field: ‘envir’
[17:39:20.037]   - Field: ‘packages’
[17:39:20.037]   - Field: ‘gc’
[17:39:20.037]   - Field: ‘conditions’
[17:39:20.037]   - Field: ‘expr’
[17:39:20.038]   - Field: ‘uuid’
[17:39:20.038]   - Field: ‘seed’
[17:39:20.038]   - Field: ‘version’
[17:39:20.038]   - Field: ‘result’
[17:39:20.039]   - Field: ‘asynchronous’
[17:39:20.039]   - Field: ‘calls’
[17:39:20.039]   - Field: ‘globals’
[17:39:20.039]   - Field: ‘stdout’
[17:39:20.039]   - Field: ‘earlySignal’
[17:39:20.039]   - Field: ‘lazy’
[17:39:20.039]   - Field: ‘state’
[17:39:20.039] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.039] - Launch lazy future ...
[17:39:20.040] Packages needed by the future expression (n = 0): <none>
[17:39:20.040] Packages needed by future strategies (n = 0): <none>
[17:39:20.040] {
[17:39:20.040]     {
[17:39:20.040]         {
[17:39:20.040]             ...future.startTime <- base::Sys.time()
[17:39:20.040]             {
[17:39:20.040]                 {
[17:39:20.040]                   {
[17:39:20.040]                     base::local({
[17:39:20.040]                       has_future <- base::requireNamespace("future", 
[17:39:20.040]                         quietly = TRUE)
[17:39:20.040]                       if (has_future) {
[17:39:20.040]                         ns <- base::getNamespace("future")
[17:39:20.040]                         version <- ns[[".package"]][["version"]]
[17:39:20.040]                         if (is.null(version)) 
[17:39:20.040]                           version <- utils::packageVersion("future")
[17:39:20.040]                       }
[17:39:20.040]                       else {
[17:39:20.040]                         version <- NULL
[17:39:20.040]                       }
[17:39:20.040]                       if (!has_future || version < "1.8.0") {
[17:39:20.040]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.040]                           "", base::R.version$version.string), 
[17:39:20.040]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:20.040]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.040]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.040]                             "release", "version")], collapse = " "), 
[17:39:20.040]                           hostname = base::Sys.info()[["nodename"]])
[17:39:20.040]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.040]                           info)
[17:39:20.040]                         info <- base::paste(info, collapse = "; ")
[17:39:20.040]                         if (!has_future) {
[17:39:20.040]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.040]                             info)
[17:39:20.040]                         }
[17:39:20.040]                         else {
[17:39:20.040]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.040]                             info, version)
[17:39:20.040]                         }
[17:39:20.040]                         base::stop(msg)
[17:39:20.040]                       }
[17:39:20.040]                     })
[17:39:20.040]                   }
[17:39:20.040]                   options(future.plan = NULL)
[17:39:20.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.040]                 }
[17:39:20.040]                 ...future.workdir <- getwd()
[17:39:20.040]             }
[17:39:20.040]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.040]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.040]         }
[17:39:20.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.040]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.040]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.040]             base::names(...future.oldOptions))
[17:39:20.040]     }
[17:39:20.040]     if (FALSE) {
[17:39:20.040]     }
[17:39:20.040]     else {
[17:39:20.040]         if (TRUE) {
[17:39:20.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.040]                 open = "w")
[17:39:20.040]         }
[17:39:20.040]         else {
[17:39:20.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.040]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.040]         }
[17:39:20.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.040]             base::sink(type = "output", split = FALSE)
[17:39:20.040]             base::close(...future.stdout)
[17:39:20.040]         }, add = TRUE)
[17:39:20.040]     }
[17:39:20.040]     ...future.frame <- base::sys.nframe()
[17:39:20.040]     ...future.conditions <- base::list()
[17:39:20.040]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.040]     if (FALSE) {
[17:39:20.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.040]     }
[17:39:20.040]     ...future.result <- base::tryCatch({
[17:39:20.040]         base::withCallingHandlers({
[17:39:20.040]             ...future.value <- base::withVisible(base::local({
[17:39:20.040]                 do.call(function(...) {
[17:39:20.040]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.040]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.040]                     ...future.globals.maxSize)) {
[17:39:20.040]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.040]                     on.exit(options(oopts), add = TRUE)
[17:39:20.040]                   }
[17:39:20.040]                   {
[17:39:20.040]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.040]                       FUN = function(jj) {
[17:39:20.040]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.040]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.040]                       })
[17:39:20.040]                   }
[17:39:20.040]                 }, args = future.call.arguments)
[17:39:20.040]             }))
[17:39:20.040]             future::FutureResult(value = ...future.value$value, 
[17:39:20.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.040]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.040]                     ...future.globalenv.names))
[17:39:20.040]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.040]         }, condition = base::local({
[17:39:20.040]             c <- base::c
[17:39:20.040]             inherits <- base::inherits
[17:39:20.040]             invokeRestart <- base::invokeRestart
[17:39:20.040]             length <- base::length
[17:39:20.040]             list <- base::list
[17:39:20.040]             seq.int <- base::seq.int
[17:39:20.040]             signalCondition <- base::signalCondition
[17:39:20.040]             sys.calls <- base::sys.calls
[17:39:20.040]             `[[` <- base::`[[`
[17:39:20.040]             `+` <- base::`+`
[17:39:20.040]             `<<-` <- base::`<<-`
[17:39:20.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.040]                   3L)]
[17:39:20.040]             }
[17:39:20.040]             function(cond) {
[17:39:20.040]                 is_error <- inherits(cond, "error")
[17:39:20.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.040]                   NULL)
[17:39:20.040]                 if (is_error) {
[17:39:20.040]                   sessionInformation <- function() {
[17:39:20.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.040]                       search = base::search(), system = base::Sys.info())
[17:39:20.040]                   }
[17:39:20.040]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.040]                     cond$call), session = sessionInformation(), 
[17:39:20.040]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.040]                   signalCondition(cond)
[17:39:20.040]                 }
[17:39:20.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.040]                 "immediateCondition"))) {
[17:39:20.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.040]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.040]                   if (TRUE && !signal) {
[17:39:20.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.040]                     {
[17:39:20.040]                       inherits <- base::inherits
[17:39:20.040]                       invokeRestart <- base::invokeRestart
[17:39:20.040]                       is.null <- base::is.null
[17:39:20.040]                       muffled <- FALSE
[17:39:20.040]                       if (inherits(cond, "message")) {
[17:39:20.040]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.040]                         if (muffled) 
[17:39:20.040]                           invokeRestart("muffleMessage")
[17:39:20.040]                       }
[17:39:20.040]                       else if (inherits(cond, "warning")) {
[17:39:20.040]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.040]                         if (muffled) 
[17:39:20.040]                           invokeRestart("muffleWarning")
[17:39:20.040]                       }
[17:39:20.040]                       else if (inherits(cond, "condition")) {
[17:39:20.040]                         if (!is.null(pattern)) {
[17:39:20.040]                           computeRestarts <- base::computeRestarts
[17:39:20.040]                           grepl <- base::grepl
[17:39:20.040]                           restarts <- computeRestarts(cond)
[17:39:20.040]                           for (restart in restarts) {
[17:39:20.040]                             name <- restart$name
[17:39:20.040]                             if (is.null(name)) 
[17:39:20.040]                               next
[17:39:20.040]                             if (!grepl(pattern, name)) 
[17:39:20.040]                               next
[17:39:20.040]                             invokeRestart(restart)
[17:39:20.040]                             muffled <- TRUE
[17:39:20.040]                             break
[17:39:20.040]                           }
[17:39:20.040]                         }
[17:39:20.040]                       }
[17:39:20.040]                       invisible(muffled)
[17:39:20.040]                     }
[17:39:20.040]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.040]                   }
[17:39:20.040]                 }
[17:39:20.040]                 else {
[17:39:20.040]                   if (TRUE) {
[17:39:20.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.040]                     {
[17:39:20.040]                       inherits <- base::inherits
[17:39:20.040]                       invokeRestart <- base::invokeRestart
[17:39:20.040]                       is.null <- base::is.null
[17:39:20.040]                       muffled <- FALSE
[17:39:20.040]                       if (inherits(cond, "message")) {
[17:39:20.040]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.040]                         if (muffled) 
[17:39:20.040]                           invokeRestart("muffleMessage")
[17:39:20.040]                       }
[17:39:20.040]                       else if (inherits(cond, "warning")) {
[17:39:20.040]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.040]                         if (muffled) 
[17:39:20.040]                           invokeRestart("muffleWarning")
[17:39:20.040]                       }
[17:39:20.040]                       else if (inherits(cond, "condition")) {
[17:39:20.040]                         if (!is.null(pattern)) {
[17:39:20.040]                           computeRestarts <- base::computeRestarts
[17:39:20.040]                           grepl <- base::grepl
[17:39:20.040]                           restarts <- computeRestarts(cond)
[17:39:20.040]                           for (restart in restarts) {
[17:39:20.040]                             name <- restart$name
[17:39:20.040]                             if (is.null(name)) 
[17:39:20.040]                               next
[17:39:20.040]                             if (!grepl(pattern, name)) 
[17:39:20.040]                               next
[17:39:20.040]                             invokeRestart(restart)
[17:39:20.040]                             muffled <- TRUE
[17:39:20.040]                             break
[17:39:20.040]                           }
[17:39:20.040]                         }
[17:39:20.040]                       }
[17:39:20.040]                       invisible(muffled)
[17:39:20.040]                     }
[17:39:20.040]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.040]                   }
[17:39:20.040]                 }
[17:39:20.040]             }
[17:39:20.040]         }))
[17:39:20.040]     }, error = function(ex) {
[17:39:20.040]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.040]                 ...future.rng), started = ...future.startTime, 
[17:39:20.040]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.040]             version = "1.8"), class = "FutureResult")
[17:39:20.040]     }, finally = {
[17:39:20.040]         if (!identical(...future.workdir, getwd())) 
[17:39:20.040]             setwd(...future.workdir)
[17:39:20.040]         {
[17:39:20.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.040]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.040]             }
[17:39:20.040]             base::options(...future.oldOptions)
[17:39:20.040]             if (.Platform$OS.type == "windows") {
[17:39:20.040]                 old_names <- names(...future.oldEnvVars)
[17:39:20.040]                 envs <- base::Sys.getenv()
[17:39:20.040]                 names <- names(envs)
[17:39:20.040]                 common <- intersect(names, old_names)
[17:39:20.040]                 added <- setdiff(names, old_names)
[17:39:20.040]                 removed <- setdiff(old_names, names)
[17:39:20.040]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.040]                   envs[common]]
[17:39:20.040]                 NAMES <- toupper(changed)
[17:39:20.040]                 args <- list()
[17:39:20.040]                 for (kk in seq_along(NAMES)) {
[17:39:20.040]                   name <- changed[[kk]]
[17:39:20.040]                   NAME <- NAMES[[kk]]
[17:39:20.040]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.040]                     next
[17:39:20.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.040]                 }
[17:39:20.040]                 NAMES <- toupper(added)
[17:39:20.040]                 for (kk in seq_along(NAMES)) {
[17:39:20.040]                   name <- added[[kk]]
[17:39:20.040]                   NAME <- NAMES[[kk]]
[17:39:20.040]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.040]                     next
[17:39:20.040]                   args[[name]] <- ""
[17:39:20.040]                 }
[17:39:20.040]                 NAMES <- toupper(removed)
[17:39:20.040]                 for (kk in seq_along(NAMES)) {
[17:39:20.040]                   name <- removed[[kk]]
[17:39:20.040]                   NAME <- NAMES[[kk]]
[17:39:20.040]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.040]                     next
[17:39:20.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.040]                 }
[17:39:20.040]                 if (length(args) > 0) 
[17:39:20.040]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.040]             }
[17:39:20.040]             else {
[17:39:20.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.040]             }
[17:39:20.040]             {
[17:39:20.040]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.040]                   0L) {
[17:39:20.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.040]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.040]                   base::options(opts)
[17:39:20.040]                 }
[17:39:20.040]                 {
[17:39:20.040]                   {
[17:39:20.040]                     NULL
[17:39:20.040]                     RNGkind("Mersenne-Twister")
[17:39:20.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:20.040]                       inherits = FALSE)
[17:39:20.040]                   }
[17:39:20.040]                   options(future.plan = NULL)
[17:39:20.040]                   if (is.na(NA_character_)) 
[17:39:20.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.040]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.040]                   {
[17:39:20.040]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.040]                     if (!future$lazy) 
[17:39:20.040]                       future <- run(future)
[17:39:20.040]                     invisible(future)
[17:39:20.040]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.040]                 }
[17:39:20.040]             }
[17:39:20.040]         }
[17:39:20.040]     })
[17:39:20.040]     if (TRUE) {
[17:39:20.040]         base::sink(type = "output", split = FALSE)
[17:39:20.040]         if (TRUE) {
[17:39:20.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.040]         }
[17:39:20.040]         else {
[17:39:20.040]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.040]         }
[17:39:20.040]         base::close(...future.stdout)
[17:39:20.040]         ...future.stdout <- NULL
[17:39:20.040]     }
[17:39:20.040]     ...future.result$conditions <- ...future.conditions
[17:39:20.040]     ...future.result$finished <- base::Sys.time()
[17:39:20.040]     ...future.result
[17:39:20.040] }
[17:39:20.042] assign_globals() ...
[17:39:20.042] List of 5
[17:39:20.042]  $ future.call.arguments    : list()
[17:39:20.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.042]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.042]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.042]  $ ...future.elements_ii    :List of 2
[17:39:20.042]   ..$ : num [1:4] 1 3 1 7
[17:39:20.042]   ..$ : num [1:4] 2 4 6 8
[17:39:20.042]  $ ...future.seeds_ii       : NULL
[17:39:20.042]  $ ...future.globals.maxSize: num Inf
[17:39:20.042]  - attr(*, "resolved")= logi FALSE
[17:39:20.042]  - attr(*, "total_size")= num NA
[17:39:20.042]  - attr(*, "where")=List of 5
[17:39:20.042]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.042]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.042]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.042]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.042]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.042]  - attr(*, "already-done")= logi TRUE
[17:39:20.047] - copied ‘future.call.arguments’ to environment
[17:39:20.047] - copied ‘...future.FUN’ to environment
[17:39:20.048] - copied ‘...future.elements_ii’ to environment
[17:39:20.048] - copied ‘...future.seeds_ii’ to environment
[17:39:20.048] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.048] assign_globals() ... done
[17:39:20.048] plan(): Setting new future strategy stack:
[17:39:20.048] List of future strategies:
[17:39:20.048] 1. sequential:
[17:39:20.048]    - args: function (..., envir = parent.frame())
[17:39:20.048]    - tweaked: FALSE
[17:39:20.048]    - call: NULL
[17:39:20.049] plan(): nbrOfWorkers() = 1
[17:39:20.050] plan(): Setting new future strategy stack:
[17:39:20.050] List of future strategies:
[17:39:20.050] 1. sequential:
[17:39:20.050]    - args: function (..., envir = parent.frame())
[17:39:20.050]    - tweaked: FALSE
[17:39:20.050]    - call: plan(strategy)
[17:39:20.051] plan(): nbrOfWorkers() = 1
[17:39:20.051] SequentialFuture started (and completed)
[17:39:20.051] - Launch lazy future ... done
[17:39:20.051] run() for ‘SequentialFuture’ ... done
[17:39:20.051] Created future:
[17:39:20.051] SequentialFuture:
[17:39:20.051] Label: ‘future_apply-1’
[17:39:20.051] Expression:
[17:39:20.051] {
[17:39:20.051]     do.call(function(...) {
[17:39:20.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.051]             on.exit(options(oopts), add = TRUE)
[17:39:20.051]         }
[17:39:20.051]         {
[17:39:20.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.051]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.051]             })
[17:39:20.051]         }
[17:39:20.051]     }, args = future.call.arguments)
[17:39:20.051] }
[17:39:20.051] Lazy evaluation: FALSE
[17:39:20.051] Asynchronous evaluation: FALSE
[17:39:20.051] Local evaluation: TRUE
[17:39:20.051] Environment: R_GlobalEnv
[17:39:20.051] Capture standard output: TRUE
[17:39:20.051] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.051] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.051] Packages: <none>
[17:39:20.051] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.051] Resolved: TRUE
[17:39:20.051] Value: 2.21 KiB of class ‘list’
[17:39:20.051] Early signaling: FALSE
[17:39:20.051] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.051] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.053] Chunk #1 of 1 ... DONE
[17:39:20.053] Launching 1 futures (chunks) ... DONE
[17:39:20.053] Resolving 1 futures (chunks) ...
[17:39:20.053] resolve() on list ...
[17:39:20.053]  recursive: 0
[17:39:20.053]  length: 1
[17:39:20.053] 
[17:39:20.053] resolved() for ‘SequentialFuture’ ...
[17:39:20.053] - state: ‘finished’
[17:39:20.053] - run: TRUE
[17:39:20.054] - result: ‘FutureResult’
[17:39:20.054] resolved() for ‘SequentialFuture’ ... done
[17:39:20.054] Future #1
[17:39:20.054] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.054] - nx: 1
[17:39:20.054] - relay: TRUE
[17:39:20.054] - stdout: TRUE
[17:39:20.054] - signal: TRUE
[17:39:20.054] - resignal: FALSE
[17:39:20.054] - force: TRUE
[17:39:20.055] - relayed: [n=1] FALSE
[17:39:20.055] - queued futures: [n=1] FALSE
[17:39:20.055]  - until=1
[17:39:20.055]  - relaying element #1
[17:39:20.055] - relayed: [n=1] TRUE
[17:39:20.055] - queued futures: [n=1] TRUE
[17:39:20.055] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.055]  length: 0 (resolved future 1)
[17:39:20.055] Relaying remaining futures
[17:39:20.056] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.056] - nx: 1
[17:39:20.056] - relay: TRUE
[17:39:20.056] - stdout: TRUE
[17:39:20.056] - signal: TRUE
[17:39:20.056] - resignal: FALSE
[17:39:20.056] - force: TRUE
[17:39:20.056] - relayed: [n=1] TRUE
[17:39:20.056] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.056] - relayed: [n=1] TRUE
[17:39:20.056] - queued futures: [n=1] TRUE
[17:39:20.056] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.057] resolve() on list ... DONE
[17:39:20.057]  - Number of value chunks collected: 1
[17:39:20.057] Resolving 1 futures (chunks) ... DONE
[17:39:20.057] Reducing values from 1 chunks ...
[17:39:20.057]  - Number of values collected after concatenation: 2
[17:39:20.057]  - Number of values expected: 2
[17:39:20.057] Reducing values from 1 chunks ... DONE
[17:39:20.057] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:39:20.060] getGlobalsAndPackagesXApply() ...
[17:39:20.060]  - future.globals: TRUE
[17:39:20.060] getGlobalsAndPackages() ...
[17:39:20.060] Searching for globals...
[17:39:20.061] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:20.061] Searching for globals ... DONE
[17:39:20.061] Resolving globals: FALSE
[17:39:20.062] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:20.062] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:20.062] - globals: [1] ‘FUN’
[17:39:20.062] - packages: [1] ‘stats’
[17:39:20.063] getGlobalsAndPackages() ... DONE
[17:39:20.063]  - globals found/used: [n=1] ‘FUN’
[17:39:20.063]  - needed namespaces: [n=1] ‘stats’
[17:39:20.063] Finding globals ... DONE
[17:39:20.063]  - use_args: TRUE
[17:39:20.063]  - Getting '...' globals ...
[17:39:20.063] resolve() on list ...
[17:39:20.063]  recursive: 0
[17:39:20.064]  length: 1
[17:39:20.064]  elements: ‘...’
[17:39:20.064]  length: 0 (resolved future 1)
[17:39:20.064] resolve() on list ... DONE
[17:39:20.064]    - '...' content: [n=0] 
[17:39:20.064] List of 1
[17:39:20.064]  $ ...: list()
[17:39:20.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.064]  - attr(*, "where")=List of 1
[17:39:20.064]   ..$ ...:<environment: 0x55c796e936f8> 
[17:39:20.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.064]  - attr(*, "resolved")= logi TRUE
[17:39:20.064]  - attr(*, "total_size")= num NA
[17:39:20.069]  - Getting '...' globals ... DONE
[17:39:20.069] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.069] List of 2
[17:39:20.069]  $ ...future.FUN:function (x, ...)  
[17:39:20.069]  $ ...          : list()
[17:39:20.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.069]  - attr(*, "where")=List of 2
[17:39:20.069]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.069]   ..$ ...          :<environment: 0x55c796e936f8> 
[17:39:20.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.069]  - attr(*, "resolved")= logi FALSE
[17:39:20.069]  - attr(*, "total_size")= num 1248
[17:39:20.072] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:20.072] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.072] future_lapply() ...
[17:39:20.072] Number of chunks: 1
[17:39:20.073] getGlobalsAndPackagesXApply() ...
[17:39:20.073]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.073]  - use_args: TRUE
[17:39:20.073] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.073] List of 2
[17:39:20.073]  $ ...          : list()
[17:39:20.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.073]  $ ...future.FUN:function (x, ...)  
[17:39:20.073]  - attr(*, "where")=List of 2
[17:39:20.073]   ..$ ...          :<environment: 0x55c796e936f8> 
[17:39:20.073]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:39:20.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.073]  - attr(*, "resolved")= logi FALSE
[17:39:20.073]  - attr(*, "total_size")= num NA
[17:39:20.076] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:20.076] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.076] Number of futures (= number of chunks): 1
[17:39:20.076] Launching 1 futures (chunks) ...
[17:39:20.076] Chunk #1 of 1 ...
[17:39:20.077]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:39:20.077]  - seeds: <none>
[17:39:20.077] getGlobalsAndPackages() ...
[17:39:20.077] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.077] Resolving globals: FALSE
[17:39:20.077] Tweak future expression to call with '...' arguments ...
[17:39:20.077] {
[17:39:20.077]     do.call(function(...) {
[17:39:20.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.077]             on.exit(options(oopts), add = TRUE)
[17:39:20.077]         }
[17:39:20.077]         {
[17:39:20.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.077]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.077]             })
[17:39:20.077]         }
[17:39:20.077]     }, args = future.call.arguments)
[17:39:20.077] }
[17:39:20.077] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.078] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.078] - packages: [1] ‘stats’
[17:39:20.078] getGlobalsAndPackages() ... DONE
[17:39:20.078] run() for ‘Future’ ...
[17:39:20.078] - state: ‘created’
[17:39:20.079] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.079]   - Field: ‘label’
[17:39:20.079]   - Field: ‘local’
[17:39:20.079]   - Field: ‘owner’
[17:39:20.079]   - Field: ‘envir’
[17:39:20.079]   - Field: ‘packages’
[17:39:20.080]   - Field: ‘gc’
[17:39:20.080]   - Field: ‘conditions’
[17:39:20.080]   - Field: ‘expr’
[17:39:20.080]   - Field: ‘uuid’
[17:39:20.080]   - Field: ‘seed’
[17:39:20.080]   - Field: ‘version’
[17:39:20.080]   - Field: ‘result’
[17:39:20.080]   - Field: ‘asynchronous’
[17:39:20.080]   - Field: ‘calls’
[17:39:20.080]   - Field: ‘globals’
[17:39:20.080]   - Field: ‘stdout’
[17:39:20.081]   - Field: ‘earlySignal’
[17:39:20.081]   - Field: ‘lazy’
[17:39:20.081]   - Field: ‘state’
[17:39:20.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.081] - Launch lazy future ...
[17:39:20.081] Packages needed by the future expression (n = 1): ‘stats’
[17:39:20.081] Packages needed by future strategies (n = 0): <none>
[17:39:20.082] {
[17:39:20.082]     {
[17:39:20.082]         {
[17:39:20.082]             ...future.startTime <- base::Sys.time()
[17:39:20.082]             {
[17:39:20.082]                 {
[17:39:20.082]                   {
[17:39:20.082]                     {
[17:39:20.082]                       base::local({
[17:39:20.082]                         has_future <- base::requireNamespace("future", 
[17:39:20.082]                           quietly = TRUE)
[17:39:20.082]                         if (has_future) {
[17:39:20.082]                           ns <- base::getNamespace("future")
[17:39:20.082]                           version <- ns[[".package"]][["version"]]
[17:39:20.082]                           if (is.null(version)) 
[17:39:20.082]                             version <- utils::packageVersion("future")
[17:39:20.082]                         }
[17:39:20.082]                         else {
[17:39:20.082]                           version <- NULL
[17:39:20.082]                         }
[17:39:20.082]                         if (!has_future || version < "1.8.0") {
[17:39:20.082]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.082]                             "", base::R.version$version.string), 
[17:39:20.082]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:20.082]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.082]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.082]                               "release", "version")], collapse = " "), 
[17:39:20.082]                             hostname = base::Sys.info()[["nodename"]])
[17:39:20.082]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.082]                             info)
[17:39:20.082]                           info <- base::paste(info, collapse = "; ")
[17:39:20.082]                           if (!has_future) {
[17:39:20.082]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.082]                               info)
[17:39:20.082]                           }
[17:39:20.082]                           else {
[17:39:20.082]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.082]                               info, version)
[17:39:20.082]                           }
[17:39:20.082]                           base::stop(msg)
[17:39:20.082]                         }
[17:39:20.082]                       })
[17:39:20.082]                     }
[17:39:20.082]                     base::local({
[17:39:20.082]                       for (pkg in "stats") {
[17:39:20.082]                         base::loadNamespace(pkg)
[17:39:20.082]                         base::library(pkg, character.only = TRUE)
[17:39:20.082]                       }
[17:39:20.082]                     })
[17:39:20.082]                   }
[17:39:20.082]                   options(future.plan = NULL)
[17:39:20.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.082]                 }
[17:39:20.082]                 ...future.workdir <- getwd()
[17:39:20.082]             }
[17:39:20.082]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.082]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.082]         }
[17:39:20.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.082]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.082]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.082]             base::names(...future.oldOptions))
[17:39:20.082]     }
[17:39:20.082]     if (FALSE) {
[17:39:20.082]     }
[17:39:20.082]     else {
[17:39:20.082]         if (TRUE) {
[17:39:20.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.082]                 open = "w")
[17:39:20.082]         }
[17:39:20.082]         else {
[17:39:20.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.082]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.082]         }
[17:39:20.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.082]             base::sink(type = "output", split = FALSE)
[17:39:20.082]             base::close(...future.stdout)
[17:39:20.082]         }, add = TRUE)
[17:39:20.082]     }
[17:39:20.082]     ...future.frame <- base::sys.nframe()
[17:39:20.082]     ...future.conditions <- base::list()
[17:39:20.082]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.082]     if (FALSE) {
[17:39:20.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.082]     }
[17:39:20.082]     ...future.result <- base::tryCatch({
[17:39:20.082]         base::withCallingHandlers({
[17:39:20.082]             ...future.value <- base::withVisible(base::local({
[17:39:20.082]                 do.call(function(...) {
[17:39:20.082]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.082]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.082]                     ...future.globals.maxSize)) {
[17:39:20.082]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.082]                     on.exit(options(oopts), add = TRUE)
[17:39:20.082]                   }
[17:39:20.082]                   {
[17:39:20.082]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.082]                       FUN = function(jj) {
[17:39:20.082]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.082]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.082]                       })
[17:39:20.082]                   }
[17:39:20.082]                 }, args = future.call.arguments)
[17:39:20.082]             }))
[17:39:20.082]             future::FutureResult(value = ...future.value$value, 
[17:39:20.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.082]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.082]                     ...future.globalenv.names))
[17:39:20.082]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.082]         }, condition = base::local({
[17:39:20.082]             c <- base::c
[17:39:20.082]             inherits <- base::inherits
[17:39:20.082]             invokeRestart <- base::invokeRestart
[17:39:20.082]             length <- base::length
[17:39:20.082]             list <- base::list
[17:39:20.082]             seq.int <- base::seq.int
[17:39:20.082]             signalCondition <- base::signalCondition
[17:39:20.082]             sys.calls <- base::sys.calls
[17:39:20.082]             `[[` <- base::`[[`
[17:39:20.082]             `+` <- base::`+`
[17:39:20.082]             `<<-` <- base::`<<-`
[17:39:20.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.082]                   3L)]
[17:39:20.082]             }
[17:39:20.082]             function(cond) {
[17:39:20.082]                 is_error <- inherits(cond, "error")
[17:39:20.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.082]                   NULL)
[17:39:20.082]                 if (is_error) {
[17:39:20.082]                   sessionInformation <- function() {
[17:39:20.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.082]                       search = base::search(), system = base::Sys.info())
[17:39:20.082]                   }
[17:39:20.082]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.082]                     cond$call), session = sessionInformation(), 
[17:39:20.082]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.082]                   signalCondition(cond)
[17:39:20.082]                 }
[17:39:20.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.082]                 "immediateCondition"))) {
[17:39:20.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.082]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.082]                   if (TRUE && !signal) {
[17:39:20.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.082]                     {
[17:39:20.082]                       inherits <- base::inherits
[17:39:20.082]                       invokeRestart <- base::invokeRestart
[17:39:20.082]                       is.null <- base::is.null
[17:39:20.082]                       muffled <- FALSE
[17:39:20.082]                       if (inherits(cond, "message")) {
[17:39:20.082]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.082]                         if (muffled) 
[17:39:20.082]                           invokeRestart("muffleMessage")
[17:39:20.082]                       }
[17:39:20.082]                       else if (inherits(cond, "warning")) {
[17:39:20.082]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.082]                         if (muffled) 
[17:39:20.082]                           invokeRestart("muffleWarning")
[17:39:20.082]                       }
[17:39:20.082]                       else if (inherits(cond, "condition")) {
[17:39:20.082]                         if (!is.null(pattern)) {
[17:39:20.082]                           computeRestarts <- base::computeRestarts
[17:39:20.082]                           grepl <- base::grepl
[17:39:20.082]                           restarts <- computeRestarts(cond)
[17:39:20.082]                           for (restart in restarts) {
[17:39:20.082]                             name <- restart$name
[17:39:20.082]                             if (is.null(name)) 
[17:39:20.082]                               next
[17:39:20.082]                             if (!grepl(pattern, name)) 
[17:39:20.082]                               next
[17:39:20.082]                             invokeRestart(restart)
[17:39:20.082]                             muffled <- TRUE
[17:39:20.082]                             break
[17:39:20.082]                           }
[17:39:20.082]                         }
[17:39:20.082]                       }
[17:39:20.082]                       invisible(muffled)
[17:39:20.082]                     }
[17:39:20.082]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.082]                   }
[17:39:20.082]                 }
[17:39:20.082]                 else {
[17:39:20.082]                   if (TRUE) {
[17:39:20.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.082]                     {
[17:39:20.082]                       inherits <- base::inherits
[17:39:20.082]                       invokeRestart <- base::invokeRestart
[17:39:20.082]                       is.null <- base::is.null
[17:39:20.082]                       muffled <- FALSE
[17:39:20.082]                       if (inherits(cond, "message")) {
[17:39:20.082]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.082]                         if (muffled) 
[17:39:20.082]                           invokeRestart("muffleMessage")
[17:39:20.082]                       }
[17:39:20.082]                       else if (inherits(cond, "warning")) {
[17:39:20.082]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.082]                         if (muffled) 
[17:39:20.082]                           invokeRestart("muffleWarning")
[17:39:20.082]                       }
[17:39:20.082]                       else if (inherits(cond, "condition")) {
[17:39:20.082]                         if (!is.null(pattern)) {
[17:39:20.082]                           computeRestarts <- base::computeRestarts
[17:39:20.082]                           grepl <- base::grepl
[17:39:20.082]                           restarts <- computeRestarts(cond)
[17:39:20.082]                           for (restart in restarts) {
[17:39:20.082]                             name <- restart$name
[17:39:20.082]                             if (is.null(name)) 
[17:39:20.082]                               next
[17:39:20.082]                             if (!grepl(pattern, name)) 
[17:39:20.082]                               next
[17:39:20.082]                             invokeRestart(restart)
[17:39:20.082]                             muffled <- TRUE
[17:39:20.082]                             break
[17:39:20.082]                           }
[17:39:20.082]                         }
[17:39:20.082]                       }
[17:39:20.082]                       invisible(muffled)
[17:39:20.082]                     }
[17:39:20.082]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.082]                   }
[17:39:20.082]                 }
[17:39:20.082]             }
[17:39:20.082]         }))
[17:39:20.082]     }, error = function(ex) {
[17:39:20.082]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.082]                 ...future.rng), started = ...future.startTime, 
[17:39:20.082]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.082]             version = "1.8"), class = "FutureResult")
[17:39:20.082]     }, finally = {
[17:39:20.082]         if (!identical(...future.workdir, getwd())) 
[17:39:20.082]             setwd(...future.workdir)
[17:39:20.082]         {
[17:39:20.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.082]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.082]             }
[17:39:20.082]             base::options(...future.oldOptions)
[17:39:20.082]             if (.Platform$OS.type == "windows") {
[17:39:20.082]                 old_names <- names(...future.oldEnvVars)
[17:39:20.082]                 envs <- base::Sys.getenv()
[17:39:20.082]                 names <- names(envs)
[17:39:20.082]                 common <- intersect(names, old_names)
[17:39:20.082]                 added <- setdiff(names, old_names)
[17:39:20.082]                 removed <- setdiff(old_names, names)
[17:39:20.082]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.082]                   envs[common]]
[17:39:20.082]                 NAMES <- toupper(changed)
[17:39:20.082]                 args <- list()
[17:39:20.082]                 for (kk in seq_along(NAMES)) {
[17:39:20.082]                   name <- changed[[kk]]
[17:39:20.082]                   NAME <- NAMES[[kk]]
[17:39:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.082]                     next
[17:39:20.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.082]                 }
[17:39:20.082]                 NAMES <- toupper(added)
[17:39:20.082]                 for (kk in seq_along(NAMES)) {
[17:39:20.082]                   name <- added[[kk]]
[17:39:20.082]                   NAME <- NAMES[[kk]]
[17:39:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.082]                     next
[17:39:20.082]                   args[[name]] <- ""
[17:39:20.082]                 }
[17:39:20.082]                 NAMES <- toupper(removed)
[17:39:20.082]                 for (kk in seq_along(NAMES)) {
[17:39:20.082]                   name <- removed[[kk]]
[17:39:20.082]                   NAME <- NAMES[[kk]]
[17:39:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.082]                     next
[17:39:20.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.082]                 }
[17:39:20.082]                 if (length(args) > 0) 
[17:39:20.082]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.082]             }
[17:39:20.082]             else {
[17:39:20.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.082]             }
[17:39:20.082]             {
[17:39:20.082]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.082]                   0L) {
[17:39:20.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.082]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.082]                   base::options(opts)
[17:39:20.082]                 }
[17:39:20.082]                 {
[17:39:20.082]                   {
[17:39:20.082]                     NULL
[17:39:20.082]                     RNGkind("Mersenne-Twister")
[17:39:20.082]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:20.082]                       inherits = FALSE)
[17:39:20.082]                   }
[17:39:20.082]                   options(future.plan = NULL)
[17:39:20.082]                   if (is.na(NA_character_)) 
[17:39:20.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.082]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.082]                   {
[17:39:20.082]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.082]                     if (!future$lazy) 
[17:39:20.082]                       future <- run(future)
[17:39:20.082]                     invisible(future)
[17:39:20.082]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.082]                 }
[17:39:20.082]             }
[17:39:20.082]         }
[17:39:20.082]     })
[17:39:20.082]     if (TRUE) {
[17:39:20.082]         base::sink(type = "output", split = FALSE)
[17:39:20.082]         if (TRUE) {
[17:39:20.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.082]         }
[17:39:20.082]         else {
[17:39:20.082]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.082]         }
[17:39:20.082]         base::close(...future.stdout)
[17:39:20.082]         ...future.stdout <- NULL
[17:39:20.082]     }
[17:39:20.082]     ...future.result$conditions <- ...future.conditions
[17:39:20.082]     ...future.result$finished <- base::Sys.time()
[17:39:20.082]     ...future.result
[17:39:20.082] }
[17:39:20.083] assign_globals() ...
[17:39:20.084] List of 5
[17:39:20.084]  $ future.call.arguments    : list()
[17:39:20.084]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.084]  $ ...future.FUN            :function (x, ...)  
[17:39:20.084]  $ ...future.elements_ii    :List of 2
[17:39:20.084]   ..$ : num [1:4] 1 3 1 7
[17:39:20.084]   ..$ : num [1:4] 2 4 6 8
[17:39:20.084]  $ ...future.seeds_ii       : NULL
[17:39:20.084]  $ ...future.globals.maxSize: num Inf
[17:39:20.084]  - attr(*, "resolved")= logi FALSE
[17:39:20.084]  - attr(*, "total_size")= num NA
[17:39:20.084]  - attr(*, "where")=List of 5
[17:39:20.084]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.084]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.084]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.084]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.084]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.084]  - attr(*, "already-done")= logi TRUE
[17:39:20.090] - copied ‘future.call.arguments’ to environment
[17:39:20.090] - copied ‘...future.FUN’ to environment
[17:39:20.090] - copied ‘...future.elements_ii’ to environment
[17:39:20.090] - copied ‘...future.seeds_ii’ to environment
[17:39:20.090] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.090] assign_globals() ... done
[17:39:20.091] plan(): Setting new future strategy stack:
[17:39:20.091] List of future strategies:
[17:39:20.091] 1. sequential:
[17:39:20.091]    - args: function (..., envir = parent.frame())
[17:39:20.091]    - tweaked: FALSE
[17:39:20.091]    - call: NULL
[17:39:20.091] plan(): nbrOfWorkers() = 1
[17:39:20.092] plan(): Setting new future strategy stack:
[17:39:20.093] List of future strategies:
[17:39:20.093] 1. sequential:
[17:39:20.093]    - args: function (..., envir = parent.frame())
[17:39:20.093]    - tweaked: FALSE
[17:39:20.093]    - call: plan(strategy)
[17:39:20.093] plan(): nbrOfWorkers() = 1
[17:39:20.093] SequentialFuture started (and completed)
[17:39:20.093] - Launch lazy future ... done
[17:39:20.093] run() for ‘SequentialFuture’ ... done
[17:39:20.093] Created future:
[17:39:20.093] SequentialFuture:
[17:39:20.093] Label: ‘future_apply-1’
[17:39:20.093] Expression:
[17:39:20.093] {
[17:39:20.093]     do.call(function(...) {
[17:39:20.093]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.093]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.093]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.093]             on.exit(options(oopts), add = TRUE)
[17:39:20.093]         }
[17:39:20.093]         {
[17:39:20.093]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.093]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.093]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.093]             })
[17:39:20.093]         }
[17:39:20.093]     }, args = future.call.arguments)
[17:39:20.093] }
[17:39:20.093] Lazy evaluation: FALSE
[17:39:20.093] Asynchronous evaluation: FALSE
[17:39:20.093] Local evaluation: TRUE
[17:39:20.093] Environment: R_GlobalEnv
[17:39:20.093] Capture standard output: TRUE
[17:39:20.093] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.093] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.093] Packages: 1 packages (‘stats’)
[17:39:20.093] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.093] Resolved: TRUE
[17:39:20.093] Value: 1.14 KiB of class ‘list’
[17:39:20.093] Early signaling: FALSE
[17:39:20.093] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.093] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.094] Chunk #1 of 1 ... DONE
[17:39:20.095] Launching 1 futures (chunks) ... DONE
[17:39:20.095] Resolving 1 futures (chunks) ...
[17:39:20.095] resolve() on list ...
[17:39:20.095]  recursive: 0
[17:39:20.095]  length: 1
[17:39:20.095] 
[17:39:20.095] resolved() for ‘SequentialFuture’ ...
[17:39:20.095] - state: ‘finished’
[17:39:20.095] - run: TRUE
[17:39:20.095] - result: ‘FutureResult’
[17:39:20.096] resolved() for ‘SequentialFuture’ ... done
[17:39:20.096] Future #1
[17:39:20.096] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.096] - nx: 1
[17:39:20.096] - relay: TRUE
[17:39:20.096] - stdout: TRUE
[17:39:20.096] - signal: TRUE
[17:39:20.096] - resignal: FALSE
[17:39:20.096] - force: TRUE
[17:39:20.096] - relayed: [n=1] FALSE
[17:39:20.096] - queued futures: [n=1] FALSE
[17:39:20.097]  - until=1
[17:39:20.097]  - relaying element #1
[17:39:20.097] - relayed: [n=1] TRUE
[17:39:20.097] - queued futures: [n=1] TRUE
[17:39:20.097] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.097]  length: 0 (resolved future 1)
[17:39:20.097] Relaying remaining futures
[17:39:20.097] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.097] - nx: 1
[17:39:20.097] - relay: TRUE
[17:39:20.098] - stdout: TRUE
[17:39:20.098] - signal: TRUE
[17:39:20.098] - resignal: FALSE
[17:39:20.098] - force: TRUE
[17:39:20.098] - relayed: [n=1] TRUE
[17:39:20.098] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.098] - relayed: [n=1] TRUE
[17:39:20.098] - queued futures: [n=1] TRUE
[17:39:20.098] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.098] resolve() on list ... DONE
[17:39:20.098]  - Number of value chunks collected: 1
[17:39:20.099] Resolving 1 futures (chunks) ... DONE
[17:39:20.099] Reducing values from 1 chunks ...
[17:39:20.099]  - Number of values collected after concatenation: 2
[17:39:20.099]  - Number of values expected: 2
[17:39:20.099] Reducing values from 1 chunks ... DONE
[17:39:20.099] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:39:20.100] getGlobalsAndPackagesXApply() ...
[17:39:20.100]  - future.globals: TRUE
[17:39:20.100] getGlobalsAndPackages() ...
[17:39:20.100] Searching for globals...
[17:39:20.101] - globals found: [1] ‘FUN’
[17:39:20.101] Searching for globals ... DONE
[17:39:20.101] Resolving globals: FALSE
[17:39:20.101] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:20.102] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:20.102] - globals: [1] ‘FUN’
[17:39:20.102] 
[17:39:20.102] getGlobalsAndPackages() ... DONE
[17:39:20.102]  - globals found/used: [n=1] ‘FUN’
[17:39:20.102]  - needed namespaces: [n=0] 
[17:39:20.102] Finding globals ... DONE
[17:39:20.102]  - use_args: TRUE
[17:39:20.103]  - Getting '...' globals ...
[17:39:20.103] resolve() on list ...
[17:39:20.103]  recursive: 0
[17:39:20.103]  length: 1
[17:39:20.103]  elements: ‘...’
[17:39:20.103]  length: 0 (resolved future 1)
[17:39:20.103] resolve() on list ... DONE
[17:39:20.103]    - '...' content: [n=0] 
[17:39:20.104] List of 1
[17:39:20.104]  $ ...: list()
[17:39:20.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.104]  - attr(*, "where")=List of 1
[17:39:20.104]   ..$ ...:<environment: 0x55c7966aab48> 
[17:39:20.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.104]  - attr(*, "resolved")= logi TRUE
[17:39:20.104]  - attr(*, "total_size")= num NA
[17:39:20.106]  - Getting '...' globals ... DONE
[17:39:20.106] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.106] List of 2
[17:39:20.106]  $ ...future.FUN:function (x)  
[17:39:20.106]  $ ...          : list()
[17:39:20.106]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.106]  - attr(*, "where")=List of 2
[17:39:20.106]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.106]   ..$ ...          :<environment: 0x55c7966aab48> 
[17:39:20.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.106]  - attr(*, "resolved")= logi FALSE
[17:39:20.106]  - attr(*, "total_size")= num 848
[17:39:20.109] Packages to be attached in all futures: [n=0] 
[17:39:20.109] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.109] future_lapply() ...
[17:39:20.109] Number of chunks: 1
[17:39:20.110] getGlobalsAndPackagesXApply() ...
[17:39:20.110]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.110]  - use_args: TRUE
[17:39:20.110] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.110] List of 2
[17:39:20.110]  $ ...          : list()
[17:39:20.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.110]  $ ...future.FUN:function (x)  
[17:39:20.110]  - attr(*, "where")=List of 2
[17:39:20.110]   ..$ ...          :<environment: 0x55c7966aab48> 
[17:39:20.110]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.110]  - attr(*, "resolved")= logi FALSE
[17:39:20.110]  - attr(*, "total_size")= num NA
[17:39:20.115] Packages to be attached in all futures: [n=0] 
[17:39:20.115] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.115] Number of futures (= number of chunks): 1
[17:39:20.115] Launching 1 futures (chunks) ...
[17:39:20.115] Chunk #1 of 1 ...
[17:39:20.115]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:39:20.115]  - seeds: <none>
[17:39:20.115] getGlobalsAndPackages() ...
[17:39:20.115] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.116] Resolving globals: FALSE
[17:39:20.116] Tweak future expression to call with '...' arguments ...
[17:39:20.116] {
[17:39:20.116]     do.call(function(...) {
[17:39:20.116]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.116]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.116]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.116]             on.exit(options(oopts), add = TRUE)
[17:39:20.116]         }
[17:39:20.116]         {
[17:39:20.116]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.116]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.116]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.116]             })
[17:39:20.116]         }
[17:39:20.116]     }, args = future.call.arguments)
[17:39:20.116] }
[17:39:20.116] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.116] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.117] 
[17:39:20.117] getGlobalsAndPackages() ... DONE
[17:39:20.117] run() for ‘Future’ ...
[17:39:20.117] - state: ‘created’
[17:39:20.117] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.117] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.118]   - Field: ‘label’
[17:39:20.118]   - Field: ‘local’
[17:39:20.118]   - Field: ‘owner’
[17:39:20.118]   - Field: ‘envir’
[17:39:20.118]   - Field: ‘packages’
[17:39:20.118]   - Field: ‘gc’
[17:39:20.118]   - Field: ‘conditions’
[17:39:20.118]   - Field: ‘expr’
[17:39:20.118]   - Field: ‘uuid’
[17:39:20.118]   - Field: ‘seed’
[17:39:20.119]   - Field: ‘version’
[17:39:20.119]   - Field: ‘result’
[17:39:20.119]   - Field: ‘asynchronous’
[17:39:20.119]   - Field: ‘calls’
[17:39:20.119]   - Field: ‘globals’
[17:39:20.119]   - Field: ‘stdout’
[17:39:20.119]   - Field: ‘earlySignal’
[17:39:20.119]   - Field: ‘lazy’
[17:39:20.119]   - Field: ‘state’
[17:39:20.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.119] - Launch lazy future ...
[17:39:20.120] Packages needed by the future expression (n = 0): <none>
[17:39:20.120] Packages needed by future strategies (n = 0): <none>
[17:39:20.120] {
[17:39:20.120]     {
[17:39:20.120]         {
[17:39:20.120]             ...future.startTime <- base::Sys.time()
[17:39:20.120]             {
[17:39:20.120]                 {
[17:39:20.120]                   {
[17:39:20.120]                     base::local({
[17:39:20.120]                       has_future <- base::requireNamespace("future", 
[17:39:20.120]                         quietly = TRUE)
[17:39:20.120]                       if (has_future) {
[17:39:20.120]                         ns <- base::getNamespace("future")
[17:39:20.120]                         version <- ns[[".package"]][["version"]]
[17:39:20.120]                         if (is.null(version)) 
[17:39:20.120]                           version <- utils::packageVersion("future")
[17:39:20.120]                       }
[17:39:20.120]                       else {
[17:39:20.120]                         version <- NULL
[17:39:20.120]                       }
[17:39:20.120]                       if (!has_future || version < "1.8.0") {
[17:39:20.120]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.120]                           "", base::R.version$version.string), 
[17:39:20.120]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:20.120]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.120]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.120]                             "release", "version")], collapse = " "), 
[17:39:20.120]                           hostname = base::Sys.info()[["nodename"]])
[17:39:20.120]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.120]                           info)
[17:39:20.120]                         info <- base::paste(info, collapse = "; ")
[17:39:20.120]                         if (!has_future) {
[17:39:20.120]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.120]                             info)
[17:39:20.120]                         }
[17:39:20.120]                         else {
[17:39:20.120]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.120]                             info, version)
[17:39:20.120]                         }
[17:39:20.120]                         base::stop(msg)
[17:39:20.120]                       }
[17:39:20.120]                     })
[17:39:20.120]                   }
[17:39:20.120]                   options(future.plan = NULL)
[17:39:20.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.120]                 }
[17:39:20.120]                 ...future.workdir <- getwd()
[17:39:20.120]             }
[17:39:20.120]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.120]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.120]         }
[17:39:20.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.120]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.120]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.120]             base::names(...future.oldOptions))
[17:39:20.120]     }
[17:39:20.120]     if (FALSE) {
[17:39:20.120]     }
[17:39:20.120]     else {
[17:39:20.120]         if (TRUE) {
[17:39:20.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.120]                 open = "w")
[17:39:20.120]         }
[17:39:20.120]         else {
[17:39:20.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.120]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.120]         }
[17:39:20.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.120]             base::sink(type = "output", split = FALSE)
[17:39:20.120]             base::close(...future.stdout)
[17:39:20.120]         }, add = TRUE)
[17:39:20.120]     }
[17:39:20.120]     ...future.frame <- base::sys.nframe()
[17:39:20.120]     ...future.conditions <- base::list()
[17:39:20.120]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.120]     if (FALSE) {
[17:39:20.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.120]     }
[17:39:20.120]     ...future.result <- base::tryCatch({
[17:39:20.120]         base::withCallingHandlers({
[17:39:20.120]             ...future.value <- base::withVisible(base::local({
[17:39:20.120]                 do.call(function(...) {
[17:39:20.120]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.120]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.120]                     ...future.globals.maxSize)) {
[17:39:20.120]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.120]                     on.exit(options(oopts), add = TRUE)
[17:39:20.120]                   }
[17:39:20.120]                   {
[17:39:20.120]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.120]                       FUN = function(jj) {
[17:39:20.120]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.120]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.120]                       })
[17:39:20.120]                   }
[17:39:20.120]                 }, args = future.call.arguments)
[17:39:20.120]             }))
[17:39:20.120]             future::FutureResult(value = ...future.value$value, 
[17:39:20.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.120]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.120]                     ...future.globalenv.names))
[17:39:20.120]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.120]         }, condition = base::local({
[17:39:20.120]             c <- base::c
[17:39:20.120]             inherits <- base::inherits
[17:39:20.120]             invokeRestart <- base::invokeRestart
[17:39:20.120]             length <- base::length
[17:39:20.120]             list <- base::list
[17:39:20.120]             seq.int <- base::seq.int
[17:39:20.120]             signalCondition <- base::signalCondition
[17:39:20.120]             sys.calls <- base::sys.calls
[17:39:20.120]             `[[` <- base::`[[`
[17:39:20.120]             `+` <- base::`+`
[17:39:20.120]             `<<-` <- base::`<<-`
[17:39:20.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.120]                   3L)]
[17:39:20.120]             }
[17:39:20.120]             function(cond) {
[17:39:20.120]                 is_error <- inherits(cond, "error")
[17:39:20.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.120]                   NULL)
[17:39:20.120]                 if (is_error) {
[17:39:20.120]                   sessionInformation <- function() {
[17:39:20.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.120]                       search = base::search(), system = base::Sys.info())
[17:39:20.120]                   }
[17:39:20.120]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.120]                     cond$call), session = sessionInformation(), 
[17:39:20.120]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.120]                   signalCondition(cond)
[17:39:20.120]                 }
[17:39:20.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.120]                 "immediateCondition"))) {
[17:39:20.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.120]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.120]                   if (TRUE && !signal) {
[17:39:20.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.120]                     {
[17:39:20.120]                       inherits <- base::inherits
[17:39:20.120]                       invokeRestart <- base::invokeRestart
[17:39:20.120]                       is.null <- base::is.null
[17:39:20.120]                       muffled <- FALSE
[17:39:20.120]                       if (inherits(cond, "message")) {
[17:39:20.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.120]                         if (muffled) 
[17:39:20.120]                           invokeRestart("muffleMessage")
[17:39:20.120]                       }
[17:39:20.120]                       else if (inherits(cond, "warning")) {
[17:39:20.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.120]                         if (muffled) 
[17:39:20.120]                           invokeRestart("muffleWarning")
[17:39:20.120]                       }
[17:39:20.120]                       else if (inherits(cond, "condition")) {
[17:39:20.120]                         if (!is.null(pattern)) {
[17:39:20.120]                           computeRestarts <- base::computeRestarts
[17:39:20.120]                           grepl <- base::grepl
[17:39:20.120]                           restarts <- computeRestarts(cond)
[17:39:20.120]                           for (restart in restarts) {
[17:39:20.120]                             name <- restart$name
[17:39:20.120]                             if (is.null(name)) 
[17:39:20.120]                               next
[17:39:20.120]                             if (!grepl(pattern, name)) 
[17:39:20.120]                               next
[17:39:20.120]                             invokeRestart(restart)
[17:39:20.120]                             muffled <- TRUE
[17:39:20.120]                             break
[17:39:20.120]                           }
[17:39:20.120]                         }
[17:39:20.120]                       }
[17:39:20.120]                       invisible(muffled)
[17:39:20.120]                     }
[17:39:20.120]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.120]                   }
[17:39:20.120]                 }
[17:39:20.120]                 else {
[17:39:20.120]                   if (TRUE) {
[17:39:20.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.120]                     {
[17:39:20.120]                       inherits <- base::inherits
[17:39:20.120]                       invokeRestart <- base::invokeRestart
[17:39:20.120]                       is.null <- base::is.null
[17:39:20.120]                       muffled <- FALSE
[17:39:20.120]                       if (inherits(cond, "message")) {
[17:39:20.120]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.120]                         if (muffled) 
[17:39:20.120]                           invokeRestart("muffleMessage")
[17:39:20.120]                       }
[17:39:20.120]                       else if (inherits(cond, "warning")) {
[17:39:20.120]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.120]                         if (muffled) 
[17:39:20.120]                           invokeRestart("muffleWarning")
[17:39:20.120]                       }
[17:39:20.120]                       else if (inherits(cond, "condition")) {
[17:39:20.120]                         if (!is.null(pattern)) {
[17:39:20.120]                           computeRestarts <- base::computeRestarts
[17:39:20.120]                           grepl <- base::grepl
[17:39:20.120]                           restarts <- computeRestarts(cond)
[17:39:20.120]                           for (restart in restarts) {
[17:39:20.120]                             name <- restart$name
[17:39:20.120]                             if (is.null(name)) 
[17:39:20.120]                               next
[17:39:20.120]                             if (!grepl(pattern, name)) 
[17:39:20.120]                               next
[17:39:20.120]                             invokeRestart(restart)
[17:39:20.120]                             muffled <- TRUE
[17:39:20.120]                             break
[17:39:20.120]                           }
[17:39:20.120]                         }
[17:39:20.120]                       }
[17:39:20.120]                       invisible(muffled)
[17:39:20.120]                     }
[17:39:20.120]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.120]                   }
[17:39:20.120]                 }
[17:39:20.120]             }
[17:39:20.120]         }))
[17:39:20.120]     }, error = function(ex) {
[17:39:20.120]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.120]                 ...future.rng), started = ...future.startTime, 
[17:39:20.120]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.120]             version = "1.8"), class = "FutureResult")
[17:39:20.120]     }, finally = {
[17:39:20.120]         if (!identical(...future.workdir, getwd())) 
[17:39:20.120]             setwd(...future.workdir)
[17:39:20.120]         {
[17:39:20.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.120]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.120]             }
[17:39:20.120]             base::options(...future.oldOptions)
[17:39:20.120]             if (.Platform$OS.type == "windows") {
[17:39:20.120]                 old_names <- names(...future.oldEnvVars)
[17:39:20.120]                 envs <- base::Sys.getenv()
[17:39:20.120]                 names <- names(envs)
[17:39:20.120]                 common <- intersect(names, old_names)
[17:39:20.120]                 added <- setdiff(names, old_names)
[17:39:20.120]                 removed <- setdiff(old_names, names)
[17:39:20.120]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.120]                   envs[common]]
[17:39:20.120]                 NAMES <- toupper(changed)
[17:39:20.120]                 args <- list()
[17:39:20.120]                 for (kk in seq_along(NAMES)) {
[17:39:20.120]                   name <- changed[[kk]]
[17:39:20.120]                   NAME <- NAMES[[kk]]
[17:39:20.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.120]                     next
[17:39:20.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.120]                 }
[17:39:20.120]                 NAMES <- toupper(added)
[17:39:20.120]                 for (kk in seq_along(NAMES)) {
[17:39:20.120]                   name <- added[[kk]]
[17:39:20.120]                   NAME <- NAMES[[kk]]
[17:39:20.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.120]                     next
[17:39:20.120]                   args[[name]] <- ""
[17:39:20.120]                 }
[17:39:20.120]                 NAMES <- toupper(removed)
[17:39:20.120]                 for (kk in seq_along(NAMES)) {
[17:39:20.120]                   name <- removed[[kk]]
[17:39:20.120]                   NAME <- NAMES[[kk]]
[17:39:20.120]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.120]                     next
[17:39:20.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.120]                 }
[17:39:20.120]                 if (length(args) > 0) 
[17:39:20.120]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.120]             }
[17:39:20.120]             else {
[17:39:20.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.120]             }
[17:39:20.120]             {
[17:39:20.120]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.120]                   0L) {
[17:39:20.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.120]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.120]                   base::options(opts)
[17:39:20.120]                 }
[17:39:20.120]                 {
[17:39:20.120]                   {
[17:39:20.120]                     NULL
[17:39:20.120]                     RNGkind("Mersenne-Twister")
[17:39:20.120]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:20.120]                       inherits = FALSE)
[17:39:20.120]                   }
[17:39:20.120]                   options(future.plan = NULL)
[17:39:20.120]                   if (is.na(NA_character_)) 
[17:39:20.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.120]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.120]                   {
[17:39:20.120]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.120]                     if (!future$lazy) 
[17:39:20.120]                       future <- run(future)
[17:39:20.120]                     invisible(future)
[17:39:20.120]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.120]                 }
[17:39:20.120]             }
[17:39:20.120]         }
[17:39:20.120]     })
[17:39:20.120]     if (TRUE) {
[17:39:20.120]         base::sink(type = "output", split = FALSE)
[17:39:20.120]         if (TRUE) {
[17:39:20.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.120]         }
[17:39:20.120]         else {
[17:39:20.120]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.120]         }
[17:39:20.120]         base::close(...future.stdout)
[17:39:20.120]         ...future.stdout <- NULL
[17:39:20.120]     }
[17:39:20.120]     ...future.result$conditions <- ...future.conditions
[17:39:20.120]     ...future.result$finished <- base::Sys.time()
[17:39:20.120]     ...future.result
[17:39:20.120] }
[17:39:20.122] assign_globals() ...
[17:39:20.122] List of 5
[17:39:20.122]  $ future.call.arguments    : list()
[17:39:20.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.122]  $ ...future.FUN            :function (x)  
[17:39:20.122]  $ ...future.elements_ii    :List of 2
[17:39:20.122]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:39:20.122]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:39:20.122]  $ ...future.seeds_ii       : NULL
[17:39:20.122]  $ ...future.globals.maxSize: num Inf
[17:39:20.122]  - attr(*, "resolved")= logi FALSE
[17:39:20.122]  - attr(*, "total_size")= num NA
[17:39:20.122]  - attr(*, "where")=List of 5
[17:39:20.122]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.122]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.122]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.122]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.122]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.122]  - attr(*, "already-done")= logi TRUE
[17:39:20.127] - copied ‘future.call.arguments’ to environment
[17:39:20.127] - copied ‘...future.FUN’ to environment
[17:39:20.127] - copied ‘...future.elements_ii’ to environment
[17:39:20.127] - copied ‘...future.seeds_ii’ to environment
[17:39:20.127] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.127] assign_globals() ... done
[17:39:20.127] plan(): Setting new future strategy stack:
[17:39:20.128] List of future strategies:
[17:39:20.128] 1. sequential:
[17:39:20.128]    - args: function (..., envir = parent.frame())
[17:39:20.128]    - tweaked: FALSE
[17:39:20.128]    - call: NULL
[17:39:20.128] plan(): nbrOfWorkers() = 1
[17:39:20.129] plan(): Setting new future strategy stack:
[17:39:20.129] List of future strategies:
[17:39:20.129] 1. sequential:
[17:39:20.129]    - args: function (..., envir = parent.frame())
[17:39:20.129]    - tweaked: FALSE
[17:39:20.129]    - call: plan(strategy)
[17:39:20.129] plan(): nbrOfWorkers() = 1
[17:39:20.129] SequentialFuture started (and completed)
[17:39:20.129] - Launch lazy future ... done
[17:39:20.129] run() for ‘SequentialFuture’ ... done
[17:39:20.130] Created future:
[17:39:20.130] SequentialFuture:
[17:39:20.130] Label: ‘future_apply-1’
[17:39:20.130] Expression:
[17:39:20.130] {
[17:39:20.130]     do.call(function(...) {
[17:39:20.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.130]             on.exit(options(oopts), add = TRUE)
[17:39:20.130]         }
[17:39:20.130]         {
[17:39:20.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.130]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.130]             })
[17:39:20.130]         }
[17:39:20.130]     }, args = future.call.arguments)
[17:39:20.130] }
[17:39:20.130] Lazy evaluation: FALSE
[17:39:20.130] Asynchronous evaluation: FALSE
[17:39:20.130] Local evaluation: TRUE
[17:39:20.130] Environment: R_GlobalEnv
[17:39:20.130] Capture standard output: TRUE
[17:39:20.130] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.130] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.130] Packages: <none>
[17:39:20.130] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.130] Resolved: TRUE
[17:39:20.130] Value: 224 bytes of class ‘list’
[17:39:20.130] Early signaling: FALSE
[17:39:20.130] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.130] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.131] Chunk #1 of 1 ... DONE
[17:39:20.131] Launching 1 futures (chunks) ... DONE
[17:39:20.131] Resolving 1 futures (chunks) ...
[17:39:20.131] resolve() on list ...
[17:39:20.131]  recursive: 0
[17:39:20.131]  length: 1
[17:39:20.131] 
[17:39:20.131] resolved() for ‘SequentialFuture’ ...
[17:39:20.131] - state: ‘finished’
[17:39:20.132] - run: TRUE
[17:39:20.132] - result: ‘FutureResult’
[17:39:20.132] resolved() for ‘SequentialFuture’ ... done
[17:39:20.132] Future #1
[17:39:20.132] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.132] - nx: 1
[17:39:20.132] - relay: TRUE
[17:39:20.132] - stdout: TRUE
[17:39:20.132] - signal: TRUE
[17:39:20.132] - resignal: FALSE
[17:39:20.132] - force: TRUE
[17:39:20.133] - relayed: [n=1] FALSE
[17:39:20.133] - queued futures: [n=1] FALSE
[17:39:20.133]  - until=1
[17:39:20.133]  - relaying element #1
[17:39:20.133] - relayed: [n=1] TRUE
[17:39:20.133] - queued futures: [n=1] TRUE
[17:39:20.133] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.133]  length: 0 (resolved future 1)
[17:39:20.135] Relaying remaining futures
[17:39:20.135] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.135] - nx: 1
[17:39:20.135] - relay: TRUE
[17:39:20.135] - stdout: TRUE
[17:39:20.135] - signal: TRUE
[17:39:20.135] - resignal: FALSE
[17:39:20.135] - force: TRUE
[17:39:20.135] - relayed: [n=1] TRUE
[17:39:20.136] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.136] - relayed: [n=1] TRUE
[17:39:20.136] - queued futures: [n=1] TRUE
[17:39:20.136] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.136] resolve() on list ... DONE
[17:39:20.136]  - Number of value chunks collected: 1
[17:39:20.136] Resolving 1 futures (chunks) ... DONE
[17:39:20.136] Reducing values from 1 chunks ...
[17:39:20.136]  - Number of values collected after concatenation: 2
[17:39:20.136]  - Number of values expected: 2
[17:39:20.137] Reducing values from 1 chunks ... DONE
[17:39:20.137] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:39:20.137] getGlobalsAndPackagesXApply() ...
[17:39:20.137]  - future.globals: TRUE
[17:39:20.137] getGlobalsAndPackages() ...
[17:39:20.137] Searching for globals...
[17:39:20.138] - globals found: [1] ‘FUN’
[17:39:20.138] Searching for globals ... DONE
[17:39:20.139] Resolving globals: FALSE
[17:39:20.139] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:20.139] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:20.139] - globals: [1] ‘FUN’
[17:39:20.139] 
[17:39:20.140] getGlobalsAndPackages() ... DONE
[17:39:20.140]  - globals found/used: [n=1] ‘FUN’
[17:39:20.140]  - needed namespaces: [n=0] 
[17:39:20.140] Finding globals ... DONE
[17:39:20.140]  - use_args: TRUE
[17:39:20.140]  - Getting '...' globals ...
[17:39:20.140] resolve() on list ...
[17:39:20.140]  recursive: 0
[17:39:20.141]  length: 1
[17:39:20.141]  elements: ‘...’
[17:39:20.141]  length: 0 (resolved future 1)
[17:39:20.141] resolve() on list ... DONE
[17:39:20.141]    - '...' content: [n=0] 
[17:39:20.141] List of 1
[17:39:20.141]  $ ...: list()
[17:39:20.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.141]  - attr(*, "where")=List of 1
[17:39:20.141]   ..$ ...:<environment: 0x55c795793f60> 
[17:39:20.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.141]  - attr(*, "resolved")= logi TRUE
[17:39:20.141]  - attr(*, "total_size")= num NA
[17:39:20.144]  - Getting '...' globals ... DONE
[17:39:20.144] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.144] List of 2
[17:39:20.144]  $ ...future.FUN:function (x)  
[17:39:20.144]  $ ...          : list()
[17:39:20.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.144]  - attr(*, "where")=List of 2
[17:39:20.144]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.144]   ..$ ...          :<environment: 0x55c795793f60> 
[17:39:20.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.144]  - attr(*, "resolved")= logi FALSE
[17:39:20.144]  - attr(*, "total_size")= num 848
[17:39:20.147] Packages to be attached in all futures: [n=0] 
[17:39:20.147] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.147] future_lapply() ...
[17:39:20.147] Number of chunks: 1
[17:39:20.148] getGlobalsAndPackagesXApply() ...
[17:39:20.148]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.148]  - use_args: TRUE
[17:39:20.148] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.148] List of 2
[17:39:20.148]  $ ...          : list()
[17:39:20.148]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.148]  $ ...future.FUN:function (x)  
[17:39:20.148]  - attr(*, "where")=List of 2
[17:39:20.148]   ..$ ...          :<environment: 0x55c795793f60> 
[17:39:20.148]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.148]  - attr(*, "resolved")= logi FALSE
[17:39:20.148]  - attr(*, "total_size")= num NA
[17:39:20.151] Packages to be attached in all futures: [n=0] 
[17:39:20.151] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.152] Number of futures (= number of chunks): 1
[17:39:20.152] Launching 1 futures (chunks) ...
[17:39:20.152] Chunk #1 of 1 ...
[17:39:20.152]  - Adjusted option 'future.globals.maxSize': Inf -> 6 * Inf = Inf (bytes)
[17:39:20.152]  - seeds: <none>
[17:39:20.152] getGlobalsAndPackages() ...
[17:39:20.152] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.152] Resolving globals: FALSE
[17:39:20.153] Tweak future expression to call with '...' arguments ...
[17:39:20.153] {
[17:39:20.153]     do.call(function(...) {
[17:39:20.153]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.153]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.153]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.153]             on.exit(options(oopts), add = TRUE)
[17:39:20.153]         }
[17:39:20.153]         {
[17:39:20.153]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.153]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.153]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.153]             })
[17:39:20.153]         }
[17:39:20.153]     }, args = future.call.arguments)
[17:39:20.153] }
[17:39:20.153] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.153] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.153] 
[17:39:20.153] getGlobalsAndPackages() ... DONE
[17:39:20.154] run() for ‘Future’ ...
[17:39:20.154] - state: ‘created’
[17:39:20.154] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.154] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.154] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.154]   - Field: ‘label’
[17:39:20.155]   - Field: ‘local’
[17:39:20.155]   - Field: ‘owner’
[17:39:20.155]   - Field: ‘envir’
[17:39:20.155]   - Field: ‘packages’
[17:39:20.155]   - Field: ‘gc’
[17:39:20.155]   - Field: ‘conditions’
[17:39:20.155]   - Field: ‘expr’
[17:39:20.155]   - Field: ‘uuid’
[17:39:20.155]   - Field: ‘seed’
[17:39:20.155]   - Field: ‘version’
[17:39:20.156]   - Field: ‘result’
[17:39:20.156]   - Field: ‘asynchronous’
[17:39:20.156]   - Field: ‘calls’
[17:39:20.156]   - Field: ‘globals’
[17:39:20.156]   - Field: ‘stdout’
[17:39:20.158]   - Field: ‘earlySignal’
[17:39:20.158]   - Field: ‘lazy’
[17:39:20.158]   - Field: ‘state’
[17:39:20.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.158] - Launch lazy future ...
[17:39:20.159] Packages needed by the future expression (n = 0): <none>
[17:39:20.159] Packages needed by future strategies (n = 0): <none>
[17:39:20.159] {
[17:39:20.159]     {
[17:39:20.159]         {
[17:39:20.159]             ...future.startTime <- base::Sys.time()
[17:39:20.159]             {
[17:39:20.159]                 {
[17:39:20.159]                   {
[17:39:20.159]                     base::local({
[17:39:20.159]                       has_future <- base::requireNamespace("future", 
[17:39:20.159]                         quietly = TRUE)
[17:39:20.159]                       if (has_future) {
[17:39:20.159]                         ns <- base::getNamespace("future")
[17:39:20.159]                         version <- ns[[".package"]][["version"]]
[17:39:20.159]                         if (is.null(version)) 
[17:39:20.159]                           version <- utils::packageVersion("future")
[17:39:20.159]                       }
[17:39:20.159]                       else {
[17:39:20.159]                         version <- NULL
[17:39:20.159]                       }
[17:39:20.159]                       if (!has_future || version < "1.8.0") {
[17:39:20.159]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.159]                           "", base::R.version$version.string), 
[17:39:20.159]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:20.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.159]                             "release", "version")], collapse = " "), 
[17:39:20.159]                           hostname = base::Sys.info()[["nodename"]])
[17:39:20.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.159]                           info)
[17:39:20.159]                         info <- base::paste(info, collapse = "; ")
[17:39:20.159]                         if (!has_future) {
[17:39:20.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.159]                             info)
[17:39:20.159]                         }
[17:39:20.159]                         else {
[17:39:20.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.159]                             info, version)
[17:39:20.159]                         }
[17:39:20.159]                         base::stop(msg)
[17:39:20.159]                       }
[17:39:20.159]                     })
[17:39:20.159]                   }
[17:39:20.159]                   options(future.plan = NULL)
[17:39:20.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.159]                 }
[17:39:20.159]                 ...future.workdir <- getwd()
[17:39:20.159]             }
[17:39:20.159]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.159]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.159]         }
[17:39:20.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.159]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.159]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.159]             base::names(...future.oldOptions))
[17:39:20.159]     }
[17:39:20.159]     if (FALSE) {
[17:39:20.159]     }
[17:39:20.159]     else {
[17:39:20.159]         if (TRUE) {
[17:39:20.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.159]                 open = "w")
[17:39:20.159]         }
[17:39:20.159]         else {
[17:39:20.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.159]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.159]         }
[17:39:20.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.159]             base::sink(type = "output", split = FALSE)
[17:39:20.159]             base::close(...future.stdout)
[17:39:20.159]         }, add = TRUE)
[17:39:20.159]     }
[17:39:20.159]     ...future.frame <- base::sys.nframe()
[17:39:20.159]     ...future.conditions <- base::list()
[17:39:20.159]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.159]     if (FALSE) {
[17:39:20.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.159]     }
[17:39:20.159]     ...future.result <- base::tryCatch({
[17:39:20.159]         base::withCallingHandlers({
[17:39:20.159]             ...future.value <- base::withVisible(base::local({
[17:39:20.159]                 do.call(function(...) {
[17:39:20.159]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.159]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.159]                     ...future.globals.maxSize)) {
[17:39:20.159]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.159]                     on.exit(options(oopts), add = TRUE)
[17:39:20.159]                   }
[17:39:20.159]                   {
[17:39:20.159]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.159]                       FUN = function(jj) {
[17:39:20.159]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.159]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.159]                       })
[17:39:20.159]                   }
[17:39:20.159]                 }, args = future.call.arguments)
[17:39:20.159]             }))
[17:39:20.159]             future::FutureResult(value = ...future.value$value, 
[17:39:20.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.159]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.159]                     ...future.globalenv.names))
[17:39:20.159]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.159]         }, condition = base::local({
[17:39:20.159]             c <- base::c
[17:39:20.159]             inherits <- base::inherits
[17:39:20.159]             invokeRestart <- base::invokeRestart
[17:39:20.159]             length <- base::length
[17:39:20.159]             list <- base::list
[17:39:20.159]             seq.int <- base::seq.int
[17:39:20.159]             signalCondition <- base::signalCondition
[17:39:20.159]             sys.calls <- base::sys.calls
[17:39:20.159]             `[[` <- base::`[[`
[17:39:20.159]             `+` <- base::`+`
[17:39:20.159]             `<<-` <- base::`<<-`
[17:39:20.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.159]                   3L)]
[17:39:20.159]             }
[17:39:20.159]             function(cond) {
[17:39:20.159]                 is_error <- inherits(cond, "error")
[17:39:20.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.159]                   NULL)
[17:39:20.159]                 if (is_error) {
[17:39:20.159]                   sessionInformation <- function() {
[17:39:20.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.159]                       search = base::search(), system = base::Sys.info())
[17:39:20.159]                   }
[17:39:20.159]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.159]                     cond$call), session = sessionInformation(), 
[17:39:20.159]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.159]                   signalCondition(cond)
[17:39:20.159]                 }
[17:39:20.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.159]                 "immediateCondition"))) {
[17:39:20.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.159]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.159]                   if (TRUE && !signal) {
[17:39:20.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.159]                     {
[17:39:20.159]                       inherits <- base::inherits
[17:39:20.159]                       invokeRestart <- base::invokeRestart
[17:39:20.159]                       is.null <- base::is.null
[17:39:20.159]                       muffled <- FALSE
[17:39:20.159]                       if (inherits(cond, "message")) {
[17:39:20.159]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.159]                         if (muffled) 
[17:39:20.159]                           invokeRestart("muffleMessage")
[17:39:20.159]                       }
[17:39:20.159]                       else if (inherits(cond, "warning")) {
[17:39:20.159]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.159]                         if (muffled) 
[17:39:20.159]                           invokeRestart("muffleWarning")
[17:39:20.159]                       }
[17:39:20.159]                       else if (inherits(cond, "condition")) {
[17:39:20.159]                         if (!is.null(pattern)) {
[17:39:20.159]                           computeRestarts <- base::computeRestarts
[17:39:20.159]                           grepl <- base::grepl
[17:39:20.159]                           restarts <- computeRestarts(cond)
[17:39:20.159]                           for (restart in restarts) {
[17:39:20.159]                             name <- restart$name
[17:39:20.159]                             if (is.null(name)) 
[17:39:20.159]                               next
[17:39:20.159]                             if (!grepl(pattern, name)) 
[17:39:20.159]                               next
[17:39:20.159]                             invokeRestart(restart)
[17:39:20.159]                             muffled <- TRUE
[17:39:20.159]                             break
[17:39:20.159]                           }
[17:39:20.159]                         }
[17:39:20.159]                       }
[17:39:20.159]                       invisible(muffled)
[17:39:20.159]                     }
[17:39:20.159]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.159]                   }
[17:39:20.159]                 }
[17:39:20.159]                 else {
[17:39:20.159]                   if (TRUE) {
[17:39:20.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.159]                     {
[17:39:20.159]                       inherits <- base::inherits
[17:39:20.159]                       invokeRestart <- base::invokeRestart
[17:39:20.159]                       is.null <- base::is.null
[17:39:20.159]                       muffled <- FALSE
[17:39:20.159]                       if (inherits(cond, "message")) {
[17:39:20.159]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.159]                         if (muffled) 
[17:39:20.159]                           invokeRestart("muffleMessage")
[17:39:20.159]                       }
[17:39:20.159]                       else if (inherits(cond, "warning")) {
[17:39:20.159]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.159]                         if (muffled) 
[17:39:20.159]                           invokeRestart("muffleWarning")
[17:39:20.159]                       }
[17:39:20.159]                       else if (inherits(cond, "condition")) {
[17:39:20.159]                         if (!is.null(pattern)) {
[17:39:20.159]                           computeRestarts <- base::computeRestarts
[17:39:20.159]                           grepl <- base::grepl
[17:39:20.159]                           restarts <- computeRestarts(cond)
[17:39:20.159]                           for (restart in restarts) {
[17:39:20.159]                             name <- restart$name
[17:39:20.159]                             if (is.null(name)) 
[17:39:20.159]                               next
[17:39:20.159]                             if (!grepl(pattern, name)) 
[17:39:20.159]                               next
[17:39:20.159]                             invokeRestart(restart)
[17:39:20.159]                             muffled <- TRUE
[17:39:20.159]                             break
[17:39:20.159]                           }
[17:39:20.159]                         }
[17:39:20.159]                       }
[17:39:20.159]                       invisible(muffled)
[17:39:20.159]                     }
[17:39:20.159]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.159]                   }
[17:39:20.159]                 }
[17:39:20.159]             }
[17:39:20.159]         }))
[17:39:20.159]     }, error = function(ex) {
[17:39:20.159]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.159]                 ...future.rng), started = ...future.startTime, 
[17:39:20.159]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.159]             version = "1.8"), class = "FutureResult")
[17:39:20.159]     }, finally = {
[17:39:20.159]         if (!identical(...future.workdir, getwd())) 
[17:39:20.159]             setwd(...future.workdir)
[17:39:20.159]         {
[17:39:20.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.159]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.159]             }
[17:39:20.159]             base::options(...future.oldOptions)
[17:39:20.159]             if (.Platform$OS.type == "windows") {
[17:39:20.159]                 old_names <- names(...future.oldEnvVars)
[17:39:20.159]                 envs <- base::Sys.getenv()
[17:39:20.159]                 names <- names(envs)
[17:39:20.159]                 common <- intersect(names, old_names)
[17:39:20.159]                 added <- setdiff(names, old_names)
[17:39:20.159]                 removed <- setdiff(old_names, names)
[17:39:20.159]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.159]                   envs[common]]
[17:39:20.159]                 NAMES <- toupper(changed)
[17:39:20.159]                 args <- list()
[17:39:20.159]                 for (kk in seq_along(NAMES)) {
[17:39:20.159]                   name <- changed[[kk]]
[17:39:20.159]                   NAME <- NAMES[[kk]]
[17:39:20.159]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.159]                     next
[17:39:20.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.159]                 }
[17:39:20.159]                 NAMES <- toupper(added)
[17:39:20.159]                 for (kk in seq_along(NAMES)) {
[17:39:20.159]                   name <- added[[kk]]
[17:39:20.159]                   NAME <- NAMES[[kk]]
[17:39:20.159]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.159]                     next
[17:39:20.159]                   args[[name]] <- ""
[17:39:20.159]                 }
[17:39:20.159]                 NAMES <- toupper(removed)
[17:39:20.159]                 for (kk in seq_along(NAMES)) {
[17:39:20.159]                   name <- removed[[kk]]
[17:39:20.159]                   NAME <- NAMES[[kk]]
[17:39:20.159]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.159]                     next
[17:39:20.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.159]                 }
[17:39:20.159]                 if (length(args) > 0) 
[17:39:20.159]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.159]             }
[17:39:20.159]             else {
[17:39:20.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.159]             }
[17:39:20.159]             {
[17:39:20.159]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.159]                   0L) {
[17:39:20.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.159]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.159]                   base::options(opts)
[17:39:20.159]                 }
[17:39:20.159]                 {
[17:39:20.159]                   {
[17:39:20.159]                     NULL
[17:39:20.159]                     RNGkind("Mersenne-Twister")
[17:39:20.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:20.159]                       inherits = FALSE)
[17:39:20.159]                   }
[17:39:20.159]                   options(future.plan = NULL)
[17:39:20.159]                   if (is.na(NA_character_)) 
[17:39:20.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.159]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.159]                   {
[17:39:20.159]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.159]                     if (!future$lazy) 
[17:39:20.159]                       future <- run(future)
[17:39:20.159]                     invisible(future)
[17:39:20.159]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.159]                 }
[17:39:20.159]             }
[17:39:20.159]         }
[17:39:20.159]     })
[17:39:20.159]     if (TRUE) {
[17:39:20.159]         base::sink(type = "output", split = FALSE)
[17:39:20.159]         if (TRUE) {
[17:39:20.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.159]         }
[17:39:20.159]         else {
[17:39:20.159]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.159]         }
[17:39:20.159]         base::close(...future.stdout)
[17:39:20.159]         ...future.stdout <- NULL
[17:39:20.159]     }
[17:39:20.159]     ...future.result$conditions <- ...future.conditions
[17:39:20.159]     ...future.result$finished <- base::Sys.time()
[17:39:20.159]     ...future.result
[17:39:20.159] }
[17:39:20.161] assign_globals() ...
[17:39:20.161] List of 5
[17:39:20.161]  $ future.call.arguments    : list()
[17:39:20.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.161]  $ ...future.FUN            :function (x)  
[17:39:20.161]  $ ...future.elements_ii    :List of 6
[17:39:20.161]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:39:20.161]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:39:20.161]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:39:20.161]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:39:20.161]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:39:20.161]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:39:20.161]  $ ...future.seeds_ii       : NULL
[17:39:20.161]  $ ...future.globals.maxSize: num Inf
[17:39:20.161]  - attr(*, "resolved")= logi FALSE
[17:39:20.161]  - attr(*, "total_size")= num NA
[17:39:20.161]  - attr(*, "where")=List of 5
[17:39:20.161]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.161]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.161]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.161]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.161]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.161]  - attr(*, "already-done")= logi TRUE
[17:39:20.169] - copied ‘future.call.arguments’ to environment
[17:39:20.169] - copied ‘...future.FUN’ to environment
[17:39:20.169] - copied ‘...future.elements_ii’ to environment
[17:39:20.170] - copied ‘...future.seeds_ii’ to environment
[17:39:20.170] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.170] assign_globals() ... done
[17:39:20.170] plan(): Setting new future strategy stack:
[17:39:20.170] List of future strategies:
[17:39:20.170] 1. sequential:
[17:39:20.170]    - args: function (..., envir = parent.frame())
[17:39:20.170]    - tweaked: FALSE
[17:39:20.170]    - call: NULL
[17:39:20.171] plan(): nbrOfWorkers() = 1
[17:39:20.172] plan(): Setting new future strategy stack:
[17:39:20.172] List of future strategies:
[17:39:20.172] 1. sequential:
[17:39:20.172]    - args: function (..., envir = parent.frame())
[17:39:20.172]    - tweaked: FALSE
[17:39:20.172]    - call: plan(strategy)
[17:39:20.172] plan(): nbrOfWorkers() = 1
[17:39:20.172] SequentialFuture started (and completed)
[17:39:20.173] - Launch lazy future ... done
[17:39:20.173] run() for ‘SequentialFuture’ ... done
[17:39:20.173] Created future:
[17:39:20.173] SequentialFuture:
[17:39:20.173] Label: ‘future_apply-1’
[17:39:20.173] Expression:
[17:39:20.173] {
[17:39:20.173]     do.call(function(...) {
[17:39:20.173]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.173]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.173]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.173]             on.exit(options(oopts), add = TRUE)
[17:39:20.173]         }
[17:39:20.173]         {
[17:39:20.173]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.173]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.173]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.173]             })
[17:39:20.173]         }
[17:39:20.173]     }, args = future.call.arguments)
[17:39:20.173] }
[17:39:20.173] Lazy evaluation: FALSE
[17:39:20.173] Asynchronous evaluation: FALSE
[17:39:20.173] Local evaluation: TRUE
[17:39:20.173] Environment: R_GlobalEnv
[17:39:20.173] Capture standard output: TRUE
[17:39:20.173] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.173] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.173] Packages: <none>
[17:39:20.173] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.173] Resolved: TRUE
[17:39:20.173] Value: 672 bytes of class ‘list’
[17:39:20.173] Early signaling: FALSE
[17:39:20.173] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.173] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.174] Chunk #1 of 1 ... DONE
[17:39:20.174] Launching 1 futures (chunks) ... DONE
[17:39:20.174] Resolving 1 futures (chunks) ...
[17:39:20.175] resolve() on list ...
[17:39:20.175]  recursive: 0
[17:39:20.175]  length: 1
[17:39:20.175] 
[17:39:20.175] resolved() for ‘SequentialFuture’ ...
[17:39:20.175] - state: ‘finished’
[17:39:20.175] - run: TRUE
[17:39:20.175] - result: ‘FutureResult’
[17:39:20.175] resolved() for ‘SequentialFuture’ ... done
[17:39:20.176] Future #1
[17:39:20.176] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.176] - nx: 1
[17:39:20.176] - relay: TRUE
[17:39:20.176] - stdout: TRUE
[17:39:20.176] - signal: TRUE
[17:39:20.176] - resignal: FALSE
[17:39:20.176] - force: TRUE
[17:39:20.176] - relayed: [n=1] FALSE
[17:39:20.176] - queued futures: [n=1] FALSE
[17:39:20.177]  - until=1
[17:39:20.177]  - relaying element #1
[17:39:20.177] - relayed: [n=1] TRUE
[17:39:20.177] - queued futures: [n=1] TRUE
[17:39:20.177] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.177]  length: 0 (resolved future 1)
[17:39:20.177] Relaying remaining futures
[17:39:20.177] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.177] - nx: 1
[17:39:20.178] - relay: TRUE
[17:39:20.178] - stdout: TRUE
[17:39:20.178] - signal: TRUE
[17:39:20.178] - resignal: FALSE
[17:39:20.178] - force: TRUE
[17:39:20.178] - relayed: [n=1] TRUE
[17:39:20.178] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.178] - relayed: [n=1] TRUE
[17:39:20.178] - queued futures: [n=1] TRUE
[17:39:20.178] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.178] resolve() on list ... DONE
[17:39:20.179]  - Number of value chunks collected: 1
[17:39:20.179] Resolving 1 futures (chunks) ... DONE
[17:39:20.179] Reducing values from 1 chunks ...
[17:39:20.179]  - Number of values collected after concatenation: 6
[17:39:20.179]  - Number of values expected: 6
[17:39:20.179] Reducing values from 1 chunks ... DONE
[17:39:20.179] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:39:20.180] getGlobalsAndPackagesXApply() ...
[17:39:20.180]  - future.globals: TRUE
[17:39:20.180] getGlobalsAndPackages() ...
[17:39:20.180] Searching for globals...
[17:39:20.182] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:39:20.182] Searching for globals ... DONE
[17:39:20.182] Resolving globals: FALSE
[17:39:20.182] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:39:20.183] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:39:20.183] - globals: [1] ‘FUN’
[17:39:20.183] 
[17:39:20.183] getGlobalsAndPackages() ... DONE
[17:39:20.183]  - globals found/used: [n=1] ‘FUN’
[17:39:20.183]  - needed namespaces: [n=0] 
[17:39:20.183] Finding globals ... DONE
[17:39:20.183]  - use_args: TRUE
[17:39:20.183]  - Getting '...' globals ...
[17:39:20.186] resolve() on list ...
[17:39:20.186]  recursive: 0
[17:39:20.186]  length: 1
[17:39:20.186]  elements: ‘...’
[17:39:20.186]  length: 0 (resolved future 1)
[17:39:20.186] resolve() on list ... DONE
[17:39:20.186]    - '...' content: [n=0] 
[17:39:20.186] List of 1
[17:39:20.186]  $ ...: list()
[17:39:20.186]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.186]  - attr(*, "where")=List of 1
[17:39:20.186]   ..$ ...:<environment: 0x55c796eeb348> 
[17:39:20.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.186]  - attr(*, "resolved")= logi TRUE
[17:39:20.186]  - attr(*, "total_size")= num NA
[17:39:20.189]  - Getting '...' globals ... DONE
[17:39:20.189] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.189] List of 2
[17:39:20.189]  $ ...future.FUN:function (x)  
[17:39:20.189]  $ ...          : list()
[17:39:20.189]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.189]  - attr(*, "where")=List of 2
[17:39:20.189]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.189]   ..$ ...          :<environment: 0x55c796eeb348> 
[17:39:20.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.189]  - attr(*, "resolved")= logi FALSE
[17:39:20.189]  - attr(*, "total_size")= num 1768
[17:39:20.192] Packages to be attached in all futures: [n=0] 
[17:39:20.192] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.192] future_lapply() ...
[17:39:20.193] Number of chunks: 1
[17:39:20.193] getGlobalsAndPackagesXApply() ...
[17:39:20.193]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.193]  - use_args: TRUE
[17:39:20.194] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.194] List of 2
[17:39:20.194]  $ ...          : list()
[17:39:20.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.194]  $ ...future.FUN:function (x)  
[17:39:20.194]  - attr(*, "where")=List of 2
[17:39:20.194]   ..$ ...          :<environment: 0x55c796eeb348> 
[17:39:20.194]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:39:20.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.194]  - attr(*, "resolved")= logi FALSE
[17:39:20.194]  - attr(*, "total_size")= num NA
[17:39:20.196] Packages to be attached in all futures: [n=0] 
[17:39:20.196] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.197] Number of futures (= number of chunks): 1
[17:39:20.197] Launching 1 futures (chunks) ...
[17:39:20.197] Chunk #1 of 1 ...
[17:39:20.197]  - Adjusted option 'future.globals.maxSize': Inf -> 6 * Inf = Inf (bytes)
[17:39:20.197]  - seeds: <none>
[17:39:20.197] getGlobalsAndPackages() ...
[17:39:20.197] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.197] Resolving globals: FALSE
[17:39:20.198] Tweak future expression to call with '...' arguments ...
[17:39:20.198] {
[17:39:20.198]     do.call(function(...) {
[17:39:20.198]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.198]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.198]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.198]             on.exit(options(oopts), add = TRUE)
[17:39:20.198]         }
[17:39:20.198]         {
[17:39:20.198]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.198]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.198]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.198]             })
[17:39:20.198]         }
[17:39:20.198]     }, args = future.call.arguments)
[17:39:20.198] }
[17:39:20.198] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.198] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.198] 
[17:39:20.198] getGlobalsAndPackages() ... DONE
[17:39:20.199] run() for ‘Future’ ...
[17:39:20.199] - state: ‘created’
[17:39:20.199] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.199] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.199] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.200]   - Field: ‘label’
[17:39:20.200]   - Field: ‘local’
[17:39:20.200]   - Field: ‘owner’
[17:39:20.200]   - Field: ‘envir’
[17:39:20.200]   - Field: ‘packages’
[17:39:20.200]   - Field: ‘gc’
[17:39:20.200]   - Field: ‘conditions’
[17:39:20.200]   - Field: ‘expr’
[17:39:20.200]   - Field: ‘uuid’
[17:39:20.200]   - Field: ‘seed’
[17:39:20.201]   - Field: ‘version’
[17:39:20.201]   - Field: ‘result’
[17:39:20.201]   - Field: ‘asynchronous’
[17:39:20.201]   - Field: ‘calls’
[17:39:20.201]   - Field: ‘globals’
[17:39:20.201]   - Field: ‘stdout’
[17:39:20.201]   - Field: ‘earlySignal’
[17:39:20.201]   - Field: ‘lazy’
[17:39:20.201]   - Field: ‘state’
[17:39:20.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.201] - Launch lazy future ...
[17:39:20.202] Packages needed by the future expression (n = 0): <none>
[17:39:20.202] Packages needed by future strategies (n = 0): <none>
[17:39:20.202] {
[17:39:20.202]     {
[17:39:20.202]         {
[17:39:20.202]             ...future.startTime <- base::Sys.time()
[17:39:20.202]             {
[17:39:20.202]                 {
[17:39:20.202]                   {
[17:39:20.202]                     base::local({
[17:39:20.202]                       has_future <- base::requireNamespace("future", 
[17:39:20.202]                         quietly = TRUE)
[17:39:20.202]                       if (has_future) {
[17:39:20.202]                         ns <- base::getNamespace("future")
[17:39:20.202]                         version <- ns[[".package"]][["version"]]
[17:39:20.202]                         if (is.null(version)) 
[17:39:20.202]                           version <- utils::packageVersion("future")
[17:39:20.202]                       }
[17:39:20.202]                       else {
[17:39:20.202]                         version <- NULL
[17:39:20.202]                       }
[17:39:20.202]                       if (!has_future || version < "1.8.0") {
[17:39:20.202]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.202]                           "", base::R.version$version.string), 
[17:39:20.202]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:20.202]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.202]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.202]                             "release", "version")], collapse = " "), 
[17:39:20.202]                           hostname = base::Sys.info()[["nodename"]])
[17:39:20.202]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.202]                           info)
[17:39:20.202]                         info <- base::paste(info, collapse = "; ")
[17:39:20.202]                         if (!has_future) {
[17:39:20.202]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.202]                             info)
[17:39:20.202]                         }
[17:39:20.202]                         else {
[17:39:20.202]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.202]                             info, version)
[17:39:20.202]                         }
[17:39:20.202]                         base::stop(msg)
[17:39:20.202]                       }
[17:39:20.202]                     })
[17:39:20.202]                   }
[17:39:20.202]                   options(future.plan = NULL)
[17:39:20.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.202]                 }
[17:39:20.202]                 ...future.workdir <- getwd()
[17:39:20.202]             }
[17:39:20.202]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.202]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.202]         }
[17:39:20.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.202]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.202]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.202]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.202]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.202]             base::names(...future.oldOptions))
[17:39:20.202]     }
[17:39:20.202]     if (FALSE) {
[17:39:20.202]     }
[17:39:20.202]     else {
[17:39:20.202]         if (TRUE) {
[17:39:20.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.202]                 open = "w")
[17:39:20.202]         }
[17:39:20.202]         else {
[17:39:20.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.202]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.202]         }
[17:39:20.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.202]             base::sink(type = "output", split = FALSE)
[17:39:20.202]             base::close(...future.stdout)
[17:39:20.202]         }, add = TRUE)
[17:39:20.202]     }
[17:39:20.202]     ...future.frame <- base::sys.nframe()
[17:39:20.202]     ...future.conditions <- base::list()
[17:39:20.202]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.202]     if (FALSE) {
[17:39:20.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.202]     }
[17:39:20.202]     ...future.result <- base::tryCatch({
[17:39:20.202]         base::withCallingHandlers({
[17:39:20.202]             ...future.value <- base::withVisible(base::local({
[17:39:20.202]                 do.call(function(...) {
[17:39:20.202]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.202]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.202]                     ...future.globals.maxSize)) {
[17:39:20.202]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.202]                     on.exit(options(oopts), add = TRUE)
[17:39:20.202]                   }
[17:39:20.202]                   {
[17:39:20.202]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.202]                       FUN = function(jj) {
[17:39:20.202]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.202]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.202]                       })
[17:39:20.202]                   }
[17:39:20.202]                 }, args = future.call.arguments)
[17:39:20.202]             }))
[17:39:20.202]             future::FutureResult(value = ...future.value$value, 
[17:39:20.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.202]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.202]                     ...future.globalenv.names))
[17:39:20.202]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.202]         }, condition = base::local({
[17:39:20.202]             c <- base::c
[17:39:20.202]             inherits <- base::inherits
[17:39:20.202]             invokeRestart <- base::invokeRestart
[17:39:20.202]             length <- base::length
[17:39:20.202]             list <- base::list
[17:39:20.202]             seq.int <- base::seq.int
[17:39:20.202]             signalCondition <- base::signalCondition
[17:39:20.202]             sys.calls <- base::sys.calls
[17:39:20.202]             `[[` <- base::`[[`
[17:39:20.202]             `+` <- base::`+`
[17:39:20.202]             `<<-` <- base::`<<-`
[17:39:20.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.202]                   3L)]
[17:39:20.202]             }
[17:39:20.202]             function(cond) {
[17:39:20.202]                 is_error <- inherits(cond, "error")
[17:39:20.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.202]                   NULL)
[17:39:20.202]                 if (is_error) {
[17:39:20.202]                   sessionInformation <- function() {
[17:39:20.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.202]                       search = base::search(), system = base::Sys.info())
[17:39:20.202]                   }
[17:39:20.202]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.202]                     cond$call), session = sessionInformation(), 
[17:39:20.202]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.202]                   signalCondition(cond)
[17:39:20.202]                 }
[17:39:20.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.202]                 "immediateCondition"))) {
[17:39:20.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.202]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.202]                   if (TRUE && !signal) {
[17:39:20.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.202]                     {
[17:39:20.202]                       inherits <- base::inherits
[17:39:20.202]                       invokeRestart <- base::invokeRestart
[17:39:20.202]                       is.null <- base::is.null
[17:39:20.202]                       muffled <- FALSE
[17:39:20.202]                       if (inherits(cond, "message")) {
[17:39:20.202]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.202]                         if (muffled) 
[17:39:20.202]                           invokeRestart("muffleMessage")
[17:39:20.202]                       }
[17:39:20.202]                       else if (inherits(cond, "warning")) {
[17:39:20.202]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.202]                         if (muffled) 
[17:39:20.202]                           invokeRestart("muffleWarning")
[17:39:20.202]                       }
[17:39:20.202]                       else if (inherits(cond, "condition")) {
[17:39:20.202]                         if (!is.null(pattern)) {
[17:39:20.202]                           computeRestarts <- base::computeRestarts
[17:39:20.202]                           grepl <- base::grepl
[17:39:20.202]                           restarts <- computeRestarts(cond)
[17:39:20.202]                           for (restart in restarts) {
[17:39:20.202]                             name <- restart$name
[17:39:20.202]                             if (is.null(name)) 
[17:39:20.202]                               next
[17:39:20.202]                             if (!grepl(pattern, name)) 
[17:39:20.202]                               next
[17:39:20.202]                             invokeRestart(restart)
[17:39:20.202]                             muffled <- TRUE
[17:39:20.202]                             break
[17:39:20.202]                           }
[17:39:20.202]                         }
[17:39:20.202]                       }
[17:39:20.202]                       invisible(muffled)
[17:39:20.202]                     }
[17:39:20.202]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.202]                   }
[17:39:20.202]                 }
[17:39:20.202]                 else {
[17:39:20.202]                   if (TRUE) {
[17:39:20.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.202]                     {
[17:39:20.202]                       inherits <- base::inherits
[17:39:20.202]                       invokeRestart <- base::invokeRestart
[17:39:20.202]                       is.null <- base::is.null
[17:39:20.202]                       muffled <- FALSE
[17:39:20.202]                       if (inherits(cond, "message")) {
[17:39:20.202]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.202]                         if (muffled) 
[17:39:20.202]                           invokeRestart("muffleMessage")
[17:39:20.202]                       }
[17:39:20.202]                       else if (inherits(cond, "warning")) {
[17:39:20.202]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.202]                         if (muffled) 
[17:39:20.202]                           invokeRestart("muffleWarning")
[17:39:20.202]                       }
[17:39:20.202]                       else if (inherits(cond, "condition")) {
[17:39:20.202]                         if (!is.null(pattern)) {
[17:39:20.202]                           computeRestarts <- base::computeRestarts
[17:39:20.202]                           grepl <- base::grepl
[17:39:20.202]                           restarts <- computeRestarts(cond)
[17:39:20.202]                           for (restart in restarts) {
[17:39:20.202]                             name <- restart$name
[17:39:20.202]                             if (is.null(name)) 
[17:39:20.202]                               next
[17:39:20.202]                             if (!grepl(pattern, name)) 
[17:39:20.202]                               next
[17:39:20.202]                             invokeRestart(restart)
[17:39:20.202]                             muffled <- TRUE
[17:39:20.202]                             break
[17:39:20.202]                           }
[17:39:20.202]                         }
[17:39:20.202]                       }
[17:39:20.202]                       invisible(muffled)
[17:39:20.202]                     }
[17:39:20.202]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.202]                   }
[17:39:20.202]                 }
[17:39:20.202]             }
[17:39:20.202]         }))
[17:39:20.202]     }, error = function(ex) {
[17:39:20.202]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.202]                 ...future.rng), started = ...future.startTime, 
[17:39:20.202]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.202]             version = "1.8"), class = "FutureResult")
[17:39:20.202]     }, finally = {
[17:39:20.202]         if (!identical(...future.workdir, getwd())) 
[17:39:20.202]             setwd(...future.workdir)
[17:39:20.202]         {
[17:39:20.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.202]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.202]             }
[17:39:20.202]             base::options(...future.oldOptions)
[17:39:20.202]             if (.Platform$OS.type == "windows") {
[17:39:20.202]                 old_names <- names(...future.oldEnvVars)
[17:39:20.202]                 envs <- base::Sys.getenv()
[17:39:20.202]                 names <- names(envs)
[17:39:20.202]                 common <- intersect(names, old_names)
[17:39:20.202]                 added <- setdiff(names, old_names)
[17:39:20.202]                 removed <- setdiff(old_names, names)
[17:39:20.202]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.202]                   envs[common]]
[17:39:20.202]                 NAMES <- toupper(changed)
[17:39:20.202]                 args <- list()
[17:39:20.202]                 for (kk in seq_along(NAMES)) {
[17:39:20.202]                   name <- changed[[kk]]
[17:39:20.202]                   NAME <- NAMES[[kk]]
[17:39:20.202]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.202]                     next
[17:39:20.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.202]                 }
[17:39:20.202]                 NAMES <- toupper(added)
[17:39:20.202]                 for (kk in seq_along(NAMES)) {
[17:39:20.202]                   name <- added[[kk]]
[17:39:20.202]                   NAME <- NAMES[[kk]]
[17:39:20.202]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.202]                     next
[17:39:20.202]                   args[[name]] <- ""
[17:39:20.202]                 }
[17:39:20.202]                 NAMES <- toupper(removed)
[17:39:20.202]                 for (kk in seq_along(NAMES)) {
[17:39:20.202]                   name <- removed[[kk]]
[17:39:20.202]                   NAME <- NAMES[[kk]]
[17:39:20.202]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.202]                     next
[17:39:20.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.202]                 }
[17:39:20.202]                 if (length(args) > 0) 
[17:39:20.202]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.202]             }
[17:39:20.202]             else {
[17:39:20.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.202]             }
[17:39:20.202]             {
[17:39:20.202]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.202]                   0L) {
[17:39:20.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.202]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.202]                   base::options(opts)
[17:39:20.202]                 }
[17:39:20.202]                 {
[17:39:20.202]                   {
[17:39:20.202]                     NULL
[17:39:20.202]                     RNGkind("Mersenne-Twister")
[17:39:20.202]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:20.202]                       inherits = FALSE)
[17:39:20.202]                   }
[17:39:20.202]                   options(future.plan = NULL)
[17:39:20.202]                   if (is.na(NA_character_)) 
[17:39:20.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.202]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.202]                   {
[17:39:20.202]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.202]                     if (!future$lazy) 
[17:39:20.202]                       future <- run(future)
[17:39:20.202]                     invisible(future)
[17:39:20.202]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.202]                 }
[17:39:20.202]             }
[17:39:20.202]         }
[17:39:20.202]     })
[17:39:20.202]     if (TRUE) {
[17:39:20.202]         base::sink(type = "output", split = FALSE)
[17:39:20.202]         if (TRUE) {
[17:39:20.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.202]         }
[17:39:20.202]         else {
[17:39:20.202]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.202]         }
[17:39:20.202]         base::close(...future.stdout)
[17:39:20.202]         ...future.stdout <- NULL
[17:39:20.202]     }
[17:39:20.202]     ...future.result$conditions <- ...future.conditions
[17:39:20.202]     ...future.result$finished <- base::Sys.time()
[17:39:20.202]     ...future.result
[17:39:20.202] }
[17:39:20.204] assign_globals() ...
[17:39:20.204] List of 5
[17:39:20.204]  $ future.call.arguments    : list()
[17:39:20.204]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.204]  $ ...future.FUN            :function (x)  
[17:39:20.204]  $ ...future.elements_ii    :List of 6
[17:39:20.204]   ..$ : int [1:4] 1 7 13 19
[17:39:20.204]   ..$ : int [1:4] 2 8 14 20
[17:39:20.204]   ..$ : int [1:4] 3 9 15 21
[17:39:20.204]   ..$ : int [1:4] 4 10 16 22
[17:39:20.204]   ..$ : int [1:4] 5 11 17 23
[17:39:20.204]   ..$ : int [1:4] 6 12 18 24
[17:39:20.204]  $ ...future.seeds_ii       : NULL
[17:39:20.204]  $ ...future.globals.maxSize: num Inf
[17:39:20.204]  - attr(*, "resolved")= logi FALSE
[17:39:20.204]  - attr(*, "total_size")= num NA
[17:39:20.204]  - attr(*, "where")=List of 5
[17:39:20.204]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.204]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.204]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.204]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.204]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.204]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.204]  - attr(*, "already-done")= logi TRUE
[17:39:20.236] - copied ‘future.call.arguments’ to environment
[17:39:20.236] - reassign environment for ‘...future.FUN’
[17:39:20.236] - copied ‘...future.FUN’ to environment
[17:39:20.236] - copied ‘...future.elements_ii’ to environment
[17:39:20.236] - copied ‘...future.seeds_ii’ to environment
[17:39:20.236] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.236] assign_globals() ... done
[17:39:20.236] plan(): Setting new future strategy stack:
[17:39:20.237] List of future strategies:
[17:39:20.237] 1. sequential:
[17:39:20.237]    - args: function (..., envir = parent.frame())
[17:39:20.237]    - tweaked: FALSE
[17:39:20.237]    - call: NULL
[17:39:20.237] plan(): nbrOfWorkers() = 1
[17:39:20.238] plan(): Setting new future strategy stack:
[17:39:20.238] List of future strategies:
[17:39:20.238] 1. sequential:
[17:39:20.238]    - args: function (..., envir = parent.frame())
[17:39:20.238]    - tweaked: FALSE
[17:39:20.238]    - call: plan(strategy)
[17:39:20.238] plan(): nbrOfWorkers() = 1
[17:39:20.238] SequentialFuture started (and completed)
[17:39:20.239] - Launch lazy future ... done
[17:39:20.239] run() for ‘SequentialFuture’ ... done
[17:39:20.239] Created future:
[17:39:20.239] SequentialFuture:
[17:39:20.239] Label: ‘future_apply-1’
[17:39:20.239] Expression:
[17:39:20.239] {
[17:39:20.239]     do.call(function(...) {
[17:39:20.239]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.239]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.239]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.239]             on.exit(options(oopts), add = TRUE)
[17:39:20.239]         }
[17:39:20.239]         {
[17:39:20.239]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.239]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.239]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.239]             })
[17:39:20.239]         }
[17:39:20.239]     }, args = future.call.arguments)
[17:39:20.239] }
[17:39:20.239] Lazy evaluation: FALSE
[17:39:20.239] Asynchronous evaluation: FALSE
[17:39:20.239] Local evaluation: TRUE
[17:39:20.239] Environment: R_GlobalEnv
[17:39:20.239] Capture standard output: TRUE
[17:39:20.239] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.239] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.239] Packages: <none>
[17:39:20.239] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.239] Resolved: TRUE
[17:39:20.239] Value: 1.03 KiB of class ‘list’
[17:39:20.239] Early signaling: FALSE
[17:39:20.239] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.239] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.240] Chunk #1 of 1 ... DONE
[17:39:20.240] Launching 1 futures (chunks) ... DONE
[17:39:20.240] Resolving 1 futures (chunks) ...
[17:39:20.240] resolve() on list ...
[17:39:20.240]  recursive: 0
[17:39:20.240]  length: 1
[17:39:20.241] 
[17:39:20.241] resolved() for ‘SequentialFuture’ ...
[17:39:20.241] - state: ‘finished’
[17:39:20.241] - run: TRUE
[17:39:20.241] - result: ‘FutureResult’
[17:39:20.241] resolved() for ‘SequentialFuture’ ... done
[17:39:20.241] Future #1
[17:39:20.241] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.241] - nx: 1
[17:39:20.241] - relay: TRUE
[17:39:20.242] - stdout: TRUE
[17:39:20.242] - signal: TRUE
[17:39:20.242] - resignal: FALSE
[17:39:20.242] - force: TRUE
[17:39:20.242] - relayed: [n=1] FALSE
[17:39:20.242] - queued futures: [n=1] FALSE
[17:39:20.242]  - until=1
[17:39:20.242]  - relaying element #1
[17:39:20.242] - relayed: [n=1] TRUE
[17:39:20.242] - queued futures: [n=1] TRUE
[17:39:20.242] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.243]  length: 0 (resolved future 1)
[17:39:20.243] Relaying remaining futures
[17:39:20.243] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.243] - nx: 1
[17:39:20.243] - relay: TRUE
[17:39:20.243] - stdout: TRUE
[17:39:20.243] - signal: TRUE
[17:39:20.243] - resignal: FALSE
[17:39:20.243] - force: TRUE
[17:39:20.243] - relayed: [n=1] TRUE
[17:39:20.243] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.244] - relayed: [n=1] TRUE
[17:39:20.244] - queued futures: [n=1] TRUE
[17:39:20.244] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.244] resolve() on list ... DONE
[17:39:20.244]  - Number of value chunks collected: 1
[17:39:20.244] Resolving 1 futures (chunks) ... DONE
[17:39:20.244] Reducing values from 1 chunks ...
[17:39:20.244]  - Number of values collected after concatenation: 6
[17:39:20.244]  - Number of values expected: 6
[17:39:20.244] Reducing values from 1 chunks ... DONE
[17:39:20.245] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:39:20.245] getGlobalsAndPackagesXApply() ...
[17:39:20.245]  - future.globals: TRUE
[17:39:20.245] getGlobalsAndPackages() ...
[17:39:20.245] Searching for globals...
[17:39:20.246] - globals found: [1] ‘FUN’
[17:39:20.246] Searching for globals ... DONE
[17:39:20.246] Resolving globals: FALSE
[17:39:20.247] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:20.247] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:20.247] - globals: [1] ‘FUN’
[17:39:20.247] 
[17:39:20.247] getGlobalsAndPackages() ... DONE
[17:39:20.247]  - globals found/used: [n=1] ‘FUN’
[17:39:20.247]  - needed namespaces: [n=0] 
[17:39:20.248] Finding globals ... DONE
[17:39:20.248]  - use_args: TRUE
[17:39:20.248]  - Getting '...' globals ...
[17:39:20.248] resolve() on list ...
[17:39:20.248]  recursive: 0
[17:39:20.248]  length: 1
[17:39:20.248]  elements: ‘...’
[17:39:20.248]  length: 0 (resolved future 1)
[17:39:20.248] resolve() on list ... DONE
[17:39:20.249]    - '...' content: [n=0] 
[17:39:20.249] List of 1
[17:39:20.249]  $ ...: list()
[17:39:20.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.249]  - attr(*, "where")=List of 1
[17:39:20.249]   ..$ ...:<environment: 0x55c79674c4a0> 
[17:39:20.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.249]  - attr(*, "resolved")= logi TRUE
[17:39:20.249]  - attr(*, "total_size")= num NA
[17:39:20.251]  - Getting '...' globals ... DONE
[17:39:20.251] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.251] List of 2
[17:39:20.251]  $ ...future.FUN:function (x)  
[17:39:20.251]  $ ...          : list()
[17:39:20.251]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.251]  - attr(*, "where")=List of 2
[17:39:20.251]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.251]   ..$ ...          :<environment: 0x55c79674c4a0> 
[17:39:20.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.251]  - attr(*, "resolved")= logi FALSE
[17:39:20.251]  - attr(*, "total_size")= num 848
[17:39:20.254] Packages to be attached in all futures: [n=0] 
[17:39:20.254] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.254] future_lapply() ...
[17:39:20.256] Number of chunks: 1
[17:39:20.256] getGlobalsAndPackagesXApply() ...
[17:39:20.256]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.256]  - use_args: TRUE
[17:39:20.256] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.257] List of 2
[17:39:20.257]  $ ...          : list()
[17:39:20.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.257]  $ ...future.FUN:function (x)  
[17:39:20.257]  - attr(*, "where")=List of 2
[17:39:20.257]   ..$ ...          :<environment: 0x55c79674c4a0> 
[17:39:20.257]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.257]  - attr(*, "resolved")= logi FALSE
[17:39:20.257]  - attr(*, "total_size")= num NA
[17:39:20.260] Packages to be attached in all futures: [n=0] 
[17:39:20.260] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.260] Number of futures (= number of chunks): 1
[17:39:20.260] Launching 1 futures (chunks) ...
[17:39:20.260] Chunk #1 of 1 ...
[17:39:20.260]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:39:20.260]  - seeds: <none>
[17:39:20.261] getGlobalsAndPackages() ...
[17:39:20.261] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.261] Resolving globals: FALSE
[17:39:20.261] Tweak future expression to call with '...' arguments ...
[17:39:20.261] {
[17:39:20.261]     do.call(function(...) {
[17:39:20.261]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.261]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.261]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.261]             on.exit(options(oopts), add = TRUE)
[17:39:20.261]         }
[17:39:20.261]         {
[17:39:20.261]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.261]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.261]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.261]             })
[17:39:20.261]         }
[17:39:20.261]     }, args = future.call.arguments)
[17:39:20.261] }
[17:39:20.261] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.262] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.262] 
[17:39:20.262] getGlobalsAndPackages() ... DONE
[17:39:20.262] run() for ‘Future’ ...
[17:39:20.262] - state: ‘created’
[17:39:20.262] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.263] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.263]   - Field: ‘label’
[17:39:20.263]   - Field: ‘local’
[17:39:20.263]   - Field: ‘owner’
[17:39:20.263]   - Field: ‘envir’
[17:39:20.263]   - Field: ‘packages’
[17:39:20.263]   - Field: ‘gc’
[17:39:20.263]   - Field: ‘conditions’
[17:39:20.263]   - Field: ‘expr’
[17:39:20.264]   - Field: ‘uuid’
[17:39:20.264]   - Field: ‘seed’
[17:39:20.264]   - Field: ‘version’
[17:39:20.264]   - Field: ‘result’
[17:39:20.264]   - Field: ‘asynchronous’
[17:39:20.264]   - Field: ‘calls’
[17:39:20.264]   - Field: ‘globals’
[17:39:20.264]   - Field: ‘stdout’
[17:39:20.264]   - Field: ‘earlySignal’
[17:39:20.264]   - Field: ‘lazy’
[17:39:20.264]   - Field: ‘state’
[17:39:20.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.265] - Launch lazy future ...
[17:39:20.265] Packages needed by the future expression (n = 0): <none>
[17:39:20.265] Packages needed by future strategies (n = 0): <none>
[17:39:20.265] {
[17:39:20.265]     {
[17:39:20.265]         {
[17:39:20.265]             ...future.startTime <- base::Sys.time()
[17:39:20.265]             {
[17:39:20.265]                 {
[17:39:20.265]                   {
[17:39:20.265]                     base::local({
[17:39:20.265]                       has_future <- base::requireNamespace("future", 
[17:39:20.265]                         quietly = TRUE)
[17:39:20.265]                       if (has_future) {
[17:39:20.265]                         ns <- base::getNamespace("future")
[17:39:20.265]                         version <- ns[[".package"]][["version"]]
[17:39:20.265]                         if (is.null(version)) 
[17:39:20.265]                           version <- utils::packageVersion("future")
[17:39:20.265]                       }
[17:39:20.265]                       else {
[17:39:20.265]                         version <- NULL
[17:39:20.265]                       }
[17:39:20.265]                       if (!has_future || version < "1.8.0") {
[17:39:20.265]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.265]                           "", base::R.version$version.string), 
[17:39:20.265]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:20.265]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.265]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.265]                             "release", "version")], collapse = " "), 
[17:39:20.265]                           hostname = base::Sys.info()[["nodename"]])
[17:39:20.265]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.265]                           info)
[17:39:20.265]                         info <- base::paste(info, collapse = "; ")
[17:39:20.265]                         if (!has_future) {
[17:39:20.265]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.265]                             info)
[17:39:20.265]                         }
[17:39:20.265]                         else {
[17:39:20.265]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.265]                             info, version)
[17:39:20.265]                         }
[17:39:20.265]                         base::stop(msg)
[17:39:20.265]                       }
[17:39:20.265]                     })
[17:39:20.265]                   }
[17:39:20.265]                   options(future.plan = NULL)
[17:39:20.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.265]                 }
[17:39:20.265]                 ...future.workdir <- getwd()
[17:39:20.265]             }
[17:39:20.265]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.265]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.265]         }
[17:39:20.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.265]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.265]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.265]             base::names(...future.oldOptions))
[17:39:20.265]     }
[17:39:20.265]     if (FALSE) {
[17:39:20.265]     }
[17:39:20.265]     else {
[17:39:20.265]         if (TRUE) {
[17:39:20.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.265]                 open = "w")
[17:39:20.265]         }
[17:39:20.265]         else {
[17:39:20.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.265]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.265]         }
[17:39:20.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.265]             base::sink(type = "output", split = FALSE)
[17:39:20.265]             base::close(...future.stdout)
[17:39:20.265]         }, add = TRUE)
[17:39:20.265]     }
[17:39:20.265]     ...future.frame <- base::sys.nframe()
[17:39:20.265]     ...future.conditions <- base::list()
[17:39:20.265]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.265]     if (FALSE) {
[17:39:20.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.265]     }
[17:39:20.265]     ...future.result <- base::tryCatch({
[17:39:20.265]         base::withCallingHandlers({
[17:39:20.265]             ...future.value <- base::withVisible(base::local({
[17:39:20.265]                 do.call(function(...) {
[17:39:20.265]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.265]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.265]                     ...future.globals.maxSize)) {
[17:39:20.265]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.265]                     on.exit(options(oopts), add = TRUE)
[17:39:20.265]                   }
[17:39:20.265]                   {
[17:39:20.265]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.265]                       FUN = function(jj) {
[17:39:20.265]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.265]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.265]                       })
[17:39:20.265]                   }
[17:39:20.265]                 }, args = future.call.arguments)
[17:39:20.265]             }))
[17:39:20.265]             future::FutureResult(value = ...future.value$value, 
[17:39:20.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.265]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.265]                     ...future.globalenv.names))
[17:39:20.265]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.265]         }, condition = base::local({
[17:39:20.265]             c <- base::c
[17:39:20.265]             inherits <- base::inherits
[17:39:20.265]             invokeRestart <- base::invokeRestart
[17:39:20.265]             length <- base::length
[17:39:20.265]             list <- base::list
[17:39:20.265]             seq.int <- base::seq.int
[17:39:20.265]             signalCondition <- base::signalCondition
[17:39:20.265]             sys.calls <- base::sys.calls
[17:39:20.265]             `[[` <- base::`[[`
[17:39:20.265]             `+` <- base::`+`
[17:39:20.265]             `<<-` <- base::`<<-`
[17:39:20.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.265]                   3L)]
[17:39:20.265]             }
[17:39:20.265]             function(cond) {
[17:39:20.265]                 is_error <- inherits(cond, "error")
[17:39:20.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.265]                   NULL)
[17:39:20.265]                 if (is_error) {
[17:39:20.265]                   sessionInformation <- function() {
[17:39:20.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.265]                       search = base::search(), system = base::Sys.info())
[17:39:20.265]                   }
[17:39:20.265]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.265]                     cond$call), session = sessionInformation(), 
[17:39:20.265]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.265]                   signalCondition(cond)
[17:39:20.265]                 }
[17:39:20.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.265]                 "immediateCondition"))) {
[17:39:20.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.265]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.265]                   if (TRUE && !signal) {
[17:39:20.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.265]                     {
[17:39:20.265]                       inherits <- base::inherits
[17:39:20.265]                       invokeRestart <- base::invokeRestart
[17:39:20.265]                       is.null <- base::is.null
[17:39:20.265]                       muffled <- FALSE
[17:39:20.265]                       if (inherits(cond, "message")) {
[17:39:20.265]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.265]                         if (muffled) 
[17:39:20.265]                           invokeRestart("muffleMessage")
[17:39:20.265]                       }
[17:39:20.265]                       else if (inherits(cond, "warning")) {
[17:39:20.265]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.265]                         if (muffled) 
[17:39:20.265]                           invokeRestart("muffleWarning")
[17:39:20.265]                       }
[17:39:20.265]                       else if (inherits(cond, "condition")) {
[17:39:20.265]                         if (!is.null(pattern)) {
[17:39:20.265]                           computeRestarts <- base::computeRestarts
[17:39:20.265]                           grepl <- base::grepl
[17:39:20.265]                           restarts <- computeRestarts(cond)
[17:39:20.265]                           for (restart in restarts) {
[17:39:20.265]                             name <- restart$name
[17:39:20.265]                             if (is.null(name)) 
[17:39:20.265]                               next
[17:39:20.265]                             if (!grepl(pattern, name)) 
[17:39:20.265]                               next
[17:39:20.265]                             invokeRestart(restart)
[17:39:20.265]                             muffled <- TRUE
[17:39:20.265]                             break
[17:39:20.265]                           }
[17:39:20.265]                         }
[17:39:20.265]                       }
[17:39:20.265]                       invisible(muffled)
[17:39:20.265]                     }
[17:39:20.265]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.265]                   }
[17:39:20.265]                 }
[17:39:20.265]                 else {
[17:39:20.265]                   if (TRUE) {
[17:39:20.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.265]                     {
[17:39:20.265]                       inherits <- base::inherits
[17:39:20.265]                       invokeRestart <- base::invokeRestart
[17:39:20.265]                       is.null <- base::is.null
[17:39:20.265]                       muffled <- FALSE
[17:39:20.265]                       if (inherits(cond, "message")) {
[17:39:20.265]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.265]                         if (muffled) 
[17:39:20.265]                           invokeRestart("muffleMessage")
[17:39:20.265]                       }
[17:39:20.265]                       else if (inherits(cond, "warning")) {
[17:39:20.265]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.265]                         if (muffled) 
[17:39:20.265]                           invokeRestart("muffleWarning")
[17:39:20.265]                       }
[17:39:20.265]                       else if (inherits(cond, "condition")) {
[17:39:20.265]                         if (!is.null(pattern)) {
[17:39:20.265]                           computeRestarts <- base::computeRestarts
[17:39:20.265]                           grepl <- base::grepl
[17:39:20.265]                           restarts <- computeRestarts(cond)
[17:39:20.265]                           for (restart in restarts) {
[17:39:20.265]                             name <- restart$name
[17:39:20.265]                             if (is.null(name)) 
[17:39:20.265]                               next
[17:39:20.265]                             if (!grepl(pattern, name)) 
[17:39:20.265]                               next
[17:39:20.265]                             invokeRestart(restart)
[17:39:20.265]                             muffled <- TRUE
[17:39:20.265]                             break
[17:39:20.265]                           }
[17:39:20.265]                         }
[17:39:20.265]                       }
[17:39:20.265]                       invisible(muffled)
[17:39:20.265]                     }
[17:39:20.265]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.265]                   }
[17:39:20.265]                 }
[17:39:20.265]             }
[17:39:20.265]         }))
[17:39:20.265]     }, error = function(ex) {
[17:39:20.265]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.265]                 ...future.rng), started = ...future.startTime, 
[17:39:20.265]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.265]             version = "1.8"), class = "FutureResult")
[17:39:20.265]     }, finally = {
[17:39:20.265]         if (!identical(...future.workdir, getwd())) 
[17:39:20.265]             setwd(...future.workdir)
[17:39:20.265]         {
[17:39:20.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.265]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.265]             }
[17:39:20.265]             base::options(...future.oldOptions)
[17:39:20.265]             if (.Platform$OS.type == "windows") {
[17:39:20.265]                 old_names <- names(...future.oldEnvVars)
[17:39:20.265]                 envs <- base::Sys.getenv()
[17:39:20.265]                 names <- names(envs)
[17:39:20.265]                 common <- intersect(names, old_names)
[17:39:20.265]                 added <- setdiff(names, old_names)
[17:39:20.265]                 removed <- setdiff(old_names, names)
[17:39:20.265]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.265]                   envs[common]]
[17:39:20.265]                 NAMES <- toupper(changed)
[17:39:20.265]                 args <- list()
[17:39:20.265]                 for (kk in seq_along(NAMES)) {
[17:39:20.265]                   name <- changed[[kk]]
[17:39:20.265]                   NAME <- NAMES[[kk]]
[17:39:20.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.265]                     next
[17:39:20.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.265]                 }
[17:39:20.265]                 NAMES <- toupper(added)
[17:39:20.265]                 for (kk in seq_along(NAMES)) {
[17:39:20.265]                   name <- added[[kk]]
[17:39:20.265]                   NAME <- NAMES[[kk]]
[17:39:20.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.265]                     next
[17:39:20.265]                   args[[name]] <- ""
[17:39:20.265]                 }
[17:39:20.265]                 NAMES <- toupper(removed)
[17:39:20.265]                 for (kk in seq_along(NAMES)) {
[17:39:20.265]                   name <- removed[[kk]]
[17:39:20.265]                   NAME <- NAMES[[kk]]
[17:39:20.265]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.265]                     next
[17:39:20.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.265]                 }
[17:39:20.265]                 if (length(args) > 0) 
[17:39:20.265]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.265]             }
[17:39:20.265]             else {
[17:39:20.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.265]             }
[17:39:20.265]             {
[17:39:20.265]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.265]                   0L) {
[17:39:20.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.265]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.265]                   base::options(opts)
[17:39:20.265]                 }
[17:39:20.265]                 {
[17:39:20.265]                   {
[17:39:20.265]                     NULL
[17:39:20.265]                     RNGkind("Mersenne-Twister")
[17:39:20.265]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:20.265]                       inherits = FALSE)
[17:39:20.265]                   }
[17:39:20.265]                   options(future.plan = NULL)
[17:39:20.265]                   if (is.na(NA_character_)) 
[17:39:20.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.265]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.265]                   {
[17:39:20.265]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.265]                     if (!future$lazy) 
[17:39:20.265]                       future <- run(future)
[17:39:20.265]                     invisible(future)
[17:39:20.265]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.265]                 }
[17:39:20.265]             }
[17:39:20.265]         }
[17:39:20.265]     })
[17:39:20.265]     if (TRUE) {
[17:39:20.265]         base::sink(type = "output", split = FALSE)
[17:39:20.265]         if (TRUE) {
[17:39:20.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.265]         }
[17:39:20.265]         else {
[17:39:20.265]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.265]         }
[17:39:20.265]         base::close(...future.stdout)
[17:39:20.265]         ...future.stdout <- NULL
[17:39:20.265]     }
[17:39:20.265]     ...future.result$conditions <- ...future.conditions
[17:39:20.265]     ...future.result$finished <- base::Sys.time()
[17:39:20.265]     ...future.result
[17:39:20.265] }
[17:39:20.267] assign_globals() ...
[17:39:20.267] List of 5
[17:39:20.267]  $ future.call.arguments    : list()
[17:39:20.267]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.267]  $ ...future.FUN            :function (x)  
[17:39:20.267]  $ ...future.elements_ii    :List of 2
[17:39:20.267]   ..$ : int 1
[17:39:20.267]   ..$ : int 2
[17:39:20.267]  $ ...future.seeds_ii       : NULL
[17:39:20.267]  $ ...future.globals.maxSize: num Inf
[17:39:20.267]  - attr(*, "resolved")= logi FALSE
[17:39:20.267]  - attr(*, "total_size")= num NA
[17:39:20.267]  - attr(*, "where")=List of 5
[17:39:20.267]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.267]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.267]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.267]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.267]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.267]  - attr(*, "already-done")= logi TRUE
[17:39:20.272] - copied ‘future.call.arguments’ to environment
[17:39:20.272] - copied ‘...future.FUN’ to environment
[17:39:20.272] - copied ‘...future.elements_ii’ to environment
[17:39:20.272] - copied ‘...future.seeds_ii’ to environment
[17:39:20.272] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.272] assign_globals() ... done
[17:39:20.273] plan(): Setting new future strategy stack:
[17:39:20.273] List of future strategies:
[17:39:20.273] 1. sequential:
[17:39:20.273]    - args: function (..., envir = parent.frame())
[17:39:20.273]    - tweaked: FALSE
[17:39:20.273]    - call: NULL
[17:39:20.273] plan(): nbrOfWorkers() = 1
[17:39:20.274] plan(): Setting new future strategy stack:
[17:39:20.274] List of future strategies:
[17:39:20.274] 1. sequential:
[17:39:20.274]    - args: function (..., envir = parent.frame())
[17:39:20.274]    - tweaked: FALSE
[17:39:20.274]    - call: plan(strategy)
[17:39:20.274] plan(): nbrOfWorkers() = 1
[17:39:20.274] SequentialFuture started (and completed)
[17:39:20.275] - Launch lazy future ... done
[17:39:20.275] run() for ‘SequentialFuture’ ... done
[17:39:20.275] Created future:
[17:39:20.275] SequentialFuture:
[17:39:20.275] Label: ‘future_apply-1’
[17:39:20.275] Expression:
[17:39:20.275] {
[17:39:20.275]     do.call(function(...) {
[17:39:20.275]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.275]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.275]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.275]             on.exit(options(oopts), add = TRUE)
[17:39:20.275]         }
[17:39:20.275]         {
[17:39:20.275]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.275]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.275]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.275]             })
[17:39:20.275]         }
[17:39:20.275]     }, args = future.call.arguments)
[17:39:20.275] }
[17:39:20.275] Lazy evaluation: FALSE
[17:39:20.275] Asynchronous evaluation: FALSE
[17:39:20.275] Local evaluation: TRUE
[17:39:20.275] Environment: R_GlobalEnv
[17:39:20.275] Capture standard output: TRUE
[17:39:20.275] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.275] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.275] Packages: <none>
[17:39:20.275] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.275] Resolved: TRUE
[17:39:20.275] Value: 112 bytes of class ‘list’
[17:39:20.275] Early signaling: FALSE
[17:39:20.275] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.275] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.276] Chunk #1 of 1 ... DONE
[17:39:20.276] Launching 1 futures (chunks) ... DONE
[17:39:20.276] Resolving 1 futures (chunks) ...
[17:39:20.276] resolve() on list ...
[17:39:20.276]  recursive: 0
[17:39:20.276]  length: 1
[17:39:20.276] 
[17:39:20.276] resolved() for ‘SequentialFuture’ ...
[17:39:20.277] - state: ‘finished’
[17:39:20.277] - run: TRUE
[17:39:20.277] - result: ‘FutureResult’
[17:39:20.277] resolved() for ‘SequentialFuture’ ... done
[17:39:20.277] Future #1
[17:39:20.277] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.277] - nx: 1
[17:39:20.277] - relay: TRUE
[17:39:20.277] - stdout: TRUE
[17:39:20.277] - signal: TRUE
[17:39:20.277] - resignal: FALSE
[17:39:20.278] - force: TRUE
[17:39:20.278] - relayed: [n=1] FALSE
[17:39:20.278] - queued futures: [n=1] FALSE
[17:39:20.278]  - until=1
[17:39:20.278]  - relaying element #1
[17:39:20.278] - relayed: [n=1] TRUE
[17:39:20.278] - queued futures: [n=1] TRUE
[17:39:20.278] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.278]  length: 0 (resolved future 1)
[17:39:20.278] Relaying remaining futures
[17:39:20.279] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.279] - nx: 1
[17:39:20.279] - relay: TRUE
[17:39:20.279] - stdout: TRUE
[17:39:20.279] - signal: TRUE
[17:39:20.279] - resignal: FALSE
[17:39:20.280] - force: TRUE
[17:39:20.280] - relayed: [n=1] TRUE
[17:39:20.280] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.280] - relayed: [n=1] TRUE
[17:39:20.280] - queued futures: [n=1] TRUE
[17:39:20.280] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.281] resolve() on list ... DONE
[17:39:20.281]  - Number of value chunks collected: 1
[17:39:20.281] Resolving 1 futures (chunks) ... DONE
[17:39:20.281] Reducing values from 1 chunks ...
[17:39:20.281]  - Number of values collected after concatenation: 2
[17:39:20.281]  - Number of values expected: 2
[17:39:20.281] Reducing values from 1 chunks ... DONE
[17:39:20.281] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:39:20.281] getGlobalsAndPackagesXApply() ...
[17:39:20.282]  - future.globals: TRUE
[17:39:20.282] getGlobalsAndPackages() ...
[17:39:20.282] Searching for globals...
[17:39:20.283] - globals found: [1] ‘FUN’
[17:39:20.283] Searching for globals ... DONE
[17:39:20.283] Resolving globals: FALSE
[17:39:20.283] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:20.284] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:20.284] - globals: [1] ‘FUN’
[17:39:20.284] 
[17:39:20.284] getGlobalsAndPackages() ... DONE
[17:39:20.284]  - globals found/used: [n=1] ‘FUN’
[17:39:20.284]  - needed namespaces: [n=0] 
[17:39:20.284] Finding globals ... DONE
[17:39:20.284]  - use_args: TRUE
[17:39:20.284]  - Getting '...' globals ...
[17:39:20.285] resolve() on list ...
[17:39:20.285]  recursive: 0
[17:39:20.285]  length: 1
[17:39:20.285]  elements: ‘...’
[17:39:20.285]  length: 0 (resolved future 1)
[17:39:20.285] resolve() on list ... DONE
[17:39:20.285]    - '...' content: [n=0] 
[17:39:20.285] List of 1
[17:39:20.285]  $ ...: list()
[17:39:20.285]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.285]  - attr(*, "where")=List of 1
[17:39:20.285]   ..$ ...:<environment: 0x55c7962c1668> 
[17:39:20.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.285]  - attr(*, "resolved")= logi TRUE
[17:39:20.285]  - attr(*, "total_size")= num NA
[17:39:20.288]  - Getting '...' globals ... DONE
[17:39:20.288] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.288] List of 2
[17:39:20.288]  $ ...future.FUN:function (x)  
[17:39:20.288]  $ ...          : list()
[17:39:20.288]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.288]  - attr(*, "where")=List of 2
[17:39:20.288]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.288]   ..$ ...          :<environment: 0x55c7962c1668> 
[17:39:20.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.288]  - attr(*, "resolved")= logi FALSE
[17:39:20.288]  - attr(*, "total_size")= num 848
[17:39:20.290] Packages to be attached in all futures: [n=0] 
[17:39:20.290] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.291] future_lapply() ...
[17:39:20.291] Number of chunks: 1
[17:39:20.291] getGlobalsAndPackagesXApply() ...
[17:39:20.291]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.291]  - use_args: TRUE
[17:39:20.292] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.292] List of 2
[17:39:20.292]  $ ...          : list()
[17:39:20.292]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.292]  $ ...future.FUN:function (x)  
[17:39:20.292]  - attr(*, "where")=List of 2
[17:39:20.292]   ..$ ...          :<environment: 0x55c7962c1668> 
[17:39:20.292]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.292]  - attr(*, "resolved")= logi FALSE
[17:39:20.292]  - attr(*, "total_size")= num NA
[17:39:20.295] Packages to be attached in all futures: [n=0] 
[17:39:20.295] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.295] Number of futures (= number of chunks): 1
[17:39:20.295] Launching 1 futures (chunks) ...
[17:39:20.295] Chunk #1 of 1 ...
[17:39:20.295]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:39:20.295]  - seeds: <none>
[17:39:20.295] getGlobalsAndPackages() ...
[17:39:20.295] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.296] Resolving globals: FALSE
[17:39:20.296] Tweak future expression to call with '...' arguments ...
[17:39:20.296] {
[17:39:20.296]     do.call(function(...) {
[17:39:20.296]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.296]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.296]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.296]             on.exit(options(oopts), add = TRUE)
[17:39:20.296]         }
[17:39:20.296]         {
[17:39:20.296]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.296]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.296]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.296]             })
[17:39:20.296]         }
[17:39:20.296]     }, args = future.call.arguments)
[17:39:20.296] }
[17:39:20.296] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.296] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.297] 
[17:39:20.297] getGlobalsAndPackages() ... DONE
[17:39:20.297] run() for ‘Future’ ...
[17:39:20.297] - state: ‘created’
[17:39:20.297] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.297] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.297] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.298]   - Field: ‘label’
[17:39:20.298]   - Field: ‘local’
[17:39:20.298]   - Field: ‘owner’
[17:39:20.298]   - Field: ‘envir’
[17:39:20.298]   - Field: ‘packages’
[17:39:20.298]   - Field: ‘gc’
[17:39:20.298]   - Field: ‘conditions’
[17:39:20.298]   - Field: ‘expr’
[17:39:20.298]   - Field: ‘uuid’
[17:39:20.298]   - Field: ‘seed’
[17:39:20.298]   - Field: ‘version’
[17:39:20.299]   - Field: ‘result’
[17:39:20.299]   - Field: ‘asynchronous’
[17:39:20.299]   - Field: ‘calls’
[17:39:20.299]   - Field: ‘globals’
[17:39:20.299]   - Field: ‘stdout’
[17:39:20.299]   - Field: ‘earlySignal’
[17:39:20.299]   - Field: ‘lazy’
[17:39:20.299]   - Field: ‘state’
[17:39:20.299] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.299] - Launch lazy future ...
[17:39:20.300] Packages needed by the future expression (n = 0): <none>
[17:39:20.300] Packages needed by future strategies (n = 0): <none>
[17:39:20.300] {
[17:39:20.300]     {
[17:39:20.300]         {
[17:39:20.300]             ...future.startTime <- base::Sys.time()
[17:39:20.300]             {
[17:39:20.300]                 {
[17:39:20.300]                   {
[17:39:20.300]                     base::local({
[17:39:20.300]                       has_future <- base::requireNamespace("future", 
[17:39:20.300]                         quietly = TRUE)
[17:39:20.300]                       if (has_future) {
[17:39:20.300]                         ns <- base::getNamespace("future")
[17:39:20.300]                         version <- ns[[".package"]][["version"]]
[17:39:20.300]                         if (is.null(version)) 
[17:39:20.300]                           version <- utils::packageVersion("future")
[17:39:20.300]                       }
[17:39:20.300]                       else {
[17:39:20.300]                         version <- NULL
[17:39:20.300]                       }
[17:39:20.300]                       if (!has_future || version < "1.8.0") {
[17:39:20.300]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.300]                           "", base::R.version$version.string), 
[17:39:20.300]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:20.300]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.300]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.300]                             "release", "version")], collapse = " "), 
[17:39:20.300]                           hostname = base::Sys.info()[["nodename"]])
[17:39:20.300]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.300]                           info)
[17:39:20.300]                         info <- base::paste(info, collapse = "; ")
[17:39:20.300]                         if (!has_future) {
[17:39:20.300]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.300]                             info)
[17:39:20.300]                         }
[17:39:20.300]                         else {
[17:39:20.300]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.300]                             info, version)
[17:39:20.300]                         }
[17:39:20.300]                         base::stop(msg)
[17:39:20.300]                       }
[17:39:20.300]                     })
[17:39:20.300]                   }
[17:39:20.300]                   options(future.plan = NULL)
[17:39:20.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.300]                 }
[17:39:20.300]                 ...future.workdir <- getwd()
[17:39:20.300]             }
[17:39:20.300]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.300]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.300]         }
[17:39:20.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.300]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.300]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.300]             base::names(...future.oldOptions))
[17:39:20.300]     }
[17:39:20.300]     if (FALSE) {
[17:39:20.300]     }
[17:39:20.300]     else {
[17:39:20.300]         if (TRUE) {
[17:39:20.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.300]                 open = "w")
[17:39:20.300]         }
[17:39:20.300]         else {
[17:39:20.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.300]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.300]         }
[17:39:20.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.300]             base::sink(type = "output", split = FALSE)
[17:39:20.300]             base::close(...future.stdout)
[17:39:20.300]         }, add = TRUE)
[17:39:20.300]     }
[17:39:20.300]     ...future.frame <- base::sys.nframe()
[17:39:20.300]     ...future.conditions <- base::list()
[17:39:20.300]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.300]     if (FALSE) {
[17:39:20.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.300]     }
[17:39:20.300]     ...future.result <- base::tryCatch({
[17:39:20.300]         base::withCallingHandlers({
[17:39:20.300]             ...future.value <- base::withVisible(base::local({
[17:39:20.300]                 do.call(function(...) {
[17:39:20.300]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.300]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.300]                     ...future.globals.maxSize)) {
[17:39:20.300]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.300]                     on.exit(options(oopts), add = TRUE)
[17:39:20.300]                   }
[17:39:20.300]                   {
[17:39:20.300]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.300]                       FUN = function(jj) {
[17:39:20.300]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.300]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.300]                       })
[17:39:20.300]                   }
[17:39:20.300]                 }, args = future.call.arguments)
[17:39:20.300]             }))
[17:39:20.300]             future::FutureResult(value = ...future.value$value, 
[17:39:20.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.300]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.300]                     ...future.globalenv.names))
[17:39:20.300]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.300]         }, condition = base::local({
[17:39:20.300]             c <- base::c
[17:39:20.300]             inherits <- base::inherits
[17:39:20.300]             invokeRestart <- base::invokeRestart
[17:39:20.300]             length <- base::length
[17:39:20.300]             list <- base::list
[17:39:20.300]             seq.int <- base::seq.int
[17:39:20.300]             signalCondition <- base::signalCondition
[17:39:20.300]             sys.calls <- base::sys.calls
[17:39:20.300]             `[[` <- base::`[[`
[17:39:20.300]             `+` <- base::`+`
[17:39:20.300]             `<<-` <- base::`<<-`
[17:39:20.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.300]                   3L)]
[17:39:20.300]             }
[17:39:20.300]             function(cond) {
[17:39:20.300]                 is_error <- inherits(cond, "error")
[17:39:20.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.300]                   NULL)
[17:39:20.300]                 if (is_error) {
[17:39:20.300]                   sessionInformation <- function() {
[17:39:20.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.300]                       search = base::search(), system = base::Sys.info())
[17:39:20.300]                   }
[17:39:20.300]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.300]                     cond$call), session = sessionInformation(), 
[17:39:20.300]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.300]                   signalCondition(cond)
[17:39:20.300]                 }
[17:39:20.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.300]                 "immediateCondition"))) {
[17:39:20.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.300]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.300]                   if (TRUE && !signal) {
[17:39:20.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.300]                     {
[17:39:20.300]                       inherits <- base::inherits
[17:39:20.300]                       invokeRestart <- base::invokeRestart
[17:39:20.300]                       is.null <- base::is.null
[17:39:20.300]                       muffled <- FALSE
[17:39:20.300]                       if (inherits(cond, "message")) {
[17:39:20.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.300]                         if (muffled) 
[17:39:20.300]                           invokeRestart("muffleMessage")
[17:39:20.300]                       }
[17:39:20.300]                       else if (inherits(cond, "warning")) {
[17:39:20.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.300]                         if (muffled) 
[17:39:20.300]                           invokeRestart("muffleWarning")
[17:39:20.300]                       }
[17:39:20.300]                       else if (inherits(cond, "condition")) {
[17:39:20.300]                         if (!is.null(pattern)) {
[17:39:20.300]                           computeRestarts <- base::computeRestarts
[17:39:20.300]                           grepl <- base::grepl
[17:39:20.300]                           restarts <- computeRestarts(cond)
[17:39:20.300]                           for (restart in restarts) {
[17:39:20.300]                             name <- restart$name
[17:39:20.300]                             if (is.null(name)) 
[17:39:20.300]                               next
[17:39:20.300]                             if (!grepl(pattern, name)) 
[17:39:20.300]                               next
[17:39:20.300]                             invokeRestart(restart)
[17:39:20.300]                             muffled <- TRUE
[17:39:20.300]                             break
[17:39:20.300]                           }
[17:39:20.300]                         }
[17:39:20.300]                       }
[17:39:20.300]                       invisible(muffled)
[17:39:20.300]                     }
[17:39:20.300]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.300]                   }
[17:39:20.300]                 }
[17:39:20.300]                 else {
[17:39:20.300]                   if (TRUE) {
[17:39:20.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.300]                     {
[17:39:20.300]                       inherits <- base::inherits
[17:39:20.300]                       invokeRestart <- base::invokeRestart
[17:39:20.300]                       is.null <- base::is.null
[17:39:20.300]                       muffled <- FALSE
[17:39:20.300]                       if (inherits(cond, "message")) {
[17:39:20.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.300]                         if (muffled) 
[17:39:20.300]                           invokeRestart("muffleMessage")
[17:39:20.300]                       }
[17:39:20.300]                       else if (inherits(cond, "warning")) {
[17:39:20.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.300]                         if (muffled) 
[17:39:20.300]                           invokeRestart("muffleWarning")
[17:39:20.300]                       }
[17:39:20.300]                       else if (inherits(cond, "condition")) {
[17:39:20.300]                         if (!is.null(pattern)) {
[17:39:20.300]                           computeRestarts <- base::computeRestarts
[17:39:20.300]                           grepl <- base::grepl
[17:39:20.300]                           restarts <- computeRestarts(cond)
[17:39:20.300]                           for (restart in restarts) {
[17:39:20.300]                             name <- restart$name
[17:39:20.300]                             if (is.null(name)) 
[17:39:20.300]                               next
[17:39:20.300]                             if (!grepl(pattern, name)) 
[17:39:20.300]                               next
[17:39:20.300]                             invokeRestart(restart)
[17:39:20.300]                             muffled <- TRUE
[17:39:20.300]                             break
[17:39:20.300]                           }
[17:39:20.300]                         }
[17:39:20.300]                       }
[17:39:20.300]                       invisible(muffled)
[17:39:20.300]                     }
[17:39:20.300]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.300]                   }
[17:39:20.300]                 }
[17:39:20.300]             }
[17:39:20.300]         }))
[17:39:20.300]     }, error = function(ex) {
[17:39:20.300]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.300]                 ...future.rng), started = ...future.startTime, 
[17:39:20.300]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.300]             version = "1.8"), class = "FutureResult")
[17:39:20.300]     }, finally = {
[17:39:20.300]         if (!identical(...future.workdir, getwd())) 
[17:39:20.300]             setwd(...future.workdir)
[17:39:20.300]         {
[17:39:20.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.300]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.300]             }
[17:39:20.300]             base::options(...future.oldOptions)
[17:39:20.300]             if (.Platform$OS.type == "windows") {
[17:39:20.300]                 old_names <- names(...future.oldEnvVars)
[17:39:20.300]                 envs <- base::Sys.getenv()
[17:39:20.300]                 names <- names(envs)
[17:39:20.300]                 common <- intersect(names, old_names)
[17:39:20.300]                 added <- setdiff(names, old_names)
[17:39:20.300]                 removed <- setdiff(old_names, names)
[17:39:20.300]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.300]                   envs[common]]
[17:39:20.300]                 NAMES <- toupper(changed)
[17:39:20.300]                 args <- list()
[17:39:20.300]                 for (kk in seq_along(NAMES)) {
[17:39:20.300]                   name <- changed[[kk]]
[17:39:20.300]                   NAME <- NAMES[[kk]]
[17:39:20.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.300]                     next
[17:39:20.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.300]                 }
[17:39:20.300]                 NAMES <- toupper(added)
[17:39:20.300]                 for (kk in seq_along(NAMES)) {
[17:39:20.300]                   name <- added[[kk]]
[17:39:20.300]                   NAME <- NAMES[[kk]]
[17:39:20.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.300]                     next
[17:39:20.300]                   args[[name]] <- ""
[17:39:20.300]                 }
[17:39:20.300]                 NAMES <- toupper(removed)
[17:39:20.300]                 for (kk in seq_along(NAMES)) {
[17:39:20.300]                   name <- removed[[kk]]
[17:39:20.300]                   NAME <- NAMES[[kk]]
[17:39:20.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.300]                     next
[17:39:20.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.300]                 }
[17:39:20.300]                 if (length(args) > 0) 
[17:39:20.300]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.300]             }
[17:39:20.300]             else {
[17:39:20.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.300]             }
[17:39:20.300]             {
[17:39:20.300]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.300]                   0L) {
[17:39:20.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.300]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.300]                   base::options(opts)
[17:39:20.300]                 }
[17:39:20.300]                 {
[17:39:20.300]                   {
[17:39:20.300]                     NULL
[17:39:20.300]                     RNGkind("Mersenne-Twister")
[17:39:20.300]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:20.300]                       inherits = FALSE)
[17:39:20.300]                   }
[17:39:20.300]                   options(future.plan = NULL)
[17:39:20.300]                   if (is.na(NA_character_)) 
[17:39:20.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.300]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.300]                   {
[17:39:20.300]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.300]                     if (!future$lazy) 
[17:39:20.300]                       future <- run(future)
[17:39:20.300]                     invisible(future)
[17:39:20.300]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.300]                 }
[17:39:20.300]             }
[17:39:20.300]         }
[17:39:20.300]     })
[17:39:20.300]     if (TRUE) {
[17:39:20.300]         base::sink(type = "output", split = FALSE)
[17:39:20.300]         if (TRUE) {
[17:39:20.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.300]         }
[17:39:20.300]         else {
[17:39:20.300]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.300]         }
[17:39:20.300]         base::close(...future.stdout)
[17:39:20.300]         ...future.stdout <- NULL
[17:39:20.300]     }
[17:39:20.300]     ...future.result$conditions <- ...future.conditions
[17:39:20.300]     ...future.result$finished <- base::Sys.time()
[17:39:20.300]     ...future.result
[17:39:20.300] }
[17:39:20.302] assign_globals() ...
[17:39:20.302] List of 5
[17:39:20.302]  $ future.call.arguments    : list()
[17:39:20.302]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.302]  $ ...future.FUN            :function (x)  
[17:39:20.302]  $ ...future.elements_ii    :List of 2
[17:39:20.302]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[17:39:20.302]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[17:39:20.302]  $ ...future.seeds_ii       : NULL
[17:39:20.302]  $ ...future.globals.maxSize: num Inf
[17:39:20.302]  - attr(*, "resolved")= logi FALSE
[17:39:20.302]  - attr(*, "total_size")= num NA
[17:39:20.302]  - attr(*, "where")=List of 5
[17:39:20.302]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.302]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.302]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.302]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.302]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.302]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.302]  - attr(*, "already-done")= logi TRUE
[17:39:20.309] - copied ‘future.call.arguments’ to environment
[17:39:20.309] - copied ‘...future.FUN’ to environment
[17:39:20.309] - copied ‘...future.elements_ii’ to environment
[17:39:20.309] - copied ‘...future.seeds_ii’ to environment
[17:39:20.309] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.309] assign_globals() ... done
[17:39:20.309] plan(): Setting new future strategy stack:
[17:39:20.309] List of future strategies:
[17:39:20.309] 1. sequential:
[17:39:20.309]    - args: function (..., envir = parent.frame())
[17:39:20.309]    - tweaked: FALSE
[17:39:20.309]    - call: NULL
[17:39:20.310] plan(): nbrOfWorkers() = 1
[17:39:20.311] plan(): Setting new future strategy stack:
[17:39:20.311] List of future strategies:
[17:39:20.311] 1. sequential:
[17:39:20.311]    - args: function (..., envir = parent.frame())
[17:39:20.311]    - tweaked: FALSE
[17:39:20.311]    - call: plan(strategy)
[17:39:20.311] plan(): nbrOfWorkers() = 1
[17:39:20.311] SequentialFuture started (and completed)
[17:39:20.311] - Launch lazy future ... done
[17:39:20.311] run() for ‘SequentialFuture’ ... done
[17:39:20.312] Created future:
[17:39:20.312] SequentialFuture:
[17:39:20.312] Label: ‘future_apply-1’
[17:39:20.312] Expression:
[17:39:20.312] {
[17:39:20.312]     do.call(function(...) {
[17:39:20.312]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.312]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.312]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.312]             on.exit(options(oopts), add = TRUE)
[17:39:20.312]         }
[17:39:20.312]         {
[17:39:20.312]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.312]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.312]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.312]             })
[17:39:20.312]         }
[17:39:20.312]     }, args = future.call.arguments)
[17:39:20.312] }
[17:39:20.312] Lazy evaluation: FALSE
[17:39:20.312] Asynchronous evaluation: FALSE
[17:39:20.312] Local evaluation: TRUE
[17:39:20.312] Environment: R_GlobalEnv
[17:39:20.312] Capture standard output: TRUE
[17:39:20.312] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.312] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.312] Packages: <none>
[17:39:20.312] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.312] Resolved: TRUE
[17:39:20.312] Value: 496 bytes of class ‘list’
[17:39:20.312] Early signaling: FALSE
[17:39:20.312] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.312] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.313] Chunk #1 of 1 ... DONE
[17:39:20.313] Launching 1 futures (chunks) ... DONE
[17:39:20.313] Resolving 1 futures (chunks) ...
[17:39:20.313] resolve() on list ...
[17:39:20.313]  recursive: 0
[17:39:20.313]  length: 1
[17:39:20.313] 
[17:39:20.313] resolved() for ‘SequentialFuture’ ...
[17:39:20.313] - state: ‘finished’
[17:39:20.314] - run: TRUE
[17:39:20.314] - result: ‘FutureResult’
[17:39:20.314] resolved() for ‘SequentialFuture’ ... done
[17:39:20.314] Future #1
[17:39:20.314] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.314] - nx: 1
[17:39:20.314] - relay: TRUE
[17:39:20.314] - stdout: TRUE
[17:39:20.314] - signal: TRUE
[17:39:20.314] - resignal: FALSE
[17:39:20.315] - force: TRUE
[17:39:20.315] - relayed: [n=1] FALSE
[17:39:20.315] - queued futures: [n=1] FALSE
[17:39:20.315]  - until=1
[17:39:20.315]  - relaying element #1
[17:39:20.315] - relayed: [n=1] TRUE
[17:39:20.315] - queued futures: [n=1] TRUE
[17:39:20.315] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.315]  length: 0 (resolved future 1)
[17:39:20.315] Relaying remaining futures
[17:39:20.316] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.316] - nx: 1
[17:39:20.316] - relay: TRUE
[17:39:20.316] - stdout: TRUE
[17:39:20.316] - signal: TRUE
[17:39:20.316] - resignal: FALSE
[17:39:20.316] - force: TRUE
[17:39:20.316] - relayed: [n=1] TRUE
[17:39:20.316] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.316] - relayed: [n=1] TRUE
[17:39:20.316] - queued futures: [n=1] TRUE
[17:39:20.317] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.317] resolve() on list ... DONE
[17:39:20.317]  - Number of value chunks collected: 1
[17:39:20.317] Resolving 1 futures (chunks) ... DONE
[17:39:20.317] Reducing values from 1 chunks ...
[17:39:20.317]  - Number of values collected after concatenation: 2
[17:39:20.317]  - Number of values expected: 2
[17:39:20.317] Reducing values from 1 chunks ... DONE
[17:39:20.317] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:39:20.318] getGlobalsAndPackagesXApply() ...
[17:39:20.318]  - future.globals: TRUE
[17:39:20.318] getGlobalsAndPackages() ...
[17:39:20.318] Searching for globals...
[17:39:20.320] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:39:20.321] Searching for globals ... DONE
[17:39:20.321] Resolving globals: FALSE
[17:39:20.321] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:39:20.322] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:39:20.322] - globals: [1] ‘FUN’
[17:39:20.322] 
[17:39:20.322] getGlobalsAndPackages() ... DONE
[17:39:20.322]  - globals found/used: [n=1] ‘FUN’
[17:39:20.322]  - needed namespaces: [n=0] 
[17:39:20.322] Finding globals ... DONE
[17:39:20.322]  - use_args: TRUE
[17:39:20.322]  - Getting '...' globals ...
[17:39:20.323] resolve() on list ...
[17:39:20.323]  recursive: 0
[17:39:20.323]  length: 1
[17:39:20.323]  elements: ‘...’
[17:39:20.323]  length: 0 (resolved future 1)
[17:39:20.323] resolve() on list ... DONE
[17:39:20.323]    - '...' content: [n=0] 
[17:39:20.323] List of 1
[17:39:20.323]  $ ...: list()
[17:39:20.323]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.323]  - attr(*, "where")=List of 1
[17:39:20.323]   ..$ ...:<environment: 0x55c796a40088> 
[17:39:20.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.323]  - attr(*, "resolved")= logi TRUE
[17:39:20.323]  - attr(*, "total_size")= num NA
[17:39:20.327]  - Getting '...' globals ... DONE
[17:39:20.327] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.328] List of 2
[17:39:20.328]  $ ...future.FUN:function (x)  
[17:39:20.328]  $ ...          : list()
[17:39:20.328]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.328]  - attr(*, "where")=List of 2
[17:39:20.328]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.328]   ..$ ...          :<environment: 0x55c796a40088> 
[17:39:20.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.328]  - attr(*, "resolved")= logi FALSE
[17:39:20.328]  - attr(*, "total_size")= num 9888
[17:39:20.330] Packages to be attached in all futures: [n=0] 
[17:39:20.330] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.331] future_lapply() ...
[17:39:20.332] Number of chunks: 1
[17:39:20.332] getGlobalsAndPackagesXApply() ...
[17:39:20.332]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.333]  - use_args: TRUE
[17:39:20.333] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.333] List of 2
[17:39:20.333]  $ ...          : list()
[17:39:20.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.333]  $ ...future.FUN:function (x)  
[17:39:20.333]  - attr(*, "where")=List of 2
[17:39:20.333]   ..$ ...          :<environment: 0x55c796a40088> 
[17:39:20.333]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:39:20.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.333]  - attr(*, "resolved")= logi FALSE
[17:39:20.333]  - attr(*, "total_size")= num NA
[17:39:20.335] Packages to be attached in all futures: [n=0] 
[17:39:20.336] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.336] Number of futures (= number of chunks): 1
[17:39:20.336] Launching 1 futures (chunks) ...
[17:39:20.336] Chunk #1 of 1 ...
[17:39:20.336]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:39:20.336]  - seeds: <none>
[17:39:20.336] getGlobalsAndPackages() ...
[17:39:20.336] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.336] Resolving globals: FALSE
[17:39:20.337] Tweak future expression to call with '...' arguments ...
[17:39:20.337] {
[17:39:20.337]     do.call(function(...) {
[17:39:20.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.337]             on.exit(options(oopts), add = TRUE)
[17:39:20.337]         }
[17:39:20.337]         {
[17:39:20.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.337]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.337]             })
[17:39:20.337]         }
[17:39:20.337]     }, args = future.call.arguments)
[17:39:20.337] }
[17:39:20.337] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.337] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.337] 
[17:39:20.337] getGlobalsAndPackages() ... DONE
[17:39:20.338] run() for ‘Future’ ...
[17:39:20.338] - state: ‘created’
[17:39:20.338] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.338] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.338] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.338]   - Field: ‘label’
[17:39:20.339]   - Field: ‘local’
[17:39:20.339]   - Field: ‘owner’
[17:39:20.339]   - Field: ‘envir’
[17:39:20.339]   - Field: ‘packages’
[17:39:20.339]   - Field: ‘gc’
[17:39:20.339]   - Field: ‘conditions’
[17:39:20.339]   - Field: ‘expr’
[17:39:20.339]   - Field: ‘uuid’
[17:39:20.339]   - Field: ‘seed’
[17:39:20.339]   - Field: ‘version’
[17:39:20.340]   - Field: ‘result’
[17:39:20.340]   - Field: ‘asynchronous’
[17:39:20.340]   - Field: ‘calls’
[17:39:20.340]   - Field: ‘globals’
[17:39:20.340]   - Field: ‘stdout’
[17:39:20.340]   - Field: ‘earlySignal’
[17:39:20.340]   - Field: ‘lazy’
[17:39:20.340]   - Field: ‘state’
[17:39:20.340] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.340] - Launch lazy future ...
[17:39:20.341] Packages needed by the future expression (n = 0): <none>
[17:39:20.341] Packages needed by future strategies (n = 0): <none>
[17:39:20.341] {
[17:39:20.341]     {
[17:39:20.341]         {
[17:39:20.341]             ...future.startTime <- base::Sys.time()
[17:39:20.341]             {
[17:39:20.341]                 {
[17:39:20.341]                   {
[17:39:20.341]                     base::local({
[17:39:20.341]                       has_future <- base::requireNamespace("future", 
[17:39:20.341]                         quietly = TRUE)
[17:39:20.341]                       if (has_future) {
[17:39:20.341]                         ns <- base::getNamespace("future")
[17:39:20.341]                         version <- ns[[".package"]][["version"]]
[17:39:20.341]                         if (is.null(version)) 
[17:39:20.341]                           version <- utils::packageVersion("future")
[17:39:20.341]                       }
[17:39:20.341]                       else {
[17:39:20.341]                         version <- NULL
[17:39:20.341]                       }
[17:39:20.341]                       if (!has_future || version < "1.8.0") {
[17:39:20.341]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.341]                           "", base::R.version$version.string), 
[17:39:20.341]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:20.341]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.341]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.341]                             "release", "version")], collapse = " "), 
[17:39:20.341]                           hostname = base::Sys.info()[["nodename"]])
[17:39:20.341]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.341]                           info)
[17:39:20.341]                         info <- base::paste(info, collapse = "; ")
[17:39:20.341]                         if (!has_future) {
[17:39:20.341]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.341]                             info)
[17:39:20.341]                         }
[17:39:20.341]                         else {
[17:39:20.341]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.341]                             info, version)
[17:39:20.341]                         }
[17:39:20.341]                         base::stop(msg)
[17:39:20.341]                       }
[17:39:20.341]                     })
[17:39:20.341]                   }
[17:39:20.341]                   options(future.plan = NULL)
[17:39:20.341]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.341]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.341]                 }
[17:39:20.341]                 ...future.workdir <- getwd()
[17:39:20.341]             }
[17:39:20.341]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.341]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.341]         }
[17:39:20.341]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.341]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.341]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.341]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.341]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.341]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.341]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.341]             base::names(...future.oldOptions))
[17:39:20.341]     }
[17:39:20.341]     if (FALSE) {
[17:39:20.341]     }
[17:39:20.341]     else {
[17:39:20.341]         if (TRUE) {
[17:39:20.341]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.341]                 open = "w")
[17:39:20.341]         }
[17:39:20.341]         else {
[17:39:20.341]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.341]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.341]         }
[17:39:20.341]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.341]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.341]             base::sink(type = "output", split = FALSE)
[17:39:20.341]             base::close(...future.stdout)
[17:39:20.341]         }, add = TRUE)
[17:39:20.341]     }
[17:39:20.341]     ...future.frame <- base::sys.nframe()
[17:39:20.341]     ...future.conditions <- base::list()
[17:39:20.341]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.341]     if (FALSE) {
[17:39:20.341]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.341]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.341]     }
[17:39:20.341]     ...future.result <- base::tryCatch({
[17:39:20.341]         base::withCallingHandlers({
[17:39:20.341]             ...future.value <- base::withVisible(base::local({
[17:39:20.341]                 do.call(function(...) {
[17:39:20.341]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.341]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.341]                     ...future.globals.maxSize)) {
[17:39:20.341]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.341]                     on.exit(options(oopts), add = TRUE)
[17:39:20.341]                   }
[17:39:20.341]                   {
[17:39:20.341]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.341]                       FUN = function(jj) {
[17:39:20.341]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.341]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.341]                       })
[17:39:20.341]                   }
[17:39:20.341]                 }, args = future.call.arguments)
[17:39:20.341]             }))
[17:39:20.341]             future::FutureResult(value = ...future.value$value, 
[17:39:20.341]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.341]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.341]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.341]                     ...future.globalenv.names))
[17:39:20.341]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.341]         }, condition = base::local({
[17:39:20.341]             c <- base::c
[17:39:20.341]             inherits <- base::inherits
[17:39:20.341]             invokeRestart <- base::invokeRestart
[17:39:20.341]             length <- base::length
[17:39:20.341]             list <- base::list
[17:39:20.341]             seq.int <- base::seq.int
[17:39:20.341]             signalCondition <- base::signalCondition
[17:39:20.341]             sys.calls <- base::sys.calls
[17:39:20.341]             `[[` <- base::`[[`
[17:39:20.341]             `+` <- base::`+`
[17:39:20.341]             `<<-` <- base::`<<-`
[17:39:20.341]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.341]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.341]                   3L)]
[17:39:20.341]             }
[17:39:20.341]             function(cond) {
[17:39:20.341]                 is_error <- inherits(cond, "error")
[17:39:20.341]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.341]                   NULL)
[17:39:20.341]                 if (is_error) {
[17:39:20.341]                   sessionInformation <- function() {
[17:39:20.341]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.341]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.341]                       search = base::search(), system = base::Sys.info())
[17:39:20.341]                   }
[17:39:20.341]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.341]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.341]                     cond$call), session = sessionInformation(), 
[17:39:20.341]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.341]                   signalCondition(cond)
[17:39:20.341]                 }
[17:39:20.341]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.341]                 "immediateCondition"))) {
[17:39:20.341]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.341]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.341]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.341]                   if (TRUE && !signal) {
[17:39:20.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.341]                     {
[17:39:20.341]                       inherits <- base::inherits
[17:39:20.341]                       invokeRestart <- base::invokeRestart
[17:39:20.341]                       is.null <- base::is.null
[17:39:20.341]                       muffled <- FALSE
[17:39:20.341]                       if (inherits(cond, "message")) {
[17:39:20.341]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.341]                         if (muffled) 
[17:39:20.341]                           invokeRestart("muffleMessage")
[17:39:20.341]                       }
[17:39:20.341]                       else if (inherits(cond, "warning")) {
[17:39:20.341]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.341]                         if (muffled) 
[17:39:20.341]                           invokeRestart("muffleWarning")
[17:39:20.341]                       }
[17:39:20.341]                       else if (inherits(cond, "condition")) {
[17:39:20.341]                         if (!is.null(pattern)) {
[17:39:20.341]                           computeRestarts <- base::computeRestarts
[17:39:20.341]                           grepl <- base::grepl
[17:39:20.341]                           restarts <- computeRestarts(cond)
[17:39:20.341]                           for (restart in restarts) {
[17:39:20.341]                             name <- restart$name
[17:39:20.341]                             if (is.null(name)) 
[17:39:20.341]                               next
[17:39:20.341]                             if (!grepl(pattern, name)) 
[17:39:20.341]                               next
[17:39:20.341]                             invokeRestart(restart)
[17:39:20.341]                             muffled <- TRUE
[17:39:20.341]                             break
[17:39:20.341]                           }
[17:39:20.341]                         }
[17:39:20.341]                       }
[17:39:20.341]                       invisible(muffled)
[17:39:20.341]                     }
[17:39:20.341]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.341]                   }
[17:39:20.341]                 }
[17:39:20.341]                 else {
[17:39:20.341]                   if (TRUE) {
[17:39:20.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.341]                     {
[17:39:20.341]                       inherits <- base::inherits
[17:39:20.341]                       invokeRestart <- base::invokeRestart
[17:39:20.341]                       is.null <- base::is.null
[17:39:20.341]                       muffled <- FALSE
[17:39:20.341]                       if (inherits(cond, "message")) {
[17:39:20.341]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.341]                         if (muffled) 
[17:39:20.341]                           invokeRestart("muffleMessage")
[17:39:20.341]                       }
[17:39:20.341]                       else if (inherits(cond, "warning")) {
[17:39:20.341]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.341]                         if (muffled) 
[17:39:20.341]                           invokeRestart("muffleWarning")
[17:39:20.341]                       }
[17:39:20.341]                       else if (inherits(cond, "condition")) {
[17:39:20.341]                         if (!is.null(pattern)) {
[17:39:20.341]                           computeRestarts <- base::computeRestarts
[17:39:20.341]                           grepl <- base::grepl
[17:39:20.341]                           restarts <- computeRestarts(cond)
[17:39:20.341]                           for (restart in restarts) {
[17:39:20.341]                             name <- restart$name
[17:39:20.341]                             if (is.null(name)) 
[17:39:20.341]                               next
[17:39:20.341]                             if (!grepl(pattern, name)) 
[17:39:20.341]                               next
[17:39:20.341]                             invokeRestart(restart)
[17:39:20.341]                             muffled <- TRUE
[17:39:20.341]                             break
[17:39:20.341]                           }
[17:39:20.341]                         }
[17:39:20.341]                       }
[17:39:20.341]                       invisible(muffled)
[17:39:20.341]                     }
[17:39:20.341]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.341]                   }
[17:39:20.341]                 }
[17:39:20.341]             }
[17:39:20.341]         }))
[17:39:20.341]     }, error = function(ex) {
[17:39:20.341]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.341]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.341]                 ...future.rng), started = ...future.startTime, 
[17:39:20.341]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.341]             version = "1.8"), class = "FutureResult")
[17:39:20.341]     }, finally = {
[17:39:20.341]         if (!identical(...future.workdir, getwd())) 
[17:39:20.341]             setwd(...future.workdir)
[17:39:20.341]         {
[17:39:20.341]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.341]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.341]             }
[17:39:20.341]             base::options(...future.oldOptions)
[17:39:20.341]             if (.Platform$OS.type == "windows") {
[17:39:20.341]                 old_names <- names(...future.oldEnvVars)
[17:39:20.341]                 envs <- base::Sys.getenv()
[17:39:20.341]                 names <- names(envs)
[17:39:20.341]                 common <- intersect(names, old_names)
[17:39:20.341]                 added <- setdiff(names, old_names)
[17:39:20.341]                 removed <- setdiff(old_names, names)
[17:39:20.341]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.341]                   envs[common]]
[17:39:20.341]                 NAMES <- toupper(changed)
[17:39:20.341]                 args <- list()
[17:39:20.341]                 for (kk in seq_along(NAMES)) {
[17:39:20.341]                   name <- changed[[kk]]
[17:39:20.341]                   NAME <- NAMES[[kk]]
[17:39:20.341]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.341]                     next
[17:39:20.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.341]                 }
[17:39:20.341]                 NAMES <- toupper(added)
[17:39:20.341]                 for (kk in seq_along(NAMES)) {
[17:39:20.341]                   name <- added[[kk]]
[17:39:20.341]                   NAME <- NAMES[[kk]]
[17:39:20.341]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.341]                     next
[17:39:20.341]                   args[[name]] <- ""
[17:39:20.341]                 }
[17:39:20.341]                 NAMES <- toupper(removed)
[17:39:20.341]                 for (kk in seq_along(NAMES)) {
[17:39:20.341]                   name <- removed[[kk]]
[17:39:20.341]                   NAME <- NAMES[[kk]]
[17:39:20.341]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.341]                     next
[17:39:20.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.341]                 }
[17:39:20.341]                 if (length(args) > 0) 
[17:39:20.341]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.341]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.341]             }
[17:39:20.341]             else {
[17:39:20.341]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.341]             }
[17:39:20.341]             {
[17:39:20.341]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.341]                   0L) {
[17:39:20.341]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.341]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.341]                   base::options(opts)
[17:39:20.341]                 }
[17:39:20.341]                 {
[17:39:20.341]                   {
[17:39:20.341]                     NULL
[17:39:20.341]                     RNGkind("Mersenne-Twister")
[17:39:20.341]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:20.341]                       inherits = FALSE)
[17:39:20.341]                   }
[17:39:20.341]                   options(future.plan = NULL)
[17:39:20.341]                   if (is.na(NA_character_)) 
[17:39:20.341]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.341]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.341]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.341]                   {
[17:39:20.341]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.341]                     if (!future$lazy) 
[17:39:20.341]                       future <- run(future)
[17:39:20.341]                     invisible(future)
[17:39:20.341]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.341]                 }
[17:39:20.341]             }
[17:39:20.341]         }
[17:39:20.341]     })
[17:39:20.341]     if (TRUE) {
[17:39:20.341]         base::sink(type = "output", split = FALSE)
[17:39:20.341]         if (TRUE) {
[17:39:20.341]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.341]         }
[17:39:20.341]         else {
[17:39:20.341]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.341]         }
[17:39:20.341]         base::close(...future.stdout)
[17:39:20.341]         ...future.stdout <- NULL
[17:39:20.341]     }
[17:39:20.341]     ...future.result$conditions <- ...future.conditions
[17:39:20.341]     ...future.result$finished <- base::Sys.time()
[17:39:20.341]     ...future.result
[17:39:20.341] }
[17:39:20.343] assign_globals() ...
[17:39:20.343] List of 5
[17:39:20.343]  $ future.call.arguments    : list()
[17:39:20.343]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.343]  $ ...future.FUN            :function (x)  
[17:39:20.343]  $ ...future.elements_ii    :List of 2
[17:39:20.343]   ..$ : int [1:2] 1 3
[17:39:20.343]   ..$ : int [1:2] 2 4
[17:39:20.343]  $ ...future.seeds_ii       : NULL
[17:39:20.343]  $ ...future.globals.maxSize: num Inf
[17:39:20.343]  - attr(*, "resolved")= logi FALSE
[17:39:20.343]  - attr(*, "total_size")= num NA
[17:39:20.343]  - attr(*, "where")=List of 5
[17:39:20.343]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.343]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.343]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.343]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.343]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.343]  - attr(*, "already-done")= logi TRUE
[17:39:20.348] - copied ‘future.call.arguments’ to environment
[17:39:20.348] - reassign environment for ‘...future.FUN’
[17:39:20.348] - copied ‘...future.FUN’ to environment
[17:39:20.348] - copied ‘...future.elements_ii’ to environment
[17:39:20.348] - copied ‘...future.seeds_ii’ to environment
[17:39:20.348] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.348] assign_globals() ... done
[17:39:20.349] plan(): Setting new future strategy stack:
[17:39:20.349] List of future strategies:
[17:39:20.349] 1. sequential:
[17:39:20.349]    - args: function (..., envir = parent.frame())
[17:39:20.349]    - tweaked: FALSE
[17:39:20.349]    - call: NULL
[17:39:20.350] plan(): nbrOfWorkers() = 1
[17:39:20.351] plan(): Setting new future strategy stack:
[17:39:20.351] List of future strategies:
[17:39:20.351] 1. sequential:
[17:39:20.351]    - args: function (..., envir = parent.frame())
[17:39:20.351]    - tweaked: FALSE
[17:39:20.351]    - call: plan(strategy)
[17:39:20.352] plan(): nbrOfWorkers() = 1
[17:39:20.352] SequentialFuture started (and completed)
[17:39:20.352] - Launch lazy future ... done
[17:39:20.352] run() for ‘SequentialFuture’ ... done
[17:39:20.352] Created future:
[17:39:20.352] SequentialFuture:
[17:39:20.352] Label: ‘future_apply-1’
[17:39:20.352] Expression:
[17:39:20.352] {
[17:39:20.352]     do.call(function(...) {
[17:39:20.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.352]             on.exit(options(oopts), add = TRUE)
[17:39:20.352]         }
[17:39:20.352]         {
[17:39:20.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.352]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.352]             })
[17:39:20.352]         }
[17:39:20.352]     }, args = future.call.arguments)
[17:39:20.352] }
[17:39:20.352] Lazy evaluation: FALSE
[17:39:20.352] Asynchronous evaluation: FALSE
[17:39:20.352] Local evaluation: TRUE
[17:39:20.352] Environment: R_GlobalEnv
[17:39:20.352] Capture standard output: TRUE
[17:39:20.352] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.352] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.352] Packages: <none>
[17:39:20.352] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.352] Resolved: TRUE
[17:39:20.352] Value: 400 bytes of class ‘list’
[17:39:20.352] Early signaling: FALSE
[17:39:20.352] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.352] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.353] Chunk #1 of 1 ... DONE
[17:39:20.353] Launching 1 futures (chunks) ... DONE
[17:39:20.354] Resolving 1 futures (chunks) ...
[17:39:20.354] resolve() on list ...
[17:39:20.354]  recursive: 0
[17:39:20.354]  length: 1
[17:39:20.354] 
[17:39:20.354] resolved() for ‘SequentialFuture’ ...
[17:39:20.354] - state: ‘finished’
[17:39:20.354] - run: TRUE
[17:39:20.354] - result: ‘FutureResult’
[17:39:20.354] resolved() for ‘SequentialFuture’ ... done
[17:39:20.355] Future #1
[17:39:20.355] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.355] - nx: 1
[17:39:20.355] - relay: TRUE
[17:39:20.355] - stdout: TRUE
[17:39:20.355] - signal: TRUE
[17:39:20.355] - resignal: FALSE
[17:39:20.355] - force: TRUE
[17:39:20.355] - relayed: [n=1] FALSE
[17:39:20.355] - queued futures: [n=1] FALSE
[17:39:20.356]  - until=1
[17:39:20.356]  - relaying element #1
[17:39:20.356] - relayed: [n=1] TRUE
[17:39:20.356] - queued futures: [n=1] TRUE
[17:39:20.356] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.356]  length: 0 (resolved future 1)
[17:39:20.356] Relaying remaining futures
[17:39:20.356] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.356] - nx: 1
[17:39:20.356] - relay: TRUE
[17:39:20.356] - stdout: TRUE
[17:39:20.357] - signal: TRUE
[17:39:20.357] - resignal: FALSE
[17:39:20.357] - force: TRUE
[17:39:20.357] - relayed: [n=1] TRUE
[17:39:20.357] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.357] - relayed: [n=1] TRUE
[17:39:20.357] - queued futures: [n=1] TRUE
[17:39:20.357] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.357] resolve() on list ... DONE
[17:39:20.357]  - Number of value chunks collected: 1
[17:39:20.358] Resolving 1 futures (chunks) ... DONE
[17:39:20.358] Reducing values from 1 chunks ...
[17:39:20.358]  - Number of values collected after concatenation: 2
[17:39:20.358]  - Number of values expected: 2
[17:39:20.358] Reducing values from 1 chunks ... DONE
[17:39:20.358] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:39:20.358] getGlobalsAndPackagesXApply() ...
[17:39:20.358]  - future.globals: TRUE
[17:39:20.358] getGlobalsAndPackages() ...
[17:39:20.359] Searching for globals...
[17:39:20.361] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:39:20.361] Searching for globals ... DONE
[17:39:20.362] Resolving globals: FALSE
[17:39:20.362] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:39:20.362] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:39:20.363] - globals: [1] ‘FUN’
[17:39:20.363] 
[17:39:20.363] getGlobalsAndPackages() ... DONE
[17:39:20.363]  - globals found/used: [n=1] ‘FUN’
[17:39:20.363]  - needed namespaces: [n=0] 
[17:39:20.363] Finding globals ... DONE
[17:39:20.363]  - use_args: TRUE
[17:39:20.363]  - Getting '...' globals ...
[17:39:20.364] resolve() on list ...
[17:39:20.364]  recursive: 0
[17:39:20.364]  length: 1
[17:39:20.364]  elements: ‘...’
[17:39:20.364]  length: 0 (resolved future 1)
[17:39:20.364] resolve() on list ... DONE
[17:39:20.364]    - '...' content: [n=0] 
[17:39:20.364] List of 1
[17:39:20.364]  $ ...: list()
[17:39:20.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.364]  - attr(*, "where")=List of 1
[17:39:20.364]   ..$ ...:<environment: 0x55c794aded60> 
[17:39:20.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.364]  - attr(*, "resolved")= logi TRUE
[17:39:20.364]  - attr(*, "total_size")= num NA
[17:39:20.367]  - Getting '...' globals ... DONE
[17:39:20.367] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.367] List of 2
[17:39:20.367]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:39:20.367]  $ ...          : list()
[17:39:20.367]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.367]  - attr(*, "where")=List of 2
[17:39:20.367]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.367]   ..$ ...          :<environment: 0x55c794aded60> 
[17:39:20.367]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.367]  - attr(*, "resolved")= logi FALSE
[17:39:20.367]  - attr(*, "total_size")= num 36296
[17:39:20.369] Packages to be attached in all futures: [n=0] 
[17:39:20.370] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.370] future_lapply() ...
[17:39:20.373] Generating random seeds ...
[17:39:20.373] Generating random seed streams for 2 elements ...
[17:39:20.373] Generating random seed streams for 2 elements ... DONE
[17:39:20.373] Generating random seeds ... DONE
[17:39:20.374] Will set RNG state on exit: 10407, -440102059, 1015864502, 2053933985, -1684567888, 1274508786, -1133242626
[17:39:20.374] Number of chunks: 1
[17:39:20.374] getGlobalsAndPackagesXApply() ...
[17:39:20.374]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.374]  - use_args: TRUE
[17:39:20.374] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.374] List of 2
[17:39:20.374]  $ ...          : list()
[17:39:20.374]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.374]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:39:20.374]  - attr(*, "where")=List of 2
[17:39:20.374]   ..$ ...          :<environment: 0x55c794aded60> 
[17:39:20.374]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.374]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.374]  - attr(*, "resolved")= logi FALSE
[17:39:20.374]  - attr(*, "total_size")= num NA
[17:39:20.377] Packages to be attached in all futures: [n=0] 
[17:39:20.378] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.378] Number of futures (= number of chunks): 1
[17:39:20.378] Launching 1 futures (chunks) ...
[17:39:20.378] Chunk #1 of 1 ...
[17:39:20.378]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:39:20.378]  - seeds: [2] <seeds>
[17:39:20.378] getGlobalsAndPackages() ...
[17:39:20.378] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.379] Resolving globals: FALSE
[17:39:20.379] Tweak future expression to call with '...' arguments ...
[17:39:20.379] {
[17:39:20.379]     do.call(function(...) {
[17:39:20.379]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.379]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.379]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.379]             on.exit(options(oopts), add = TRUE)
[17:39:20.379]         }
[17:39:20.379]         {
[17:39:20.379]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.379]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.379]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:20.379]                   envir = globalenv(), inherits = FALSE)
[17:39:20.379]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.379]             })
[17:39:20.379]         }
[17:39:20.379]     }, args = future.call.arguments)
[17:39:20.379] }
[17:39:20.379] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.379] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.380] 
[17:39:20.380] getGlobalsAndPackages() ... DONE
[17:39:20.380] run() for ‘Future’ ...
[17:39:20.380] - state: ‘created’
[17:39:20.380] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:20.380] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:20.381]   - Field: ‘label’
[17:39:20.381]   - Field: ‘local’
[17:39:20.381]   - Field: ‘owner’
[17:39:20.381]   - Field: ‘envir’
[17:39:20.381]   - Field: ‘packages’
[17:39:20.381]   - Field: ‘gc’
[17:39:20.381]   - Field: ‘conditions’
[17:39:20.381]   - Field: ‘expr’
[17:39:20.381]   - Field: ‘uuid’
[17:39:20.381]   - Field: ‘seed’
[17:39:20.382]   - Field: ‘version’
[17:39:20.382]   - Field: ‘result’
[17:39:20.382]   - Field: ‘asynchronous’
[17:39:20.382]   - Field: ‘calls’
[17:39:20.382]   - Field: ‘globals’
[17:39:20.382]   - Field: ‘stdout’
[17:39:20.382]   - Field: ‘earlySignal’
[17:39:20.382]   - Field: ‘lazy’
[17:39:20.382]   - Field: ‘state’
[17:39:20.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:20.382] - Launch lazy future ...
[17:39:20.383] Packages needed by the future expression (n = 0): <none>
[17:39:20.383] Packages needed by future strategies (n = 0): <none>
[17:39:20.383] {
[17:39:20.383]     {
[17:39:20.383]         {
[17:39:20.383]             ...future.startTime <- base::Sys.time()
[17:39:20.383]             {
[17:39:20.383]                 {
[17:39:20.383]                   {
[17:39:20.383]                     base::local({
[17:39:20.383]                       has_future <- base::requireNamespace("future", 
[17:39:20.383]                         quietly = TRUE)
[17:39:20.383]                       if (has_future) {
[17:39:20.383]                         ns <- base::getNamespace("future")
[17:39:20.383]                         version <- ns[[".package"]][["version"]]
[17:39:20.383]                         if (is.null(version)) 
[17:39:20.383]                           version <- utils::packageVersion("future")
[17:39:20.383]                       }
[17:39:20.383]                       else {
[17:39:20.383]                         version <- NULL
[17:39:20.383]                       }
[17:39:20.383]                       if (!has_future || version < "1.8.0") {
[17:39:20.383]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.383]                           "", base::R.version$version.string), 
[17:39:20.383]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:20.383]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.383]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.383]                             "release", "version")], collapse = " "), 
[17:39:20.383]                           hostname = base::Sys.info()[["nodename"]])
[17:39:20.383]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.383]                           info)
[17:39:20.383]                         info <- base::paste(info, collapse = "; ")
[17:39:20.383]                         if (!has_future) {
[17:39:20.383]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.383]                             info)
[17:39:20.383]                         }
[17:39:20.383]                         else {
[17:39:20.383]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.383]                             info, version)
[17:39:20.383]                         }
[17:39:20.383]                         base::stop(msg)
[17:39:20.383]                       }
[17:39:20.383]                     })
[17:39:20.383]                   }
[17:39:20.383]                   options(future.plan = NULL)
[17:39:20.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.383]                 }
[17:39:20.383]                 ...future.workdir <- getwd()
[17:39:20.383]             }
[17:39:20.383]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.383]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.383]         }
[17:39:20.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.383]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.383]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.383]             base::names(...future.oldOptions))
[17:39:20.383]     }
[17:39:20.383]     if (FALSE) {
[17:39:20.383]     }
[17:39:20.383]     else {
[17:39:20.383]         if (TRUE) {
[17:39:20.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.383]                 open = "w")
[17:39:20.383]         }
[17:39:20.383]         else {
[17:39:20.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.383]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.383]         }
[17:39:20.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.383]             base::sink(type = "output", split = FALSE)
[17:39:20.383]             base::close(...future.stdout)
[17:39:20.383]         }, add = TRUE)
[17:39:20.383]     }
[17:39:20.383]     ...future.frame <- base::sys.nframe()
[17:39:20.383]     ...future.conditions <- base::list()
[17:39:20.383]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.383]     if (FALSE) {
[17:39:20.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.383]     }
[17:39:20.383]     ...future.result <- base::tryCatch({
[17:39:20.383]         base::withCallingHandlers({
[17:39:20.383]             ...future.value <- base::withVisible(base::local({
[17:39:20.383]                 do.call(function(...) {
[17:39:20.383]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.383]                   if (!identical(...future.globals.maxSize.org, 
[17:39:20.383]                     ...future.globals.maxSize)) {
[17:39:20.383]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.383]                     on.exit(options(oopts), add = TRUE)
[17:39:20.383]                   }
[17:39:20.383]                   {
[17:39:20.383]                     lapply(seq_along(...future.elements_ii), 
[17:39:20.383]                       FUN = function(jj) {
[17:39:20.383]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.383]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:20.383]                           envir = globalenv(), inherits = FALSE)
[17:39:20.383]                         ...future.FUN(...future.X_jj, ...)
[17:39:20.383]                       })
[17:39:20.383]                   }
[17:39:20.383]                 }, args = future.call.arguments)
[17:39:20.383]             }))
[17:39:20.383]             future::FutureResult(value = ...future.value$value, 
[17:39:20.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.383]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.383]                     ...future.globalenv.names))
[17:39:20.383]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.383]         }, condition = base::local({
[17:39:20.383]             c <- base::c
[17:39:20.383]             inherits <- base::inherits
[17:39:20.383]             invokeRestart <- base::invokeRestart
[17:39:20.383]             length <- base::length
[17:39:20.383]             list <- base::list
[17:39:20.383]             seq.int <- base::seq.int
[17:39:20.383]             signalCondition <- base::signalCondition
[17:39:20.383]             sys.calls <- base::sys.calls
[17:39:20.383]             `[[` <- base::`[[`
[17:39:20.383]             `+` <- base::`+`
[17:39:20.383]             `<<-` <- base::`<<-`
[17:39:20.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.383]                   3L)]
[17:39:20.383]             }
[17:39:20.383]             function(cond) {
[17:39:20.383]                 is_error <- inherits(cond, "error")
[17:39:20.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.383]                   NULL)
[17:39:20.383]                 if (is_error) {
[17:39:20.383]                   sessionInformation <- function() {
[17:39:20.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.383]                       search = base::search(), system = base::Sys.info())
[17:39:20.383]                   }
[17:39:20.383]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.383]                     cond$call), session = sessionInformation(), 
[17:39:20.383]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.383]                   signalCondition(cond)
[17:39:20.383]                 }
[17:39:20.383]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[17:39:20.383]                   signal <- TRUE && inherits(cond, character(0))
[17:39:20.383]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.383]                   if (TRUE && !signal) {
[17:39:20.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.383]                     {
[17:39:20.383]                       inherits <- base::inherits
[17:39:20.383]                       invokeRestart <- base::invokeRestart
[17:39:20.383]                       is.null <- base::is.null
[17:39:20.383]                       muffled <- FALSE
[17:39:20.383]                       if (inherits(cond, "message")) {
[17:39:20.383]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.383]                         if (muffled) 
[17:39:20.383]                           invokeRestart("muffleMessage")
[17:39:20.383]                       }
[17:39:20.383]                       else if (inherits(cond, "warning")) {
[17:39:20.383]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.383]                         if (muffled) 
[17:39:20.383]                           invokeRestart("muffleWarning")
[17:39:20.383]                       }
[17:39:20.383]                       else if (inherits(cond, "condition")) {
[17:39:20.383]                         if (!is.null(pattern)) {
[17:39:20.383]                           computeRestarts <- base::computeRestarts
[17:39:20.383]                           grepl <- base::grepl
[17:39:20.383]                           restarts <- computeRestarts(cond)
[17:39:20.383]                           for (restart in restarts) {
[17:39:20.383]                             name <- restart$name
[17:39:20.383]                             if (is.null(name)) 
[17:39:20.383]                               next
[17:39:20.383]                             if (!grepl(pattern, name)) 
[17:39:20.383]                               next
[17:39:20.383]                             invokeRestart(restart)
[17:39:20.383]                             muffled <- TRUE
[17:39:20.383]                             break
[17:39:20.383]                           }
[17:39:20.383]                         }
[17:39:20.383]                       }
[17:39:20.383]                       invisible(muffled)
[17:39:20.383]                     }
[17:39:20.383]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.383]                   }
[17:39:20.383]                 }
[17:39:20.383]                 else {
[17:39:20.383]                   if (FALSE) {
[17:39:20.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.383]                     {
[17:39:20.383]                       inherits <- base::inherits
[17:39:20.383]                       invokeRestart <- base::invokeRestart
[17:39:20.383]                       is.null <- base::is.null
[17:39:20.383]                       muffled <- FALSE
[17:39:20.383]                       if (inherits(cond, "message")) {
[17:39:20.383]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.383]                         if (muffled) 
[17:39:20.383]                           invokeRestart("muffleMessage")
[17:39:20.383]                       }
[17:39:20.383]                       else if (inherits(cond, "warning")) {
[17:39:20.383]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.383]                         if (muffled) 
[17:39:20.383]                           invokeRestart("muffleWarning")
[17:39:20.383]                       }
[17:39:20.383]                       else if (inherits(cond, "condition")) {
[17:39:20.383]                         if (!is.null(pattern)) {
[17:39:20.383]                           computeRestarts <- base::computeRestarts
[17:39:20.383]                           grepl <- base::grepl
[17:39:20.383]                           restarts <- computeRestarts(cond)
[17:39:20.383]                           for (restart in restarts) {
[17:39:20.383]                             name <- restart$name
[17:39:20.383]                             if (is.null(name)) 
[17:39:20.383]                               next
[17:39:20.383]                             if (!grepl(pattern, name)) 
[17:39:20.383]                               next
[17:39:20.383]                             invokeRestart(restart)
[17:39:20.383]                             muffled <- TRUE
[17:39:20.383]                             break
[17:39:20.383]                           }
[17:39:20.383]                         }
[17:39:20.383]                       }
[17:39:20.383]                       invisible(muffled)
[17:39:20.383]                     }
[17:39:20.383]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.383]                   }
[17:39:20.383]                 }
[17:39:20.383]             }
[17:39:20.383]         }))
[17:39:20.383]     }, error = function(ex) {
[17:39:20.383]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.383]                 ...future.rng), started = ...future.startTime, 
[17:39:20.383]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.383]             version = "1.8"), class = "FutureResult")
[17:39:20.383]     }, finally = {
[17:39:20.383]         if (!identical(...future.workdir, getwd())) 
[17:39:20.383]             setwd(...future.workdir)
[17:39:20.383]         {
[17:39:20.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.383]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.383]             }
[17:39:20.383]             base::options(...future.oldOptions)
[17:39:20.383]             if (.Platform$OS.type == "windows") {
[17:39:20.383]                 old_names <- names(...future.oldEnvVars)
[17:39:20.383]                 envs <- base::Sys.getenv()
[17:39:20.383]                 names <- names(envs)
[17:39:20.383]                 common <- intersect(names, old_names)
[17:39:20.383]                 added <- setdiff(names, old_names)
[17:39:20.383]                 removed <- setdiff(old_names, names)
[17:39:20.383]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.383]                   envs[common]]
[17:39:20.383]                 NAMES <- toupper(changed)
[17:39:20.383]                 args <- list()
[17:39:20.383]                 for (kk in seq_along(NAMES)) {
[17:39:20.383]                   name <- changed[[kk]]
[17:39:20.383]                   NAME <- NAMES[[kk]]
[17:39:20.383]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.383]                     next
[17:39:20.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.383]                 }
[17:39:20.383]                 NAMES <- toupper(added)
[17:39:20.383]                 for (kk in seq_along(NAMES)) {
[17:39:20.383]                   name <- added[[kk]]
[17:39:20.383]                   NAME <- NAMES[[kk]]
[17:39:20.383]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.383]                     next
[17:39:20.383]                   args[[name]] <- ""
[17:39:20.383]                 }
[17:39:20.383]                 NAMES <- toupper(removed)
[17:39:20.383]                 for (kk in seq_along(NAMES)) {
[17:39:20.383]                   name <- removed[[kk]]
[17:39:20.383]                   NAME <- NAMES[[kk]]
[17:39:20.383]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.383]                     next
[17:39:20.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.383]                 }
[17:39:20.383]                 if (length(args) > 0) 
[17:39:20.383]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.383]             }
[17:39:20.383]             else {
[17:39:20.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.383]             }
[17:39:20.383]             {
[17:39:20.383]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.383]                   0L) {
[17:39:20.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.383]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.383]                   base::options(opts)
[17:39:20.383]                 }
[17:39:20.383]                 {
[17:39:20.383]                   {
[17:39:20.383]                     base::assign(".Random.seed", c(10407L, -440102059L, 
[17:39:20.383]                     1015864502L, 2053933985L, -1684567888L, 1274508786L, 
[17:39:20.383]                     -1133242626L), envir = base::globalenv(), 
[17:39:20.383]                       inherits = FALSE)
[17:39:20.383]                     NULL
[17:39:20.383]                   }
[17:39:20.383]                   options(future.plan = NULL)
[17:39:20.383]                   if (is.na(NA_character_)) 
[17:39:20.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.383]                   future::plan(list(function (..., envir = parent.frame()) 
[17:39:20.383]                   {
[17:39:20.383]                     future <- SequentialFuture(..., envir = envir)
[17:39:20.383]                     if (!future$lazy) 
[17:39:20.383]                       future <- run(future)
[17:39:20.383]                     invisible(future)
[17:39:20.383]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.383]                 }
[17:39:20.383]             }
[17:39:20.383]         }
[17:39:20.383]     })
[17:39:20.383]     if (TRUE) {
[17:39:20.383]         base::sink(type = "output", split = FALSE)
[17:39:20.383]         if (TRUE) {
[17:39:20.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.383]         }
[17:39:20.383]         else {
[17:39:20.383]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.383]         }
[17:39:20.383]         base::close(...future.stdout)
[17:39:20.383]         ...future.stdout <- NULL
[17:39:20.383]     }
[17:39:20.383]     ...future.result$conditions <- ...future.conditions
[17:39:20.383]     ...future.result$finished <- base::Sys.time()
[17:39:20.383]     ...future.result
[17:39:20.383] }
[17:39:20.385] assign_globals() ...
[17:39:20.385] List of 5
[17:39:20.385]  $ future.call.arguments    : list()
[17:39:20.385]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.385]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:39:20.385]  $ ...future.elements_ii    :List of 2
[17:39:20.385]   ..$ : int [1:2] 1 3
[17:39:20.385]   ..$ : int [1:2] 2 4
[17:39:20.385]  $ ...future.seeds_ii       :List of 2
[17:39:20.385]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:39:20.385]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:39:20.385]  $ ...future.globals.maxSize: num Inf
[17:39:20.385]  - attr(*, "resolved")= logi FALSE
[17:39:20.385]  - attr(*, "total_size")= num NA
[17:39:20.385]  - attr(*, "where")=List of 5
[17:39:20.385]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.385]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.385]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.385]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.385]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.385]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.385]  - attr(*, "already-done")= logi TRUE
[17:39:20.390] - copied ‘future.call.arguments’ to environment
[17:39:20.391] - copied ‘...future.FUN’ to environment
[17:39:20.391] - copied ‘...future.elements_ii’ to environment
[17:39:20.391] - copied ‘...future.seeds_ii’ to environment
[17:39:20.391] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.391] assign_globals() ... done
[17:39:20.391] plan(): Setting new future strategy stack:
[17:39:20.391] List of future strategies:
[17:39:20.391] 1. sequential:
[17:39:20.391]    - args: function (..., envir = parent.frame())
[17:39:20.391]    - tweaked: FALSE
[17:39:20.391]    - call: NULL
[17:39:20.392] plan(): nbrOfWorkers() = 1
[17:39:20.392] plan(): Setting new future strategy stack:
[17:39:20.392] List of future strategies:
[17:39:20.392] 1. sequential:
[17:39:20.392]    - args: function (..., envir = parent.frame())
[17:39:20.392]    - tweaked: FALSE
[17:39:20.392]    - call: plan(strategy)
[17:39:20.393] plan(): nbrOfWorkers() = 1
[17:39:20.393] SequentialFuture started (and completed)
[17:39:20.393] - Launch lazy future ... done
[17:39:20.393] run() for ‘SequentialFuture’ ... done
[17:39:20.393] Created future:
[17:39:20.393] SequentialFuture:
[17:39:20.393] Label: ‘future_apply-1’
[17:39:20.393] Expression:
[17:39:20.393] {
[17:39:20.393]     do.call(function(...) {
[17:39:20.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.393]             on.exit(options(oopts), add = TRUE)
[17:39:20.393]         }
[17:39:20.393]         {
[17:39:20.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.393]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:20.393]                   envir = globalenv(), inherits = FALSE)
[17:39:20.393]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.393]             })
[17:39:20.393]         }
[17:39:20.393]     }, args = future.call.arguments)
[17:39:20.393] }
[17:39:20.393] Lazy evaluation: FALSE
[17:39:20.393] Asynchronous evaluation: FALSE
[17:39:20.393] Local evaluation: TRUE
[17:39:20.393] Environment: R_GlobalEnv
[17:39:20.393] Capture standard output: TRUE
[17:39:20.393] Capture condition classes: <none>
[17:39:20.393] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:20.393] Packages: <none>
[17:39:20.393] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:39:20.393] Resolved: TRUE
[17:39:20.393] Value: 112 bytes of class ‘list’
[17:39:20.393] Early signaling: FALSE
[17:39:20.393] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.393] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:20.394] Chunk #1 of 1 ... DONE
[17:39:20.394] Launching 1 futures (chunks) ... DONE
[17:39:20.395] Resolving 1 futures (chunks) ...
[17:39:20.395] resolve() on list ...
[17:39:20.396]  recursive: 0
[17:39:20.396]  length: 1
[17:39:20.396] 
[17:39:20.396] resolved() for ‘SequentialFuture’ ...
[17:39:20.396] - state: ‘finished’
[17:39:20.396] - run: TRUE
[17:39:20.396] - result: ‘FutureResult’
[17:39:20.396] resolved() for ‘SequentialFuture’ ... done
[17:39:20.396] Future #1
[17:39:20.397] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:39:20.397] - nx: 1
[17:39:20.397] - relay: TRUE
[17:39:20.397] - stdout: TRUE
[17:39:20.397] - signal: TRUE
[17:39:20.397] - resignal: FALSE
[17:39:20.397] - force: TRUE
[17:39:20.397] - relayed: [n=1] FALSE
[17:39:20.397] - queued futures: [n=1] FALSE
[17:39:20.397]  - until=1
[17:39:20.398]  - relaying element #1
[17:39:20.398] - relayed: [n=1] TRUE
[17:39:20.398] - queued futures: [n=1] TRUE
[17:39:20.398] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:39:20.398]  length: 0 (resolved future 1)
[17:39:20.398] Relaying remaining futures
[17:39:20.398] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.398] - nx: 1
[17:39:20.398] - relay: TRUE
[17:39:20.398] - stdout: TRUE
[17:39:20.399] - signal: TRUE
[17:39:20.399] - resignal: FALSE
[17:39:20.399] - force: TRUE
[17:39:20.399] - relayed: [n=1] TRUE
[17:39:20.399] - queued futures: [n=1] TRUE
 - flush all
[17:39:20.399] - relayed: [n=1] TRUE
[17:39:20.399] - queued futures: [n=1] TRUE
[17:39:20.399] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.399] resolve() on list ... DONE
[17:39:20.399]  - Number of value chunks collected: 1
[17:39:20.399] Resolving 1 futures (chunks) ... DONE
[17:39:20.400] Reducing values from 1 chunks ...
[17:39:20.400]  - Number of values collected after concatenation: 2
[17:39:20.400]  - Number of values expected: 2
[17:39:20.400] Reducing values from 1 chunks ... DONE
[17:39:20.400] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:39:20.400] plan(): Setting new future strategy stack:
[17:39:20.400] List of future strategies:
[17:39:20.400] 1. sequential:
[17:39:20.400]    - args: function (..., envir = parent.frame())
[17:39:20.400]    - tweaked: FALSE
[17:39:20.400]    - call: plan(sequential)
[17:39:20.401] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:39:20.401] plan(): Setting new future strategy stack:
[17:39:20.401] List of future strategies:
[17:39:20.401] 1. multicore:
[17:39:20.401]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.401]    - tweaked: FALSE
[17:39:20.401]    - call: plan(strategy)
[17:39:20.405] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[17:39:20.405] getGlobalsAndPackagesXApply() ...
[17:39:20.406]  - future.globals: TRUE
[17:39:20.406] getGlobalsAndPackages() ...
[17:39:20.406] Searching for globals...
[17:39:20.439] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:39:20.440] Searching for globals ... DONE
[17:39:20.440] Resolving globals: FALSE
[17:39:20.441] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:39:20.442] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:39:20.442] - globals: [1] ‘FUN’
[17:39:20.442] 
[17:39:20.442] getGlobalsAndPackages() ... DONE
[17:39:20.442]  - globals found/used: [n=1] ‘FUN’
[17:39:20.442]  - needed namespaces: [n=0] 
[17:39:20.442] Finding globals ... DONE
[17:39:20.442]  - use_args: TRUE
[17:39:20.443]  - Getting '...' globals ...
[17:39:20.443] resolve() on list ...
[17:39:20.443]  recursive: 0
[17:39:20.443]  length: 1
[17:39:20.443]  elements: ‘...’
[17:39:20.443]  length: 0 (resolved future 1)
[17:39:20.443] resolve() on list ... DONE
[17:39:20.443]    - '...' content: [n=0] 
[17:39:20.444] List of 1
[17:39:20.444]  $ ...: list()
[17:39:20.444]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.444]  - attr(*, "where")=List of 1
[17:39:20.444]   ..$ ...:<environment: 0x55c794b0be50> 
[17:39:20.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.444]  - attr(*, "resolved")= logi TRUE
[17:39:20.444]  - attr(*, "total_size")= num NA
[17:39:20.446]  - Getting '...' globals ... DONE
[17:39:20.446] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.446] List of 2
[17:39:20.446]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.446]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.446]  $ ...          : list()
[17:39:20.446]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.446]  - attr(*, "where")=List of 2
[17:39:20.446]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.446]   ..$ ...          :<environment: 0x55c794b0be50> 
[17:39:20.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.446]  - attr(*, "resolved")= logi FALSE
[17:39:20.446]  - attr(*, "total_size")= num 354224
[17:39:20.449] Packages to be attached in all futures: [n=0] 
[17:39:20.449] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.453] future_lapply() ...
[17:39:20.489] Number of chunks: 2
[17:39:20.489] getGlobalsAndPackagesXApply() ...
[17:39:20.489]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.489]  - use_args: TRUE
[17:39:20.489] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.489] List of 2
[17:39:20.489]  $ ...          : list()
[17:39:20.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.489]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.489]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.489]  - attr(*, "where")=List of 2
[17:39:20.489]   ..$ ...          :<environment: 0x55c794b0be50> 
[17:39:20.489]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.489]  - attr(*, "resolved")= logi FALSE
[17:39:20.489]  - attr(*, "total_size")= num NA
[17:39:20.494] Packages to be attached in all futures: [n=0] 
[17:39:20.494] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.494] Number of futures (= number of chunks): 2
[17:39:20.494] Launching 2 futures (chunks) ...
[17:39:20.494] Chunk #1 of 2 ...
[17:39:20.495]  - seeds: <none>
[17:39:20.495] getGlobalsAndPackages() ...
[17:39:20.495] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.495] Resolving globals: FALSE
[17:39:20.495] Tweak future expression to call with '...' arguments ...
[17:39:20.495] {
[17:39:20.495]     do.call(function(...) {
[17:39:20.495]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.495]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.495]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.495]             on.exit(options(oopts), add = TRUE)
[17:39:20.495]         }
[17:39:20.495]         {
[17:39:20.495]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.495]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.495]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.495]             })
[17:39:20.495]         }
[17:39:20.495]     }, args = future.call.arguments)
[17:39:20.495] }
[17:39:20.496] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.496] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.496] 
[17:39:20.496] getGlobalsAndPackages() ... DONE
[17:39:20.496] run() for ‘Future’ ...
[17:39:20.497] - state: ‘created’
[17:39:20.497] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:20.500] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:20.501]   - Field: ‘label’
[17:39:20.501]   - Field: ‘local’
[17:39:20.501]   - Field: ‘owner’
[17:39:20.501]   - Field: ‘envir’
[17:39:20.501]   - Field: ‘workers’
[17:39:20.501]   - Field: ‘packages’
[17:39:20.501]   - Field: ‘gc’
[17:39:20.501]   - Field: ‘job’
[17:39:20.501]   - Field: ‘conditions’
[17:39:20.501]   - Field: ‘expr’
[17:39:20.502]   - Field: ‘uuid’
[17:39:20.502]   - Field: ‘seed’
[17:39:20.502]   - Field: ‘version’
[17:39:20.502]   - Field: ‘result’
[17:39:20.502]   - Field: ‘asynchronous’
[17:39:20.502]   - Field: ‘calls’
[17:39:20.502]   - Field: ‘globals’
[17:39:20.502]   - Field: ‘stdout’
[17:39:20.502]   - Field: ‘earlySignal’
[17:39:20.502]   - Field: ‘lazy’
[17:39:20.502]   - Field: ‘state’
[17:39:20.503] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:20.503] - Launch lazy future ...
[17:39:20.504] Packages needed by the future expression (n = 0): <none>
[17:39:20.504] Packages needed by future strategies (n = 0): <none>
[17:39:20.504] {
[17:39:20.504]     {
[17:39:20.504]         {
[17:39:20.504]             ...future.startTime <- base::Sys.time()
[17:39:20.504]             {
[17:39:20.504]                 {
[17:39:20.504]                   {
[17:39:20.504]                     {
[17:39:20.504]                       base::local({
[17:39:20.504]                         has_future <- base::requireNamespace("future", 
[17:39:20.504]                           quietly = TRUE)
[17:39:20.504]                         if (has_future) {
[17:39:20.504]                           ns <- base::getNamespace("future")
[17:39:20.504]                           version <- ns[[".package"]][["version"]]
[17:39:20.504]                           if (is.null(version)) 
[17:39:20.504]                             version <- utils::packageVersion("future")
[17:39:20.504]                         }
[17:39:20.504]                         else {
[17:39:20.504]                           version <- NULL
[17:39:20.504]                         }
[17:39:20.504]                         if (!has_future || version < "1.8.0") {
[17:39:20.504]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.504]                             "", base::R.version$version.string), 
[17:39:20.504]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:20.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.504]                               "release", "version")], collapse = " "), 
[17:39:20.504]                             hostname = base::Sys.info()[["nodename"]])
[17:39:20.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.504]                             info)
[17:39:20.504]                           info <- base::paste(info, collapse = "; ")
[17:39:20.504]                           if (!has_future) {
[17:39:20.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.504]                               info)
[17:39:20.504]                           }
[17:39:20.504]                           else {
[17:39:20.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.504]                               info, version)
[17:39:20.504]                           }
[17:39:20.504]                           base::stop(msg)
[17:39:20.504]                         }
[17:39:20.504]                       })
[17:39:20.504]                     }
[17:39:20.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:20.504]                     base::options(mc.cores = 1L)
[17:39:20.504]                   }
[17:39:20.504]                   options(future.plan = NULL)
[17:39:20.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.504]                 }
[17:39:20.504]                 ...future.workdir <- getwd()
[17:39:20.504]             }
[17:39:20.504]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.504]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.504]         }
[17:39:20.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.504]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.504]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.504]             base::names(...future.oldOptions))
[17:39:20.504]     }
[17:39:20.504]     if (FALSE) {
[17:39:20.504]     }
[17:39:20.504]     else {
[17:39:20.504]         if (TRUE) {
[17:39:20.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.504]                 open = "w")
[17:39:20.504]         }
[17:39:20.504]         else {
[17:39:20.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.504]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.504]         }
[17:39:20.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.504]             base::sink(type = "output", split = FALSE)
[17:39:20.504]             base::close(...future.stdout)
[17:39:20.504]         }, add = TRUE)
[17:39:20.504]     }
[17:39:20.504]     ...future.frame <- base::sys.nframe()
[17:39:20.504]     ...future.conditions <- base::list()
[17:39:20.504]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.504]     if (FALSE) {
[17:39:20.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.504]     }
[17:39:20.504]     ...future.result <- base::tryCatch({
[17:39:20.504]         base::withCallingHandlers({
[17:39:20.504]             ...future.value <- base::withVisible(base::local({
[17:39:20.504]                 withCallingHandlers({
[17:39:20.504]                   {
[17:39:20.504]                     do.call(function(...) {
[17:39:20.504]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.504]                       if (!identical(...future.globals.maxSize.org, 
[17:39:20.504]                         ...future.globals.maxSize)) {
[17:39:20.504]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.504]                         on.exit(options(oopts), add = TRUE)
[17:39:20.504]                       }
[17:39:20.504]                       {
[17:39:20.504]                         lapply(seq_along(...future.elements_ii), 
[17:39:20.504]                           FUN = function(jj) {
[17:39:20.504]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.504]                             ...future.FUN(...future.X_jj, ...)
[17:39:20.504]                           })
[17:39:20.504]                       }
[17:39:20.504]                     }, args = future.call.arguments)
[17:39:20.504]                   }
[17:39:20.504]                 }, immediateCondition = function(cond) {
[17:39:20.504]                   save_rds <- function (object, pathname, ...) 
[17:39:20.504]                   {
[17:39:20.504]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:20.504]                     if (file_test("-f", pathname_tmp)) {
[17:39:20.504]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.504]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:20.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.504]                         fi_tmp[["mtime"]])
[17:39:20.504]                     }
[17:39:20.504]                     tryCatch({
[17:39:20.504]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:20.504]                     }, error = function(ex) {
[17:39:20.504]                       msg <- conditionMessage(ex)
[17:39:20.504]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.504]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:20.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.504]                         fi_tmp[["mtime"]], msg)
[17:39:20.504]                       ex$message <- msg
[17:39:20.504]                       stop(ex)
[17:39:20.504]                     })
[17:39:20.504]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:20.504]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:20.504]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:20.504]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.504]                       fi <- file.info(pathname)
[17:39:20.504]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:20.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.504]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:20.504]                         fi[["size"]], fi[["mtime"]])
[17:39:20.504]                       stop(msg)
[17:39:20.504]                     }
[17:39:20.504]                     invisible(pathname)
[17:39:20.504]                   }
[17:39:20.504]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:20.504]                     rootPath = tempdir()) 
[17:39:20.504]                   {
[17:39:20.504]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:20.504]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:20.504]                       tmpdir = path, fileext = ".rds")
[17:39:20.504]                     save_rds(obj, file)
[17:39:20.504]                   }
[17:39:20.504]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:20.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.504]                   {
[17:39:20.504]                     inherits <- base::inherits
[17:39:20.504]                     invokeRestart <- base::invokeRestart
[17:39:20.504]                     is.null <- base::is.null
[17:39:20.504]                     muffled <- FALSE
[17:39:20.504]                     if (inherits(cond, "message")) {
[17:39:20.504]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:20.504]                       if (muffled) 
[17:39:20.504]                         invokeRestart("muffleMessage")
[17:39:20.504]                     }
[17:39:20.504]                     else if (inherits(cond, "warning")) {
[17:39:20.504]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:20.504]                       if (muffled) 
[17:39:20.504]                         invokeRestart("muffleWarning")
[17:39:20.504]                     }
[17:39:20.504]                     else if (inherits(cond, "condition")) {
[17:39:20.504]                       if (!is.null(pattern)) {
[17:39:20.504]                         computeRestarts <- base::computeRestarts
[17:39:20.504]                         grepl <- base::grepl
[17:39:20.504]                         restarts <- computeRestarts(cond)
[17:39:20.504]                         for (restart in restarts) {
[17:39:20.504]                           name <- restart$name
[17:39:20.504]                           if (is.null(name)) 
[17:39:20.504]                             next
[17:39:20.504]                           if (!grepl(pattern, name)) 
[17:39:20.504]                             next
[17:39:20.504]                           invokeRestart(restart)
[17:39:20.504]                           muffled <- TRUE
[17:39:20.504]                           break
[17:39:20.504]                         }
[17:39:20.504]                       }
[17:39:20.504]                     }
[17:39:20.504]                     invisible(muffled)
[17:39:20.504]                   }
[17:39:20.504]                   muffleCondition(cond)
[17:39:20.504]                 })
[17:39:20.504]             }))
[17:39:20.504]             future::FutureResult(value = ...future.value$value, 
[17:39:20.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.504]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.504]                     ...future.globalenv.names))
[17:39:20.504]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.504]         }, condition = base::local({
[17:39:20.504]             c <- base::c
[17:39:20.504]             inherits <- base::inherits
[17:39:20.504]             invokeRestart <- base::invokeRestart
[17:39:20.504]             length <- base::length
[17:39:20.504]             list <- base::list
[17:39:20.504]             seq.int <- base::seq.int
[17:39:20.504]             signalCondition <- base::signalCondition
[17:39:20.504]             sys.calls <- base::sys.calls
[17:39:20.504]             `[[` <- base::`[[`
[17:39:20.504]             `+` <- base::`+`
[17:39:20.504]             `<<-` <- base::`<<-`
[17:39:20.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.504]                   3L)]
[17:39:20.504]             }
[17:39:20.504]             function(cond) {
[17:39:20.504]                 is_error <- inherits(cond, "error")
[17:39:20.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.504]                   NULL)
[17:39:20.504]                 if (is_error) {
[17:39:20.504]                   sessionInformation <- function() {
[17:39:20.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.504]                       search = base::search(), system = base::Sys.info())
[17:39:20.504]                   }
[17:39:20.504]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.504]                     cond$call), session = sessionInformation(), 
[17:39:20.504]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.504]                   signalCondition(cond)
[17:39:20.504]                 }
[17:39:20.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.504]                 "immediateCondition"))) {
[17:39:20.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.504]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.504]                   if (TRUE && !signal) {
[17:39:20.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.504]                     {
[17:39:20.504]                       inherits <- base::inherits
[17:39:20.504]                       invokeRestart <- base::invokeRestart
[17:39:20.504]                       is.null <- base::is.null
[17:39:20.504]                       muffled <- FALSE
[17:39:20.504]                       if (inherits(cond, "message")) {
[17:39:20.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.504]                         if (muffled) 
[17:39:20.504]                           invokeRestart("muffleMessage")
[17:39:20.504]                       }
[17:39:20.504]                       else if (inherits(cond, "warning")) {
[17:39:20.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.504]                         if (muffled) 
[17:39:20.504]                           invokeRestart("muffleWarning")
[17:39:20.504]                       }
[17:39:20.504]                       else if (inherits(cond, "condition")) {
[17:39:20.504]                         if (!is.null(pattern)) {
[17:39:20.504]                           computeRestarts <- base::computeRestarts
[17:39:20.504]                           grepl <- base::grepl
[17:39:20.504]                           restarts <- computeRestarts(cond)
[17:39:20.504]                           for (restart in restarts) {
[17:39:20.504]                             name <- restart$name
[17:39:20.504]                             if (is.null(name)) 
[17:39:20.504]                               next
[17:39:20.504]                             if (!grepl(pattern, name)) 
[17:39:20.504]                               next
[17:39:20.504]                             invokeRestart(restart)
[17:39:20.504]                             muffled <- TRUE
[17:39:20.504]                             break
[17:39:20.504]                           }
[17:39:20.504]                         }
[17:39:20.504]                       }
[17:39:20.504]                       invisible(muffled)
[17:39:20.504]                     }
[17:39:20.504]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.504]                   }
[17:39:20.504]                 }
[17:39:20.504]                 else {
[17:39:20.504]                   if (TRUE) {
[17:39:20.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.504]                     {
[17:39:20.504]                       inherits <- base::inherits
[17:39:20.504]                       invokeRestart <- base::invokeRestart
[17:39:20.504]                       is.null <- base::is.null
[17:39:20.504]                       muffled <- FALSE
[17:39:20.504]                       if (inherits(cond, "message")) {
[17:39:20.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.504]                         if (muffled) 
[17:39:20.504]                           invokeRestart("muffleMessage")
[17:39:20.504]                       }
[17:39:20.504]                       else if (inherits(cond, "warning")) {
[17:39:20.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.504]                         if (muffled) 
[17:39:20.504]                           invokeRestart("muffleWarning")
[17:39:20.504]                       }
[17:39:20.504]                       else if (inherits(cond, "condition")) {
[17:39:20.504]                         if (!is.null(pattern)) {
[17:39:20.504]                           computeRestarts <- base::computeRestarts
[17:39:20.504]                           grepl <- base::grepl
[17:39:20.504]                           restarts <- computeRestarts(cond)
[17:39:20.504]                           for (restart in restarts) {
[17:39:20.504]                             name <- restart$name
[17:39:20.504]                             if (is.null(name)) 
[17:39:20.504]                               next
[17:39:20.504]                             if (!grepl(pattern, name)) 
[17:39:20.504]                               next
[17:39:20.504]                             invokeRestart(restart)
[17:39:20.504]                             muffled <- TRUE
[17:39:20.504]                             break
[17:39:20.504]                           }
[17:39:20.504]                         }
[17:39:20.504]                       }
[17:39:20.504]                       invisible(muffled)
[17:39:20.504]                     }
[17:39:20.504]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.504]                   }
[17:39:20.504]                 }
[17:39:20.504]             }
[17:39:20.504]         }))
[17:39:20.504]     }, error = function(ex) {
[17:39:20.504]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.504]                 ...future.rng), started = ...future.startTime, 
[17:39:20.504]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.504]             version = "1.8"), class = "FutureResult")
[17:39:20.504]     }, finally = {
[17:39:20.504]         if (!identical(...future.workdir, getwd())) 
[17:39:20.504]             setwd(...future.workdir)
[17:39:20.504]         {
[17:39:20.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.504]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.504]             }
[17:39:20.504]             base::options(...future.oldOptions)
[17:39:20.504]             if (.Platform$OS.type == "windows") {
[17:39:20.504]                 old_names <- names(...future.oldEnvVars)
[17:39:20.504]                 envs <- base::Sys.getenv()
[17:39:20.504]                 names <- names(envs)
[17:39:20.504]                 common <- intersect(names, old_names)
[17:39:20.504]                 added <- setdiff(names, old_names)
[17:39:20.504]                 removed <- setdiff(old_names, names)
[17:39:20.504]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.504]                   envs[common]]
[17:39:20.504]                 NAMES <- toupper(changed)
[17:39:20.504]                 args <- list()
[17:39:20.504]                 for (kk in seq_along(NAMES)) {
[17:39:20.504]                   name <- changed[[kk]]
[17:39:20.504]                   NAME <- NAMES[[kk]]
[17:39:20.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.504]                     next
[17:39:20.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.504]                 }
[17:39:20.504]                 NAMES <- toupper(added)
[17:39:20.504]                 for (kk in seq_along(NAMES)) {
[17:39:20.504]                   name <- added[[kk]]
[17:39:20.504]                   NAME <- NAMES[[kk]]
[17:39:20.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.504]                     next
[17:39:20.504]                   args[[name]] <- ""
[17:39:20.504]                 }
[17:39:20.504]                 NAMES <- toupper(removed)
[17:39:20.504]                 for (kk in seq_along(NAMES)) {
[17:39:20.504]                   name <- removed[[kk]]
[17:39:20.504]                   NAME <- NAMES[[kk]]
[17:39:20.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.504]                     next
[17:39:20.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.504]                 }
[17:39:20.504]                 if (length(args) > 0) 
[17:39:20.504]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.504]             }
[17:39:20.504]             else {
[17:39:20.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.504]             }
[17:39:20.504]             {
[17:39:20.504]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.504]                   0L) {
[17:39:20.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.504]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.504]                   base::options(opts)
[17:39:20.504]                 }
[17:39:20.504]                 {
[17:39:20.504]                   {
[17:39:20.504]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:20.504]                     NULL
[17:39:20.504]                   }
[17:39:20.504]                   options(future.plan = NULL)
[17:39:20.504]                   if (is.na(NA_character_)) 
[17:39:20.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.504]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:20.504]                     envir = parent.frame()) 
[17:39:20.504]                   {
[17:39:20.504]                     default_workers <- missing(workers)
[17:39:20.504]                     if (is.function(workers)) 
[17:39:20.504]                       workers <- workers()
[17:39:20.504]                     workers <- structure(as.integer(workers), 
[17:39:20.504]                       class = class(workers))
[17:39:20.504]                     stop_if_not(is.finite(workers), workers >= 
[17:39:20.504]                       1L)
[17:39:20.504]                     if ((workers == 1L && !inherits(workers, 
[17:39:20.504]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:20.504]                       if (default_workers) 
[17:39:20.504]                         supportsMulticore(warn = TRUE)
[17:39:20.504]                       return(sequential(..., envir = envir))
[17:39:20.504]                     }
[17:39:20.504]                     oopts <- options(mc.cores = workers)
[17:39:20.504]                     on.exit(options(oopts))
[17:39:20.504]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:20.504]                       envir = envir)
[17:39:20.504]                     if (!future$lazy) 
[17:39:20.504]                       future <- run(future)
[17:39:20.504]                     invisible(future)
[17:39:20.504]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.504]                 }
[17:39:20.504]             }
[17:39:20.504]         }
[17:39:20.504]     })
[17:39:20.504]     if (TRUE) {
[17:39:20.504]         base::sink(type = "output", split = FALSE)
[17:39:20.504]         if (TRUE) {
[17:39:20.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.504]         }
[17:39:20.504]         else {
[17:39:20.504]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.504]         }
[17:39:20.504]         base::close(...future.stdout)
[17:39:20.504]         ...future.stdout <- NULL
[17:39:20.504]     }
[17:39:20.504]     ...future.result$conditions <- ...future.conditions
[17:39:20.504]     ...future.result$finished <- base::Sys.time()
[17:39:20.504]     ...future.result
[17:39:20.504] }
[17:39:20.507] assign_globals() ...
[17:39:20.507] List of 5
[17:39:20.507]  $ future.call.arguments    : list()
[17:39:20.507]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.507]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.507]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.507]  $ ...future.elements_ii    :List of 1
[17:39:20.507]   ..$ : num [1:4] 1 3 1 7
[17:39:20.507]  $ ...future.seeds_ii       : NULL
[17:39:20.507]  $ ...future.globals.maxSize: NULL
[17:39:20.507]  - attr(*, "where")=List of 5
[17:39:20.507]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.507]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.507]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.507]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.507]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.507]  - attr(*, "resolved")= logi FALSE
[17:39:20.507]  - attr(*, "total_size")= num NA
[17:39:20.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.507]  - attr(*, "already-done")= logi TRUE
[17:39:20.512] - copied ‘future.call.arguments’ to environment
[17:39:20.512] - copied ‘...future.FUN’ to environment
[17:39:20.512] - copied ‘...future.elements_ii’ to environment
[17:39:20.512] - copied ‘...future.seeds_ii’ to environment
[17:39:20.512] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.512] assign_globals() ... done
[17:39:20.512] requestCore(): workers = 2
[17:39:20.515] MulticoreFuture started
[17:39:20.516] - Launch lazy future ... done
[17:39:20.516] run() for ‘MulticoreFuture’ ... done
[17:39:20.516] plan(): Setting new future strategy stack:
[17:39:20.516] Created future:
[17:39:20.516] List of future strategies:
[17:39:20.516] 1. sequential:
[17:39:20.516]    - args: function (..., envir = parent.frame())
[17:39:20.516]    - tweaked: FALSE
[17:39:20.516]    - call: NULL
[17:39:20.517] plan(): nbrOfWorkers() = 1
[17:39:20.520] plan(): Setting new future strategy stack:
[17:39:20.520] List of future strategies:
[17:39:20.520] 1. multicore:
[17:39:20.520]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.520]    - tweaked: FALSE
[17:39:20.520]    - call: plan(strategy)
[17:39:20.524] plan(): nbrOfWorkers() = 2
[17:39:20.517] MulticoreFuture:
[17:39:20.517] Label: ‘future_apply-1’
[17:39:20.517] Expression:
[17:39:20.517] {
[17:39:20.517]     do.call(function(...) {
[17:39:20.517]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.517]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.517]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.517]             on.exit(options(oopts), add = TRUE)
[17:39:20.517]         }
[17:39:20.517]         {
[17:39:20.517]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.517]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.517]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.517]             })
[17:39:20.517]         }
[17:39:20.517]     }, args = future.call.arguments)
[17:39:20.517] }
[17:39:20.517] Lazy evaluation: FALSE
[17:39:20.517] Asynchronous evaluation: TRUE
[17:39:20.517] Local evaluation: TRUE
[17:39:20.517] Environment: R_GlobalEnv
[17:39:20.517] Capture standard output: TRUE
[17:39:20.517] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.517] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:20.517] Packages: <none>
[17:39:20.517] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.517] Resolved: TRUE
[17:39:20.517] Value: <not collected>
[17:39:20.517] Conditions captured: <none>
[17:39:20.517] Early signaling: FALSE
[17:39:20.517] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.517] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.526] Chunk #1 of 2 ... DONE
[17:39:20.526] Chunk #2 of 2 ...
[17:39:20.526]  - seeds: <none>
[17:39:20.526] getGlobalsAndPackages() ...
[17:39:20.526] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.527] Resolving globals: FALSE
[17:39:20.527] Tweak future expression to call with '...' arguments ...
[17:39:20.527] {
[17:39:20.527]     do.call(function(...) {
[17:39:20.527]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.527]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.527]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.527]             on.exit(options(oopts), add = TRUE)
[17:39:20.527]         }
[17:39:20.527]         {
[17:39:20.527]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.527]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.527]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.527]             })
[17:39:20.527]         }
[17:39:20.527]     }, args = future.call.arguments)
[17:39:20.527] }
[17:39:20.527] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.528] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.528] 
[17:39:20.528] getGlobalsAndPackages() ... DONE
[17:39:20.529] run() for ‘Future’ ...
[17:39:20.529] - state: ‘created’
[17:39:20.529] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:20.534] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.534] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:20.534]   - Field: ‘label’
[17:39:20.534]   - Field: ‘local’
[17:39:20.534]   - Field: ‘owner’
[17:39:20.535]   - Field: ‘envir’
[17:39:20.535]   - Field: ‘workers’
[17:39:20.535]   - Field: ‘packages’
[17:39:20.535]   - Field: ‘gc’
[17:39:20.535]   - Field: ‘job’
[17:39:20.535]   - Field: ‘conditions’
[17:39:20.535]   - Field: ‘expr’
[17:39:20.536]   - Field: ‘uuid’
[17:39:20.536]   - Field: ‘seed’
[17:39:20.536]   - Field: ‘version’
[17:39:20.536]   - Field: ‘result’
[17:39:20.536]   - Field: ‘asynchronous’
[17:39:20.536]   - Field: ‘calls’
[17:39:20.537]   - Field: ‘globals’
[17:39:20.537]   - Field: ‘stdout’
[17:39:20.541]   - Field: ‘earlySignal’
[17:39:20.541]   - Field: ‘lazy’
[17:39:20.542]   - Field: ‘state’
[17:39:20.542] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:20.542] - Launch lazy future ...
[17:39:20.543] Packages needed by the future expression (n = 0): <none>
[17:39:20.543] Packages needed by future strategies (n = 0): <none>
[17:39:20.544] {
[17:39:20.544]     {
[17:39:20.544]         {
[17:39:20.544]             ...future.startTime <- base::Sys.time()
[17:39:20.544]             {
[17:39:20.544]                 {
[17:39:20.544]                   {
[17:39:20.544]                     {
[17:39:20.544]                       base::local({
[17:39:20.544]                         has_future <- base::requireNamespace("future", 
[17:39:20.544]                           quietly = TRUE)
[17:39:20.544]                         if (has_future) {
[17:39:20.544]                           ns <- base::getNamespace("future")
[17:39:20.544]                           version <- ns[[".package"]][["version"]]
[17:39:20.544]                           if (is.null(version)) 
[17:39:20.544]                             version <- utils::packageVersion("future")
[17:39:20.544]                         }
[17:39:20.544]                         else {
[17:39:20.544]                           version <- NULL
[17:39:20.544]                         }
[17:39:20.544]                         if (!has_future || version < "1.8.0") {
[17:39:20.544]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.544]                             "", base::R.version$version.string), 
[17:39:20.544]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:20.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.544]                               "release", "version")], collapse = " "), 
[17:39:20.544]                             hostname = base::Sys.info()[["nodename"]])
[17:39:20.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.544]                             info)
[17:39:20.544]                           info <- base::paste(info, collapse = "; ")
[17:39:20.544]                           if (!has_future) {
[17:39:20.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.544]                               info)
[17:39:20.544]                           }
[17:39:20.544]                           else {
[17:39:20.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.544]                               info, version)
[17:39:20.544]                           }
[17:39:20.544]                           base::stop(msg)
[17:39:20.544]                         }
[17:39:20.544]                       })
[17:39:20.544]                     }
[17:39:20.544]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:20.544]                     base::options(mc.cores = 1L)
[17:39:20.544]                   }
[17:39:20.544]                   options(future.plan = NULL)
[17:39:20.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.544]                 }
[17:39:20.544]                 ...future.workdir <- getwd()
[17:39:20.544]             }
[17:39:20.544]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.544]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.544]         }
[17:39:20.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.544]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.544]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.544]             base::names(...future.oldOptions))
[17:39:20.544]     }
[17:39:20.544]     if (FALSE) {
[17:39:20.544]     }
[17:39:20.544]     else {
[17:39:20.544]         if (TRUE) {
[17:39:20.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.544]                 open = "w")
[17:39:20.544]         }
[17:39:20.544]         else {
[17:39:20.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.544]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.544]         }
[17:39:20.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.544]             base::sink(type = "output", split = FALSE)
[17:39:20.544]             base::close(...future.stdout)
[17:39:20.544]         }, add = TRUE)
[17:39:20.544]     }
[17:39:20.544]     ...future.frame <- base::sys.nframe()
[17:39:20.544]     ...future.conditions <- base::list()
[17:39:20.544]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.544]     if (FALSE) {
[17:39:20.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.544]     }
[17:39:20.544]     ...future.result <- base::tryCatch({
[17:39:20.544]         base::withCallingHandlers({
[17:39:20.544]             ...future.value <- base::withVisible(base::local({
[17:39:20.544]                 withCallingHandlers({
[17:39:20.544]                   {
[17:39:20.544]                     do.call(function(...) {
[17:39:20.544]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.544]                       if (!identical(...future.globals.maxSize.org, 
[17:39:20.544]                         ...future.globals.maxSize)) {
[17:39:20.544]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.544]                         on.exit(options(oopts), add = TRUE)
[17:39:20.544]                       }
[17:39:20.544]                       {
[17:39:20.544]                         lapply(seq_along(...future.elements_ii), 
[17:39:20.544]                           FUN = function(jj) {
[17:39:20.544]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.544]                             ...future.FUN(...future.X_jj, ...)
[17:39:20.544]                           })
[17:39:20.544]                       }
[17:39:20.544]                     }, args = future.call.arguments)
[17:39:20.544]                   }
[17:39:20.544]                 }, immediateCondition = function(cond) {
[17:39:20.544]                   save_rds <- function (object, pathname, ...) 
[17:39:20.544]                   {
[17:39:20.544]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:20.544]                     if (file_test("-f", pathname_tmp)) {
[17:39:20.544]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.544]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:20.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.544]                         fi_tmp[["mtime"]])
[17:39:20.544]                     }
[17:39:20.544]                     tryCatch({
[17:39:20.544]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:20.544]                     }, error = function(ex) {
[17:39:20.544]                       msg <- conditionMessage(ex)
[17:39:20.544]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.544]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:20.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.544]                         fi_tmp[["mtime"]], msg)
[17:39:20.544]                       ex$message <- msg
[17:39:20.544]                       stop(ex)
[17:39:20.544]                     })
[17:39:20.544]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:20.544]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:20.544]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:20.544]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.544]                       fi <- file.info(pathname)
[17:39:20.544]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:20.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.544]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:20.544]                         fi[["size"]], fi[["mtime"]])
[17:39:20.544]                       stop(msg)
[17:39:20.544]                     }
[17:39:20.544]                     invisible(pathname)
[17:39:20.544]                   }
[17:39:20.544]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:20.544]                     rootPath = tempdir()) 
[17:39:20.544]                   {
[17:39:20.544]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:20.544]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:20.544]                       tmpdir = path, fileext = ".rds")
[17:39:20.544]                     save_rds(obj, file)
[17:39:20.544]                   }
[17:39:20.544]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:20.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.544]                   {
[17:39:20.544]                     inherits <- base::inherits
[17:39:20.544]                     invokeRestart <- base::invokeRestart
[17:39:20.544]                     is.null <- base::is.null
[17:39:20.544]                     muffled <- FALSE
[17:39:20.544]                     if (inherits(cond, "message")) {
[17:39:20.544]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:20.544]                       if (muffled) 
[17:39:20.544]                         invokeRestart("muffleMessage")
[17:39:20.544]                     }
[17:39:20.544]                     else if (inherits(cond, "warning")) {
[17:39:20.544]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:20.544]                       if (muffled) 
[17:39:20.544]                         invokeRestart("muffleWarning")
[17:39:20.544]                     }
[17:39:20.544]                     else if (inherits(cond, "condition")) {
[17:39:20.544]                       if (!is.null(pattern)) {
[17:39:20.544]                         computeRestarts <- base::computeRestarts
[17:39:20.544]                         grepl <- base::grepl
[17:39:20.544]                         restarts <- computeRestarts(cond)
[17:39:20.544]                         for (restart in restarts) {
[17:39:20.544]                           name <- restart$name
[17:39:20.544]                           if (is.null(name)) 
[17:39:20.544]                             next
[17:39:20.544]                           if (!grepl(pattern, name)) 
[17:39:20.544]                             next
[17:39:20.544]                           invokeRestart(restart)
[17:39:20.544]                           muffled <- TRUE
[17:39:20.544]                           break
[17:39:20.544]                         }
[17:39:20.544]                       }
[17:39:20.544]                     }
[17:39:20.544]                     invisible(muffled)
[17:39:20.544]                   }
[17:39:20.544]                   muffleCondition(cond)
[17:39:20.544]                 })
[17:39:20.544]             }))
[17:39:20.544]             future::FutureResult(value = ...future.value$value, 
[17:39:20.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.544]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.544]                     ...future.globalenv.names))
[17:39:20.544]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.544]         }, condition = base::local({
[17:39:20.544]             c <- base::c
[17:39:20.544]             inherits <- base::inherits
[17:39:20.544]             invokeRestart <- base::invokeRestart
[17:39:20.544]             length <- base::length
[17:39:20.544]             list <- base::list
[17:39:20.544]             seq.int <- base::seq.int
[17:39:20.544]             signalCondition <- base::signalCondition
[17:39:20.544]             sys.calls <- base::sys.calls
[17:39:20.544]             `[[` <- base::`[[`
[17:39:20.544]             `+` <- base::`+`
[17:39:20.544]             `<<-` <- base::`<<-`
[17:39:20.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.544]                   3L)]
[17:39:20.544]             }
[17:39:20.544]             function(cond) {
[17:39:20.544]                 is_error <- inherits(cond, "error")
[17:39:20.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.544]                   NULL)
[17:39:20.544]                 if (is_error) {
[17:39:20.544]                   sessionInformation <- function() {
[17:39:20.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.544]                       search = base::search(), system = base::Sys.info())
[17:39:20.544]                   }
[17:39:20.544]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.544]                     cond$call), session = sessionInformation(), 
[17:39:20.544]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.544]                   signalCondition(cond)
[17:39:20.544]                 }
[17:39:20.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.544]                 "immediateCondition"))) {
[17:39:20.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.544]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.544]                   if (TRUE && !signal) {
[17:39:20.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.544]                     {
[17:39:20.544]                       inherits <- base::inherits
[17:39:20.544]                       invokeRestart <- base::invokeRestart
[17:39:20.544]                       is.null <- base::is.null
[17:39:20.544]                       muffled <- FALSE
[17:39:20.544]                       if (inherits(cond, "message")) {
[17:39:20.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.544]                         if (muffled) 
[17:39:20.544]                           invokeRestart("muffleMessage")
[17:39:20.544]                       }
[17:39:20.544]                       else if (inherits(cond, "warning")) {
[17:39:20.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.544]                         if (muffled) 
[17:39:20.544]                           invokeRestart("muffleWarning")
[17:39:20.544]                       }
[17:39:20.544]                       else if (inherits(cond, "condition")) {
[17:39:20.544]                         if (!is.null(pattern)) {
[17:39:20.544]                           computeRestarts <- base::computeRestarts
[17:39:20.544]                           grepl <- base::grepl
[17:39:20.544]                           restarts <- computeRestarts(cond)
[17:39:20.544]                           for (restart in restarts) {
[17:39:20.544]                             name <- restart$name
[17:39:20.544]                             if (is.null(name)) 
[17:39:20.544]                               next
[17:39:20.544]                             if (!grepl(pattern, name)) 
[17:39:20.544]                               next
[17:39:20.544]                             invokeRestart(restart)
[17:39:20.544]                             muffled <- TRUE
[17:39:20.544]                             break
[17:39:20.544]                           }
[17:39:20.544]                         }
[17:39:20.544]                       }
[17:39:20.544]                       invisible(muffled)
[17:39:20.544]                     }
[17:39:20.544]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.544]                   }
[17:39:20.544]                 }
[17:39:20.544]                 else {
[17:39:20.544]                   if (TRUE) {
[17:39:20.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.544]                     {
[17:39:20.544]                       inherits <- base::inherits
[17:39:20.544]                       invokeRestart <- base::invokeRestart
[17:39:20.544]                       is.null <- base::is.null
[17:39:20.544]                       muffled <- FALSE
[17:39:20.544]                       if (inherits(cond, "message")) {
[17:39:20.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.544]                         if (muffled) 
[17:39:20.544]                           invokeRestart("muffleMessage")
[17:39:20.544]                       }
[17:39:20.544]                       else if (inherits(cond, "warning")) {
[17:39:20.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.544]                         if (muffled) 
[17:39:20.544]                           invokeRestart("muffleWarning")
[17:39:20.544]                       }
[17:39:20.544]                       else if (inherits(cond, "condition")) {
[17:39:20.544]                         if (!is.null(pattern)) {
[17:39:20.544]                           computeRestarts <- base::computeRestarts
[17:39:20.544]                           grepl <- base::grepl
[17:39:20.544]                           restarts <- computeRestarts(cond)
[17:39:20.544]                           for (restart in restarts) {
[17:39:20.544]                             name <- restart$name
[17:39:20.544]                             if (is.null(name)) 
[17:39:20.544]                               next
[17:39:20.544]                             if (!grepl(pattern, name)) 
[17:39:20.544]                               next
[17:39:20.544]                             invokeRestart(restart)
[17:39:20.544]                             muffled <- TRUE
[17:39:20.544]                             break
[17:39:20.544]                           }
[17:39:20.544]                         }
[17:39:20.544]                       }
[17:39:20.544]                       invisible(muffled)
[17:39:20.544]                     }
[17:39:20.544]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.544]                   }
[17:39:20.544]                 }
[17:39:20.544]             }
[17:39:20.544]         }))
[17:39:20.544]     }, error = function(ex) {
[17:39:20.544]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.544]                 ...future.rng), started = ...future.startTime, 
[17:39:20.544]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.544]             version = "1.8"), class = "FutureResult")
[17:39:20.544]     }, finally = {
[17:39:20.544]         if (!identical(...future.workdir, getwd())) 
[17:39:20.544]             setwd(...future.workdir)
[17:39:20.544]         {
[17:39:20.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.544]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.544]             }
[17:39:20.544]             base::options(...future.oldOptions)
[17:39:20.544]             if (.Platform$OS.type == "windows") {
[17:39:20.544]                 old_names <- names(...future.oldEnvVars)
[17:39:20.544]                 envs <- base::Sys.getenv()
[17:39:20.544]                 names <- names(envs)
[17:39:20.544]                 common <- intersect(names, old_names)
[17:39:20.544]                 added <- setdiff(names, old_names)
[17:39:20.544]                 removed <- setdiff(old_names, names)
[17:39:20.544]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.544]                   envs[common]]
[17:39:20.544]                 NAMES <- toupper(changed)
[17:39:20.544]                 args <- list()
[17:39:20.544]                 for (kk in seq_along(NAMES)) {
[17:39:20.544]                   name <- changed[[kk]]
[17:39:20.544]                   NAME <- NAMES[[kk]]
[17:39:20.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.544]                     next
[17:39:20.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.544]                 }
[17:39:20.544]                 NAMES <- toupper(added)
[17:39:20.544]                 for (kk in seq_along(NAMES)) {
[17:39:20.544]                   name <- added[[kk]]
[17:39:20.544]                   NAME <- NAMES[[kk]]
[17:39:20.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.544]                     next
[17:39:20.544]                   args[[name]] <- ""
[17:39:20.544]                 }
[17:39:20.544]                 NAMES <- toupper(removed)
[17:39:20.544]                 for (kk in seq_along(NAMES)) {
[17:39:20.544]                   name <- removed[[kk]]
[17:39:20.544]                   NAME <- NAMES[[kk]]
[17:39:20.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.544]                     next
[17:39:20.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.544]                 }
[17:39:20.544]                 if (length(args) > 0) 
[17:39:20.544]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.544]             }
[17:39:20.544]             else {
[17:39:20.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.544]             }
[17:39:20.544]             {
[17:39:20.544]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.544]                   0L) {
[17:39:20.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.544]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.544]                   base::options(opts)
[17:39:20.544]                 }
[17:39:20.544]                 {
[17:39:20.544]                   {
[17:39:20.544]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:20.544]                     NULL
[17:39:20.544]                   }
[17:39:20.544]                   options(future.plan = NULL)
[17:39:20.544]                   if (is.na(NA_character_)) 
[17:39:20.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.544]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:20.544]                     envir = parent.frame()) 
[17:39:20.544]                   {
[17:39:20.544]                     default_workers <- missing(workers)
[17:39:20.544]                     if (is.function(workers)) 
[17:39:20.544]                       workers <- workers()
[17:39:20.544]                     workers <- structure(as.integer(workers), 
[17:39:20.544]                       class = class(workers))
[17:39:20.544]                     stop_if_not(is.finite(workers), workers >= 
[17:39:20.544]                       1L)
[17:39:20.544]                     if ((workers == 1L && !inherits(workers, 
[17:39:20.544]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:20.544]                       if (default_workers) 
[17:39:20.544]                         supportsMulticore(warn = TRUE)
[17:39:20.544]                       return(sequential(..., envir = envir))
[17:39:20.544]                     }
[17:39:20.544]                     oopts <- options(mc.cores = workers)
[17:39:20.544]                     on.exit(options(oopts))
[17:39:20.544]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:20.544]                       envir = envir)
[17:39:20.544]                     if (!future$lazy) 
[17:39:20.544]                       future <- run(future)
[17:39:20.544]                     invisible(future)
[17:39:20.544]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.544]                 }
[17:39:20.544]             }
[17:39:20.544]         }
[17:39:20.544]     })
[17:39:20.544]     if (TRUE) {
[17:39:20.544]         base::sink(type = "output", split = FALSE)
[17:39:20.544]         if (TRUE) {
[17:39:20.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.544]         }
[17:39:20.544]         else {
[17:39:20.544]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.544]         }
[17:39:20.544]         base::close(...future.stdout)
[17:39:20.544]         ...future.stdout <- NULL
[17:39:20.544]     }
[17:39:20.544]     ...future.result$conditions <- ...future.conditions
[17:39:20.544]     ...future.result$finished <- base::Sys.time()
[17:39:20.544]     ...future.result
[17:39:20.544] }
[17:39:20.547] assign_globals() ...
[17:39:20.547] List of 5
[17:39:20.547]  $ future.call.arguments    : list()
[17:39:20.547]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.547]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.547]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.547]  $ ...future.elements_ii    :List of 1
[17:39:20.547]   ..$ : num [1:4] 2 4 6 8
[17:39:20.547]  $ ...future.seeds_ii       : NULL
[17:39:20.547]  $ ...future.globals.maxSize: NULL
[17:39:20.547]  - attr(*, "where")=List of 5
[17:39:20.547]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.547]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.547]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.547]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.547]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.547]  - attr(*, "resolved")= logi FALSE
[17:39:20.547]  - attr(*, "total_size")= num NA
[17:39:20.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.547]  - attr(*, "already-done")= logi TRUE
[17:39:20.556] - copied ‘future.call.arguments’ to environment
[17:39:20.556] - copied ‘...future.FUN’ to environment
[17:39:20.556] - copied ‘...future.elements_ii’ to environment
[17:39:20.556] - copied ‘...future.seeds_ii’ to environment
[17:39:20.556] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.556] assign_globals() ... done
[17:39:20.556] requestCore(): workers = 2
[17:39:20.562] MulticoreFuture started
[17:39:20.562] - Launch lazy future ... done
[17:39:20.563] run() for ‘MulticoreFuture’ ... done
[17:39:20.563] Created future:
[17:39:20.563] plan(): Setting new future strategy stack:
[17:39:20.564] List of future strategies:
[17:39:20.564] 1. sequential:
[17:39:20.564]    - args: function (..., envir = parent.frame())
[17:39:20.564]    - tweaked: FALSE
[17:39:20.564]    - call: NULL
[17:39:20.564] plan(): nbrOfWorkers() = 1
[17:39:20.567] plan(): Setting new future strategy stack:
[17:39:20.567] List of future strategies:
[17:39:20.567] 1. multicore:
[17:39:20.567]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.567]    - tweaked: FALSE
[17:39:20.567]    - call: plan(strategy)
[17:39:20.572] plan(): nbrOfWorkers() = 2
[17:39:20.563] MulticoreFuture:
[17:39:20.563] Label: ‘future_apply-2’
[17:39:20.563] Expression:
[17:39:20.563] {
[17:39:20.563]     do.call(function(...) {
[17:39:20.563]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.563]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.563]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.563]             on.exit(options(oopts), add = TRUE)
[17:39:20.563]         }
[17:39:20.563]         {
[17:39:20.563]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.563]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.563]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.563]             })
[17:39:20.563]         }
[17:39:20.563]     }, args = future.call.arguments)
[17:39:20.563] }
[17:39:20.563] Lazy evaluation: FALSE
[17:39:20.563] Asynchronous evaluation: TRUE
[17:39:20.563] Local evaluation: TRUE
[17:39:20.563] Environment: R_GlobalEnv
[17:39:20.563] Capture standard output: TRUE
[17:39:20.563] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.563] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:20.563] Packages: <none>
[17:39:20.563] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.563] Resolved: TRUE
[17:39:20.563] Value: <not collected>
[17:39:20.563] Conditions captured: <none>
[17:39:20.563] Early signaling: FALSE
[17:39:20.563] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.563] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.573] Chunk #2 of 2 ... DONE
[17:39:20.573] Launching 2 futures (chunks) ... DONE
[17:39:20.574] Resolving 2 futures (chunks) ...
[17:39:20.574] resolve() on list ...
[17:39:20.574]  recursive: 0
[17:39:20.574]  length: 2
[17:39:20.574] 
[17:39:20.575] Future #1
[17:39:20.577] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:20.577] - nx: 2
[17:39:20.577] - relay: TRUE
[17:39:20.577] - stdout: TRUE
[17:39:20.578] - signal: TRUE
[17:39:20.578] - resignal: FALSE
[17:39:20.578] - force: TRUE
[17:39:20.578] - relayed: [n=2] FALSE, FALSE
[17:39:20.578] - queued futures: [n=2] FALSE, FALSE
[17:39:20.578]  - until=1
[17:39:20.579]  - relaying element #1
[17:39:20.579] - relayed: [n=2] TRUE, FALSE
[17:39:20.579] - queued futures: [n=2] TRUE, FALSE
[17:39:20.579] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:20.579]  length: 1 (resolved future 1)
[17:39:20.580] Future #2
[17:39:20.580] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:20.581] - nx: 2
[17:39:20.581] - relay: TRUE
[17:39:20.581] - stdout: TRUE
[17:39:20.581] - signal: TRUE
[17:39:20.581] - resignal: FALSE
[17:39:20.581] - force: TRUE
[17:39:20.581] - relayed: [n=2] TRUE, FALSE
[17:39:20.581] - queued futures: [n=2] TRUE, FALSE
[17:39:20.582]  - until=2
[17:39:20.582]  - relaying element #2
[17:39:20.582] - relayed: [n=2] TRUE, TRUE
[17:39:20.582] - queued futures: [n=2] TRUE, TRUE
[17:39:20.582] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:20.582]  length: 0 (resolved future 2)
[17:39:20.582] Relaying remaining futures
[17:39:20.583] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.583] - nx: 2
[17:39:20.583] - relay: TRUE
[17:39:20.583] - stdout: TRUE
[17:39:20.583] - signal: TRUE
[17:39:20.583] - resignal: FALSE
[17:39:20.583] - force: TRUE
[17:39:20.583] - relayed: [n=2] TRUE, TRUE
[17:39:20.583] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:20.584] - relayed: [n=2] TRUE, TRUE
[17:39:20.584] - queued futures: [n=2] TRUE, TRUE
[17:39:20.584] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.584] resolve() on list ... DONE
[17:39:20.584]  - Number of value chunks collected: 2
[17:39:20.584] Resolving 2 futures (chunks) ... DONE
[17:39:20.584] Reducing values from 2 chunks ...
[17:39:20.584]  - Number of values collected after concatenation: 2
[17:39:20.585]  - Number of values expected: 2
[17:39:20.585] Reducing values from 2 chunks ... DONE
[17:39:20.585] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:39:20.585] getGlobalsAndPackagesXApply() ...
[17:39:20.585]  - future.globals: TRUE
[17:39:20.586] getGlobalsAndPackages() ...
[17:39:20.586] Searching for globals...
[17:39:20.626] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:39:20.626] Searching for globals ... DONE
[17:39:20.626] Resolving globals: FALSE
[17:39:20.628] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:39:20.628] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:39:20.628] - globals: [1] ‘FUN’
[17:39:20.628] 
[17:39:20.629] getGlobalsAndPackages() ... DONE
[17:39:20.629]  - globals found/used: [n=1] ‘FUN’
[17:39:20.629]  - needed namespaces: [n=0] 
[17:39:20.629] Finding globals ... DONE
[17:39:20.629]  - use_args: TRUE
[17:39:20.629]  - Getting '...' globals ...
[17:39:20.629] resolve() on list ...
[17:39:20.629]  recursive: 0
[17:39:20.629]  length: 1
[17:39:20.630]  elements: ‘...’
[17:39:20.630]  length: 0 (resolved future 1)
[17:39:20.630] resolve() on list ... DONE
[17:39:20.630]    - '...' content: [n=0] 
[17:39:20.630] List of 1
[17:39:20.630]  $ ...: list()
[17:39:20.630]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.630]  - attr(*, "where")=List of 1
[17:39:20.630]   ..$ ...:<environment: 0x55c796fdb368> 
[17:39:20.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.630]  - attr(*, "resolved")= logi TRUE
[17:39:20.630]  - attr(*, "total_size")= num NA
[17:39:20.633]  - Getting '...' globals ... DONE
[17:39:20.633] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.633] List of 2
[17:39:20.633]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.633]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.633]  $ ...          : list()
[17:39:20.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.633]  - attr(*, "where")=List of 2
[17:39:20.633]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.633]   ..$ ...          :<environment: 0x55c796fdb368> 
[17:39:20.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.633]  - attr(*, "resolved")= logi FALSE
[17:39:20.633]  - attr(*, "total_size")= num 354224
[17:39:20.635] Packages to be attached in all futures: [n=0] 
[17:39:20.635] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.639] future_lapply() ...
[17:39:20.676] Number of chunks: 2
[17:39:20.676] getGlobalsAndPackagesXApply() ...
[17:39:20.676]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.677]  - use_args: TRUE
[17:39:20.677] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.677] List of 2
[17:39:20.677]  $ ...          : list()
[17:39:20.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.677]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.677]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.677]  - attr(*, "where")=List of 2
[17:39:20.677]   ..$ ...          :<environment: 0x55c796fdb368> 
[17:39:20.677]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.677]  - attr(*, "resolved")= logi FALSE
[17:39:20.677]  - attr(*, "total_size")= num NA
[17:39:20.681] Packages to be attached in all futures: [n=0] 
[17:39:20.681] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.681] Number of futures (= number of chunks): 2
[17:39:20.681] Launching 2 futures (chunks) ...
[17:39:20.681] Chunk #1 of 2 ...
[17:39:20.682]  - seeds: <none>
[17:39:20.682] getGlobalsAndPackages() ...
[17:39:20.683] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.683] Resolving globals: FALSE
[17:39:20.683] Tweak future expression to call with '...' arguments ...
[17:39:20.683] {
[17:39:20.683]     do.call(function(...) {
[17:39:20.683]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.683]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.683]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.683]             on.exit(options(oopts), add = TRUE)
[17:39:20.683]         }
[17:39:20.683]         {
[17:39:20.683]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.683]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.683]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.683]             })
[17:39:20.683]         }
[17:39:20.683]     }, args = future.call.arguments)
[17:39:20.683] }
[17:39:20.683] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.684] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.684] 
[17:39:20.684] getGlobalsAndPackages() ... DONE
[17:39:20.684] run() for ‘Future’ ...
[17:39:20.684] - state: ‘created’
[17:39:20.685] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:20.688] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.688] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:20.688]   - Field: ‘label’
[17:39:20.688]   - Field: ‘local’
[17:39:20.689]   - Field: ‘owner’
[17:39:20.689]   - Field: ‘envir’
[17:39:20.689]   - Field: ‘workers’
[17:39:20.689]   - Field: ‘packages’
[17:39:20.689]   - Field: ‘gc’
[17:39:20.689]   - Field: ‘job’
[17:39:20.689]   - Field: ‘conditions’
[17:39:20.689]   - Field: ‘expr’
[17:39:20.689]   - Field: ‘uuid’
[17:39:20.689]   - Field: ‘seed’
[17:39:20.689]   - Field: ‘version’
[17:39:20.690]   - Field: ‘result’
[17:39:20.690]   - Field: ‘asynchronous’
[17:39:20.690]   - Field: ‘calls’
[17:39:20.690]   - Field: ‘globals’
[17:39:20.690]   - Field: ‘stdout’
[17:39:20.690]   - Field: ‘earlySignal’
[17:39:20.690]   - Field: ‘lazy’
[17:39:20.690]   - Field: ‘state’
[17:39:20.690] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:20.690] - Launch lazy future ...
[17:39:20.691] Packages needed by the future expression (n = 0): <none>
[17:39:20.691] Packages needed by future strategies (n = 0): <none>
[17:39:20.691] {
[17:39:20.691]     {
[17:39:20.691]         {
[17:39:20.691]             ...future.startTime <- base::Sys.time()
[17:39:20.691]             {
[17:39:20.691]                 {
[17:39:20.691]                   {
[17:39:20.691]                     {
[17:39:20.691]                       base::local({
[17:39:20.691]                         has_future <- base::requireNamespace("future", 
[17:39:20.691]                           quietly = TRUE)
[17:39:20.691]                         if (has_future) {
[17:39:20.691]                           ns <- base::getNamespace("future")
[17:39:20.691]                           version <- ns[[".package"]][["version"]]
[17:39:20.691]                           if (is.null(version)) 
[17:39:20.691]                             version <- utils::packageVersion("future")
[17:39:20.691]                         }
[17:39:20.691]                         else {
[17:39:20.691]                           version <- NULL
[17:39:20.691]                         }
[17:39:20.691]                         if (!has_future || version < "1.8.0") {
[17:39:20.691]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.691]                             "", base::R.version$version.string), 
[17:39:20.691]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:20.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.691]                               "release", "version")], collapse = " "), 
[17:39:20.691]                             hostname = base::Sys.info()[["nodename"]])
[17:39:20.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.691]                             info)
[17:39:20.691]                           info <- base::paste(info, collapse = "; ")
[17:39:20.691]                           if (!has_future) {
[17:39:20.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.691]                               info)
[17:39:20.691]                           }
[17:39:20.691]                           else {
[17:39:20.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.691]                               info, version)
[17:39:20.691]                           }
[17:39:20.691]                           base::stop(msg)
[17:39:20.691]                         }
[17:39:20.691]                       })
[17:39:20.691]                     }
[17:39:20.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:20.691]                     base::options(mc.cores = 1L)
[17:39:20.691]                   }
[17:39:20.691]                   options(future.plan = NULL)
[17:39:20.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.691]                 }
[17:39:20.691]                 ...future.workdir <- getwd()
[17:39:20.691]             }
[17:39:20.691]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.691]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.691]         }
[17:39:20.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.691]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.691]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.691]             base::names(...future.oldOptions))
[17:39:20.691]     }
[17:39:20.691]     if (FALSE) {
[17:39:20.691]     }
[17:39:20.691]     else {
[17:39:20.691]         if (TRUE) {
[17:39:20.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.691]                 open = "w")
[17:39:20.691]         }
[17:39:20.691]         else {
[17:39:20.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.691]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.691]         }
[17:39:20.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.691]             base::sink(type = "output", split = FALSE)
[17:39:20.691]             base::close(...future.stdout)
[17:39:20.691]         }, add = TRUE)
[17:39:20.691]     }
[17:39:20.691]     ...future.frame <- base::sys.nframe()
[17:39:20.691]     ...future.conditions <- base::list()
[17:39:20.691]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.691]     if (FALSE) {
[17:39:20.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.691]     }
[17:39:20.691]     ...future.result <- base::tryCatch({
[17:39:20.691]         base::withCallingHandlers({
[17:39:20.691]             ...future.value <- base::withVisible(base::local({
[17:39:20.691]                 withCallingHandlers({
[17:39:20.691]                   {
[17:39:20.691]                     do.call(function(...) {
[17:39:20.691]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.691]                       if (!identical(...future.globals.maxSize.org, 
[17:39:20.691]                         ...future.globals.maxSize)) {
[17:39:20.691]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.691]                         on.exit(options(oopts), add = TRUE)
[17:39:20.691]                       }
[17:39:20.691]                       {
[17:39:20.691]                         lapply(seq_along(...future.elements_ii), 
[17:39:20.691]                           FUN = function(jj) {
[17:39:20.691]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.691]                             ...future.FUN(...future.X_jj, ...)
[17:39:20.691]                           })
[17:39:20.691]                       }
[17:39:20.691]                     }, args = future.call.arguments)
[17:39:20.691]                   }
[17:39:20.691]                 }, immediateCondition = function(cond) {
[17:39:20.691]                   save_rds <- function (object, pathname, ...) 
[17:39:20.691]                   {
[17:39:20.691]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:20.691]                     if (file_test("-f", pathname_tmp)) {
[17:39:20.691]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.691]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:20.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.691]                         fi_tmp[["mtime"]])
[17:39:20.691]                     }
[17:39:20.691]                     tryCatch({
[17:39:20.691]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:20.691]                     }, error = function(ex) {
[17:39:20.691]                       msg <- conditionMessage(ex)
[17:39:20.691]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.691]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:20.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.691]                         fi_tmp[["mtime"]], msg)
[17:39:20.691]                       ex$message <- msg
[17:39:20.691]                       stop(ex)
[17:39:20.691]                     })
[17:39:20.691]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:20.691]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:20.691]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:20.691]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.691]                       fi <- file.info(pathname)
[17:39:20.691]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:20.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.691]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:20.691]                         fi[["size"]], fi[["mtime"]])
[17:39:20.691]                       stop(msg)
[17:39:20.691]                     }
[17:39:20.691]                     invisible(pathname)
[17:39:20.691]                   }
[17:39:20.691]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:20.691]                     rootPath = tempdir()) 
[17:39:20.691]                   {
[17:39:20.691]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:20.691]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:20.691]                       tmpdir = path, fileext = ".rds")
[17:39:20.691]                     save_rds(obj, file)
[17:39:20.691]                   }
[17:39:20.691]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:20.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.691]                   {
[17:39:20.691]                     inherits <- base::inherits
[17:39:20.691]                     invokeRestart <- base::invokeRestart
[17:39:20.691]                     is.null <- base::is.null
[17:39:20.691]                     muffled <- FALSE
[17:39:20.691]                     if (inherits(cond, "message")) {
[17:39:20.691]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:20.691]                       if (muffled) 
[17:39:20.691]                         invokeRestart("muffleMessage")
[17:39:20.691]                     }
[17:39:20.691]                     else if (inherits(cond, "warning")) {
[17:39:20.691]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:20.691]                       if (muffled) 
[17:39:20.691]                         invokeRestart("muffleWarning")
[17:39:20.691]                     }
[17:39:20.691]                     else if (inherits(cond, "condition")) {
[17:39:20.691]                       if (!is.null(pattern)) {
[17:39:20.691]                         computeRestarts <- base::computeRestarts
[17:39:20.691]                         grepl <- base::grepl
[17:39:20.691]                         restarts <- computeRestarts(cond)
[17:39:20.691]                         for (restart in restarts) {
[17:39:20.691]                           name <- restart$name
[17:39:20.691]                           if (is.null(name)) 
[17:39:20.691]                             next
[17:39:20.691]                           if (!grepl(pattern, name)) 
[17:39:20.691]                             next
[17:39:20.691]                           invokeRestart(restart)
[17:39:20.691]                           muffled <- TRUE
[17:39:20.691]                           break
[17:39:20.691]                         }
[17:39:20.691]                       }
[17:39:20.691]                     }
[17:39:20.691]                     invisible(muffled)
[17:39:20.691]                   }
[17:39:20.691]                   muffleCondition(cond)
[17:39:20.691]                 })
[17:39:20.691]             }))
[17:39:20.691]             future::FutureResult(value = ...future.value$value, 
[17:39:20.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.691]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.691]                     ...future.globalenv.names))
[17:39:20.691]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.691]         }, condition = base::local({
[17:39:20.691]             c <- base::c
[17:39:20.691]             inherits <- base::inherits
[17:39:20.691]             invokeRestart <- base::invokeRestart
[17:39:20.691]             length <- base::length
[17:39:20.691]             list <- base::list
[17:39:20.691]             seq.int <- base::seq.int
[17:39:20.691]             signalCondition <- base::signalCondition
[17:39:20.691]             sys.calls <- base::sys.calls
[17:39:20.691]             `[[` <- base::`[[`
[17:39:20.691]             `+` <- base::`+`
[17:39:20.691]             `<<-` <- base::`<<-`
[17:39:20.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.691]                   3L)]
[17:39:20.691]             }
[17:39:20.691]             function(cond) {
[17:39:20.691]                 is_error <- inherits(cond, "error")
[17:39:20.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.691]                   NULL)
[17:39:20.691]                 if (is_error) {
[17:39:20.691]                   sessionInformation <- function() {
[17:39:20.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.691]                       search = base::search(), system = base::Sys.info())
[17:39:20.691]                   }
[17:39:20.691]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.691]                     cond$call), session = sessionInformation(), 
[17:39:20.691]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.691]                   signalCondition(cond)
[17:39:20.691]                 }
[17:39:20.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.691]                 "immediateCondition"))) {
[17:39:20.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.691]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.691]                   if (TRUE && !signal) {
[17:39:20.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.691]                     {
[17:39:20.691]                       inherits <- base::inherits
[17:39:20.691]                       invokeRestart <- base::invokeRestart
[17:39:20.691]                       is.null <- base::is.null
[17:39:20.691]                       muffled <- FALSE
[17:39:20.691]                       if (inherits(cond, "message")) {
[17:39:20.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.691]                         if (muffled) 
[17:39:20.691]                           invokeRestart("muffleMessage")
[17:39:20.691]                       }
[17:39:20.691]                       else if (inherits(cond, "warning")) {
[17:39:20.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.691]                         if (muffled) 
[17:39:20.691]                           invokeRestart("muffleWarning")
[17:39:20.691]                       }
[17:39:20.691]                       else if (inherits(cond, "condition")) {
[17:39:20.691]                         if (!is.null(pattern)) {
[17:39:20.691]                           computeRestarts <- base::computeRestarts
[17:39:20.691]                           grepl <- base::grepl
[17:39:20.691]                           restarts <- computeRestarts(cond)
[17:39:20.691]                           for (restart in restarts) {
[17:39:20.691]                             name <- restart$name
[17:39:20.691]                             if (is.null(name)) 
[17:39:20.691]                               next
[17:39:20.691]                             if (!grepl(pattern, name)) 
[17:39:20.691]                               next
[17:39:20.691]                             invokeRestart(restart)
[17:39:20.691]                             muffled <- TRUE
[17:39:20.691]                             break
[17:39:20.691]                           }
[17:39:20.691]                         }
[17:39:20.691]                       }
[17:39:20.691]                       invisible(muffled)
[17:39:20.691]                     }
[17:39:20.691]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.691]                   }
[17:39:20.691]                 }
[17:39:20.691]                 else {
[17:39:20.691]                   if (TRUE) {
[17:39:20.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.691]                     {
[17:39:20.691]                       inherits <- base::inherits
[17:39:20.691]                       invokeRestart <- base::invokeRestart
[17:39:20.691]                       is.null <- base::is.null
[17:39:20.691]                       muffled <- FALSE
[17:39:20.691]                       if (inherits(cond, "message")) {
[17:39:20.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.691]                         if (muffled) 
[17:39:20.691]                           invokeRestart("muffleMessage")
[17:39:20.691]                       }
[17:39:20.691]                       else if (inherits(cond, "warning")) {
[17:39:20.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.691]                         if (muffled) 
[17:39:20.691]                           invokeRestart("muffleWarning")
[17:39:20.691]                       }
[17:39:20.691]                       else if (inherits(cond, "condition")) {
[17:39:20.691]                         if (!is.null(pattern)) {
[17:39:20.691]                           computeRestarts <- base::computeRestarts
[17:39:20.691]                           grepl <- base::grepl
[17:39:20.691]                           restarts <- computeRestarts(cond)
[17:39:20.691]                           for (restart in restarts) {
[17:39:20.691]                             name <- restart$name
[17:39:20.691]                             if (is.null(name)) 
[17:39:20.691]                               next
[17:39:20.691]                             if (!grepl(pattern, name)) 
[17:39:20.691]                               next
[17:39:20.691]                             invokeRestart(restart)
[17:39:20.691]                             muffled <- TRUE
[17:39:20.691]                             break
[17:39:20.691]                           }
[17:39:20.691]                         }
[17:39:20.691]                       }
[17:39:20.691]                       invisible(muffled)
[17:39:20.691]                     }
[17:39:20.691]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.691]                   }
[17:39:20.691]                 }
[17:39:20.691]             }
[17:39:20.691]         }))
[17:39:20.691]     }, error = function(ex) {
[17:39:20.691]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.691]                 ...future.rng), started = ...future.startTime, 
[17:39:20.691]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.691]             version = "1.8"), class = "FutureResult")
[17:39:20.691]     }, finally = {
[17:39:20.691]         if (!identical(...future.workdir, getwd())) 
[17:39:20.691]             setwd(...future.workdir)
[17:39:20.691]         {
[17:39:20.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.691]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.691]             }
[17:39:20.691]             base::options(...future.oldOptions)
[17:39:20.691]             if (.Platform$OS.type == "windows") {
[17:39:20.691]                 old_names <- names(...future.oldEnvVars)
[17:39:20.691]                 envs <- base::Sys.getenv()
[17:39:20.691]                 names <- names(envs)
[17:39:20.691]                 common <- intersect(names, old_names)
[17:39:20.691]                 added <- setdiff(names, old_names)
[17:39:20.691]                 removed <- setdiff(old_names, names)
[17:39:20.691]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.691]                   envs[common]]
[17:39:20.691]                 NAMES <- toupper(changed)
[17:39:20.691]                 args <- list()
[17:39:20.691]                 for (kk in seq_along(NAMES)) {
[17:39:20.691]                   name <- changed[[kk]]
[17:39:20.691]                   NAME <- NAMES[[kk]]
[17:39:20.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.691]                     next
[17:39:20.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.691]                 }
[17:39:20.691]                 NAMES <- toupper(added)
[17:39:20.691]                 for (kk in seq_along(NAMES)) {
[17:39:20.691]                   name <- added[[kk]]
[17:39:20.691]                   NAME <- NAMES[[kk]]
[17:39:20.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.691]                     next
[17:39:20.691]                   args[[name]] <- ""
[17:39:20.691]                 }
[17:39:20.691]                 NAMES <- toupper(removed)
[17:39:20.691]                 for (kk in seq_along(NAMES)) {
[17:39:20.691]                   name <- removed[[kk]]
[17:39:20.691]                   NAME <- NAMES[[kk]]
[17:39:20.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.691]                     next
[17:39:20.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.691]                 }
[17:39:20.691]                 if (length(args) > 0) 
[17:39:20.691]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.691]             }
[17:39:20.691]             else {
[17:39:20.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.691]             }
[17:39:20.691]             {
[17:39:20.691]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.691]                   0L) {
[17:39:20.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.691]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.691]                   base::options(opts)
[17:39:20.691]                 }
[17:39:20.691]                 {
[17:39:20.691]                   {
[17:39:20.691]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:20.691]                     NULL
[17:39:20.691]                   }
[17:39:20.691]                   options(future.plan = NULL)
[17:39:20.691]                   if (is.na(NA_character_)) 
[17:39:20.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.691]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:20.691]                     envir = parent.frame()) 
[17:39:20.691]                   {
[17:39:20.691]                     default_workers <- missing(workers)
[17:39:20.691]                     if (is.function(workers)) 
[17:39:20.691]                       workers <- workers()
[17:39:20.691]                     workers <- structure(as.integer(workers), 
[17:39:20.691]                       class = class(workers))
[17:39:20.691]                     stop_if_not(is.finite(workers), workers >= 
[17:39:20.691]                       1L)
[17:39:20.691]                     if ((workers == 1L && !inherits(workers, 
[17:39:20.691]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:20.691]                       if (default_workers) 
[17:39:20.691]                         supportsMulticore(warn = TRUE)
[17:39:20.691]                       return(sequential(..., envir = envir))
[17:39:20.691]                     }
[17:39:20.691]                     oopts <- options(mc.cores = workers)
[17:39:20.691]                     on.exit(options(oopts))
[17:39:20.691]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:20.691]                       envir = envir)
[17:39:20.691]                     if (!future$lazy) 
[17:39:20.691]                       future <- run(future)
[17:39:20.691]                     invisible(future)
[17:39:20.691]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.691]                 }
[17:39:20.691]             }
[17:39:20.691]         }
[17:39:20.691]     })
[17:39:20.691]     if (TRUE) {
[17:39:20.691]         base::sink(type = "output", split = FALSE)
[17:39:20.691]         if (TRUE) {
[17:39:20.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.691]         }
[17:39:20.691]         else {
[17:39:20.691]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.691]         }
[17:39:20.691]         base::close(...future.stdout)
[17:39:20.691]         ...future.stdout <- NULL
[17:39:20.691]     }
[17:39:20.691]     ...future.result$conditions <- ...future.conditions
[17:39:20.691]     ...future.result$finished <- base::Sys.time()
[17:39:20.691]     ...future.result
[17:39:20.691] }
[17:39:20.694] assign_globals() ...
[17:39:20.694] List of 5
[17:39:20.694]  $ future.call.arguments    : list()
[17:39:20.694]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.694]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.694]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.694]  $ ...future.elements_ii    :List of 1
[17:39:20.694]   ..$ : num [1:4] 1 3 1 7
[17:39:20.694]  $ ...future.seeds_ii       : NULL
[17:39:20.694]  $ ...future.globals.maxSize: NULL
[17:39:20.694]  - attr(*, "where")=List of 5
[17:39:20.694]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.694]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.694]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.694]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.694]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.694]  - attr(*, "resolved")= logi FALSE
[17:39:20.694]  - attr(*, "total_size")= num NA
[17:39:20.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.694]  - attr(*, "already-done")= logi TRUE
[17:39:20.698] - copied ‘future.call.arguments’ to environment
[17:39:20.698] - copied ‘...future.FUN’ to environment
[17:39:20.698] - copied ‘...future.elements_ii’ to environment
[17:39:20.698] - copied ‘...future.seeds_ii’ to environment
[17:39:20.699] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.699] assign_globals() ... done
[17:39:20.699] requestCore(): workers = 2
[17:39:20.701] MulticoreFuture started
[17:39:20.701] - Launch lazy future ... done
[17:39:20.702] run() for ‘MulticoreFuture’ ... done
[17:39:20.702] Created future:
[17:39:20.702] plan(): Setting new future strategy stack:
[17:39:20.702] List of future strategies:
[17:39:20.702] 1. sequential:
[17:39:20.702]    - args: function (..., envir = parent.frame())
[17:39:20.702]    - tweaked: FALSE
[17:39:20.702]    - call: NULL
[17:39:20.703] plan(): nbrOfWorkers() = 1
[17:39:20.705] plan(): Setting new future strategy stack:
[17:39:20.706] List of future strategies:
[17:39:20.706] 1. multicore:
[17:39:20.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.706]    - tweaked: FALSE
[17:39:20.706]    - call: plan(strategy)
[17:39:20.710] plan(): nbrOfWorkers() = 2
[17:39:20.702] MulticoreFuture:
[17:39:20.702] Label: ‘future_apply-1’
[17:39:20.702] Expression:
[17:39:20.702] {
[17:39:20.702]     do.call(function(...) {
[17:39:20.702]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.702]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.702]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.702]             on.exit(options(oopts), add = TRUE)
[17:39:20.702]         }
[17:39:20.702]         {
[17:39:20.702]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.702]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.702]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.702]             })
[17:39:20.702]         }
[17:39:20.702]     }, args = future.call.arguments)
[17:39:20.702] }
[17:39:20.702] Lazy evaluation: FALSE
[17:39:20.702] Asynchronous evaluation: TRUE
[17:39:20.702] Local evaluation: TRUE
[17:39:20.702] Environment: R_GlobalEnv
[17:39:20.702] Capture standard output: TRUE
[17:39:20.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.702] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:20.702] Packages: <none>
[17:39:20.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.702] Resolved: TRUE
[17:39:20.702] Value: <not collected>
[17:39:20.702] Conditions captured: <none>
[17:39:20.702] Early signaling: FALSE
[17:39:20.702] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.702] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.712] Chunk #1 of 2 ... DONE
[17:39:20.712] Chunk #2 of 2 ...
[17:39:20.712]  - seeds: <none>
[17:39:20.712] getGlobalsAndPackages() ...
[17:39:20.712] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.712] Resolving globals: FALSE
[17:39:20.713] Tweak future expression to call with '...' arguments ...
[17:39:20.713] {
[17:39:20.713]     do.call(function(...) {
[17:39:20.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.713]             on.exit(options(oopts), add = TRUE)
[17:39:20.713]         }
[17:39:20.713]         {
[17:39:20.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.713]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.713]             })
[17:39:20.713]         }
[17:39:20.713]     }, args = future.call.arguments)
[17:39:20.713] }
[17:39:20.713] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.714] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.714] 
[17:39:20.714] getGlobalsAndPackages() ... DONE
[17:39:20.715] run() for ‘Future’ ...
[17:39:20.715] - state: ‘created’
[17:39:20.715] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:20.719] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:20.720]   - Field: ‘label’
[17:39:20.720]   - Field: ‘local’
[17:39:20.720]   - Field: ‘owner’
[17:39:20.720]   - Field: ‘envir’
[17:39:20.720]   - Field: ‘workers’
[17:39:20.721]   - Field: ‘packages’
[17:39:20.721]   - Field: ‘gc’
[17:39:20.721]   - Field: ‘job’
[17:39:20.721]   - Field: ‘conditions’
[17:39:20.721]   - Field: ‘expr’
[17:39:20.721]   - Field: ‘uuid’
[17:39:20.721]   - Field: ‘seed’
[17:39:20.722]   - Field: ‘version’
[17:39:20.722]   - Field: ‘result’
[17:39:20.722]   - Field: ‘asynchronous’
[17:39:20.722]   - Field: ‘calls’
[17:39:20.722]   - Field: ‘globals’
[17:39:20.722]   - Field: ‘stdout’
[17:39:20.722]   - Field: ‘earlySignal’
[17:39:20.723]   - Field: ‘lazy’
[17:39:20.723]   - Field: ‘state’
[17:39:20.726] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:20.726] - Launch lazy future ...
[17:39:20.727] Packages needed by the future expression (n = 0): <none>
[17:39:20.727] Packages needed by future strategies (n = 0): <none>
[17:39:20.729] {
[17:39:20.729]     {
[17:39:20.729]         {
[17:39:20.729]             ...future.startTime <- base::Sys.time()
[17:39:20.729]             {
[17:39:20.729]                 {
[17:39:20.729]                   {
[17:39:20.729]                     {
[17:39:20.729]                       base::local({
[17:39:20.729]                         has_future <- base::requireNamespace("future", 
[17:39:20.729]                           quietly = TRUE)
[17:39:20.729]                         if (has_future) {
[17:39:20.729]                           ns <- base::getNamespace("future")
[17:39:20.729]                           version <- ns[[".package"]][["version"]]
[17:39:20.729]                           if (is.null(version)) 
[17:39:20.729]                             version <- utils::packageVersion("future")
[17:39:20.729]                         }
[17:39:20.729]                         else {
[17:39:20.729]                           version <- NULL
[17:39:20.729]                         }
[17:39:20.729]                         if (!has_future || version < "1.8.0") {
[17:39:20.729]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.729]                             "", base::R.version$version.string), 
[17:39:20.729]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:20.729]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.729]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.729]                               "release", "version")], collapse = " "), 
[17:39:20.729]                             hostname = base::Sys.info()[["nodename"]])
[17:39:20.729]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.729]                             info)
[17:39:20.729]                           info <- base::paste(info, collapse = "; ")
[17:39:20.729]                           if (!has_future) {
[17:39:20.729]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.729]                               info)
[17:39:20.729]                           }
[17:39:20.729]                           else {
[17:39:20.729]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.729]                               info, version)
[17:39:20.729]                           }
[17:39:20.729]                           base::stop(msg)
[17:39:20.729]                         }
[17:39:20.729]                       })
[17:39:20.729]                     }
[17:39:20.729]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:20.729]                     base::options(mc.cores = 1L)
[17:39:20.729]                   }
[17:39:20.729]                   options(future.plan = NULL)
[17:39:20.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.729]                 }
[17:39:20.729]                 ...future.workdir <- getwd()
[17:39:20.729]             }
[17:39:20.729]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.729]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.729]         }
[17:39:20.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.729]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.729]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.729]             base::names(...future.oldOptions))
[17:39:20.729]     }
[17:39:20.729]     if (FALSE) {
[17:39:20.729]     }
[17:39:20.729]     else {
[17:39:20.729]         if (TRUE) {
[17:39:20.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.729]                 open = "w")
[17:39:20.729]         }
[17:39:20.729]         else {
[17:39:20.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.729]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.729]         }
[17:39:20.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.729]             base::sink(type = "output", split = FALSE)
[17:39:20.729]             base::close(...future.stdout)
[17:39:20.729]         }, add = TRUE)
[17:39:20.729]     }
[17:39:20.729]     ...future.frame <- base::sys.nframe()
[17:39:20.729]     ...future.conditions <- base::list()
[17:39:20.729]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.729]     if (FALSE) {
[17:39:20.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.729]     }
[17:39:20.729]     ...future.result <- base::tryCatch({
[17:39:20.729]         base::withCallingHandlers({
[17:39:20.729]             ...future.value <- base::withVisible(base::local({
[17:39:20.729]                 withCallingHandlers({
[17:39:20.729]                   {
[17:39:20.729]                     do.call(function(...) {
[17:39:20.729]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.729]                       if (!identical(...future.globals.maxSize.org, 
[17:39:20.729]                         ...future.globals.maxSize)) {
[17:39:20.729]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.729]                         on.exit(options(oopts), add = TRUE)
[17:39:20.729]                       }
[17:39:20.729]                       {
[17:39:20.729]                         lapply(seq_along(...future.elements_ii), 
[17:39:20.729]                           FUN = function(jj) {
[17:39:20.729]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.729]                             ...future.FUN(...future.X_jj, ...)
[17:39:20.729]                           })
[17:39:20.729]                       }
[17:39:20.729]                     }, args = future.call.arguments)
[17:39:20.729]                   }
[17:39:20.729]                 }, immediateCondition = function(cond) {
[17:39:20.729]                   save_rds <- function (object, pathname, ...) 
[17:39:20.729]                   {
[17:39:20.729]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:20.729]                     if (file_test("-f", pathname_tmp)) {
[17:39:20.729]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.729]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:20.729]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.729]                         fi_tmp[["mtime"]])
[17:39:20.729]                     }
[17:39:20.729]                     tryCatch({
[17:39:20.729]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:20.729]                     }, error = function(ex) {
[17:39:20.729]                       msg <- conditionMessage(ex)
[17:39:20.729]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.729]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:20.729]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.729]                         fi_tmp[["mtime"]], msg)
[17:39:20.729]                       ex$message <- msg
[17:39:20.729]                       stop(ex)
[17:39:20.729]                     })
[17:39:20.729]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:20.729]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:20.729]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:20.729]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.729]                       fi <- file.info(pathname)
[17:39:20.729]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:20.729]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.729]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:20.729]                         fi[["size"]], fi[["mtime"]])
[17:39:20.729]                       stop(msg)
[17:39:20.729]                     }
[17:39:20.729]                     invisible(pathname)
[17:39:20.729]                   }
[17:39:20.729]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:20.729]                     rootPath = tempdir()) 
[17:39:20.729]                   {
[17:39:20.729]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:20.729]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:20.729]                       tmpdir = path, fileext = ".rds")
[17:39:20.729]                     save_rds(obj, file)
[17:39:20.729]                   }
[17:39:20.729]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:20.729]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.729]                   {
[17:39:20.729]                     inherits <- base::inherits
[17:39:20.729]                     invokeRestart <- base::invokeRestart
[17:39:20.729]                     is.null <- base::is.null
[17:39:20.729]                     muffled <- FALSE
[17:39:20.729]                     if (inherits(cond, "message")) {
[17:39:20.729]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:20.729]                       if (muffled) 
[17:39:20.729]                         invokeRestart("muffleMessage")
[17:39:20.729]                     }
[17:39:20.729]                     else if (inherits(cond, "warning")) {
[17:39:20.729]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:20.729]                       if (muffled) 
[17:39:20.729]                         invokeRestart("muffleWarning")
[17:39:20.729]                     }
[17:39:20.729]                     else if (inherits(cond, "condition")) {
[17:39:20.729]                       if (!is.null(pattern)) {
[17:39:20.729]                         computeRestarts <- base::computeRestarts
[17:39:20.729]                         grepl <- base::grepl
[17:39:20.729]                         restarts <- computeRestarts(cond)
[17:39:20.729]                         for (restart in restarts) {
[17:39:20.729]                           name <- restart$name
[17:39:20.729]                           if (is.null(name)) 
[17:39:20.729]                             next
[17:39:20.729]                           if (!grepl(pattern, name)) 
[17:39:20.729]                             next
[17:39:20.729]                           invokeRestart(restart)
[17:39:20.729]                           muffled <- TRUE
[17:39:20.729]                           break
[17:39:20.729]                         }
[17:39:20.729]                       }
[17:39:20.729]                     }
[17:39:20.729]                     invisible(muffled)
[17:39:20.729]                   }
[17:39:20.729]                   muffleCondition(cond)
[17:39:20.729]                 })
[17:39:20.729]             }))
[17:39:20.729]             future::FutureResult(value = ...future.value$value, 
[17:39:20.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.729]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.729]                     ...future.globalenv.names))
[17:39:20.729]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.729]         }, condition = base::local({
[17:39:20.729]             c <- base::c
[17:39:20.729]             inherits <- base::inherits
[17:39:20.729]             invokeRestart <- base::invokeRestart
[17:39:20.729]             length <- base::length
[17:39:20.729]             list <- base::list
[17:39:20.729]             seq.int <- base::seq.int
[17:39:20.729]             signalCondition <- base::signalCondition
[17:39:20.729]             sys.calls <- base::sys.calls
[17:39:20.729]             `[[` <- base::`[[`
[17:39:20.729]             `+` <- base::`+`
[17:39:20.729]             `<<-` <- base::`<<-`
[17:39:20.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.729]                   3L)]
[17:39:20.729]             }
[17:39:20.729]             function(cond) {
[17:39:20.729]                 is_error <- inherits(cond, "error")
[17:39:20.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.729]                   NULL)
[17:39:20.729]                 if (is_error) {
[17:39:20.729]                   sessionInformation <- function() {
[17:39:20.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.729]                       search = base::search(), system = base::Sys.info())
[17:39:20.729]                   }
[17:39:20.729]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.729]                     cond$call), session = sessionInformation(), 
[17:39:20.729]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.729]                   signalCondition(cond)
[17:39:20.729]                 }
[17:39:20.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.729]                 "immediateCondition"))) {
[17:39:20.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.729]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.729]                   if (TRUE && !signal) {
[17:39:20.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.729]                     {
[17:39:20.729]                       inherits <- base::inherits
[17:39:20.729]                       invokeRestart <- base::invokeRestart
[17:39:20.729]                       is.null <- base::is.null
[17:39:20.729]                       muffled <- FALSE
[17:39:20.729]                       if (inherits(cond, "message")) {
[17:39:20.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.729]                         if (muffled) 
[17:39:20.729]                           invokeRestart("muffleMessage")
[17:39:20.729]                       }
[17:39:20.729]                       else if (inherits(cond, "warning")) {
[17:39:20.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.729]                         if (muffled) 
[17:39:20.729]                           invokeRestart("muffleWarning")
[17:39:20.729]                       }
[17:39:20.729]                       else if (inherits(cond, "condition")) {
[17:39:20.729]                         if (!is.null(pattern)) {
[17:39:20.729]                           computeRestarts <- base::computeRestarts
[17:39:20.729]                           grepl <- base::grepl
[17:39:20.729]                           restarts <- computeRestarts(cond)
[17:39:20.729]                           for (restart in restarts) {
[17:39:20.729]                             name <- restart$name
[17:39:20.729]                             if (is.null(name)) 
[17:39:20.729]                               next
[17:39:20.729]                             if (!grepl(pattern, name)) 
[17:39:20.729]                               next
[17:39:20.729]                             invokeRestart(restart)
[17:39:20.729]                             muffled <- TRUE
[17:39:20.729]                             break
[17:39:20.729]                           }
[17:39:20.729]                         }
[17:39:20.729]                       }
[17:39:20.729]                       invisible(muffled)
[17:39:20.729]                     }
[17:39:20.729]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.729]                   }
[17:39:20.729]                 }
[17:39:20.729]                 else {
[17:39:20.729]                   if (TRUE) {
[17:39:20.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.729]                     {
[17:39:20.729]                       inherits <- base::inherits
[17:39:20.729]                       invokeRestart <- base::invokeRestart
[17:39:20.729]                       is.null <- base::is.null
[17:39:20.729]                       muffled <- FALSE
[17:39:20.729]                       if (inherits(cond, "message")) {
[17:39:20.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.729]                         if (muffled) 
[17:39:20.729]                           invokeRestart("muffleMessage")
[17:39:20.729]                       }
[17:39:20.729]                       else if (inherits(cond, "warning")) {
[17:39:20.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.729]                         if (muffled) 
[17:39:20.729]                           invokeRestart("muffleWarning")
[17:39:20.729]                       }
[17:39:20.729]                       else if (inherits(cond, "condition")) {
[17:39:20.729]                         if (!is.null(pattern)) {
[17:39:20.729]                           computeRestarts <- base::computeRestarts
[17:39:20.729]                           grepl <- base::grepl
[17:39:20.729]                           restarts <- computeRestarts(cond)
[17:39:20.729]                           for (restart in restarts) {
[17:39:20.729]                             name <- restart$name
[17:39:20.729]                             if (is.null(name)) 
[17:39:20.729]                               next
[17:39:20.729]                             if (!grepl(pattern, name)) 
[17:39:20.729]                               next
[17:39:20.729]                             invokeRestart(restart)
[17:39:20.729]                             muffled <- TRUE
[17:39:20.729]                             break
[17:39:20.729]                           }
[17:39:20.729]                         }
[17:39:20.729]                       }
[17:39:20.729]                       invisible(muffled)
[17:39:20.729]                     }
[17:39:20.729]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.729]                   }
[17:39:20.729]                 }
[17:39:20.729]             }
[17:39:20.729]         }))
[17:39:20.729]     }, error = function(ex) {
[17:39:20.729]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.729]                 ...future.rng), started = ...future.startTime, 
[17:39:20.729]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.729]             version = "1.8"), class = "FutureResult")
[17:39:20.729]     }, finally = {
[17:39:20.729]         if (!identical(...future.workdir, getwd())) 
[17:39:20.729]             setwd(...future.workdir)
[17:39:20.729]         {
[17:39:20.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.729]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.729]             }
[17:39:20.729]             base::options(...future.oldOptions)
[17:39:20.729]             if (.Platform$OS.type == "windows") {
[17:39:20.729]                 old_names <- names(...future.oldEnvVars)
[17:39:20.729]                 envs <- base::Sys.getenv()
[17:39:20.729]                 names <- names(envs)
[17:39:20.729]                 common <- intersect(names, old_names)
[17:39:20.729]                 added <- setdiff(names, old_names)
[17:39:20.729]                 removed <- setdiff(old_names, names)
[17:39:20.729]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.729]                   envs[common]]
[17:39:20.729]                 NAMES <- toupper(changed)
[17:39:20.729]                 args <- list()
[17:39:20.729]                 for (kk in seq_along(NAMES)) {
[17:39:20.729]                   name <- changed[[kk]]
[17:39:20.729]                   NAME <- NAMES[[kk]]
[17:39:20.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.729]                     next
[17:39:20.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.729]                 }
[17:39:20.729]                 NAMES <- toupper(added)
[17:39:20.729]                 for (kk in seq_along(NAMES)) {
[17:39:20.729]                   name <- added[[kk]]
[17:39:20.729]                   NAME <- NAMES[[kk]]
[17:39:20.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.729]                     next
[17:39:20.729]                   args[[name]] <- ""
[17:39:20.729]                 }
[17:39:20.729]                 NAMES <- toupper(removed)
[17:39:20.729]                 for (kk in seq_along(NAMES)) {
[17:39:20.729]                   name <- removed[[kk]]
[17:39:20.729]                   NAME <- NAMES[[kk]]
[17:39:20.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.729]                     next
[17:39:20.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.729]                 }
[17:39:20.729]                 if (length(args) > 0) 
[17:39:20.729]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.729]             }
[17:39:20.729]             else {
[17:39:20.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.729]             }
[17:39:20.729]             {
[17:39:20.729]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.729]                   0L) {
[17:39:20.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.729]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.729]                   base::options(opts)
[17:39:20.729]                 }
[17:39:20.729]                 {
[17:39:20.729]                   {
[17:39:20.729]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:20.729]                     NULL
[17:39:20.729]                   }
[17:39:20.729]                   options(future.plan = NULL)
[17:39:20.729]                   if (is.na(NA_character_)) 
[17:39:20.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.729]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:20.729]                     envir = parent.frame()) 
[17:39:20.729]                   {
[17:39:20.729]                     default_workers <- missing(workers)
[17:39:20.729]                     if (is.function(workers)) 
[17:39:20.729]                       workers <- workers()
[17:39:20.729]                     workers <- structure(as.integer(workers), 
[17:39:20.729]                       class = class(workers))
[17:39:20.729]                     stop_if_not(is.finite(workers), workers >= 
[17:39:20.729]                       1L)
[17:39:20.729]                     if ((workers == 1L && !inherits(workers, 
[17:39:20.729]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:20.729]                       if (default_workers) 
[17:39:20.729]                         supportsMulticore(warn = TRUE)
[17:39:20.729]                       return(sequential(..., envir = envir))
[17:39:20.729]                     }
[17:39:20.729]                     oopts <- options(mc.cores = workers)
[17:39:20.729]                     on.exit(options(oopts))
[17:39:20.729]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:20.729]                       envir = envir)
[17:39:20.729]                     if (!future$lazy) 
[17:39:20.729]                       future <- run(future)
[17:39:20.729]                     invisible(future)
[17:39:20.729]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.729]                 }
[17:39:20.729]             }
[17:39:20.729]         }
[17:39:20.729]     })
[17:39:20.729]     if (TRUE) {
[17:39:20.729]         base::sink(type = "output", split = FALSE)
[17:39:20.729]         if (TRUE) {
[17:39:20.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.729]         }
[17:39:20.729]         else {
[17:39:20.729]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.729]         }
[17:39:20.729]         base::close(...future.stdout)
[17:39:20.729]         ...future.stdout <- NULL
[17:39:20.729]     }
[17:39:20.729]     ...future.result$conditions <- ...future.conditions
[17:39:20.729]     ...future.result$finished <- base::Sys.time()
[17:39:20.729]     ...future.result
[17:39:20.729] }
[17:39:20.732] assign_globals() ...
[17:39:20.732] List of 5
[17:39:20.732]  $ future.call.arguments    : list()
[17:39:20.732]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.732]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:20.732]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:20.732]  $ ...future.elements_ii    :List of 1
[17:39:20.732]   ..$ : num [1:4] 2 4 6 8
[17:39:20.732]  $ ...future.seeds_ii       : NULL
[17:39:20.732]  $ ...future.globals.maxSize: NULL
[17:39:20.732]  - attr(*, "where")=List of 5
[17:39:20.732]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.732]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.732]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.732]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.732]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.732]  - attr(*, "resolved")= logi FALSE
[17:39:20.732]  - attr(*, "total_size")= num NA
[17:39:20.732]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.732]  - attr(*, "already-done")= logi TRUE
[17:39:20.740] - copied ‘future.call.arguments’ to environment
[17:39:20.740] - copied ‘...future.FUN’ to environment
[17:39:20.740] - copied ‘...future.elements_ii’ to environment
[17:39:20.740] - copied ‘...future.seeds_ii’ to environment
[17:39:20.740] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.741] assign_globals() ... done
[17:39:20.741] requestCore(): workers = 2
[17:39:20.743] MulticoreFuture started
[17:39:20.743] - Launch lazy future ... done
[17:39:20.743] run() for ‘MulticoreFuture’ ... done
[17:39:20.744] Created future:
[17:39:20.744] plan(): Setting new future strategy stack:
[17:39:20.744] List of future strategies:
[17:39:20.744] 1. sequential:
[17:39:20.744]    - args: function (..., envir = parent.frame())
[17:39:20.744]    - tweaked: FALSE
[17:39:20.744]    - call: NULL
[17:39:20.745] plan(): nbrOfWorkers() = 1
[17:39:20.747] plan(): Setting new future strategy stack:
[17:39:20.748] List of future strategies:
[17:39:20.748] 1. multicore:
[17:39:20.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.748]    - tweaked: FALSE
[17:39:20.748]    - call: plan(strategy)
[17:39:20.753] plan(): nbrOfWorkers() = 2
[17:39:20.744] MulticoreFuture:
[17:39:20.744] Label: ‘future_apply-2’
[17:39:20.744] Expression:
[17:39:20.744] {
[17:39:20.744]     do.call(function(...) {
[17:39:20.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.744]             on.exit(options(oopts), add = TRUE)
[17:39:20.744]         }
[17:39:20.744]         {
[17:39:20.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.744]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.744]             })
[17:39:20.744]         }
[17:39:20.744]     }, args = future.call.arguments)
[17:39:20.744] }
[17:39:20.744] Lazy evaluation: FALSE
[17:39:20.744] Asynchronous evaluation: TRUE
[17:39:20.744] Local evaluation: TRUE
[17:39:20.744] Environment: R_GlobalEnv
[17:39:20.744] Capture standard output: TRUE
[17:39:20.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.744] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:20.744] Packages: <none>
[17:39:20.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.744] Resolved: TRUE
[17:39:20.744] Value: <not collected>
[17:39:20.744] Conditions captured: <none>
[17:39:20.744] Early signaling: FALSE
[17:39:20.744] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.744] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.754] Chunk #2 of 2 ... DONE
[17:39:20.754] Launching 2 futures (chunks) ... DONE
[17:39:20.754] Resolving 2 futures (chunks) ...
[17:39:20.755] resolve() on list ...
[17:39:20.755]  recursive: 0
[17:39:20.755]  length: 2
[17:39:20.755] 
[17:39:20.756] Future #1
[17:39:20.757] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:20.757] - nx: 2
[17:39:20.757] - relay: TRUE
[17:39:20.757] - stdout: TRUE
[17:39:20.757] - signal: TRUE
[17:39:20.758] - resignal: FALSE
[17:39:20.758] - force: TRUE
[17:39:20.758] - relayed: [n=2] FALSE, FALSE
[17:39:20.758] - queued futures: [n=2] FALSE, FALSE
[17:39:20.758]  - until=1
[17:39:20.759]  - relaying element #1
[17:39:20.759] - relayed: [n=2] TRUE, FALSE
[17:39:20.759] - queued futures: [n=2] TRUE, FALSE
[17:39:20.759] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:20.760]  length: 1 (resolved future 1)
[17:39:20.760] Future #2
[17:39:20.761] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:20.761] - nx: 2
[17:39:20.761] - relay: TRUE
[17:39:20.761] - stdout: TRUE
[17:39:20.761] - signal: TRUE
[17:39:20.762] - resignal: FALSE
[17:39:20.762] - force: TRUE
[17:39:20.762] - relayed: [n=2] TRUE, FALSE
[17:39:20.762] - queued futures: [n=2] TRUE, FALSE
[17:39:20.762]  - until=2
[17:39:20.762]  - relaying element #2
[17:39:20.762] - relayed: [n=2] TRUE, TRUE
[17:39:20.763] - queued futures: [n=2] TRUE, TRUE
[17:39:20.763] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:20.763]  length: 0 (resolved future 2)
[17:39:20.763] Relaying remaining futures
[17:39:20.763] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.763] - nx: 2
[17:39:20.763] - relay: TRUE
[17:39:20.763] - stdout: TRUE
[17:39:20.764] - signal: TRUE
[17:39:20.764] - resignal: FALSE
[17:39:20.764] - force: TRUE
[17:39:20.764] - relayed: [n=2] TRUE, TRUE
[17:39:20.764] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:20.764] - relayed: [n=2] TRUE, TRUE
[17:39:20.764] - queued futures: [n=2] TRUE, TRUE
[17:39:20.764] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.764] resolve() on list ... DONE
[17:39:20.765]  - Number of value chunks collected: 2
[17:39:20.765] Resolving 2 futures (chunks) ... DONE
[17:39:20.765] Reducing values from 2 chunks ...
[17:39:20.765]  - Number of values collected after concatenation: 2
[17:39:20.765]  - Number of values expected: 2
[17:39:20.765] Reducing values from 2 chunks ... DONE
[17:39:20.765] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:39:20.766] getGlobalsAndPackagesXApply() ...
[17:39:20.766]  - future.globals: TRUE
[17:39:20.767] getGlobalsAndPackages() ...
[17:39:20.767] Searching for globals...
[17:39:20.768] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:20.768] Searching for globals ... DONE
[17:39:20.768] Resolving globals: FALSE
[17:39:20.769] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:20.769] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:20.769] - globals: [1] ‘FUN’
[17:39:20.770] - packages: [1] ‘stats’
[17:39:20.770] getGlobalsAndPackages() ... DONE
[17:39:20.770]  - globals found/used: [n=1] ‘FUN’
[17:39:20.770]  - needed namespaces: [n=1] ‘stats’
[17:39:20.770] Finding globals ... DONE
[17:39:20.770]  - use_args: TRUE
[17:39:20.770]  - Getting '...' globals ...
[17:39:20.776] resolve() on list ...
[17:39:20.776]  recursive: 0
[17:39:20.776]  length: 1
[17:39:20.776]  elements: ‘...’
[17:39:20.776]  length: 0 (resolved future 1)
[17:39:20.776] resolve() on list ... DONE
[17:39:20.776]    - '...' content: [n=0] 
[17:39:20.776] List of 1
[17:39:20.776]  $ ...: list()
[17:39:20.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.776]  - attr(*, "where")=List of 1
[17:39:20.776]   ..$ ...:<environment: 0x55c796ce4e30> 
[17:39:20.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.776]  - attr(*, "resolved")= logi TRUE
[17:39:20.776]  - attr(*, "total_size")= num NA
[17:39:20.780]  - Getting '...' globals ... DONE
[17:39:20.780] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.780] List of 2
[17:39:20.780]  $ ...future.FUN:function (x, ...)  
[17:39:20.780]  $ ...          : list()
[17:39:20.780]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.780]  - attr(*, "where")=List of 2
[17:39:20.780]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.780]   ..$ ...          :<environment: 0x55c796ce4e30> 
[17:39:20.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.780]  - attr(*, "resolved")= logi FALSE
[17:39:20.780]  - attr(*, "total_size")= num 1248
[17:39:20.783] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:20.784] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.787] future_lapply() ...
[17:39:20.791] Number of chunks: 2
[17:39:20.791] getGlobalsAndPackagesXApply() ...
[17:39:20.791]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.791]  - use_args: TRUE
[17:39:20.791] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.792] List of 2
[17:39:20.792]  $ ...          : list()
[17:39:20.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.792]  $ ...future.FUN:function (x, ...)  
[17:39:20.792]  - attr(*, "where")=List of 2
[17:39:20.792]   ..$ ...          :<environment: 0x55c796ce4e30> 
[17:39:20.792]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:39:20.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.792]  - attr(*, "resolved")= logi FALSE
[17:39:20.792]  - attr(*, "total_size")= num NA
[17:39:20.794] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:20.794] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.795] Number of futures (= number of chunks): 2
[17:39:20.795] Launching 2 futures (chunks) ...
[17:39:20.795] Chunk #1 of 2 ...
[17:39:20.795]  - seeds: <none>
[17:39:20.795] getGlobalsAndPackages() ...
[17:39:20.795] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.795] Resolving globals: FALSE
[17:39:20.795] Tweak future expression to call with '...' arguments ...
[17:39:20.796] {
[17:39:20.796]     do.call(function(...) {
[17:39:20.796]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.796]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.796]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.796]             on.exit(options(oopts), add = TRUE)
[17:39:20.796]         }
[17:39:20.796]         {
[17:39:20.796]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.796]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.796]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.796]             })
[17:39:20.796]         }
[17:39:20.796]     }, args = future.call.arguments)
[17:39:20.796] }
[17:39:20.796] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.796] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.796] - packages: [1] ‘stats’
[17:39:20.796] getGlobalsAndPackages() ... DONE
[17:39:20.797] run() for ‘Future’ ...
[17:39:20.797] - state: ‘created’
[17:39:20.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:20.800] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.801] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:20.801]   - Field: ‘label’
[17:39:20.801]   - Field: ‘local’
[17:39:20.801]   - Field: ‘owner’
[17:39:20.801]   - Field: ‘envir’
[17:39:20.801]   - Field: ‘workers’
[17:39:20.801]   - Field: ‘packages’
[17:39:20.801]   - Field: ‘gc’
[17:39:20.801]   - Field: ‘job’
[17:39:20.801]   - Field: ‘conditions’
[17:39:20.802]   - Field: ‘expr’
[17:39:20.802]   - Field: ‘uuid’
[17:39:20.802]   - Field: ‘seed’
[17:39:20.802]   - Field: ‘version’
[17:39:20.802]   - Field: ‘result’
[17:39:20.802]   - Field: ‘asynchronous’
[17:39:20.802]   - Field: ‘calls’
[17:39:20.802]   - Field: ‘globals’
[17:39:20.802]   - Field: ‘stdout’
[17:39:20.802]   - Field: ‘earlySignal’
[17:39:20.802]   - Field: ‘lazy’
[17:39:20.803]   - Field: ‘state’
[17:39:20.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:20.803] - Launch lazy future ...
[17:39:20.803] Packages needed by the future expression (n = 1): ‘stats’
[17:39:20.803] Packages needed by future strategies (n = 0): <none>
[17:39:20.804] {
[17:39:20.804]     {
[17:39:20.804]         {
[17:39:20.804]             ...future.startTime <- base::Sys.time()
[17:39:20.804]             {
[17:39:20.804]                 {
[17:39:20.804]                   {
[17:39:20.804]                     {
[17:39:20.804]                       {
[17:39:20.804]                         base::local({
[17:39:20.804]                           has_future <- base::requireNamespace("future", 
[17:39:20.804]                             quietly = TRUE)
[17:39:20.804]                           if (has_future) {
[17:39:20.804]                             ns <- base::getNamespace("future")
[17:39:20.804]                             version <- ns[[".package"]][["version"]]
[17:39:20.804]                             if (is.null(version)) 
[17:39:20.804]                               version <- utils::packageVersion("future")
[17:39:20.804]                           }
[17:39:20.804]                           else {
[17:39:20.804]                             version <- NULL
[17:39:20.804]                           }
[17:39:20.804]                           if (!has_future || version < "1.8.0") {
[17:39:20.804]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.804]                               "", base::R.version$version.string), 
[17:39:20.804]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:20.804]                                 base::R.version$platform, 8 * 
[17:39:20.804]                                   base::.Machine$sizeof.pointer), 
[17:39:20.804]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.804]                                 "release", "version")], collapse = " "), 
[17:39:20.804]                               hostname = base::Sys.info()[["nodename"]])
[17:39:20.804]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.804]                               info)
[17:39:20.804]                             info <- base::paste(info, collapse = "; ")
[17:39:20.804]                             if (!has_future) {
[17:39:20.804]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.804]                                 info)
[17:39:20.804]                             }
[17:39:20.804]                             else {
[17:39:20.804]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.804]                                 info, version)
[17:39:20.804]                             }
[17:39:20.804]                             base::stop(msg)
[17:39:20.804]                           }
[17:39:20.804]                         })
[17:39:20.804]                       }
[17:39:20.804]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:20.804]                       base::options(mc.cores = 1L)
[17:39:20.804]                     }
[17:39:20.804]                     base::local({
[17:39:20.804]                       for (pkg in "stats") {
[17:39:20.804]                         base::loadNamespace(pkg)
[17:39:20.804]                         base::library(pkg, character.only = TRUE)
[17:39:20.804]                       }
[17:39:20.804]                     })
[17:39:20.804]                   }
[17:39:20.804]                   options(future.plan = NULL)
[17:39:20.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.804]                 }
[17:39:20.804]                 ...future.workdir <- getwd()
[17:39:20.804]             }
[17:39:20.804]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.804]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.804]         }
[17:39:20.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.804]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.804]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.804]             base::names(...future.oldOptions))
[17:39:20.804]     }
[17:39:20.804]     if (FALSE) {
[17:39:20.804]     }
[17:39:20.804]     else {
[17:39:20.804]         if (TRUE) {
[17:39:20.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.804]                 open = "w")
[17:39:20.804]         }
[17:39:20.804]         else {
[17:39:20.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.804]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.804]         }
[17:39:20.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.804]             base::sink(type = "output", split = FALSE)
[17:39:20.804]             base::close(...future.stdout)
[17:39:20.804]         }, add = TRUE)
[17:39:20.804]     }
[17:39:20.804]     ...future.frame <- base::sys.nframe()
[17:39:20.804]     ...future.conditions <- base::list()
[17:39:20.804]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.804]     if (FALSE) {
[17:39:20.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.804]     }
[17:39:20.804]     ...future.result <- base::tryCatch({
[17:39:20.804]         base::withCallingHandlers({
[17:39:20.804]             ...future.value <- base::withVisible(base::local({
[17:39:20.804]                 withCallingHandlers({
[17:39:20.804]                   {
[17:39:20.804]                     do.call(function(...) {
[17:39:20.804]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.804]                       if (!identical(...future.globals.maxSize.org, 
[17:39:20.804]                         ...future.globals.maxSize)) {
[17:39:20.804]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.804]                         on.exit(options(oopts), add = TRUE)
[17:39:20.804]                       }
[17:39:20.804]                       {
[17:39:20.804]                         lapply(seq_along(...future.elements_ii), 
[17:39:20.804]                           FUN = function(jj) {
[17:39:20.804]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.804]                             ...future.FUN(...future.X_jj, ...)
[17:39:20.804]                           })
[17:39:20.804]                       }
[17:39:20.804]                     }, args = future.call.arguments)
[17:39:20.804]                   }
[17:39:20.804]                 }, immediateCondition = function(cond) {
[17:39:20.804]                   save_rds <- function (object, pathname, ...) 
[17:39:20.804]                   {
[17:39:20.804]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:20.804]                     if (file_test("-f", pathname_tmp)) {
[17:39:20.804]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.804]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:20.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.804]                         fi_tmp[["mtime"]])
[17:39:20.804]                     }
[17:39:20.804]                     tryCatch({
[17:39:20.804]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:20.804]                     }, error = function(ex) {
[17:39:20.804]                       msg <- conditionMessage(ex)
[17:39:20.804]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.804]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:20.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.804]                         fi_tmp[["mtime"]], msg)
[17:39:20.804]                       ex$message <- msg
[17:39:20.804]                       stop(ex)
[17:39:20.804]                     })
[17:39:20.804]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:20.804]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:20.804]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:20.804]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.804]                       fi <- file.info(pathname)
[17:39:20.804]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:20.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.804]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:20.804]                         fi[["size"]], fi[["mtime"]])
[17:39:20.804]                       stop(msg)
[17:39:20.804]                     }
[17:39:20.804]                     invisible(pathname)
[17:39:20.804]                   }
[17:39:20.804]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:20.804]                     rootPath = tempdir()) 
[17:39:20.804]                   {
[17:39:20.804]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:20.804]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:20.804]                       tmpdir = path, fileext = ".rds")
[17:39:20.804]                     save_rds(obj, file)
[17:39:20.804]                   }
[17:39:20.804]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:20.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.804]                   {
[17:39:20.804]                     inherits <- base::inherits
[17:39:20.804]                     invokeRestart <- base::invokeRestart
[17:39:20.804]                     is.null <- base::is.null
[17:39:20.804]                     muffled <- FALSE
[17:39:20.804]                     if (inherits(cond, "message")) {
[17:39:20.804]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:20.804]                       if (muffled) 
[17:39:20.804]                         invokeRestart("muffleMessage")
[17:39:20.804]                     }
[17:39:20.804]                     else if (inherits(cond, "warning")) {
[17:39:20.804]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:20.804]                       if (muffled) 
[17:39:20.804]                         invokeRestart("muffleWarning")
[17:39:20.804]                     }
[17:39:20.804]                     else if (inherits(cond, "condition")) {
[17:39:20.804]                       if (!is.null(pattern)) {
[17:39:20.804]                         computeRestarts <- base::computeRestarts
[17:39:20.804]                         grepl <- base::grepl
[17:39:20.804]                         restarts <- computeRestarts(cond)
[17:39:20.804]                         for (restart in restarts) {
[17:39:20.804]                           name <- restart$name
[17:39:20.804]                           if (is.null(name)) 
[17:39:20.804]                             next
[17:39:20.804]                           if (!grepl(pattern, name)) 
[17:39:20.804]                             next
[17:39:20.804]                           invokeRestart(restart)
[17:39:20.804]                           muffled <- TRUE
[17:39:20.804]                           break
[17:39:20.804]                         }
[17:39:20.804]                       }
[17:39:20.804]                     }
[17:39:20.804]                     invisible(muffled)
[17:39:20.804]                   }
[17:39:20.804]                   muffleCondition(cond)
[17:39:20.804]                 })
[17:39:20.804]             }))
[17:39:20.804]             future::FutureResult(value = ...future.value$value, 
[17:39:20.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.804]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.804]                     ...future.globalenv.names))
[17:39:20.804]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.804]         }, condition = base::local({
[17:39:20.804]             c <- base::c
[17:39:20.804]             inherits <- base::inherits
[17:39:20.804]             invokeRestart <- base::invokeRestart
[17:39:20.804]             length <- base::length
[17:39:20.804]             list <- base::list
[17:39:20.804]             seq.int <- base::seq.int
[17:39:20.804]             signalCondition <- base::signalCondition
[17:39:20.804]             sys.calls <- base::sys.calls
[17:39:20.804]             `[[` <- base::`[[`
[17:39:20.804]             `+` <- base::`+`
[17:39:20.804]             `<<-` <- base::`<<-`
[17:39:20.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.804]                   3L)]
[17:39:20.804]             }
[17:39:20.804]             function(cond) {
[17:39:20.804]                 is_error <- inherits(cond, "error")
[17:39:20.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.804]                   NULL)
[17:39:20.804]                 if (is_error) {
[17:39:20.804]                   sessionInformation <- function() {
[17:39:20.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.804]                       search = base::search(), system = base::Sys.info())
[17:39:20.804]                   }
[17:39:20.804]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.804]                     cond$call), session = sessionInformation(), 
[17:39:20.804]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.804]                   signalCondition(cond)
[17:39:20.804]                 }
[17:39:20.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.804]                 "immediateCondition"))) {
[17:39:20.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.804]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.804]                   if (TRUE && !signal) {
[17:39:20.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.804]                     {
[17:39:20.804]                       inherits <- base::inherits
[17:39:20.804]                       invokeRestart <- base::invokeRestart
[17:39:20.804]                       is.null <- base::is.null
[17:39:20.804]                       muffled <- FALSE
[17:39:20.804]                       if (inherits(cond, "message")) {
[17:39:20.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.804]                         if (muffled) 
[17:39:20.804]                           invokeRestart("muffleMessage")
[17:39:20.804]                       }
[17:39:20.804]                       else if (inherits(cond, "warning")) {
[17:39:20.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.804]                         if (muffled) 
[17:39:20.804]                           invokeRestart("muffleWarning")
[17:39:20.804]                       }
[17:39:20.804]                       else if (inherits(cond, "condition")) {
[17:39:20.804]                         if (!is.null(pattern)) {
[17:39:20.804]                           computeRestarts <- base::computeRestarts
[17:39:20.804]                           grepl <- base::grepl
[17:39:20.804]                           restarts <- computeRestarts(cond)
[17:39:20.804]                           for (restart in restarts) {
[17:39:20.804]                             name <- restart$name
[17:39:20.804]                             if (is.null(name)) 
[17:39:20.804]                               next
[17:39:20.804]                             if (!grepl(pattern, name)) 
[17:39:20.804]                               next
[17:39:20.804]                             invokeRestart(restart)
[17:39:20.804]                             muffled <- TRUE
[17:39:20.804]                             break
[17:39:20.804]                           }
[17:39:20.804]                         }
[17:39:20.804]                       }
[17:39:20.804]                       invisible(muffled)
[17:39:20.804]                     }
[17:39:20.804]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.804]                   }
[17:39:20.804]                 }
[17:39:20.804]                 else {
[17:39:20.804]                   if (TRUE) {
[17:39:20.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.804]                     {
[17:39:20.804]                       inherits <- base::inherits
[17:39:20.804]                       invokeRestart <- base::invokeRestart
[17:39:20.804]                       is.null <- base::is.null
[17:39:20.804]                       muffled <- FALSE
[17:39:20.804]                       if (inherits(cond, "message")) {
[17:39:20.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.804]                         if (muffled) 
[17:39:20.804]                           invokeRestart("muffleMessage")
[17:39:20.804]                       }
[17:39:20.804]                       else if (inherits(cond, "warning")) {
[17:39:20.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.804]                         if (muffled) 
[17:39:20.804]                           invokeRestart("muffleWarning")
[17:39:20.804]                       }
[17:39:20.804]                       else if (inherits(cond, "condition")) {
[17:39:20.804]                         if (!is.null(pattern)) {
[17:39:20.804]                           computeRestarts <- base::computeRestarts
[17:39:20.804]                           grepl <- base::grepl
[17:39:20.804]                           restarts <- computeRestarts(cond)
[17:39:20.804]                           for (restart in restarts) {
[17:39:20.804]                             name <- restart$name
[17:39:20.804]                             if (is.null(name)) 
[17:39:20.804]                               next
[17:39:20.804]                             if (!grepl(pattern, name)) 
[17:39:20.804]                               next
[17:39:20.804]                             invokeRestart(restart)
[17:39:20.804]                             muffled <- TRUE
[17:39:20.804]                             break
[17:39:20.804]                           }
[17:39:20.804]                         }
[17:39:20.804]                       }
[17:39:20.804]                       invisible(muffled)
[17:39:20.804]                     }
[17:39:20.804]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.804]                   }
[17:39:20.804]                 }
[17:39:20.804]             }
[17:39:20.804]         }))
[17:39:20.804]     }, error = function(ex) {
[17:39:20.804]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.804]                 ...future.rng), started = ...future.startTime, 
[17:39:20.804]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.804]             version = "1.8"), class = "FutureResult")
[17:39:20.804]     }, finally = {
[17:39:20.804]         if (!identical(...future.workdir, getwd())) 
[17:39:20.804]             setwd(...future.workdir)
[17:39:20.804]         {
[17:39:20.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.804]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.804]             }
[17:39:20.804]             base::options(...future.oldOptions)
[17:39:20.804]             if (.Platform$OS.type == "windows") {
[17:39:20.804]                 old_names <- names(...future.oldEnvVars)
[17:39:20.804]                 envs <- base::Sys.getenv()
[17:39:20.804]                 names <- names(envs)
[17:39:20.804]                 common <- intersect(names, old_names)
[17:39:20.804]                 added <- setdiff(names, old_names)
[17:39:20.804]                 removed <- setdiff(old_names, names)
[17:39:20.804]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.804]                   envs[common]]
[17:39:20.804]                 NAMES <- toupper(changed)
[17:39:20.804]                 args <- list()
[17:39:20.804]                 for (kk in seq_along(NAMES)) {
[17:39:20.804]                   name <- changed[[kk]]
[17:39:20.804]                   NAME <- NAMES[[kk]]
[17:39:20.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.804]                     next
[17:39:20.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.804]                 }
[17:39:20.804]                 NAMES <- toupper(added)
[17:39:20.804]                 for (kk in seq_along(NAMES)) {
[17:39:20.804]                   name <- added[[kk]]
[17:39:20.804]                   NAME <- NAMES[[kk]]
[17:39:20.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.804]                     next
[17:39:20.804]                   args[[name]] <- ""
[17:39:20.804]                 }
[17:39:20.804]                 NAMES <- toupper(removed)
[17:39:20.804]                 for (kk in seq_along(NAMES)) {
[17:39:20.804]                   name <- removed[[kk]]
[17:39:20.804]                   NAME <- NAMES[[kk]]
[17:39:20.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.804]                     next
[17:39:20.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.804]                 }
[17:39:20.804]                 if (length(args) > 0) 
[17:39:20.804]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.804]             }
[17:39:20.804]             else {
[17:39:20.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.804]             }
[17:39:20.804]             {
[17:39:20.804]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.804]                   0L) {
[17:39:20.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.804]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.804]                   base::options(opts)
[17:39:20.804]                 }
[17:39:20.804]                 {
[17:39:20.804]                   {
[17:39:20.804]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:20.804]                     NULL
[17:39:20.804]                   }
[17:39:20.804]                   options(future.plan = NULL)
[17:39:20.804]                   if (is.na(NA_character_)) 
[17:39:20.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.804]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:20.804]                     envir = parent.frame()) 
[17:39:20.804]                   {
[17:39:20.804]                     default_workers <- missing(workers)
[17:39:20.804]                     if (is.function(workers)) 
[17:39:20.804]                       workers <- workers()
[17:39:20.804]                     workers <- structure(as.integer(workers), 
[17:39:20.804]                       class = class(workers))
[17:39:20.804]                     stop_if_not(is.finite(workers), workers >= 
[17:39:20.804]                       1L)
[17:39:20.804]                     if ((workers == 1L && !inherits(workers, 
[17:39:20.804]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:20.804]                       if (default_workers) 
[17:39:20.804]                         supportsMulticore(warn = TRUE)
[17:39:20.804]                       return(sequential(..., envir = envir))
[17:39:20.804]                     }
[17:39:20.804]                     oopts <- options(mc.cores = workers)
[17:39:20.804]                     on.exit(options(oopts))
[17:39:20.804]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:20.804]                       envir = envir)
[17:39:20.804]                     if (!future$lazy) 
[17:39:20.804]                       future <- run(future)
[17:39:20.804]                     invisible(future)
[17:39:20.804]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.804]                 }
[17:39:20.804]             }
[17:39:20.804]         }
[17:39:20.804]     })
[17:39:20.804]     if (TRUE) {
[17:39:20.804]         base::sink(type = "output", split = FALSE)
[17:39:20.804]         if (TRUE) {
[17:39:20.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.804]         }
[17:39:20.804]         else {
[17:39:20.804]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.804]         }
[17:39:20.804]         base::close(...future.stdout)
[17:39:20.804]         ...future.stdout <- NULL
[17:39:20.804]     }
[17:39:20.804]     ...future.result$conditions <- ...future.conditions
[17:39:20.804]     ...future.result$finished <- base::Sys.time()
[17:39:20.804]     ...future.result
[17:39:20.804] }
[17:39:20.806] assign_globals() ...
[17:39:20.806] List of 5
[17:39:20.806]  $ future.call.arguments    : list()
[17:39:20.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.806]  $ ...future.FUN            :function (x, ...)  
[17:39:20.806]  $ ...future.elements_ii    :List of 1
[17:39:20.806]   ..$ : num [1:4] 1 3 1 7
[17:39:20.806]  $ ...future.seeds_ii       : NULL
[17:39:20.806]  $ ...future.globals.maxSize: NULL
[17:39:20.806]  - attr(*, "where")=List of 5
[17:39:20.806]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.806]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.806]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.806]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.806]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.806]  - attr(*, "resolved")= logi FALSE
[17:39:20.806]  - attr(*, "total_size")= num NA
[17:39:20.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.806]  - attr(*, "already-done")= logi TRUE
[17:39:20.812] - copied ‘future.call.arguments’ to environment
[17:39:20.813] - copied ‘...future.FUN’ to environment
[17:39:20.813] - copied ‘...future.elements_ii’ to environment
[17:39:20.813] - copied ‘...future.seeds_ii’ to environment
[17:39:20.813] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.813] assign_globals() ... done
[17:39:20.813] requestCore(): workers = 2
[17:39:20.815] MulticoreFuture started
[17:39:20.816] - Launch lazy future ... done
[17:39:20.816] run() for ‘MulticoreFuture’ ... done
[17:39:20.817] Created future:
[17:39:20.817] plan(): Setting new future strategy stack:
[17:39:20.817] List of future strategies:
[17:39:20.817] 1. sequential:
[17:39:20.817]    - args: function (..., envir = parent.frame())
[17:39:20.817]    - tweaked: FALSE
[17:39:20.817]    - call: NULL
[17:39:20.818] plan(): nbrOfWorkers() = 1
[17:39:20.821] plan(): Setting new future strategy stack:
[17:39:20.821] List of future strategies:
[17:39:20.821] 1. multicore:
[17:39:20.821]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.821]    - tweaked: FALSE
[17:39:20.821]    - call: plan(strategy)
[17:39:20.826] plan(): nbrOfWorkers() = 2
[17:39:20.817] MulticoreFuture:
[17:39:20.817] Label: ‘future_apply-1’
[17:39:20.817] Expression:
[17:39:20.817] {
[17:39:20.817]     do.call(function(...) {
[17:39:20.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.817]             on.exit(options(oopts), add = TRUE)
[17:39:20.817]         }
[17:39:20.817]         {
[17:39:20.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.817]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.817]             })
[17:39:20.817]         }
[17:39:20.817]     }, args = future.call.arguments)
[17:39:20.817] }
[17:39:20.817] Lazy evaluation: FALSE
[17:39:20.817] Asynchronous evaluation: TRUE
[17:39:20.817] Local evaluation: TRUE
[17:39:20.817] Environment: R_GlobalEnv
[17:39:20.817] Capture standard output: TRUE
[17:39:20.817] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.817] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:20.817] Packages: 1 packages (‘stats’)
[17:39:20.817] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.817] Resolved: TRUE
[17:39:20.817] Value: <not collected>
[17:39:20.817] Conditions captured: <none>
[17:39:20.817] Early signaling: FALSE
[17:39:20.817] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.817] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.827] Chunk #1 of 2 ... DONE
[17:39:20.827] Chunk #2 of 2 ...
[17:39:20.828]  - seeds: <none>
[17:39:20.828] getGlobalsAndPackages() ...
[17:39:20.828] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.828] Resolving globals: FALSE
[17:39:20.828] Tweak future expression to call with '...' arguments ...
[17:39:20.828] {
[17:39:20.828]     do.call(function(...) {
[17:39:20.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.828]             on.exit(options(oopts), add = TRUE)
[17:39:20.828]         }
[17:39:20.828]         {
[17:39:20.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.828]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.828]             })
[17:39:20.828]         }
[17:39:20.828]     }, args = future.call.arguments)
[17:39:20.828] }
[17:39:20.829] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.829] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.830] - packages: [1] ‘stats’
[17:39:20.830] getGlobalsAndPackages() ... DONE
[17:39:20.830] run() for ‘Future’ ...
[17:39:20.830] - state: ‘created’
[17:39:20.831] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:20.835] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:20.835]   - Field: ‘label’
[17:39:20.836]   - Field: ‘local’
[17:39:20.836]   - Field: ‘owner’
[17:39:20.836]   - Field: ‘envir’
[17:39:20.836]   - Field: ‘workers’
[17:39:20.836]   - Field: ‘packages’
[17:39:20.836]   - Field: ‘gc’
[17:39:20.837]   - Field: ‘job’
[17:39:20.837]   - Field: ‘conditions’
[17:39:20.837]   - Field: ‘expr’
[17:39:20.837]   - Field: ‘uuid’
[17:39:20.837]   - Field: ‘seed’
[17:39:20.837]   - Field: ‘version’
[17:39:20.837]   - Field: ‘result’
[17:39:20.838]   - Field: ‘asynchronous’
[17:39:20.838]   - Field: ‘calls’
[17:39:20.838]   - Field: ‘globals’
[17:39:20.838]   - Field: ‘stdout’
[17:39:20.838]   - Field: ‘earlySignal’
[17:39:20.838]   - Field: ‘lazy’
[17:39:20.839]   - Field: ‘state’
[17:39:20.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:20.839] - Launch lazy future ...
[17:39:20.839] Packages needed by the future expression (n = 1): ‘stats’
[17:39:20.839] Packages needed by future strategies (n = 0): <none>
[17:39:20.840] {
[17:39:20.840]     {
[17:39:20.840]         {
[17:39:20.840]             ...future.startTime <- base::Sys.time()
[17:39:20.840]             {
[17:39:20.840]                 {
[17:39:20.840]                   {
[17:39:20.840]                     {
[17:39:20.840]                       {
[17:39:20.840]                         base::local({
[17:39:20.840]                           has_future <- base::requireNamespace("future", 
[17:39:20.840]                             quietly = TRUE)
[17:39:20.840]                           if (has_future) {
[17:39:20.840]                             ns <- base::getNamespace("future")
[17:39:20.840]                             version <- ns[[".package"]][["version"]]
[17:39:20.840]                             if (is.null(version)) 
[17:39:20.840]                               version <- utils::packageVersion("future")
[17:39:20.840]                           }
[17:39:20.840]                           else {
[17:39:20.840]                             version <- NULL
[17:39:20.840]                           }
[17:39:20.840]                           if (!has_future || version < "1.8.0") {
[17:39:20.840]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.840]                               "", base::R.version$version.string), 
[17:39:20.840]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:20.840]                                 base::R.version$platform, 8 * 
[17:39:20.840]                                   base::.Machine$sizeof.pointer), 
[17:39:20.840]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.840]                                 "release", "version")], collapse = " "), 
[17:39:20.840]                               hostname = base::Sys.info()[["nodename"]])
[17:39:20.840]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.840]                               info)
[17:39:20.840]                             info <- base::paste(info, collapse = "; ")
[17:39:20.840]                             if (!has_future) {
[17:39:20.840]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.840]                                 info)
[17:39:20.840]                             }
[17:39:20.840]                             else {
[17:39:20.840]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.840]                                 info, version)
[17:39:20.840]                             }
[17:39:20.840]                             base::stop(msg)
[17:39:20.840]                           }
[17:39:20.840]                         })
[17:39:20.840]                       }
[17:39:20.840]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:20.840]                       base::options(mc.cores = 1L)
[17:39:20.840]                     }
[17:39:20.840]                     base::local({
[17:39:20.840]                       for (pkg in "stats") {
[17:39:20.840]                         base::loadNamespace(pkg)
[17:39:20.840]                         base::library(pkg, character.only = TRUE)
[17:39:20.840]                       }
[17:39:20.840]                     })
[17:39:20.840]                   }
[17:39:20.840]                   options(future.plan = NULL)
[17:39:20.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.840]                 }
[17:39:20.840]                 ...future.workdir <- getwd()
[17:39:20.840]             }
[17:39:20.840]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.840]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.840]         }
[17:39:20.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.840]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.840]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.840]             base::names(...future.oldOptions))
[17:39:20.840]     }
[17:39:20.840]     if (FALSE) {
[17:39:20.840]     }
[17:39:20.840]     else {
[17:39:20.840]         if (TRUE) {
[17:39:20.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.840]                 open = "w")
[17:39:20.840]         }
[17:39:20.840]         else {
[17:39:20.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.840]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.840]         }
[17:39:20.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.840]             base::sink(type = "output", split = FALSE)
[17:39:20.840]             base::close(...future.stdout)
[17:39:20.840]         }, add = TRUE)
[17:39:20.840]     }
[17:39:20.840]     ...future.frame <- base::sys.nframe()
[17:39:20.840]     ...future.conditions <- base::list()
[17:39:20.840]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.840]     if (FALSE) {
[17:39:20.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.840]     }
[17:39:20.840]     ...future.result <- base::tryCatch({
[17:39:20.840]         base::withCallingHandlers({
[17:39:20.840]             ...future.value <- base::withVisible(base::local({
[17:39:20.840]                 withCallingHandlers({
[17:39:20.840]                   {
[17:39:20.840]                     do.call(function(...) {
[17:39:20.840]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.840]                       if (!identical(...future.globals.maxSize.org, 
[17:39:20.840]                         ...future.globals.maxSize)) {
[17:39:20.840]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.840]                         on.exit(options(oopts), add = TRUE)
[17:39:20.840]                       }
[17:39:20.840]                       {
[17:39:20.840]                         lapply(seq_along(...future.elements_ii), 
[17:39:20.840]                           FUN = function(jj) {
[17:39:20.840]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.840]                             ...future.FUN(...future.X_jj, ...)
[17:39:20.840]                           })
[17:39:20.840]                       }
[17:39:20.840]                     }, args = future.call.arguments)
[17:39:20.840]                   }
[17:39:20.840]                 }, immediateCondition = function(cond) {
[17:39:20.840]                   save_rds <- function (object, pathname, ...) 
[17:39:20.840]                   {
[17:39:20.840]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:20.840]                     if (file_test("-f", pathname_tmp)) {
[17:39:20.840]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.840]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:20.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.840]                         fi_tmp[["mtime"]])
[17:39:20.840]                     }
[17:39:20.840]                     tryCatch({
[17:39:20.840]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:20.840]                     }, error = function(ex) {
[17:39:20.840]                       msg <- conditionMessage(ex)
[17:39:20.840]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.840]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:20.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.840]                         fi_tmp[["mtime"]], msg)
[17:39:20.840]                       ex$message <- msg
[17:39:20.840]                       stop(ex)
[17:39:20.840]                     })
[17:39:20.840]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:20.840]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:20.840]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:20.840]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.840]                       fi <- file.info(pathname)
[17:39:20.840]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:20.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.840]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:20.840]                         fi[["size"]], fi[["mtime"]])
[17:39:20.840]                       stop(msg)
[17:39:20.840]                     }
[17:39:20.840]                     invisible(pathname)
[17:39:20.840]                   }
[17:39:20.840]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:20.840]                     rootPath = tempdir()) 
[17:39:20.840]                   {
[17:39:20.840]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:20.840]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:20.840]                       tmpdir = path, fileext = ".rds")
[17:39:20.840]                     save_rds(obj, file)
[17:39:20.840]                   }
[17:39:20.840]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:20.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.840]                   {
[17:39:20.840]                     inherits <- base::inherits
[17:39:20.840]                     invokeRestart <- base::invokeRestart
[17:39:20.840]                     is.null <- base::is.null
[17:39:20.840]                     muffled <- FALSE
[17:39:20.840]                     if (inherits(cond, "message")) {
[17:39:20.840]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:20.840]                       if (muffled) 
[17:39:20.840]                         invokeRestart("muffleMessage")
[17:39:20.840]                     }
[17:39:20.840]                     else if (inherits(cond, "warning")) {
[17:39:20.840]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:20.840]                       if (muffled) 
[17:39:20.840]                         invokeRestart("muffleWarning")
[17:39:20.840]                     }
[17:39:20.840]                     else if (inherits(cond, "condition")) {
[17:39:20.840]                       if (!is.null(pattern)) {
[17:39:20.840]                         computeRestarts <- base::computeRestarts
[17:39:20.840]                         grepl <- base::grepl
[17:39:20.840]                         restarts <- computeRestarts(cond)
[17:39:20.840]                         for (restart in restarts) {
[17:39:20.840]                           name <- restart$name
[17:39:20.840]                           if (is.null(name)) 
[17:39:20.840]                             next
[17:39:20.840]                           if (!grepl(pattern, name)) 
[17:39:20.840]                             next
[17:39:20.840]                           invokeRestart(restart)
[17:39:20.840]                           muffled <- TRUE
[17:39:20.840]                           break
[17:39:20.840]                         }
[17:39:20.840]                       }
[17:39:20.840]                     }
[17:39:20.840]                     invisible(muffled)
[17:39:20.840]                   }
[17:39:20.840]                   muffleCondition(cond)
[17:39:20.840]                 })
[17:39:20.840]             }))
[17:39:20.840]             future::FutureResult(value = ...future.value$value, 
[17:39:20.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.840]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.840]                     ...future.globalenv.names))
[17:39:20.840]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.840]         }, condition = base::local({
[17:39:20.840]             c <- base::c
[17:39:20.840]             inherits <- base::inherits
[17:39:20.840]             invokeRestart <- base::invokeRestart
[17:39:20.840]             length <- base::length
[17:39:20.840]             list <- base::list
[17:39:20.840]             seq.int <- base::seq.int
[17:39:20.840]             signalCondition <- base::signalCondition
[17:39:20.840]             sys.calls <- base::sys.calls
[17:39:20.840]             `[[` <- base::`[[`
[17:39:20.840]             `+` <- base::`+`
[17:39:20.840]             `<<-` <- base::`<<-`
[17:39:20.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.840]                   3L)]
[17:39:20.840]             }
[17:39:20.840]             function(cond) {
[17:39:20.840]                 is_error <- inherits(cond, "error")
[17:39:20.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.840]                   NULL)
[17:39:20.840]                 if (is_error) {
[17:39:20.840]                   sessionInformation <- function() {
[17:39:20.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.840]                       search = base::search(), system = base::Sys.info())
[17:39:20.840]                   }
[17:39:20.840]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.840]                     cond$call), session = sessionInformation(), 
[17:39:20.840]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.840]                   signalCondition(cond)
[17:39:20.840]                 }
[17:39:20.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.840]                 "immediateCondition"))) {
[17:39:20.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.840]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.840]                   if (TRUE && !signal) {
[17:39:20.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.840]                     {
[17:39:20.840]                       inherits <- base::inherits
[17:39:20.840]                       invokeRestart <- base::invokeRestart
[17:39:20.840]                       is.null <- base::is.null
[17:39:20.840]                       muffled <- FALSE
[17:39:20.840]                       if (inherits(cond, "message")) {
[17:39:20.840]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.840]                         if (muffled) 
[17:39:20.840]                           invokeRestart("muffleMessage")
[17:39:20.840]                       }
[17:39:20.840]                       else if (inherits(cond, "warning")) {
[17:39:20.840]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.840]                         if (muffled) 
[17:39:20.840]                           invokeRestart("muffleWarning")
[17:39:20.840]                       }
[17:39:20.840]                       else if (inherits(cond, "condition")) {
[17:39:20.840]                         if (!is.null(pattern)) {
[17:39:20.840]                           computeRestarts <- base::computeRestarts
[17:39:20.840]                           grepl <- base::grepl
[17:39:20.840]                           restarts <- computeRestarts(cond)
[17:39:20.840]                           for (restart in restarts) {
[17:39:20.840]                             name <- restart$name
[17:39:20.840]                             if (is.null(name)) 
[17:39:20.840]                               next
[17:39:20.840]                             if (!grepl(pattern, name)) 
[17:39:20.840]                               next
[17:39:20.840]                             invokeRestart(restart)
[17:39:20.840]                             muffled <- TRUE
[17:39:20.840]                             break
[17:39:20.840]                           }
[17:39:20.840]                         }
[17:39:20.840]                       }
[17:39:20.840]                       invisible(muffled)
[17:39:20.840]                     }
[17:39:20.840]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.840]                   }
[17:39:20.840]                 }
[17:39:20.840]                 else {
[17:39:20.840]                   if (TRUE) {
[17:39:20.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.840]                     {
[17:39:20.840]                       inherits <- base::inherits
[17:39:20.840]                       invokeRestart <- base::invokeRestart
[17:39:20.840]                       is.null <- base::is.null
[17:39:20.840]                       muffled <- FALSE
[17:39:20.840]                       if (inherits(cond, "message")) {
[17:39:20.840]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.840]                         if (muffled) 
[17:39:20.840]                           invokeRestart("muffleMessage")
[17:39:20.840]                       }
[17:39:20.840]                       else if (inherits(cond, "warning")) {
[17:39:20.840]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.840]                         if (muffled) 
[17:39:20.840]                           invokeRestart("muffleWarning")
[17:39:20.840]                       }
[17:39:20.840]                       else if (inherits(cond, "condition")) {
[17:39:20.840]                         if (!is.null(pattern)) {
[17:39:20.840]                           computeRestarts <- base::computeRestarts
[17:39:20.840]                           grepl <- base::grepl
[17:39:20.840]                           restarts <- computeRestarts(cond)
[17:39:20.840]                           for (restart in restarts) {
[17:39:20.840]                             name <- restart$name
[17:39:20.840]                             if (is.null(name)) 
[17:39:20.840]                               next
[17:39:20.840]                             if (!grepl(pattern, name)) 
[17:39:20.840]                               next
[17:39:20.840]                             invokeRestart(restart)
[17:39:20.840]                             muffled <- TRUE
[17:39:20.840]                             break
[17:39:20.840]                           }
[17:39:20.840]                         }
[17:39:20.840]                       }
[17:39:20.840]                       invisible(muffled)
[17:39:20.840]                     }
[17:39:20.840]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.840]                   }
[17:39:20.840]                 }
[17:39:20.840]             }
[17:39:20.840]         }))
[17:39:20.840]     }, error = function(ex) {
[17:39:20.840]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.840]                 ...future.rng), started = ...future.startTime, 
[17:39:20.840]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.840]             version = "1.8"), class = "FutureResult")
[17:39:20.840]     }, finally = {
[17:39:20.840]         if (!identical(...future.workdir, getwd())) 
[17:39:20.840]             setwd(...future.workdir)
[17:39:20.840]         {
[17:39:20.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.840]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.840]             }
[17:39:20.840]             base::options(...future.oldOptions)
[17:39:20.840]             if (.Platform$OS.type == "windows") {
[17:39:20.840]                 old_names <- names(...future.oldEnvVars)
[17:39:20.840]                 envs <- base::Sys.getenv()
[17:39:20.840]                 names <- names(envs)
[17:39:20.840]                 common <- intersect(names, old_names)
[17:39:20.840]                 added <- setdiff(names, old_names)
[17:39:20.840]                 removed <- setdiff(old_names, names)
[17:39:20.840]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.840]                   envs[common]]
[17:39:20.840]                 NAMES <- toupper(changed)
[17:39:20.840]                 args <- list()
[17:39:20.840]                 for (kk in seq_along(NAMES)) {
[17:39:20.840]                   name <- changed[[kk]]
[17:39:20.840]                   NAME <- NAMES[[kk]]
[17:39:20.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.840]                     next
[17:39:20.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.840]                 }
[17:39:20.840]                 NAMES <- toupper(added)
[17:39:20.840]                 for (kk in seq_along(NAMES)) {
[17:39:20.840]                   name <- added[[kk]]
[17:39:20.840]                   NAME <- NAMES[[kk]]
[17:39:20.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.840]                     next
[17:39:20.840]                   args[[name]] <- ""
[17:39:20.840]                 }
[17:39:20.840]                 NAMES <- toupper(removed)
[17:39:20.840]                 for (kk in seq_along(NAMES)) {
[17:39:20.840]                   name <- removed[[kk]]
[17:39:20.840]                   NAME <- NAMES[[kk]]
[17:39:20.840]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.840]                     next
[17:39:20.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.840]                 }
[17:39:20.840]                 if (length(args) > 0) 
[17:39:20.840]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.840]             }
[17:39:20.840]             else {
[17:39:20.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.840]             }
[17:39:20.840]             {
[17:39:20.840]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.840]                   0L) {
[17:39:20.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.840]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.840]                   base::options(opts)
[17:39:20.840]                 }
[17:39:20.840]                 {
[17:39:20.840]                   {
[17:39:20.840]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:20.840]                     NULL
[17:39:20.840]                   }
[17:39:20.840]                   options(future.plan = NULL)
[17:39:20.840]                   if (is.na(NA_character_)) 
[17:39:20.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.840]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:20.840]                     envir = parent.frame()) 
[17:39:20.840]                   {
[17:39:20.840]                     default_workers <- missing(workers)
[17:39:20.840]                     if (is.function(workers)) 
[17:39:20.840]                       workers <- workers()
[17:39:20.840]                     workers <- structure(as.integer(workers), 
[17:39:20.840]                       class = class(workers))
[17:39:20.840]                     stop_if_not(is.finite(workers), workers >= 
[17:39:20.840]                       1L)
[17:39:20.840]                     if ((workers == 1L && !inherits(workers, 
[17:39:20.840]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:20.840]                       if (default_workers) 
[17:39:20.840]                         supportsMulticore(warn = TRUE)
[17:39:20.840]                       return(sequential(..., envir = envir))
[17:39:20.840]                     }
[17:39:20.840]                     oopts <- options(mc.cores = workers)
[17:39:20.840]                     on.exit(options(oopts))
[17:39:20.840]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:20.840]                       envir = envir)
[17:39:20.840]                     if (!future$lazy) 
[17:39:20.840]                       future <- run(future)
[17:39:20.840]                     invisible(future)
[17:39:20.840]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.840]                 }
[17:39:20.840]             }
[17:39:20.840]         }
[17:39:20.840]     })
[17:39:20.840]     if (TRUE) {
[17:39:20.840]         base::sink(type = "output", split = FALSE)
[17:39:20.840]         if (TRUE) {
[17:39:20.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.840]         }
[17:39:20.840]         else {
[17:39:20.840]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.840]         }
[17:39:20.840]         base::close(...future.stdout)
[17:39:20.840]         ...future.stdout <- NULL
[17:39:20.840]     }
[17:39:20.840]     ...future.result$conditions <- ...future.conditions
[17:39:20.840]     ...future.result$finished <- base::Sys.time()
[17:39:20.840]     ...future.result
[17:39:20.840] }
[17:39:20.844] assign_globals() ...
[17:39:20.844] List of 5
[17:39:20.844]  $ future.call.arguments    : list()
[17:39:20.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.844]  $ ...future.FUN            :function (x, ...)  
[17:39:20.844]  $ ...future.elements_ii    :List of 1
[17:39:20.844]   ..$ : num [1:4] 2 4 6 8
[17:39:20.844]  $ ...future.seeds_ii       : NULL
[17:39:20.844]  $ ...future.globals.maxSize: NULL
[17:39:20.844]  - attr(*, "where")=List of 5
[17:39:20.844]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.844]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.844]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.844]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.844]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.844]  - attr(*, "resolved")= logi FALSE
[17:39:20.844]  - attr(*, "total_size")= num NA
[17:39:20.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.844]  - attr(*, "already-done")= logi TRUE
[17:39:20.851] - copied ‘future.call.arguments’ to environment
[17:39:20.851] - copied ‘...future.FUN’ to environment
[17:39:20.852] - copied ‘...future.elements_ii’ to environment
[17:39:20.852] - copied ‘...future.seeds_ii’ to environment
[17:39:20.852] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.852] assign_globals() ... done
[17:39:20.852] requestCore(): workers = 2
[17:39:20.855] MulticoreFuture started
[17:39:20.855] - Launch lazy future ... done
[17:39:20.855] run() for ‘MulticoreFuture’ ... done
[17:39:20.855] Created future:
[17:39:20.856] plan(): Setting new future strategy stack:
[17:39:20.856] List of future strategies:
[17:39:20.856] 1. sequential:
[17:39:20.856]    - args: function (..., envir = parent.frame())
[17:39:20.856]    - tweaked: FALSE
[17:39:20.856]    - call: NULL
[17:39:20.860] plan(): nbrOfWorkers() = 1
[17:39:20.864] plan(): Setting new future strategy stack:
[17:39:20.864] List of future strategies:
[17:39:20.864] 1. multicore:
[17:39:20.864]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.864]    - tweaked: FALSE
[17:39:20.864]    - call: plan(strategy)
[17:39:20.871] plan(): nbrOfWorkers() = 2
[17:39:20.856] MulticoreFuture:
[17:39:20.856] Label: ‘future_apply-2’
[17:39:20.856] Expression:
[17:39:20.856] {
[17:39:20.856]     do.call(function(...) {
[17:39:20.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.856]             on.exit(options(oopts), add = TRUE)
[17:39:20.856]         }
[17:39:20.856]         {
[17:39:20.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.856]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.856]             })
[17:39:20.856]         }
[17:39:20.856]     }, args = future.call.arguments)
[17:39:20.856] }
[17:39:20.856] Lazy evaluation: FALSE
[17:39:20.856] Asynchronous evaluation: TRUE
[17:39:20.856] Local evaluation: TRUE
[17:39:20.856] Environment: R_GlobalEnv
[17:39:20.856] Capture standard output: TRUE
[17:39:20.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.856] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:20.856] Packages: 1 packages (‘stats’)
[17:39:20.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.856] Resolved: TRUE
[17:39:20.856] Value: <not collected>
[17:39:20.856] Conditions captured: <none>
[17:39:20.856] Early signaling: FALSE
[17:39:20.856] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.856] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.872] Chunk #2 of 2 ... DONE
[17:39:20.873] Launching 2 futures (chunks) ... DONE
[17:39:20.873] Resolving 2 futures (chunks) ...
[17:39:20.873] resolve() on list ...
[17:39:20.874]  recursive: 0
[17:39:20.874]  length: 2
[17:39:20.874] 
[17:39:20.875] Future #1
[17:39:20.876] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:20.876] - nx: 2
[17:39:20.877] - relay: TRUE
[17:39:20.877] - stdout: TRUE
[17:39:20.877] - signal: TRUE
[17:39:20.877] - resignal: FALSE
[17:39:20.878] - force: TRUE
[17:39:20.878] - relayed: [n=2] FALSE, FALSE
[17:39:20.878] - queued futures: [n=2] FALSE, FALSE
[17:39:20.878]  - until=1
[17:39:20.879]  - relaying element #1
[17:39:20.879] - relayed: [n=2] TRUE, FALSE
[17:39:20.880] - queued futures: [n=2] TRUE, FALSE
[17:39:20.880] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:20.880]  length: 1 (resolved future 1)
[17:39:20.880] Future #2
[17:39:20.881] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:20.881] - nx: 2
[17:39:20.881] - relay: TRUE
[17:39:20.882] - stdout: TRUE
[17:39:20.882] - signal: TRUE
[17:39:20.882] - resignal: FALSE
[17:39:20.882] - force: TRUE
[17:39:20.882] - relayed: [n=2] TRUE, FALSE
[17:39:20.882] - queued futures: [n=2] TRUE, FALSE
[17:39:20.883]  - until=2
[17:39:20.883]  - relaying element #2
[17:39:20.883] - relayed: [n=2] TRUE, TRUE
[17:39:20.883] - queued futures: [n=2] TRUE, TRUE
[17:39:20.883] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:20.883]  length: 0 (resolved future 2)
[17:39:20.883] Relaying remaining futures
[17:39:20.884] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.884] - nx: 2
[17:39:20.884] - relay: TRUE
[17:39:20.884] - stdout: TRUE
[17:39:20.884] - signal: TRUE
[17:39:20.884] - resignal: FALSE
[17:39:20.884] - force: TRUE
[17:39:20.884] - relayed: [n=2] TRUE, TRUE
[17:39:20.884] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:20.885] - relayed: [n=2] TRUE, TRUE
[17:39:20.885] - queued futures: [n=2] TRUE, TRUE
[17:39:20.885] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.885] resolve() on list ... DONE
[17:39:20.885]  - Number of value chunks collected: 2
[17:39:20.885] Resolving 2 futures (chunks) ... DONE
[17:39:20.885] Reducing values from 2 chunks ...
[17:39:20.885]  - Number of values collected after concatenation: 2
[17:39:20.886]  - Number of values expected: 2
[17:39:20.886] Reducing values from 2 chunks ... DONE
[17:39:20.886] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:39:20.886] getGlobalsAndPackagesXApply() ...
[17:39:20.887]  - future.globals: TRUE
[17:39:20.887] getGlobalsAndPackages() ...
[17:39:20.887] Searching for globals...
[17:39:20.888] - globals found: [1] ‘FUN’
[17:39:20.888] Searching for globals ... DONE
[17:39:20.888] Resolving globals: FALSE
[17:39:20.889] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:20.889] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:20.889] - globals: [1] ‘FUN’
[17:39:20.889] 
[17:39:20.889] getGlobalsAndPackages() ... DONE
[17:39:20.889]  - globals found/used: [n=1] ‘FUN’
[17:39:20.890]  - needed namespaces: [n=0] 
[17:39:20.890] Finding globals ... DONE
[17:39:20.890]  - use_args: TRUE
[17:39:20.890]  - Getting '...' globals ...
[17:39:20.890] resolve() on list ...
[17:39:20.890]  recursive: 0
[17:39:20.891]  length: 1
[17:39:20.891]  elements: ‘...’
[17:39:20.891]  length: 0 (resolved future 1)
[17:39:20.891] resolve() on list ... DONE
[17:39:20.891]    - '...' content: [n=0] 
[17:39:20.891] List of 1
[17:39:20.891]  $ ...: list()
[17:39:20.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.891]  - attr(*, "where")=List of 1
[17:39:20.891]   ..$ ...:<environment: 0x55c794d165f0> 
[17:39:20.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.891]  - attr(*, "resolved")= logi TRUE
[17:39:20.891]  - attr(*, "total_size")= num NA
[17:39:20.894]  - Getting '...' globals ... DONE
[17:39:20.894] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:20.894] List of 2
[17:39:20.894]  $ ...future.FUN:function (x)  
[17:39:20.894]  $ ...          : list()
[17:39:20.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.894]  - attr(*, "where")=List of 2
[17:39:20.894]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:20.894]   ..$ ...          :<environment: 0x55c794d165f0> 
[17:39:20.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.894]  - attr(*, "resolved")= logi FALSE
[17:39:20.894]  - attr(*, "total_size")= num 848
[17:39:20.897] Packages to be attached in all futures: [n=0] 
[17:39:20.897] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.901] future_lapply() ...
[17:39:20.905] Number of chunks: 2
[17:39:20.905] getGlobalsAndPackagesXApply() ...
[17:39:20.907]  - future.globals: <name-value list> with names ‘list()’
[17:39:20.907]  - use_args: TRUE
[17:39:20.908] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:20.908] List of 2
[17:39:20.908]  $ ...          : list()
[17:39:20.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.908]  $ ...future.FUN:function (x)  
[17:39:20.908]  - attr(*, "where")=List of 2
[17:39:20.908]   ..$ ...          :<environment: 0x55c794d165f0> 
[17:39:20.908]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:20.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.908]  - attr(*, "resolved")= logi FALSE
[17:39:20.908]  - attr(*, "total_size")= num NA
[17:39:20.911] Packages to be attached in all futures: [n=0] 
[17:39:20.911] getGlobalsAndPackagesXApply() ... DONE
[17:39:20.912] Number of futures (= number of chunks): 2
[17:39:20.912] Launching 2 futures (chunks) ...
[17:39:20.912] Chunk #1 of 2 ...
[17:39:20.912]  - seeds: <none>
[17:39:20.912] getGlobalsAndPackages() ...
[17:39:20.912] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.912] Resolving globals: FALSE
[17:39:20.912] Tweak future expression to call with '...' arguments ...
[17:39:20.913] {
[17:39:20.913]     do.call(function(...) {
[17:39:20.913]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.913]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.913]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.913]             on.exit(options(oopts), add = TRUE)
[17:39:20.913]         }
[17:39:20.913]         {
[17:39:20.913]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.913]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.913]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.913]             })
[17:39:20.913]         }
[17:39:20.913]     }, args = future.call.arguments)
[17:39:20.913] }
[17:39:20.913] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.913] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.913] 
[17:39:20.913] getGlobalsAndPackages() ... DONE
[17:39:20.914] run() for ‘Future’ ...
[17:39:20.914] - state: ‘created’
[17:39:20.914] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:20.918] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:20.918]   - Field: ‘label’
[17:39:20.918]   - Field: ‘local’
[17:39:20.918]   - Field: ‘owner’
[17:39:20.918]   - Field: ‘envir’
[17:39:20.918]   - Field: ‘workers’
[17:39:20.918]   - Field: ‘packages’
[17:39:20.918]   - Field: ‘gc’
[17:39:20.919]   - Field: ‘job’
[17:39:20.919]   - Field: ‘conditions’
[17:39:20.919]   - Field: ‘expr’
[17:39:20.919]   - Field: ‘uuid’
[17:39:20.919]   - Field: ‘seed’
[17:39:20.919]   - Field: ‘version’
[17:39:20.919]   - Field: ‘result’
[17:39:20.919]   - Field: ‘asynchronous’
[17:39:20.919]   - Field: ‘calls’
[17:39:20.920]   - Field: ‘globals’
[17:39:20.920]   - Field: ‘stdout’
[17:39:20.920]   - Field: ‘earlySignal’
[17:39:20.920]   - Field: ‘lazy’
[17:39:20.920]   - Field: ‘state’
[17:39:20.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:20.920] - Launch lazy future ...
[17:39:20.920] Packages needed by the future expression (n = 0): <none>
[17:39:20.920] Packages needed by future strategies (n = 0): <none>
[17:39:20.921] {
[17:39:20.921]     {
[17:39:20.921]         {
[17:39:20.921]             ...future.startTime <- base::Sys.time()
[17:39:20.921]             {
[17:39:20.921]                 {
[17:39:20.921]                   {
[17:39:20.921]                     {
[17:39:20.921]                       base::local({
[17:39:20.921]                         has_future <- base::requireNamespace("future", 
[17:39:20.921]                           quietly = TRUE)
[17:39:20.921]                         if (has_future) {
[17:39:20.921]                           ns <- base::getNamespace("future")
[17:39:20.921]                           version <- ns[[".package"]][["version"]]
[17:39:20.921]                           if (is.null(version)) 
[17:39:20.921]                             version <- utils::packageVersion("future")
[17:39:20.921]                         }
[17:39:20.921]                         else {
[17:39:20.921]                           version <- NULL
[17:39:20.921]                         }
[17:39:20.921]                         if (!has_future || version < "1.8.0") {
[17:39:20.921]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.921]                             "", base::R.version$version.string), 
[17:39:20.921]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:20.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.921]                               "release", "version")], collapse = " "), 
[17:39:20.921]                             hostname = base::Sys.info()[["nodename"]])
[17:39:20.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.921]                             info)
[17:39:20.921]                           info <- base::paste(info, collapse = "; ")
[17:39:20.921]                           if (!has_future) {
[17:39:20.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.921]                               info)
[17:39:20.921]                           }
[17:39:20.921]                           else {
[17:39:20.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.921]                               info, version)
[17:39:20.921]                           }
[17:39:20.921]                           base::stop(msg)
[17:39:20.921]                         }
[17:39:20.921]                       })
[17:39:20.921]                     }
[17:39:20.921]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:20.921]                     base::options(mc.cores = 1L)
[17:39:20.921]                   }
[17:39:20.921]                   options(future.plan = NULL)
[17:39:20.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.921]                 }
[17:39:20.921]                 ...future.workdir <- getwd()
[17:39:20.921]             }
[17:39:20.921]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.921]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.921]         }
[17:39:20.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.921]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.921]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.921]             base::names(...future.oldOptions))
[17:39:20.921]     }
[17:39:20.921]     if (FALSE) {
[17:39:20.921]     }
[17:39:20.921]     else {
[17:39:20.921]         if (TRUE) {
[17:39:20.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.921]                 open = "w")
[17:39:20.921]         }
[17:39:20.921]         else {
[17:39:20.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.921]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.921]         }
[17:39:20.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.921]             base::sink(type = "output", split = FALSE)
[17:39:20.921]             base::close(...future.stdout)
[17:39:20.921]         }, add = TRUE)
[17:39:20.921]     }
[17:39:20.921]     ...future.frame <- base::sys.nframe()
[17:39:20.921]     ...future.conditions <- base::list()
[17:39:20.921]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.921]     if (FALSE) {
[17:39:20.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.921]     }
[17:39:20.921]     ...future.result <- base::tryCatch({
[17:39:20.921]         base::withCallingHandlers({
[17:39:20.921]             ...future.value <- base::withVisible(base::local({
[17:39:20.921]                 withCallingHandlers({
[17:39:20.921]                   {
[17:39:20.921]                     do.call(function(...) {
[17:39:20.921]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.921]                       if (!identical(...future.globals.maxSize.org, 
[17:39:20.921]                         ...future.globals.maxSize)) {
[17:39:20.921]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.921]                         on.exit(options(oopts), add = TRUE)
[17:39:20.921]                       }
[17:39:20.921]                       {
[17:39:20.921]                         lapply(seq_along(...future.elements_ii), 
[17:39:20.921]                           FUN = function(jj) {
[17:39:20.921]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.921]                             ...future.FUN(...future.X_jj, ...)
[17:39:20.921]                           })
[17:39:20.921]                       }
[17:39:20.921]                     }, args = future.call.arguments)
[17:39:20.921]                   }
[17:39:20.921]                 }, immediateCondition = function(cond) {
[17:39:20.921]                   save_rds <- function (object, pathname, ...) 
[17:39:20.921]                   {
[17:39:20.921]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:20.921]                     if (file_test("-f", pathname_tmp)) {
[17:39:20.921]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.921]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:20.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.921]                         fi_tmp[["mtime"]])
[17:39:20.921]                     }
[17:39:20.921]                     tryCatch({
[17:39:20.921]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:20.921]                     }, error = function(ex) {
[17:39:20.921]                       msg <- conditionMessage(ex)
[17:39:20.921]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.921]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:20.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.921]                         fi_tmp[["mtime"]], msg)
[17:39:20.921]                       ex$message <- msg
[17:39:20.921]                       stop(ex)
[17:39:20.921]                     })
[17:39:20.921]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:20.921]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:20.921]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:20.921]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.921]                       fi <- file.info(pathname)
[17:39:20.921]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:20.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.921]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:20.921]                         fi[["size"]], fi[["mtime"]])
[17:39:20.921]                       stop(msg)
[17:39:20.921]                     }
[17:39:20.921]                     invisible(pathname)
[17:39:20.921]                   }
[17:39:20.921]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:20.921]                     rootPath = tempdir()) 
[17:39:20.921]                   {
[17:39:20.921]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:20.921]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:20.921]                       tmpdir = path, fileext = ".rds")
[17:39:20.921]                     save_rds(obj, file)
[17:39:20.921]                   }
[17:39:20.921]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:20.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.921]                   {
[17:39:20.921]                     inherits <- base::inherits
[17:39:20.921]                     invokeRestart <- base::invokeRestart
[17:39:20.921]                     is.null <- base::is.null
[17:39:20.921]                     muffled <- FALSE
[17:39:20.921]                     if (inherits(cond, "message")) {
[17:39:20.921]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:20.921]                       if (muffled) 
[17:39:20.921]                         invokeRestart("muffleMessage")
[17:39:20.921]                     }
[17:39:20.921]                     else if (inherits(cond, "warning")) {
[17:39:20.921]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:20.921]                       if (muffled) 
[17:39:20.921]                         invokeRestart("muffleWarning")
[17:39:20.921]                     }
[17:39:20.921]                     else if (inherits(cond, "condition")) {
[17:39:20.921]                       if (!is.null(pattern)) {
[17:39:20.921]                         computeRestarts <- base::computeRestarts
[17:39:20.921]                         grepl <- base::grepl
[17:39:20.921]                         restarts <- computeRestarts(cond)
[17:39:20.921]                         for (restart in restarts) {
[17:39:20.921]                           name <- restart$name
[17:39:20.921]                           if (is.null(name)) 
[17:39:20.921]                             next
[17:39:20.921]                           if (!grepl(pattern, name)) 
[17:39:20.921]                             next
[17:39:20.921]                           invokeRestart(restart)
[17:39:20.921]                           muffled <- TRUE
[17:39:20.921]                           break
[17:39:20.921]                         }
[17:39:20.921]                       }
[17:39:20.921]                     }
[17:39:20.921]                     invisible(muffled)
[17:39:20.921]                   }
[17:39:20.921]                   muffleCondition(cond)
[17:39:20.921]                 })
[17:39:20.921]             }))
[17:39:20.921]             future::FutureResult(value = ...future.value$value, 
[17:39:20.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.921]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.921]                     ...future.globalenv.names))
[17:39:20.921]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.921]         }, condition = base::local({
[17:39:20.921]             c <- base::c
[17:39:20.921]             inherits <- base::inherits
[17:39:20.921]             invokeRestart <- base::invokeRestart
[17:39:20.921]             length <- base::length
[17:39:20.921]             list <- base::list
[17:39:20.921]             seq.int <- base::seq.int
[17:39:20.921]             signalCondition <- base::signalCondition
[17:39:20.921]             sys.calls <- base::sys.calls
[17:39:20.921]             `[[` <- base::`[[`
[17:39:20.921]             `+` <- base::`+`
[17:39:20.921]             `<<-` <- base::`<<-`
[17:39:20.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.921]                   3L)]
[17:39:20.921]             }
[17:39:20.921]             function(cond) {
[17:39:20.921]                 is_error <- inherits(cond, "error")
[17:39:20.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.921]                   NULL)
[17:39:20.921]                 if (is_error) {
[17:39:20.921]                   sessionInformation <- function() {
[17:39:20.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.921]                       search = base::search(), system = base::Sys.info())
[17:39:20.921]                   }
[17:39:20.921]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.921]                     cond$call), session = sessionInformation(), 
[17:39:20.921]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.921]                   signalCondition(cond)
[17:39:20.921]                 }
[17:39:20.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.921]                 "immediateCondition"))) {
[17:39:20.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.921]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.921]                   if (TRUE && !signal) {
[17:39:20.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.921]                     {
[17:39:20.921]                       inherits <- base::inherits
[17:39:20.921]                       invokeRestart <- base::invokeRestart
[17:39:20.921]                       is.null <- base::is.null
[17:39:20.921]                       muffled <- FALSE
[17:39:20.921]                       if (inherits(cond, "message")) {
[17:39:20.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.921]                         if (muffled) 
[17:39:20.921]                           invokeRestart("muffleMessage")
[17:39:20.921]                       }
[17:39:20.921]                       else if (inherits(cond, "warning")) {
[17:39:20.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.921]                         if (muffled) 
[17:39:20.921]                           invokeRestart("muffleWarning")
[17:39:20.921]                       }
[17:39:20.921]                       else if (inherits(cond, "condition")) {
[17:39:20.921]                         if (!is.null(pattern)) {
[17:39:20.921]                           computeRestarts <- base::computeRestarts
[17:39:20.921]                           grepl <- base::grepl
[17:39:20.921]                           restarts <- computeRestarts(cond)
[17:39:20.921]                           for (restart in restarts) {
[17:39:20.921]                             name <- restart$name
[17:39:20.921]                             if (is.null(name)) 
[17:39:20.921]                               next
[17:39:20.921]                             if (!grepl(pattern, name)) 
[17:39:20.921]                               next
[17:39:20.921]                             invokeRestart(restart)
[17:39:20.921]                             muffled <- TRUE
[17:39:20.921]                             break
[17:39:20.921]                           }
[17:39:20.921]                         }
[17:39:20.921]                       }
[17:39:20.921]                       invisible(muffled)
[17:39:20.921]                     }
[17:39:20.921]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.921]                   }
[17:39:20.921]                 }
[17:39:20.921]                 else {
[17:39:20.921]                   if (TRUE) {
[17:39:20.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.921]                     {
[17:39:20.921]                       inherits <- base::inherits
[17:39:20.921]                       invokeRestart <- base::invokeRestart
[17:39:20.921]                       is.null <- base::is.null
[17:39:20.921]                       muffled <- FALSE
[17:39:20.921]                       if (inherits(cond, "message")) {
[17:39:20.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.921]                         if (muffled) 
[17:39:20.921]                           invokeRestart("muffleMessage")
[17:39:20.921]                       }
[17:39:20.921]                       else if (inherits(cond, "warning")) {
[17:39:20.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.921]                         if (muffled) 
[17:39:20.921]                           invokeRestart("muffleWarning")
[17:39:20.921]                       }
[17:39:20.921]                       else if (inherits(cond, "condition")) {
[17:39:20.921]                         if (!is.null(pattern)) {
[17:39:20.921]                           computeRestarts <- base::computeRestarts
[17:39:20.921]                           grepl <- base::grepl
[17:39:20.921]                           restarts <- computeRestarts(cond)
[17:39:20.921]                           for (restart in restarts) {
[17:39:20.921]                             name <- restart$name
[17:39:20.921]                             if (is.null(name)) 
[17:39:20.921]                               next
[17:39:20.921]                             if (!grepl(pattern, name)) 
[17:39:20.921]                               next
[17:39:20.921]                             invokeRestart(restart)
[17:39:20.921]                             muffled <- TRUE
[17:39:20.921]                             break
[17:39:20.921]                           }
[17:39:20.921]                         }
[17:39:20.921]                       }
[17:39:20.921]                       invisible(muffled)
[17:39:20.921]                     }
[17:39:20.921]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.921]                   }
[17:39:20.921]                 }
[17:39:20.921]             }
[17:39:20.921]         }))
[17:39:20.921]     }, error = function(ex) {
[17:39:20.921]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.921]                 ...future.rng), started = ...future.startTime, 
[17:39:20.921]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.921]             version = "1.8"), class = "FutureResult")
[17:39:20.921]     }, finally = {
[17:39:20.921]         if (!identical(...future.workdir, getwd())) 
[17:39:20.921]             setwd(...future.workdir)
[17:39:20.921]         {
[17:39:20.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.921]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.921]             }
[17:39:20.921]             base::options(...future.oldOptions)
[17:39:20.921]             if (.Platform$OS.type == "windows") {
[17:39:20.921]                 old_names <- names(...future.oldEnvVars)
[17:39:20.921]                 envs <- base::Sys.getenv()
[17:39:20.921]                 names <- names(envs)
[17:39:20.921]                 common <- intersect(names, old_names)
[17:39:20.921]                 added <- setdiff(names, old_names)
[17:39:20.921]                 removed <- setdiff(old_names, names)
[17:39:20.921]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.921]                   envs[common]]
[17:39:20.921]                 NAMES <- toupper(changed)
[17:39:20.921]                 args <- list()
[17:39:20.921]                 for (kk in seq_along(NAMES)) {
[17:39:20.921]                   name <- changed[[kk]]
[17:39:20.921]                   NAME <- NAMES[[kk]]
[17:39:20.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.921]                     next
[17:39:20.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.921]                 }
[17:39:20.921]                 NAMES <- toupper(added)
[17:39:20.921]                 for (kk in seq_along(NAMES)) {
[17:39:20.921]                   name <- added[[kk]]
[17:39:20.921]                   NAME <- NAMES[[kk]]
[17:39:20.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.921]                     next
[17:39:20.921]                   args[[name]] <- ""
[17:39:20.921]                 }
[17:39:20.921]                 NAMES <- toupper(removed)
[17:39:20.921]                 for (kk in seq_along(NAMES)) {
[17:39:20.921]                   name <- removed[[kk]]
[17:39:20.921]                   NAME <- NAMES[[kk]]
[17:39:20.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.921]                     next
[17:39:20.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.921]                 }
[17:39:20.921]                 if (length(args) > 0) 
[17:39:20.921]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.921]             }
[17:39:20.921]             else {
[17:39:20.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.921]             }
[17:39:20.921]             {
[17:39:20.921]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.921]                   0L) {
[17:39:20.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.921]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.921]                   base::options(opts)
[17:39:20.921]                 }
[17:39:20.921]                 {
[17:39:20.921]                   {
[17:39:20.921]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:20.921]                     NULL
[17:39:20.921]                   }
[17:39:20.921]                   options(future.plan = NULL)
[17:39:20.921]                   if (is.na(NA_character_)) 
[17:39:20.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.921]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:20.921]                     envir = parent.frame()) 
[17:39:20.921]                   {
[17:39:20.921]                     default_workers <- missing(workers)
[17:39:20.921]                     if (is.function(workers)) 
[17:39:20.921]                       workers <- workers()
[17:39:20.921]                     workers <- structure(as.integer(workers), 
[17:39:20.921]                       class = class(workers))
[17:39:20.921]                     stop_if_not(is.finite(workers), workers >= 
[17:39:20.921]                       1L)
[17:39:20.921]                     if ((workers == 1L && !inherits(workers, 
[17:39:20.921]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:20.921]                       if (default_workers) 
[17:39:20.921]                         supportsMulticore(warn = TRUE)
[17:39:20.921]                       return(sequential(..., envir = envir))
[17:39:20.921]                     }
[17:39:20.921]                     oopts <- options(mc.cores = workers)
[17:39:20.921]                     on.exit(options(oopts))
[17:39:20.921]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:20.921]                       envir = envir)
[17:39:20.921]                     if (!future$lazy) 
[17:39:20.921]                       future <- run(future)
[17:39:20.921]                     invisible(future)
[17:39:20.921]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.921]                 }
[17:39:20.921]             }
[17:39:20.921]         }
[17:39:20.921]     })
[17:39:20.921]     if (TRUE) {
[17:39:20.921]         base::sink(type = "output", split = FALSE)
[17:39:20.921]         if (TRUE) {
[17:39:20.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.921]         }
[17:39:20.921]         else {
[17:39:20.921]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.921]         }
[17:39:20.921]         base::close(...future.stdout)
[17:39:20.921]         ...future.stdout <- NULL
[17:39:20.921]     }
[17:39:20.921]     ...future.result$conditions <- ...future.conditions
[17:39:20.921]     ...future.result$finished <- base::Sys.time()
[17:39:20.921]     ...future.result
[17:39:20.921] }
[17:39:20.923] assign_globals() ...
[17:39:20.923] List of 5
[17:39:20.923]  $ future.call.arguments    : list()
[17:39:20.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.923]  $ ...future.FUN            :function (x)  
[17:39:20.923]  $ ...future.elements_ii    :List of 1
[17:39:20.923]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:39:20.923]  $ ...future.seeds_ii       : NULL
[17:39:20.923]  $ ...future.globals.maxSize: NULL
[17:39:20.923]  - attr(*, "where")=List of 5
[17:39:20.923]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.923]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.923]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.923]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.923]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.923]  - attr(*, "resolved")= logi FALSE
[17:39:20.923]  - attr(*, "total_size")= num NA
[17:39:20.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.923]  - attr(*, "already-done")= logi TRUE
[17:39:20.928] - copied ‘future.call.arguments’ to environment
[17:39:20.928] - copied ‘...future.FUN’ to environment
[17:39:20.928] - copied ‘...future.elements_ii’ to environment
[17:39:20.928] - copied ‘...future.seeds_ii’ to environment
[17:39:20.929] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.929] assign_globals() ... done
[17:39:20.929] requestCore(): workers = 2
[17:39:20.931] MulticoreFuture started
[17:39:20.931] - Launch lazy future ... done
[17:39:20.931] run() for ‘MulticoreFuture’ ... done
[17:39:20.932] Created future:
[17:39:20.932] plan(): Setting new future strategy stack:
[17:39:20.932] List of future strategies:
[17:39:20.932] 1. sequential:
[17:39:20.932]    - args: function (..., envir = parent.frame())
[17:39:20.932]    - tweaked: FALSE
[17:39:20.932]    - call: NULL
[17:39:20.933] plan(): nbrOfWorkers() = 1
[17:39:20.935] plan(): Setting new future strategy stack:
[17:39:20.935] List of future strategies:
[17:39:20.935] 1. multicore:
[17:39:20.935]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.935]    - tweaked: FALSE
[17:39:20.935]    - call: plan(strategy)
[17:39:20.940] plan(): nbrOfWorkers() = 2
[17:39:20.932] MulticoreFuture:
[17:39:20.932] Label: ‘future_apply-1’
[17:39:20.932] Expression:
[17:39:20.932] {
[17:39:20.932]     do.call(function(...) {
[17:39:20.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.932]             on.exit(options(oopts), add = TRUE)
[17:39:20.932]         }
[17:39:20.932]         {
[17:39:20.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.932]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.932]             })
[17:39:20.932]         }
[17:39:20.932]     }, args = future.call.arguments)
[17:39:20.932] }
[17:39:20.932] Lazy evaluation: FALSE
[17:39:20.932] Asynchronous evaluation: TRUE
[17:39:20.932] Local evaluation: TRUE
[17:39:20.932] Environment: R_GlobalEnv
[17:39:20.932] Capture standard output: TRUE
[17:39:20.932] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.932] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:20.932] Packages: <none>
[17:39:20.932] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.932] Resolved: TRUE
[17:39:20.932] Value: <not collected>
[17:39:20.932] Conditions captured: <none>
[17:39:20.932] Early signaling: FALSE
[17:39:20.932] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.932] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.941] Chunk #1 of 2 ... DONE
[17:39:20.941] Chunk #2 of 2 ...
[17:39:20.942]  - seeds: <none>
[17:39:20.942] getGlobalsAndPackages() ...
[17:39:20.942] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.942] Resolving globals: FALSE
[17:39:20.942] Tweak future expression to call with '...' arguments ...
[17:39:20.942] {
[17:39:20.942]     do.call(function(...) {
[17:39:20.942]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.942]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.942]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.942]             on.exit(options(oopts), add = TRUE)
[17:39:20.942]         }
[17:39:20.942]         {
[17:39:20.942]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.942]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.942]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.942]             })
[17:39:20.942]         }
[17:39:20.942]     }, args = future.call.arguments)
[17:39:20.942] }
[17:39:20.943] Tweak future expression to call with '...' arguments ... DONE
[17:39:20.943] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:20.944] 
[17:39:20.944] getGlobalsAndPackages() ... DONE
[17:39:20.944] run() for ‘Future’ ...
[17:39:20.944] - state: ‘created’
[17:39:20.945] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:20.953] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:20.954]   - Field: ‘label’
[17:39:20.954]   - Field: ‘local’
[17:39:20.955]   - Field: ‘owner’
[17:39:20.955]   - Field: ‘envir’
[17:39:20.955]   - Field: ‘workers’
[17:39:20.955]   - Field: ‘packages’
[17:39:20.956]   - Field: ‘gc’
[17:39:20.956]   - Field: ‘job’
[17:39:20.956]   - Field: ‘conditions’
[17:39:20.956]   - Field: ‘expr’
[17:39:20.957]   - Field: ‘uuid’
[17:39:20.957]   - Field: ‘seed’
[17:39:20.957]   - Field: ‘version’
[17:39:20.957]   - Field: ‘result’
[17:39:20.958]   - Field: ‘asynchronous’
[17:39:20.958]   - Field: ‘calls’
[17:39:20.958]   - Field: ‘globals’
[17:39:20.958]   - Field: ‘stdout’
[17:39:20.959]   - Field: ‘earlySignal’
[17:39:20.959]   - Field: ‘lazy’
[17:39:20.959]   - Field: ‘state’
[17:39:20.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:20.959] - Launch lazy future ...
[17:39:20.960] Packages needed by the future expression (n = 0): <none>
[17:39:20.960] Packages needed by future strategies (n = 0): <none>
[17:39:20.961] {
[17:39:20.961]     {
[17:39:20.961]         {
[17:39:20.961]             ...future.startTime <- base::Sys.time()
[17:39:20.961]             {
[17:39:20.961]                 {
[17:39:20.961]                   {
[17:39:20.961]                     {
[17:39:20.961]                       base::local({
[17:39:20.961]                         has_future <- base::requireNamespace("future", 
[17:39:20.961]                           quietly = TRUE)
[17:39:20.961]                         if (has_future) {
[17:39:20.961]                           ns <- base::getNamespace("future")
[17:39:20.961]                           version <- ns[[".package"]][["version"]]
[17:39:20.961]                           if (is.null(version)) 
[17:39:20.961]                             version <- utils::packageVersion("future")
[17:39:20.961]                         }
[17:39:20.961]                         else {
[17:39:20.961]                           version <- NULL
[17:39:20.961]                         }
[17:39:20.961]                         if (!has_future || version < "1.8.0") {
[17:39:20.961]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:20.961]                             "", base::R.version$version.string), 
[17:39:20.961]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:20.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:20.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:20.961]                               "release", "version")], collapse = " "), 
[17:39:20.961]                             hostname = base::Sys.info()[["nodename"]])
[17:39:20.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:20.961]                             info)
[17:39:20.961]                           info <- base::paste(info, collapse = "; ")
[17:39:20.961]                           if (!has_future) {
[17:39:20.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:20.961]                               info)
[17:39:20.961]                           }
[17:39:20.961]                           else {
[17:39:20.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:20.961]                               info, version)
[17:39:20.961]                           }
[17:39:20.961]                           base::stop(msg)
[17:39:20.961]                         }
[17:39:20.961]                       })
[17:39:20.961]                     }
[17:39:20.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:20.961]                     base::options(mc.cores = 1L)
[17:39:20.961]                   }
[17:39:20.961]                   options(future.plan = NULL)
[17:39:20.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:20.961]                 }
[17:39:20.961]                 ...future.workdir <- getwd()
[17:39:20.961]             }
[17:39:20.961]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:20.961]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:20.961]         }
[17:39:20.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:20.961]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:20.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:20.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:20.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:20.961]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:20.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:20.961]             base::names(...future.oldOptions))
[17:39:20.961]     }
[17:39:20.961]     if (FALSE) {
[17:39:20.961]     }
[17:39:20.961]     else {
[17:39:20.961]         if (TRUE) {
[17:39:20.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:20.961]                 open = "w")
[17:39:20.961]         }
[17:39:20.961]         else {
[17:39:20.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:20.961]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:20.961]         }
[17:39:20.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:20.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:20.961]             base::sink(type = "output", split = FALSE)
[17:39:20.961]             base::close(...future.stdout)
[17:39:20.961]         }, add = TRUE)
[17:39:20.961]     }
[17:39:20.961]     ...future.frame <- base::sys.nframe()
[17:39:20.961]     ...future.conditions <- base::list()
[17:39:20.961]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:20.961]     if (FALSE) {
[17:39:20.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:20.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:20.961]     }
[17:39:20.961]     ...future.result <- base::tryCatch({
[17:39:20.961]         base::withCallingHandlers({
[17:39:20.961]             ...future.value <- base::withVisible(base::local({
[17:39:20.961]                 withCallingHandlers({
[17:39:20.961]                   {
[17:39:20.961]                     do.call(function(...) {
[17:39:20.961]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.961]                       if (!identical(...future.globals.maxSize.org, 
[17:39:20.961]                         ...future.globals.maxSize)) {
[17:39:20.961]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.961]                         on.exit(options(oopts), add = TRUE)
[17:39:20.961]                       }
[17:39:20.961]                       {
[17:39:20.961]                         lapply(seq_along(...future.elements_ii), 
[17:39:20.961]                           FUN = function(jj) {
[17:39:20.961]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.961]                             ...future.FUN(...future.X_jj, ...)
[17:39:20.961]                           })
[17:39:20.961]                       }
[17:39:20.961]                     }, args = future.call.arguments)
[17:39:20.961]                   }
[17:39:20.961]                 }, immediateCondition = function(cond) {
[17:39:20.961]                   save_rds <- function (object, pathname, ...) 
[17:39:20.961]                   {
[17:39:20.961]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:20.961]                     if (file_test("-f", pathname_tmp)) {
[17:39:20.961]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.961]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:20.961]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.961]                         fi_tmp[["mtime"]])
[17:39:20.961]                     }
[17:39:20.961]                     tryCatch({
[17:39:20.961]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:20.961]                     }, error = function(ex) {
[17:39:20.961]                       msg <- conditionMessage(ex)
[17:39:20.961]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.961]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:20.961]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.961]                         fi_tmp[["mtime"]], msg)
[17:39:20.961]                       ex$message <- msg
[17:39:20.961]                       stop(ex)
[17:39:20.961]                     })
[17:39:20.961]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:20.961]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:20.961]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:20.961]                       fi_tmp <- file.info(pathname_tmp)
[17:39:20.961]                       fi <- file.info(pathname)
[17:39:20.961]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:20.961]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:20.961]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:20.961]                         fi[["size"]], fi[["mtime"]])
[17:39:20.961]                       stop(msg)
[17:39:20.961]                     }
[17:39:20.961]                     invisible(pathname)
[17:39:20.961]                   }
[17:39:20.961]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:20.961]                     rootPath = tempdir()) 
[17:39:20.961]                   {
[17:39:20.961]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:20.961]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:20.961]                       tmpdir = path, fileext = ".rds")
[17:39:20.961]                     save_rds(obj, file)
[17:39:20.961]                   }
[17:39:20.961]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:20.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.961]                   {
[17:39:20.961]                     inherits <- base::inherits
[17:39:20.961]                     invokeRestart <- base::invokeRestart
[17:39:20.961]                     is.null <- base::is.null
[17:39:20.961]                     muffled <- FALSE
[17:39:20.961]                     if (inherits(cond, "message")) {
[17:39:20.961]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:20.961]                       if (muffled) 
[17:39:20.961]                         invokeRestart("muffleMessage")
[17:39:20.961]                     }
[17:39:20.961]                     else if (inherits(cond, "warning")) {
[17:39:20.961]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:20.961]                       if (muffled) 
[17:39:20.961]                         invokeRestart("muffleWarning")
[17:39:20.961]                     }
[17:39:20.961]                     else if (inherits(cond, "condition")) {
[17:39:20.961]                       if (!is.null(pattern)) {
[17:39:20.961]                         computeRestarts <- base::computeRestarts
[17:39:20.961]                         grepl <- base::grepl
[17:39:20.961]                         restarts <- computeRestarts(cond)
[17:39:20.961]                         for (restart in restarts) {
[17:39:20.961]                           name <- restart$name
[17:39:20.961]                           if (is.null(name)) 
[17:39:20.961]                             next
[17:39:20.961]                           if (!grepl(pattern, name)) 
[17:39:20.961]                             next
[17:39:20.961]                           invokeRestart(restart)
[17:39:20.961]                           muffled <- TRUE
[17:39:20.961]                           break
[17:39:20.961]                         }
[17:39:20.961]                       }
[17:39:20.961]                     }
[17:39:20.961]                     invisible(muffled)
[17:39:20.961]                   }
[17:39:20.961]                   muffleCondition(cond)
[17:39:20.961]                 })
[17:39:20.961]             }))
[17:39:20.961]             future::FutureResult(value = ...future.value$value, 
[17:39:20.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.961]                   ...future.rng), globalenv = if (FALSE) 
[17:39:20.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:20.961]                     ...future.globalenv.names))
[17:39:20.961]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:20.961]         }, condition = base::local({
[17:39:20.961]             c <- base::c
[17:39:20.961]             inherits <- base::inherits
[17:39:20.961]             invokeRestart <- base::invokeRestart
[17:39:20.961]             length <- base::length
[17:39:20.961]             list <- base::list
[17:39:20.961]             seq.int <- base::seq.int
[17:39:20.961]             signalCondition <- base::signalCondition
[17:39:20.961]             sys.calls <- base::sys.calls
[17:39:20.961]             `[[` <- base::`[[`
[17:39:20.961]             `+` <- base::`+`
[17:39:20.961]             `<<-` <- base::`<<-`
[17:39:20.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:20.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:20.961]                   3L)]
[17:39:20.961]             }
[17:39:20.961]             function(cond) {
[17:39:20.961]                 is_error <- inherits(cond, "error")
[17:39:20.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:20.961]                   NULL)
[17:39:20.961]                 if (is_error) {
[17:39:20.961]                   sessionInformation <- function() {
[17:39:20.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:20.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:20.961]                       search = base::search(), system = base::Sys.info())
[17:39:20.961]                   }
[17:39:20.961]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:20.961]                     cond$call), session = sessionInformation(), 
[17:39:20.961]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:20.961]                   signalCondition(cond)
[17:39:20.961]                 }
[17:39:20.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:20.961]                 "immediateCondition"))) {
[17:39:20.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:20.961]                   ...future.conditions[[length(...future.conditions) + 
[17:39:20.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:20.961]                   if (TRUE && !signal) {
[17:39:20.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.961]                     {
[17:39:20.961]                       inherits <- base::inherits
[17:39:20.961]                       invokeRestart <- base::invokeRestart
[17:39:20.961]                       is.null <- base::is.null
[17:39:20.961]                       muffled <- FALSE
[17:39:20.961]                       if (inherits(cond, "message")) {
[17:39:20.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.961]                         if (muffled) 
[17:39:20.961]                           invokeRestart("muffleMessage")
[17:39:20.961]                       }
[17:39:20.961]                       else if (inherits(cond, "warning")) {
[17:39:20.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.961]                         if (muffled) 
[17:39:20.961]                           invokeRestart("muffleWarning")
[17:39:20.961]                       }
[17:39:20.961]                       else if (inherits(cond, "condition")) {
[17:39:20.961]                         if (!is.null(pattern)) {
[17:39:20.961]                           computeRestarts <- base::computeRestarts
[17:39:20.961]                           grepl <- base::grepl
[17:39:20.961]                           restarts <- computeRestarts(cond)
[17:39:20.961]                           for (restart in restarts) {
[17:39:20.961]                             name <- restart$name
[17:39:20.961]                             if (is.null(name)) 
[17:39:20.961]                               next
[17:39:20.961]                             if (!grepl(pattern, name)) 
[17:39:20.961]                               next
[17:39:20.961]                             invokeRestart(restart)
[17:39:20.961]                             muffled <- TRUE
[17:39:20.961]                             break
[17:39:20.961]                           }
[17:39:20.961]                         }
[17:39:20.961]                       }
[17:39:20.961]                       invisible(muffled)
[17:39:20.961]                     }
[17:39:20.961]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.961]                   }
[17:39:20.961]                 }
[17:39:20.961]                 else {
[17:39:20.961]                   if (TRUE) {
[17:39:20.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:20.961]                     {
[17:39:20.961]                       inherits <- base::inherits
[17:39:20.961]                       invokeRestart <- base::invokeRestart
[17:39:20.961]                       is.null <- base::is.null
[17:39:20.961]                       muffled <- FALSE
[17:39:20.961]                       if (inherits(cond, "message")) {
[17:39:20.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:20.961]                         if (muffled) 
[17:39:20.961]                           invokeRestart("muffleMessage")
[17:39:20.961]                       }
[17:39:20.961]                       else if (inherits(cond, "warning")) {
[17:39:20.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:20.961]                         if (muffled) 
[17:39:20.961]                           invokeRestart("muffleWarning")
[17:39:20.961]                       }
[17:39:20.961]                       else if (inherits(cond, "condition")) {
[17:39:20.961]                         if (!is.null(pattern)) {
[17:39:20.961]                           computeRestarts <- base::computeRestarts
[17:39:20.961]                           grepl <- base::grepl
[17:39:20.961]                           restarts <- computeRestarts(cond)
[17:39:20.961]                           for (restart in restarts) {
[17:39:20.961]                             name <- restart$name
[17:39:20.961]                             if (is.null(name)) 
[17:39:20.961]                               next
[17:39:20.961]                             if (!grepl(pattern, name)) 
[17:39:20.961]                               next
[17:39:20.961]                             invokeRestart(restart)
[17:39:20.961]                             muffled <- TRUE
[17:39:20.961]                             break
[17:39:20.961]                           }
[17:39:20.961]                         }
[17:39:20.961]                       }
[17:39:20.961]                       invisible(muffled)
[17:39:20.961]                     }
[17:39:20.961]                     muffleCondition(cond, pattern = "^muffle")
[17:39:20.961]                   }
[17:39:20.961]                 }
[17:39:20.961]             }
[17:39:20.961]         }))
[17:39:20.961]     }, error = function(ex) {
[17:39:20.961]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:20.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:20.961]                 ...future.rng), started = ...future.startTime, 
[17:39:20.961]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:20.961]             version = "1.8"), class = "FutureResult")
[17:39:20.961]     }, finally = {
[17:39:20.961]         if (!identical(...future.workdir, getwd())) 
[17:39:20.961]             setwd(...future.workdir)
[17:39:20.961]         {
[17:39:20.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:20.961]                 ...future.oldOptions$nwarnings <- NULL
[17:39:20.961]             }
[17:39:20.961]             base::options(...future.oldOptions)
[17:39:20.961]             if (.Platform$OS.type == "windows") {
[17:39:20.961]                 old_names <- names(...future.oldEnvVars)
[17:39:20.961]                 envs <- base::Sys.getenv()
[17:39:20.961]                 names <- names(envs)
[17:39:20.961]                 common <- intersect(names, old_names)
[17:39:20.961]                 added <- setdiff(names, old_names)
[17:39:20.961]                 removed <- setdiff(old_names, names)
[17:39:20.961]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:20.961]                   envs[common]]
[17:39:20.961]                 NAMES <- toupper(changed)
[17:39:20.961]                 args <- list()
[17:39:20.961]                 for (kk in seq_along(NAMES)) {
[17:39:20.961]                   name <- changed[[kk]]
[17:39:20.961]                   NAME <- NAMES[[kk]]
[17:39:20.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.961]                     next
[17:39:20.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.961]                 }
[17:39:20.961]                 NAMES <- toupper(added)
[17:39:20.961]                 for (kk in seq_along(NAMES)) {
[17:39:20.961]                   name <- added[[kk]]
[17:39:20.961]                   NAME <- NAMES[[kk]]
[17:39:20.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.961]                     next
[17:39:20.961]                   args[[name]] <- ""
[17:39:20.961]                 }
[17:39:20.961]                 NAMES <- toupper(removed)
[17:39:20.961]                 for (kk in seq_along(NAMES)) {
[17:39:20.961]                   name <- removed[[kk]]
[17:39:20.961]                   NAME <- NAMES[[kk]]
[17:39:20.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:20.961]                     next
[17:39:20.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:20.961]                 }
[17:39:20.961]                 if (length(args) > 0) 
[17:39:20.961]                   base::do.call(base::Sys.setenv, args = args)
[17:39:20.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:20.961]             }
[17:39:20.961]             else {
[17:39:20.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:20.961]             }
[17:39:20.961]             {
[17:39:20.961]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:20.961]                   0L) {
[17:39:20.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:20.961]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:20.961]                   base::options(opts)
[17:39:20.961]                 }
[17:39:20.961]                 {
[17:39:20.961]                   {
[17:39:20.961]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:20.961]                     NULL
[17:39:20.961]                   }
[17:39:20.961]                   options(future.plan = NULL)
[17:39:20.961]                   if (is.na(NA_character_)) 
[17:39:20.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:20.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:20.961]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:20.961]                     envir = parent.frame()) 
[17:39:20.961]                   {
[17:39:20.961]                     default_workers <- missing(workers)
[17:39:20.961]                     if (is.function(workers)) 
[17:39:20.961]                       workers <- workers()
[17:39:20.961]                     workers <- structure(as.integer(workers), 
[17:39:20.961]                       class = class(workers))
[17:39:20.961]                     stop_if_not(is.finite(workers), workers >= 
[17:39:20.961]                       1L)
[17:39:20.961]                     if ((workers == 1L && !inherits(workers, 
[17:39:20.961]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:20.961]                       if (default_workers) 
[17:39:20.961]                         supportsMulticore(warn = TRUE)
[17:39:20.961]                       return(sequential(..., envir = envir))
[17:39:20.961]                     }
[17:39:20.961]                     oopts <- options(mc.cores = workers)
[17:39:20.961]                     on.exit(options(oopts))
[17:39:20.961]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:20.961]                       envir = envir)
[17:39:20.961]                     if (!future$lazy) 
[17:39:20.961]                       future <- run(future)
[17:39:20.961]                     invisible(future)
[17:39:20.961]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:20.961]                 }
[17:39:20.961]             }
[17:39:20.961]         }
[17:39:20.961]     })
[17:39:20.961]     if (TRUE) {
[17:39:20.961]         base::sink(type = "output", split = FALSE)
[17:39:20.961]         if (TRUE) {
[17:39:20.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:20.961]         }
[17:39:20.961]         else {
[17:39:20.961]             ...future.result["stdout"] <- base::list(NULL)
[17:39:20.961]         }
[17:39:20.961]         base::close(...future.stdout)
[17:39:20.961]         ...future.stdout <- NULL
[17:39:20.961]     }
[17:39:20.961]     ...future.result$conditions <- ...future.conditions
[17:39:20.961]     ...future.result$finished <- base::Sys.time()
[17:39:20.961]     ...future.result
[17:39:20.961] }
[17:39:20.963] assign_globals() ...
[17:39:20.964] List of 5
[17:39:20.964]  $ future.call.arguments    : list()
[17:39:20.964]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:20.964]  $ ...future.FUN            :function (x)  
[17:39:20.964]  $ ...future.elements_ii    :List of 1
[17:39:20.964]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:39:20.964]  $ ...future.seeds_ii       : NULL
[17:39:20.964]  $ ...future.globals.maxSize: NULL
[17:39:20.964]  - attr(*, "where")=List of 5
[17:39:20.964]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:20.964]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:20.964]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:20.964]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:20.964]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:20.964]  - attr(*, "resolved")= logi FALSE
[17:39:20.964]  - attr(*, "total_size")= num NA
[17:39:20.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:20.964]  - attr(*, "already-done")= logi TRUE
[17:39:20.971] - copied ‘future.call.arguments’ to environment
[17:39:20.971] - copied ‘...future.FUN’ to environment
[17:39:20.971] - copied ‘...future.elements_ii’ to environment
[17:39:20.971] - copied ‘...future.seeds_ii’ to environment
[17:39:20.972] - copied ‘...future.globals.maxSize’ to environment
[17:39:20.972] assign_globals() ... done
[17:39:20.972] requestCore(): workers = 2
[17:39:20.974] MulticoreFuture started
[17:39:20.974] - Launch lazy future ... done
[17:39:20.975] run() for ‘MulticoreFuture’ ... done
[17:39:20.975] Created future:
[17:39:20.975] plan(): Setting new future strategy stack:
[17:39:20.975] List of future strategies:
[17:39:20.975] 1. sequential:
[17:39:20.975]    - args: function (..., envir = parent.frame())
[17:39:20.975]    - tweaked: FALSE
[17:39:20.975]    - call: NULL
[17:39:20.976] plan(): nbrOfWorkers() = 1
[17:39:20.978] plan(): Setting new future strategy stack:
[17:39:20.979] List of future strategies:
[17:39:20.979] 1. multicore:
[17:39:20.979]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:20.979]    - tweaked: FALSE
[17:39:20.979]    - call: plan(strategy)
[17:39:20.984] plan(): nbrOfWorkers() = 2
[17:39:20.975] MulticoreFuture:
[17:39:20.975] Label: ‘future_apply-2’
[17:39:20.975] Expression:
[17:39:20.975] {
[17:39:20.975]     do.call(function(...) {
[17:39:20.975]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:20.975]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:20.975]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:20.975]             on.exit(options(oopts), add = TRUE)
[17:39:20.975]         }
[17:39:20.975]         {
[17:39:20.975]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:20.975]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:20.975]                 ...future.FUN(...future.X_jj, ...)
[17:39:20.975]             })
[17:39:20.975]         }
[17:39:20.975]     }, args = future.call.arguments)
[17:39:20.975] }
[17:39:20.975] Lazy evaluation: FALSE
[17:39:20.975] Asynchronous evaluation: TRUE
[17:39:20.975] Local evaluation: TRUE
[17:39:20.975] Environment: R_GlobalEnv
[17:39:20.975] Capture standard output: TRUE
[17:39:20.975] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:20.975] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:20.975] Packages: <none>
[17:39:20.975] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:20.975] Resolved: TRUE
[17:39:20.975] Value: <not collected>
[17:39:20.975] Conditions captured: <none>
[17:39:20.975] Early signaling: FALSE
[17:39:20.975] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:20.975] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:20.985] Chunk #2 of 2 ... DONE
[17:39:20.985] Launching 2 futures (chunks) ... DONE
[17:39:20.985] Resolving 2 futures (chunks) ...
[17:39:20.985] resolve() on list ...
[17:39:20.985]  recursive: 0
[17:39:20.985]  length: 2
[17:39:20.986] 
[17:39:20.986] Future #1
[17:39:20.987] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:20.987] - nx: 2
[17:39:20.987] - relay: TRUE
[17:39:20.987] - stdout: TRUE
[17:39:20.987] - signal: TRUE
[17:39:20.988] - resignal: FALSE
[17:39:20.988] - force: TRUE
[17:39:20.988] - relayed: [n=2] FALSE, FALSE
[17:39:20.988] - queued futures: [n=2] FALSE, FALSE
[17:39:20.988]  - until=1
[17:39:20.988]  - relaying element #1
[17:39:20.989] - relayed: [n=2] TRUE, FALSE
[17:39:20.989] - queued futures: [n=2] TRUE, FALSE
[17:39:20.989] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:20.989]  length: 1 (resolved future 1)
[17:39:20.989] Future #2
[17:39:20.990] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:20.990] - nx: 2
[17:39:20.991] - relay: TRUE
[17:39:20.991] - stdout: TRUE
[17:39:20.991] - signal: TRUE
[17:39:20.991] - resignal: FALSE
[17:39:20.991] - force: TRUE
[17:39:20.991] - relayed: [n=2] TRUE, FALSE
[17:39:20.991] - queued futures: [n=2] TRUE, FALSE
[17:39:20.991]  - until=2
[17:39:20.992]  - relaying element #2
[17:39:20.992] - relayed: [n=2] TRUE, TRUE
[17:39:20.992] - queued futures: [n=2] TRUE, TRUE
[17:39:20.992] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:20.992]  length: 0 (resolved future 2)
[17:39:20.992] Relaying remaining futures
[17:39:20.992] signalConditionsASAP(NULL, pos=0) ...
[17:39:20.993] - nx: 2
[17:39:20.993] - relay: TRUE
[17:39:20.993] - stdout: TRUE
[17:39:20.993] - signal: TRUE
[17:39:20.993] - resignal: FALSE
[17:39:20.993] - force: TRUE
[17:39:20.993] - relayed: [n=2] TRUE, TRUE
[17:39:20.993] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:20.993] - relayed: [n=2] TRUE, TRUE
[17:39:20.994] - queued futures: [n=2] TRUE, TRUE
[17:39:20.994] signalConditionsASAP(NULL, pos=0) ... done
[17:39:20.994] resolve() on list ... DONE
[17:39:20.994]  - Number of value chunks collected: 2
[17:39:20.994] Resolving 2 futures (chunks) ... DONE
[17:39:20.994] Reducing values from 2 chunks ...
[17:39:20.994]  - Number of values collected after concatenation: 2
[17:39:20.994]  - Number of values expected: 2
[17:39:20.995] Reducing values from 2 chunks ... DONE
[17:39:20.995] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:39:20.995] getGlobalsAndPackagesXApply() ...
[17:39:20.995]  - future.globals: TRUE
[17:39:20.995] getGlobalsAndPackages() ...
[17:39:20.996] Searching for globals...
[17:39:20.997] - globals found: [1] ‘FUN’
[17:39:20.997] Searching for globals ... DONE
[17:39:20.997] Resolving globals: FALSE
[17:39:21.000] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:21.000] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:21.001] - globals: [1] ‘FUN’
[17:39:21.001] 
[17:39:21.001] getGlobalsAndPackages() ... DONE
[17:39:21.001]  - globals found/used: [n=1] ‘FUN’
[17:39:21.001]  - needed namespaces: [n=0] 
[17:39:21.001] Finding globals ... DONE
[17:39:21.002]  - use_args: TRUE
[17:39:21.002]  - Getting '...' globals ...
[17:39:21.002] resolve() on list ...
[17:39:21.002]  recursive: 0
[17:39:21.003]  length: 1
[17:39:21.003]  elements: ‘...’
[17:39:21.003]  length: 0 (resolved future 1)
[17:39:21.003] resolve() on list ... DONE
[17:39:21.003]    - '...' content: [n=0] 
[17:39:21.003] List of 1
[17:39:21.003]  $ ...: list()
[17:39:21.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.003]  - attr(*, "where")=List of 1
[17:39:21.003]   ..$ ...:<environment: 0x55c796f03ed0> 
[17:39:21.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.003]  - attr(*, "resolved")= logi TRUE
[17:39:21.003]  - attr(*, "total_size")= num NA
[17:39:21.007]  - Getting '...' globals ... DONE
[17:39:21.007] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:21.007] List of 2
[17:39:21.007]  $ ...future.FUN:function (x)  
[17:39:21.007]  $ ...          : list()
[17:39:21.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.007]  - attr(*, "where")=List of 2
[17:39:21.007]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:21.007]   ..$ ...          :<environment: 0x55c796f03ed0> 
[17:39:21.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.007]  - attr(*, "resolved")= logi FALSE
[17:39:21.007]  - attr(*, "total_size")= num 848
[17:39:21.011] Packages to be attached in all futures: [n=0] 
[17:39:21.011] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.014] future_lapply() ...
[17:39:21.018] Number of chunks: 2
[17:39:21.018] getGlobalsAndPackagesXApply() ...
[17:39:21.019]  - future.globals: <name-value list> with names ‘list()’
[17:39:21.019]  - use_args: TRUE
[17:39:21.019] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:21.019] List of 2
[17:39:21.019]  $ ...          : list()
[17:39:21.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.019]  $ ...future.FUN:function (x)  
[17:39:21.019]  - attr(*, "where")=List of 2
[17:39:21.019]   ..$ ...          :<environment: 0x55c796f03ed0> 
[17:39:21.019]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:21.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.019]  - attr(*, "resolved")= logi FALSE
[17:39:21.019]  - attr(*, "total_size")= num NA
[17:39:21.022] Packages to be attached in all futures: [n=0] 
[17:39:21.022] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.023] Number of futures (= number of chunks): 2
[17:39:21.023] Launching 2 futures (chunks) ...
[17:39:21.023] Chunk #1 of 2 ...
[17:39:21.023]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[17:39:21.023]  - seeds: <none>
[17:39:21.023] getGlobalsAndPackages() ...
[17:39:21.023] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.023] Resolving globals: FALSE
[17:39:21.024] Tweak future expression to call with '...' arguments ...
[17:39:21.024] {
[17:39:21.024]     do.call(function(...) {
[17:39:21.024]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.024]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.024]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.024]             on.exit(options(oopts), add = TRUE)
[17:39:21.024]         }
[17:39:21.024]         {
[17:39:21.024]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.024]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.024]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.024]             })
[17:39:21.024]         }
[17:39:21.024]     }, args = future.call.arguments)
[17:39:21.024] }
[17:39:21.024] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.024] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.025] 
[17:39:21.025] getGlobalsAndPackages() ... DONE
[17:39:21.025] run() for ‘Future’ ...
[17:39:21.025] - state: ‘created’
[17:39:21.025] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.029] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.029] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.029]   - Field: ‘label’
[17:39:21.029]   - Field: ‘local’
[17:39:21.029]   - Field: ‘owner’
[17:39:21.029]   - Field: ‘envir’
[17:39:21.029]   - Field: ‘workers’
[17:39:21.029]   - Field: ‘packages’
[17:39:21.029]   - Field: ‘gc’
[17:39:21.030]   - Field: ‘job’
[17:39:21.030]   - Field: ‘conditions’
[17:39:21.030]   - Field: ‘expr’
[17:39:21.030]   - Field: ‘uuid’
[17:39:21.030]   - Field: ‘seed’
[17:39:21.030]   - Field: ‘version’
[17:39:21.030]   - Field: ‘result’
[17:39:21.030]   - Field: ‘asynchronous’
[17:39:21.030]   - Field: ‘calls’
[17:39:21.030]   - Field: ‘globals’
[17:39:21.032]   - Field: ‘stdout’
[17:39:21.032]   - Field: ‘earlySignal’
[17:39:21.032]   - Field: ‘lazy’
[17:39:21.032]   - Field: ‘state’
[17:39:21.032] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.033] - Launch lazy future ...
[17:39:21.033] Packages needed by the future expression (n = 0): <none>
[17:39:21.033] Packages needed by future strategies (n = 0): <none>
[17:39:21.034] {
[17:39:21.034]     {
[17:39:21.034]         {
[17:39:21.034]             ...future.startTime <- base::Sys.time()
[17:39:21.034]             {
[17:39:21.034]                 {
[17:39:21.034]                   {
[17:39:21.034]                     {
[17:39:21.034]                       base::local({
[17:39:21.034]                         has_future <- base::requireNamespace("future", 
[17:39:21.034]                           quietly = TRUE)
[17:39:21.034]                         if (has_future) {
[17:39:21.034]                           ns <- base::getNamespace("future")
[17:39:21.034]                           version <- ns[[".package"]][["version"]]
[17:39:21.034]                           if (is.null(version)) 
[17:39:21.034]                             version <- utils::packageVersion("future")
[17:39:21.034]                         }
[17:39:21.034]                         else {
[17:39:21.034]                           version <- NULL
[17:39:21.034]                         }
[17:39:21.034]                         if (!has_future || version < "1.8.0") {
[17:39:21.034]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.034]                             "", base::R.version$version.string), 
[17:39:21.034]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.034]                               "release", "version")], collapse = " "), 
[17:39:21.034]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.034]                             info)
[17:39:21.034]                           info <- base::paste(info, collapse = "; ")
[17:39:21.034]                           if (!has_future) {
[17:39:21.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.034]                               info)
[17:39:21.034]                           }
[17:39:21.034]                           else {
[17:39:21.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.034]                               info, version)
[17:39:21.034]                           }
[17:39:21.034]                           base::stop(msg)
[17:39:21.034]                         }
[17:39:21.034]                       })
[17:39:21.034]                     }
[17:39:21.034]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.034]                     base::options(mc.cores = 1L)
[17:39:21.034]                   }
[17:39:21.034]                   options(future.plan = NULL)
[17:39:21.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.034]                 }
[17:39:21.034]                 ...future.workdir <- getwd()
[17:39:21.034]             }
[17:39:21.034]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.034]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.034]         }
[17:39:21.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.034]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.034]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.034]             base::names(...future.oldOptions))
[17:39:21.034]     }
[17:39:21.034]     if (FALSE) {
[17:39:21.034]     }
[17:39:21.034]     else {
[17:39:21.034]         if (TRUE) {
[17:39:21.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.034]                 open = "w")
[17:39:21.034]         }
[17:39:21.034]         else {
[17:39:21.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.034]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.034]         }
[17:39:21.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.034]             base::sink(type = "output", split = FALSE)
[17:39:21.034]             base::close(...future.stdout)
[17:39:21.034]         }, add = TRUE)
[17:39:21.034]     }
[17:39:21.034]     ...future.frame <- base::sys.nframe()
[17:39:21.034]     ...future.conditions <- base::list()
[17:39:21.034]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.034]     if (FALSE) {
[17:39:21.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.034]     }
[17:39:21.034]     ...future.result <- base::tryCatch({
[17:39:21.034]         base::withCallingHandlers({
[17:39:21.034]             ...future.value <- base::withVisible(base::local({
[17:39:21.034]                 withCallingHandlers({
[17:39:21.034]                   {
[17:39:21.034]                     do.call(function(...) {
[17:39:21.034]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.034]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.034]                         ...future.globals.maxSize)) {
[17:39:21.034]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.034]                         on.exit(options(oopts), add = TRUE)
[17:39:21.034]                       }
[17:39:21.034]                       {
[17:39:21.034]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.034]                           FUN = function(jj) {
[17:39:21.034]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.034]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.034]                           })
[17:39:21.034]                       }
[17:39:21.034]                     }, args = future.call.arguments)
[17:39:21.034]                   }
[17:39:21.034]                 }, immediateCondition = function(cond) {
[17:39:21.034]                   save_rds <- function (object, pathname, ...) 
[17:39:21.034]                   {
[17:39:21.034]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.034]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.034]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.034]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.034]                         fi_tmp[["mtime"]])
[17:39:21.034]                     }
[17:39:21.034]                     tryCatch({
[17:39:21.034]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.034]                     }, error = function(ex) {
[17:39:21.034]                       msg <- conditionMessage(ex)
[17:39:21.034]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.034]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.034]                         fi_tmp[["mtime"]], msg)
[17:39:21.034]                       ex$message <- msg
[17:39:21.034]                       stop(ex)
[17:39:21.034]                     })
[17:39:21.034]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.034]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.034]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.034]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.034]                       fi <- file.info(pathname)
[17:39:21.034]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.034]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.034]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.034]                         fi[["size"]], fi[["mtime"]])
[17:39:21.034]                       stop(msg)
[17:39:21.034]                     }
[17:39:21.034]                     invisible(pathname)
[17:39:21.034]                   }
[17:39:21.034]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.034]                     rootPath = tempdir()) 
[17:39:21.034]                   {
[17:39:21.034]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.034]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.034]                       tmpdir = path, fileext = ".rds")
[17:39:21.034]                     save_rds(obj, file)
[17:39:21.034]                   }
[17:39:21.034]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.034]                   {
[17:39:21.034]                     inherits <- base::inherits
[17:39:21.034]                     invokeRestart <- base::invokeRestart
[17:39:21.034]                     is.null <- base::is.null
[17:39:21.034]                     muffled <- FALSE
[17:39:21.034]                     if (inherits(cond, "message")) {
[17:39:21.034]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.034]                       if (muffled) 
[17:39:21.034]                         invokeRestart("muffleMessage")
[17:39:21.034]                     }
[17:39:21.034]                     else if (inherits(cond, "warning")) {
[17:39:21.034]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.034]                       if (muffled) 
[17:39:21.034]                         invokeRestart("muffleWarning")
[17:39:21.034]                     }
[17:39:21.034]                     else if (inherits(cond, "condition")) {
[17:39:21.034]                       if (!is.null(pattern)) {
[17:39:21.034]                         computeRestarts <- base::computeRestarts
[17:39:21.034]                         grepl <- base::grepl
[17:39:21.034]                         restarts <- computeRestarts(cond)
[17:39:21.034]                         for (restart in restarts) {
[17:39:21.034]                           name <- restart$name
[17:39:21.034]                           if (is.null(name)) 
[17:39:21.034]                             next
[17:39:21.034]                           if (!grepl(pattern, name)) 
[17:39:21.034]                             next
[17:39:21.034]                           invokeRestart(restart)
[17:39:21.034]                           muffled <- TRUE
[17:39:21.034]                           break
[17:39:21.034]                         }
[17:39:21.034]                       }
[17:39:21.034]                     }
[17:39:21.034]                     invisible(muffled)
[17:39:21.034]                   }
[17:39:21.034]                   muffleCondition(cond)
[17:39:21.034]                 })
[17:39:21.034]             }))
[17:39:21.034]             future::FutureResult(value = ...future.value$value, 
[17:39:21.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.034]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.034]                     ...future.globalenv.names))
[17:39:21.034]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.034]         }, condition = base::local({
[17:39:21.034]             c <- base::c
[17:39:21.034]             inherits <- base::inherits
[17:39:21.034]             invokeRestart <- base::invokeRestart
[17:39:21.034]             length <- base::length
[17:39:21.034]             list <- base::list
[17:39:21.034]             seq.int <- base::seq.int
[17:39:21.034]             signalCondition <- base::signalCondition
[17:39:21.034]             sys.calls <- base::sys.calls
[17:39:21.034]             `[[` <- base::`[[`
[17:39:21.034]             `+` <- base::`+`
[17:39:21.034]             `<<-` <- base::`<<-`
[17:39:21.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.034]                   3L)]
[17:39:21.034]             }
[17:39:21.034]             function(cond) {
[17:39:21.034]                 is_error <- inherits(cond, "error")
[17:39:21.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.034]                   NULL)
[17:39:21.034]                 if (is_error) {
[17:39:21.034]                   sessionInformation <- function() {
[17:39:21.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.034]                       search = base::search(), system = base::Sys.info())
[17:39:21.034]                   }
[17:39:21.034]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.034]                     cond$call), session = sessionInformation(), 
[17:39:21.034]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.034]                   signalCondition(cond)
[17:39:21.034]                 }
[17:39:21.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.034]                 "immediateCondition"))) {
[17:39:21.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.034]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.034]                   if (TRUE && !signal) {
[17:39:21.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.034]                     {
[17:39:21.034]                       inherits <- base::inherits
[17:39:21.034]                       invokeRestart <- base::invokeRestart
[17:39:21.034]                       is.null <- base::is.null
[17:39:21.034]                       muffled <- FALSE
[17:39:21.034]                       if (inherits(cond, "message")) {
[17:39:21.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.034]                         if (muffled) 
[17:39:21.034]                           invokeRestart("muffleMessage")
[17:39:21.034]                       }
[17:39:21.034]                       else if (inherits(cond, "warning")) {
[17:39:21.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.034]                         if (muffled) 
[17:39:21.034]                           invokeRestart("muffleWarning")
[17:39:21.034]                       }
[17:39:21.034]                       else if (inherits(cond, "condition")) {
[17:39:21.034]                         if (!is.null(pattern)) {
[17:39:21.034]                           computeRestarts <- base::computeRestarts
[17:39:21.034]                           grepl <- base::grepl
[17:39:21.034]                           restarts <- computeRestarts(cond)
[17:39:21.034]                           for (restart in restarts) {
[17:39:21.034]                             name <- restart$name
[17:39:21.034]                             if (is.null(name)) 
[17:39:21.034]                               next
[17:39:21.034]                             if (!grepl(pattern, name)) 
[17:39:21.034]                               next
[17:39:21.034]                             invokeRestart(restart)
[17:39:21.034]                             muffled <- TRUE
[17:39:21.034]                             break
[17:39:21.034]                           }
[17:39:21.034]                         }
[17:39:21.034]                       }
[17:39:21.034]                       invisible(muffled)
[17:39:21.034]                     }
[17:39:21.034]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.034]                   }
[17:39:21.034]                 }
[17:39:21.034]                 else {
[17:39:21.034]                   if (TRUE) {
[17:39:21.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.034]                     {
[17:39:21.034]                       inherits <- base::inherits
[17:39:21.034]                       invokeRestart <- base::invokeRestart
[17:39:21.034]                       is.null <- base::is.null
[17:39:21.034]                       muffled <- FALSE
[17:39:21.034]                       if (inherits(cond, "message")) {
[17:39:21.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.034]                         if (muffled) 
[17:39:21.034]                           invokeRestart("muffleMessage")
[17:39:21.034]                       }
[17:39:21.034]                       else if (inherits(cond, "warning")) {
[17:39:21.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.034]                         if (muffled) 
[17:39:21.034]                           invokeRestart("muffleWarning")
[17:39:21.034]                       }
[17:39:21.034]                       else if (inherits(cond, "condition")) {
[17:39:21.034]                         if (!is.null(pattern)) {
[17:39:21.034]                           computeRestarts <- base::computeRestarts
[17:39:21.034]                           grepl <- base::grepl
[17:39:21.034]                           restarts <- computeRestarts(cond)
[17:39:21.034]                           for (restart in restarts) {
[17:39:21.034]                             name <- restart$name
[17:39:21.034]                             if (is.null(name)) 
[17:39:21.034]                               next
[17:39:21.034]                             if (!grepl(pattern, name)) 
[17:39:21.034]                               next
[17:39:21.034]                             invokeRestart(restart)
[17:39:21.034]                             muffled <- TRUE
[17:39:21.034]                             break
[17:39:21.034]                           }
[17:39:21.034]                         }
[17:39:21.034]                       }
[17:39:21.034]                       invisible(muffled)
[17:39:21.034]                     }
[17:39:21.034]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.034]                   }
[17:39:21.034]                 }
[17:39:21.034]             }
[17:39:21.034]         }))
[17:39:21.034]     }, error = function(ex) {
[17:39:21.034]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.034]                 ...future.rng), started = ...future.startTime, 
[17:39:21.034]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.034]             version = "1.8"), class = "FutureResult")
[17:39:21.034]     }, finally = {
[17:39:21.034]         if (!identical(...future.workdir, getwd())) 
[17:39:21.034]             setwd(...future.workdir)
[17:39:21.034]         {
[17:39:21.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.034]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.034]             }
[17:39:21.034]             base::options(...future.oldOptions)
[17:39:21.034]             if (.Platform$OS.type == "windows") {
[17:39:21.034]                 old_names <- names(...future.oldEnvVars)
[17:39:21.034]                 envs <- base::Sys.getenv()
[17:39:21.034]                 names <- names(envs)
[17:39:21.034]                 common <- intersect(names, old_names)
[17:39:21.034]                 added <- setdiff(names, old_names)
[17:39:21.034]                 removed <- setdiff(old_names, names)
[17:39:21.034]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.034]                   envs[common]]
[17:39:21.034]                 NAMES <- toupper(changed)
[17:39:21.034]                 args <- list()
[17:39:21.034]                 for (kk in seq_along(NAMES)) {
[17:39:21.034]                   name <- changed[[kk]]
[17:39:21.034]                   NAME <- NAMES[[kk]]
[17:39:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.034]                     next
[17:39:21.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.034]                 }
[17:39:21.034]                 NAMES <- toupper(added)
[17:39:21.034]                 for (kk in seq_along(NAMES)) {
[17:39:21.034]                   name <- added[[kk]]
[17:39:21.034]                   NAME <- NAMES[[kk]]
[17:39:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.034]                     next
[17:39:21.034]                   args[[name]] <- ""
[17:39:21.034]                 }
[17:39:21.034]                 NAMES <- toupper(removed)
[17:39:21.034]                 for (kk in seq_along(NAMES)) {
[17:39:21.034]                   name <- removed[[kk]]
[17:39:21.034]                   NAME <- NAMES[[kk]]
[17:39:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.034]                     next
[17:39:21.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.034]                 }
[17:39:21.034]                 if (length(args) > 0) 
[17:39:21.034]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.034]             }
[17:39:21.034]             else {
[17:39:21.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.034]             }
[17:39:21.034]             {
[17:39:21.034]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.034]                   0L) {
[17:39:21.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.034]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.034]                   base::options(opts)
[17:39:21.034]                 }
[17:39:21.034]                 {
[17:39:21.034]                   {
[17:39:21.034]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.034]                     NULL
[17:39:21.034]                   }
[17:39:21.034]                   options(future.plan = NULL)
[17:39:21.034]                   if (is.na(NA_character_)) 
[17:39:21.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.034]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.034]                     envir = parent.frame()) 
[17:39:21.034]                   {
[17:39:21.034]                     default_workers <- missing(workers)
[17:39:21.034]                     if (is.function(workers)) 
[17:39:21.034]                       workers <- workers()
[17:39:21.034]                     workers <- structure(as.integer(workers), 
[17:39:21.034]                       class = class(workers))
[17:39:21.034]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.034]                       1L)
[17:39:21.034]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.034]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.034]                       if (default_workers) 
[17:39:21.034]                         supportsMulticore(warn = TRUE)
[17:39:21.034]                       return(sequential(..., envir = envir))
[17:39:21.034]                     }
[17:39:21.034]                     oopts <- options(mc.cores = workers)
[17:39:21.034]                     on.exit(options(oopts))
[17:39:21.034]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.034]                       envir = envir)
[17:39:21.034]                     if (!future$lazy) 
[17:39:21.034]                       future <- run(future)
[17:39:21.034]                     invisible(future)
[17:39:21.034]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.034]                 }
[17:39:21.034]             }
[17:39:21.034]         }
[17:39:21.034]     })
[17:39:21.034]     if (TRUE) {
[17:39:21.034]         base::sink(type = "output", split = FALSE)
[17:39:21.034]         if (TRUE) {
[17:39:21.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.034]         }
[17:39:21.034]         else {
[17:39:21.034]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.034]         }
[17:39:21.034]         base::close(...future.stdout)
[17:39:21.034]         ...future.stdout <- NULL
[17:39:21.034]     }
[17:39:21.034]     ...future.result$conditions <- ...future.conditions
[17:39:21.034]     ...future.result$finished <- base::Sys.time()
[17:39:21.034]     ...future.result
[17:39:21.034] }
[17:39:21.036] assign_globals() ...
[17:39:21.036] List of 5
[17:39:21.036]  $ future.call.arguments    : list()
[17:39:21.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.036]  $ ...future.FUN            :function (x)  
[17:39:21.036]  $ ...future.elements_ii    :List of 3
[17:39:21.036]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:39:21.036]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:39:21.036]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:39:21.036]  $ ...future.seeds_ii       : NULL
[17:39:21.036]  $ ...future.globals.maxSize: num Inf
[17:39:21.036]  - attr(*, "resolved")= logi FALSE
[17:39:21.036]  - attr(*, "total_size")= num NA
[17:39:21.036]  - attr(*, "where")=List of 5
[17:39:21.036]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.036]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.036]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.036]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.036]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.036]  - attr(*, "already-done")= logi TRUE
[17:39:21.042] - copied ‘future.call.arguments’ to environment
[17:39:21.042] - copied ‘...future.FUN’ to environment
[17:39:21.042] - copied ‘...future.elements_ii’ to environment
[17:39:21.042] - copied ‘...future.seeds_ii’ to environment
[17:39:21.042] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.042] assign_globals() ... done
[17:39:21.042] requestCore(): workers = 2
[17:39:21.045] MulticoreFuture started
[17:39:21.045] - Launch lazy future ... done
[17:39:21.045] run() for ‘MulticoreFuture’ ... done
[17:39:21.046] Created future:
[17:39:21.046] plan(): Setting new future strategy stack:
[17:39:21.046] List of future strategies:
[17:39:21.046] 1. sequential:
[17:39:21.046]    - args: function (..., envir = parent.frame())
[17:39:21.046]    - tweaked: FALSE
[17:39:21.046]    - call: NULL
[17:39:21.047] plan(): nbrOfWorkers() = 1
[17:39:21.049] plan(): Setting new future strategy stack:
[17:39:21.049] List of future strategies:
[17:39:21.049] 1. multicore:
[17:39:21.049]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.049]    - tweaked: FALSE
[17:39:21.049]    - call: plan(strategy)
[17:39:21.054] plan(): nbrOfWorkers() = 2
[17:39:21.046] MulticoreFuture:
[17:39:21.046] Label: ‘future_apply-1’
[17:39:21.046] Expression:
[17:39:21.046] {
[17:39:21.046]     do.call(function(...) {
[17:39:21.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.046]             on.exit(options(oopts), add = TRUE)
[17:39:21.046]         }
[17:39:21.046]         {
[17:39:21.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.046]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.046]             })
[17:39:21.046]         }
[17:39:21.046]     }, args = future.call.arguments)
[17:39:21.046] }
[17:39:21.046] Lazy evaluation: FALSE
[17:39:21.046] Asynchronous evaluation: TRUE
[17:39:21.046] Local evaluation: TRUE
[17:39:21.046] Environment: R_GlobalEnv
[17:39:21.046] Capture standard output: TRUE
[17:39:21.046] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.046] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:21.046] Packages: <none>
[17:39:21.046] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.046] Resolved: TRUE
[17:39:21.046] Value: <not collected>
[17:39:21.046] Conditions captured: <none>
[17:39:21.046] Early signaling: FALSE
[17:39:21.046] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.046] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.055] Chunk #1 of 2 ... DONE
[17:39:21.055] Chunk #2 of 2 ...
[17:39:21.056]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[17:39:21.056]  - seeds: <none>
[17:39:21.056] getGlobalsAndPackages() ...
[17:39:21.056] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.056] Resolving globals: FALSE
[17:39:21.056] Tweak future expression to call with '...' arguments ...
[17:39:21.057] {
[17:39:21.057]     do.call(function(...) {
[17:39:21.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.057]             on.exit(options(oopts), add = TRUE)
[17:39:21.057]         }
[17:39:21.057]         {
[17:39:21.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.057]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.057]             })
[17:39:21.057]         }
[17:39:21.057]     }, args = future.call.arguments)
[17:39:21.057] }
[17:39:21.057] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.058] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.058] 
[17:39:21.058] getGlobalsAndPackages() ... DONE
[17:39:21.058] run() for ‘Future’ ...
[17:39:21.059] - state: ‘created’
[17:39:21.059] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.063] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.063] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.064]   - Field: ‘label’
[17:39:21.064]   - Field: ‘local’
[17:39:21.064]   - Field: ‘owner’
[17:39:21.064]   - Field: ‘envir’
[17:39:21.064]   - Field: ‘workers’
[17:39:21.064]   - Field: ‘packages’
[17:39:21.065]   - Field: ‘gc’
[17:39:21.065]   - Field: ‘job’
[17:39:21.065]   - Field: ‘conditions’
[17:39:21.065]   - Field: ‘expr’
[17:39:21.065]   - Field: ‘uuid’
[17:39:21.065]   - Field: ‘seed’
[17:39:21.066]   - Field: ‘version’
[17:39:21.066]   - Field: ‘result’
[17:39:21.066]   - Field: ‘asynchronous’
[17:39:21.066]   - Field: ‘calls’
[17:39:21.066]   - Field: ‘globals’
[17:39:21.066]   - Field: ‘stdout’
[17:39:21.066]   - Field: ‘earlySignal’
[17:39:21.067]   - Field: ‘lazy’
[17:39:21.067]   - Field: ‘state’
[17:39:21.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.067] - Launch lazy future ...
[17:39:21.067] Packages needed by the future expression (n = 0): <none>
[17:39:21.068] Packages needed by future strategies (n = 0): <none>
[17:39:21.068] {
[17:39:21.068]     {
[17:39:21.068]         {
[17:39:21.068]             ...future.startTime <- base::Sys.time()
[17:39:21.068]             {
[17:39:21.068]                 {
[17:39:21.068]                   {
[17:39:21.068]                     {
[17:39:21.068]                       base::local({
[17:39:21.068]                         has_future <- base::requireNamespace("future", 
[17:39:21.068]                           quietly = TRUE)
[17:39:21.068]                         if (has_future) {
[17:39:21.068]                           ns <- base::getNamespace("future")
[17:39:21.068]                           version <- ns[[".package"]][["version"]]
[17:39:21.068]                           if (is.null(version)) 
[17:39:21.068]                             version <- utils::packageVersion("future")
[17:39:21.068]                         }
[17:39:21.068]                         else {
[17:39:21.068]                           version <- NULL
[17:39:21.068]                         }
[17:39:21.068]                         if (!has_future || version < "1.8.0") {
[17:39:21.068]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.068]                             "", base::R.version$version.string), 
[17:39:21.068]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.068]                               "release", "version")], collapse = " "), 
[17:39:21.068]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.068]                             info)
[17:39:21.068]                           info <- base::paste(info, collapse = "; ")
[17:39:21.068]                           if (!has_future) {
[17:39:21.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.068]                               info)
[17:39:21.068]                           }
[17:39:21.068]                           else {
[17:39:21.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.068]                               info, version)
[17:39:21.068]                           }
[17:39:21.068]                           base::stop(msg)
[17:39:21.068]                         }
[17:39:21.068]                       })
[17:39:21.068]                     }
[17:39:21.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.068]                     base::options(mc.cores = 1L)
[17:39:21.068]                   }
[17:39:21.068]                   options(future.plan = NULL)
[17:39:21.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.068]                 }
[17:39:21.068]                 ...future.workdir <- getwd()
[17:39:21.068]             }
[17:39:21.068]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.068]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.068]         }
[17:39:21.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.068]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.068]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.068]             base::names(...future.oldOptions))
[17:39:21.068]     }
[17:39:21.068]     if (FALSE) {
[17:39:21.068]     }
[17:39:21.068]     else {
[17:39:21.068]         if (TRUE) {
[17:39:21.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.068]                 open = "w")
[17:39:21.068]         }
[17:39:21.068]         else {
[17:39:21.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.068]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.068]         }
[17:39:21.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.068]             base::sink(type = "output", split = FALSE)
[17:39:21.068]             base::close(...future.stdout)
[17:39:21.068]         }, add = TRUE)
[17:39:21.068]     }
[17:39:21.068]     ...future.frame <- base::sys.nframe()
[17:39:21.068]     ...future.conditions <- base::list()
[17:39:21.068]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.068]     if (FALSE) {
[17:39:21.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.068]     }
[17:39:21.068]     ...future.result <- base::tryCatch({
[17:39:21.068]         base::withCallingHandlers({
[17:39:21.068]             ...future.value <- base::withVisible(base::local({
[17:39:21.068]                 withCallingHandlers({
[17:39:21.068]                   {
[17:39:21.068]                     do.call(function(...) {
[17:39:21.068]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.068]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.068]                         ...future.globals.maxSize)) {
[17:39:21.068]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.068]                         on.exit(options(oopts), add = TRUE)
[17:39:21.068]                       }
[17:39:21.068]                       {
[17:39:21.068]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.068]                           FUN = function(jj) {
[17:39:21.068]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.068]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.068]                           })
[17:39:21.068]                       }
[17:39:21.068]                     }, args = future.call.arguments)
[17:39:21.068]                   }
[17:39:21.068]                 }, immediateCondition = function(cond) {
[17:39:21.068]                   save_rds <- function (object, pathname, ...) 
[17:39:21.068]                   {
[17:39:21.068]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.068]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.068]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.068]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.068]                         fi_tmp[["mtime"]])
[17:39:21.068]                     }
[17:39:21.068]                     tryCatch({
[17:39:21.068]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.068]                     }, error = function(ex) {
[17:39:21.068]                       msg <- conditionMessage(ex)
[17:39:21.068]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.068]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.068]                         fi_tmp[["mtime"]], msg)
[17:39:21.068]                       ex$message <- msg
[17:39:21.068]                       stop(ex)
[17:39:21.068]                     })
[17:39:21.068]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.068]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.068]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.068]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.068]                       fi <- file.info(pathname)
[17:39:21.068]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.068]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.068]                         fi[["size"]], fi[["mtime"]])
[17:39:21.068]                       stop(msg)
[17:39:21.068]                     }
[17:39:21.068]                     invisible(pathname)
[17:39:21.068]                   }
[17:39:21.068]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.068]                     rootPath = tempdir()) 
[17:39:21.068]                   {
[17:39:21.068]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.068]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.068]                       tmpdir = path, fileext = ".rds")
[17:39:21.068]                     save_rds(obj, file)
[17:39:21.068]                   }
[17:39:21.068]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.068]                   {
[17:39:21.068]                     inherits <- base::inherits
[17:39:21.068]                     invokeRestart <- base::invokeRestart
[17:39:21.068]                     is.null <- base::is.null
[17:39:21.068]                     muffled <- FALSE
[17:39:21.068]                     if (inherits(cond, "message")) {
[17:39:21.068]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.068]                       if (muffled) 
[17:39:21.068]                         invokeRestart("muffleMessage")
[17:39:21.068]                     }
[17:39:21.068]                     else if (inherits(cond, "warning")) {
[17:39:21.068]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.068]                       if (muffled) 
[17:39:21.068]                         invokeRestart("muffleWarning")
[17:39:21.068]                     }
[17:39:21.068]                     else if (inherits(cond, "condition")) {
[17:39:21.068]                       if (!is.null(pattern)) {
[17:39:21.068]                         computeRestarts <- base::computeRestarts
[17:39:21.068]                         grepl <- base::grepl
[17:39:21.068]                         restarts <- computeRestarts(cond)
[17:39:21.068]                         for (restart in restarts) {
[17:39:21.068]                           name <- restart$name
[17:39:21.068]                           if (is.null(name)) 
[17:39:21.068]                             next
[17:39:21.068]                           if (!grepl(pattern, name)) 
[17:39:21.068]                             next
[17:39:21.068]                           invokeRestart(restart)
[17:39:21.068]                           muffled <- TRUE
[17:39:21.068]                           break
[17:39:21.068]                         }
[17:39:21.068]                       }
[17:39:21.068]                     }
[17:39:21.068]                     invisible(muffled)
[17:39:21.068]                   }
[17:39:21.068]                   muffleCondition(cond)
[17:39:21.068]                 })
[17:39:21.068]             }))
[17:39:21.068]             future::FutureResult(value = ...future.value$value, 
[17:39:21.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.068]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.068]                     ...future.globalenv.names))
[17:39:21.068]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.068]         }, condition = base::local({
[17:39:21.068]             c <- base::c
[17:39:21.068]             inherits <- base::inherits
[17:39:21.068]             invokeRestart <- base::invokeRestart
[17:39:21.068]             length <- base::length
[17:39:21.068]             list <- base::list
[17:39:21.068]             seq.int <- base::seq.int
[17:39:21.068]             signalCondition <- base::signalCondition
[17:39:21.068]             sys.calls <- base::sys.calls
[17:39:21.068]             `[[` <- base::`[[`
[17:39:21.068]             `+` <- base::`+`
[17:39:21.068]             `<<-` <- base::`<<-`
[17:39:21.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.068]                   3L)]
[17:39:21.068]             }
[17:39:21.068]             function(cond) {
[17:39:21.068]                 is_error <- inherits(cond, "error")
[17:39:21.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.068]                   NULL)
[17:39:21.068]                 if (is_error) {
[17:39:21.068]                   sessionInformation <- function() {
[17:39:21.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.068]                       search = base::search(), system = base::Sys.info())
[17:39:21.068]                   }
[17:39:21.068]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.068]                     cond$call), session = sessionInformation(), 
[17:39:21.068]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.068]                   signalCondition(cond)
[17:39:21.068]                 }
[17:39:21.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.068]                 "immediateCondition"))) {
[17:39:21.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.068]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.068]                   if (TRUE && !signal) {
[17:39:21.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.068]                     {
[17:39:21.068]                       inherits <- base::inherits
[17:39:21.068]                       invokeRestart <- base::invokeRestart
[17:39:21.068]                       is.null <- base::is.null
[17:39:21.068]                       muffled <- FALSE
[17:39:21.068]                       if (inherits(cond, "message")) {
[17:39:21.068]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.068]                         if (muffled) 
[17:39:21.068]                           invokeRestart("muffleMessage")
[17:39:21.068]                       }
[17:39:21.068]                       else if (inherits(cond, "warning")) {
[17:39:21.068]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.068]                         if (muffled) 
[17:39:21.068]                           invokeRestart("muffleWarning")
[17:39:21.068]                       }
[17:39:21.068]                       else if (inherits(cond, "condition")) {
[17:39:21.068]                         if (!is.null(pattern)) {
[17:39:21.068]                           computeRestarts <- base::computeRestarts
[17:39:21.068]                           grepl <- base::grepl
[17:39:21.068]                           restarts <- computeRestarts(cond)
[17:39:21.068]                           for (restart in restarts) {
[17:39:21.068]                             name <- restart$name
[17:39:21.068]                             if (is.null(name)) 
[17:39:21.068]                               next
[17:39:21.068]                             if (!grepl(pattern, name)) 
[17:39:21.068]                               next
[17:39:21.068]                             invokeRestart(restart)
[17:39:21.068]                             muffled <- TRUE
[17:39:21.068]                             break
[17:39:21.068]                           }
[17:39:21.068]                         }
[17:39:21.068]                       }
[17:39:21.068]                       invisible(muffled)
[17:39:21.068]                     }
[17:39:21.068]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.068]                   }
[17:39:21.068]                 }
[17:39:21.068]                 else {
[17:39:21.068]                   if (TRUE) {
[17:39:21.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.068]                     {
[17:39:21.068]                       inherits <- base::inherits
[17:39:21.068]                       invokeRestart <- base::invokeRestart
[17:39:21.068]                       is.null <- base::is.null
[17:39:21.068]                       muffled <- FALSE
[17:39:21.068]                       if (inherits(cond, "message")) {
[17:39:21.068]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.068]                         if (muffled) 
[17:39:21.068]                           invokeRestart("muffleMessage")
[17:39:21.068]                       }
[17:39:21.068]                       else if (inherits(cond, "warning")) {
[17:39:21.068]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.068]                         if (muffled) 
[17:39:21.068]                           invokeRestart("muffleWarning")
[17:39:21.068]                       }
[17:39:21.068]                       else if (inherits(cond, "condition")) {
[17:39:21.068]                         if (!is.null(pattern)) {
[17:39:21.068]                           computeRestarts <- base::computeRestarts
[17:39:21.068]                           grepl <- base::grepl
[17:39:21.068]                           restarts <- computeRestarts(cond)
[17:39:21.068]                           for (restart in restarts) {
[17:39:21.068]                             name <- restart$name
[17:39:21.068]                             if (is.null(name)) 
[17:39:21.068]                               next
[17:39:21.068]                             if (!grepl(pattern, name)) 
[17:39:21.068]                               next
[17:39:21.068]                             invokeRestart(restart)
[17:39:21.068]                             muffled <- TRUE
[17:39:21.068]                             break
[17:39:21.068]                           }
[17:39:21.068]                         }
[17:39:21.068]                       }
[17:39:21.068]                       invisible(muffled)
[17:39:21.068]                     }
[17:39:21.068]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.068]                   }
[17:39:21.068]                 }
[17:39:21.068]             }
[17:39:21.068]         }))
[17:39:21.068]     }, error = function(ex) {
[17:39:21.068]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.068]                 ...future.rng), started = ...future.startTime, 
[17:39:21.068]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.068]             version = "1.8"), class = "FutureResult")
[17:39:21.068]     }, finally = {
[17:39:21.068]         if (!identical(...future.workdir, getwd())) 
[17:39:21.068]             setwd(...future.workdir)
[17:39:21.068]         {
[17:39:21.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.068]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.068]             }
[17:39:21.068]             base::options(...future.oldOptions)
[17:39:21.068]             if (.Platform$OS.type == "windows") {
[17:39:21.068]                 old_names <- names(...future.oldEnvVars)
[17:39:21.068]                 envs <- base::Sys.getenv()
[17:39:21.068]                 names <- names(envs)
[17:39:21.068]                 common <- intersect(names, old_names)
[17:39:21.068]                 added <- setdiff(names, old_names)
[17:39:21.068]                 removed <- setdiff(old_names, names)
[17:39:21.068]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.068]                   envs[common]]
[17:39:21.068]                 NAMES <- toupper(changed)
[17:39:21.068]                 args <- list()
[17:39:21.068]                 for (kk in seq_along(NAMES)) {
[17:39:21.068]                   name <- changed[[kk]]
[17:39:21.068]                   NAME <- NAMES[[kk]]
[17:39:21.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.068]                     next
[17:39:21.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.068]                 }
[17:39:21.068]                 NAMES <- toupper(added)
[17:39:21.068]                 for (kk in seq_along(NAMES)) {
[17:39:21.068]                   name <- added[[kk]]
[17:39:21.068]                   NAME <- NAMES[[kk]]
[17:39:21.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.068]                     next
[17:39:21.068]                   args[[name]] <- ""
[17:39:21.068]                 }
[17:39:21.068]                 NAMES <- toupper(removed)
[17:39:21.068]                 for (kk in seq_along(NAMES)) {
[17:39:21.068]                   name <- removed[[kk]]
[17:39:21.068]                   NAME <- NAMES[[kk]]
[17:39:21.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.068]                     next
[17:39:21.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.068]                 }
[17:39:21.068]                 if (length(args) > 0) 
[17:39:21.068]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.068]             }
[17:39:21.068]             else {
[17:39:21.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.068]             }
[17:39:21.068]             {
[17:39:21.068]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.068]                   0L) {
[17:39:21.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.068]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.068]                   base::options(opts)
[17:39:21.068]                 }
[17:39:21.068]                 {
[17:39:21.068]                   {
[17:39:21.068]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.068]                     NULL
[17:39:21.068]                   }
[17:39:21.068]                   options(future.plan = NULL)
[17:39:21.068]                   if (is.na(NA_character_)) 
[17:39:21.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.068]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.068]                     envir = parent.frame()) 
[17:39:21.068]                   {
[17:39:21.068]                     default_workers <- missing(workers)
[17:39:21.068]                     if (is.function(workers)) 
[17:39:21.068]                       workers <- workers()
[17:39:21.068]                     workers <- structure(as.integer(workers), 
[17:39:21.068]                       class = class(workers))
[17:39:21.068]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.068]                       1L)
[17:39:21.068]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.068]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.068]                       if (default_workers) 
[17:39:21.068]                         supportsMulticore(warn = TRUE)
[17:39:21.068]                       return(sequential(..., envir = envir))
[17:39:21.068]                     }
[17:39:21.068]                     oopts <- options(mc.cores = workers)
[17:39:21.068]                     on.exit(options(oopts))
[17:39:21.068]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.068]                       envir = envir)
[17:39:21.068]                     if (!future$lazy) 
[17:39:21.068]                       future <- run(future)
[17:39:21.068]                     invisible(future)
[17:39:21.068]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.068]                 }
[17:39:21.068]             }
[17:39:21.068]         }
[17:39:21.068]     })
[17:39:21.068]     if (TRUE) {
[17:39:21.068]         base::sink(type = "output", split = FALSE)
[17:39:21.068]         if (TRUE) {
[17:39:21.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.068]         }
[17:39:21.068]         else {
[17:39:21.068]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.068]         }
[17:39:21.068]         base::close(...future.stdout)
[17:39:21.068]         ...future.stdout <- NULL
[17:39:21.068]     }
[17:39:21.068]     ...future.result$conditions <- ...future.conditions
[17:39:21.068]     ...future.result$finished <- base::Sys.time()
[17:39:21.068]     ...future.result
[17:39:21.068] }
[17:39:21.072] assign_globals() ...
[17:39:21.072] List of 5
[17:39:21.072]  $ future.call.arguments    : list()
[17:39:21.072]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.072]  $ ...future.FUN            :function (x)  
[17:39:21.072]  $ ...future.elements_ii    :List of 3
[17:39:21.072]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:39:21.072]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:39:21.072]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:39:21.072]  $ ...future.seeds_ii       : NULL
[17:39:21.072]  $ ...future.globals.maxSize: num Inf
[17:39:21.072]  - attr(*, "resolved")= logi FALSE
[17:39:21.072]  - attr(*, "total_size")= num NA
[17:39:21.072]  - attr(*, "where")=List of 5
[17:39:21.072]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.072]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.072]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.072]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.072]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.072]  - attr(*, "already-done")= logi TRUE
[17:39:21.085] - copied ‘future.call.arguments’ to environment
[17:39:21.085] - copied ‘...future.FUN’ to environment
[17:39:21.085] - copied ‘...future.elements_ii’ to environment
[17:39:21.085] - copied ‘...future.seeds_ii’ to environment
[17:39:21.085] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.085] assign_globals() ... done
[17:39:21.086] requestCore(): workers = 2
[17:39:21.088] MulticoreFuture started
[17:39:21.088] - Launch lazy future ... done
[17:39:21.089] run() for ‘MulticoreFuture’ ... done
[17:39:21.089] Created future:
[17:39:21.089] plan(): Setting new future strategy stack:
[17:39:21.089] List of future strategies:
[17:39:21.089] 1. sequential:
[17:39:21.089]    - args: function (..., envir = parent.frame())
[17:39:21.089]    - tweaked: FALSE
[17:39:21.089]    - call: NULL
[17:39:21.090] plan(): nbrOfWorkers() = 1
[17:39:21.092] plan(): Setting new future strategy stack:
[17:39:21.093] List of future strategies:
[17:39:21.093] 1. multicore:
[17:39:21.093]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.093]    - tweaked: FALSE
[17:39:21.093]    - call: plan(strategy)
[17:39:21.099] plan(): nbrOfWorkers() = 2
[17:39:21.089] MulticoreFuture:
[17:39:21.089] Label: ‘future_apply-2’
[17:39:21.089] Expression:
[17:39:21.089] {
[17:39:21.089]     do.call(function(...) {
[17:39:21.089]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.089]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.089]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.089]             on.exit(options(oopts), add = TRUE)
[17:39:21.089]         }
[17:39:21.089]         {
[17:39:21.089]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.089]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.089]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.089]             })
[17:39:21.089]         }
[17:39:21.089]     }, args = future.call.arguments)
[17:39:21.089] }
[17:39:21.089] Lazy evaluation: FALSE
[17:39:21.089] Asynchronous evaluation: TRUE
[17:39:21.089] Local evaluation: TRUE
[17:39:21.089] Environment: R_GlobalEnv
[17:39:21.089] Capture standard output: TRUE
[17:39:21.089] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.089] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:21.089] Packages: <none>
[17:39:21.089] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.089] Resolved: TRUE
[17:39:21.089] Value: <not collected>
[17:39:21.089] Conditions captured: <none>
[17:39:21.089] Early signaling: FALSE
[17:39:21.089] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.089] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.100] Chunk #2 of 2 ... DONE
[17:39:21.100] Launching 2 futures (chunks) ... DONE
[17:39:21.100] Resolving 2 futures (chunks) ...
[17:39:21.101] resolve() on list ...
[17:39:21.101]  recursive: 0
[17:39:21.101]  length: 2
[17:39:21.102] 
[17:39:21.102] Future #1
[17:39:21.103] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:21.103] - nx: 2
[17:39:21.103] - relay: TRUE
[17:39:21.103] - stdout: TRUE
[17:39:21.104] - signal: TRUE
[17:39:21.104] - resignal: FALSE
[17:39:21.104] - force: TRUE
[17:39:21.104] - relayed: [n=2] FALSE, FALSE
[17:39:21.104] - queued futures: [n=2] FALSE, FALSE
[17:39:21.105]  - until=1
[17:39:21.105]  - relaying element #1
[17:39:21.105] - relayed: [n=2] TRUE, FALSE
[17:39:21.105] - queued futures: [n=2] TRUE, FALSE
[17:39:21.105] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:21.106]  length: 1 (resolved future 1)
[17:39:21.106] Future #2
[17:39:21.107] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:21.107] - nx: 2
[17:39:21.107] - relay: TRUE
[17:39:21.107] - stdout: TRUE
[17:39:21.107] - signal: TRUE
[17:39:21.107] - resignal: FALSE
[17:39:21.107] - force: TRUE
[17:39:21.108] - relayed: [n=2] TRUE, FALSE
[17:39:21.108] - queued futures: [n=2] TRUE, FALSE
[17:39:21.108]  - until=2
[17:39:21.108]  - relaying element #2
[17:39:21.108] - relayed: [n=2] TRUE, TRUE
[17:39:21.108] - queued futures: [n=2] TRUE, TRUE
[17:39:21.108] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:21.109]  length: 0 (resolved future 2)
[17:39:21.109] Relaying remaining futures
[17:39:21.109] signalConditionsASAP(NULL, pos=0) ...
[17:39:21.109] - nx: 2
[17:39:21.109] - relay: TRUE
[17:39:21.109] - stdout: TRUE
[17:39:21.109] - signal: TRUE
[17:39:21.109] - resignal: FALSE
[17:39:21.109] - force: TRUE
[17:39:21.110] - relayed: [n=2] TRUE, TRUE
[17:39:21.110] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:21.110] - relayed: [n=2] TRUE, TRUE
[17:39:21.110] - queued futures: [n=2] TRUE, TRUE
[17:39:21.110] signalConditionsASAP(NULL, pos=0) ... done
[17:39:21.110] resolve() on list ... DONE
[17:39:21.110]  - Number of value chunks collected: 2
[17:39:21.111] Resolving 2 futures (chunks) ... DONE
[17:39:21.111] Reducing values from 2 chunks ...
[17:39:21.111]  - Number of values collected after concatenation: 6
[17:39:21.111]  - Number of values expected: 6
[17:39:21.111] Reducing values from 2 chunks ... DONE
[17:39:21.111] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:39:21.112] getGlobalsAndPackagesXApply() ...
[17:39:21.112]  - future.globals: TRUE
[17:39:21.112] getGlobalsAndPackages() ...
[17:39:21.112] Searching for globals...
[17:39:21.114] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:39:21.114] Searching for globals ... DONE
[17:39:21.114] Resolving globals: FALSE
[17:39:21.114] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:39:21.115] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:39:21.115] - globals: [1] ‘FUN’
[17:39:21.115] 
[17:39:21.115] getGlobalsAndPackages() ... DONE
[17:39:21.115]  - globals found/used: [n=1] ‘FUN’
[17:39:21.116]  - needed namespaces: [n=0] 
[17:39:21.116] Finding globals ... DONE
[17:39:21.116]  - use_args: TRUE
[17:39:21.116]  - Getting '...' globals ...
[17:39:21.116] resolve() on list ...
[17:39:21.116]  recursive: 0
[17:39:21.116]  length: 1
[17:39:21.117]  elements: ‘...’
[17:39:21.117]  length: 0 (resolved future 1)
[17:39:21.117] resolve() on list ... DONE
[17:39:21.117]    - '...' content: [n=0] 
[17:39:21.117] List of 1
[17:39:21.117]  $ ...: list()
[17:39:21.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.117]  - attr(*, "where")=List of 1
[17:39:21.117]   ..$ ...:<environment: 0x55c7966b9168> 
[17:39:21.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.117]  - attr(*, "resolved")= logi TRUE
[17:39:21.117]  - attr(*, "total_size")= num NA
[17:39:21.120]  - Getting '...' globals ... DONE
[17:39:21.120] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:21.121] List of 2
[17:39:21.121]  $ ...future.FUN:function (x)  
[17:39:21.121]  $ ...          : list()
[17:39:21.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.121]  - attr(*, "where")=List of 2
[17:39:21.121]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:21.121]   ..$ ...          :<environment: 0x55c7966b9168> 
[17:39:21.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.121]  - attr(*, "resolved")= logi FALSE
[17:39:21.121]  - attr(*, "total_size")= num 1768
[17:39:21.126] Packages to be attached in all futures: [n=0] 
[17:39:21.126] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.130] future_lapply() ...
[17:39:21.134] Number of chunks: 2
[17:39:21.134] getGlobalsAndPackagesXApply() ...
[17:39:21.134]  - future.globals: <name-value list> with names ‘list()’
[17:39:21.135]  - use_args: TRUE
[17:39:21.135] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:21.135] List of 2
[17:39:21.135]  $ ...          : list()
[17:39:21.135]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.135]  $ ...future.FUN:function (x)  
[17:39:21.135]  - attr(*, "where")=List of 2
[17:39:21.135]   ..$ ...          :<environment: 0x55c7966b9168> 
[17:39:21.135]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:39:21.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.135]  - attr(*, "resolved")= logi FALSE
[17:39:21.135]  - attr(*, "total_size")= num NA
[17:39:21.137] Packages to be attached in all futures: [n=0] 
[17:39:21.138] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.138] Number of futures (= number of chunks): 2
[17:39:21.138] Launching 2 futures (chunks) ...
[17:39:21.138] Chunk #1 of 2 ...
[17:39:21.138]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[17:39:21.138]  - seeds: <none>
[17:39:21.138] getGlobalsAndPackages() ...
[17:39:21.138] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.139] Resolving globals: FALSE
[17:39:21.139] Tweak future expression to call with '...' arguments ...
[17:39:21.139] {
[17:39:21.139]     do.call(function(...) {
[17:39:21.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.139]             on.exit(options(oopts), add = TRUE)
[17:39:21.139]         }
[17:39:21.139]         {
[17:39:21.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.139]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.139]             })
[17:39:21.139]         }
[17:39:21.139]     }, args = future.call.arguments)
[17:39:21.139] }
[17:39:21.139] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.139] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.140] 
[17:39:21.140] getGlobalsAndPackages() ... DONE
[17:39:21.140] run() for ‘Future’ ...
[17:39:21.140] - state: ‘created’
[17:39:21.140] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.144] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.144] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.144]   - Field: ‘label’
[17:39:21.144]   - Field: ‘local’
[17:39:21.144]   - Field: ‘owner’
[17:39:21.144]   - Field: ‘envir’
[17:39:21.144]   - Field: ‘workers’
[17:39:21.144]   - Field: ‘packages’
[17:39:21.144]   - Field: ‘gc’
[17:39:21.145]   - Field: ‘job’
[17:39:21.145]   - Field: ‘conditions’
[17:39:21.145]   - Field: ‘expr’
[17:39:21.145]   - Field: ‘uuid’
[17:39:21.145]   - Field: ‘seed’
[17:39:21.145]   - Field: ‘version’
[17:39:21.145]   - Field: ‘result’
[17:39:21.145]   - Field: ‘asynchronous’
[17:39:21.145]   - Field: ‘calls’
[17:39:21.145]   - Field: ‘globals’
[17:39:21.146]   - Field: ‘stdout’
[17:39:21.146]   - Field: ‘earlySignal’
[17:39:21.146]   - Field: ‘lazy’
[17:39:21.146]   - Field: ‘state’
[17:39:21.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.146] - Launch lazy future ...
[17:39:21.146] Packages needed by the future expression (n = 0): <none>
[17:39:21.146] Packages needed by future strategies (n = 0): <none>
[17:39:21.147] {
[17:39:21.147]     {
[17:39:21.147]         {
[17:39:21.147]             ...future.startTime <- base::Sys.time()
[17:39:21.147]             {
[17:39:21.147]                 {
[17:39:21.147]                   {
[17:39:21.147]                     {
[17:39:21.147]                       base::local({
[17:39:21.147]                         has_future <- base::requireNamespace("future", 
[17:39:21.147]                           quietly = TRUE)
[17:39:21.147]                         if (has_future) {
[17:39:21.147]                           ns <- base::getNamespace("future")
[17:39:21.147]                           version <- ns[[".package"]][["version"]]
[17:39:21.147]                           if (is.null(version)) 
[17:39:21.147]                             version <- utils::packageVersion("future")
[17:39:21.147]                         }
[17:39:21.147]                         else {
[17:39:21.147]                           version <- NULL
[17:39:21.147]                         }
[17:39:21.147]                         if (!has_future || version < "1.8.0") {
[17:39:21.147]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.147]                             "", base::R.version$version.string), 
[17:39:21.147]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.147]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.147]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.147]                               "release", "version")], collapse = " "), 
[17:39:21.147]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.147]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.147]                             info)
[17:39:21.147]                           info <- base::paste(info, collapse = "; ")
[17:39:21.147]                           if (!has_future) {
[17:39:21.147]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.147]                               info)
[17:39:21.147]                           }
[17:39:21.147]                           else {
[17:39:21.147]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.147]                               info, version)
[17:39:21.147]                           }
[17:39:21.147]                           base::stop(msg)
[17:39:21.147]                         }
[17:39:21.147]                       })
[17:39:21.147]                     }
[17:39:21.147]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.147]                     base::options(mc.cores = 1L)
[17:39:21.147]                   }
[17:39:21.147]                   options(future.plan = NULL)
[17:39:21.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.147]                 }
[17:39:21.147]                 ...future.workdir <- getwd()
[17:39:21.147]             }
[17:39:21.147]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.147]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.147]         }
[17:39:21.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.147]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.147]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.147]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.147]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.147]             base::names(...future.oldOptions))
[17:39:21.147]     }
[17:39:21.147]     if (FALSE) {
[17:39:21.147]     }
[17:39:21.147]     else {
[17:39:21.147]         if (TRUE) {
[17:39:21.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.147]                 open = "w")
[17:39:21.147]         }
[17:39:21.147]         else {
[17:39:21.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.147]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.147]         }
[17:39:21.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.147]             base::sink(type = "output", split = FALSE)
[17:39:21.147]             base::close(...future.stdout)
[17:39:21.147]         }, add = TRUE)
[17:39:21.147]     }
[17:39:21.147]     ...future.frame <- base::sys.nframe()
[17:39:21.147]     ...future.conditions <- base::list()
[17:39:21.147]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.147]     if (FALSE) {
[17:39:21.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.147]     }
[17:39:21.147]     ...future.result <- base::tryCatch({
[17:39:21.147]         base::withCallingHandlers({
[17:39:21.147]             ...future.value <- base::withVisible(base::local({
[17:39:21.147]                 withCallingHandlers({
[17:39:21.147]                   {
[17:39:21.147]                     do.call(function(...) {
[17:39:21.147]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.147]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.147]                         ...future.globals.maxSize)) {
[17:39:21.147]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.147]                         on.exit(options(oopts), add = TRUE)
[17:39:21.147]                       }
[17:39:21.147]                       {
[17:39:21.147]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.147]                           FUN = function(jj) {
[17:39:21.147]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.147]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.147]                           })
[17:39:21.147]                       }
[17:39:21.147]                     }, args = future.call.arguments)
[17:39:21.147]                   }
[17:39:21.147]                 }, immediateCondition = function(cond) {
[17:39:21.147]                   save_rds <- function (object, pathname, ...) 
[17:39:21.147]                   {
[17:39:21.147]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.147]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.147]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.147]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.147]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.147]                         fi_tmp[["mtime"]])
[17:39:21.147]                     }
[17:39:21.147]                     tryCatch({
[17:39:21.147]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.147]                     }, error = function(ex) {
[17:39:21.147]                       msg <- conditionMessage(ex)
[17:39:21.147]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.147]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.147]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.147]                         fi_tmp[["mtime"]], msg)
[17:39:21.147]                       ex$message <- msg
[17:39:21.147]                       stop(ex)
[17:39:21.147]                     })
[17:39:21.147]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.147]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.147]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.147]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.147]                       fi <- file.info(pathname)
[17:39:21.147]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.147]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.147]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.147]                         fi[["size"]], fi[["mtime"]])
[17:39:21.147]                       stop(msg)
[17:39:21.147]                     }
[17:39:21.147]                     invisible(pathname)
[17:39:21.147]                   }
[17:39:21.147]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.147]                     rootPath = tempdir()) 
[17:39:21.147]                   {
[17:39:21.147]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.147]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.147]                       tmpdir = path, fileext = ".rds")
[17:39:21.147]                     save_rds(obj, file)
[17:39:21.147]                   }
[17:39:21.147]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.147]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.147]                   {
[17:39:21.147]                     inherits <- base::inherits
[17:39:21.147]                     invokeRestart <- base::invokeRestart
[17:39:21.147]                     is.null <- base::is.null
[17:39:21.147]                     muffled <- FALSE
[17:39:21.147]                     if (inherits(cond, "message")) {
[17:39:21.147]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.147]                       if (muffled) 
[17:39:21.147]                         invokeRestart("muffleMessage")
[17:39:21.147]                     }
[17:39:21.147]                     else if (inherits(cond, "warning")) {
[17:39:21.147]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.147]                       if (muffled) 
[17:39:21.147]                         invokeRestart("muffleWarning")
[17:39:21.147]                     }
[17:39:21.147]                     else if (inherits(cond, "condition")) {
[17:39:21.147]                       if (!is.null(pattern)) {
[17:39:21.147]                         computeRestarts <- base::computeRestarts
[17:39:21.147]                         grepl <- base::grepl
[17:39:21.147]                         restarts <- computeRestarts(cond)
[17:39:21.147]                         for (restart in restarts) {
[17:39:21.147]                           name <- restart$name
[17:39:21.147]                           if (is.null(name)) 
[17:39:21.147]                             next
[17:39:21.147]                           if (!grepl(pattern, name)) 
[17:39:21.147]                             next
[17:39:21.147]                           invokeRestart(restart)
[17:39:21.147]                           muffled <- TRUE
[17:39:21.147]                           break
[17:39:21.147]                         }
[17:39:21.147]                       }
[17:39:21.147]                     }
[17:39:21.147]                     invisible(muffled)
[17:39:21.147]                   }
[17:39:21.147]                   muffleCondition(cond)
[17:39:21.147]                 })
[17:39:21.147]             }))
[17:39:21.147]             future::FutureResult(value = ...future.value$value, 
[17:39:21.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.147]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.147]                     ...future.globalenv.names))
[17:39:21.147]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.147]         }, condition = base::local({
[17:39:21.147]             c <- base::c
[17:39:21.147]             inherits <- base::inherits
[17:39:21.147]             invokeRestart <- base::invokeRestart
[17:39:21.147]             length <- base::length
[17:39:21.147]             list <- base::list
[17:39:21.147]             seq.int <- base::seq.int
[17:39:21.147]             signalCondition <- base::signalCondition
[17:39:21.147]             sys.calls <- base::sys.calls
[17:39:21.147]             `[[` <- base::`[[`
[17:39:21.147]             `+` <- base::`+`
[17:39:21.147]             `<<-` <- base::`<<-`
[17:39:21.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.147]                   3L)]
[17:39:21.147]             }
[17:39:21.147]             function(cond) {
[17:39:21.147]                 is_error <- inherits(cond, "error")
[17:39:21.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.147]                   NULL)
[17:39:21.147]                 if (is_error) {
[17:39:21.147]                   sessionInformation <- function() {
[17:39:21.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.147]                       search = base::search(), system = base::Sys.info())
[17:39:21.147]                   }
[17:39:21.147]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.147]                     cond$call), session = sessionInformation(), 
[17:39:21.147]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.147]                   signalCondition(cond)
[17:39:21.147]                 }
[17:39:21.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.147]                 "immediateCondition"))) {
[17:39:21.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.147]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.147]                   if (TRUE && !signal) {
[17:39:21.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.147]                     {
[17:39:21.147]                       inherits <- base::inherits
[17:39:21.147]                       invokeRestart <- base::invokeRestart
[17:39:21.147]                       is.null <- base::is.null
[17:39:21.147]                       muffled <- FALSE
[17:39:21.147]                       if (inherits(cond, "message")) {
[17:39:21.147]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.147]                         if (muffled) 
[17:39:21.147]                           invokeRestart("muffleMessage")
[17:39:21.147]                       }
[17:39:21.147]                       else if (inherits(cond, "warning")) {
[17:39:21.147]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.147]                         if (muffled) 
[17:39:21.147]                           invokeRestart("muffleWarning")
[17:39:21.147]                       }
[17:39:21.147]                       else if (inherits(cond, "condition")) {
[17:39:21.147]                         if (!is.null(pattern)) {
[17:39:21.147]                           computeRestarts <- base::computeRestarts
[17:39:21.147]                           grepl <- base::grepl
[17:39:21.147]                           restarts <- computeRestarts(cond)
[17:39:21.147]                           for (restart in restarts) {
[17:39:21.147]                             name <- restart$name
[17:39:21.147]                             if (is.null(name)) 
[17:39:21.147]                               next
[17:39:21.147]                             if (!grepl(pattern, name)) 
[17:39:21.147]                               next
[17:39:21.147]                             invokeRestart(restart)
[17:39:21.147]                             muffled <- TRUE
[17:39:21.147]                             break
[17:39:21.147]                           }
[17:39:21.147]                         }
[17:39:21.147]                       }
[17:39:21.147]                       invisible(muffled)
[17:39:21.147]                     }
[17:39:21.147]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.147]                   }
[17:39:21.147]                 }
[17:39:21.147]                 else {
[17:39:21.147]                   if (TRUE) {
[17:39:21.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.147]                     {
[17:39:21.147]                       inherits <- base::inherits
[17:39:21.147]                       invokeRestart <- base::invokeRestart
[17:39:21.147]                       is.null <- base::is.null
[17:39:21.147]                       muffled <- FALSE
[17:39:21.147]                       if (inherits(cond, "message")) {
[17:39:21.147]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.147]                         if (muffled) 
[17:39:21.147]                           invokeRestart("muffleMessage")
[17:39:21.147]                       }
[17:39:21.147]                       else if (inherits(cond, "warning")) {
[17:39:21.147]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.147]                         if (muffled) 
[17:39:21.147]                           invokeRestart("muffleWarning")
[17:39:21.147]                       }
[17:39:21.147]                       else if (inherits(cond, "condition")) {
[17:39:21.147]                         if (!is.null(pattern)) {
[17:39:21.147]                           computeRestarts <- base::computeRestarts
[17:39:21.147]                           grepl <- base::grepl
[17:39:21.147]                           restarts <- computeRestarts(cond)
[17:39:21.147]                           for (restart in restarts) {
[17:39:21.147]                             name <- restart$name
[17:39:21.147]                             if (is.null(name)) 
[17:39:21.147]                               next
[17:39:21.147]                             if (!grepl(pattern, name)) 
[17:39:21.147]                               next
[17:39:21.147]                             invokeRestart(restart)
[17:39:21.147]                             muffled <- TRUE
[17:39:21.147]                             break
[17:39:21.147]                           }
[17:39:21.147]                         }
[17:39:21.147]                       }
[17:39:21.147]                       invisible(muffled)
[17:39:21.147]                     }
[17:39:21.147]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.147]                   }
[17:39:21.147]                 }
[17:39:21.147]             }
[17:39:21.147]         }))
[17:39:21.147]     }, error = function(ex) {
[17:39:21.147]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.147]                 ...future.rng), started = ...future.startTime, 
[17:39:21.147]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.147]             version = "1.8"), class = "FutureResult")
[17:39:21.147]     }, finally = {
[17:39:21.147]         if (!identical(...future.workdir, getwd())) 
[17:39:21.147]             setwd(...future.workdir)
[17:39:21.147]         {
[17:39:21.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.147]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.147]             }
[17:39:21.147]             base::options(...future.oldOptions)
[17:39:21.147]             if (.Platform$OS.type == "windows") {
[17:39:21.147]                 old_names <- names(...future.oldEnvVars)
[17:39:21.147]                 envs <- base::Sys.getenv()
[17:39:21.147]                 names <- names(envs)
[17:39:21.147]                 common <- intersect(names, old_names)
[17:39:21.147]                 added <- setdiff(names, old_names)
[17:39:21.147]                 removed <- setdiff(old_names, names)
[17:39:21.147]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.147]                   envs[common]]
[17:39:21.147]                 NAMES <- toupper(changed)
[17:39:21.147]                 args <- list()
[17:39:21.147]                 for (kk in seq_along(NAMES)) {
[17:39:21.147]                   name <- changed[[kk]]
[17:39:21.147]                   NAME <- NAMES[[kk]]
[17:39:21.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.147]                     next
[17:39:21.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.147]                 }
[17:39:21.147]                 NAMES <- toupper(added)
[17:39:21.147]                 for (kk in seq_along(NAMES)) {
[17:39:21.147]                   name <- added[[kk]]
[17:39:21.147]                   NAME <- NAMES[[kk]]
[17:39:21.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.147]                     next
[17:39:21.147]                   args[[name]] <- ""
[17:39:21.147]                 }
[17:39:21.147]                 NAMES <- toupper(removed)
[17:39:21.147]                 for (kk in seq_along(NAMES)) {
[17:39:21.147]                   name <- removed[[kk]]
[17:39:21.147]                   NAME <- NAMES[[kk]]
[17:39:21.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.147]                     next
[17:39:21.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.147]                 }
[17:39:21.147]                 if (length(args) > 0) 
[17:39:21.147]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.147]             }
[17:39:21.147]             else {
[17:39:21.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.147]             }
[17:39:21.147]             {
[17:39:21.147]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.147]                   0L) {
[17:39:21.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.147]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.147]                   base::options(opts)
[17:39:21.147]                 }
[17:39:21.147]                 {
[17:39:21.147]                   {
[17:39:21.147]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.147]                     NULL
[17:39:21.147]                   }
[17:39:21.147]                   options(future.plan = NULL)
[17:39:21.147]                   if (is.na(NA_character_)) 
[17:39:21.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.147]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.147]                     envir = parent.frame()) 
[17:39:21.147]                   {
[17:39:21.147]                     default_workers <- missing(workers)
[17:39:21.147]                     if (is.function(workers)) 
[17:39:21.147]                       workers <- workers()
[17:39:21.147]                     workers <- structure(as.integer(workers), 
[17:39:21.147]                       class = class(workers))
[17:39:21.147]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.147]                       1L)
[17:39:21.147]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.147]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.147]                       if (default_workers) 
[17:39:21.147]                         supportsMulticore(warn = TRUE)
[17:39:21.147]                       return(sequential(..., envir = envir))
[17:39:21.147]                     }
[17:39:21.147]                     oopts <- options(mc.cores = workers)
[17:39:21.147]                     on.exit(options(oopts))
[17:39:21.147]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.147]                       envir = envir)
[17:39:21.147]                     if (!future$lazy) 
[17:39:21.147]                       future <- run(future)
[17:39:21.147]                     invisible(future)
[17:39:21.147]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.147]                 }
[17:39:21.147]             }
[17:39:21.147]         }
[17:39:21.147]     })
[17:39:21.147]     if (TRUE) {
[17:39:21.147]         base::sink(type = "output", split = FALSE)
[17:39:21.147]         if (TRUE) {
[17:39:21.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.147]         }
[17:39:21.147]         else {
[17:39:21.147]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.147]         }
[17:39:21.147]         base::close(...future.stdout)
[17:39:21.147]         ...future.stdout <- NULL
[17:39:21.147]     }
[17:39:21.147]     ...future.result$conditions <- ...future.conditions
[17:39:21.147]     ...future.result$finished <- base::Sys.time()
[17:39:21.147]     ...future.result
[17:39:21.147] }
[17:39:21.149] assign_globals() ...
[17:39:21.150] List of 5
[17:39:21.150]  $ future.call.arguments    : list()
[17:39:21.150]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.150]  $ ...future.FUN            :function (x)  
[17:39:21.150]  $ ...future.elements_ii    :List of 3
[17:39:21.150]   ..$ : int [1:4] 1 7 13 19
[17:39:21.150]   ..$ : int [1:4] 2 8 14 20
[17:39:21.150]   ..$ : int [1:4] 3 9 15 21
[17:39:21.150]  $ ...future.seeds_ii       : NULL
[17:39:21.150]  $ ...future.globals.maxSize: num Inf
[17:39:21.150]  - attr(*, "resolved")= logi FALSE
[17:39:21.150]  - attr(*, "total_size")= num NA
[17:39:21.150]  - attr(*, "where")=List of 5
[17:39:21.150]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.150]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.150]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.150]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.150]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.150]  - attr(*, "already-done")= logi TRUE
[17:39:21.157] - copied ‘future.call.arguments’ to environment
[17:39:21.157] - reassign environment for ‘...future.FUN’
[17:39:21.157] - copied ‘...future.FUN’ to environment
[17:39:21.157] - copied ‘...future.elements_ii’ to environment
[17:39:21.158] - copied ‘...future.seeds_ii’ to environment
[17:39:21.158] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.158] assign_globals() ... done
[17:39:21.158] requestCore(): workers = 2
[17:39:21.160] MulticoreFuture started
[17:39:21.161] - Launch lazy future ... done
[17:39:21.161] run() for ‘MulticoreFuture’ ... done
[17:39:21.162] plan(): Setting new future strategy stack:
[17:39:21.162] Created future:
[17:39:21.162] List of future strategies:
[17:39:21.162] 1. sequential:
[17:39:21.162]    - args: function (..., envir = parent.frame())
[17:39:21.162]    - tweaked: FALSE
[17:39:21.162]    - call: NULL
[17:39:21.163] plan(): nbrOfWorkers() = 1
[17:39:21.166] plan(): Setting new future strategy stack:
[17:39:21.166] List of future strategies:
[17:39:21.166] 1. multicore:
[17:39:21.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.166]    - tweaked: FALSE
[17:39:21.166]    - call: plan(strategy)
[17:39:21.172] plan(): nbrOfWorkers() = 2
[17:39:21.162] MulticoreFuture:
[17:39:21.162] Label: ‘future_apply-1’
[17:39:21.162] Expression:
[17:39:21.162] {
[17:39:21.162]     do.call(function(...) {
[17:39:21.162]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.162]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.162]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.162]             on.exit(options(oopts), add = TRUE)
[17:39:21.162]         }
[17:39:21.162]         {
[17:39:21.162]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.162]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.162]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.162]             })
[17:39:21.162]         }
[17:39:21.162]     }, args = future.call.arguments)
[17:39:21.162] }
[17:39:21.162] Lazy evaluation: FALSE
[17:39:21.162] Asynchronous evaluation: TRUE
[17:39:21.162] Local evaluation: TRUE
[17:39:21.162] Environment: R_GlobalEnv
[17:39:21.162] Capture standard output: TRUE
[17:39:21.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.162] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:21.162] Packages: <none>
[17:39:21.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.162] Resolved: TRUE
[17:39:21.162] Value: <not collected>
[17:39:21.162] Conditions captured: <none>
[17:39:21.162] Early signaling: FALSE
[17:39:21.162] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.162] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.173] Chunk #1 of 2 ... DONE
[17:39:21.174] Chunk #2 of 2 ...
[17:39:21.174]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[17:39:21.174]  - seeds: <none>
[17:39:21.174] getGlobalsAndPackages() ...
[17:39:21.175] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.175] Resolving globals: FALSE
[17:39:21.175] Tweak future expression to call with '...' arguments ...
[17:39:21.175] {
[17:39:21.175]     do.call(function(...) {
[17:39:21.175]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.175]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.175]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.175]             on.exit(options(oopts), add = TRUE)
[17:39:21.175]         }
[17:39:21.175]         {
[17:39:21.175]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.175]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.175]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.175]             })
[17:39:21.175]         }
[17:39:21.175]     }, args = future.call.arguments)
[17:39:21.175] }
[17:39:21.176] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.176] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.177] 
[17:39:21.177] getGlobalsAndPackages() ... DONE
[17:39:21.177] run() for ‘Future’ ...
[17:39:21.178] - state: ‘created’
[17:39:21.178] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.182] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.183]   - Field: ‘label’
[17:39:21.183]   - Field: ‘local’
[17:39:21.183]   - Field: ‘owner’
[17:39:21.183]   - Field: ‘envir’
[17:39:21.184]   - Field: ‘workers’
[17:39:21.184]   - Field: ‘packages’
[17:39:21.184]   - Field: ‘gc’
[17:39:21.184]   - Field: ‘job’
[17:39:21.184]   - Field: ‘conditions’
[17:39:21.184]   - Field: ‘expr’
[17:39:21.184]   - Field: ‘uuid’
[17:39:21.185]   - Field: ‘seed’
[17:39:21.185]   - Field: ‘version’
[17:39:21.185]   - Field: ‘result’
[17:39:21.185]   - Field: ‘asynchronous’
[17:39:21.185]   - Field: ‘calls’
[17:39:21.185]   - Field: ‘globals’
[17:39:21.185]   - Field: ‘stdout’
[17:39:21.186]   - Field: ‘earlySignal’
[17:39:21.186]   - Field: ‘lazy’
[17:39:21.186]   - Field: ‘state’
[17:39:21.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.186] - Launch lazy future ...
[17:39:21.187] Packages needed by the future expression (n = 0): <none>
[17:39:21.187] Packages needed by future strategies (n = 0): <none>
[17:39:21.187] {
[17:39:21.187]     {
[17:39:21.187]         {
[17:39:21.187]             ...future.startTime <- base::Sys.time()
[17:39:21.187]             {
[17:39:21.187]                 {
[17:39:21.187]                   {
[17:39:21.187]                     {
[17:39:21.187]                       base::local({
[17:39:21.187]                         has_future <- base::requireNamespace("future", 
[17:39:21.187]                           quietly = TRUE)
[17:39:21.187]                         if (has_future) {
[17:39:21.187]                           ns <- base::getNamespace("future")
[17:39:21.187]                           version <- ns[[".package"]][["version"]]
[17:39:21.187]                           if (is.null(version)) 
[17:39:21.187]                             version <- utils::packageVersion("future")
[17:39:21.187]                         }
[17:39:21.187]                         else {
[17:39:21.187]                           version <- NULL
[17:39:21.187]                         }
[17:39:21.187]                         if (!has_future || version < "1.8.0") {
[17:39:21.187]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.187]                             "", base::R.version$version.string), 
[17:39:21.187]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.187]                               "release", "version")], collapse = " "), 
[17:39:21.187]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.187]                             info)
[17:39:21.187]                           info <- base::paste(info, collapse = "; ")
[17:39:21.187]                           if (!has_future) {
[17:39:21.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.187]                               info)
[17:39:21.187]                           }
[17:39:21.187]                           else {
[17:39:21.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.187]                               info, version)
[17:39:21.187]                           }
[17:39:21.187]                           base::stop(msg)
[17:39:21.187]                         }
[17:39:21.187]                       })
[17:39:21.187]                     }
[17:39:21.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.187]                     base::options(mc.cores = 1L)
[17:39:21.187]                   }
[17:39:21.187]                   options(future.plan = NULL)
[17:39:21.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.187]                 }
[17:39:21.187]                 ...future.workdir <- getwd()
[17:39:21.187]             }
[17:39:21.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.187]         }
[17:39:21.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.187]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.187]             base::names(...future.oldOptions))
[17:39:21.187]     }
[17:39:21.187]     if (FALSE) {
[17:39:21.187]     }
[17:39:21.187]     else {
[17:39:21.187]         if (TRUE) {
[17:39:21.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.187]                 open = "w")
[17:39:21.187]         }
[17:39:21.187]         else {
[17:39:21.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.187]         }
[17:39:21.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.187]             base::sink(type = "output", split = FALSE)
[17:39:21.187]             base::close(...future.stdout)
[17:39:21.187]         }, add = TRUE)
[17:39:21.187]     }
[17:39:21.187]     ...future.frame <- base::sys.nframe()
[17:39:21.187]     ...future.conditions <- base::list()
[17:39:21.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.187]     if (FALSE) {
[17:39:21.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.187]     }
[17:39:21.187]     ...future.result <- base::tryCatch({
[17:39:21.187]         base::withCallingHandlers({
[17:39:21.187]             ...future.value <- base::withVisible(base::local({
[17:39:21.187]                 withCallingHandlers({
[17:39:21.187]                   {
[17:39:21.187]                     do.call(function(...) {
[17:39:21.187]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.187]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.187]                         ...future.globals.maxSize)) {
[17:39:21.187]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.187]                         on.exit(options(oopts), add = TRUE)
[17:39:21.187]                       }
[17:39:21.187]                       {
[17:39:21.187]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.187]                           FUN = function(jj) {
[17:39:21.187]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.187]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.187]                           })
[17:39:21.187]                       }
[17:39:21.187]                     }, args = future.call.arguments)
[17:39:21.187]                   }
[17:39:21.187]                 }, immediateCondition = function(cond) {
[17:39:21.187]                   save_rds <- function (object, pathname, ...) 
[17:39:21.187]                   {
[17:39:21.187]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.187]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.187]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.187]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.187]                         fi_tmp[["mtime"]])
[17:39:21.187]                     }
[17:39:21.187]                     tryCatch({
[17:39:21.187]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.187]                     }, error = function(ex) {
[17:39:21.187]                       msg <- conditionMessage(ex)
[17:39:21.187]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.187]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.187]                         fi_tmp[["mtime"]], msg)
[17:39:21.187]                       ex$message <- msg
[17:39:21.187]                       stop(ex)
[17:39:21.187]                     })
[17:39:21.187]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.187]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.187]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.187]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.187]                       fi <- file.info(pathname)
[17:39:21.187]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.187]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.187]                         fi[["size"]], fi[["mtime"]])
[17:39:21.187]                       stop(msg)
[17:39:21.187]                     }
[17:39:21.187]                     invisible(pathname)
[17:39:21.187]                   }
[17:39:21.187]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.187]                     rootPath = tempdir()) 
[17:39:21.187]                   {
[17:39:21.187]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.187]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.187]                       tmpdir = path, fileext = ".rds")
[17:39:21.187]                     save_rds(obj, file)
[17:39:21.187]                   }
[17:39:21.187]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.187]                   {
[17:39:21.187]                     inherits <- base::inherits
[17:39:21.187]                     invokeRestart <- base::invokeRestart
[17:39:21.187]                     is.null <- base::is.null
[17:39:21.187]                     muffled <- FALSE
[17:39:21.187]                     if (inherits(cond, "message")) {
[17:39:21.187]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.187]                       if (muffled) 
[17:39:21.187]                         invokeRestart("muffleMessage")
[17:39:21.187]                     }
[17:39:21.187]                     else if (inherits(cond, "warning")) {
[17:39:21.187]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.187]                       if (muffled) 
[17:39:21.187]                         invokeRestart("muffleWarning")
[17:39:21.187]                     }
[17:39:21.187]                     else if (inherits(cond, "condition")) {
[17:39:21.187]                       if (!is.null(pattern)) {
[17:39:21.187]                         computeRestarts <- base::computeRestarts
[17:39:21.187]                         grepl <- base::grepl
[17:39:21.187]                         restarts <- computeRestarts(cond)
[17:39:21.187]                         for (restart in restarts) {
[17:39:21.187]                           name <- restart$name
[17:39:21.187]                           if (is.null(name)) 
[17:39:21.187]                             next
[17:39:21.187]                           if (!grepl(pattern, name)) 
[17:39:21.187]                             next
[17:39:21.187]                           invokeRestart(restart)
[17:39:21.187]                           muffled <- TRUE
[17:39:21.187]                           break
[17:39:21.187]                         }
[17:39:21.187]                       }
[17:39:21.187]                     }
[17:39:21.187]                     invisible(muffled)
[17:39:21.187]                   }
[17:39:21.187]                   muffleCondition(cond)
[17:39:21.187]                 })
[17:39:21.187]             }))
[17:39:21.187]             future::FutureResult(value = ...future.value$value, 
[17:39:21.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.187]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.187]                     ...future.globalenv.names))
[17:39:21.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.187]         }, condition = base::local({
[17:39:21.187]             c <- base::c
[17:39:21.187]             inherits <- base::inherits
[17:39:21.187]             invokeRestart <- base::invokeRestart
[17:39:21.187]             length <- base::length
[17:39:21.187]             list <- base::list
[17:39:21.187]             seq.int <- base::seq.int
[17:39:21.187]             signalCondition <- base::signalCondition
[17:39:21.187]             sys.calls <- base::sys.calls
[17:39:21.187]             `[[` <- base::`[[`
[17:39:21.187]             `+` <- base::`+`
[17:39:21.187]             `<<-` <- base::`<<-`
[17:39:21.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.187]                   3L)]
[17:39:21.187]             }
[17:39:21.187]             function(cond) {
[17:39:21.187]                 is_error <- inherits(cond, "error")
[17:39:21.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.187]                   NULL)
[17:39:21.187]                 if (is_error) {
[17:39:21.187]                   sessionInformation <- function() {
[17:39:21.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.187]                       search = base::search(), system = base::Sys.info())
[17:39:21.187]                   }
[17:39:21.187]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.187]                     cond$call), session = sessionInformation(), 
[17:39:21.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.187]                   signalCondition(cond)
[17:39:21.187]                 }
[17:39:21.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.187]                 "immediateCondition"))) {
[17:39:21.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.187]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.187]                   if (TRUE && !signal) {
[17:39:21.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.187]                     {
[17:39:21.187]                       inherits <- base::inherits
[17:39:21.187]                       invokeRestart <- base::invokeRestart
[17:39:21.187]                       is.null <- base::is.null
[17:39:21.187]                       muffled <- FALSE
[17:39:21.187]                       if (inherits(cond, "message")) {
[17:39:21.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.187]                         if (muffled) 
[17:39:21.187]                           invokeRestart("muffleMessage")
[17:39:21.187]                       }
[17:39:21.187]                       else if (inherits(cond, "warning")) {
[17:39:21.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.187]                         if (muffled) 
[17:39:21.187]                           invokeRestart("muffleWarning")
[17:39:21.187]                       }
[17:39:21.187]                       else if (inherits(cond, "condition")) {
[17:39:21.187]                         if (!is.null(pattern)) {
[17:39:21.187]                           computeRestarts <- base::computeRestarts
[17:39:21.187]                           grepl <- base::grepl
[17:39:21.187]                           restarts <- computeRestarts(cond)
[17:39:21.187]                           for (restart in restarts) {
[17:39:21.187]                             name <- restart$name
[17:39:21.187]                             if (is.null(name)) 
[17:39:21.187]                               next
[17:39:21.187]                             if (!grepl(pattern, name)) 
[17:39:21.187]                               next
[17:39:21.187]                             invokeRestart(restart)
[17:39:21.187]                             muffled <- TRUE
[17:39:21.187]                             break
[17:39:21.187]                           }
[17:39:21.187]                         }
[17:39:21.187]                       }
[17:39:21.187]                       invisible(muffled)
[17:39:21.187]                     }
[17:39:21.187]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.187]                   }
[17:39:21.187]                 }
[17:39:21.187]                 else {
[17:39:21.187]                   if (TRUE) {
[17:39:21.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.187]                     {
[17:39:21.187]                       inherits <- base::inherits
[17:39:21.187]                       invokeRestart <- base::invokeRestart
[17:39:21.187]                       is.null <- base::is.null
[17:39:21.187]                       muffled <- FALSE
[17:39:21.187]                       if (inherits(cond, "message")) {
[17:39:21.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.187]                         if (muffled) 
[17:39:21.187]                           invokeRestart("muffleMessage")
[17:39:21.187]                       }
[17:39:21.187]                       else if (inherits(cond, "warning")) {
[17:39:21.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.187]                         if (muffled) 
[17:39:21.187]                           invokeRestart("muffleWarning")
[17:39:21.187]                       }
[17:39:21.187]                       else if (inherits(cond, "condition")) {
[17:39:21.187]                         if (!is.null(pattern)) {
[17:39:21.187]                           computeRestarts <- base::computeRestarts
[17:39:21.187]                           grepl <- base::grepl
[17:39:21.187]                           restarts <- computeRestarts(cond)
[17:39:21.187]                           for (restart in restarts) {
[17:39:21.187]                             name <- restart$name
[17:39:21.187]                             if (is.null(name)) 
[17:39:21.187]                               next
[17:39:21.187]                             if (!grepl(pattern, name)) 
[17:39:21.187]                               next
[17:39:21.187]                             invokeRestart(restart)
[17:39:21.187]                             muffled <- TRUE
[17:39:21.187]                             break
[17:39:21.187]                           }
[17:39:21.187]                         }
[17:39:21.187]                       }
[17:39:21.187]                       invisible(muffled)
[17:39:21.187]                     }
[17:39:21.187]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.187]                   }
[17:39:21.187]                 }
[17:39:21.187]             }
[17:39:21.187]         }))
[17:39:21.187]     }, error = function(ex) {
[17:39:21.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.187]                 ...future.rng), started = ...future.startTime, 
[17:39:21.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.187]             version = "1.8"), class = "FutureResult")
[17:39:21.187]     }, finally = {
[17:39:21.187]         if (!identical(...future.workdir, getwd())) 
[17:39:21.187]             setwd(...future.workdir)
[17:39:21.187]         {
[17:39:21.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.187]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.187]             }
[17:39:21.187]             base::options(...future.oldOptions)
[17:39:21.187]             if (.Platform$OS.type == "windows") {
[17:39:21.187]                 old_names <- names(...future.oldEnvVars)
[17:39:21.187]                 envs <- base::Sys.getenv()
[17:39:21.187]                 names <- names(envs)
[17:39:21.187]                 common <- intersect(names, old_names)
[17:39:21.187]                 added <- setdiff(names, old_names)
[17:39:21.187]                 removed <- setdiff(old_names, names)
[17:39:21.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.187]                   envs[common]]
[17:39:21.187]                 NAMES <- toupper(changed)
[17:39:21.187]                 args <- list()
[17:39:21.187]                 for (kk in seq_along(NAMES)) {
[17:39:21.187]                   name <- changed[[kk]]
[17:39:21.187]                   NAME <- NAMES[[kk]]
[17:39:21.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.187]                     next
[17:39:21.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.187]                 }
[17:39:21.187]                 NAMES <- toupper(added)
[17:39:21.187]                 for (kk in seq_along(NAMES)) {
[17:39:21.187]                   name <- added[[kk]]
[17:39:21.187]                   NAME <- NAMES[[kk]]
[17:39:21.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.187]                     next
[17:39:21.187]                   args[[name]] <- ""
[17:39:21.187]                 }
[17:39:21.187]                 NAMES <- toupper(removed)
[17:39:21.187]                 for (kk in seq_along(NAMES)) {
[17:39:21.187]                   name <- removed[[kk]]
[17:39:21.187]                   NAME <- NAMES[[kk]]
[17:39:21.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.187]                     next
[17:39:21.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.187]                 }
[17:39:21.187]                 if (length(args) > 0) 
[17:39:21.187]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.187]             }
[17:39:21.187]             else {
[17:39:21.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.187]             }
[17:39:21.187]             {
[17:39:21.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.187]                   0L) {
[17:39:21.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.187]                   base::options(opts)
[17:39:21.187]                 }
[17:39:21.187]                 {
[17:39:21.187]                   {
[17:39:21.187]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.187]                     NULL
[17:39:21.187]                   }
[17:39:21.187]                   options(future.plan = NULL)
[17:39:21.187]                   if (is.na(NA_character_)) 
[17:39:21.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.187]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.187]                     envir = parent.frame()) 
[17:39:21.187]                   {
[17:39:21.187]                     default_workers <- missing(workers)
[17:39:21.187]                     if (is.function(workers)) 
[17:39:21.187]                       workers <- workers()
[17:39:21.187]                     workers <- structure(as.integer(workers), 
[17:39:21.187]                       class = class(workers))
[17:39:21.187]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.187]                       1L)
[17:39:21.187]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.187]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.187]                       if (default_workers) 
[17:39:21.187]                         supportsMulticore(warn = TRUE)
[17:39:21.187]                       return(sequential(..., envir = envir))
[17:39:21.187]                     }
[17:39:21.187]                     oopts <- options(mc.cores = workers)
[17:39:21.187]                     on.exit(options(oopts))
[17:39:21.187]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.187]                       envir = envir)
[17:39:21.187]                     if (!future$lazy) 
[17:39:21.187]                       future <- run(future)
[17:39:21.187]                     invisible(future)
[17:39:21.187]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.187]                 }
[17:39:21.187]             }
[17:39:21.187]         }
[17:39:21.187]     })
[17:39:21.187]     if (TRUE) {
[17:39:21.187]         base::sink(type = "output", split = FALSE)
[17:39:21.187]         if (TRUE) {
[17:39:21.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.187]         }
[17:39:21.187]         else {
[17:39:21.187]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.187]         }
[17:39:21.187]         base::close(...future.stdout)
[17:39:21.187]         ...future.stdout <- NULL
[17:39:21.187]     }
[17:39:21.187]     ...future.result$conditions <- ...future.conditions
[17:39:21.187]     ...future.result$finished <- base::Sys.time()
[17:39:21.187]     ...future.result
[17:39:21.187] }
[17:39:21.191] assign_globals() ...
[17:39:21.191] List of 5
[17:39:21.191]  $ future.call.arguments    : list()
[17:39:21.191]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.191]  $ ...future.FUN            :function (x)  
[17:39:21.191]  $ ...future.elements_ii    :List of 3
[17:39:21.191]   ..$ : int [1:4] 4 10 16 22
[17:39:21.191]   ..$ : int [1:4] 5 11 17 23
[17:39:21.191]   ..$ : int [1:4] 6 12 18 24
[17:39:21.191]  $ ...future.seeds_ii       : NULL
[17:39:21.191]  $ ...future.globals.maxSize: num Inf
[17:39:21.191]  - attr(*, "resolved")= logi FALSE
[17:39:21.191]  - attr(*, "total_size")= num NA
[17:39:21.191]  - attr(*, "where")=List of 5
[17:39:21.191]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.191]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.191]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.191]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.191]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.191]  - attr(*, "already-done")= logi TRUE
[17:39:21.199] - copied ‘future.call.arguments’ to environment
[17:39:21.199] - reassign environment for ‘...future.FUN’
[17:39:21.200] - copied ‘...future.FUN’ to environment
[17:39:21.200] - copied ‘...future.elements_ii’ to environment
[17:39:21.200] - copied ‘...future.seeds_ii’ to environment
[17:39:21.200] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.200] assign_globals() ... done
[17:39:21.200] requestCore(): workers = 2
[17:39:21.203] MulticoreFuture started
[17:39:21.203] - Launch lazy future ... done
[17:39:21.203] run() for ‘MulticoreFuture’ ... done
[17:39:21.203] Created future:
[17:39:21.204] plan(): Setting new future strategy stack:
[17:39:21.204] List of future strategies:
[17:39:21.204] 1. sequential:
[17:39:21.204]    - args: function (..., envir = parent.frame())
[17:39:21.204]    - tweaked: FALSE
[17:39:21.204]    - call: NULL
[17:39:21.205] plan(): nbrOfWorkers() = 1
[17:39:21.210] plan(): Setting new future strategy stack:
[17:39:21.210] List of future strategies:
[17:39:21.210] 1. multicore:
[17:39:21.210]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.210]    - tweaked: FALSE
[17:39:21.210]    - call: plan(strategy)
[17:39:21.217] plan(): nbrOfWorkers() = 2
[17:39:21.204] MulticoreFuture:
[17:39:21.204] Label: ‘future_apply-2’
[17:39:21.204] Expression:
[17:39:21.204] {
[17:39:21.204]     do.call(function(...) {
[17:39:21.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.204]             on.exit(options(oopts), add = TRUE)
[17:39:21.204]         }
[17:39:21.204]         {
[17:39:21.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.204]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.204]             })
[17:39:21.204]         }
[17:39:21.204]     }, args = future.call.arguments)
[17:39:21.204] }
[17:39:21.204] Lazy evaluation: FALSE
[17:39:21.204] Asynchronous evaluation: TRUE
[17:39:21.204] Local evaluation: TRUE
[17:39:21.204] Environment: R_GlobalEnv
[17:39:21.204] Capture standard output: TRUE
[17:39:21.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.204] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:21.204] Packages: <none>
[17:39:21.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.204] Resolved: TRUE
[17:39:21.204] Value: <not collected>
[17:39:21.204] Conditions captured: <none>
[17:39:21.204] Early signaling: FALSE
[17:39:21.204] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.204] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.219] Chunk #2 of 2 ... DONE
[17:39:21.219] Launching 2 futures (chunks) ... DONE
[17:39:21.219] Resolving 2 futures (chunks) ...
[17:39:21.219] resolve() on list ...
[17:39:21.220]  recursive: 0
[17:39:21.220]  length: 2
[17:39:21.220] 
[17:39:21.221] Future #1
[17:39:21.222] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:21.222] - nx: 2
[17:39:21.223] - relay: TRUE
[17:39:21.223] - stdout: TRUE
[17:39:21.223] - signal: TRUE
[17:39:21.224] - resignal: FALSE
[17:39:21.224] - force: TRUE
[17:39:21.224] - relayed: [n=2] FALSE, FALSE
[17:39:21.225] - queued futures: [n=2] FALSE, FALSE
[17:39:21.225]  - until=1
[17:39:21.225]  - relaying element #1
[17:39:21.226] - relayed: [n=2] TRUE, FALSE
[17:39:21.226] - queued futures: [n=2] TRUE, FALSE
[17:39:21.226] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:21.226]  length: 1 (resolved future 1)
[17:39:21.227] Future #2
[17:39:21.227] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:21.228] - nx: 2
[17:39:21.228] - relay: TRUE
[17:39:21.228] - stdout: TRUE
[17:39:21.228] - signal: TRUE
[17:39:21.228] - resignal: FALSE
[17:39:21.229] - force: TRUE
[17:39:21.229] - relayed: [n=2] TRUE, FALSE
[17:39:21.229] - queued futures: [n=2] TRUE, FALSE
[17:39:21.229]  - until=2
[17:39:21.229]  - relaying element #2
[17:39:21.229] - relayed: [n=2] TRUE, TRUE
[17:39:21.230] - queued futures: [n=2] TRUE, TRUE
[17:39:21.230] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:21.230]  length: 0 (resolved future 2)
[17:39:21.230] Relaying remaining futures
[17:39:21.230] signalConditionsASAP(NULL, pos=0) ...
[17:39:21.230] - nx: 2
[17:39:21.230] - relay: TRUE
[17:39:21.230] - stdout: TRUE
[17:39:21.230] - signal: TRUE
[17:39:21.231] - resignal: FALSE
[17:39:21.231] - force: TRUE
[17:39:21.231] - relayed: [n=2] TRUE, TRUE
[17:39:21.231] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:21.231] - relayed: [n=2] TRUE, TRUE
[17:39:21.231] - queued futures: [n=2] TRUE, TRUE
[17:39:21.231] signalConditionsASAP(NULL, pos=0) ... done
[17:39:21.231] resolve() on list ... DONE
[17:39:21.232]  - Number of value chunks collected: 2
[17:39:21.232] Resolving 2 futures (chunks) ... DONE
[17:39:21.232] Reducing values from 2 chunks ...
[17:39:21.232]  - Number of values collected after concatenation: 6
[17:39:21.232]  - Number of values expected: 6
[17:39:21.232] Reducing values from 2 chunks ... DONE
[17:39:21.232] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:39:21.233] getGlobalsAndPackagesXApply() ...
[17:39:21.233]  - future.globals: TRUE
[17:39:21.233] getGlobalsAndPackages() ...
[17:39:21.233] Searching for globals...
[17:39:21.234] - globals found: [1] ‘FUN’
[17:39:21.234] Searching for globals ... DONE
[17:39:21.235] Resolving globals: FALSE
[17:39:21.235] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:21.235] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:21.235] - globals: [1] ‘FUN’
[17:39:21.236] 
[17:39:21.236] getGlobalsAndPackages() ... DONE
[17:39:21.236]  - globals found/used: [n=1] ‘FUN’
[17:39:21.236]  - needed namespaces: [n=0] 
[17:39:21.236] Finding globals ... DONE
[17:39:21.236]  - use_args: TRUE
[17:39:21.236]  - Getting '...' globals ...
[17:39:21.237] resolve() on list ...
[17:39:21.237]  recursive: 0
[17:39:21.237]  length: 1
[17:39:21.237]  elements: ‘...’
[17:39:21.237]  length: 0 (resolved future 1)
[17:39:21.237] resolve() on list ... DONE
[17:39:21.237]    - '...' content: [n=0] 
[17:39:21.237] List of 1
[17:39:21.237]  $ ...: list()
[17:39:21.237]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.237]  - attr(*, "where")=List of 1
[17:39:21.237]   ..$ ...:<environment: 0x55c794fde630> 
[17:39:21.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.237]  - attr(*, "resolved")= logi TRUE
[17:39:21.237]  - attr(*, "total_size")= num NA
[17:39:21.240]  - Getting '...' globals ... DONE
[17:39:21.241] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:21.241] List of 2
[17:39:21.241]  $ ...future.FUN:function (x)  
[17:39:21.241]  $ ...          : list()
[17:39:21.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.241]  - attr(*, "where")=List of 2
[17:39:21.241]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:21.241]   ..$ ...          :<environment: 0x55c794fde630> 
[17:39:21.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.241]  - attr(*, "resolved")= logi FALSE
[17:39:21.241]  - attr(*, "total_size")= num 848
[17:39:21.244] Packages to be attached in all futures: [n=0] 
[17:39:21.244] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.247] future_lapply() ...
[17:39:21.253] Number of chunks: 2
[17:39:21.253] getGlobalsAndPackagesXApply() ...
[17:39:21.253]  - future.globals: <name-value list> with names ‘list()’
[17:39:21.254]  - use_args: TRUE
[17:39:21.254] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:21.254] List of 2
[17:39:21.254]  $ ...          : list()
[17:39:21.254]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.254]  $ ...future.FUN:function (x)  
[17:39:21.254]  - attr(*, "where")=List of 2
[17:39:21.254]   ..$ ...          :<environment: 0x55c794fde630> 
[17:39:21.254]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:21.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.254]  - attr(*, "resolved")= logi FALSE
[17:39:21.254]  - attr(*, "total_size")= num NA
[17:39:21.257] Packages to be attached in all futures: [n=0] 
[17:39:21.257] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.258] Number of futures (= number of chunks): 2
[17:39:21.258] Launching 2 futures (chunks) ...
[17:39:21.258] Chunk #1 of 2 ...
[17:39:21.258]  - seeds: <none>
[17:39:21.258] getGlobalsAndPackages() ...
[17:39:21.258] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.258] Resolving globals: FALSE
[17:39:21.258] Tweak future expression to call with '...' arguments ...
[17:39:21.258] {
[17:39:21.258]     do.call(function(...) {
[17:39:21.258]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.258]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.258]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.258]             on.exit(options(oopts), add = TRUE)
[17:39:21.258]         }
[17:39:21.258]         {
[17:39:21.258]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.258]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.258]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.258]             })
[17:39:21.258]         }
[17:39:21.258]     }, args = future.call.arguments)
[17:39:21.258] }
[17:39:21.259] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.259] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.259] 
[17:39:21.259] getGlobalsAndPackages() ... DONE
[17:39:21.260] run() for ‘Future’ ...
[17:39:21.260] - state: ‘created’
[17:39:21.260] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.263] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.264] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.264]   - Field: ‘label’
[17:39:21.264]   - Field: ‘local’
[17:39:21.264]   - Field: ‘owner’
[17:39:21.264]   - Field: ‘envir’
[17:39:21.264]   - Field: ‘workers’
[17:39:21.264]   - Field: ‘packages’
[17:39:21.264]   - Field: ‘gc’
[17:39:21.264]   - Field: ‘job’
[17:39:21.265]   - Field: ‘conditions’
[17:39:21.265]   - Field: ‘expr’
[17:39:21.265]   - Field: ‘uuid’
[17:39:21.265]   - Field: ‘seed’
[17:39:21.265]   - Field: ‘version’
[17:39:21.265]   - Field: ‘result’
[17:39:21.265]   - Field: ‘asynchronous’
[17:39:21.265]   - Field: ‘calls’
[17:39:21.265]   - Field: ‘globals’
[17:39:21.265]   - Field: ‘stdout’
[17:39:21.265]   - Field: ‘earlySignal’
[17:39:21.266]   - Field: ‘lazy’
[17:39:21.266]   - Field: ‘state’
[17:39:21.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.266] - Launch lazy future ...
[17:39:21.266] Packages needed by the future expression (n = 0): <none>
[17:39:21.266] Packages needed by future strategies (n = 0): <none>
[17:39:21.267] {
[17:39:21.267]     {
[17:39:21.267]         {
[17:39:21.267]             ...future.startTime <- base::Sys.time()
[17:39:21.267]             {
[17:39:21.267]                 {
[17:39:21.267]                   {
[17:39:21.267]                     {
[17:39:21.267]                       base::local({
[17:39:21.267]                         has_future <- base::requireNamespace("future", 
[17:39:21.267]                           quietly = TRUE)
[17:39:21.267]                         if (has_future) {
[17:39:21.267]                           ns <- base::getNamespace("future")
[17:39:21.267]                           version <- ns[[".package"]][["version"]]
[17:39:21.267]                           if (is.null(version)) 
[17:39:21.267]                             version <- utils::packageVersion("future")
[17:39:21.267]                         }
[17:39:21.267]                         else {
[17:39:21.267]                           version <- NULL
[17:39:21.267]                         }
[17:39:21.267]                         if (!has_future || version < "1.8.0") {
[17:39:21.267]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.267]                             "", base::R.version$version.string), 
[17:39:21.267]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.267]                               "release", "version")], collapse = " "), 
[17:39:21.267]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.267]                             info)
[17:39:21.267]                           info <- base::paste(info, collapse = "; ")
[17:39:21.267]                           if (!has_future) {
[17:39:21.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.267]                               info)
[17:39:21.267]                           }
[17:39:21.267]                           else {
[17:39:21.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.267]                               info, version)
[17:39:21.267]                           }
[17:39:21.267]                           base::stop(msg)
[17:39:21.267]                         }
[17:39:21.267]                       })
[17:39:21.267]                     }
[17:39:21.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.267]                     base::options(mc.cores = 1L)
[17:39:21.267]                   }
[17:39:21.267]                   options(future.plan = NULL)
[17:39:21.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.267]                 }
[17:39:21.267]                 ...future.workdir <- getwd()
[17:39:21.267]             }
[17:39:21.267]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.267]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.267]         }
[17:39:21.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.267]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.267]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.267]             base::names(...future.oldOptions))
[17:39:21.267]     }
[17:39:21.267]     if (FALSE) {
[17:39:21.267]     }
[17:39:21.267]     else {
[17:39:21.267]         if (TRUE) {
[17:39:21.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.267]                 open = "w")
[17:39:21.267]         }
[17:39:21.267]         else {
[17:39:21.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.267]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.267]         }
[17:39:21.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.267]             base::sink(type = "output", split = FALSE)
[17:39:21.267]             base::close(...future.stdout)
[17:39:21.267]         }, add = TRUE)
[17:39:21.267]     }
[17:39:21.267]     ...future.frame <- base::sys.nframe()
[17:39:21.267]     ...future.conditions <- base::list()
[17:39:21.267]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.267]     if (FALSE) {
[17:39:21.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.267]     }
[17:39:21.267]     ...future.result <- base::tryCatch({
[17:39:21.267]         base::withCallingHandlers({
[17:39:21.267]             ...future.value <- base::withVisible(base::local({
[17:39:21.267]                 withCallingHandlers({
[17:39:21.267]                   {
[17:39:21.267]                     do.call(function(...) {
[17:39:21.267]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.267]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.267]                         ...future.globals.maxSize)) {
[17:39:21.267]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.267]                         on.exit(options(oopts), add = TRUE)
[17:39:21.267]                       }
[17:39:21.267]                       {
[17:39:21.267]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.267]                           FUN = function(jj) {
[17:39:21.267]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.267]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.267]                           })
[17:39:21.267]                       }
[17:39:21.267]                     }, args = future.call.arguments)
[17:39:21.267]                   }
[17:39:21.267]                 }, immediateCondition = function(cond) {
[17:39:21.267]                   save_rds <- function (object, pathname, ...) 
[17:39:21.267]                   {
[17:39:21.267]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.267]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.267]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.267]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.267]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.267]                         fi_tmp[["mtime"]])
[17:39:21.267]                     }
[17:39:21.267]                     tryCatch({
[17:39:21.267]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.267]                     }, error = function(ex) {
[17:39:21.267]                       msg <- conditionMessage(ex)
[17:39:21.267]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.267]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.267]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.267]                         fi_tmp[["mtime"]], msg)
[17:39:21.267]                       ex$message <- msg
[17:39:21.267]                       stop(ex)
[17:39:21.267]                     })
[17:39:21.267]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.267]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.267]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.267]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.267]                       fi <- file.info(pathname)
[17:39:21.267]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.267]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.267]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.267]                         fi[["size"]], fi[["mtime"]])
[17:39:21.267]                       stop(msg)
[17:39:21.267]                     }
[17:39:21.267]                     invisible(pathname)
[17:39:21.267]                   }
[17:39:21.267]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.267]                     rootPath = tempdir()) 
[17:39:21.267]                   {
[17:39:21.267]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.267]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.267]                       tmpdir = path, fileext = ".rds")
[17:39:21.267]                     save_rds(obj, file)
[17:39:21.267]                   }
[17:39:21.267]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.267]                   {
[17:39:21.267]                     inherits <- base::inherits
[17:39:21.267]                     invokeRestart <- base::invokeRestart
[17:39:21.267]                     is.null <- base::is.null
[17:39:21.267]                     muffled <- FALSE
[17:39:21.267]                     if (inherits(cond, "message")) {
[17:39:21.267]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.267]                       if (muffled) 
[17:39:21.267]                         invokeRestart("muffleMessage")
[17:39:21.267]                     }
[17:39:21.267]                     else if (inherits(cond, "warning")) {
[17:39:21.267]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.267]                       if (muffled) 
[17:39:21.267]                         invokeRestart("muffleWarning")
[17:39:21.267]                     }
[17:39:21.267]                     else if (inherits(cond, "condition")) {
[17:39:21.267]                       if (!is.null(pattern)) {
[17:39:21.267]                         computeRestarts <- base::computeRestarts
[17:39:21.267]                         grepl <- base::grepl
[17:39:21.267]                         restarts <- computeRestarts(cond)
[17:39:21.267]                         for (restart in restarts) {
[17:39:21.267]                           name <- restart$name
[17:39:21.267]                           if (is.null(name)) 
[17:39:21.267]                             next
[17:39:21.267]                           if (!grepl(pattern, name)) 
[17:39:21.267]                             next
[17:39:21.267]                           invokeRestart(restart)
[17:39:21.267]                           muffled <- TRUE
[17:39:21.267]                           break
[17:39:21.267]                         }
[17:39:21.267]                       }
[17:39:21.267]                     }
[17:39:21.267]                     invisible(muffled)
[17:39:21.267]                   }
[17:39:21.267]                   muffleCondition(cond)
[17:39:21.267]                 })
[17:39:21.267]             }))
[17:39:21.267]             future::FutureResult(value = ...future.value$value, 
[17:39:21.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.267]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.267]                     ...future.globalenv.names))
[17:39:21.267]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.267]         }, condition = base::local({
[17:39:21.267]             c <- base::c
[17:39:21.267]             inherits <- base::inherits
[17:39:21.267]             invokeRestart <- base::invokeRestart
[17:39:21.267]             length <- base::length
[17:39:21.267]             list <- base::list
[17:39:21.267]             seq.int <- base::seq.int
[17:39:21.267]             signalCondition <- base::signalCondition
[17:39:21.267]             sys.calls <- base::sys.calls
[17:39:21.267]             `[[` <- base::`[[`
[17:39:21.267]             `+` <- base::`+`
[17:39:21.267]             `<<-` <- base::`<<-`
[17:39:21.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.267]                   3L)]
[17:39:21.267]             }
[17:39:21.267]             function(cond) {
[17:39:21.267]                 is_error <- inherits(cond, "error")
[17:39:21.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.267]                   NULL)
[17:39:21.267]                 if (is_error) {
[17:39:21.267]                   sessionInformation <- function() {
[17:39:21.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.267]                       search = base::search(), system = base::Sys.info())
[17:39:21.267]                   }
[17:39:21.267]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.267]                     cond$call), session = sessionInformation(), 
[17:39:21.267]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.267]                   signalCondition(cond)
[17:39:21.267]                 }
[17:39:21.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.267]                 "immediateCondition"))) {
[17:39:21.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.267]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.267]                   if (TRUE && !signal) {
[17:39:21.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.267]                     {
[17:39:21.267]                       inherits <- base::inherits
[17:39:21.267]                       invokeRestart <- base::invokeRestart
[17:39:21.267]                       is.null <- base::is.null
[17:39:21.267]                       muffled <- FALSE
[17:39:21.267]                       if (inherits(cond, "message")) {
[17:39:21.267]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.267]                         if (muffled) 
[17:39:21.267]                           invokeRestart("muffleMessage")
[17:39:21.267]                       }
[17:39:21.267]                       else if (inherits(cond, "warning")) {
[17:39:21.267]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.267]                         if (muffled) 
[17:39:21.267]                           invokeRestart("muffleWarning")
[17:39:21.267]                       }
[17:39:21.267]                       else if (inherits(cond, "condition")) {
[17:39:21.267]                         if (!is.null(pattern)) {
[17:39:21.267]                           computeRestarts <- base::computeRestarts
[17:39:21.267]                           grepl <- base::grepl
[17:39:21.267]                           restarts <- computeRestarts(cond)
[17:39:21.267]                           for (restart in restarts) {
[17:39:21.267]                             name <- restart$name
[17:39:21.267]                             if (is.null(name)) 
[17:39:21.267]                               next
[17:39:21.267]                             if (!grepl(pattern, name)) 
[17:39:21.267]                               next
[17:39:21.267]                             invokeRestart(restart)
[17:39:21.267]                             muffled <- TRUE
[17:39:21.267]                             break
[17:39:21.267]                           }
[17:39:21.267]                         }
[17:39:21.267]                       }
[17:39:21.267]                       invisible(muffled)
[17:39:21.267]                     }
[17:39:21.267]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.267]                   }
[17:39:21.267]                 }
[17:39:21.267]                 else {
[17:39:21.267]                   if (TRUE) {
[17:39:21.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.267]                     {
[17:39:21.267]                       inherits <- base::inherits
[17:39:21.267]                       invokeRestart <- base::invokeRestart
[17:39:21.267]                       is.null <- base::is.null
[17:39:21.267]                       muffled <- FALSE
[17:39:21.267]                       if (inherits(cond, "message")) {
[17:39:21.267]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.267]                         if (muffled) 
[17:39:21.267]                           invokeRestart("muffleMessage")
[17:39:21.267]                       }
[17:39:21.267]                       else if (inherits(cond, "warning")) {
[17:39:21.267]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.267]                         if (muffled) 
[17:39:21.267]                           invokeRestart("muffleWarning")
[17:39:21.267]                       }
[17:39:21.267]                       else if (inherits(cond, "condition")) {
[17:39:21.267]                         if (!is.null(pattern)) {
[17:39:21.267]                           computeRestarts <- base::computeRestarts
[17:39:21.267]                           grepl <- base::grepl
[17:39:21.267]                           restarts <- computeRestarts(cond)
[17:39:21.267]                           for (restart in restarts) {
[17:39:21.267]                             name <- restart$name
[17:39:21.267]                             if (is.null(name)) 
[17:39:21.267]                               next
[17:39:21.267]                             if (!grepl(pattern, name)) 
[17:39:21.267]                               next
[17:39:21.267]                             invokeRestart(restart)
[17:39:21.267]                             muffled <- TRUE
[17:39:21.267]                             break
[17:39:21.267]                           }
[17:39:21.267]                         }
[17:39:21.267]                       }
[17:39:21.267]                       invisible(muffled)
[17:39:21.267]                     }
[17:39:21.267]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.267]                   }
[17:39:21.267]                 }
[17:39:21.267]             }
[17:39:21.267]         }))
[17:39:21.267]     }, error = function(ex) {
[17:39:21.267]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.267]                 ...future.rng), started = ...future.startTime, 
[17:39:21.267]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.267]             version = "1.8"), class = "FutureResult")
[17:39:21.267]     }, finally = {
[17:39:21.267]         if (!identical(...future.workdir, getwd())) 
[17:39:21.267]             setwd(...future.workdir)
[17:39:21.267]         {
[17:39:21.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.267]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.267]             }
[17:39:21.267]             base::options(...future.oldOptions)
[17:39:21.267]             if (.Platform$OS.type == "windows") {
[17:39:21.267]                 old_names <- names(...future.oldEnvVars)
[17:39:21.267]                 envs <- base::Sys.getenv()
[17:39:21.267]                 names <- names(envs)
[17:39:21.267]                 common <- intersect(names, old_names)
[17:39:21.267]                 added <- setdiff(names, old_names)
[17:39:21.267]                 removed <- setdiff(old_names, names)
[17:39:21.267]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.267]                   envs[common]]
[17:39:21.267]                 NAMES <- toupper(changed)
[17:39:21.267]                 args <- list()
[17:39:21.267]                 for (kk in seq_along(NAMES)) {
[17:39:21.267]                   name <- changed[[kk]]
[17:39:21.267]                   NAME <- NAMES[[kk]]
[17:39:21.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.267]                     next
[17:39:21.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.267]                 }
[17:39:21.267]                 NAMES <- toupper(added)
[17:39:21.267]                 for (kk in seq_along(NAMES)) {
[17:39:21.267]                   name <- added[[kk]]
[17:39:21.267]                   NAME <- NAMES[[kk]]
[17:39:21.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.267]                     next
[17:39:21.267]                   args[[name]] <- ""
[17:39:21.267]                 }
[17:39:21.267]                 NAMES <- toupper(removed)
[17:39:21.267]                 for (kk in seq_along(NAMES)) {
[17:39:21.267]                   name <- removed[[kk]]
[17:39:21.267]                   NAME <- NAMES[[kk]]
[17:39:21.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.267]                     next
[17:39:21.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.267]                 }
[17:39:21.267]                 if (length(args) > 0) 
[17:39:21.267]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.267]             }
[17:39:21.267]             else {
[17:39:21.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.267]             }
[17:39:21.267]             {
[17:39:21.267]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.267]                   0L) {
[17:39:21.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.267]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.267]                   base::options(opts)
[17:39:21.267]                 }
[17:39:21.267]                 {
[17:39:21.267]                   {
[17:39:21.267]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.267]                     NULL
[17:39:21.267]                   }
[17:39:21.267]                   options(future.plan = NULL)
[17:39:21.267]                   if (is.na(NA_character_)) 
[17:39:21.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.267]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.267]                     envir = parent.frame()) 
[17:39:21.267]                   {
[17:39:21.267]                     default_workers <- missing(workers)
[17:39:21.267]                     if (is.function(workers)) 
[17:39:21.267]                       workers <- workers()
[17:39:21.267]                     workers <- structure(as.integer(workers), 
[17:39:21.267]                       class = class(workers))
[17:39:21.267]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.267]                       1L)
[17:39:21.267]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.267]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.267]                       if (default_workers) 
[17:39:21.267]                         supportsMulticore(warn = TRUE)
[17:39:21.267]                       return(sequential(..., envir = envir))
[17:39:21.267]                     }
[17:39:21.267]                     oopts <- options(mc.cores = workers)
[17:39:21.267]                     on.exit(options(oopts))
[17:39:21.267]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.267]                       envir = envir)
[17:39:21.267]                     if (!future$lazy) 
[17:39:21.267]                       future <- run(future)
[17:39:21.267]                     invisible(future)
[17:39:21.267]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.267]                 }
[17:39:21.267]             }
[17:39:21.267]         }
[17:39:21.267]     })
[17:39:21.267]     if (TRUE) {
[17:39:21.267]         base::sink(type = "output", split = FALSE)
[17:39:21.267]         if (TRUE) {
[17:39:21.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.267]         }
[17:39:21.267]         else {
[17:39:21.267]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.267]         }
[17:39:21.267]         base::close(...future.stdout)
[17:39:21.267]         ...future.stdout <- NULL
[17:39:21.267]     }
[17:39:21.267]     ...future.result$conditions <- ...future.conditions
[17:39:21.267]     ...future.result$finished <- base::Sys.time()
[17:39:21.267]     ...future.result
[17:39:21.267] }
[17:39:21.269] assign_globals() ...
[17:39:21.269] List of 5
[17:39:21.269]  $ future.call.arguments    : list()
[17:39:21.269]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.269]  $ ...future.FUN            :function (x)  
[17:39:21.269]  $ ...future.elements_ii    :List of 1
[17:39:21.269]   ..$ : int 1
[17:39:21.269]  $ ...future.seeds_ii       : NULL
[17:39:21.269]  $ ...future.globals.maxSize: NULL
[17:39:21.269]  - attr(*, "where")=List of 5
[17:39:21.269]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.269]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.269]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.269]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.269]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.269]  - attr(*, "resolved")= logi FALSE
[17:39:21.269]  - attr(*, "total_size")= num NA
[17:39:21.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.269]  - attr(*, "already-done")= logi TRUE
[17:39:21.274] - copied ‘future.call.arguments’ to environment
[17:39:21.274] - copied ‘...future.FUN’ to environment
[17:39:21.274] - copied ‘...future.elements_ii’ to environment
[17:39:21.274] - copied ‘...future.seeds_ii’ to environment
[17:39:21.274] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.274] assign_globals() ... done
[17:39:21.274] requestCore(): workers = 2
[17:39:21.276] MulticoreFuture started
[17:39:21.277] - Launch lazy future ... done
[17:39:21.277] run() for ‘MulticoreFuture’ ... done
[17:39:21.277] Created future:
[17:39:21.277] plan(): Setting new future strategy stack:
[17:39:21.278] List of future strategies:
[17:39:21.278] 1. sequential:
[17:39:21.278]    - args: function (..., envir = parent.frame())
[17:39:21.278]    - tweaked: FALSE
[17:39:21.278]    - call: NULL
[17:39:21.279] plan(): nbrOfWorkers() = 1
[17:39:21.280] plan(): Setting new future strategy stack:
[17:39:21.281] List of future strategies:
[17:39:21.281] 1. multicore:
[17:39:21.281]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.281]    - tweaked: FALSE
[17:39:21.281]    - call: plan(strategy)
[17:39:21.277] MulticoreFuture:
[17:39:21.277] Label: ‘future_apply-1’
[17:39:21.277] Expression:
[17:39:21.277] {
[17:39:21.277]     do.call(function(...) {
[17:39:21.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.277]             on.exit(options(oopts), add = TRUE)
[17:39:21.277]         }
[17:39:21.277]         {
[17:39:21.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.277]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.277]             })
[17:39:21.277]         }
[17:39:21.277]     }, args = future.call.arguments)
[17:39:21.277] }
[17:39:21.277] Lazy evaluation: FALSE
[17:39:21.277] Asynchronous evaluation: TRUE
[17:39:21.277] Local evaluation: TRUE
[17:39:21.277] Environment: R_GlobalEnv
[17:39:21.277] Capture standard output: TRUE
[17:39:21.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.277] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:21.277] Packages: <none>
[17:39:21.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.277] Resolved: FALSE
[17:39:21.277] Value: <not collected>
[17:39:21.277] Conditions captured: <none>
[17:39:21.277] Early signaling: FALSE
[17:39:21.277] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.277] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.290] Chunk #1 of 2 ... DONE
[17:39:21.290] Chunk #2 of 2 ...
[17:39:21.291]  - seeds: <none>
[17:39:21.291] getGlobalsAndPackages() ...
[17:39:21.291] plan(): nbrOfWorkers() = 2
[17:39:21.293] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.293] Resolving globals: FALSE
[17:39:21.294] Tweak future expression to call with '...' arguments ...
[17:39:21.294] {
[17:39:21.294]     do.call(function(...) {
[17:39:21.294]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.294]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.294]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.294]             on.exit(options(oopts), add = TRUE)
[17:39:21.294]         }
[17:39:21.294]         {
[17:39:21.294]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.294]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.294]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.294]             })
[17:39:21.294]         }
[17:39:21.294]     }, args = future.call.arguments)
[17:39:21.294] }
[17:39:21.294] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.295] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.296] 
[17:39:21.296] getGlobalsAndPackages() ... DONE
[17:39:21.297] run() for ‘Future’ ...
[17:39:21.297] - state: ‘created’
[17:39:21.297] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.303] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.304]   - Field: ‘label’
[17:39:21.304]   - Field: ‘local’
[17:39:21.304]   - Field: ‘owner’
[17:39:21.304]   - Field: ‘envir’
[17:39:21.304]   - Field: ‘workers’
[17:39:21.304]   - Field: ‘packages’
[17:39:21.305]   - Field: ‘gc’
[17:39:21.305]   - Field: ‘job’
[17:39:21.305]   - Field: ‘conditions’
[17:39:21.305]   - Field: ‘expr’
[17:39:21.305]   - Field: ‘uuid’
[17:39:21.305]   - Field: ‘seed’
[17:39:21.306]   - Field: ‘version’
[17:39:21.306]   - Field: ‘result’
[17:39:21.306]   - Field: ‘asynchronous’
[17:39:21.306]   - Field: ‘calls’
[17:39:21.307]   - Field: ‘globals’
[17:39:21.307]   - Field: ‘stdout’
[17:39:21.307]   - Field: ‘earlySignal’
[17:39:21.307]   - Field: ‘lazy’
[17:39:21.307]   - Field: ‘state’
[17:39:21.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.308] - Launch lazy future ...
[17:39:21.308] Packages needed by the future expression (n = 0): <none>
[17:39:21.308] Packages needed by future strategies (n = 0): <none>
[17:39:21.309] {
[17:39:21.309]     {
[17:39:21.309]         {
[17:39:21.309]             ...future.startTime <- base::Sys.time()
[17:39:21.309]             {
[17:39:21.309]                 {
[17:39:21.309]                   {
[17:39:21.309]                     {
[17:39:21.309]                       base::local({
[17:39:21.309]                         has_future <- base::requireNamespace("future", 
[17:39:21.309]                           quietly = TRUE)
[17:39:21.309]                         if (has_future) {
[17:39:21.309]                           ns <- base::getNamespace("future")
[17:39:21.309]                           version <- ns[[".package"]][["version"]]
[17:39:21.309]                           if (is.null(version)) 
[17:39:21.309]                             version <- utils::packageVersion("future")
[17:39:21.309]                         }
[17:39:21.309]                         else {
[17:39:21.309]                           version <- NULL
[17:39:21.309]                         }
[17:39:21.309]                         if (!has_future || version < "1.8.0") {
[17:39:21.309]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.309]                             "", base::R.version$version.string), 
[17:39:21.309]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.309]                               "release", "version")], collapse = " "), 
[17:39:21.309]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.309]                             info)
[17:39:21.309]                           info <- base::paste(info, collapse = "; ")
[17:39:21.309]                           if (!has_future) {
[17:39:21.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.309]                               info)
[17:39:21.309]                           }
[17:39:21.309]                           else {
[17:39:21.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.309]                               info, version)
[17:39:21.309]                           }
[17:39:21.309]                           base::stop(msg)
[17:39:21.309]                         }
[17:39:21.309]                       })
[17:39:21.309]                     }
[17:39:21.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.309]                     base::options(mc.cores = 1L)
[17:39:21.309]                   }
[17:39:21.309]                   options(future.plan = NULL)
[17:39:21.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.309]                 }
[17:39:21.309]                 ...future.workdir <- getwd()
[17:39:21.309]             }
[17:39:21.309]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.309]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.309]         }
[17:39:21.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.309]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.309]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.309]             base::names(...future.oldOptions))
[17:39:21.309]     }
[17:39:21.309]     if (FALSE) {
[17:39:21.309]     }
[17:39:21.309]     else {
[17:39:21.309]         if (TRUE) {
[17:39:21.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.309]                 open = "w")
[17:39:21.309]         }
[17:39:21.309]         else {
[17:39:21.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.309]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.309]         }
[17:39:21.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.309]             base::sink(type = "output", split = FALSE)
[17:39:21.309]             base::close(...future.stdout)
[17:39:21.309]         }, add = TRUE)
[17:39:21.309]     }
[17:39:21.309]     ...future.frame <- base::sys.nframe()
[17:39:21.309]     ...future.conditions <- base::list()
[17:39:21.309]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.309]     if (FALSE) {
[17:39:21.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.309]     }
[17:39:21.309]     ...future.result <- base::tryCatch({
[17:39:21.309]         base::withCallingHandlers({
[17:39:21.309]             ...future.value <- base::withVisible(base::local({
[17:39:21.309]                 withCallingHandlers({
[17:39:21.309]                   {
[17:39:21.309]                     do.call(function(...) {
[17:39:21.309]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.309]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.309]                         ...future.globals.maxSize)) {
[17:39:21.309]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.309]                         on.exit(options(oopts), add = TRUE)
[17:39:21.309]                       }
[17:39:21.309]                       {
[17:39:21.309]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.309]                           FUN = function(jj) {
[17:39:21.309]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.309]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.309]                           })
[17:39:21.309]                       }
[17:39:21.309]                     }, args = future.call.arguments)
[17:39:21.309]                   }
[17:39:21.309]                 }, immediateCondition = function(cond) {
[17:39:21.309]                   save_rds <- function (object, pathname, ...) 
[17:39:21.309]                   {
[17:39:21.309]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.309]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.309]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.309]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.309]                         fi_tmp[["mtime"]])
[17:39:21.309]                     }
[17:39:21.309]                     tryCatch({
[17:39:21.309]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.309]                     }, error = function(ex) {
[17:39:21.309]                       msg <- conditionMessage(ex)
[17:39:21.309]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.309]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.309]                         fi_tmp[["mtime"]], msg)
[17:39:21.309]                       ex$message <- msg
[17:39:21.309]                       stop(ex)
[17:39:21.309]                     })
[17:39:21.309]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.309]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.309]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.309]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.309]                       fi <- file.info(pathname)
[17:39:21.309]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.309]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.309]                         fi[["size"]], fi[["mtime"]])
[17:39:21.309]                       stop(msg)
[17:39:21.309]                     }
[17:39:21.309]                     invisible(pathname)
[17:39:21.309]                   }
[17:39:21.309]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.309]                     rootPath = tempdir()) 
[17:39:21.309]                   {
[17:39:21.309]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.309]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.309]                       tmpdir = path, fileext = ".rds")
[17:39:21.309]                     save_rds(obj, file)
[17:39:21.309]                   }
[17:39:21.309]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.309]                   {
[17:39:21.309]                     inherits <- base::inherits
[17:39:21.309]                     invokeRestart <- base::invokeRestart
[17:39:21.309]                     is.null <- base::is.null
[17:39:21.309]                     muffled <- FALSE
[17:39:21.309]                     if (inherits(cond, "message")) {
[17:39:21.309]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.309]                       if (muffled) 
[17:39:21.309]                         invokeRestart("muffleMessage")
[17:39:21.309]                     }
[17:39:21.309]                     else if (inherits(cond, "warning")) {
[17:39:21.309]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.309]                       if (muffled) 
[17:39:21.309]                         invokeRestart("muffleWarning")
[17:39:21.309]                     }
[17:39:21.309]                     else if (inherits(cond, "condition")) {
[17:39:21.309]                       if (!is.null(pattern)) {
[17:39:21.309]                         computeRestarts <- base::computeRestarts
[17:39:21.309]                         grepl <- base::grepl
[17:39:21.309]                         restarts <- computeRestarts(cond)
[17:39:21.309]                         for (restart in restarts) {
[17:39:21.309]                           name <- restart$name
[17:39:21.309]                           if (is.null(name)) 
[17:39:21.309]                             next
[17:39:21.309]                           if (!grepl(pattern, name)) 
[17:39:21.309]                             next
[17:39:21.309]                           invokeRestart(restart)
[17:39:21.309]                           muffled <- TRUE
[17:39:21.309]                           break
[17:39:21.309]                         }
[17:39:21.309]                       }
[17:39:21.309]                     }
[17:39:21.309]                     invisible(muffled)
[17:39:21.309]                   }
[17:39:21.309]                   muffleCondition(cond)
[17:39:21.309]                 })
[17:39:21.309]             }))
[17:39:21.309]             future::FutureResult(value = ...future.value$value, 
[17:39:21.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.309]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.309]                     ...future.globalenv.names))
[17:39:21.309]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.309]         }, condition = base::local({
[17:39:21.309]             c <- base::c
[17:39:21.309]             inherits <- base::inherits
[17:39:21.309]             invokeRestart <- base::invokeRestart
[17:39:21.309]             length <- base::length
[17:39:21.309]             list <- base::list
[17:39:21.309]             seq.int <- base::seq.int
[17:39:21.309]             signalCondition <- base::signalCondition
[17:39:21.309]             sys.calls <- base::sys.calls
[17:39:21.309]             `[[` <- base::`[[`
[17:39:21.309]             `+` <- base::`+`
[17:39:21.309]             `<<-` <- base::`<<-`
[17:39:21.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.309]                   3L)]
[17:39:21.309]             }
[17:39:21.309]             function(cond) {
[17:39:21.309]                 is_error <- inherits(cond, "error")
[17:39:21.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.309]                   NULL)
[17:39:21.309]                 if (is_error) {
[17:39:21.309]                   sessionInformation <- function() {
[17:39:21.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.309]                       search = base::search(), system = base::Sys.info())
[17:39:21.309]                   }
[17:39:21.309]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.309]                     cond$call), session = sessionInformation(), 
[17:39:21.309]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.309]                   signalCondition(cond)
[17:39:21.309]                 }
[17:39:21.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.309]                 "immediateCondition"))) {
[17:39:21.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.309]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.309]                   if (TRUE && !signal) {
[17:39:21.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.309]                     {
[17:39:21.309]                       inherits <- base::inherits
[17:39:21.309]                       invokeRestart <- base::invokeRestart
[17:39:21.309]                       is.null <- base::is.null
[17:39:21.309]                       muffled <- FALSE
[17:39:21.309]                       if (inherits(cond, "message")) {
[17:39:21.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.309]                         if (muffled) 
[17:39:21.309]                           invokeRestart("muffleMessage")
[17:39:21.309]                       }
[17:39:21.309]                       else if (inherits(cond, "warning")) {
[17:39:21.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.309]                         if (muffled) 
[17:39:21.309]                           invokeRestart("muffleWarning")
[17:39:21.309]                       }
[17:39:21.309]                       else if (inherits(cond, "condition")) {
[17:39:21.309]                         if (!is.null(pattern)) {
[17:39:21.309]                           computeRestarts <- base::computeRestarts
[17:39:21.309]                           grepl <- base::grepl
[17:39:21.309]                           restarts <- computeRestarts(cond)
[17:39:21.309]                           for (restart in restarts) {
[17:39:21.309]                             name <- restart$name
[17:39:21.309]                             if (is.null(name)) 
[17:39:21.309]                               next
[17:39:21.309]                             if (!grepl(pattern, name)) 
[17:39:21.309]                               next
[17:39:21.309]                             invokeRestart(restart)
[17:39:21.309]                             muffled <- TRUE
[17:39:21.309]                             break
[17:39:21.309]                           }
[17:39:21.309]                         }
[17:39:21.309]                       }
[17:39:21.309]                       invisible(muffled)
[17:39:21.309]                     }
[17:39:21.309]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.309]                   }
[17:39:21.309]                 }
[17:39:21.309]                 else {
[17:39:21.309]                   if (TRUE) {
[17:39:21.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.309]                     {
[17:39:21.309]                       inherits <- base::inherits
[17:39:21.309]                       invokeRestart <- base::invokeRestart
[17:39:21.309]                       is.null <- base::is.null
[17:39:21.309]                       muffled <- FALSE
[17:39:21.309]                       if (inherits(cond, "message")) {
[17:39:21.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.309]                         if (muffled) 
[17:39:21.309]                           invokeRestart("muffleMessage")
[17:39:21.309]                       }
[17:39:21.309]                       else if (inherits(cond, "warning")) {
[17:39:21.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.309]                         if (muffled) 
[17:39:21.309]                           invokeRestart("muffleWarning")
[17:39:21.309]                       }
[17:39:21.309]                       else if (inherits(cond, "condition")) {
[17:39:21.309]                         if (!is.null(pattern)) {
[17:39:21.309]                           computeRestarts <- base::computeRestarts
[17:39:21.309]                           grepl <- base::grepl
[17:39:21.309]                           restarts <- computeRestarts(cond)
[17:39:21.309]                           for (restart in restarts) {
[17:39:21.309]                             name <- restart$name
[17:39:21.309]                             if (is.null(name)) 
[17:39:21.309]                               next
[17:39:21.309]                             if (!grepl(pattern, name)) 
[17:39:21.309]                               next
[17:39:21.309]                             invokeRestart(restart)
[17:39:21.309]                             muffled <- TRUE
[17:39:21.309]                             break
[17:39:21.309]                           }
[17:39:21.309]                         }
[17:39:21.309]                       }
[17:39:21.309]                       invisible(muffled)
[17:39:21.309]                     }
[17:39:21.309]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.309]                   }
[17:39:21.309]                 }
[17:39:21.309]             }
[17:39:21.309]         }))
[17:39:21.309]     }, error = function(ex) {
[17:39:21.309]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.309]                 ...future.rng), started = ...future.startTime, 
[17:39:21.309]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.309]             version = "1.8"), class = "FutureResult")
[17:39:21.309]     }, finally = {
[17:39:21.309]         if (!identical(...future.workdir, getwd())) 
[17:39:21.309]             setwd(...future.workdir)
[17:39:21.309]         {
[17:39:21.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.309]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.309]             }
[17:39:21.309]             base::options(...future.oldOptions)
[17:39:21.309]             if (.Platform$OS.type == "windows") {
[17:39:21.309]                 old_names <- names(...future.oldEnvVars)
[17:39:21.309]                 envs <- base::Sys.getenv()
[17:39:21.309]                 names <- names(envs)
[17:39:21.309]                 common <- intersect(names, old_names)
[17:39:21.309]                 added <- setdiff(names, old_names)
[17:39:21.309]                 removed <- setdiff(old_names, names)
[17:39:21.309]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.309]                   envs[common]]
[17:39:21.309]                 NAMES <- toupper(changed)
[17:39:21.309]                 args <- list()
[17:39:21.309]                 for (kk in seq_along(NAMES)) {
[17:39:21.309]                   name <- changed[[kk]]
[17:39:21.309]                   NAME <- NAMES[[kk]]
[17:39:21.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.309]                     next
[17:39:21.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.309]                 }
[17:39:21.309]                 NAMES <- toupper(added)
[17:39:21.309]                 for (kk in seq_along(NAMES)) {
[17:39:21.309]                   name <- added[[kk]]
[17:39:21.309]                   NAME <- NAMES[[kk]]
[17:39:21.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.309]                     next
[17:39:21.309]                   args[[name]] <- ""
[17:39:21.309]                 }
[17:39:21.309]                 NAMES <- toupper(removed)
[17:39:21.309]                 for (kk in seq_along(NAMES)) {
[17:39:21.309]                   name <- removed[[kk]]
[17:39:21.309]                   NAME <- NAMES[[kk]]
[17:39:21.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.309]                     next
[17:39:21.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.309]                 }
[17:39:21.309]                 if (length(args) > 0) 
[17:39:21.309]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.309]             }
[17:39:21.309]             else {
[17:39:21.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.309]             }
[17:39:21.309]             {
[17:39:21.309]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.309]                   0L) {
[17:39:21.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.309]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.309]                   base::options(opts)
[17:39:21.309]                 }
[17:39:21.309]                 {
[17:39:21.309]                   {
[17:39:21.309]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.309]                     NULL
[17:39:21.309]                   }
[17:39:21.309]                   options(future.plan = NULL)
[17:39:21.309]                   if (is.na(NA_character_)) 
[17:39:21.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.309]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.309]                     envir = parent.frame()) 
[17:39:21.309]                   {
[17:39:21.309]                     default_workers <- missing(workers)
[17:39:21.309]                     if (is.function(workers)) 
[17:39:21.309]                       workers <- workers()
[17:39:21.309]                     workers <- structure(as.integer(workers), 
[17:39:21.309]                       class = class(workers))
[17:39:21.309]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.309]                       1L)
[17:39:21.309]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.309]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.309]                       if (default_workers) 
[17:39:21.309]                         supportsMulticore(warn = TRUE)
[17:39:21.309]                       return(sequential(..., envir = envir))
[17:39:21.309]                     }
[17:39:21.309]                     oopts <- options(mc.cores = workers)
[17:39:21.309]                     on.exit(options(oopts))
[17:39:21.309]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.309]                       envir = envir)
[17:39:21.309]                     if (!future$lazy) 
[17:39:21.309]                       future <- run(future)
[17:39:21.309]                     invisible(future)
[17:39:21.309]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.309]                 }
[17:39:21.309]             }
[17:39:21.309]         }
[17:39:21.309]     })
[17:39:21.309]     if (TRUE) {
[17:39:21.309]         base::sink(type = "output", split = FALSE)
[17:39:21.309]         if (TRUE) {
[17:39:21.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.309]         }
[17:39:21.309]         else {
[17:39:21.309]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.309]         }
[17:39:21.309]         base::close(...future.stdout)
[17:39:21.309]         ...future.stdout <- NULL
[17:39:21.309]     }
[17:39:21.309]     ...future.result$conditions <- ...future.conditions
[17:39:21.309]     ...future.result$finished <- base::Sys.time()
[17:39:21.309]     ...future.result
[17:39:21.309] }
[17:39:21.312] assign_globals() ...
[17:39:21.312] List of 5
[17:39:21.312]  $ future.call.arguments    : list()
[17:39:21.312]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.312]  $ ...future.FUN            :function (x)  
[17:39:21.312]  $ ...future.elements_ii    :List of 1
[17:39:21.312]   ..$ : int 2
[17:39:21.312]  $ ...future.seeds_ii       : NULL
[17:39:21.312]  $ ...future.globals.maxSize: NULL
[17:39:21.312]  - attr(*, "where")=List of 5
[17:39:21.312]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.312]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.312]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.312]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.312]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.312]  - attr(*, "resolved")= logi FALSE
[17:39:21.312]  - attr(*, "total_size")= num NA
[17:39:21.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.312]  - attr(*, "already-done")= logi TRUE
[17:39:21.318] - copied ‘future.call.arguments’ to environment
[17:39:21.318] - copied ‘...future.FUN’ to environment
[17:39:21.319] - copied ‘...future.elements_ii’ to environment
[17:39:21.319] - copied ‘...future.seeds_ii’ to environment
[17:39:21.319] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.319] assign_globals() ... done
[17:39:21.319] requestCore(): workers = 2
[17:39:21.321] MulticoreFuture started
[17:39:21.322] - Launch lazy future ... done
[17:39:21.322] run() for ‘MulticoreFuture’ ... done
[17:39:21.322] Created future:
[17:39:21.322] plan(): Setting new future strategy stack:
[17:39:21.323] List of future strategies:
[17:39:21.323] 1. sequential:
[17:39:21.323]    - args: function (..., envir = parent.frame())
[17:39:21.323]    - tweaked: FALSE
[17:39:21.323]    - call: NULL
[17:39:21.324] plan(): nbrOfWorkers() = 1
[17:39:21.326] plan(): Setting new future strategy stack:
[17:39:21.326] List of future strategies:
[17:39:21.326] 1. multicore:
[17:39:21.326]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.326]    - tweaked: FALSE
[17:39:21.326]    - call: plan(strategy)
[17:39:21.331] plan(): nbrOfWorkers() = 2
[17:39:21.322] MulticoreFuture:
[17:39:21.322] Label: ‘future_apply-2’
[17:39:21.322] Expression:
[17:39:21.322] {
[17:39:21.322]     do.call(function(...) {
[17:39:21.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.322]             on.exit(options(oopts), add = TRUE)
[17:39:21.322]         }
[17:39:21.322]         {
[17:39:21.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.322]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.322]             })
[17:39:21.322]         }
[17:39:21.322]     }, args = future.call.arguments)
[17:39:21.322] }
[17:39:21.322] Lazy evaluation: FALSE
[17:39:21.322] Asynchronous evaluation: TRUE
[17:39:21.322] Local evaluation: TRUE
[17:39:21.322] Environment: R_GlobalEnv
[17:39:21.322] Capture standard output: TRUE
[17:39:21.322] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.322] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:21.322] Packages: <none>
[17:39:21.322] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.322] Resolved: TRUE
[17:39:21.322] Value: <not collected>
[17:39:21.322] Conditions captured: <none>
[17:39:21.322] Early signaling: FALSE
[17:39:21.322] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.322] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.332] Chunk #2 of 2 ... DONE
[17:39:21.332] Launching 2 futures (chunks) ... DONE
[17:39:21.332] Resolving 2 futures (chunks) ...
[17:39:21.332] resolve() on list ...
[17:39:21.332]  recursive: 0
[17:39:21.332]  length: 2
[17:39:21.332] 
[17:39:21.333] Future #1
[17:39:21.334] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:21.334] - nx: 2
[17:39:21.334] - relay: TRUE
[17:39:21.334] - stdout: TRUE
[17:39:21.334] - signal: TRUE
[17:39:21.334] - resignal: FALSE
[17:39:21.335] - force: TRUE
[17:39:21.335] - relayed: [n=2] FALSE, FALSE
[17:39:21.335] - queued futures: [n=2] FALSE, FALSE
[17:39:21.335]  - until=1
[17:39:21.335]  - relaying element #1
[17:39:21.336] - relayed: [n=2] TRUE, FALSE
[17:39:21.336] - queued futures: [n=2] TRUE, FALSE
[17:39:21.336] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:21.336]  length: 1 (resolved future 1)
[17:39:21.336] Future #2
[17:39:21.337] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:21.337] - nx: 2
[17:39:21.337] - relay: TRUE
[17:39:21.338] - stdout: TRUE
[17:39:21.338] - signal: TRUE
[17:39:21.338] - resignal: FALSE
[17:39:21.338] - force: TRUE
[17:39:21.338] - relayed: [n=2] TRUE, FALSE
[17:39:21.338] - queued futures: [n=2] TRUE, FALSE
[17:39:21.338]  - until=2
[17:39:21.339]  - relaying element #2
[17:39:21.339] - relayed: [n=2] TRUE, TRUE
[17:39:21.339] - queued futures: [n=2] TRUE, TRUE
[17:39:21.339] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:21.339]  length: 0 (resolved future 2)
[17:39:21.339] Relaying remaining futures
[17:39:21.339] signalConditionsASAP(NULL, pos=0) ...
[17:39:21.340] - nx: 2
[17:39:21.340] - relay: TRUE
[17:39:21.340] - stdout: TRUE
[17:39:21.340] - signal: TRUE
[17:39:21.340] - resignal: FALSE
[17:39:21.340] - force: TRUE
[17:39:21.342] - relayed: [n=2] TRUE, TRUE
[17:39:21.343] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:21.343] - relayed: [n=2] TRUE, TRUE
[17:39:21.343] - queued futures: [n=2] TRUE, TRUE
[17:39:21.343] signalConditionsASAP(NULL, pos=0) ... done
[17:39:21.343] resolve() on list ... DONE
[17:39:21.344]  - Number of value chunks collected: 2
[17:39:21.344] Resolving 2 futures (chunks) ... DONE
[17:39:21.344] Reducing values from 2 chunks ...
[17:39:21.344]  - Number of values collected after concatenation: 2
[17:39:21.345]  - Number of values expected: 2
[17:39:21.345] Reducing values from 2 chunks ... DONE
[17:39:21.345] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:39:21.345] getGlobalsAndPackagesXApply() ...
[17:39:21.345]  - future.globals: TRUE
[17:39:21.346] getGlobalsAndPackages() ...
[17:39:21.346] Searching for globals...
[17:39:21.347] - globals found: [1] ‘FUN’
[17:39:21.348] Searching for globals ... DONE
[17:39:21.348] Resolving globals: FALSE
[17:39:21.348] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:21.348] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:21.349] - globals: [1] ‘FUN’
[17:39:21.349] 
[17:39:21.349] getGlobalsAndPackages() ... DONE
[17:39:21.349]  - globals found/used: [n=1] ‘FUN’
[17:39:21.349]  - needed namespaces: [n=0] 
[17:39:21.349] Finding globals ... DONE
[17:39:21.349]  - use_args: TRUE
[17:39:21.350]  - Getting '...' globals ...
[17:39:21.350] resolve() on list ...
[17:39:21.350]  recursive: 0
[17:39:21.350]  length: 1
[17:39:21.350]  elements: ‘...’
[17:39:21.351]  length: 0 (resolved future 1)
[17:39:21.351] resolve() on list ... DONE
[17:39:21.351]    - '...' content: [n=0] 
[17:39:21.351] List of 1
[17:39:21.351]  $ ...: list()
[17:39:21.351]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.351]  - attr(*, "where")=List of 1
[17:39:21.351]   ..$ ...:<environment: 0x55c7969528b8> 
[17:39:21.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.351]  - attr(*, "resolved")= logi TRUE
[17:39:21.351]  - attr(*, "total_size")= num NA
[17:39:21.354]  - Getting '...' globals ... DONE
[17:39:21.354] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:21.354] List of 2
[17:39:21.354]  $ ...future.FUN:function (x)  
[17:39:21.354]  $ ...          : list()
[17:39:21.354]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.354]  - attr(*, "where")=List of 2
[17:39:21.354]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:21.354]   ..$ ...          :<environment: 0x55c7969528b8> 
[17:39:21.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.354]  - attr(*, "resolved")= logi FALSE
[17:39:21.354]  - attr(*, "total_size")= num 848
[17:39:21.357] Packages to be attached in all futures: [n=0] 
[17:39:21.358] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.361] future_lapply() ...
[17:39:21.365] Number of chunks: 2
[17:39:21.365] getGlobalsAndPackagesXApply() ...
[17:39:21.365]  - future.globals: <name-value list> with names ‘list()’
[17:39:21.365]  - use_args: TRUE
[17:39:21.365] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:21.366] List of 2
[17:39:21.366]  $ ...          : list()
[17:39:21.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.366]  $ ...future.FUN:function (x)  
[17:39:21.366]  - attr(*, "where")=List of 2
[17:39:21.366]   ..$ ...          :<environment: 0x55c7969528b8> 
[17:39:21.366]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:21.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.366]  - attr(*, "resolved")= logi FALSE
[17:39:21.366]  - attr(*, "total_size")= num NA
[17:39:21.369] Packages to be attached in all futures: [n=0] 
[17:39:21.369] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.369] Number of futures (= number of chunks): 2
[17:39:21.369] Launching 2 futures (chunks) ...
[17:39:21.369] Chunk #1 of 2 ...
[17:39:21.370]  - seeds: <none>
[17:39:21.370] getGlobalsAndPackages() ...
[17:39:21.370] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.370] Resolving globals: FALSE
[17:39:21.370] Tweak future expression to call with '...' arguments ...
[17:39:21.370] {
[17:39:21.370]     do.call(function(...) {
[17:39:21.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.370]             on.exit(options(oopts), add = TRUE)
[17:39:21.370]         }
[17:39:21.370]         {
[17:39:21.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.370]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.370]             })
[17:39:21.370]         }
[17:39:21.370]     }, args = future.call.arguments)
[17:39:21.370] }
[17:39:21.372] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.372] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.372] 
[17:39:21.373] getGlobalsAndPackages() ... DONE
[17:39:21.373] run() for ‘Future’ ...
[17:39:21.373] - state: ‘created’
[17:39:21.373] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.377] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.377] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.377]   - Field: ‘label’
[17:39:21.377]   - Field: ‘local’
[17:39:21.377]   - Field: ‘owner’
[17:39:21.377]   - Field: ‘envir’
[17:39:21.377]   - Field: ‘workers’
[17:39:21.378]   - Field: ‘packages’
[17:39:21.378]   - Field: ‘gc’
[17:39:21.378]   - Field: ‘job’
[17:39:21.378]   - Field: ‘conditions’
[17:39:21.378]   - Field: ‘expr’
[17:39:21.378]   - Field: ‘uuid’
[17:39:21.378]   - Field: ‘seed’
[17:39:21.378]   - Field: ‘version’
[17:39:21.378]   - Field: ‘result’
[17:39:21.378]   - Field: ‘asynchronous’
[17:39:21.378]   - Field: ‘calls’
[17:39:21.379]   - Field: ‘globals’
[17:39:21.379]   - Field: ‘stdout’
[17:39:21.379]   - Field: ‘earlySignal’
[17:39:21.379]   - Field: ‘lazy’
[17:39:21.379]   - Field: ‘state’
[17:39:21.379] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.379] - Launch lazy future ...
[17:39:21.379] Packages needed by the future expression (n = 0): <none>
[17:39:21.380] Packages needed by future strategies (n = 0): <none>
[17:39:21.380] {
[17:39:21.380]     {
[17:39:21.380]         {
[17:39:21.380]             ...future.startTime <- base::Sys.time()
[17:39:21.380]             {
[17:39:21.380]                 {
[17:39:21.380]                   {
[17:39:21.380]                     {
[17:39:21.380]                       base::local({
[17:39:21.380]                         has_future <- base::requireNamespace("future", 
[17:39:21.380]                           quietly = TRUE)
[17:39:21.380]                         if (has_future) {
[17:39:21.380]                           ns <- base::getNamespace("future")
[17:39:21.380]                           version <- ns[[".package"]][["version"]]
[17:39:21.380]                           if (is.null(version)) 
[17:39:21.380]                             version <- utils::packageVersion("future")
[17:39:21.380]                         }
[17:39:21.380]                         else {
[17:39:21.380]                           version <- NULL
[17:39:21.380]                         }
[17:39:21.380]                         if (!has_future || version < "1.8.0") {
[17:39:21.380]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.380]                             "", base::R.version$version.string), 
[17:39:21.380]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.380]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.380]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.380]                               "release", "version")], collapse = " "), 
[17:39:21.380]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.380]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.380]                             info)
[17:39:21.380]                           info <- base::paste(info, collapse = "; ")
[17:39:21.380]                           if (!has_future) {
[17:39:21.380]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.380]                               info)
[17:39:21.380]                           }
[17:39:21.380]                           else {
[17:39:21.380]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.380]                               info, version)
[17:39:21.380]                           }
[17:39:21.380]                           base::stop(msg)
[17:39:21.380]                         }
[17:39:21.380]                       })
[17:39:21.380]                     }
[17:39:21.380]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.380]                     base::options(mc.cores = 1L)
[17:39:21.380]                   }
[17:39:21.380]                   options(future.plan = NULL)
[17:39:21.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.380]                 }
[17:39:21.380]                 ...future.workdir <- getwd()
[17:39:21.380]             }
[17:39:21.380]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.380]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.380]         }
[17:39:21.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.380]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.380]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.380]             base::names(...future.oldOptions))
[17:39:21.380]     }
[17:39:21.380]     if (FALSE) {
[17:39:21.380]     }
[17:39:21.380]     else {
[17:39:21.380]         if (TRUE) {
[17:39:21.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.380]                 open = "w")
[17:39:21.380]         }
[17:39:21.380]         else {
[17:39:21.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.380]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.380]         }
[17:39:21.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.380]             base::sink(type = "output", split = FALSE)
[17:39:21.380]             base::close(...future.stdout)
[17:39:21.380]         }, add = TRUE)
[17:39:21.380]     }
[17:39:21.380]     ...future.frame <- base::sys.nframe()
[17:39:21.380]     ...future.conditions <- base::list()
[17:39:21.380]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.380]     if (FALSE) {
[17:39:21.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.380]     }
[17:39:21.380]     ...future.result <- base::tryCatch({
[17:39:21.380]         base::withCallingHandlers({
[17:39:21.380]             ...future.value <- base::withVisible(base::local({
[17:39:21.380]                 withCallingHandlers({
[17:39:21.380]                   {
[17:39:21.380]                     do.call(function(...) {
[17:39:21.380]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.380]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.380]                         ...future.globals.maxSize)) {
[17:39:21.380]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.380]                         on.exit(options(oopts), add = TRUE)
[17:39:21.380]                       }
[17:39:21.380]                       {
[17:39:21.380]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.380]                           FUN = function(jj) {
[17:39:21.380]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.380]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.380]                           })
[17:39:21.380]                       }
[17:39:21.380]                     }, args = future.call.arguments)
[17:39:21.380]                   }
[17:39:21.380]                 }, immediateCondition = function(cond) {
[17:39:21.380]                   save_rds <- function (object, pathname, ...) 
[17:39:21.380]                   {
[17:39:21.380]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.380]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.380]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.380]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.380]                         fi_tmp[["mtime"]])
[17:39:21.380]                     }
[17:39:21.380]                     tryCatch({
[17:39:21.380]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.380]                     }, error = function(ex) {
[17:39:21.380]                       msg <- conditionMessage(ex)
[17:39:21.380]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.380]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.380]                         fi_tmp[["mtime"]], msg)
[17:39:21.380]                       ex$message <- msg
[17:39:21.380]                       stop(ex)
[17:39:21.380]                     })
[17:39:21.380]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.380]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.380]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.380]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.380]                       fi <- file.info(pathname)
[17:39:21.380]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.380]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.380]                         fi[["size"]], fi[["mtime"]])
[17:39:21.380]                       stop(msg)
[17:39:21.380]                     }
[17:39:21.380]                     invisible(pathname)
[17:39:21.380]                   }
[17:39:21.380]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.380]                     rootPath = tempdir()) 
[17:39:21.380]                   {
[17:39:21.380]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.380]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.380]                       tmpdir = path, fileext = ".rds")
[17:39:21.380]                     save_rds(obj, file)
[17:39:21.380]                   }
[17:39:21.380]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.380]                   {
[17:39:21.380]                     inherits <- base::inherits
[17:39:21.380]                     invokeRestart <- base::invokeRestart
[17:39:21.380]                     is.null <- base::is.null
[17:39:21.380]                     muffled <- FALSE
[17:39:21.380]                     if (inherits(cond, "message")) {
[17:39:21.380]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.380]                       if (muffled) 
[17:39:21.380]                         invokeRestart("muffleMessage")
[17:39:21.380]                     }
[17:39:21.380]                     else if (inherits(cond, "warning")) {
[17:39:21.380]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.380]                       if (muffled) 
[17:39:21.380]                         invokeRestart("muffleWarning")
[17:39:21.380]                     }
[17:39:21.380]                     else if (inherits(cond, "condition")) {
[17:39:21.380]                       if (!is.null(pattern)) {
[17:39:21.380]                         computeRestarts <- base::computeRestarts
[17:39:21.380]                         grepl <- base::grepl
[17:39:21.380]                         restarts <- computeRestarts(cond)
[17:39:21.380]                         for (restart in restarts) {
[17:39:21.380]                           name <- restart$name
[17:39:21.380]                           if (is.null(name)) 
[17:39:21.380]                             next
[17:39:21.380]                           if (!grepl(pattern, name)) 
[17:39:21.380]                             next
[17:39:21.380]                           invokeRestart(restart)
[17:39:21.380]                           muffled <- TRUE
[17:39:21.380]                           break
[17:39:21.380]                         }
[17:39:21.380]                       }
[17:39:21.380]                     }
[17:39:21.380]                     invisible(muffled)
[17:39:21.380]                   }
[17:39:21.380]                   muffleCondition(cond)
[17:39:21.380]                 })
[17:39:21.380]             }))
[17:39:21.380]             future::FutureResult(value = ...future.value$value, 
[17:39:21.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.380]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.380]                     ...future.globalenv.names))
[17:39:21.380]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.380]         }, condition = base::local({
[17:39:21.380]             c <- base::c
[17:39:21.380]             inherits <- base::inherits
[17:39:21.380]             invokeRestart <- base::invokeRestart
[17:39:21.380]             length <- base::length
[17:39:21.380]             list <- base::list
[17:39:21.380]             seq.int <- base::seq.int
[17:39:21.380]             signalCondition <- base::signalCondition
[17:39:21.380]             sys.calls <- base::sys.calls
[17:39:21.380]             `[[` <- base::`[[`
[17:39:21.380]             `+` <- base::`+`
[17:39:21.380]             `<<-` <- base::`<<-`
[17:39:21.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.380]                   3L)]
[17:39:21.380]             }
[17:39:21.380]             function(cond) {
[17:39:21.380]                 is_error <- inherits(cond, "error")
[17:39:21.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.380]                   NULL)
[17:39:21.380]                 if (is_error) {
[17:39:21.380]                   sessionInformation <- function() {
[17:39:21.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.380]                       search = base::search(), system = base::Sys.info())
[17:39:21.380]                   }
[17:39:21.380]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.380]                     cond$call), session = sessionInformation(), 
[17:39:21.380]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.380]                   signalCondition(cond)
[17:39:21.380]                 }
[17:39:21.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.380]                 "immediateCondition"))) {
[17:39:21.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.380]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.380]                   if (TRUE && !signal) {
[17:39:21.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.380]                     {
[17:39:21.380]                       inherits <- base::inherits
[17:39:21.380]                       invokeRestart <- base::invokeRestart
[17:39:21.380]                       is.null <- base::is.null
[17:39:21.380]                       muffled <- FALSE
[17:39:21.380]                       if (inherits(cond, "message")) {
[17:39:21.380]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.380]                         if (muffled) 
[17:39:21.380]                           invokeRestart("muffleMessage")
[17:39:21.380]                       }
[17:39:21.380]                       else if (inherits(cond, "warning")) {
[17:39:21.380]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.380]                         if (muffled) 
[17:39:21.380]                           invokeRestart("muffleWarning")
[17:39:21.380]                       }
[17:39:21.380]                       else if (inherits(cond, "condition")) {
[17:39:21.380]                         if (!is.null(pattern)) {
[17:39:21.380]                           computeRestarts <- base::computeRestarts
[17:39:21.380]                           grepl <- base::grepl
[17:39:21.380]                           restarts <- computeRestarts(cond)
[17:39:21.380]                           for (restart in restarts) {
[17:39:21.380]                             name <- restart$name
[17:39:21.380]                             if (is.null(name)) 
[17:39:21.380]                               next
[17:39:21.380]                             if (!grepl(pattern, name)) 
[17:39:21.380]                               next
[17:39:21.380]                             invokeRestart(restart)
[17:39:21.380]                             muffled <- TRUE
[17:39:21.380]                             break
[17:39:21.380]                           }
[17:39:21.380]                         }
[17:39:21.380]                       }
[17:39:21.380]                       invisible(muffled)
[17:39:21.380]                     }
[17:39:21.380]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.380]                   }
[17:39:21.380]                 }
[17:39:21.380]                 else {
[17:39:21.380]                   if (TRUE) {
[17:39:21.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.380]                     {
[17:39:21.380]                       inherits <- base::inherits
[17:39:21.380]                       invokeRestart <- base::invokeRestart
[17:39:21.380]                       is.null <- base::is.null
[17:39:21.380]                       muffled <- FALSE
[17:39:21.380]                       if (inherits(cond, "message")) {
[17:39:21.380]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.380]                         if (muffled) 
[17:39:21.380]                           invokeRestart("muffleMessage")
[17:39:21.380]                       }
[17:39:21.380]                       else if (inherits(cond, "warning")) {
[17:39:21.380]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.380]                         if (muffled) 
[17:39:21.380]                           invokeRestart("muffleWarning")
[17:39:21.380]                       }
[17:39:21.380]                       else if (inherits(cond, "condition")) {
[17:39:21.380]                         if (!is.null(pattern)) {
[17:39:21.380]                           computeRestarts <- base::computeRestarts
[17:39:21.380]                           grepl <- base::grepl
[17:39:21.380]                           restarts <- computeRestarts(cond)
[17:39:21.380]                           for (restart in restarts) {
[17:39:21.380]                             name <- restart$name
[17:39:21.380]                             if (is.null(name)) 
[17:39:21.380]                               next
[17:39:21.380]                             if (!grepl(pattern, name)) 
[17:39:21.380]                               next
[17:39:21.380]                             invokeRestart(restart)
[17:39:21.380]                             muffled <- TRUE
[17:39:21.380]                             break
[17:39:21.380]                           }
[17:39:21.380]                         }
[17:39:21.380]                       }
[17:39:21.380]                       invisible(muffled)
[17:39:21.380]                     }
[17:39:21.380]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.380]                   }
[17:39:21.380]                 }
[17:39:21.380]             }
[17:39:21.380]         }))
[17:39:21.380]     }, error = function(ex) {
[17:39:21.380]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.380]                 ...future.rng), started = ...future.startTime, 
[17:39:21.380]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.380]             version = "1.8"), class = "FutureResult")
[17:39:21.380]     }, finally = {
[17:39:21.380]         if (!identical(...future.workdir, getwd())) 
[17:39:21.380]             setwd(...future.workdir)
[17:39:21.380]         {
[17:39:21.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.380]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.380]             }
[17:39:21.380]             base::options(...future.oldOptions)
[17:39:21.380]             if (.Platform$OS.type == "windows") {
[17:39:21.380]                 old_names <- names(...future.oldEnvVars)
[17:39:21.380]                 envs <- base::Sys.getenv()
[17:39:21.380]                 names <- names(envs)
[17:39:21.380]                 common <- intersect(names, old_names)
[17:39:21.380]                 added <- setdiff(names, old_names)
[17:39:21.380]                 removed <- setdiff(old_names, names)
[17:39:21.380]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.380]                   envs[common]]
[17:39:21.380]                 NAMES <- toupper(changed)
[17:39:21.380]                 args <- list()
[17:39:21.380]                 for (kk in seq_along(NAMES)) {
[17:39:21.380]                   name <- changed[[kk]]
[17:39:21.380]                   NAME <- NAMES[[kk]]
[17:39:21.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.380]                     next
[17:39:21.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.380]                 }
[17:39:21.380]                 NAMES <- toupper(added)
[17:39:21.380]                 for (kk in seq_along(NAMES)) {
[17:39:21.380]                   name <- added[[kk]]
[17:39:21.380]                   NAME <- NAMES[[kk]]
[17:39:21.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.380]                     next
[17:39:21.380]                   args[[name]] <- ""
[17:39:21.380]                 }
[17:39:21.380]                 NAMES <- toupper(removed)
[17:39:21.380]                 for (kk in seq_along(NAMES)) {
[17:39:21.380]                   name <- removed[[kk]]
[17:39:21.380]                   NAME <- NAMES[[kk]]
[17:39:21.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.380]                     next
[17:39:21.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.380]                 }
[17:39:21.380]                 if (length(args) > 0) 
[17:39:21.380]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.380]             }
[17:39:21.380]             else {
[17:39:21.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.380]             }
[17:39:21.380]             {
[17:39:21.380]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.380]                   0L) {
[17:39:21.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.380]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.380]                   base::options(opts)
[17:39:21.380]                 }
[17:39:21.380]                 {
[17:39:21.380]                   {
[17:39:21.380]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.380]                     NULL
[17:39:21.380]                   }
[17:39:21.380]                   options(future.plan = NULL)
[17:39:21.380]                   if (is.na(NA_character_)) 
[17:39:21.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.380]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.380]                     envir = parent.frame()) 
[17:39:21.380]                   {
[17:39:21.380]                     default_workers <- missing(workers)
[17:39:21.380]                     if (is.function(workers)) 
[17:39:21.380]                       workers <- workers()
[17:39:21.380]                     workers <- structure(as.integer(workers), 
[17:39:21.380]                       class = class(workers))
[17:39:21.380]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.380]                       1L)
[17:39:21.380]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.380]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.380]                       if (default_workers) 
[17:39:21.380]                         supportsMulticore(warn = TRUE)
[17:39:21.380]                       return(sequential(..., envir = envir))
[17:39:21.380]                     }
[17:39:21.380]                     oopts <- options(mc.cores = workers)
[17:39:21.380]                     on.exit(options(oopts))
[17:39:21.380]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.380]                       envir = envir)
[17:39:21.380]                     if (!future$lazy) 
[17:39:21.380]                       future <- run(future)
[17:39:21.380]                     invisible(future)
[17:39:21.380]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.380]                 }
[17:39:21.380]             }
[17:39:21.380]         }
[17:39:21.380]     })
[17:39:21.380]     if (TRUE) {
[17:39:21.380]         base::sink(type = "output", split = FALSE)
[17:39:21.380]         if (TRUE) {
[17:39:21.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.380]         }
[17:39:21.380]         else {
[17:39:21.380]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.380]         }
[17:39:21.380]         base::close(...future.stdout)
[17:39:21.380]         ...future.stdout <- NULL
[17:39:21.380]     }
[17:39:21.380]     ...future.result$conditions <- ...future.conditions
[17:39:21.380]     ...future.result$finished <- base::Sys.time()
[17:39:21.380]     ...future.result
[17:39:21.380] }
[17:39:21.382] assign_globals() ...
[17:39:21.383] List of 5
[17:39:21.383]  $ future.call.arguments    : list()
[17:39:21.383]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.383]  $ ...future.FUN            :function (x)  
[17:39:21.383]  $ ...future.elements_ii    :List of 1
[17:39:21.383]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[17:39:21.383]  $ ...future.seeds_ii       : NULL
[17:39:21.383]  $ ...future.globals.maxSize: NULL
[17:39:21.383]  - attr(*, "where")=List of 5
[17:39:21.383]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.383]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.383]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.383]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.383]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.383]  - attr(*, "resolved")= logi FALSE
[17:39:21.383]  - attr(*, "total_size")= num NA
[17:39:21.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.383]  - attr(*, "already-done")= logi TRUE
[17:39:21.387] - copied ‘future.call.arguments’ to environment
[17:39:21.388] - copied ‘...future.FUN’ to environment
[17:39:21.388] - copied ‘...future.elements_ii’ to environment
[17:39:21.388] - copied ‘...future.seeds_ii’ to environment
[17:39:21.388] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.388] assign_globals() ... done
[17:39:21.388] requestCore(): workers = 2
[17:39:21.391] MulticoreFuture started
[17:39:21.391] - Launch lazy future ... done
[17:39:21.391] run() for ‘MulticoreFuture’ ... done
[17:39:21.391] plan(): Setting new future strategy stack:
[17:39:21.392] Created future:
[17:39:21.392] List of future strategies:
[17:39:21.392] 1. sequential:
[17:39:21.392]    - args: function (..., envir = parent.frame())
[17:39:21.392]    - tweaked: FALSE
[17:39:21.392]    - call: NULL
[17:39:21.393] plan(): nbrOfWorkers() = 1
[17:39:21.395] plan(): Setting new future strategy stack:
[17:39:21.395] List of future strategies:
[17:39:21.395] 1. multicore:
[17:39:21.395]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.395]    - tweaked: FALSE
[17:39:21.395]    - call: plan(strategy)
[17:39:21.400] plan(): nbrOfWorkers() = 2
[17:39:21.392] MulticoreFuture:
[17:39:21.392] Label: ‘future_apply-1’
[17:39:21.392] Expression:
[17:39:21.392] {
[17:39:21.392]     do.call(function(...) {
[17:39:21.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.392]             on.exit(options(oopts), add = TRUE)
[17:39:21.392]         }
[17:39:21.392]         {
[17:39:21.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.392]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.392]             })
[17:39:21.392]         }
[17:39:21.392]     }, args = future.call.arguments)
[17:39:21.392] }
[17:39:21.392] Lazy evaluation: FALSE
[17:39:21.392] Asynchronous evaluation: TRUE
[17:39:21.392] Local evaluation: TRUE
[17:39:21.392] Environment: R_GlobalEnv
[17:39:21.392] Capture standard output: TRUE
[17:39:21.392] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.392] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:21.392] Packages: <none>
[17:39:21.392] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.392] Resolved: TRUE
[17:39:21.392] Value: <not collected>
[17:39:21.392] Conditions captured: <none>
[17:39:21.392] Early signaling: FALSE
[17:39:21.392] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.392] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.401] Chunk #1 of 2 ... DONE
[17:39:21.401] Chunk #2 of 2 ...
[17:39:21.401]  - seeds: <none>
[17:39:21.402] getGlobalsAndPackages() ...
[17:39:21.402] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.402] Resolving globals: FALSE
[17:39:21.402] Tweak future expression to call with '...' arguments ...
[17:39:21.402] {
[17:39:21.402]     do.call(function(...) {
[17:39:21.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.402]             on.exit(options(oopts), add = TRUE)
[17:39:21.402]         }
[17:39:21.402]         {
[17:39:21.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.402]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.402]             })
[17:39:21.402]         }
[17:39:21.402]     }, args = future.call.arguments)
[17:39:21.402] }
[17:39:21.403] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.403] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.404] 
[17:39:21.404] getGlobalsAndPackages() ... DONE
[17:39:21.404] run() for ‘Future’ ...
[17:39:21.404] - state: ‘created’
[17:39:21.405] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.409] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.409]   - Field: ‘label’
[17:39:21.410]   - Field: ‘local’
[17:39:21.410]   - Field: ‘owner’
[17:39:21.410]   - Field: ‘envir’
[17:39:21.410]   - Field: ‘workers’
[17:39:21.410]   - Field: ‘packages’
[17:39:21.410]   - Field: ‘gc’
[17:39:21.411]   - Field: ‘job’
[17:39:21.411]   - Field: ‘conditions’
[17:39:21.411]   - Field: ‘expr’
[17:39:21.411]   - Field: ‘uuid’
[17:39:21.411]   - Field: ‘seed’
[17:39:21.411]   - Field: ‘version’
[17:39:21.412]   - Field: ‘result’
[17:39:21.412]   - Field: ‘asynchronous’
[17:39:21.412]   - Field: ‘calls’
[17:39:21.412]   - Field: ‘globals’
[17:39:21.412]   - Field: ‘stdout’
[17:39:21.412]   - Field: ‘earlySignal’
[17:39:21.412]   - Field: ‘lazy’
[17:39:21.413]   - Field: ‘state’
[17:39:21.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.416] - Launch lazy future ...
[17:39:21.417] Packages needed by the future expression (n = 0): <none>
[17:39:21.417] Packages needed by future strategies (n = 0): <none>
[17:39:21.419] {
[17:39:21.419]     {
[17:39:21.419]         {
[17:39:21.419]             ...future.startTime <- base::Sys.time()
[17:39:21.419]             {
[17:39:21.419]                 {
[17:39:21.419]                   {
[17:39:21.419]                     {
[17:39:21.419]                       base::local({
[17:39:21.419]                         has_future <- base::requireNamespace("future", 
[17:39:21.419]                           quietly = TRUE)
[17:39:21.419]                         if (has_future) {
[17:39:21.419]                           ns <- base::getNamespace("future")
[17:39:21.419]                           version <- ns[[".package"]][["version"]]
[17:39:21.419]                           if (is.null(version)) 
[17:39:21.419]                             version <- utils::packageVersion("future")
[17:39:21.419]                         }
[17:39:21.419]                         else {
[17:39:21.419]                           version <- NULL
[17:39:21.419]                         }
[17:39:21.419]                         if (!has_future || version < "1.8.0") {
[17:39:21.419]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.419]                             "", base::R.version$version.string), 
[17:39:21.419]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.419]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.419]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.419]                               "release", "version")], collapse = " "), 
[17:39:21.419]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.419]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.419]                             info)
[17:39:21.419]                           info <- base::paste(info, collapse = "; ")
[17:39:21.419]                           if (!has_future) {
[17:39:21.419]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.419]                               info)
[17:39:21.419]                           }
[17:39:21.419]                           else {
[17:39:21.419]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.419]                               info, version)
[17:39:21.419]                           }
[17:39:21.419]                           base::stop(msg)
[17:39:21.419]                         }
[17:39:21.419]                       })
[17:39:21.419]                     }
[17:39:21.419]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.419]                     base::options(mc.cores = 1L)
[17:39:21.419]                   }
[17:39:21.419]                   options(future.plan = NULL)
[17:39:21.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.419]                 }
[17:39:21.419]                 ...future.workdir <- getwd()
[17:39:21.419]             }
[17:39:21.419]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.419]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.419]         }
[17:39:21.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.419]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.419]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.419]             base::names(...future.oldOptions))
[17:39:21.419]     }
[17:39:21.419]     if (FALSE) {
[17:39:21.419]     }
[17:39:21.419]     else {
[17:39:21.419]         if (TRUE) {
[17:39:21.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.419]                 open = "w")
[17:39:21.419]         }
[17:39:21.419]         else {
[17:39:21.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.419]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.419]         }
[17:39:21.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.419]             base::sink(type = "output", split = FALSE)
[17:39:21.419]             base::close(...future.stdout)
[17:39:21.419]         }, add = TRUE)
[17:39:21.419]     }
[17:39:21.419]     ...future.frame <- base::sys.nframe()
[17:39:21.419]     ...future.conditions <- base::list()
[17:39:21.419]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.419]     if (FALSE) {
[17:39:21.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.419]     }
[17:39:21.419]     ...future.result <- base::tryCatch({
[17:39:21.419]         base::withCallingHandlers({
[17:39:21.419]             ...future.value <- base::withVisible(base::local({
[17:39:21.419]                 withCallingHandlers({
[17:39:21.419]                   {
[17:39:21.419]                     do.call(function(...) {
[17:39:21.419]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.419]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.419]                         ...future.globals.maxSize)) {
[17:39:21.419]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.419]                         on.exit(options(oopts), add = TRUE)
[17:39:21.419]                       }
[17:39:21.419]                       {
[17:39:21.419]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.419]                           FUN = function(jj) {
[17:39:21.419]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.419]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.419]                           })
[17:39:21.419]                       }
[17:39:21.419]                     }, args = future.call.arguments)
[17:39:21.419]                   }
[17:39:21.419]                 }, immediateCondition = function(cond) {
[17:39:21.419]                   save_rds <- function (object, pathname, ...) 
[17:39:21.419]                   {
[17:39:21.419]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.419]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.419]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.419]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.419]                         fi_tmp[["mtime"]])
[17:39:21.419]                     }
[17:39:21.419]                     tryCatch({
[17:39:21.419]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.419]                     }, error = function(ex) {
[17:39:21.419]                       msg <- conditionMessage(ex)
[17:39:21.419]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.419]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.419]                         fi_tmp[["mtime"]], msg)
[17:39:21.419]                       ex$message <- msg
[17:39:21.419]                       stop(ex)
[17:39:21.419]                     })
[17:39:21.419]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.419]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.419]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.419]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.419]                       fi <- file.info(pathname)
[17:39:21.419]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.419]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.419]                         fi[["size"]], fi[["mtime"]])
[17:39:21.419]                       stop(msg)
[17:39:21.419]                     }
[17:39:21.419]                     invisible(pathname)
[17:39:21.419]                   }
[17:39:21.419]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.419]                     rootPath = tempdir()) 
[17:39:21.419]                   {
[17:39:21.419]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.419]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.419]                       tmpdir = path, fileext = ".rds")
[17:39:21.419]                     save_rds(obj, file)
[17:39:21.419]                   }
[17:39:21.419]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.419]                   {
[17:39:21.419]                     inherits <- base::inherits
[17:39:21.419]                     invokeRestart <- base::invokeRestart
[17:39:21.419]                     is.null <- base::is.null
[17:39:21.419]                     muffled <- FALSE
[17:39:21.419]                     if (inherits(cond, "message")) {
[17:39:21.419]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.419]                       if (muffled) 
[17:39:21.419]                         invokeRestart("muffleMessage")
[17:39:21.419]                     }
[17:39:21.419]                     else if (inherits(cond, "warning")) {
[17:39:21.419]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.419]                       if (muffled) 
[17:39:21.419]                         invokeRestart("muffleWarning")
[17:39:21.419]                     }
[17:39:21.419]                     else if (inherits(cond, "condition")) {
[17:39:21.419]                       if (!is.null(pattern)) {
[17:39:21.419]                         computeRestarts <- base::computeRestarts
[17:39:21.419]                         grepl <- base::grepl
[17:39:21.419]                         restarts <- computeRestarts(cond)
[17:39:21.419]                         for (restart in restarts) {
[17:39:21.419]                           name <- restart$name
[17:39:21.419]                           if (is.null(name)) 
[17:39:21.419]                             next
[17:39:21.419]                           if (!grepl(pattern, name)) 
[17:39:21.419]                             next
[17:39:21.419]                           invokeRestart(restart)
[17:39:21.419]                           muffled <- TRUE
[17:39:21.419]                           break
[17:39:21.419]                         }
[17:39:21.419]                       }
[17:39:21.419]                     }
[17:39:21.419]                     invisible(muffled)
[17:39:21.419]                   }
[17:39:21.419]                   muffleCondition(cond)
[17:39:21.419]                 })
[17:39:21.419]             }))
[17:39:21.419]             future::FutureResult(value = ...future.value$value, 
[17:39:21.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.419]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.419]                     ...future.globalenv.names))
[17:39:21.419]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.419]         }, condition = base::local({
[17:39:21.419]             c <- base::c
[17:39:21.419]             inherits <- base::inherits
[17:39:21.419]             invokeRestart <- base::invokeRestart
[17:39:21.419]             length <- base::length
[17:39:21.419]             list <- base::list
[17:39:21.419]             seq.int <- base::seq.int
[17:39:21.419]             signalCondition <- base::signalCondition
[17:39:21.419]             sys.calls <- base::sys.calls
[17:39:21.419]             `[[` <- base::`[[`
[17:39:21.419]             `+` <- base::`+`
[17:39:21.419]             `<<-` <- base::`<<-`
[17:39:21.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.419]                   3L)]
[17:39:21.419]             }
[17:39:21.419]             function(cond) {
[17:39:21.419]                 is_error <- inherits(cond, "error")
[17:39:21.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.419]                   NULL)
[17:39:21.419]                 if (is_error) {
[17:39:21.419]                   sessionInformation <- function() {
[17:39:21.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.419]                       search = base::search(), system = base::Sys.info())
[17:39:21.419]                   }
[17:39:21.419]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.419]                     cond$call), session = sessionInformation(), 
[17:39:21.419]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.419]                   signalCondition(cond)
[17:39:21.419]                 }
[17:39:21.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.419]                 "immediateCondition"))) {
[17:39:21.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.419]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.419]                   if (TRUE && !signal) {
[17:39:21.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.419]                     {
[17:39:21.419]                       inherits <- base::inherits
[17:39:21.419]                       invokeRestart <- base::invokeRestart
[17:39:21.419]                       is.null <- base::is.null
[17:39:21.419]                       muffled <- FALSE
[17:39:21.419]                       if (inherits(cond, "message")) {
[17:39:21.419]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.419]                         if (muffled) 
[17:39:21.419]                           invokeRestart("muffleMessage")
[17:39:21.419]                       }
[17:39:21.419]                       else if (inherits(cond, "warning")) {
[17:39:21.419]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.419]                         if (muffled) 
[17:39:21.419]                           invokeRestart("muffleWarning")
[17:39:21.419]                       }
[17:39:21.419]                       else if (inherits(cond, "condition")) {
[17:39:21.419]                         if (!is.null(pattern)) {
[17:39:21.419]                           computeRestarts <- base::computeRestarts
[17:39:21.419]                           grepl <- base::grepl
[17:39:21.419]                           restarts <- computeRestarts(cond)
[17:39:21.419]                           for (restart in restarts) {
[17:39:21.419]                             name <- restart$name
[17:39:21.419]                             if (is.null(name)) 
[17:39:21.419]                               next
[17:39:21.419]                             if (!grepl(pattern, name)) 
[17:39:21.419]                               next
[17:39:21.419]                             invokeRestart(restart)
[17:39:21.419]                             muffled <- TRUE
[17:39:21.419]                             break
[17:39:21.419]                           }
[17:39:21.419]                         }
[17:39:21.419]                       }
[17:39:21.419]                       invisible(muffled)
[17:39:21.419]                     }
[17:39:21.419]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.419]                   }
[17:39:21.419]                 }
[17:39:21.419]                 else {
[17:39:21.419]                   if (TRUE) {
[17:39:21.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.419]                     {
[17:39:21.419]                       inherits <- base::inherits
[17:39:21.419]                       invokeRestart <- base::invokeRestart
[17:39:21.419]                       is.null <- base::is.null
[17:39:21.419]                       muffled <- FALSE
[17:39:21.419]                       if (inherits(cond, "message")) {
[17:39:21.419]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.419]                         if (muffled) 
[17:39:21.419]                           invokeRestart("muffleMessage")
[17:39:21.419]                       }
[17:39:21.419]                       else if (inherits(cond, "warning")) {
[17:39:21.419]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.419]                         if (muffled) 
[17:39:21.419]                           invokeRestart("muffleWarning")
[17:39:21.419]                       }
[17:39:21.419]                       else if (inherits(cond, "condition")) {
[17:39:21.419]                         if (!is.null(pattern)) {
[17:39:21.419]                           computeRestarts <- base::computeRestarts
[17:39:21.419]                           grepl <- base::grepl
[17:39:21.419]                           restarts <- computeRestarts(cond)
[17:39:21.419]                           for (restart in restarts) {
[17:39:21.419]                             name <- restart$name
[17:39:21.419]                             if (is.null(name)) 
[17:39:21.419]                               next
[17:39:21.419]                             if (!grepl(pattern, name)) 
[17:39:21.419]                               next
[17:39:21.419]                             invokeRestart(restart)
[17:39:21.419]                             muffled <- TRUE
[17:39:21.419]                             break
[17:39:21.419]                           }
[17:39:21.419]                         }
[17:39:21.419]                       }
[17:39:21.419]                       invisible(muffled)
[17:39:21.419]                     }
[17:39:21.419]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.419]                   }
[17:39:21.419]                 }
[17:39:21.419]             }
[17:39:21.419]         }))
[17:39:21.419]     }, error = function(ex) {
[17:39:21.419]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.419]                 ...future.rng), started = ...future.startTime, 
[17:39:21.419]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.419]             version = "1.8"), class = "FutureResult")
[17:39:21.419]     }, finally = {
[17:39:21.419]         if (!identical(...future.workdir, getwd())) 
[17:39:21.419]             setwd(...future.workdir)
[17:39:21.419]         {
[17:39:21.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.419]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.419]             }
[17:39:21.419]             base::options(...future.oldOptions)
[17:39:21.419]             if (.Platform$OS.type == "windows") {
[17:39:21.419]                 old_names <- names(...future.oldEnvVars)
[17:39:21.419]                 envs <- base::Sys.getenv()
[17:39:21.419]                 names <- names(envs)
[17:39:21.419]                 common <- intersect(names, old_names)
[17:39:21.419]                 added <- setdiff(names, old_names)
[17:39:21.419]                 removed <- setdiff(old_names, names)
[17:39:21.419]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.419]                   envs[common]]
[17:39:21.419]                 NAMES <- toupper(changed)
[17:39:21.419]                 args <- list()
[17:39:21.419]                 for (kk in seq_along(NAMES)) {
[17:39:21.419]                   name <- changed[[kk]]
[17:39:21.419]                   NAME <- NAMES[[kk]]
[17:39:21.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.419]                     next
[17:39:21.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.419]                 }
[17:39:21.419]                 NAMES <- toupper(added)
[17:39:21.419]                 for (kk in seq_along(NAMES)) {
[17:39:21.419]                   name <- added[[kk]]
[17:39:21.419]                   NAME <- NAMES[[kk]]
[17:39:21.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.419]                     next
[17:39:21.419]                   args[[name]] <- ""
[17:39:21.419]                 }
[17:39:21.419]                 NAMES <- toupper(removed)
[17:39:21.419]                 for (kk in seq_along(NAMES)) {
[17:39:21.419]                   name <- removed[[kk]]
[17:39:21.419]                   NAME <- NAMES[[kk]]
[17:39:21.419]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.419]                     next
[17:39:21.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.419]                 }
[17:39:21.419]                 if (length(args) > 0) 
[17:39:21.419]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.419]             }
[17:39:21.419]             else {
[17:39:21.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.419]             }
[17:39:21.419]             {
[17:39:21.419]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.419]                   0L) {
[17:39:21.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.419]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.419]                   base::options(opts)
[17:39:21.419]                 }
[17:39:21.419]                 {
[17:39:21.419]                   {
[17:39:21.419]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.419]                     NULL
[17:39:21.419]                   }
[17:39:21.419]                   options(future.plan = NULL)
[17:39:21.419]                   if (is.na(NA_character_)) 
[17:39:21.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.419]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.419]                     envir = parent.frame()) 
[17:39:21.419]                   {
[17:39:21.419]                     default_workers <- missing(workers)
[17:39:21.419]                     if (is.function(workers)) 
[17:39:21.419]                       workers <- workers()
[17:39:21.419]                     workers <- structure(as.integer(workers), 
[17:39:21.419]                       class = class(workers))
[17:39:21.419]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.419]                       1L)
[17:39:21.419]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.419]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.419]                       if (default_workers) 
[17:39:21.419]                         supportsMulticore(warn = TRUE)
[17:39:21.419]                       return(sequential(..., envir = envir))
[17:39:21.419]                     }
[17:39:21.419]                     oopts <- options(mc.cores = workers)
[17:39:21.419]                     on.exit(options(oopts))
[17:39:21.419]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.419]                       envir = envir)
[17:39:21.419]                     if (!future$lazy) 
[17:39:21.419]                       future <- run(future)
[17:39:21.419]                     invisible(future)
[17:39:21.419]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.419]                 }
[17:39:21.419]             }
[17:39:21.419]         }
[17:39:21.419]     })
[17:39:21.419]     if (TRUE) {
[17:39:21.419]         base::sink(type = "output", split = FALSE)
[17:39:21.419]         if (TRUE) {
[17:39:21.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.419]         }
[17:39:21.419]         else {
[17:39:21.419]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.419]         }
[17:39:21.419]         base::close(...future.stdout)
[17:39:21.419]         ...future.stdout <- NULL
[17:39:21.419]     }
[17:39:21.419]     ...future.result$conditions <- ...future.conditions
[17:39:21.419]     ...future.result$finished <- base::Sys.time()
[17:39:21.419]     ...future.result
[17:39:21.419] }
[17:39:21.422] assign_globals() ...
[17:39:21.422] List of 5
[17:39:21.422]  $ future.call.arguments    : list()
[17:39:21.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.422]  $ ...future.FUN            :function (x)  
[17:39:21.422]  $ ...future.elements_ii    :List of 1
[17:39:21.422]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[17:39:21.422]  $ ...future.seeds_ii       : NULL
[17:39:21.422]  $ ...future.globals.maxSize: NULL
[17:39:21.422]  - attr(*, "where")=List of 5
[17:39:21.422]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.422]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.422]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.422]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.422]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.422]  - attr(*, "resolved")= logi FALSE
[17:39:21.422]  - attr(*, "total_size")= num NA
[17:39:21.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.422]  - attr(*, "already-done")= logi TRUE
[17:39:21.431] - copied ‘future.call.arguments’ to environment
[17:39:21.431] - copied ‘...future.FUN’ to environment
[17:39:21.431] - copied ‘...future.elements_ii’ to environment
[17:39:21.432] - copied ‘...future.seeds_ii’ to environment
[17:39:21.432] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.432] assign_globals() ... done
[17:39:21.432] requestCore(): workers = 2
[17:39:21.434] MulticoreFuture started
[17:39:21.435] - Launch lazy future ... done
[17:39:21.435] run() for ‘MulticoreFuture’ ... done
[17:39:21.435] Created future:
[17:39:21.435] plan(): Setting new future strategy stack:
[17:39:21.436] List of future strategies:
[17:39:21.436] 1. sequential:
[17:39:21.436]    - args: function (..., envir = parent.frame())
[17:39:21.436]    - tweaked: FALSE
[17:39:21.436]    - call: NULL
[17:39:21.437] plan(): nbrOfWorkers() = 1
[17:39:21.439] plan(): Setting new future strategy stack:
[17:39:21.439] List of future strategies:
[17:39:21.439] 1. multicore:
[17:39:21.439]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.439]    - tweaked: FALSE
[17:39:21.439]    - call: plan(strategy)
[17:39:21.444] plan(): nbrOfWorkers() = 2
[17:39:21.436] MulticoreFuture:
[17:39:21.436] Label: ‘future_apply-2’
[17:39:21.436] Expression:
[17:39:21.436] {
[17:39:21.436]     do.call(function(...) {
[17:39:21.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.436]             on.exit(options(oopts), add = TRUE)
[17:39:21.436]         }
[17:39:21.436]         {
[17:39:21.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.436]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.436]             })
[17:39:21.436]         }
[17:39:21.436]     }, args = future.call.arguments)
[17:39:21.436] }
[17:39:21.436] Lazy evaluation: FALSE
[17:39:21.436] Asynchronous evaluation: TRUE
[17:39:21.436] Local evaluation: TRUE
[17:39:21.436] Environment: R_GlobalEnv
[17:39:21.436] Capture standard output: TRUE
[17:39:21.436] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.436] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:21.436] Packages: <none>
[17:39:21.436] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.436] Resolved: TRUE
[17:39:21.436] Value: <not collected>
[17:39:21.436] Conditions captured: <none>
[17:39:21.436] Early signaling: FALSE
[17:39:21.436] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.436] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.445] Chunk #2 of 2 ... DONE
[17:39:21.445] Launching 2 futures (chunks) ... DONE
[17:39:21.445] Resolving 2 futures (chunks) ...
[17:39:21.445] resolve() on list ...
[17:39:21.445]  recursive: 0
[17:39:21.446]  length: 2
[17:39:21.446] 
[17:39:21.446] Future #1
[17:39:21.447] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:21.447] - nx: 2
[17:39:21.447] - relay: TRUE
[17:39:21.448] - stdout: TRUE
[17:39:21.448] - signal: TRUE
[17:39:21.448] - resignal: FALSE
[17:39:21.448] - force: TRUE
[17:39:21.448] - relayed: [n=2] FALSE, FALSE
[17:39:21.448] - queued futures: [n=2] FALSE, FALSE
[17:39:21.448]  - until=1
[17:39:21.449]  - relaying element #1
[17:39:21.449] - relayed: [n=2] TRUE, FALSE
[17:39:21.449] - queued futures: [n=2] TRUE, FALSE
[17:39:21.449] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:21.449]  length: 1 (resolved future 1)
[17:39:21.450] Future #2
[17:39:21.450] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:21.451] - nx: 2
[17:39:21.451] - relay: TRUE
[17:39:21.451] - stdout: TRUE
[17:39:21.451] - signal: TRUE
[17:39:21.451] - resignal: FALSE
[17:39:21.451] - force: TRUE
[17:39:21.451] - relayed: [n=2] TRUE, FALSE
[17:39:21.452] - queued futures: [n=2] TRUE, FALSE
[17:39:21.452]  - until=2
[17:39:21.452]  - relaying element #2
[17:39:21.452] - relayed: [n=2] TRUE, TRUE
[17:39:21.452] - queued futures: [n=2] TRUE, TRUE
[17:39:21.452] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:21.452]  length: 0 (resolved future 2)
[17:39:21.453] Relaying remaining futures
[17:39:21.453] signalConditionsASAP(NULL, pos=0) ...
[17:39:21.453] - nx: 2
[17:39:21.453] - relay: TRUE
[17:39:21.453] - stdout: TRUE
[17:39:21.453] - signal: TRUE
[17:39:21.453] - resignal: FALSE
[17:39:21.453] - force: TRUE
[17:39:21.453] - relayed: [n=2] TRUE, TRUE
[17:39:21.453] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:21.454] - relayed: [n=2] TRUE, TRUE
[17:39:21.454] - queued futures: [n=2] TRUE, TRUE
[17:39:21.454] signalConditionsASAP(NULL, pos=0) ... done
[17:39:21.454] resolve() on list ... DONE
[17:39:21.454]  - Number of value chunks collected: 2
[17:39:21.454] Resolving 2 futures (chunks) ... DONE
[17:39:21.454] Reducing values from 2 chunks ...
[17:39:21.455]  - Number of values collected after concatenation: 2
[17:39:21.455]  - Number of values expected: 2
[17:39:21.455] Reducing values from 2 chunks ... DONE
[17:39:21.455] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:39:21.455] getGlobalsAndPackagesXApply() ...
[17:39:21.456]  - future.globals: TRUE
[17:39:21.456] getGlobalsAndPackages() ...
[17:39:21.456] Searching for globals...
[17:39:21.461] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:39:21.461] Searching for globals ... DONE
[17:39:21.462] Resolving globals: FALSE
[17:39:21.463] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:39:21.463] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:39:21.463] - globals: [1] ‘FUN’
[17:39:21.463] 
[17:39:21.464] getGlobalsAndPackages() ... DONE
[17:39:21.464]  - globals found/used: [n=1] ‘FUN’
[17:39:21.464]  - needed namespaces: [n=0] 
[17:39:21.464] Finding globals ... DONE
[17:39:21.464]  - use_args: TRUE
[17:39:21.464]  - Getting '...' globals ...
[17:39:21.465] resolve() on list ...
[17:39:21.465]  recursive: 0
[17:39:21.465]  length: 1
[17:39:21.465]  elements: ‘...’
[17:39:21.465]  length: 0 (resolved future 1)
[17:39:21.465] resolve() on list ... DONE
[17:39:21.466]    - '...' content: [n=0] 
[17:39:21.466] List of 1
[17:39:21.466]  $ ...: list()
[17:39:21.466]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.466]  - attr(*, "where")=List of 1
[17:39:21.466]   ..$ ...:<environment: 0x55c796bcf480> 
[17:39:21.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.466]  - attr(*, "resolved")= logi TRUE
[17:39:21.466]  - attr(*, "total_size")= num NA
[17:39:21.469]  - Getting '...' globals ... DONE
[17:39:21.469] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:21.469] List of 2
[17:39:21.469]  $ ...future.FUN:function (x)  
[17:39:21.469]  $ ...          : list()
[17:39:21.469]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.469]  - attr(*, "where")=List of 2
[17:39:21.469]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:21.469]   ..$ ...          :<environment: 0x55c796bcf480> 
[17:39:21.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.469]  - attr(*, "resolved")= logi FALSE
[17:39:21.469]  - attr(*, "total_size")= num 9888
[17:39:21.472] Packages to be attached in all futures: [n=0] 
[17:39:21.472] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.476] future_lapply() ...
[17:39:21.481] Number of chunks: 2
[17:39:21.481] getGlobalsAndPackagesXApply() ...
[17:39:21.481]  - future.globals: <name-value list> with names ‘list()’
[17:39:21.481]  - use_args: TRUE
[17:39:21.481] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:21.481] List of 2
[17:39:21.481]  $ ...          : list()
[17:39:21.481]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.481]  $ ...future.FUN:function (x)  
[17:39:21.481]  - attr(*, "where")=List of 2
[17:39:21.481]   ..$ ...          :<environment: 0x55c796bcf480> 
[17:39:21.481]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:39:21.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.481]  - attr(*, "resolved")= logi FALSE
[17:39:21.481]  - attr(*, "total_size")= num NA
[17:39:21.484] Packages to be attached in all futures: [n=0] 
[17:39:21.484] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.484] Number of futures (= number of chunks): 2
[17:39:21.484] Launching 2 futures (chunks) ...
[17:39:21.485] Chunk #1 of 2 ...
[17:39:21.485]  - seeds: <none>
[17:39:21.485] getGlobalsAndPackages() ...
[17:39:21.485] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.485] Resolving globals: FALSE
[17:39:21.485] Tweak future expression to call with '...' arguments ...
[17:39:21.485] {
[17:39:21.485]     do.call(function(...) {
[17:39:21.485]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.485]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.485]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.485]             on.exit(options(oopts), add = TRUE)
[17:39:21.485]         }
[17:39:21.485]         {
[17:39:21.485]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.485]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.485]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.485]             })
[17:39:21.485]         }
[17:39:21.485]     }, args = future.call.arguments)
[17:39:21.485] }
[17:39:21.486] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.486] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.486] 
[17:39:21.486] getGlobalsAndPackages() ... DONE
[17:39:21.486] run() for ‘Future’ ...
[17:39:21.488] - state: ‘created’
[17:39:21.488] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.492] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.492]   - Field: ‘label’
[17:39:21.492]   - Field: ‘local’
[17:39:21.492]   - Field: ‘owner’
[17:39:21.492]   - Field: ‘envir’
[17:39:21.493]   - Field: ‘workers’
[17:39:21.493]   - Field: ‘packages’
[17:39:21.493]   - Field: ‘gc’
[17:39:21.493]   - Field: ‘job’
[17:39:21.493]   - Field: ‘conditions’
[17:39:21.493]   - Field: ‘expr’
[17:39:21.493]   - Field: ‘uuid’
[17:39:21.493]   - Field: ‘seed’
[17:39:21.493]   - Field: ‘version’
[17:39:21.493]   - Field: ‘result’
[17:39:21.494]   - Field: ‘asynchronous’
[17:39:21.494]   - Field: ‘calls’
[17:39:21.494]   - Field: ‘globals’
[17:39:21.494]   - Field: ‘stdout’
[17:39:21.494]   - Field: ‘earlySignal’
[17:39:21.494]   - Field: ‘lazy’
[17:39:21.494]   - Field: ‘state’
[17:39:21.494] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.494] - Launch lazy future ...
[17:39:21.495] Packages needed by the future expression (n = 0): <none>
[17:39:21.495] Packages needed by future strategies (n = 0): <none>
[17:39:21.495] {
[17:39:21.495]     {
[17:39:21.495]         {
[17:39:21.495]             ...future.startTime <- base::Sys.time()
[17:39:21.495]             {
[17:39:21.495]                 {
[17:39:21.495]                   {
[17:39:21.495]                     {
[17:39:21.495]                       base::local({
[17:39:21.495]                         has_future <- base::requireNamespace("future", 
[17:39:21.495]                           quietly = TRUE)
[17:39:21.495]                         if (has_future) {
[17:39:21.495]                           ns <- base::getNamespace("future")
[17:39:21.495]                           version <- ns[[".package"]][["version"]]
[17:39:21.495]                           if (is.null(version)) 
[17:39:21.495]                             version <- utils::packageVersion("future")
[17:39:21.495]                         }
[17:39:21.495]                         else {
[17:39:21.495]                           version <- NULL
[17:39:21.495]                         }
[17:39:21.495]                         if (!has_future || version < "1.8.0") {
[17:39:21.495]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.495]                             "", base::R.version$version.string), 
[17:39:21.495]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.495]                               "release", "version")], collapse = " "), 
[17:39:21.495]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.495]                             info)
[17:39:21.495]                           info <- base::paste(info, collapse = "; ")
[17:39:21.495]                           if (!has_future) {
[17:39:21.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.495]                               info)
[17:39:21.495]                           }
[17:39:21.495]                           else {
[17:39:21.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.495]                               info, version)
[17:39:21.495]                           }
[17:39:21.495]                           base::stop(msg)
[17:39:21.495]                         }
[17:39:21.495]                       })
[17:39:21.495]                     }
[17:39:21.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.495]                     base::options(mc.cores = 1L)
[17:39:21.495]                   }
[17:39:21.495]                   options(future.plan = NULL)
[17:39:21.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.495]                 }
[17:39:21.495]                 ...future.workdir <- getwd()
[17:39:21.495]             }
[17:39:21.495]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.495]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.495]         }
[17:39:21.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.495]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.495]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.495]             base::names(...future.oldOptions))
[17:39:21.495]     }
[17:39:21.495]     if (FALSE) {
[17:39:21.495]     }
[17:39:21.495]     else {
[17:39:21.495]         if (TRUE) {
[17:39:21.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.495]                 open = "w")
[17:39:21.495]         }
[17:39:21.495]         else {
[17:39:21.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.495]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.495]         }
[17:39:21.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.495]             base::sink(type = "output", split = FALSE)
[17:39:21.495]             base::close(...future.stdout)
[17:39:21.495]         }, add = TRUE)
[17:39:21.495]     }
[17:39:21.495]     ...future.frame <- base::sys.nframe()
[17:39:21.495]     ...future.conditions <- base::list()
[17:39:21.495]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.495]     if (FALSE) {
[17:39:21.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.495]     }
[17:39:21.495]     ...future.result <- base::tryCatch({
[17:39:21.495]         base::withCallingHandlers({
[17:39:21.495]             ...future.value <- base::withVisible(base::local({
[17:39:21.495]                 withCallingHandlers({
[17:39:21.495]                   {
[17:39:21.495]                     do.call(function(...) {
[17:39:21.495]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.495]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.495]                         ...future.globals.maxSize)) {
[17:39:21.495]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.495]                         on.exit(options(oopts), add = TRUE)
[17:39:21.495]                       }
[17:39:21.495]                       {
[17:39:21.495]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.495]                           FUN = function(jj) {
[17:39:21.495]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.495]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.495]                           })
[17:39:21.495]                       }
[17:39:21.495]                     }, args = future.call.arguments)
[17:39:21.495]                   }
[17:39:21.495]                 }, immediateCondition = function(cond) {
[17:39:21.495]                   save_rds <- function (object, pathname, ...) 
[17:39:21.495]                   {
[17:39:21.495]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.495]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.495]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.495]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.495]                         fi_tmp[["mtime"]])
[17:39:21.495]                     }
[17:39:21.495]                     tryCatch({
[17:39:21.495]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.495]                     }, error = function(ex) {
[17:39:21.495]                       msg <- conditionMessage(ex)
[17:39:21.495]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.495]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.495]                         fi_tmp[["mtime"]], msg)
[17:39:21.495]                       ex$message <- msg
[17:39:21.495]                       stop(ex)
[17:39:21.495]                     })
[17:39:21.495]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.495]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.495]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.495]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.495]                       fi <- file.info(pathname)
[17:39:21.495]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.495]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.495]                         fi[["size"]], fi[["mtime"]])
[17:39:21.495]                       stop(msg)
[17:39:21.495]                     }
[17:39:21.495]                     invisible(pathname)
[17:39:21.495]                   }
[17:39:21.495]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.495]                     rootPath = tempdir()) 
[17:39:21.495]                   {
[17:39:21.495]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.495]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.495]                       tmpdir = path, fileext = ".rds")
[17:39:21.495]                     save_rds(obj, file)
[17:39:21.495]                   }
[17:39:21.495]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.495]                   {
[17:39:21.495]                     inherits <- base::inherits
[17:39:21.495]                     invokeRestart <- base::invokeRestart
[17:39:21.495]                     is.null <- base::is.null
[17:39:21.495]                     muffled <- FALSE
[17:39:21.495]                     if (inherits(cond, "message")) {
[17:39:21.495]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.495]                       if (muffled) 
[17:39:21.495]                         invokeRestart("muffleMessage")
[17:39:21.495]                     }
[17:39:21.495]                     else if (inherits(cond, "warning")) {
[17:39:21.495]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.495]                       if (muffled) 
[17:39:21.495]                         invokeRestart("muffleWarning")
[17:39:21.495]                     }
[17:39:21.495]                     else if (inherits(cond, "condition")) {
[17:39:21.495]                       if (!is.null(pattern)) {
[17:39:21.495]                         computeRestarts <- base::computeRestarts
[17:39:21.495]                         grepl <- base::grepl
[17:39:21.495]                         restarts <- computeRestarts(cond)
[17:39:21.495]                         for (restart in restarts) {
[17:39:21.495]                           name <- restart$name
[17:39:21.495]                           if (is.null(name)) 
[17:39:21.495]                             next
[17:39:21.495]                           if (!grepl(pattern, name)) 
[17:39:21.495]                             next
[17:39:21.495]                           invokeRestart(restart)
[17:39:21.495]                           muffled <- TRUE
[17:39:21.495]                           break
[17:39:21.495]                         }
[17:39:21.495]                       }
[17:39:21.495]                     }
[17:39:21.495]                     invisible(muffled)
[17:39:21.495]                   }
[17:39:21.495]                   muffleCondition(cond)
[17:39:21.495]                 })
[17:39:21.495]             }))
[17:39:21.495]             future::FutureResult(value = ...future.value$value, 
[17:39:21.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.495]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.495]                     ...future.globalenv.names))
[17:39:21.495]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.495]         }, condition = base::local({
[17:39:21.495]             c <- base::c
[17:39:21.495]             inherits <- base::inherits
[17:39:21.495]             invokeRestart <- base::invokeRestart
[17:39:21.495]             length <- base::length
[17:39:21.495]             list <- base::list
[17:39:21.495]             seq.int <- base::seq.int
[17:39:21.495]             signalCondition <- base::signalCondition
[17:39:21.495]             sys.calls <- base::sys.calls
[17:39:21.495]             `[[` <- base::`[[`
[17:39:21.495]             `+` <- base::`+`
[17:39:21.495]             `<<-` <- base::`<<-`
[17:39:21.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.495]                   3L)]
[17:39:21.495]             }
[17:39:21.495]             function(cond) {
[17:39:21.495]                 is_error <- inherits(cond, "error")
[17:39:21.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.495]                   NULL)
[17:39:21.495]                 if (is_error) {
[17:39:21.495]                   sessionInformation <- function() {
[17:39:21.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.495]                       search = base::search(), system = base::Sys.info())
[17:39:21.495]                   }
[17:39:21.495]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.495]                     cond$call), session = sessionInformation(), 
[17:39:21.495]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.495]                   signalCondition(cond)
[17:39:21.495]                 }
[17:39:21.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.495]                 "immediateCondition"))) {
[17:39:21.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.495]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.495]                   if (TRUE && !signal) {
[17:39:21.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.495]                     {
[17:39:21.495]                       inherits <- base::inherits
[17:39:21.495]                       invokeRestart <- base::invokeRestart
[17:39:21.495]                       is.null <- base::is.null
[17:39:21.495]                       muffled <- FALSE
[17:39:21.495]                       if (inherits(cond, "message")) {
[17:39:21.495]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.495]                         if (muffled) 
[17:39:21.495]                           invokeRestart("muffleMessage")
[17:39:21.495]                       }
[17:39:21.495]                       else if (inherits(cond, "warning")) {
[17:39:21.495]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.495]                         if (muffled) 
[17:39:21.495]                           invokeRestart("muffleWarning")
[17:39:21.495]                       }
[17:39:21.495]                       else if (inherits(cond, "condition")) {
[17:39:21.495]                         if (!is.null(pattern)) {
[17:39:21.495]                           computeRestarts <- base::computeRestarts
[17:39:21.495]                           grepl <- base::grepl
[17:39:21.495]                           restarts <- computeRestarts(cond)
[17:39:21.495]                           for (restart in restarts) {
[17:39:21.495]                             name <- restart$name
[17:39:21.495]                             if (is.null(name)) 
[17:39:21.495]                               next
[17:39:21.495]                             if (!grepl(pattern, name)) 
[17:39:21.495]                               next
[17:39:21.495]                             invokeRestart(restart)
[17:39:21.495]                             muffled <- TRUE
[17:39:21.495]                             break
[17:39:21.495]                           }
[17:39:21.495]                         }
[17:39:21.495]                       }
[17:39:21.495]                       invisible(muffled)
[17:39:21.495]                     }
[17:39:21.495]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.495]                   }
[17:39:21.495]                 }
[17:39:21.495]                 else {
[17:39:21.495]                   if (TRUE) {
[17:39:21.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.495]                     {
[17:39:21.495]                       inherits <- base::inherits
[17:39:21.495]                       invokeRestart <- base::invokeRestart
[17:39:21.495]                       is.null <- base::is.null
[17:39:21.495]                       muffled <- FALSE
[17:39:21.495]                       if (inherits(cond, "message")) {
[17:39:21.495]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.495]                         if (muffled) 
[17:39:21.495]                           invokeRestart("muffleMessage")
[17:39:21.495]                       }
[17:39:21.495]                       else if (inherits(cond, "warning")) {
[17:39:21.495]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.495]                         if (muffled) 
[17:39:21.495]                           invokeRestart("muffleWarning")
[17:39:21.495]                       }
[17:39:21.495]                       else if (inherits(cond, "condition")) {
[17:39:21.495]                         if (!is.null(pattern)) {
[17:39:21.495]                           computeRestarts <- base::computeRestarts
[17:39:21.495]                           grepl <- base::grepl
[17:39:21.495]                           restarts <- computeRestarts(cond)
[17:39:21.495]                           for (restart in restarts) {
[17:39:21.495]                             name <- restart$name
[17:39:21.495]                             if (is.null(name)) 
[17:39:21.495]                               next
[17:39:21.495]                             if (!grepl(pattern, name)) 
[17:39:21.495]                               next
[17:39:21.495]                             invokeRestart(restart)
[17:39:21.495]                             muffled <- TRUE
[17:39:21.495]                             break
[17:39:21.495]                           }
[17:39:21.495]                         }
[17:39:21.495]                       }
[17:39:21.495]                       invisible(muffled)
[17:39:21.495]                     }
[17:39:21.495]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.495]                   }
[17:39:21.495]                 }
[17:39:21.495]             }
[17:39:21.495]         }))
[17:39:21.495]     }, error = function(ex) {
[17:39:21.495]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.495]                 ...future.rng), started = ...future.startTime, 
[17:39:21.495]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.495]             version = "1.8"), class = "FutureResult")
[17:39:21.495]     }, finally = {
[17:39:21.495]         if (!identical(...future.workdir, getwd())) 
[17:39:21.495]             setwd(...future.workdir)
[17:39:21.495]         {
[17:39:21.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.495]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.495]             }
[17:39:21.495]             base::options(...future.oldOptions)
[17:39:21.495]             if (.Platform$OS.type == "windows") {
[17:39:21.495]                 old_names <- names(...future.oldEnvVars)
[17:39:21.495]                 envs <- base::Sys.getenv()
[17:39:21.495]                 names <- names(envs)
[17:39:21.495]                 common <- intersect(names, old_names)
[17:39:21.495]                 added <- setdiff(names, old_names)
[17:39:21.495]                 removed <- setdiff(old_names, names)
[17:39:21.495]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.495]                   envs[common]]
[17:39:21.495]                 NAMES <- toupper(changed)
[17:39:21.495]                 args <- list()
[17:39:21.495]                 for (kk in seq_along(NAMES)) {
[17:39:21.495]                   name <- changed[[kk]]
[17:39:21.495]                   NAME <- NAMES[[kk]]
[17:39:21.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.495]                     next
[17:39:21.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.495]                 }
[17:39:21.495]                 NAMES <- toupper(added)
[17:39:21.495]                 for (kk in seq_along(NAMES)) {
[17:39:21.495]                   name <- added[[kk]]
[17:39:21.495]                   NAME <- NAMES[[kk]]
[17:39:21.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.495]                     next
[17:39:21.495]                   args[[name]] <- ""
[17:39:21.495]                 }
[17:39:21.495]                 NAMES <- toupper(removed)
[17:39:21.495]                 for (kk in seq_along(NAMES)) {
[17:39:21.495]                   name <- removed[[kk]]
[17:39:21.495]                   NAME <- NAMES[[kk]]
[17:39:21.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.495]                     next
[17:39:21.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.495]                 }
[17:39:21.495]                 if (length(args) > 0) 
[17:39:21.495]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.495]             }
[17:39:21.495]             else {
[17:39:21.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.495]             }
[17:39:21.495]             {
[17:39:21.495]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.495]                   0L) {
[17:39:21.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.495]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.495]                   base::options(opts)
[17:39:21.495]                 }
[17:39:21.495]                 {
[17:39:21.495]                   {
[17:39:21.495]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.495]                     NULL
[17:39:21.495]                   }
[17:39:21.495]                   options(future.plan = NULL)
[17:39:21.495]                   if (is.na(NA_character_)) 
[17:39:21.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.495]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.495]                     envir = parent.frame()) 
[17:39:21.495]                   {
[17:39:21.495]                     default_workers <- missing(workers)
[17:39:21.495]                     if (is.function(workers)) 
[17:39:21.495]                       workers <- workers()
[17:39:21.495]                     workers <- structure(as.integer(workers), 
[17:39:21.495]                       class = class(workers))
[17:39:21.495]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.495]                       1L)
[17:39:21.495]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.495]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.495]                       if (default_workers) 
[17:39:21.495]                         supportsMulticore(warn = TRUE)
[17:39:21.495]                       return(sequential(..., envir = envir))
[17:39:21.495]                     }
[17:39:21.495]                     oopts <- options(mc.cores = workers)
[17:39:21.495]                     on.exit(options(oopts))
[17:39:21.495]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.495]                       envir = envir)
[17:39:21.495]                     if (!future$lazy) 
[17:39:21.495]                       future <- run(future)
[17:39:21.495]                     invisible(future)
[17:39:21.495]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.495]                 }
[17:39:21.495]             }
[17:39:21.495]         }
[17:39:21.495]     })
[17:39:21.495]     if (TRUE) {
[17:39:21.495]         base::sink(type = "output", split = FALSE)
[17:39:21.495]         if (TRUE) {
[17:39:21.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.495]         }
[17:39:21.495]         else {
[17:39:21.495]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.495]         }
[17:39:21.495]         base::close(...future.stdout)
[17:39:21.495]         ...future.stdout <- NULL
[17:39:21.495]     }
[17:39:21.495]     ...future.result$conditions <- ...future.conditions
[17:39:21.495]     ...future.result$finished <- base::Sys.time()
[17:39:21.495]     ...future.result
[17:39:21.495] }
[17:39:21.498] assign_globals() ...
[17:39:21.498] List of 5
[17:39:21.498]  $ future.call.arguments    : list()
[17:39:21.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.498]  $ ...future.FUN            :function (x)  
[17:39:21.498]  $ ...future.elements_ii    :List of 1
[17:39:21.498]   ..$ : int [1:2] 1 3
[17:39:21.498]  $ ...future.seeds_ii       : NULL
[17:39:21.498]  $ ...future.globals.maxSize: NULL
[17:39:21.498]  - attr(*, "where")=List of 5
[17:39:21.498]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.498]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.498]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.498]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.498]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.498]  - attr(*, "resolved")= logi FALSE
[17:39:21.498]  - attr(*, "total_size")= num NA
[17:39:21.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.498]  - attr(*, "already-done")= logi TRUE
[17:39:21.502] - copied ‘future.call.arguments’ to environment
[17:39:21.502] - reassign environment for ‘...future.FUN’
[17:39:21.503] - copied ‘...future.FUN’ to environment
[17:39:21.503] - copied ‘...future.elements_ii’ to environment
[17:39:21.503] - copied ‘...future.seeds_ii’ to environment
[17:39:21.503] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.503] assign_globals() ... done
[17:39:21.503] requestCore(): workers = 2
[17:39:21.505] MulticoreFuture started
[17:39:21.506] - Launch lazy future ... done
[17:39:21.506] run() for ‘MulticoreFuture’ ... done
[17:39:21.506] Created future:
[17:39:21.506] plan(): Setting new future strategy stack:
[17:39:21.507] List of future strategies:
[17:39:21.507] 1. sequential:
[17:39:21.507]    - args: function (..., envir = parent.frame())
[17:39:21.507]    - tweaked: FALSE
[17:39:21.507]    - call: NULL
[17:39:21.507] plan(): nbrOfWorkers() = 1
[17:39:21.509] plan(): Setting new future strategy stack:
[17:39:21.509] List of future strategies:
[17:39:21.509] 1. multicore:
[17:39:21.509]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.509]    - tweaked: FALSE
[17:39:21.509]    - call: plan(strategy)
[17:39:21.515] plan(): nbrOfWorkers() = 2
[17:39:21.506] MulticoreFuture:
[17:39:21.506] Label: ‘future_apply-1’
[17:39:21.506] Expression:
[17:39:21.506] {
[17:39:21.506]     do.call(function(...) {
[17:39:21.506]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.506]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.506]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.506]             on.exit(options(oopts), add = TRUE)
[17:39:21.506]         }
[17:39:21.506]         {
[17:39:21.506]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.506]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.506]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.506]             })
[17:39:21.506]         }
[17:39:21.506]     }, args = future.call.arguments)
[17:39:21.506] }
[17:39:21.506] Lazy evaluation: FALSE
[17:39:21.506] Asynchronous evaluation: TRUE
[17:39:21.506] Local evaluation: TRUE
[17:39:21.506] Environment: R_GlobalEnv
[17:39:21.506] Capture standard output: TRUE
[17:39:21.506] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.506] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:21.506] Packages: <none>
[17:39:21.506] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.506] Resolved: TRUE
[17:39:21.506] Value: <not collected>
[17:39:21.506] Conditions captured: <none>
[17:39:21.506] Early signaling: FALSE
[17:39:21.506] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.506] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.516] Chunk #1 of 2 ... DONE
[17:39:21.516] Chunk #2 of 2 ...
[17:39:21.516]  - seeds: <none>
[17:39:21.516] getGlobalsAndPackages() ...
[17:39:21.517] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.517] Resolving globals: FALSE
[17:39:21.517] Tweak future expression to call with '...' arguments ...
[17:39:21.517] {
[17:39:21.517]     do.call(function(...) {
[17:39:21.517]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.517]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.517]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.517]             on.exit(options(oopts), add = TRUE)
[17:39:21.517]         }
[17:39:21.517]         {
[17:39:21.517]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.517]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.517]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.517]             })
[17:39:21.517]         }
[17:39:21.517]     }, args = future.call.arguments)
[17:39:21.517] }
[17:39:21.517] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.518] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.518] 
[17:39:21.518] getGlobalsAndPackages() ... DONE
[17:39:21.519] run() for ‘Future’ ...
[17:39:21.519] - state: ‘created’
[17:39:21.519] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.524] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.524] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.524]   - Field: ‘label’
[17:39:21.524]   - Field: ‘local’
[17:39:21.524]   - Field: ‘owner’
[17:39:21.525]   - Field: ‘envir’
[17:39:21.525]   - Field: ‘workers’
[17:39:21.525]   - Field: ‘packages’
[17:39:21.525]   - Field: ‘gc’
[17:39:21.525]   - Field: ‘job’
[17:39:21.525]   - Field: ‘conditions’
[17:39:21.526]   - Field: ‘expr’
[17:39:21.526]   - Field: ‘uuid’
[17:39:21.526]   - Field: ‘seed’
[17:39:21.526]   - Field: ‘version’
[17:39:21.526]   - Field: ‘result’
[17:39:21.526]   - Field: ‘asynchronous’
[17:39:21.526]   - Field: ‘calls’
[17:39:21.527]   - Field: ‘globals’
[17:39:21.527]   - Field: ‘stdout’
[17:39:21.527]   - Field: ‘earlySignal’
[17:39:21.527]   - Field: ‘lazy’
[17:39:21.527]   - Field: ‘state’
[17:39:21.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.527] - Launch lazy future ...
[17:39:21.528] Packages needed by the future expression (n = 0): <none>
[17:39:21.531] Packages needed by future strategies (n = 0): <none>
[17:39:21.532] {
[17:39:21.532]     {
[17:39:21.532]         {
[17:39:21.532]             ...future.startTime <- base::Sys.time()
[17:39:21.532]             {
[17:39:21.532]                 {
[17:39:21.532]                   {
[17:39:21.532]                     {
[17:39:21.532]                       base::local({
[17:39:21.532]                         has_future <- base::requireNamespace("future", 
[17:39:21.532]                           quietly = TRUE)
[17:39:21.532]                         if (has_future) {
[17:39:21.532]                           ns <- base::getNamespace("future")
[17:39:21.532]                           version <- ns[[".package"]][["version"]]
[17:39:21.532]                           if (is.null(version)) 
[17:39:21.532]                             version <- utils::packageVersion("future")
[17:39:21.532]                         }
[17:39:21.532]                         else {
[17:39:21.532]                           version <- NULL
[17:39:21.532]                         }
[17:39:21.532]                         if (!has_future || version < "1.8.0") {
[17:39:21.532]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.532]                             "", base::R.version$version.string), 
[17:39:21.532]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.532]                               "release", "version")], collapse = " "), 
[17:39:21.532]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.532]                             info)
[17:39:21.532]                           info <- base::paste(info, collapse = "; ")
[17:39:21.532]                           if (!has_future) {
[17:39:21.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.532]                               info)
[17:39:21.532]                           }
[17:39:21.532]                           else {
[17:39:21.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.532]                               info, version)
[17:39:21.532]                           }
[17:39:21.532]                           base::stop(msg)
[17:39:21.532]                         }
[17:39:21.532]                       })
[17:39:21.532]                     }
[17:39:21.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.532]                     base::options(mc.cores = 1L)
[17:39:21.532]                   }
[17:39:21.532]                   options(future.plan = NULL)
[17:39:21.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.532]                 }
[17:39:21.532]                 ...future.workdir <- getwd()
[17:39:21.532]             }
[17:39:21.532]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.532]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.532]         }
[17:39:21.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.532]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.532]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.532]             base::names(...future.oldOptions))
[17:39:21.532]     }
[17:39:21.532]     if (FALSE) {
[17:39:21.532]     }
[17:39:21.532]     else {
[17:39:21.532]         if (TRUE) {
[17:39:21.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.532]                 open = "w")
[17:39:21.532]         }
[17:39:21.532]         else {
[17:39:21.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.532]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.532]         }
[17:39:21.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.532]             base::sink(type = "output", split = FALSE)
[17:39:21.532]             base::close(...future.stdout)
[17:39:21.532]         }, add = TRUE)
[17:39:21.532]     }
[17:39:21.532]     ...future.frame <- base::sys.nframe()
[17:39:21.532]     ...future.conditions <- base::list()
[17:39:21.532]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.532]     if (FALSE) {
[17:39:21.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.532]     }
[17:39:21.532]     ...future.result <- base::tryCatch({
[17:39:21.532]         base::withCallingHandlers({
[17:39:21.532]             ...future.value <- base::withVisible(base::local({
[17:39:21.532]                 withCallingHandlers({
[17:39:21.532]                   {
[17:39:21.532]                     do.call(function(...) {
[17:39:21.532]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.532]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.532]                         ...future.globals.maxSize)) {
[17:39:21.532]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.532]                         on.exit(options(oopts), add = TRUE)
[17:39:21.532]                       }
[17:39:21.532]                       {
[17:39:21.532]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.532]                           FUN = function(jj) {
[17:39:21.532]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.532]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.532]                           })
[17:39:21.532]                       }
[17:39:21.532]                     }, args = future.call.arguments)
[17:39:21.532]                   }
[17:39:21.532]                 }, immediateCondition = function(cond) {
[17:39:21.532]                   save_rds <- function (object, pathname, ...) 
[17:39:21.532]                   {
[17:39:21.532]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.532]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.532]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.532]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.532]                         fi_tmp[["mtime"]])
[17:39:21.532]                     }
[17:39:21.532]                     tryCatch({
[17:39:21.532]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.532]                     }, error = function(ex) {
[17:39:21.532]                       msg <- conditionMessage(ex)
[17:39:21.532]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.532]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.532]                         fi_tmp[["mtime"]], msg)
[17:39:21.532]                       ex$message <- msg
[17:39:21.532]                       stop(ex)
[17:39:21.532]                     })
[17:39:21.532]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.532]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.532]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.532]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.532]                       fi <- file.info(pathname)
[17:39:21.532]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.532]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.532]                         fi[["size"]], fi[["mtime"]])
[17:39:21.532]                       stop(msg)
[17:39:21.532]                     }
[17:39:21.532]                     invisible(pathname)
[17:39:21.532]                   }
[17:39:21.532]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.532]                     rootPath = tempdir()) 
[17:39:21.532]                   {
[17:39:21.532]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.532]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.532]                       tmpdir = path, fileext = ".rds")
[17:39:21.532]                     save_rds(obj, file)
[17:39:21.532]                   }
[17:39:21.532]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.532]                   {
[17:39:21.532]                     inherits <- base::inherits
[17:39:21.532]                     invokeRestart <- base::invokeRestart
[17:39:21.532]                     is.null <- base::is.null
[17:39:21.532]                     muffled <- FALSE
[17:39:21.532]                     if (inherits(cond, "message")) {
[17:39:21.532]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.532]                       if (muffled) 
[17:39:21.532]                         invokeRestart("muffleMessage")
[17:39:21.532]                     }
[17:39:21.532]                     else if (inherits(cond, "warning")) {
[17:39:21.532]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.532]                       if (muffled) 
[17:39:21.532]                         invokeRestart("muffleWarning")
[17:39:21.532]                     }
[17:39:21.532]                     else if (inherits(cond, "condition")) {
[17:39:21.532]                       if (!is.null(pattern)) {
[17:39:21.532]                         computeRestarts <- base::computeRestarts
[17:39:21.532]                         grepl <- base::grepl
[17:39:21.532]                         restarts <- computeRestarts(cond)
[17:39:21.532]                         for (restart in restarts) {
[17:39:21.532]                           name <- restart$name
[17:39:21.532]                           if (is.null(name)) 
[17:39:21.532]                             next
[17:39:21.532]                           if (!grepl(pattern, name)) 
[17:39:21.532]                             next
[17:39:21.532]                           invokeRestart(restart)
[17:39:21.532]                           muffled <- TRUE
[17:39:21.532]                           break
[17:39:21.532]                         }
[17:39:21.532]                       }
[17:39:21.532]                     }
[17:39:21.532]                     invisible(muffled)
[17:39:21.532]                   }
[17:39:21.532]                   muffleCondition(cond)
[17:39:21.532]                 })
[17:39:21.532]             }))
[17:39:21.532]             future::FutureResult(value = ...future.value$value, 
[17:39:21.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.532]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.532]                     ...future.globalenv.names))
[17:39:21.532]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.532]         }, condition = base::local({
[17:39:21.532]             c <- base::c
[17:39:21.532]             inherits <- base::inherits
[17:39:21.532]             invokeRestart <- base::invokeRestart
[17:39:21.532]             length <- base::length
[17:39:21.532]             list <- base::list
[17:39:21.532]             seq.int <- base::seq.int
[17:39:21.532]             signalCondition <- base::signalCondition
[17:39:21.532]             sys.calls <- base::sys.calls
[17:39:21.532]             `[[` <- base::`[[`
[17:39:21.532]             `+` <- base::`+`
[17:39:21.532]             `<<-` <- base::`<<-`
[17:39:21.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.532]                   3L)]
[17:39:21.532]             }
[17:39:21.532]             function(cond) {
[17:39:21.532]                 is_error <- inherits(cond, "error")
[17:39:21.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.532]                   NULL)
[17:39:21.532]                 if (is_error) {
[17:39:21.532]                   sessionInformation <- function() {
[17:39:21.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.532]                       search = base::search(), system = base::Sys.info())
[17:39:21.532]                   }
[17:39:21.532]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.532]                     cond$call), session = sessionInformation(), 
[17:39:21.532]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.532]                   signalCondition(cond)
[17:39:21.532]                 }
[17:39:21.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:21.532]                 "immediateCondition"))) {
[17:39:21.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.532]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.532]                   if (TRUE && !signal) {
[17:39:21.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.532]                     {
[17:39:21.532]                       inherits <- base::inherits
[17:39:21.532]                       invokeRestart <- base::invokeRestart
[17:39:21.532]                       is.null <- base::is.null
[17:39:21.532]                       muffled <- FALSE
[17:39:21.532]                       if (inherits(cond, "message")) {
[17:39:21.532]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.532]                         if (muffled) 
[17:39:21.532]                           invokeRestart("muffleMessage")
[17:39:21.532]                       }
[17:39:21.532]                       else if (inherits(cond, "warning")) {
[17:39:21.532]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.532]                         if (muffled) 
[17:39:21.532]                           invokeRestart("muffleWarning")
[17:39:21.532]                       }
[17:39:21.532]                       else if (inherits(cond, "condition")) {
[17:39:21.532]                         if (!is.null(pattern)) {
[17:39:21.532]                           computeRestarts <- base::computeRestarts
[17:39:21.532]                           grepl <- base::grepl
[17:39:21.532]                           restarts <- computeRestarts(cond)
[17:39:21.532]                           for (restart in restarts) {
[17:39:21.532]                             name <- restart$name
[17:39:21.532]                             if (is.null(name)) 
[17:39:21.532]                               next
[17:39:21.532]                             if (!grepl(pattern, name)) 
[17:39:21.532]                               next
[17:39:21.532]                             invokeRestart(restart)
[17:39:21.532]                             muffled <- TRUE
[17:39:21.532]                             break
[17:39:21.532]                           }
[17:39:21.532]                         }
[17:39:21.532]                       }
[17:39:21.532]                       invisible(muffled)
[17:39:21.532]                     }
[17:39:21.532]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.532]                   }
[17:39:21.532]                 }
[17:39:21.532]                 else {
[17:39:21.532]                   if (TRUE) {
[17:39:21.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.532]                     {
[17:39:21.532]                       inherits <- base::inherits
[17:39:21.532]                       invokeRestart <- base::invokeRestart
[17:39:21.532]                       is.null <- base::is.null
[17:39:21.532]                       muffled <- FALSE
[17:39:21.532]                       if (inherits(cond, "message")) {
[17:39:21.532]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.532]                         if (muffled) 
[17:39:21.532]                           invokeRestart("muffleMessage")
[17:39:21.532]                       }
[17:39:21.532]                       else if (inherits(cond, "warning")) {
[17:39:21.532]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.532]                         if (muffled) 
[17:39:21.532]                           invokeRestart("muffleWarning")
[17:39:21.532]                       }
[17:39:21.532]                       else if (inherits(cond, "condition")) {
[17:39:21.532]                         if (!is.null(pattern)) {
[17:39:21.532]                           computeRestarts <- base::computeRestarts
[17:39:21.532]                           grepl <- base::grepl
[17:39:21.532]                           restarts <- computeRestarts(cond)
[17:39:21.532]                           for (restart in restarts) {
[17:39:21.532]                             name <- restart$name
[17:39:21.532]                             if (is.null(name)) 
[17:39:21.532]                               next
[17:39:21.532]                             if (!grepl(pattern, name)) 
[17:39:21.532]                               next
[17:39:21.532]                             invokeRestart(restart)
[17:39:21.532]                             muffled <- TRUE
[17:39:21.532]                             break
[17:39:21.532]                           }
[17:39:21.532]                         }
[17:39:21.532]                       }
[17:39:21.532]                       invisible(muffled)
[17:39:21.532]                     }
[17:39:21.532]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.532]                   }
[17:39:21.532]                 }
[17:39:21.532]             }
[17:39:21.532]         }))
[17:39:21.532]     }, error = function(ex) {
[17:39:21.532]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.532]                 ...future.rng), started = ...future.startTime, 
[17:39:21.532]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.532]             version = "1.8"), class = "FutureResult")
[17:39:21.532]     }, finally = {
[17:39:21.532]         if (!identical(...future.workdir, getwd())) 
[17:39:21.532]             setwd(...future.workdir)
[17:39:21.532]         {
[17:39:21.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.532]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.532]             }
[17:39:21.532]             base::options(...future.oldOptions)
[17:39:21.532]             if (.Platform$OS.type == "windows") {
[17:39:21.532]                 old_names <- names(...future.oldEnvVars)
[17:39:21.532]                 envs <- base::Sys.getenv()
[17:39:21.532]                 names <- names(envs)
[17:39:21.532]                 common <- intersect(names, old_names)
[17:39:21.532]                 added <- setdiff(names, old_names)
[17:39:21.532]                 removed <- setdiff(old_names, names)
[17:39:21.532]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.532]                   envs[common]]
[17:39:21.532]                 NAMES <- toupper(changed)
[17:39:21.532]                 args <- list()
[17:39:21.532]                 for (kk in seq_along(NAMES)) {
[17:39:21.532]                   name <- changed[[kk]]
[17:39:21.532]                   NAME <- NAMES[[kk]]
[17:39:21.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.532]                     next
[17:39:21.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.532]                 }
[17:39:21.532]                 NAMES <- toupper(added)
[17:39:21.532]                 for (kk in seq_along(NAMES)) {
[17:39:21.532]                   name <- added[[kk]]
[17:39:21.532]                   NAME <- NAMES[[kk]]
[17:39:21.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.532]                     next
[17:39:21.532]                   args[[name]] <- ""
[17:39:21.532]                 }
[17:39:21.532]                 NAMES <- toupper(removed)
[17:39:21.532]                 for (kk in seq_along(NAMES)) {
[17:39:21.532]                   name <- removed[[kk]]
[17:39:21.532]                   NAME <- NAMES[[kk]]
[17:39:21.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.532]                     next
[17:39:21.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.532]                 }
[17:39:21.532]                 if (length(args) > 0) 
[17:39:21.532]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.532]             }
[17:39:21.532]             else {
[17:39:21.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.532]             }
[17:39:21.532]             {
[17:39:21.532]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.532]                   0L) {
[17:39:21.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.532]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.532]                   base::options(opts)
[17:39:21.532]                 }
[17:39:21.532]                 {
[17:39:21.532]                   {
[17:39:21.532]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.532]                     NULL
[17:39:21.532]                   }
[17:39:21.532]                   options(future.plan = NULL)
[17:39:21.532]                   if (is.na(NA_character_)) 
[17:39:21.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.532]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.532]                     envir = parent.frame()) 
[17:39:21.532]                   {
[17:39:21.532]                     default_workers <- missing(workers)
[17:39:21.532]                     if (is.function(workers)) 
[17:39:21.532]                       workers <- workers()
[17:39:21.532]                     workers <- structure(as.integer(workers), 
[17:39:21.532]                       class = class(workers))
[17:39:21.532]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.532]                       1L)
[17:39:21.532]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.532]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.532]                       if (default_workers) 
[17:39:21.532]                         supportsMulticore(warn = TRUE)
[17:39:21.532]                       return(sequential(..., envir = envir))
[17:39:21.532]                     }
[17:39:21.532]                     oopts <- options(mc.cores = workers)
[17:39:21.532]                     on.exit(options(oopts))
[17:39:21.532]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.532]                       envir = envir)
[17:39:21.532]                     if (!future$lazy) 
[17:39:21.532]                       future <- run(future)
[17:39:21.532]                     invisible(future)
[17:39:21.532]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.532]                 }
[17:39:21.532]             }
[17:39:21.532]         }
[17:39:21.532]     })
[17:39:21.532]     if (TRUE) {
[17:39:21.532]         base::sink(type = "output", split = FALSE)
[17:39:21.532]         if (TRUE) {
[17:39:21.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.532]         }
[17:39:21.532]         else {
[17:39:21.532]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.532]         }
[17:39:21.532]         base::close(...future.stdout)
[17:39:21.532]         ...future.stdout <- NULL
[17:39:21.532]     }
[17:39:21.532]     ...future.result$conditions <- ...future.conditions
[17:39:21.532]     ...future.result$finished <- base::Sys.time()
[17:39:21.532]     ...future.result
[17:39:21.532] }
[17:39:21.536] assign_globals() ...
[17:39:21.536] List of 5
[17:39:21.536]  $ future.call.arguments    : list()
[17:39:21.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.536]  $ ...future.FUN            :function (x)  
[17:39:21.536]  $ ...future.elements_ii    :List of 1
[17:39:21.536]   ..$ : int [1:2] 2 4
[17:39:21.536]  $ ...future.seeds_ii       : NULL
[17:39:21.536]  $ ...future.globals.maxSize: NULL
[17:39:21.536]  - attr(*, "where")=List of 5
[17:39:21.536]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.536]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.536]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.536]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.536]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.536]  - attr(*, "resolved")= logi FALSE
[17:39:21.536]  - attr(*, "total_size")= num NA
[17:39:21.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.536]  - attr(*, "already-done")= logi TRUE
[17:39:21.546] - copied ‘future.call.arguments’ to environment
[17:39:21.546] - reassign environment for ‘...future.FUN’
[17:39:21.546] - copied ‘...future.FUN’ to environment
[17:39:21.546] - copied ‘...future.elements_ii’ to environment
[17:39:21.546] - copied ‘...future.seeds_ii’ to environment
[17:39:21.547] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.547] assign_globals() ... done
[17:39:21.547] requestCore(): workers = 2
[17:39:21.549] MulticoreFuture started
[17:39:21.550] - Launch lazy future ... done
[17:39:21.550] run() for ‘MulticoreFuture’ ... done
[17:39:21.550] Created future:
[17:39:21.550] plan(): Setting new future strategy stack:
[17:39:21.551] List of future strategies:
[17:39:21.551] 1. sequential:
[17:39:21.551]    - args: function (..., envir = parent.frame())
[17:39:21.551]    - tweaked: FALSE
[17:39:21.551]    - call: NULL
[17:39:21.552] plan(): nbrOfWorkers() = 1
[17:39:21.554] plan(): Setting new future strategy stack:
[17:39:21.554] List of future strategies:
[17:39:21.554] 1. multicore:
[17:39:21.554]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.554]    - tweaked: FALSE
[17:39:21.554]    - call: plan(strategy)
[17:39:21.559] plan(): nbrOfWorkers() = 2
[17:39:21.550] MulticoreFuture:
[17:39:21.550] Label: ‘future_apply-2’
[17:39:21.550] Expression:
[17:39:21.550] {
[17:39:21.550]     do.call(function(...) {
[17:39:21.550]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.550]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.550]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.550]             on.exit(options(oopts), add = TRUE)
[17:39:21.550]         }
[17:39:21.550]         {
[17:39:21.550]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.550]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.550]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.550]             })
[17:39:21.550]         }
[17:39:21.550]     }, args = future.call.arguments)
[17:39:21.550] }
[17:39:21.550] Lazy evaluation: FALSE
[17:39:21.550] Asynchronous evaluation: TRUE
[17:39:21.550] Local evaluation: TRUE
[17:39:21.550] Environment: R_GlobalEnv
[17:39:21.550] Capture standard output: TRUE
[17:39:21.550] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:21.550] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:21.550] Packages: <none>
[17:39:21.550] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:21.550] Resolved: TRUE
[17:39:21.550] Value: <not collected>
[17:39:21.550] Conditions captured: <none>
[17:39:21.550] Early signaling: FALSE
[17:39:21.550] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.550] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.560] Chunk #2 of 2 ... DONE
[17:39:21.560] Launching 2 futures (chunks) ... DONE
[17:39:21.560] Resolving 2 futures (chunks) ...
[17:39:21.561] resolve() on list ...
[17:39:21.561]  recursive: 0
[17:39:21.561]  length: 2
[17:39:21.561] 
[17:39:21.561] Future #1
[17:39:21.562] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:21.563] - nx: 2
[17:39:21.563] - relay: TRUE
[17:39:21.563] - stdout: TRUE
[17:39:21.563] - signal: TRUE
[17:39:21.563] - resignal: FALSE
[17:39:21.563] - force: TRUE
[17:39:21.564] - relayed: [n=2] FALSE, FALSE
[17:39:21.564] - queued futures: [n=2] FALSE, FALSE
[17:39:21.564]  - until=1
[17:39:21.564]  - relaying element #1
[17:39:21.564] - relayed: [n=2] TRUE, FALSE
[17:39:21.564] - queued futures: [n=2] TRUE, FALSE
[17:39:21.565] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:21.565]  length: 1 (resolved future 1)
[17:39:21.565] Future #2
[17:39:21.566] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:21.566] - nx: 2
[17:39:21.566] - relay: TRUE
[17:39:21.566] - stdout: TRUE
[17:39:21.567] - signal: TRUE
[17:39:21.567] - resignal: FALSE
[17:39:21.567] - force: TRUE
[17:39:21.567] - relayed: [n=2] TRUE, FALSE
[17:39:21.567] - queued futures: [n=2] TRUE, FALSE
[17:39:21.567]  - until=2
[17:39:21.567]  - relaying element #2
[17:39:21.567] - relayed: [n=2] TRUE, TRUE
[17:39:21.568] - queued futures: [n=2] TRUE, TRUE
[17:39:21.568] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:21.568]  length: 0 (resolved future 2)
[17:39:21.568] Relaying remaining futures
[17:39:21.568] signalConditionsASAP(NULL, pos=0) ...
[17:39:21.568] - nx: 2
[17:39:21.568] - relay: TRUE
[17:39:21.568] - stdout: TRUE
[17:39:21.569] - signal: TRUE
[17:39:21.569] - resignal: FALSE
[17:39:21.569] - force: TRUE
[17:39:21.569] - relayed: [n=2] TRUE, TRUE
[17:39:21.569] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:21.569] - relayed: [n=2] TRUE, TRUE
[17:39:21.569] - queued futures: [n=2] TRUE, TRUE
[17:39:21.569] signalConditionsASAP(NULL, pos=0) ... done
[17:39:21.569] resolve() on list ... DONE
[17:39:21.570]  - Number of value chunks collected: 2
[17:39:21.570] Resolving 2 futures (chunks) ... DONE
[17:39:21.570] Reducing values from 2 chunks ...
[17:39:21.570]  - Number of values collected after concatenation: 2
[17:39:21.570]  - Number of values expected: 2
[17:39:21.570] Reducing values from 2 chunks ... DONE
[17:39:21.570] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:39:21.571] getGlobalsAndPackagesXApply() ...
[17:39:21.571]  - future.globals: TRUE
[17:39:21.571] getGlobalsAndPackages() ...
[17:39:21.571] Searching for globals...
[17:39:21.578] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:39:21.578] Searching for globals ... DONE
[17:39:21.578] Resolving globals: FALSE
[17:39:21.579] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:39:21.580] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:39:21.580] - globals: [1] ‘FUN’
[17:39:21.580] 
[17:39:21.580] getGlobalsAndPackages() ... DONE
[17:39:21.580]  - globals found/used: [n=1] ‘FUN’
[17:39:21.581]  - needed namespaces: [n=0] 
[17:39:21.581] Finding globals ... DONE
[17:39:21.581]  - use_args: TRUE
[17:39:21.581]  - Getting '...' globals ...
[17:39:21.581] resolve() on list ...
[17:39:21.582]  recursive: 0
[17:39:21.582]  length: 1
[17:39:21.582]  elements: ‘...’
[17:39:21.582]  length: 0 (resolved future 1)
[17:39:21.582] resolve() on list ... DONE
[17:39:21.582]    - '...' content: [n=0] 
[17:39:21.582] List of 1
[17:39:21.582]  $ ...: list()
[17:39:21.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.582]  - attr(*, "where")=List of 1
[17:39:21.582]   ..$ ...:<environment: 0x55c796b68528> 
[17:39:21.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.582]  - attr(*, "resolved")= logi TRUE
[17:39:21.582]  - attr(*, "total_size")= num NA
[17:39:21.586]  - Getting '...' globals ... DONE
[17:39:21.586] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:21.586] List of 2
[17:39:21.586]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:39:21.586]  $ ...          : list()
[17:39:21.586]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.586]  - attr(*, "where")=List of 2
[17:39:21.586]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:21.586]   ..$ ...          :<environment: 0x55c796b68528> 
[17:39:21.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.586]  - attr(*, "resolved")= logi FALSE
[17:39:21.586]  - attr(*, "total_size")= num 36296
[17:39:21.589] Packages to be attached in all futures: [n=0] 
[17:39:21.589] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.593] future_lapply() ...
[17:39:21.595] Generating random seeds ...
[17:39:21.595] Generating random seed streams for 2 elements ...
[17:39:21.595] Generating random seed streams for 2 elements ... DONE
[17:39:21.595] Generating random seeds ... DONE
[17:39:21.595] Will set RNG state on exit: 10407, 2053933985, -1868898121, 1652188737, -1133242626, 1655567831, -559973058
[17:39:21.599] Number of chunks: 2
[17:39:21.599] getGlobalsAndPackagesXApply() ...
[17:39:21.599]  - future.globals: <name-value list> with names ‘list()’
[17:39:21.599]  - use_args: TRUE
[17:39:21.599] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:21.599] List of 2
[17:39:21.599]  $ ...          : list()
[17:39:21.599]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.599]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:39:21.599]  - attr(*, "where")=List of 2
[17:39:21.599]   ..$ ...          :<environment: 0x55c796b68528> 
[17:39:21.599]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:21.599]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.599]  - attr(*, "resolved")= logi FALSE
[17:39:21.599]  - attr(*, "total_size")= num NA
[17:39:21.604] Packages to be attached in all futures: [n=0] 
[17:39:21.604] getGlobalsAndPackagesXApply() ... DONE
[17:39:21.604] Number of futures (= number of chunks): 2
[17:39:21.605] Launching 2 futures (chunks) ...
[17:39:21.605] Chunk #1 of 2 ...
[17:39:21.605]  - seeds: [1] <seeds>
[17:39:21.605] getGlobalsAndPackages() ...
[17:39:21.605] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.605] Resolving globals: FALSE
[17:39:21.605] Tweak future expression to call with '...' arguments ...
[17:39:21.605] {
[17:39:21.605]     do.call(function(...) {
[17:39:21.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.605]             on.exit(options(oopts), add = TRUE)
[17:39:21.605]         }
[17:39:21.605]         {
[17:39:21.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.605]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:21.605]                   envir = globalenv(), inherits = FALSE)
[17:39:21.605]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.605]             })
[17:39:21.605]         }
[17:39:21.605]     }, args = future.call.arguments)
[17:39:21.605] }
[17:39:21.606] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.606] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.606] 
[17:39:21.606] getGlobalsAndPackages() ... DONE
[17:39:21.607] run() for ‘Future’ ...
[17:39:21.607] - state: ‘created’
[17:39:21.607] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.611] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.611]   - Field: ‘label’
[17:39:21.611]   - Field: ‘local’
[17:39:21.611]   - Field: ‘owner’
[17:39:21.611]   - Field: ‘envir’
[17:39:21.611]   - Field: ‘workers’
[17:39:21.611]   - Field: ‘packages’
[17:39:21.611]   - Field: ‘gc’
[17:39:21.612]   - Field: ‘job’
[17:39:21.612]   - Field: ‘conditions’
[17:39:21.612]   - Field: ‘expr’
[17:39:21.612]   - Field: ‘uuid’
[17:39:21.612]   - Field: ‘seed’
[17:39:21.612]   - Field: ‘version’
[17:39:21.612]   - Field: ‘result’
[17:39:21.612]   - Field: ‘asynchronous’
[17:39:21.612]   - Field: ‘calls’
[17:39:21.612]   - Field: ‘globals’
[17:39:21.612]   - Field: ‘stdout’
[17:39:21.613]   - Field: ‘earlySignal’
[17:39:21.613]   - Field: ‘lazy’
[17:39:21.613]   - Field: ‘state’
[17:39:21.613] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.613] - Launch lazy future ...
[17:39:21.613] Packages needed by the future expression (n = 0): <none>
[17:39:21.613] Packages needed by future strategies (n = 0): <none>
[17:39:21.614] {
[17:39:21.614]     {
[17:39:21.614]         {
[17:39:21.614]             ...future.startTime <- base::Sys.time()
[17:39:21.614]             {
[17:39:21.614]                 {
[17:39:21.614]                   {
[17:39:21.614]                     {
[17:39:21.614]                       base::local({
[17:39:21.614]                         has_future <- base::requireNamespace("future", 
[17:39:21.614]                           quietly = TRUE)
[17:39:21.614]                         if (has_future) {
[17:39:21.614]                           ns <- base::getNamespace("future")
[17:39:21.614]                           version <- ns[[".package"]][["version"]]
[17:39:21.614]                           if (is.null(version)) 
[17:39:21.614]                             version <- utils::packageVersion("future")
[17:39:21.614]                         }
[17:39:21.614]                         else {
[17:39:21.614]                           version <- NULL
[17:39:21.614]                         }
[17:39:21.614]                         if (!has_future || version < "1.8.0") {
[17:39:21.614]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.614]                             "", base::R.version$version.string), 
[17:39:21.614]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.614]                               "release", "version")], collapse = " "), 
[17:39:21.614]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.614]                             info)
[17:39:21.614]                           info <- base::paste(info, collapse = "; ")
[17:39:21.614]                           if (!has_future) {
[17:39:21.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.614]                               info)
[17:39:21.614]                           }
[17:39:21.614]                           else {
[17:39:21.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.614]                               info, version)
[17:39:21.614]                           }
[17:39:21.614]                           base::stop(msg)
[17:39:21.614]                         }
[17:39:21.614]                       })
[17:39:21.614]                     }
[17:39:21.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.614]                     base::options(mc.cores = 1L)
[17:39:21.614]                   }
[17:39:21.614]                   options(future.plan = NULL)
[17:39:21.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.614]                 }
[17:39:21.614]                 ...future.workdir <- getwd()
[17:39:21.614]             }
[17:39:21.614]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.614]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.614]         }
[17:39:21.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.614]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.614]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.614]             base::names(...future.oldOptions))
[17:39:21.614]     }
[17:39:21.614]     if (FALSE) {
[17:39:21.614]     }
[17:39:21.614]     else {
[17:39:21.614]         if (TRUE) {
[17:39:21.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.614]                 open = "w")
[17:39:21.614]         }
[17:39:21.614]         else {
[17:39:21.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.614]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.614]         }
[17:39:21.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.614]             base::sink(type = "output", split = FALSE)
[17:39:21.614]             base::close(...future.stdout)
[17:39:21.614]         }, add = TRUE)
[17:39:21.614]     }
[17:39:21.614]     ...future.frame <- base::sys.nframe()
[17:39:21.614]     ...future.conditions <- base::list()
[17:39:21.614]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.614]     if (FALSE) {
[17:39:21.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.614]     }
[17:39:21.614]     ...future.result <- base::tryCatch({
[17:39:21.614]         base::withCallingHandlers({
[17:39:21.614]             ...future.value <- base::withVisible(base::local({
[17:39:21.614]                 withCallingHandlers({
[17:39:21.614]                   {
[17:39:21.614]                     do.call(function(...) {
[17:39:21.614]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.614]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.614]                         ...future.globals.maxSize)) {
[17:39:21.614]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.614]                         on.exit(options(oopts), add = TRUE)
[17:39:21.614]                       }
[17:39:21.614]                       {
[17:39:21.614]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.614]                           FUN = function(jj) {
[17:39:21.614]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.614]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:21.614]                               envir = globalenv(), inherits = FALSE)
[17:39:21.614]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.614]                           })
[17:39:21.614]                       }
[17:39:21.614]                     }, args = future.call.arguments)
[17:39:21.614]                   }
[17:39:21.614]                 }, immediateCondition = function(cond) {
[17:39:21.614]                   save_rds <- function (object, pathname, ...) 
[17:39:21.614]                   {
[17:39:21.614]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.614]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.614]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.614]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.614]                         fi_tmp[["mtime"]])
[17:39:21.614]                     }
[17:39:21.614]                     tryCatch({
[17:39:21.614]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.614]                     }, error = function(ex) {
[17:39:21.614]                       msg <- conditionMessage(ex)
[17:39:21.614]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.614]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.614]                         fi_tmp[["mtime"]], msg)
[17:39:21.614]                       ex$message <- msg
[17:39:21.614]                       stop(ex)
[17:39:21.614]                     })
[17:39:21.614]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.614]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.614]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.614]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.614]                       fi <- file.info(pathname)
[17:39:21.614]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.614]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.614]                         fi[["size"]], fi[["mtime"]])
[17:39:21.614]                       stop(msg)
[17:39:21.614]                     }
[17:39:21.614]                     invisible(pathname)
[17:39:21.614]                   }
[17:39:21.614]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.614]                     rootPath = tempdir()) 
[17:39:21.614]                   {
[17:39:21.614]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.614]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.614]                       tmpdir = path, fileext = ".rds")
[17:39:21.614]                     save_rds(obj, file)
[17:39:21.614]                   }
[17:39:21.614]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.614]                   {
[17:39:21.614]                     inherits <- base::inherits
[17:39:21.614]                     invokeRestart <- base::invokeRestart
[17:39:21.614]                     is.null <- base::is.null
[17:39:21.614]                     muffled <- FALSE
[17:39:21.614]                     if (inherits(cond, "message")) {
[17:39:21.614]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.614]                       if (muffled) 
[17:39:21.614]                         invokeRestart("muffleMessage")
[17:39:21.614]                     }
[17:39:21.614]                     else if (inherits(cond, "warning")) {
[17:39:21.614]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.614]                       if (muffled) 
[17:39:21.614]                         invokeRestart("muffleWarning")
[17:39:21.614]                     }
[17:39:21.614]                     else if (inherits(cond, "condition")) {
[17:39:21.614]                       if (!is.null(pattern)) {
[17:39:21.614]                         computeRestarts <- base::computeRestarts
[17:39:21.614]                         grepl <- base::grepl
[17:39:21.614]                         restarts <- computeRestarts(cond)
[17:39:21.614]                         for (restart in restarts) {
[17:39:21.614]                           name <- restart$name
[17:39:21.614]                           if (is.null(name)) 
[17:39:21.614]                             next
[17:39:21.614]                           if (!grepl(pattern, name)) 
[17:39:21.614]                             next
[17:39:21.614]                           invokeRestart(restart)
[17:39:21.614]                           muffled <- TRUE
[17:39:21.614]                           break
[17:39:21.614]                         }
[17:39:21.614]                       }
[17:39:21.614]                     }
[17:39:21.614]                     invisible(muffled)
[17:39:21.614]                   }
[17:39:21.614]                   muffleCondition(cond)
[17:39:21.614]                 })
[17:39:21.614]             }))
[17:39:21.614]             future::FutureResult(value = ...future.value$value, 
[17:39:21.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.614]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.614]                     ...future.globalenv.names))
[17:39:21.614]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.614]         }, condition = base::local({
[17:39:21.614]             c <- base::c
[17:39:21.614]             inherits <- base::inherits
[17:39:21.614]             invokeRestart <- base::invokeRestart
[17:39:21.614]             length <- base::length
[17:39:21.614]             list <- base::list
[17:39:21.614]             seq.int <- base::seq.int
[17:39:21.614]             signalCondition <- base::signalCondition
[17:39:21.614]             sys.calls <- base::sys.calls
[17:39:21.614]             `[[` <- base::`[[`
[17:39:21.614]             `+` <- base::`+`
[17:39:21.614]             `<<-` <- base::`<<-`
[17:39:21.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.614]                   3L)]
[17:39:21.614]             }
[17:39:21.614]             function(cond) {
[17:39:21.614]                 is_error <- inherits(cond, "error")
[17:39:21.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.614]                   NULL)
[17:39:21.614]                 if (is_error) {
[17:39:21.614]                   sessionInformation <- function() {
[17:39:21.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.614]                       search = base::search(), system = base::Sys.info())
[17:39:21.614]                   }
[17:39:21.614]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.614]                     cond$call), session = sessionInformation(), 
[17:39:21.614]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.614]                   signalCondition(cond)
[17:39:21.614]                 }
[17:39:21.614]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:39:21.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.614]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.614]                   if (TRUE && !signal) {
[17:39:21.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.614]                     {
[17:39:21.614]                       inherits <- base::inherits
[17:39:21.614]                       invokeRestart <- base::invokeRestart
[17:39:21.614]                       is.null <- base::is.null
[17:39:21.614]                       muffled <- FALSE
[17:39:21.614]                       if (inherits(cond, "message")) {
[17:39:21.614]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.614]                         if (muffled) 
[17:39:21.614]                           invokeRestart("muffleMessage")
[17:39:21.614]                       }
[17:39:21.614]                       else if (inherits(cond, "warning")) {
[17:39:21.614]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.614]                         if (muffled) 
[17:39:21.614]                           invokeRestart("muffleWarning")
[17:39:21.614]                       }
[17:39:21.614]                       else if (inherits(cond, "condition")) {
[17:39:21.614]                         if (!is.null(pattern)) {
[17:39:21.614]                           computeRestarts <- base::computeRestarts
[17:39:21.614]                           grepl <- base::grepl
[17:39:21.614]                           restarts <- computeRestarts(cond)
[17:39:21.614]                           for (restart in restarts) {
[17:39:21.614]                             name <- restart$name
[17:39:21.614]                             if (is.null(name)) 
[17:39:21.614]                               next
[17:39:21.614]                             if (!grepl(pattern, name)) 
[17:39:21.614]                               next
[17:39:21.614]                             invokeRestart(restart)
[17:39:21.614]                             muffled <- TRUE
[17:39:21.614]                             break
[17:39:21.614]                           }
[17:39:21.614]                         }
[17:39:21.614]                       }
[17:39:21.614]                       invisible(muffled)
[17:39:21.614]                     }
[17:39:21.614]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.614]                   }
[17:39:21.614]                 }
[17:39:21.614]                 else {
[17:39:21.614]                   if (TRUE) {
[17:39:21.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.614]                     {
[17:39:21.614]                       inherits <- base::inherits
[17:39:21.614]                       invokeRestart <- base::invokeRestart
[17:39:21.614]                       is.null <- base::is.null
[17:39:21.614]                       muffled <- FALSE
[17:39:21.614]                       if (inherits(cond, "message")) {
[17:39:21.614]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.614]                         if (muffled) 
[17:39:21.614]                           invokeRestart("muffleMessage")
[17:39:21.614]                       }
[17:39:21.614]                       else if (inherits(cond, "warning")) {
[17:39:21.614]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.614]                         if (muffled) 
[17:39:21.614]                           invokeRestart("muffleWarning")
[17:39:21.614]                       }
[17:39:21.614]                       else if (inherits(cond, "condition")) {
[17:39:21.614]                         if (!is.null(pattern)) {
[17:39:21.614]                           computeRestarts <- base::computeRestarts
[17:39:21.614]                           grepl <- base::grepl
[17:39:21.614]                           restarts <- computeRestarts(cond)
[17:39:21.614]                           for (restart in restarts) {
[17:39:21.614]                             name <- restart$name
[17:39:21.614]                             if (is.null(name)) 
[17:39:21.614]                               next
[17:39:21.614]                             if (!grepl(pattern, name)) 
[17:39:21.614]                               next
[17:39:21.614]                             invokeRestart(restart)
[17:39:21.614]                             muffled <- TRUE
[17:39:21.614]                             break
[17:39:21.614]                           }
[17:39:21.614]                         }
[17:39:21.614]                       }
[17:39:21.614]                       invisible(muffled)
[17:39:21.614]                     }
[17:39:21.614]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.614]                   }
[17:39:21.614]                 }
[17:39:21.614]             }
[17:39:21.614]         }))
[17:39:21.614]     }, error = function(ex) {
[17:39:21.614]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.614]                 ...future.rng), started = ...future.startTime, 
[17:39:21.614]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.614]             version = "1.8"), class = "FutureResult")
[17:39:21.614]     }, finally = {
[17:39:21.614]         if (!identical(...future.workdir, getwd())) 
[17:39:21.614]             setwd(...future.workdir)
[17:39:21.614]         {
[17:39:21.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.614]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.614]             }
[17:39:21.614]             base::options(...future.oldOptions)
[17:39:21.614]             if (.Platform$OS.type == "windows") {
[17:39:21.614]                 old_names <- names(...future.oldEnvVars)
[17:39:21.614]                 envs <- base::Sys.getenv()
[17:39:21.614]                 names <- names(envs)
[17:39:21.614]                 common <- intersect(names, old_names)
[17:39:21.614]                 added <- setdiff(names, old_names)
[17:39:21.614]                 removed <- setdiff(old_names, names)
[17:39:21.614]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.614]                   envs[common]]
[17:39:21.614]                 NAMES <- toupper(changed)
[17:39:21.614]                 args <- list()
[17:39:21.614]                 for (kk in seq_along(NAMES)) {
[17:39:21.614]                   name <- changed[[kk]]
[17:39:21.614]                   NAME <- NAMES[[kk]]
[17:39:21.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.614]                     next
[17:39:21.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.614]                 }
[17:39:21.614]                 NAMES <- toupper(added)
[17:39:21.614]                 for (kk in seq_along(NAMES)) {
[17:39:21.614]                   name <- added[[kk]]
[17:39:21.614]                   NAME <- NAMES[[kk]]
[17:39:21.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.614]                     next
[17:39:21.614]                   args[[name]] <- ""
[17:39:21.614]                 }
[17:39:21.614]                 NAMES <- toupper(removed)
[17:39:21.614]                 for (kk in seq_along(NAMES)) {
[17:39:21.614]                   name <- removed[[kk]]
[17:39:21.614]                   NAME <- NAMES[[kk]]
[17:39:21.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.614]                     next
[17:39:21.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.614]                 }
[17:39:21.614]                 if (length(args) > 0) 
[17:39:21.614]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.614]             }
[17:39:21.614]             else {
[17:39:21.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.614]             }
[17:39:21.614]             {
[17:39:21.614]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.614]                   0L) {
[17:39:21.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.614]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.614]                   base::options(opts)
[17:39:21.614]                 }
[17:39:21.614]                 {
[17:39:21.614]                   {
[17:39:21.614]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.614]                     NULL
[17:39:21.614]                   }
[17:39:21.614]                   options(future.plan = NULL)
[17:39:21.614]                   if (is.na(NA_character_)) 
[17:39:21.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.614]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.614]                     envir = parent.frame()) 
[17:39:21.614]                   {
[17:39:21.614]                     default_workers <- missing(workers)
[17:39:21.614]                     if (is.function(workers)) 
[17:39:21.614]                       workers <- workers()
[17:39:21.614]                     workers <- structure(as.integer(workers), 
[17:39:21.614]                       class = class(workers))
[17:39:21.614]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.614]                       1L)
[17:39:21.614]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.614]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.614]                       if (default_workers) 
[17:39:21.614]                         supportsMulticore(warn = TRUE)
[17:39:21.614]                       return(sequential(..., envir = envir))
[17:39:21.614]                     }
[17:39:21.614]                     oopts <- options(mc.cores = workers)
[17:39:21.614]                     on.exit(options(oopts))
[17:39:21.614]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.614]                       envir = envir)
[17:39:21.614]                     if (!future$lazy) 
[17:39:21.614]                       future <- run(future)
[17:39:21.614]                     invisible(future)
[17:39:21.614]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.614]                 }
[17:39:21.614]             }
[17:39:21.614]         }
[17:39:21.614]     })
[17:39:21.614]     if (TRUE) {
[17:39:21.614]         base::sink(type = "output", split = FALSE)
[17:39:21.614]         if (TRUE) {
[17:39:21.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.614]         }
[17:39:21.614]         else {
[17:39:21.614]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.614]         }
[17:39:21.614]         base::close(...future.stdout)
[17:39:21.614]         ...future.stdout <- NULL
[17:39:21.614]     }
[17:39:21.614]     ...future.result$conditions <- ...future.conditions
[17:39:21.614]     ...future.result$finished <- base::Sys.time()
[17:39:21.614]     ...future.result
[17:39:21.614] }
[17:39:21.616] assign_globals() ...
[17:39:21.616] List of 5
[17:39:21.616]  $ future.call.arguments    : list()
[17:39:21.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.616]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:39:21.616]  $ ...future.elements_ii    :List of 1
[17:39:21.616]   ..$ : int [1:2] 1 3
[17:39:21.616]  $ ...future.seeds_ii       :List of 1
[17:39:21.616]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:39:21.616]  $ ...future.globals.maxSize: NULL
[17:39:21.616]  - attr(*, "where")=List of 5
[17:39:21.616]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.616]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.616]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.616]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.616]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.616]  - attr(*, "resolved")= logi FALSE
[17:39:21.616]  - attr(*, "total_size")= num NA
[17:39:21.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.616]  - attr(*, "already-done")= logi TRUE
[17:39:21.621] - copied ‘future.call.arguments’ to environment
[17:39:21.621] - copied ‘...future.FUN’ to environment
[17:39:21.622] - copied ‘...future.elements_ii’ to environment
[17:39:21.622] - copied ‘...future.seeds_ii’ to environment
[17:39:21.622] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.622] assign_globals() ... done
[17:39:21.622] requestCore(): workers = 2
[17:39:21.624] MulticoreFuture started
[17:39:21.624] - Launch lazy future ... done
[17:39:21.625] run() for ‘MulticoreFuture’ ... done
[17:39:21.625] Created future:
[17:39:21.625] plan(): Setting new future strategy stack:
[17:39:21.625] List of future strategies:
[17:39:21.625] 1. sequential:
[17:39:21.625]    - args: function (..., envir = parent.frame())
[17:39:21.625]    - tweaked: FALSE
[17:39:21.625]    - call: NULL
[17:39:21.626] plan(): nbrOfWorkers() = 1
[17:39:21.628] plan(): Setting new future strategy stack:
[17:39:21.628] List of future strategies:
[17:39:21.628] 1. multicore:
[17:39:21.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.628]    - tweaked: FALSE
[17:39:21.628]    - call: plan(strategy)
[17:39:21.633] plan(): nbrOfWorkers() = 2
[17:39:21.625] MulticoreFuture:
[17:39:21.625] Label: ‘future_apply-1’
[17:39:21.625] Expression:
[17:39:21.625] {
[17:39:21.625]     do.call(function(...) {
[17:39:21.625]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.625]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.625]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.625]             on.exit(options(oopts), add = TRUE)
[17:39:21.625]         }
[17:39:21.625]         {
[17:39:21.625]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.625]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.625]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:21.625]                   envir = globalenv(), inherits = FALSE)
[17:39:21.625]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.625]             })
[17:39:21.625]         }
[17:39:21.625]     }, args = future.call.arguments)
[17:39:21.625] }
[17:39:21.625] Lazy evaluation: FALSE
[17:39:21.625] Asynchronous evaluation: TRUE
[17:39:21.625] Local evaluation: TRUE
[17:39:21.625] Environment: R_GlobalEnv
[17:39:21.625] Capture standard output: TRUE
[17:39:21.625] Capture condition classes: <none>
[17:39:21.625] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:21.625] Packages: <none>
[17:39:21.625] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:39:21.625] Resolved: TRUE
[17:39:21.625] Value: <not collected>
[17:39:21.625] Conditions captured: <none>
[17:39:21.625] Early signaling: FALSE
[17:39:21.625] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.625] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.634] Chunk #1 of 2 ... DONE
[17:39:21.635] Chunk #2 of 2 ...
[17:39:21.635]  - seeds: [1] <seeds>
[17:39:21.635] getGlobalsAndPackages() ...
[17:39:21.635] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.635] Resolving globals: FALSE
[17:39:21.635] Tweak future expression to call with '...' arguments ...
[17:39:21.636] {
[17:39:21.636]     do.call(function(...) {
[17:39:21.636]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.636]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.636]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.636]             on.exit(options(oopts), add = TRUE)
[17:39:21.636]         }
[17:39:21.636]         {
[17:39:21.636]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.636]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.636]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:21.636]                   envir = globalenv(), inherits = FALSE)
[17:39:21.636]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.636]             })
[17:39:21.636]         }
[17:39:21.636]     }, args = future.call.arguments)
[17:39:21.636] }
[17:39:21.636] Tweak future expression to call with '...' arguments ... DONE
[17:39:21.637] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:21.637] 
[17:39:21.637] getGlobalsAndPackages() ... DONE
[17:39:21.637] run() for ‘Future’ ...
[17:39:21.638] - state: ‘created’
[17:39:21.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:21.650] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:21.650]   - Field: ‘label’
[17:39:21.651]   - Field: ‘local’
[17:39:21.651]   - Field: ‘owner’
[17:39:21.651]   - Field: ‘envir’
[17:39:21.651]   - Field: ‘workers’
[17:39:21.651]   - Field: ‘packages’
[17:39:21.651]   - Field: ‘gc’
[17:39:21.651]   - Field: ‘job’
[17:39:21.651]   - Field: ‘conditions’
[17:39:21.652]   - Field: ‘expr’
[17:39:21.652]   - Field: ‘uuid’
[17:39:21.652]   - Field: ‘seed’
[17:39:21.652]   - Field: ‘version’
[17:39:21.652]   - Field: ‘result’
[17:39:21.652]   - Field: ‘asynchronous’
[17:39:21.652]   - Field: ‘calls’
[17:39:21.653]   - Field: ‘globals’
[17:39:21.653]   - Field: ‘stdout’
[17:39:21.653]   - Field: ‘earlySignal’
[17:39:21.653]   - Field: ‘lazy’
[17:39:21.653]   - Field: ‘state’
[17:39:21.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:21.654] - Launch lazy future ...
[17:39:21.654] Packages needed by the future expression (n = 0): <none>
[17:39:21.655] Packages needed by future strategies (n = 0): <none>
[17:39:21.656] {
[17:39:21.656]     {
[17:39:21.656]         {
[17:39:21.656]             ...future.startTime <- base::Sys.time()
[17:39:21.656]             {
[17:39:21.656]                 {
[17:39:21.656]                   {
[17:39:21.656]                     {
[17:39:21.656]                       base::local({
[17:39:21.656]                         has_future <- base::requireNamespace("future", 
[17:39:21.656]                           quietly = TRUE)
[17:39:21.656]                         if (has_future) {
[17:39:21.656]                           ns <- base::getNamespace("future")
[17:39:21.656]                           version <- ns[[".package"]][["version"]]
[17:39:21.656]                           if (is.null(version)) 
[17:39:21.656]                             version <- utils::packageVersion("future")
[17:39:21.656]                         }
[17:39:21.656]                         else {
[17:39:21.656]                           version <- NULL
[17:39:21.656]                         }
[17:39:21.656]                         if (!has_future || version < "1.8.0") {
[17:39:21.656]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:21.656]                             "", base::R.version$version.string), 
[17:39:21.656]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:21.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:21.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:21.656]                               "release", "version")], collapse = " "), 
[17:39:21.656]                             hostname = base::Sys.info()[["nodename"]])
[17:39:21.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:21.656]                             info)
[17:39:21.656]                           info <- base::paste(info, collapse = "; ")
[17:39:21.656]                           if (!has_future) {
[17:39:21.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:21.656]                               info)
[17:39:21.656]                           }
[17:39:21.656]                           else {
[17:39:21.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:21.656]                               info, version)
[17:39:21.656]                           }
[17:39:21.656]                           base::stop(msg)
[17:39:21.656]                         }
[17:39:21.656]                       })
[17:39:21.656]                     }
[17:39:21.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:21.656]                     base::options(mc.cores = 1L)
[17:39:21.656]                   }
[17:39:21.656]                   options(future.plan = NULL)
[17:39:21.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:21.656]                 }
[17:39:21.656]                 ...future.workdir <- getwd()
[17:39:21.656]             }
[17:39:21.656]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:21.656]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:21.656]         }
[17:39:21.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:21.656]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:21.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:21.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:21.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:21.656]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:21.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:21.656]             base::names(...future.oldOptions))
[17:39:21.656]     }
[17:39:21.656]     if (FALSE) {
[17:39:21.656]     }
[17:39:21.656]     else {
[17:39:21.656]         if (TRUE) {
[17:39:21.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:21.656]                 open = "w")
[17:39:21.656]         }
[17:39:21.656]         else {
[17:39:21.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:21.656]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:21.656]         }
[17:39:21.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:21.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:21.656]             base::sink(type = "output", split = FALSE)
[17:39:21.656]             base::close(...future.stdout)
[17:39:21.656]         }, add = TRUE)
[17:39:21.656]     }
[17:39:21.656]     ...future.frame <- base::sys.nframe()
[17:39:21.656]     ...future.conditions <- base::list()
[17:39:21.656]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:21.656]     if (FALSE) {
[17:39:21.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:21.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:21.656]     }
[17:39:21.656]     ...future.result <- base::tryCatch({
[17:39:21.656]         base::withCallingHandlers({
[17:39:21.656]             ...future.value <- base::withVisible(base::local({
[17:39:21.656]                 withCallingHandlers({
[17:39:21.656]                   {
[17:39:21.656]                     do.call(function(...) {
[17:39:21.656]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.656]                       if (!identical(...future.globals.maxSize.org, 
[17:39:21.656]                         ...future.globals.maxSize)) {
[17:39:21.656]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.656]                         on.exit(options(oopts), add = TRUE)
[17:39:21.656]                       }
[17:39:21.656]                       {
[17:39:21.656]                         lapply(seq_along(...future.elements_ii), 
[17:39:21.656]                           FUN = function(jj) {
[17:39:21.656]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.656]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:21.656]                               envir = globalenv(), inherits = FALSE)
[17:39:21.656]                             ...future.FUN(...future.X_jj, ...)
[17:39:21.656]                           })
[17:39:21.656]                       }
[17:39:21.656]                     }, args = future.call.arguments)
[17:39:21.656]                   }
[17:39:21.656]                 }, immediateCondition = function(cond) {
[17:39:21.656]                   save_rds <- function (object, pathname, ...) 
[17:39:21.656]                   {
[17:39:21.656]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:21.656]                     if (file_test("-f", pathname_tmp)) {
[17:39:21.656]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.656]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:21.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.656]                         fi_tmp[["mtime"]])
[17:39:21.656]                     }
[17:39:21.656]                     tryCatch({
[17:39:21.656]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:21.656]                     }, error = function(ex) {
[17:39:21.656]                       msg <- conditionMessage(ex)
[17:39:21.656]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.656]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:21.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.656]                         fi_tmp[["mtime"]], msg)
[17:39:21.656]                       ex$message <- msg
[17:39:21.656]                       stop(ex)
[17:39:21.656]                     })
[17:39:21.656]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:21.656]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:21.656]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:21.656]                       fi_tmp <- file.info(pathname_tmp)
[17:39:21.656]                       fi <- file.info(pathname)
[17:39:21.656]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:21.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:21.656]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:21.656]                         fi[["size"]], fi[["mtime"]])
[17:39:21.656]                       stop(msg)
[17:39:21.656]                     }
[17:39:21.656]                     invisible(pathname)
[17:39:21.656]                   }
[17:39:21.656]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:21.656]                     rootPath = tempdir()) 
[17:39:21.656]                   {
[17:39:21.656]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:21.656]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:21.656]                       tmpdir = path, fileext = ".rds")
[17:39:21.656]                     save_rds(obj, file)
[17:39:21.656]                   }
[17:39:21.656]                   saveImmediateCondition(cond, path = "/tmp/RtmpXrjv13/.future/immediateConditions")
[17:39:21.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.656]                   {
[17:39:21.656]                     inherits <- base::inherits
[17:39:21.656]                     invokeRestart <- base::invokeRestart
[17:39:21.656]                     is.null <- base::is.null
[17:39:21.656]                     muffled <- FALSE
[17:39:21.656]                     if (inherits(cond, "message")) {
[17:39:21.656]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:21.656]                       if (muffled) 
[17:39:21.656]                         invokeRestart("muffleMessage")
[17:39:21.656]                     }
[17:39:21.656]                     else if (inherits(cond, "warning")) {
[17:39:21.656]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:21.656]                       if (muffled) 
[17:39:21.656]                         invokeRestart("muffleWarning")
[17:39:21.656]                     }
[17:39:21.656]                     else if (inherits(cond, "condition")) {
[17:39:21.656]                       if (!is.null(pattern)) {
[17:39:21.656]                         computeRestarts <- base::computeRestarts
[17:39:21.656]                         grepl <- base::grepl
[17:39:21.656]                         restarts <- computeRestarts(cond)
[17:39:21.656]                         for (restart in restarts) {
[17:39:21.656]                           name <- restart$name
[17:39:21.656]                           if (is.null(name)) 
[17:39:21.656]                             next
[17:39:21.656]                           if (!grepl(pattern, name)) 
[17:39:21.656]                             next
[17:39:21.656]                           invokeRestart(restart)
[17:39:21.656]                           muffled <- TRUE
[17:39:21.656]                           break
[17:39:21.656]                         }
[17:39:21.656]                       }
[17:39:21.656]                     }
[17:39:21.656]                     invisible(muffled)
[17:39:21.656]                   }
[17:39:21.656]                   muffleCondition(cond)
[17:39:21.656]                 })
[17:39:21.656]             }))
[17:39:21.656]             future::FutureResult(value = ...future.value$value, 
[17:39:21.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.656]                   ...future.rng), globalenv = if (FALSE) 
[17:39:21.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:21.656]                     ...future.globalenv.names))
[17:39:21.656]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:21.656]         }, condition = base::local({
[17:39:21.656]             c <- base::c
[17:39:21.656]             inherits <- base::inherits
[17:39:21.656]             invokeRestart <- base::invokeRestart
[17:39:21.656]             length <- base::length
[17:39:21.656]             list <- base::list
[17:39:21.656]             seq.int <- base::seq.int
[17:39:21.656]             signalCondition <- base::signalCondition
[17:39:21.656]             sys.calls <- base::sys.calls
[17:39:21.656]             `[[` <- base::`[[`
[17:39:21.656]             `+` <- base::`+`
[17:39:21.656]             `<<-` <- base::`<<-`
[17:39:21.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:21.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:21.656]                   3L)]
[17:39:21.656]             }
[17:39:21.656]             function(cond) {
[17:39:21.656]                 is_error <- inherits(cond, "error")
[17:39:21.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:21.656]                   NULL)
[17:39:21.656]                 if (is_error) {
[17:39:21.656]                   sessionInformation <- function() {
[17:39:21.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:21.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:21.656]                       search = base::search(), system = base::Sys.info())
[17:39:21.656]                   }
[17:39:21.656]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:21.656]                     cond$call), session = sessionInformation(), 
[17:39:21.656]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:21.656]                   signalCondition(cond)
[17:39:21.656]                 }
[17:39:21.656]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:39:21.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:21.656]                   ...future.conditions[[length(...future.conditions) + 
[17:39:21.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:21.656]                   if (TRUE && !signal) {
[17:39:21.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.656]                     {
[17:39:21.656]                       inherits <- base::inherits
[17:39:21.656]                       invokeRestart <- base::invokeRestart
[17:39:21.656]                       is.null <- base::is.null
[17:39:21.656]                       muffled <- FALSE
[17:39:21.656]                       if (inherits(cond, "message")) {
[17:39:21.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.656]                         if (muffled) 
[17:39:21.656]                           invokeRestart("muffleMessage")
[17:39:21.656]                       }
[17:39:21.656]                       else if (inherits(cond, "warning")) {
[17:39:21.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.656]                         if (muffled) 
[17:39:21.656]                           invokeRestart("muffleWarning")
[17:39:21.656]                       }
[17:39:21.656]                       else if (inherits(cond, "condition")) {
[17:39:21.656]                         if (!is.null(pattern)) {
[17:39:21.656]                           computeRestarts <- base::computeRestarts
[17:39:21.656]                           grepl <- base::grepl
[17:39:21.656]                           restarts <- computeRestarts(cond)
[17:39:21.656]                           for (restart in restarts) {
[17:39:21.656]                             name <- restart$name
[17:39:21.656]                             if (is.null(name)) 
[17:39:21.656]                               next
[17:39:21.656]                             if (!grepl(pattern, name)) 
[17:39:21.656]                               next
[17:39:21.656]                             invokeRestart(restart)
[17:39:21.656]                             muffled <- TRUE
[17:39:21.656]                             break
[17:39:21.656]                           }
[17:39:21.656]                         }
[17:39:21.656]                       }
[17:39:21.656]                       invisible(muffled)
[17:39:21.656]                     }
[17:39:21.656]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.656]                   }
[17:39:21.656]                 }
[17:39:21.656]                 else {
[17:39:21.656]                   if (TRUE) {
[17:39:21.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:21.656]                     {
[17:39:21.656]                       inherits <- base::inherits
[17:39:21.656]                       invokeRestart <- base::invokeRestart
[17:39:21.656]                       is.null <- base::is.null
[17:39:21.656]                       muffled <- FALSE
[17:39:21.656]                       if (inherits(cond, "message")) {
[17:39:21.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:21.656]                         if (muffled) 
[17:39:21.656]                           invokeRestart("muffleMessage")
[17:39:21.656]                       }
[17:39:21.656]                       else if (inherits(cond, "warning")) {
[17:39:21.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:21.656]                         if (muffled) 
[17:39:21.656]                           invokeRestart("muffleWarning")
[17:39:21.656]                       }
[17:39:21.656]                       else if (inherits(cond, "condition")) {
[17:39:21.656]                         if (!is.null(pattern)) {
[17:39:21.656]                           computeRestarts <- base::computeRestarts
[17:39:21.656]                           grepl <- base::grepl
[17:39:21.656]                           restarts <- computeRestarts(cond)
[17:39:21.656]                           for (restart in restarts) {
[17:39:21.656]                             name <- restart$name
[17:39:21.656]                             if (is.null(name)) 
[17:39:21.656]                               next
[17:39:21.656]                             if (!grepl(pattern, name)) 
[17:39:21.656]                               next
[17:39:21.656]                             invokeRestart(restart)
[17:39:21.656]                             muffled <- TRUE
[17:39:21.656]                             break
[17:39:21.656]                           }
[17:39:21.656]                         }
[17:39:21.656]                       }
[17:39:21.656]                       invisible(muffled)
[17:39:21.656]                     }
[17:39:21.656]                     muffleCondition(cond, pattern = "^muffle")
[17:39:21.656]                   }
[17:39:21.656]                 }
[17:39:21.656]             }
[17:39:21.656]         }))
[17:39:21.656]     }, error = function(ex) {
[17:39:21.656]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:21.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:21.656]                 ...future.rng), started = ...future.startTime, 
[17:39:21.656]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:21.656]             version = "1.8"), class = "FutureResult")
[17:39:21.656]     }, finally = {
[17:39:21.656]         if (!identical(...future.workdir, getwd())) 
[17:39:21.656]             setwd(...future.workdir)
[17:39:21.656]         {
[17:39:21.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:21.656]                 ...future.oldOptions$nwarnings <- NULL
[17:39:21.656]             }
[17:39:21.656]             base::options(...future.oldOptions)
[17:39:21.656]             if (.Platform$OS.type == "windows") {
[17:39:21.656]                 old_names <- names(...future.oldEnvVars)
[17:39:21.656]                 envs <- base::Sys.getenv()
[17:39:21.656]                 names <- names(envs)
[17:39:21.656]                 common <- intersect(names, old_names)
[17:39:21.656]                 added <- setdiff(names, old_names)
[17:39:21.656]                 removed <- setdiff(old_names, names)
[17:39:21.656]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:21.656]                   envs[common]]
[17:39:21.656]                 NAMES <- toupper(changed)
[17:39:21.656]                 args <- list()
[17:39:21.656]                 for (kk in seq_along(NAMES)) {
[17:39:21.656]                   name <- changed[[kk]]
[17:39:21.656]                   NAME <- NAMES[[kk]]
[17:39:21.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.656]                     next
[17:39:21.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.656]                 }
[17:39:21.656]                 NAMES <- toupper(added)
[17:39:21.656]                 for (kk in seq_along(NAMES)) {
[17:39:21.656]                   name <- added[[kk]]
[17:39:21.656]                   NAME <- NAMES[[kk]]
[17:39:21.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.656]                     next
[17:39:21.656]                   args[[name]] <- ""
[17:39:21.656]                 }
[17:39:21.656]                 NAMES <- toupper(removed)
[17:39:21.656]                 for (kk in seq_along(NAMES)) {
[17:39:21.656]                   name <- removed[[kk]]
[17:39:21.656]                   NAME <- NAMES[[kk]]
[17:39:21.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:21.656]                     next
[17:39:21.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:21.656]                 }
[17:39:21.656]                 if (length(args) > 0) 
[17:39:21.656]                   base::do.call(base::Sys.setenv, args = args)
[17:39:21.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:21.656]             }
[17:39:21.656]             else {
[17:39:21.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:21.656]             }
[17:39:21.656]             {
[17:39:21.656]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:21.656]                   0L) {
[17:39:21.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:21.656]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:21.656]                   base::options(opts)
[17:39:21.656]                 }
[17:39:21.656]                 {
[17:39:21.656]                   {
[17:39:21.656]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:21.656]                     NULL
[17:39:21.656]                   }
[17:39:21.656]                   options(future.plan = NULL)
[17:39:21.656]                   if (is.na(NA_character_)) 
[17:39:21.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:21.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:21.656]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:39:21.656]                     envir = parent.frame()) 
[17:39:21.656]                   {
[17:39:21.656]                     default_workers <- missing(workers)
[17:39:21.656]                     if (is.function(workers)) 
[17:39:21.656]                       workers <- workers()
[17:39:21.656]                     workers <- structure(as.integer(workers), 
[17:39:21.656]                       class = class(workers))
[17:39:21.656]                     stop_if_not(is.finite(workers), workers >= 
[17:39:21.656]                       1L)
[17:39:21.656]                     if ((workers == 1L && !inherits(workers, 
[17:39:21.656]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:39:21.656]                       if (default_workers) 
[17:39:21.656]                         supportsMulticore(warn = TRUE)
[17:39:21.656]                       return(sequential(..., envir = envir))
[17:39:21.656]                     }
[17:39:21.656]                     oopts <- options(mc.cores = workers)
[17:39:21.656]                     on.exit(options(oopts))
[17:39:21.656]                     future <- MulticoreFuture(..., workers = workers, 
[17:39:21.656]                       envir = envir)
[17:39:21.656]                     if (!future$lazy) 
[17:39:21.656]                       future <- run(future)
[17:39:21.656]                     invisible(future)
[17:39:21.656]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:21.656]                 }
[17:39:21.656]             }
[17:39:21.656]         }
[17:39:21.656]     })
[17:39:21.656]     if (TRUE) {
[17:39:21.656]         base::sink(type = "output", split = FALSE)
[17:39:21.656]         if (TRUE) {
[17:39:21.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:21.656]         }
[17:39:21.656]         else {
[17:39:21.656]             ...future.result["stdout"] <- base::list(NULL)
[17:39:21.656]         }
[17:39:21.656]         base::close(...future.stdout)
[17:39:21.656]         ...future.stdout <- NULL
[17:39:21.656]     }
[17:39:21.656]     ...future.result$conditions <- ...future.conditions
[17:39:21.656]     ...future.result$finished <- base::Sys.time()
[17:39:21.656]     ...future.result
[17:39:21.656] }
[17:39:21.659] assign_globals() ...
[17:39:21.659] List of 5
[17:39:21.659]  $ future.call.arguments    : list()
[17:39:21.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:21.659]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:39:21.659]  $ ...future.elements_ii    :List of 1
[17:39:21.659]   ..$ : int [1:2] 2 4
[17:39:21.659]  $ ...future.seeds_ii       :List of 1
[17:39:21.659]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:39:21.659]  $ ...future.globals.maxSize: NULL
[17:39:21.659]  - attr(*, "where")=List of 5
[17:39:21.659]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:39:21.659]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:39:21.659]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:39:21.659]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:39:21.659]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:39:21.659]  - attr(*, "resolved")= logi FALSE
[17:39:21.659]  - attr(*, "total_size")= num NA
[17:39:21.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:21.659]  - attr(*, "already-done")= logi TRUE
[17:39:21.668] - copied ‘future.call.arguments’ to environment
[17:39:21.668] - copied ‘...future.FUN’ to environment
[17:39:21.668] - copied ‘...future.elements_ii’ to environment
[17:39:21.668] - copied ‘...future.seeds_ii’ to environment
[17:39:21.668] - copied ‘...future.globals.maxSize’ to environment
[17:39:21.668] assign_globals() ... done
[17:39:21.669] requestCore(): workers = 2
[17:39:21.671] MulticoreFuture started
[17:39:21.671] - Launch lazy future ... done
[17:39:21.672] run() for ‘MulticoreFuture’ ... done
[17:39:21.672] Created future:
[17:39:21.672] plan(): Setting new future strategy stack:
[17:39:21.673] List of future strategies:
[17:39:21.673] 1. sequential:
[17:39:21.673]    - args: function (..., envir = parent.frame())
[17:39:21.673]    - tweaked: FALSE
[17:39:21.673]    - call: NULL
[17:39:21.673] plan(): nbrOfWorkers() = 1
[17:39:21.676] plan(): Setting new future strategy stack:
[17:39:21.676] List of future strategies:
[17:39:21.676] 1. multicore:
[17:39:21.676]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:21.676]    - tweaked: FALSE
[17:39:21.676]    - call: plan(strategy)
[17:39:21.681] plan(): nbrOfWorkers() = 2
[17:39:21.672] MulticoreFuture:
[17:39:21.672] Label: ‘future_apply-2’
[17:39:21.672] Expression:
[17:39:21.672] {
[17:39:21.672]     do.call(function(...) {
[17:39:21.672]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:21.672]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:21.672]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:21.672]             on.exit(options(oopts), add = TRUE)
[17:39:21.672]         }
[17:39:21.672]         {
[17:39:21.672]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:21.672]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:21.672]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:21.672]                   envir = globalenv(), inherits = FALSE)
[17:39:21.672]                 ...future.FUN(...future.X_jj, ...)
[17:39:21.672]             })
[17:39:21.672]         }
[17:39:21.672]     }, args = future.call.arguments)
[17:39:21.672] }
[17:39:21.672] Lazy evaluation: FALSE
[17:39:21.672] Asynchronous evaluation: TRUE
[17:39:21.672] Local evaluation: TRUE
[17:39:21.672] Environment: R_GlobalEnv
[17:39:21.672] Capture standard output: TRUE
[17:39:21.672] Capture condition classes: <none>
[17:39:21.672] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:21.672] Packages: <none>
[17:39:21.672] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:39:21.672] Resolved: TRUE
[17:39:21.672] Value: <not collected>
[17:39:21.672] Conditions captured: <none>
[17:39:21.672] Early signaling: FALSE
[17:39:21.672] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:21.672] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:21.683] Chunk #2 of 2 ... DONE
[17:39:21.683] Launching 2 futures (chunks) ... DONE
[17:39:21.683] Resolving 2 futures (chunks) ...
[17:39:21.683] resolve() on list ...
[17:39:21.683]  recursive: 0
[17:39:21.684]  length: 2
[17:39:21.684] 
[17:39:21.684] Future #1
[17:39:21.685] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:39:21.685] - nx: 2
[17:39:21.685] - relay: TRUE
[17:39:21.685] - stdout: TRUE
[17:39:21.686] - signal: TRUE
[17:39:21.686] - resignal: FALSE
[17:39:21.686] - force: TRUE
[17:39:21.686] - relayed: [n=2] FALSE, FALSE
[17:39:21.686] - queued futures: [n=2] FALSE, FALSE
[17:39:21.686]  - until=1
[17:39:21.687]  - relaying element #1
[17:39:21.687] - relayed: [n=2] TRUE, FALSE
[17:39:21.687] - queued futures: [n=2] TRUE, FALSE
[17:39:21.687] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:39:21.687]  length: 1 (resolved future 1)
[17:39:21.688] Future #2
[17:39:21.689] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:21.689] - nx: 2
[17:39:21.689] - relay: TRUE
[17:39:21.689] - stdout: TRUE
[17:39:21.689] - signal: TRUE
[17:39:21.689] - resignal: FALSE
[17:39:21.689] - force: TRUE
[17:39:21.689] - relayed: [n=2] TRUE, FALSE
[17:39:21.690] - queued futures: [n=2] TRUE, FALSE
[17:39:21.690]  - until=2
[17:39:21.690]  - relaying element #2
[17:39:21.690] - relayed: [n=2] TRUE, TRUE
[17:39:21.690] - queued futures: [n=2] TRUE, TRUE
[17:39:21.690] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:21.691]  length: 0 (resolved future 2)
[17:39:21.691] Relaying remaining futures
[17:39:21.691] signalConditionsASAP(NULL, pos=0) ...
[17:39:21.691] - nx: 2
[17:39:21.691] - relay: TRUE
[17:39:21.691] - stdout: TRUE
[17:39:21.691] - signal: TRUE
[17:39:21.691] - resignal: FALSE
[17:39:21.691] - force: TRUE
[17:39:21.692] - relayed: [n=2] TRUE, TRUE
[17:39:21.692] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:21.692] - relayed: [n=2] TRUE, TRUE
[17:39:21.692] - queued futures: [n=2] TRUE, TRUE
[17:39:21.692] signalConditionsASAP(NULL, pos=0) ... done
[17:39:21.692] resolve() on list ... DONE
[17:39:21.692]  - Number of value chunks collected: 2
[17:39:21.693] Resolving 2 futures (chunks) ... DONE
[17:39:21.693] Reducing values from 2 chunks ...
[17:39:21.693]  - Number of values collected after concatenation: 2
[17:39:21.693]  - Number of values expected: 2
[17:39:21.693] Reducing values from 2 chunks ... DONE
[17:39:21.693] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:39:21.694] plan(): Setting new future strategy stack:
[17:39:21.694] List of future strategies:
[17:39:21.694] 1. sequential:
[17:39:21.694]    - args: function (..., envir = parent.frame())
[17:39:21.694]    - tweaked: FALSE
[17:39:21.694]    - call: plan(sequential)
[17:39:21.694] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:39:21.695] plan(): Setting new future strategy stack:
[17:39:21.695] List of future strategies:
[17:39:21.695] 1. multisession:
[17:39:21.695]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:21.695]    - tweaked: FALSE
[17:39:21.695]    - call: plan(strategy)
[17:39:21.695] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:21.698] multisession:
[17:39:21.698] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:21.698] - tweaked: FALSE
[17:39:21.698] - call: plan(strategy)
[17:39:21.706] getGlobalsAndPackages() ...
[17:39:21.706] Not searching for globals
[17:39:21.706] - globals: [0] <none>
[17:39:21.707] getGlobalsAndPackages() ... DONE
[17:39:21.707] [local output] makeClusterPSOCK() ...
[17:39:21.749] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:21.754] [local output] Base port: 11038
[17:39:21.754] [local output] Getting setup options for 2 cluster nodes ...
[17:39:21.754] [local output]  - Node 1 of 2 ...
[17:39:21.755] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:21.756] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXrjv13/worker.rank=1.parallelly.parent=30260.76346e66c967.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpXrjv13/worker.rank=1.parallelly.parent=30260.76346e66c967.pid")'’
[17:39:21.945] - Possible to infer worker's PID: TRUE
[17:39:21.945] [local output] Rscript port: 11038

[17:39:21.945] [local output]  - Node 2 of 2 ...
[17:39:21.946] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:21.946] [local output] Rscript port: 11038

[17:39:21.947] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:21.947] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:21.947] [local output] Setting up PSOCK nodes in parallel
[17:39:21.947] List of 36
[17:39:21.947]  $ worker          : chr "localhost"
[17:39:21.947]   ..- attr(*, "localhost")= logi TRUE
[17:39:21.947]  $ master          : chr "localhost"
[17:39:21.947]  $ port            : int 11038
[17:39:21.947]  $ connectTimeout  : num 120
[17:39:21.947]  $ timeout         : num 2592000
[17:39:21.947]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:21.947]  $ homogeneous     : logi TRUE
[17:39:21.947]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:21.947]  $ rscript_envs    : NULL
[17:39:21.947]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:21.947]  $ rscript_startup : NULL
[17:39:21.947]  $ rscript_sh      : chr "sh"
[17:39:21.947]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:21.947]  $ methods         : logi TRUE
[17:39:21.947]  $ socketOptions   : chr "no-delay"
[17:39:21.947]  $ useXDR          : logi FALSE
[17:39:21.947]  $ outfile         : chr "/dev/null"
[17:39:21.947]  $ renice          : int NA
[17:39:21.947]  $ rshcmd          : NULL
[17:39:21.947]  $ user            : chr(0) 
[17:39:21.947]  $ revtunnel       : logi FALSE
[17:39:21.947]  $ rshlogfile      : NULL
[17:39:21.947]  $ rshopts         : chr(0) 
[17:39:21.947]  $ rank            : int 1
[17:39:21.947]  $ manual          : logi FALSE
[17:39:21.947]  $ dryrun          : logi FALSE
[17:39:21.947]  $ quiet           : logi FALSE
[17:39:21.947]  $ setup_strategy  : chr "parallel"
[17:39:21.947]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:21.947]  $ pidfile         : chr "/tmp/RtmpXrjv13/worker.rank=1.parallelly.parent=30260.76346e66c967.pid"
[17:39:21.947]  $ rshcmd_label    : NULL
[17:39:21.947]  $ rsh_call        : NULL
[17:39:21.947]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:21.947]  $ localMachine    : logi TRUE
[17:39:21.947]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:21.947]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:21.947]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:21.947]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:21.947]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:21.947]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:21.947]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:21.947]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:21.947]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:21.947]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:21.947]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:21.947]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:21.947]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:21.947]  $ arguments       :List of 28
[17:39:21.947]   ..$ worker          : chr "localhost"
[17:39:21.947]   ..$ master          : NULL
[17:39:21.947]   ..$ port            : int 11038
[17:39:21.947]   ..$ connectTimeout  : num 120
[17:39:21.947]   ..$ timeout         : num 2592000
[17:39:21.947]   ..$ rscript         : NULL
[17:39:21.947]   ..$ homogeneous     : NULL
[17:39:21.947]   ..$ rscript_args    : NULL
[17:39:21.947]   ..$ rscript_envs    : NULL
[17:39:21.947]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:21.947]   ..$ rscript_startup : NULL
[17:39:21.947]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:21.947]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:21.947]   ..$ methods         : logi TRUE
[17:39:21.947]   ..$ socketOptions   : chr "no-delay"
[17:39:21.947]   ..$ useXDR          : logi FALSE
[17:39:21.947]   ..$ outfile         : chr "/dev/null"
[17:39:21.947]   ..$ renice          : int NA
[17:39:21.947]   ..$ rshcmd          : NULL
[17:39:21.947]   ..$ user            : NULL
[17:39:21.947]   ..$ revtunnel       : logi NA
[17:39:21.947]   ..$ rshlogfile      : NULL
[17:39:21.947]   ..$ rshopts         : NULL
[17:39:21.947]   ..$ rank            : int 1
[17:39:21.947]   ..$ manual          : logi FALSE
[17:39:21.947]   ..$ dryrun          : logi FALSE
[17:39:21.947]   ..$ quiet           : logi FALSE
[17:39:21.947]   ..$ setup_strategy  : chr "parallel"
[17:39:21.947]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:21.965] [local output] System call to launch all workers:
[17:39:21.965] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXrjv13/worker.rank=1.parallelly.parent=30260.76346e66c967.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11038 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:21.965] [local output] Starting PSOCK main server
[17:39:21.966] [local output] Workers launched
[17:39:21.966] [local output] Waiting for workers to connect back
[17:39:21.967]  - [local output] 0 workers out of 2 ready
[17:39:22.233]  - [local output] 0 workers out of 2 ready
[17:39:22.233]  - [local output] 1 workers out of 2 ready
[17:39:22.233]  - [local output] 2 workers out of 2 ready
[17:39:22.234] [local output] Launching of workers completed
[17:39:22.234] [local output] Collecting session information from workers
[17:39:22.235] [local output]  - Worker #1 of 2
[17:39:22.235] [local output]  - Worker #2 of 2
[17:39:22.235] [local output] makeClusterPSOCK() ... done
[17:39:22.248] Packages needed by the future expression (n = 0): <none>
[17:39:22.248] Packages needed by future strategies (n = 0): <none>
[17:39:22.249] {
[17:39:22.249]     {
[17:39:22.249]         {
[17:39:22.249]             ...future.startTime <- base::Sys.time()
[17:39:22.249]             {
[17:39:22.249]                 {
[17:39:22.249]                   {
[17:39:22.249]                     {
[17:39:22.249]                       base::local({
[17:39:22.249]                         has_future <- base::requireNamespace("future", 
[17:39:22.249]                           quietly = TRUE)
[17:39:22.249]                         if (has_future) {
[17:39:22.249]                           ns <- base::getNamespace("future")
[17:39:22.249]                           version <- ns[[".package"]][["version"]]
[17:39:22.249]                           if (is.null(version)) 
[17:39:22.249]                             version <- utils::packageVersion("future")
[17:39:22.249]                         }
[17:39:22.249]                         else {
[17:39:22.249]                           version <- NULL
[17:39:22.249]                         }
[17:39:22.249]                         if (!has_future || version < "1.8.0") {
[17:39:22.249]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:22.249]                             "", base::R.version$version.string), 
[17:39:22.249]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:22.249]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:22.249]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:22.249]                               "release", "version")], collapse = " "), 
[17:39:22.249]                             hostname = base::Sys.info()[["nodename"]])
[17:39:22.249]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:22.249]                             info)
[17:39:22.249]                           info <- base::paste(info, collapse = "; ")
[17:39:22.249]                           if (!has_future) {
[17:39:22.249]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:22.249]                               info)
[17:39:22.249]                           }
[17:39:22.249]                           else {
[17:39:22.249]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:22.249]                               info, version)
[17:39:22.249]                           }
[17:39:22.249]                           base::stop(msg)
[17:39:22.249]                         }
[17:39:22.249]                       })
[17:39:22.249]                     }
[17:39:22.249]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:22.249]                     base::options(mc.cores = 1L)
[17:39:22.249]                   }
[17:39:22.249]                   options(future.plan = NULL)
[17:39:22.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:22.249]                 }
[17:39:22.249]                 ...future.workdir <- getwd()
[17:39:22.249]             }
[17:39:22.249]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:22.249]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:22.249]         }
[17:39:22.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:22.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:22.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:22.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:22.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:22.249]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:22.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:22.249]             base::names(...future.oldOptions))
[17:39:22.249]     }
[17:39:22.249]     if (FALSE) {
[17:39:22.249]     }
[17:39:22.249]     else {
[17:39:22.249]         if (TRUE) {
[17:39:22.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:22.249]                 open = "w")
[17:39:22.249]         }
[17:39:22.249]         else {
[17:39:22.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:22.249]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:22.249]         }
[17:39:22.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:22.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:22.249]             base::sink(type = "output", split = FALSE)
[17:39:22.249]             base::close(...future.stdout)
[17:39:22.249]         }, add = TRUE)
[17:39:22.249]     }
[17:39:22.249]     ...future.frame <- base::sys.nframe()
[17:39:22.249]     ...future.conditions <- base::list()
[17:39:22.249]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:22.249]     if (FALSE) {
[17:39:22.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:22.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:22.249]     }
[17:39:22.249]     ...future.result <- base::tryCatch({
[17:39:22.249]         base::withCallingHandlers({
[17:39:22.249]             ...future.value <- base::withVisible(base::local({
[17:39:22.249]                 ...future.makeSendCondition <- local({
[17:39:22.249]                   sendCondition <- NULL
[17:39:22.249]                   function(frame = 1L) {
[17:39:22.249]                     if (is.function(sendCondition)) 
[17:39:22.249]                       return(sendCondition)
[17:39:22.249]                     ns <- getNamespace("parallel")
[17:39:22.249]                     if (exists("sendData", mode = "function", 
[17:39:22.249]                       envir = ns)) {
[17:39:22.249]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:22.249]                         envir = ns)
[17:39:22.249]                       envir <- sys.frame(frame)
[17:39:22.249]                       master <- NULL
[17:39:22.249]                       while (!identical(envir, .GlobalEnv) && 
[17:39:22.249]                         !identical(envir, emptyenv())) {
[17:39:22.249]                         if (exists("master", mode = "list", envir = envir, 
[17:39:22.249]                           inherits = FALSE)) {
[17:39:22.249]                           master <- get("master", mode = "list", 
[17:39:22.249]                             envir = envir, inherits = FALSE)
[17:39:22.249]                           if (inherits(master, c("SOCKnode", 
[17:39:22.249]                             "SOCK0node"))) {
[17:39:22.249]                             sendCondition <<- function(cond) {
[17:39:22.249]                               data <- list(type = "VALUE", value = cond, 
[17:39:22.249]                                 success = TRUE)
[17:39:22.249]                               parallel_sendData(master, data)
[17:39:22.249]                             }
[17:39:22.249]                             return(sendCondition)
[17:39:22.249]                           }
[17:39:22.249]                         }
[17:39:22.249]                         frame <- frame + 1L
[17:39:22.249]                         envir <- sys.frame(frame)
[17:39:22.249]                       }
[17:39:22.249]                     }
[17:39:22.249]                     sendCondition <<- function(cond) NULL
[17:39:22.249]                   }
[17:39:22.249]                 })
[17:39:22.249]                 withCallingHandlers({
[17:39:22.249]                   NA
[17:39:22.249]                 }, immediateCondition = function(cond) {
[17:39:22.249]                   sendCondition <- ...future.makeSendCondition()
[17:39:22.249]                   sendCondition(cond)
[17:39:22.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.249]                   {
[17:39:22.249]                     inherits <- base::inherits
[17:39:22.249]                     invokeRestart <- base::invokeRestart
[17:39:22.249]                     is.null <- base::is.null
[17:39:22.249]                     muffled <- FALSE
[17:39:22.249]                     if (inherits(cond, "message")) {
[17:39:22.249]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:22.249]                       if (muffled) 
[17:39:22.249]                         invokeRestart("muffleMessage")
[17:39:22.249]                     }
[17:39:22.249]                     else if (inherits(cond, "warning")) {
[17:39:22.249]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:22.249]                       if (muffled) 
[17:39:22.249]                         invokeRestart("muffleWarning")
[17:39:22.249]                     }
[17:39:22.249]                     else if (inherits(cond, "condition")) {
[17:39:22.249]                       if (!is.null(pattern)) {
[17:39:22.249]                         computeRestarts <- base::computeRestarts
[17:39:22.249]                         grepl <- base::grepl
[17:39:22.249]                         restarts <- computeRestarts(cond)
[17:39:22.249]                         for (restart in restarts) {
[17:39:22.249]                           name <- restart$name
[17:39:22.249]                           if (is.null(name)) 
[17:39:22.249]                             next
[17:39:22.249]                           if (!grepl(pattern, name)) 
[17:39:22.249]                             next
[17:39:22.249]                           invokeRestart(restart)
[17:39:22.249]                           muffled <- TRUE
[17:39:22.249]                           break
[17:39:22.249]                         }
[17:39:22.249]                       }
[17:39:22.249]                     }
[17:39:22.249]                     invisible(muffled)
[17:39:22.249]                   }
[17:39:22.249]                   muffleCondition(cond)
[17:39:22.249]                 })
[17:39:22.249]             }))
[17:39:22.249]             future::FutureResult(value = ...future.value$value, 
[17:39:22.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.249]                   ...future.rng), globalenv = if (FALSE) 
[17:39:22.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:22.249]                     ...future.globalenv.names))
[17:39:22.249]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:22.249]         }, condition = base::local({
[17:39:22.249]             c <- base::c
[17:39:22.249]             inherits <- base::inherits
[17:39:22.249]             invokeRestart <- base::invokeRestart
[17:39:22.249]             length <- base::length
[17:39:22.249]             list <- base::list
[17:39:22.249]             seq.int <- base::seq.int
[17:39:22.249]             signalCondition <- base::signalCondition
[17:39:22.249]             sys.calls <- base::sys.calls
[17:39:22.249]             `[[` <- base::`[[`
[17:39:22.249]             `+` <- base::`+`
[17:39:22.249]             `<<-` <- base::`<<-`
[17:39:22.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:22.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:22.249]                   3L)]
[17:39:22.249]             }
[17:39:22.249]             function(cond) {
[17:39:22.249]                 is_error <- inherits(cond, "error")
[17:39:22.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:22.249]                   NULL)
[17:39:22.249]                 if (is_error) {
[17:39:22.249]                   sessionInformation <- function() {
[17:39:22.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:22.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:22.249]                       search = base::search(), system = base::Sys.info())
[17:39:22.249]                   }
[17:39:22.249]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:22.249]                     cond$call), session = sessionInformation(), 
[17:39:22.249]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:22.249]                   signalCondition(cond)
[17:39:22.249]                 }
[17:39:22.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:22.249]                 "immediateCondition"))) {
[17:39:22.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:22.249]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:22.249]                   if (TRUE && !signal) {
[17:39:22.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.249]                     {
[17:39:22.249]                       inherits <- base::inherits
[17:39:22.249]                       invokeRestart <- base::invokeRestart
[17:39:22.249]                       is.null <- base::is.null
[17:39:22.249]                       muffled <- FALSE
[17:39:22.249]                       if (inherits(cond, "message")) {
[17:39:22.249]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.249]                         if (muffled) 
[17:39:22.249]                           invokeRestart("muffleMessage")
[17:39:22.249]                       }
[17:39:22.249]                       else if (inherits(cond, "warning")) {
[17:39:22.249]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.249]                         if (muffled) 
[17:39:22.249]                           invokeRestart("muffleWarning")
[17:39:22.249]                       }
[17:39:22.249]                       else if (inherits(cond, "condition")) {
[17:39:22.249]                         if (!is.null(pattern)) {
[17:39:22.249]                           computeRestarts <- base::computeRestarts
[17:39:22.249]                           grepl <- base::grepl
[17:39:22.249]                           restarts <- computeRestarts(cond)
[17:39:22.249]                           for (restart in restarts) {
[17:39:22.249]                             name <- restart$name
[17:39:22.249]                             if (is.null(name)) 
[17:39:22.249]                               next
[17:39:22.249]                             if (!grepl(pattern, name)) 
[17:39:22.249]                               next
[17:39:22.249]                             invokeRestart(restart)
[17:39:22.249]                             muffled <- TRUE
[17:39:22.249]                             break
[17:39:22.249]                           }
[17:39:22.249]                         }
[17:39:22.249]                       }
[17:39:22.249]                       invisible(muffled)
[17:39:22.249]                     }
[17:39:22.249]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.249]                   }
[17:39:22.249]                 }
[17:39:22.249]                 else {
[17:39:22.249]                   if (TRUE) {
[17:39:22.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.249]                     {
[17:39:22.249]                       inherits <- base::inherits
[17:39:22.249]                       invokeRestart <- base::invokeRestart
[17:39:22.249]                       is.null <- base::is.null
[17:39:22.249]                       muffled <- FALSE
[17:39:22.249]                       if (inherits(cond, "message")) {
[17:39:22.249]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.249]                         if (muffled) 
[17:39:22.249]                           invokeRestart("muffleMessage")
[17:39:22.249]                       }
[17:39:22.249]                       else if (inherits(cond, "warning")) {
[17:39:22.249]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.249]                         if (muffled) 
[17:39:22.249]                           invokeRestart("muffleWarning")
[17:39:22.249]                       }
[17:39:22.249]                       else if (inherits(cond, "condition")) {
[17:39:22.249]                         if (!is.null(pattern)) {
[17:39:22.249]                           computeRestarts <- base::computeRestarts
[17:39:22.249]                           grepl <- base::grepl
[17:39:22.249]                           restarts <- computeRestarts(cond)
[17:39:22.249]                           for (restart in restarts) {
[17:39:22.249]                             name <- restart$name
[17:39:22.249]                             if (is.null(name)) 
[17:39:22.249]                               next
[17:39:22.249]                             if (!grepl(pattern, name)) 
[17:39:22.249]                               next
[17:39:22.249]                             invokeRestart(restart)
[17:39:22.249]                             muffled <- TRUE
[17:39:22.249]                             break
[17:39:22.249]                           }
[17:39:22.249]                         }
[17:39:22.249]                       }
[17:39:22.249]                       invisible(muffled)
[17:39:22.249]                     }
[17:39:22.249]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.249]                   }
[17:39:22.249]                 }
[17:39:22.249]             }
[17:39:22.249]         }))
[17:39:22.249]     }, error = function(ex) {
[17:39:22.249]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:22.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.249]                 ...future.rng), started = ...future.startTime, 
[17:39:22.249]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:22.249]             version = "1.8"), class = "FutureResult")
[17:39:22.249]     }, finally = {
[17:39:22.249]         if (!identical(...future.workdir, getwd())) 
[17:39:22.249]             setwd(...future.workdir)
[17:39:22.249]         {
[17:39:22.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:22.249]                 ...future.oldOptions$nwarnings <- NULL
[17:39:22.249]             }
[17:39:22.249]             base::options(...future.oldOptions)
[17:39:22.249]             if (.Platform$OS.type == "windows") {
[17:39:22.249]                 old_names <- names(...future.oldEnvVars)
[17:39:22.249]                 envs <- base::Sys.getenv()
[17:39:22.249]                 names <- names(envs)
[17:39:22.249]                 common <- intersect(names, old_names)
[17:39:22.249]                 added <- setdiff(names, old_names)
[17:39:22.249]                 removed <- setdiff(old_names, names)
[17:39:22.249]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:22.249]                   envs[common]]
[17:39:22.249]                 NAMES <- toupper(changed)
[17:39:22.249]                 args <- list()
[17:39:22.249]                 for (kk in seq_along(NAMES)) {
[17:39:22.249]                   name <- changed[[kk]]
[17:39:22.249]                   NAME <- NAMES[[kk]]
[17:39:22.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.249]                     next
[17:39:22.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.249]                 }
[17:39:22.249]                 NAMES <- toupper(added)
[17:39:22.249]                 for (kk in seq_along(NAMES)) {
[17:39:22.249]                   name <- added[[kk]]
[17:39:22.249]                   NAME <- NAMES[[kk]]
[17:39:22.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.249]                     next
[17:39:22.249]                   args[[name]] <- ""
[17:39:22.249]                 }
[17:39:22.249]                 NAMES <- toupper(removed)
[17:39:22.249]                 for (kk in seq_along(NAMES)) {
[17:39:22.249]                   name <- removed[[kk]]
[17:39:22.249]                   NAME <- NAMES[[kk]]
[17:39:22.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.249]                     next
[17:39:22.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.249]                 }
[17:39:22.249]                 if (length(args) > 0) 
[17:39:22.249]                   base::do.call(base::Sys.setenv, args = args)
[17:39:22.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:22.249]             }
[17:39:22.249]             else {
[17:39:22.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:22.249]             }
[17:39:22.249]             {
[17:39:22.249]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:22.249]                   0L) {
[17:39:22.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:22.249]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:22.249]                   base::options(opts)
[17:39:22.249]                 }
[17:39:22.249]                 {
[17:39:22.249]                   {
[17:39:22.249]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:22.249]                     NULL
[17:39:22.249]                   }
[17:39:22.249]                   options(future.plan = NULL)
[17:39:22.249]                   if (is.na(NA_character_)) 
[17:39:22.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:22.249]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:22.249]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:22.249]                     envir = parent.frame()) 
[17:39:22.249]                   {
[17:39:22.249]                     if (is.function(workers)) 
[17:39:22.249]                       workers <- workers()
[17:39:22.249]                     workers <- structure(as.integer(workers), 
[17:39:22.249]                       class = class(workers))
[17:39:22.249]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:22.249]                       workers >= 1)
[17:39:22.249]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:22.249]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:22.249]                     }
[17:39:22.249]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:22.249]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:22.249]                       envir = envir)
[17:39:22.249]                     if (!future$lazy) 
[17:39:22.249]                       future <- run(future)
[17:39:22.249]                     invisible(future)
[17:39:22.249]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:22.249]                 }
[17:39:22.249]             }
[17:39:22.249]         }
[17:39:22.249]     })
[17:39:22.249]     if (TRUE) {
[17:39:22.249]         base::sink(type = "output", split = FALSE)
[17:39:22.249]         if (TRUE) {
[17:39:22.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:22.249]         }
[17:39:22.249]         else {
[17:39:22.249]             ...future.result["stdout"] <- base::list(NULL)
[17:39:22.249]         }
[17:39:22.249]         base::close(...future.stdout)
[17:39:22.249]         ...future.stdout <- NULL
[17:39:22.249]     }
[17:39:22.249]     ...future.result$conditions <- ...future.conditions
[17:39:22.249]     ...future.result$finished <- base::Sys.time()
[17:39:22.249]     ...future.result
[17:39:22.249] }
[17:39:22.321] MultisessionFuture started
[17:39:22.321] result() for ClusterFuture ...
[17:39:22.322] receiveMessageFromWorker() for ClusterFuture ...
[17:39:22.322] - Validating connection of MultisessionFuture
[17:39:22.354] - received message: FutureResult
[17:39:22.355] - Received FutureResult
[17:39:22.355] - Erased future from FutureRegistry
[17:39:22.355] result() for ClusterFuture ...
[17:39:22.355] - result already collected: FutureResult
[17:39:22.355] result() for ClusterFuture ... done
[17:39:22.355] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:22.355] result() for ClusterFuture ... done
[17:39:22.356] result() for ClusterFuture ...
[17:39:22.356] - result already collected: FutureResult
[17:39:22.356] result() for ClusterFuture ... done
[17:39:22.356] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:22.360] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[17:39:22.360] getGlobalsAndPackagesXApply() ...
[17:39:22.361]  - future.globals: TRUE
[17:39:22.361] getGlobalsAndPackages() ...
[17:39:22.361] Searching for globals...
[17:39:22.405] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:39:22.406] Searching for globals ... DONE
[17:39:22.406] Resolving globals: FALSE
[17:39:22.407] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:39:22.408] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:39:22.408] - globals: [1] ‘FUN’
[17:39:22.408] 
[17:39:22.408] getGlobalsAndPackages() ... DONE
[17:39:22.408]  - globals found/used: [n=1] ‘FUN’
[17:39:22.408]  - needed namespaces: [n=0] 
[17:39:22.408] Finding globals ... DONE
[17:39:22.408]  - use_args: TRUE
[17:39:22.409]  - Getting '...' globals ...
[17:39:22.409] resolve() on list ...
[17:39:22.409]  recursive: 0
[17:39:22.409]  length: 1
[17:39:22.409]  elements: ‘...’
[17:39:22.409]  length: 0 (resolved future 1)
[17:39:22.409] resolve() on list ... DONE
[17:39:22.409]    - '...' content: [n=0] 
[17:39:22.410] List of 1
[17:39:22.410]  $ ...: list()
[17:39:22.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:22.410]  - attr(*, "where")=List of 1
[17:39:22.410]   ..$ ...:<environment: 0x55c797f1cbe0> 
[17:39:22.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:22.410]  - attr(*, "resolved")= logi TRUE
[17:39:22.410]  - attr(*, "total_size")= num NA
[17:39:22.412]  - Getting '...' globals ... DONE
[17:39:22.412] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:22.412] List of 2
[17:39:22.412]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:22.412]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:22.412]  $ ...          : list()
[17:39:22.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:22.412]  - attr(*, "where")=List of 2
[17:39:22.412]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:22.412]   ..$ ...          :<environment: 0x55c797f1cbe0> 
[17:39:22.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:22.412]  - attr(*, "resolved")= logi FALSE
[17:39:22.412]  - attr(*, "total_size")= num 354224
[17:39:22.415] Packages to be attached in all futures: [n=0] 
[17:39:22.415] getGlobalsAndPackagesXApply() ... DONE
[17:39:22.419] future_lapply() ...
[17:39:22.452] Number of chunks: 2
[17:39:22.452] getGlobalsAndPackagesXApply() ...
[17:39:22.453]  - future.globals: <name-value list> with names ‘list()’
[17:39:22.453]  - use_args: TRUE
[17:39:22.453] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:22.453] List of 2
[17:39:22.453]  $ ...          : list()
[17:39:22.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:22.453]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:22.453]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:22.453]  - attr(*, "where")=List of 2
[17:39:22.453]   ..$ ...          :<environment: 0x55c797f1cbe0> 
[17:39:22.453]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:22.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:22.453]  - attr(*, "resolved")= logi FALSE
[17:39:22.453]  - attr(*, "total_size")= num NA
[17:39:22.457] Packages to be attached in all futures: [n=0] 
[17:39:22.457] getGlobalsAndPackagesXApply() ... DONE
[17:39:22.457] Number of futures (= number of chunks): 2
[17:39:22.457] Launching 2 futures (chunks) ...
[17:39:22.457] Chunk #1 of 2 ...
[17:39:22.457]  - seeds: <none>
[17:39:22.457] getGlobalsAndPackages() ...
[17:39:22.457] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:22.458] Resolving globals: FALSE
[17:39:22.458] Tweak future expression to call with '...' arguments ...
[17:39:22.458] {
[17:39:22.458]     do.call(function(...) {
[17:39:22.458]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.458]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:22.458]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.458]             on.exit(options(oopts), add = TRUE)
[17:39:22.458]         }
[17:39:22.458]         {
[17:39:22.458]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:22.458]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.458]                 ...future.FUN(...future.X_jj, ...)
[17:39:22.458]             })
[17:39:22.458]         }
[17:39:22.458]     }, args = future.call.arguments)
[17:39:22.458] }
[17:39:22.458] Tweak future expression to call with '...' arguments ... DONE
[17:39:22.458] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:22.459] 
[17:39:22.459] getGlobalsAndPackages() ... DONE
[17:39:22.459] run() for ‘Future’ ...
[17:39:22.459] - state: ‘created’
[17:39:22.459] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:22.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:22.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:22.474]   - Field: ‘node’
[17:39:22.474]   - Field: ‘label’
[17:39:22.474]   - Field: ‘local’
[17:39:22.474]   - Field: ‘owner’
[17:39:22.474]   - Field: ‘envir’
[17:39:22.475]   - Field: ‘workers’
[17:39:22.475]   - Field: ‘packages’
[17:39:22.475]   - Field: ‘gc’
[17:39:22.475]   - Field: ‘conditions’
[17:39:22.475]   - Field: ‘persistent’
[17:39:22.475]   - Field: ‘expr’
[17:39:22.475]   - Field: ‘uuid’
[17:39:22.475]   - Field: ‘seed’
[17:39:22.475]   - Field: ‘version’
[17:39:22.475]   - Field: ‘result’
[17:39:22.475]   - Field: ‘asynchronous’
[17:39:22.476]   - Field: ‘calls’
[17:39:22.476]   - Field: ‘globals’
[17:39:22.476]   - Field: ‘stdout’
[17:39:22.476]   - Field: ‘earlySignal’
[17:39:22.476]   - Field: ‘lazy’
[17:39:22.476]   - Field: ‘state’
[17:39:22.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:22.476] - Launch lazy future ...
[17:39:22.476] Packages needed by the future expression (n = 0): <none>
[17:39:22.477] Packages needed by future strategies (n = 0): <none>
[17:39:22.477] {
[17:39:22.477]     {
[17:39:22.477]         {
[17:39:22.477]             ...future.startTime <- base::Sys.time()
[17:39:22.477]             {
[17:39:22.477]                 {
[17:39:22.477]                   {
[17:39:22.477]                     {
[17:39:22.477]                       base::local({
[17:39:22.477]                         has_future <- base::requireNamespace("future", 
[17:39:22.477]                           quietly = TRUE)
[17:39:22.477]                         if (has_future) {
[17:39:22.477]                           ns <- base::getNamespace("future")
[17:39:22.477]                           version <- ns[[".package"]][["version"]]
[17:39:22.477]                           if (is.null(version)) 
[17:39:22.477]                             version <- utils::packageVersion("future")
[17:39:22.477]                         }
[17:39:22.477]                         else {
[17:39:22.477]                           version <- NULL
[17:39:22.477]                         }
[17:39:22.477]                         if (!has_future || version < "1.8.0") {
[17:39:22.477]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:22.477]                             "", base::R.version$version.string), 
[17:39:22.477]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:22.477]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:22.477]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:22.477]                               "release", "version")], collapse = " "), 
[17:39:22.477]                             hostname = base::Sys.info()[["nodename"]])
[17:39:22.477]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:22.477]                             info)
[17:39:22.477]                           info <- base::paste(info, collapse = "; ")
[17:39:22.477]                           if (!has_future) {
[17:39:22.477]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:22.477]                               info)
[17:39:22.477]                           }
[17:39:22.477]                           else {
[17:39:22.477]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:22.477]                               info, version)
[17:39:22.477]                           }
[17:39:22.477]                           base::stop(msg)
[17:39:22.477]                         }
[17:39:22.477]                       })
[17:39:22.477]                     }
[17:39:22.477]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:22.477]                     base::options(mc.cores = 1L)
[17:39:22.477]                   }
[17:39:22.477]                   options(future.plan = NULL)
[17:39:22.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:22.477]                 }
[17:39:22.477]                 ...future.workdir <- getwd()
[17:39:22.477]             }
[17:39:22.477]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:22.477]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:22.477]         }
[17:39:22.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:22.477]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:22.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:22.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:22.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:22.477]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:22.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:22.477]             base::names(...future.oldOptions))
[17:39:22.477]     }
[17:39:22.477]     if (FALSE) {
[17:39:22.477]     }
[17:39:22.477]     else {
[17:39:22.477]         if (TRUE) {
[17:39:22.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:22.477]                 open = "w")
[17:39:22.477]         }
[17:39:22.477]         else {
[17:39:22.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:22.477]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:22.477]         }
[17:39:22.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:22.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:22.477]             base::sink(type = "output", split = FALSE)
[17:39:22.477]             base::close(...future.stdout)
[17:39:22.477]         }, add = TRUE)
[17:39:22.477]     }
[17:39:22.477]     ...future.frame <- base::sys.nframe()
[17:39:22.477]     ...future.conditions <- base::list()
[17:39:22.477]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:22.477]     if (FALSE) {
[17:39:22.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:22.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:22.477]     }
[17:39:22.477]     ...future.result <- base::tryCatch({
[17:39:22.477]         base::withCallingHandlers({
[17:39:22.477]             ...future.value <- base::withVisible(base::local({
[17:39:22.477]                 ...future.makeSendCondition <- local({
[17:39:22.477]                   sendCondition <- NULL
[17:39:22.477]                   function(frame = 1L) {
[17:39:22.477]                     if (is.function(sendCondition)) 
[17:39:22.477]                       return(sendCondition)
[17:39:22.477]                     ns <- getNamespace("parallel")
[17:39:22.477]                     if (exists("sendData", mode = "function", 
[17:39:22.477]                       envir = ns)) {
[17:39:22.477]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:22.477]                         envir = ns)
[17:39:22.477]                       envir <- sys.frame(frame)
[17:39:22.477]                       master <- NULL
[17:39:22.477]                       while (!identical(envir, .GlobalEnv) && 
[17:39:22.477]                         !identical(envir, emptyenv())) {
[17:39:22.477]                         if (exists("master", mode = "list", envir = envir, 
[17:39:22.477]                           inherits = FALSE)) {
[17:39:22.477]                           master <- get("master", mode = "list", 
[17:39:22.477]                             envir = envir, inherits = FALSE)
[17:39:22.477]                           if (inherits(master, c("SOCKnode", 
[17:39:22.477]                             "SOCK0node"))) {
[17:39:22.477]                             sendCondition <<- function(cond) {
[17:39:22.477]                               data <- list(type = "VALUE", value = cond, 
[17:39:22.477]                                 success = TRUE)
[17:39:22.477]                               parallel_sendData(master, data)
[17:39:22.477]                             }
[17:39:22.477]                             return(sendCondition)
[17:39:22.477]                           }
[17:39:22.477]                         }
[17:39:22.477]                         frame <- frame + 1L
[17:39:22.477]                         envir <- sys.frame(frame)
[17:39:22.477]                       }
[17:39:22.477]                     }
[17:39:22.477]                     sendCondition <<- function(cond) NULL
[17:39:22.477]                   }
[17:39:22.477]                 })
[17:39:22.477]                 withCallingHandlers({
[17:39:22.477]                   {
[17:39:22.477]                     do.call(function(...) {
[17:39:22.477]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.477]                       if (!identical(...future.globals.maxSize.org, 
[17:39:22.477]                         ...future.globals.maxSize)) {
[17:39:22.477]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.477]                         on.exit(options(oopts), add = TRUE)
[17:39:22.477]                       }
[17:39:22.477]                       {
[17:39:22.477]                         lapply(seq_along(...future.elements_ii), 
[17:39:22.477]                           FUN = function(jj) {
[17:39:22.477]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.477]                             ...future.FUN(...future.X_jj, ...)
[17:39:22.477]                           })
[17:39:22.477]                       }
[17:39:22.477]                     }, args = future.call.arguments)
[17:39:22.477]                   }
[17:39:22.477]                 }, immediateCondition = function(cond) {
[17:39:22.477]                   sendCondition <- ...future.makeSendCondition()
[17:39:22.477]                   sendCondition(cond)
[17:39:22.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.477]                   {
[17:39:22.477]                     inherits <- base::inherits
[17:39:22.477]                     invokeRestart <- base::invokeRestart
[17:39:22.477]                     is.null <- base::is.null
[17:39:22.477]                     muffled <- FALSE
[17:39:22.477]                     if (inherits(cond, "message")) {
[17:39:22.477]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:22.477]                       if (muffled) 
[17:39:22.477]                         invokeRestart("muffleMessage")
[17:39:22.477]                     }
[17:39:22.477]                     else if (inherits(cond, "warning")) {
[17:39:22.477]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:22.477]                       if (muffled) 
[17:39:22.477]                         invokeRestart("muffleWarning")
[17:39:22.477]                     }
[17:39:22.477]                     else if (inherits(cond, "condition")) {
[17:39:22.477]                       if (!is.null(pattern)) {
[17:39:22.477]                         computeRestarts <- base::computeRestarts
[17:39:22.477]                         grepl <- base::grepl
[17:39:22.477]                         restarts <- computeRestarts(cond)
[17:39:22.477]                         for (restart in restarts) {
[17:39:22.477]                           name <- restart$name
[17:39:22.477]                           if (is.null(name)) 
[17:39:22.477]                             next
[17:39:22.477]                           if (!grepl(pattern, name)) 
[17:39:22.477]                             next
[17:39:22.477]                           invokeRestart(restart)
[17:39:22.477]                           muffled <- TRUE
[17:39:22.477]                           break
[17:39:22.477]                         }
[17:39:22.477]                       }
[17:39:22.477]                     }
[17:39:22.477]                     invisible(muffled)
[17:39:22.477]                   }
[17:39:22.477]                   muffleCondition(cond)
[17:39:22.477]                 })
[17:39:22.477]             }))
[17:39:22.477]             future::FutureResult(value = ...future.value$value, 
[17:39:22.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.477]                   ...future.rng), globalenv = if (FALSE) 
[17:39:22.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:22.477]                     ...future.globalenv.names))
[17:39:22.477]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:22.477]         }, condition = base::local({
[17:39:22.477]             c <- base::c
[17:39:22.477]             inherits <- base::inherits
[17:39:22.477]             invokeRestart <- base::invokeRestart
[17:39:22.477]             length <- base::length
[17:39:22.477]             list <- base::list
[17:39:22.477]             seq.int <- base::seq.int
[17:39:22.477]             signalCondition <- base::signalCondition
[17:39:22.477]             sys.calls <- base::sys.calls
[17:39:22.477]             `[[` <- base::`[[`
[17:39:22.477]             `+` <- base::`+`
[17:39:22.477]             `<<-` <- base::`<<-`
[17:39:22.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:22.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:22.477]                   3L)]
[17:39:22.477]             }
[17:39:22.477]             function(cond) {
[17:39:22.477]                 is_error <- inherits(cond, "error")
[17:39:22.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:22.477]                   NULL)
[17:39:22.477]                 if (is_error) {
[17:39:22.477]                   sessionInformation <- function() {
[17:39:22.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:22.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:22.477]                       search = base::search(), system = base::Sys.info())
[17:39:22.477]                   }
[17:39:22.477]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:22.477]                     cond$call), session = sessionInformation(), 
[17:39:22.477]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:22.477]                   signalCondition(cond)
[17:39:22.477]                 }
[17:39:22.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:22.477]                 "immediateCondition"))) {
[17:39:22.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:22.477]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:22.477]                   if (TRUE && !signal) {
[17:39:22.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.477]                     {
[17:39:22.477]                       inherits <- base::inherits
[17:39:22.477]                       invokeRestart <- base::invokeRestart
[17:39:22.477]                       is.null <- base::is.null
[17:39:22.477]                       muffled <- FALSE
[17:39:22.477]                       if (inherits(cond, "message")) {
[17:39:22.477]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.477]                         if (muffled) 
[17:39:22.477]                           invokeRestart("muffleMessage")
[17:39:22.477]                       }
[17:39:22.477]                       else if (inherits(cond, "warning")) {
[17:39:22.477]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.477]                         if (muffled) 
[17:39:22.477]                           invokeRestart("muffleWarning")
[17:39:22.477]                       }
[17:39:22.477]                       else if (inherits(cond, "condition")) {
[17:39:22.477]                         if (!is.null(pattern)) {
[17:39:22.477]                           computeRestarts <- base::computeRestarts
[17:39:22.477]                           grepl <- base::grepl
[17:39:22.477]                           restarts <- computeRestarts(cond)
[17:39:22.477]                           for (restart in restarts) {
[17:39:22.477]                             name <- restart$name
[17:39:22.477]                             if (is.null(name)) 
[17:39:22.477]                               next
[17:39:22.477]                             if (!grepl(pattern, name)) 
[17:39:22.477]                               next
[17:39:22.477]                             invokeRestart(restart)
[17:39:22.477]                             muffled <- TRUE
[17:39:22.477]                             break
[17:39:22.477]                           }
[17:39:22.477]                         }
[17:39:22.477]                       }
[17:39:22.477]                       invisible(muffled)
[17:39:22.477]                     }
[17:39:22.477]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.477]                   }
[17:39:22.477]                 }
[17:39:22.477]                 else {
[17:39:22.477]                   if (TRUE) {
[17:39:22.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.477]                     {
[17:39:22.477]                       inherits <- base::inherits
[17:39:22.477]                       invokeRestart <- base::invokeRestart
[17:39:22.477]                       is.null <- base::is.null
[17:39:22.477]                       muffled <- FALSE
[17:39:22.477]                       if (inherits(cond, "message")) {
[17:39:22.477]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.477]                         if (muffled) 
[17:39:22.477]                           invokeRestart("muffleMessage")
[17:39:22.477]                       }
[17:39:22.477]                       else if (inherits(cond, "warning")) {
[17:39:22.477]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.477]                         if (muffled) 
[17:39:22.477]                           invokeRestart("muffleWarning")
[17:39:22.477]                       }
[17:39:22.477]                       else if (inherits(cond, "condition")) {
[17:39:22.477]                         if (!is.null(pattern)) {
[17:39:22.477]                           computeRestarts <- base::computeRestarts
[17:39:22.477]                           grepl <- base::grepl
[17:39:22.477]                           restarts <- computeRestarts(cond)
[17:39:22.477]                           for (restart in restarts) {
[17:39:22.477]                             name <- restart$name
[17:39:22.477]                             if (is.null(name)) 
[17:39:22.477]                               next
[17:39:22.477]                             if (!grepl(pattern, name)) 
[17:39:22.477]                               next
[17:39:22.477]                             invokeRestart(restart)
[17:39:22.477]                             muffled <- TRUE
[17:39:22.477]                             break
[17:39:22.477]                           }
[17:39:22.477]                         }
[17:39:22.477]                       }
[17:39:22.477]                       invisible(muffled)
[17:39:22.477]                     }
[17:39:22.477]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.477]                   }
[17:39:22.477]                 }
[17:39:22.477]             }
[17:39:22.477]         }))
[17:39:22.477]     }, error = function(ex) {
[17:39:22.477]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:22.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.477]                 ...future.rng), started = ...future.startTime, 
[17:39:22.477]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:22.477]             version = "1.8"), class = "FutureResult")
[17:39:22.477]     }, finally = {
[17:39:22.477]         if (!identical(...future.workdir, getwd())) 
[17:39:22.477]             setwd(...future.workdir)
[17:39:22.477]         {
[17:39:22.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:22.477]                 ...future.oldOptions$nwarnings <- NULL
[17:39:22.477]             }
[17:39:22.477]             base::options(...future.oldOptions)
[17:39:22.477]             if (.Platform$OS.type == "windows") {
[17:39:22.477]                 old_names <- names(...future.oldEnvVars)
[17:39:22.477]                 envs <- base::Sys.getenv()
[17:39:22.477]                 names <- names(envs)
[17:39:22.477]                 common <- intersect(names, old_names)
[17:39:22.477]                 added <- setdiff(names, old_names)
[17:39:22.477]                 removed <- setdiff(old_names, names)
[17:39:22.477]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:22.477]                   envs[common]]
[17:39:22.477]                 NAMES <- toupper(changed)
[17:39:22.477]                 args <- list()
[17:39:22.477]                 for (kk in seq_along(NAMES)) {
[17:39:22.477]                   name <- changed[[kk]]
[17:39:22.477]                   NAME <- NAMES[[kk]]
[17:39:22.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.477]                     next
[17:39:22.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.477]                 }
[17:39:22.477]                 NAMES <- toupper(added)
[17:39:22.477]                 for (kk in seq_along(NAMES)) {
[17:39:22.477]                   name <- added[[kk]]
[17:39:22.477]                   NAME <- NAMES[[kk]]
[17:39:22.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.477]                     next
[17:39:22.477]                   args[[name]] <- ""
[17:39:22.477]                 }
[17:39:22.477]                 NAMES <- toupper(removed)
[17:39:22.477]                 for (kk in seq_along(NAMES)) {
[17:39:22.477]                   name <- removed[[kk]]
[17:39:22.477]                   NAME <- NAMES[[kk]]
[17:39:22.477]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.477]                     next
[17:39:22.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.477]                 }
[17:39:22.477]                 if (length(args) > 0) 
[17:39:22.477]                   base::do.call(base::Sys.setenv, args = args)
[17:39:22.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:22.477]             }
[17:39:22.477]             else {
[17:39:22.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:22.477]             }
[17:39:22.477]             {
[17:39:22.477]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:22.477]                   0L) {
[17:39:22.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:22.477]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:22.477]                   base::options(opts)
[17:39:22.477]                 }
[17:39:22.477]                 {
[17:39:22.477]                   {
[17:39:22.477]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:22.477]                     NULL
[17:39:22.477]                   }
[17:39:22.477]                   options(future.plan = NULL)
[17:39:22.477]                   if (is.na(NA_character_)) 
[17:39:22.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:22.477]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:22.477]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:22.477]                     envir = parent.frame()) 
[17:39:22.477]                   {
[17:39:22.477]                     if (is.function(workers)) 
[17:39:22.477]                       workers <- workers()
[17:39:22.477]                     workers <- structure(as.integer(workers), 
[17:39:22.477]                       class = class(workers))
[17:39:22.477]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:22.477]                       workers >= 1)
[17:39:22.477]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:22.477]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:22.477]                     }
[17:39:22.477]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:22.477]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:22.477]                       envir = envir)
[17:39:22.477]                     if (!future$lazy) 
[17:39:22.477]                       future <- run(future)
[17:39:22.477]                     invisible(future)
[17:39:22.477]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:22.477]                 }
[17:39:22.477]             }
[17:39:22.477]         }
[17:39:22.477]     })
[17:39:22.477]     if (TRUE) {
[17:39:22.477]         base::sink(type = "output", split = FALSE)
[17:39:22.477]         if (TRUE) {
[17:39:22.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:22.477]         }
[17:39:22.477]         else {
[17:39:22.477]             ...future.result["stdout"] <- base::list(NULL)
[17:39:22.477]         }
[17:39:22.477]         base::close(...future.stdout)
[17:39:22.477]         ...future.stdout <- NULL
[17:39:22.477]     }
[17:39:22.477]     ...future.result$conditions <- ...future.conditions
[17:39:22.477]     ...future.result$finished <- base::Sys.time()
[17:39:22.477]     ...future.result
[17:39:22.477] }
[17:39:22.480] Exporting 5 global objects (346.00 KiB) to cluster node #1 ...
[17:39:22.480] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:22.481] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:22.481] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[17:39:22.523] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[17:39:22.524] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:39:22.524] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:39:22.524] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:22.525] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:22.525] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:22.525] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:22.525] Exporting 5 global objects (346.00 KiB) to cluster node #1 ... DONE
[17:39:22.526] MultisessionFuture started
[17:39:22.526] - Launch lazy future ... done
[17:39:22.526] run() for ‘MultisessionFuture’ ... done
[17:39:22.526] Created future:
[17:39:22.526] MultisessionFuture:
[17:39:22.526] Label: ‘future_apply-1’
[17:39:22.526] Expression:
[17:39:22.526] {
[17:39:22.526]     do.call(function(...) {
[17:39:22.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:22.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.526]             on.exit(options(oopts), add = TRUE)
[17:39:22.526]         }
[17:39:22.526]         {
[17:39:22.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:22.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.526]                 ...future.FUN(...future.X_jj, ...)
[17:39:22.526]             })
[17:39:22.526]         }
[17:39:22.526]     }, args = future.call.arguments)
[17:39:22.526] }
[17:39:22.526] Lazy evaluation: FALSE
[17:39:22.526] Asynchronous evaluation: TRUE
[17:39:22.526] Local evaluation: TRUE
[17:39:22.526] Environment: R_GlobalEnv
[17:39:22.526] Capture standard output: TRUE
[17:39:22.526] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:22.526] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:22.526] Packages: <none>
[17:39:22.526] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:22.526] Resolved: FALSE
[17:39:22.526] Value: <not collected>
[17:39:22.526] Conditions captured: <none>
[17:39:22.526] Early signaling: FALSE
[17:39:22.526] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:22.526] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:22.538] Chunk #1 of 2 ... DONE
[17:39:22.539] Chunk #2 of 2 ...
[17:39:22.539]  - seeds: <none>
[17:39:22.539] getGlobalsAndPackages() ...
[17:39:22.539] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:22.539] Resolving globals: FALSE
[17:39:22.539] Tweak future expression to call with '...' arguments ...
[17:39:22.539] {
[17:39:22.539]     do.call(function(...) {
[17:39:22.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:22.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.539]             on.exit(options(oopts), add = TRUE)
[17:39:22.539]         }
[17:39:22.539]         {
[17:39:22.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:22.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.539]                 ...future.FUN(...future.X_jj, ...)
[17:39:22.539]             })
[17:39:22.539]         }
[17:39:22.539]     }, args = future.call.arguments)
[17:39:22.539] }
[17:39:22.540] Tweak future expression to call with '...' arguments ... DONE
[17:39:22.540] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:22.540] 
[17:39:22.540] getGlobalsAndPackages() ... DONE
[17:39:22.541] run() for ‘Future’ ...
[17:39:22.541] - state: ‘created’
[17:39:22.541] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:22.556] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:22.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:22.557]   - Field: ‘node’
[17:39:22.557]   - Field: ‘label’
[17:39:22.557]   - Field: ‘local’
[17:39:22.557]   - Field: ‘owner’
[17:39:22.557]   - Field: ‘envir’
[17:39:22.557]   - Field: ‘workers’
[17:39:22.557]   - Field: ‘packages’
[17:39:22.557]   - Field: ‘gc’
[17:39:22.557]   - Field: ‘conditions’
[17:39:22.558]   - Field: ‘persistent’
[17:39:22.558]   - Field: ‘expr’
[17:39:22.560]   - Field: ‘uuid’
[17:39:22.560]   - Field: ‘seed’
[17:39:22.560]   - Field: ‘version’
[17:39:22.560]   - Field: ‘result’
[17:39:22.560]   - Field: ‘asynchronous’
[17:39:22.560]   - Field: ‘calls’
[17:39:22.560]   - Field: ‘globals’
[17:39:22.560]   - Field: ‘stdout’
[17:39:22.560]   - Field: ‘earlySignal’
[17:39:22.560]   - Field: ‘lazy’
[17:39:22.561]   - Field: ‘state’
[17:39:22.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:22.561] - Launch lazy future ...
[17:39:22.561] Packages needed by the future expression (n = 0): <none>
[17:39:22.561] Packages needed by future strategies (n = 0): <none>
[17:39:22.562] {
[17:39:22.562]     {
[17:39:22.562]         {
[17:39:22.562]             ...future.startTime <- base::Sys.time()
[17:39:22.562]             {
[17:39:22.562]                 {
[17:39:22.562]                   {
[17:39:22.562]                     {
[17:39:22.562]                       base::local({
[17:39:22.562]                         has_future <- base::requireNamespace("future", 
[17:39:22.562]                           quietly = TRUE)
[17:39:22.562]                         if (has_future) {
[17:39:22.562]                           ns <- base::getNamespace("future")
[17:39:22.562]                           version <- ns[[".package"]][["version"]]
[17:39:22.562]                           if (is.null(version)) 
[17:39:22.562]                             version <- utils::packageVersion("future")
[17:39:22.562]                         }
[17:39:22.562]                         else {
[17:39:22.562]                           version <- NULL
[17:39:22.562]                         }
[17:39:22.562]                         if (!has_future || version < "1.8.0") {
[17:39:22.562]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:22.562]                             "", base::R.version$version.string), 
[17:39:22.562]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:22.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:22.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:22.562]                               "release", "version")], collapse = " "), 
[17:39:22.562]                             hostname = base::Sys.info()[["nodename"]])
[17:39:22.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:22.562]                             info)
[17:39:22.562]                           info <- base::paste(info, collapse = "; ")
[17:39:22.562]                           if (!has_future) {
[17:39:22.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:22.562]                               info)
[17:39:22.562]                           }
[17:39:22.562]                           else {
[17:39:22.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:22.562]                               info, version)
[17:39:22.562]                           }
[17:39:22.562]                           base::stop(msg)
[17:39:22.562]                         }
[17:39:22.562]                       })
[17:39:22.562]                     }
[17:39:22.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:22.562]                     base::options(mc.cores = 1L)
[17:39:22.562]                   }
[17:39:22.562]                   options(future.plan = NULL)
[17:39:22.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:22.562]                 }
[17:39:22.562]                 ...future.workdir <- getwd()
[17:39:22.562]             }
[17:39:22.562]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:22.562]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:22.562]         }
[17:39:22.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:22.562]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:22.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:22.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:22.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:22.562]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:22.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:22.562]             base::names(...future.oldOptions))
[17:39:22.562]     }
[17:39:22.562]     if (FALSE) {
[17:39:22.562]     }
[17:39:22.562]     else {
[17:39:22.562]         if (TRUE) {
[17:39:22.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:22.562]                 open = "w")
[17:39:22.562]         }
[17:39:22.562]         else {
[17:39:22.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:22.562]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:22.562]         }
[17:39:22.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:22.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:22.562]             base::sink(type = "output", split = FALSE)
[17:39:22.562]             base::close(...future.stdout)
[17:39:22.562]         }, add = TRUE)
[17:39:22.562]     }
[17:39:22.562]     ...future.frame <- base::sys.nframe()
[17:39:22.562]     ...future.conditions <- base::list()
[17:39:22.562]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:22.562]     if (FALSE) {
[17:39:22.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:22.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:22.562]     }
[17:39:22.562]     ...future.result <- base::tryCatch({
[17:39:22.562]         base::withCallingHandlers({
[17:39:22.562]             ...future.value <- base::withVisible(base::local({
[17:39:22.562]                 ...future.makeSendCondition <- local({
[17:39:22.562]                   sendCondition <- NULL
[17:39:22.562]                   function(frame = 1L) {
[17:39:22.562]                     if (is.function(sendCondition)) 
[17:39:22.562]                       return(sendCondition)
[17:39:22.562]                     ns <- getNamespace("parallel")
[17:39:22.562]                     if (exists("sendData", mode = "function", 
[17:39:22.562]                       envir = ns)) {
[17:39:22.562]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:22.562]                         envir = ns)
[17:39:22.562]                       envir <- sys.frame(frame)
[17:39:22.562]                       master <- NULL
[17:39:22.562]                       while (!identical(envir, .GlobalEnv) && 
[17:39:22.562]                         !identical(envir, emptyenv())) {
[17:39:22.562]                         if (exists("master", mode = "list", envir = envir, 
[17:39:22.562]                           inherits = FALSE)) {
[17:39:22.562]                           master <- get("master", mode = "list", 
[17:39:22.562]                             envir = envir, inherits = FALSE)
[17:39:22.562]                           if (inherits(master, c("SOCKnode", 
[17:39:22.562]                             "SOCK0node"))) {
[17:39:22.562]                             sendCondition <<- function(cond) {
[17:39:22.562]                               data <- list(type = "VALUE", value = cond, 
[17:39:22.562]                                 success = TRUE)
[17:39:22.562]                               parallel_sendData(master, data)
[17:39:22.562]                             }
[17:39:22.562]                             return(sendCondition)
[17:39:22.562]                           }
[17:39:22.562]                         }
[17:39:22.562]                         frame <- frame + 1L
[17:39:22.562]                         envir <- sys.frame(frame)
[17:39:22.562]                       }
[17:39:22.562]                     }
[17:39:22.562]                     sendCondition <<- function(cond) NULL
[17:39:22.562]                   }
[17:39:22.562]                 })
[17:39:22.562]                 withCallingHandlers({
[17:39:22.562]                   {
[17:39:22.562]                     do.call(function(...) {
[17:39:22.562]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.562]                       if (!identical(...future.globals.maxSize.org, 
[17:39:22.562]                         ...future.globals.maxSize)) {
[17:39:22.562]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.562]                         on.exit(options(oopts), add = TRUE)
[17:39:22.562]                       }
[17:39:22.562]                       {
[17:39:22.562]                         lapply(seq_along(...future.elements_ii), 
[17:39:22.562]                           FUN = function(jj) {
[17:39:22.562]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.562]                             ...future.FUN(...future.X_jj, ...)
[17:39:22.562]                           })
[17:39:22.562]                       }
[17:39:22.562]                     }, args = future.call.arguments)
[17:39:22.562]                   }
[17:39:22.562]                 }, immediateCondition = function(cond) {
[17:39:22.562]                   sendCondition <- ...future.makeSendCondition()
[17:39:22.562]                   sendCondition(cond)
[17:39:22.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.562]                   {
[17:39:22.562]                     inherits <- base::inherits
[17:39:22.562]                     invokeRestart <- base::invokeRestart
[17:39:22.562]                     is.null <- base::is.null
[17:39:22.562]                     muffled <- FALSE
[17:39:22.562]                     if (inherits(cond, "message")) {
[17:39:22.562]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:22.562]                       if (muffled) 
[17:39:22.562]                         invokeRestart("muffleMessage")
[17:39:22.562]                     }
[17:39:22.562]                     else if (inherits(cond, "warning")) {
[17:39:22.562]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:22.562]                       if (muffled) 
[17:39:22.562]                         invokeRestart("muffleWarning")
[17:39:22.562]                     }
[17:39:22.562]                     else if (inherits(cond, "condition")) {
[17:39:22.562]                       if (!is.null(pattern)) {
[17:39:22.562]                         computeRestarts <- base::computeRestarts
[17:39:22.562]                         grepl <- base::grepl
[17:39:22.562]                         restarts <- computeRestarts(cond)
[17:39:22.562]                         for (restart in restarts) {
[17:39:22.562]                           name <- restart$name
[17:39:22.562]                           if (is.null(name)) 
[17:39:22.562]                             next
[17:39:22.562]                           if (!grepl(pattern, name)) 
[17:39:22.562]                             next
[17:39:22.562]                           invokeRestart(restart)
[17:39:22.562]                           muffled <- TRUE
[17:39:22.562]                           break
[17:39:22.562]                         }
[17:39:22.562]                       }
[17:39:22.562]                     }
[17:39:22.562]                     invisible(muffled)
[17:39:22.562]                   }
[17:39:22.562]                   muffleCondition(cond)
[17:39:22.562]                 })
[17:39:22.562]             }))
[17:39:22.562]             future::FutureResult(value = ...future.value$value, 
[17:39:22.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.562]                   ...future.rng), globalenv = if (FALSE) 
[17:39:22.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:22.562]                     ...future.globalenv.names))
[17:39:22.562]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:22.562]         }, condition = base::local({
[17:39:22.562]             c <- base::c
[17:39:22.562]             inherits <- base::inherits
[17:39:22.562]             invokeRestart <- base::invokeRestart
[17:39:22.562]             length <- base::length
[17:39:22.562]             list <- base::list
[17:39:22.562]             seq.int <- base::seq.int
[17:39:22.562]             signalCondition <- base::signalCondition
[17:39:22.562]             sys.calls <- base::sys.calls
[17:39:22.562]             `[[` <- base::`[[`
[17:39:22.562]             `+` <- base::`+`
[17:39:22.562]             `<<-` <- base::`<<-`
[17:39:22.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:22.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:22.562]                   3L)]
[17:39:22.562]             }
[17:39:22.562]             function(cond) {
[17:39:22.562]                 is_error <- inherits(cond, "error")
[17:39:22.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:22.562]                   NULL)
[17:39:22.562]                 if (is_error) {
[17:39:22.562]                   sessionInformation <- function() {
[17:39:22.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:22.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:22.562]                       search = base::search(), system = base::Sys.info())
[17:39:22.562]                   }
[17:39:22.562]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:22.562]                     cond$call), session = sessionInformation(), 
[17:39:22.562]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:22.562]                   signalCondition(cond)
[17:39:22.562]                 }
[17:39:22.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:22.562]                 "immediateCondition"))) {
[17:39:22.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:22.562]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:22.562]                   if (TRUE && !signal) {
[17:39:22.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.562]                     {
[17:39:22.562]                       inherits <- base::inherits
[17:39:22.562]                       invokeRestart <- base::invokeRestart
[17:39:22.562]                       is.null <- base::is.null
[17:39:22.562]                       muffled <- FALSE
[17:39:22.562]                       if (inherits(cond, "message")) {
[17:39:22.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.562]                         if (muffled) 
[17:39:22.562]                           invokeRestart("muffleMessage")
[17:39:22.562]                       }
[17:39:22.562]                       else if (inherits(cond, "warning")) {
[17:39:22.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.562]                         if (muffled) 
[17:39:22.562]                           invokeRestart("muffleWarning")
[17:39:22.562]                       }
[17:39:22.562]                       else if (inherits(cond, "condition")) {
[17:39:22.562]                         if (!is.null(pattern)) {
[17:39:22.562]                           computeRestarts <- base::computeRestarts
[17:39:22.562]                           grepl <- base::grepl
[17:39:22.562]                           restarts <- computeRestarts(cond)
[17:39:22.562]                           for (restart in restarts) {
[17:39:22.562]                             name <- restart$name
[17:39:22.562]                             if (is.null(name)) 
[17:39:22.562]                               next
[17:39:22.562]                             if (!grepl(pattern, name)) 
[17:39:22.562]                               next
[17:39:22.562]                             invokeRestart(restart)
[17:39:22.562]                             muffled <- TRUE
[17:39:22.562]                             break
[17:39:22.562]                           }
[17:39:22.562]                         }
[17:39:22.562]                       }
[17:39:22.562]                       invisible(muffled)
[17:39:22.562]                     }
[17:39:22.562]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.562]                   }
[17:39:22.562]                 }
[17:39:22.562]                 else {
[17:39:22.562]                   if (TRUE) {
[17:39:22.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.562]                     {
[17:39:22.562]                       inherits <- base::inherits
[17:39:22.562]                       invokeRestart <- base::invokeRestart
[17:39:22.562]                       is.null <- base::is.null
[17:39:22.562]                       muffled <- FALSE
[17:39:22.562]                       if (inherits(cond, "message")) {
[17:39:22.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.562]                         if (muffled) 
[17:39:22.562]                           invokeRestart("muffleMessage")
[17:39:22.562]                       }
[17:39:22.562]                       else if (inherits(cond, "warning")) {
[17:39:22.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.562]                         if (muffled) 
[17:39:22.562]                           invokeRestart("muffleWarning")
[17:39:22.562]                       }
[17:39:22.562]                       else if (inherits(cond, "condition")) {
[17:39:22.562]                         if (!is.null(pattern)) {
[17:39:22.562]                           computeRestarts <- base::computeRestarts
[17:39:22.562]                           grepl <- base::grepl
[17:39:22.562]                           restarts <- computeRestarts(cond)
[17:39:22.562]                           for (restart in restarts) {
[17:39:22.562]                             name <- restart$name
[17:39:22.562]                             if (is.null(name)) 
[17:39:22.562]                               next
[17:39:22.562]                             if (!grepl(pattern, name)) 
[17:39:22.562]                               next
[17:39:22.562]                             invokeRestart(restart)
[17:39:22.562]                             muffled <- TRUE
[17:39:22.562]                             break
[17:39:22.562]                           }
[17:39:22.562]                         }
[17:39:22.562]                       }
[17:39:22.562]                       invisible(muffled)
[17:39:22.562]                     }
[17:39:22.562]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.562]                   }
[17:39:22.562]                 }
[17:39:22.562]             }
[17:39:22.562]         }))
[17:39:22.562]     }, error = function(ex) {
[17:39:22.562]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:22.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.562]                 ...future.rng), started = ...future.startTime, 
[17:39:22.562]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:22.562]             version = "1.8"), class = "FutureResult")
[17:39:22.562]     }, finally = {
[17:39:22.562]         if (!identical(...future.workdir, getwd())) 
[17:39:22.562]             setwd(...future.workdir)
[17:39:22.562]         {
[17:39:22.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:22.562]                 ...future.oldOptions$nwarnings <- NULL
[17:39:22.562]             }
[17:39:22.562]             base::options(...future.oldOptions)
[17:39:22.562]             if (.Platform$OS.type == "windows") {
[17:39:22.562]                 old_names <- names(...future.oldEnvVars)
[17:39:22.562]                 envs <- base::Sys.getenv()
[17:39:22.562]                 names <- names(envs)
[17:39:22.562]                 common <- intersect(names, old_names)
[17:39:22.562]                 added <- setdiff(names, old_names)
[17:39:22.562]                 removed <- setdiff(old_names, names)
[17:39:22.562]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:22.562]                   envs[common]]
[17:39:22.562]                 NAMES <- toupper(changed)
[17:39:22.562]                 args <- list()
[17:39:22.562]                 for (kk in seq_along(NAMES)) {
[17:39:22.562]                   name <- changed[[kk]]
[17:39:22.562]                   NAME <- NAMES[[kk]]
[17:39:22.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.562]                     next
[17:39:22.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.562]                 }
[17:39:22.562]                 NAMES <- toupper(added)
[17:39:22.562]                 for (kk in seq_along(NAMES)) {
[17:39:22.562]                   name <- added[[kk]]
[17:39:22.562]                   NAME <- NAMES[[kk]]
[17:39:22.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.562]                     next
[17:39:22.562]                   args[[name]] <- ""
[17:39:22.562]                 }
[17:39:22.562]                 NAMES <- toupper(removed)
[17:39:22.562]                 for (kk in seq_along(NAMES)) {
[17:39:22.562]                   name <- removed[[kk]]
[17:39:22.562]                   NAME <- NAMES[[kk]]
[17:39:22.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.562]                     next
[17:39:22.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.562]                 }
[17:39:22.562]                 if (length(args) > 0) 
[17:39:22.562]                   base::do.call(base::Sys.setenv, args = args)
[17:39:22.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:22.562]             }
[17:39:22.562]             else {
[17:39:22.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:22.562]             }
[17:39:22.562]             {
[17:39:22.562]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:22.562]                   0L) {
[17:39:22.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:22.562]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:22.562]                   base::options(opts)
[17:39:22.562]                 }
[17:39:22.562]                 {
[17:39:22.562]                   {
[17:39:22.562]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:22.562]                     NULL
[17:39:22.562]                   }
[17:39:22.562]                   options(future.plan = NULL)
[17:39:22.562]                   if (is.na(NA_character_)) 
[17:39:22.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:22.562]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:22.562]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:22.562]                     envir = parent.frame()) 
[17:39:22.562]                   {
[17:39:22.562]                     if (is.function(workers)) 
[17:39:22.562]                       workers <- workers()
[17:39:22.562]                     workers <- structure(as.integer(workers), 
[17:39:22.562]                       class = class(workers))
[17:39:22.562]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:22.562]                       workers >= 1)
[17:39:22.562]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:22.562]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:22.562]                     }
[17:39:22.562]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:22.562]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:22.562]                       envir = envir)
[17:39:22.562]                     if (!future$lazy) 
[17:39:22.562]                       future <- run(future)
[17:39:22.562]                     invisible(future)
[17:39:22.562]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:22.562]                 }
[17:39:22.562]             }
[17:39:22.562]         }
[17:39:22.562]     })
[17:39:22.562]     if (TRUE) {
[17:39:22.562]         base::sink(type = "output", split = FALSE)
[17:39:22.562]         if (TRUE) {
[17:39:22.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:22.562]         }
[17:39:22.562]         else {
[17:39:22.562]             ...future.result["stdout"] <- base::list(NULL)
[17:39:22.562]         }
[17:39:22.562]         base::close(...future.stdout)
[17:39:22.562]         ...future.stdout <- NULL
[17:39:22.562]     }
[17:39:22.562]     ...future.result$conditions <- ...future.conditions
[17:39:22.562]     ...future.result$finished <- base::Sys.time()
[17:39:22.562]     ...future.result
[17:39:22.562] }
[17:39:22.634] Exporting 5 global objects (346.00 KiB) to cluster node #2 ...
[17:39:22.634] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:22.635] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:22.635] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[17:39:22.679] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[17:39:22.680] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:39:22.680] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:39:22.680] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:22.681] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:22.681] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:22.681] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:22.681] Exporting 5 global objects (346.00 KiB) to cluster node #2 ... DONE
[17:39:22.682] MultisessionFuture started
[17:39:22.682] - Launch lazy future ... done
[17:39:22.682] run() for ‘MultisessionFuture’ ... done
[17:39:22.683] Created future:
[17:39:22.683] MultisessionFuture:
[17:39:22.683] Label: ‘future_apply-2’
[17:39:22.683] Expression:
[17:39:22.683] {
[17:39:22.683]     do.call(function(...) {
[17:39:22.683]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.683]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:22.683]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.683]             on.exit(options(oopts), add = TRUE)
[17:39:22.683]         }
[17:39:22.683]         {
[17:39:22.683]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:22.683]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.683]                 ...future.FUN(...future.X_jj, ...)
[17:39:22.683]             })
[17:39:22.683]         }
[17:39:22.683]     }, args = future.call.arguments)
[17:39:22.683] }
[17:39:22.683] Lazy evaluation: FALSE
[17:39:22.683] Asynchronous evaluation: TRUE
[17:39:22.683] Local evaluation: TRUE
[17:39:22.683] Environment: R_GlobalEnv
[17:39:22.683] Capture standard output: TRUE
[17:39:22.683] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:22.683] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:22.683] Packages: <none>
[17:39:22.683] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:22.683] Resolved: FALSE
[17:39:22.683] Value: <not collected>
[17:39:22.683] Conditions captured: <none>
[17:39:22.683] Early signaling: FALSE
[17:39:22.683] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:22.683] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:22.694] Chunk #2 of 2 ... DONE
[17:39:22.695] Launching 2 futures (chunks) ... DONE
[17:39:22.695] Resolving 2 futures (chunks) ...
[17:39:22.695] resolve() on list ...
[17:39:22.695]  recursive: 0
[17:39:22.695]  length: 2
[17:39:22.695] 
[17:39:22.696] receiveMessageFromWorker() for ClusterFuture ...
[17:39:22.696] - Validating connection of MultisessionFuture
[17:39:22.696] - received message: FutureResult
[17:39:22.696] - Received FutureResult
[17:39:22.696] - Erased future from FutureRegistry
[17:39:22.696] result() for ClusterFuture ...
[17:39:22.696] - result already collected: FutureResult
[17:39:22.696] result() for ClusterFuture ... done
[17:39:22.696] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:22.697] Future #1
[17:39:22.697] result() for ClusterFuture ...
[17:39:22.697] - result already collected: FutureResult
[17:39:22.697] result() for ClusterFuture ... done
[17:39:22.697] result() for ClusterFuture ...
[17:39:22.697] - result already collected: FutureResult
[17:39:22.697] result() for ClusterFuture ... done
[17:39:22.697] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:22.697] - nx: 2
[17:39:22.697] - relay: TRUE
[17:39:22.697] - stdout: TRUE
[17:39:22.698] - signal: TRUE
[17:39:22.698] - resignal: FALSE
[17:39:22.698] - force: TRUE
[17:39:22.698] - relayed: [n=2] FALSE, FALSE
[17:39:22.698] - queued futures: [n=2] FALSE, FALSE
[17:39:22.698]  - until=1
[17:39:22.698]  - relaying element #1
[17:39:22.698] result() for ClusterFuture ...
[17:39:22.698] - result already collected: FutureResult
[17:39:22.698] result() for ClusterFuture ... done
[17:39:22.698] result() for ClusterFuture ...
[17:39:22.698] - result already collected: FutureResult
[17:39:22.699] result() for ClusterFuture ... done
[17:39:22.699] result() for ClusterFuture ...
[17:39:22.699] - result already collected: FutureResult
[17:39:22.699] result() for ClusterFuture ... done
[17:39:22.699] result() for ClusterFuture ...
[17:39:22.699] - result already collected: FutureResult
[17:39:22.699] result() for ClusterFuture ... done
[17:39:22.699] - relayed: [n=2] TRUE, FALSE
[17:39:22.699] - queued futures: [n=2] TRUE, FALSE
[17:39:22.699] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:22.700]  length: 1 (resolved future 1)
[17:39:22.762] receiveMessageFromWorker() for ClusterFuture ...
[17:39:22.763] - Validating connection of MultisessionFuture
[17:39:22.763] - received message: FutureResult
[17:39:22.763] - Received FutureResult
[17:39:22.763] - Erased future from FutureRegistry
[17:39:22.763] result() for ClusterFuture ...
[17:39:22.763] - result already collected: FutureResult
[17:39:22.763] result() for ClusterFuture ... done
[17:39:22.763] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:22.764] Future #2
[17:39:22.764] result() for ClusterFuture ...
[17:39:22.764] - result already collected: FutureResult
[17:39:22.764] result() for ClusterFuture ... done
[17:39:22.764] result() for ClusterFuture ...
[17:39:22.764] - result already collected: FutureResult
[17:39:22.764] result() for ClusterFuture ... done
[17:39:22.764] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:22.764] - nx: 2
[17:39:22.764] - relay: TRUE
[17:39:22.764] - stdout: TRUE
[17:39:22.765] - signal: TRUE
[17:39:22.765] - resignal: FALSE
[17:39:22.765] - force: TRUE
[17:39:22.765] - relayed: [n=2] TRUE, FALSE
[17:39:22.765] - queued futures: [n=2] TRUE, FALSE
[17:39:22.765]  - until=2
[17:39:22.765]  - relaying element #2
[17:39:22.765] result() for ClusterFuture ...
[17:39:22.765] - result already collected: FutureResult
[17:39:22.765] result() for ClusterFuture ... done
[17:39:22.765] result() for ClusterFuture ...
[17:39:22.766] - result already collected: FutureResult
[17:39:22.766] result() for ClusterFuture ... done
[17:39:22.766] result() for ClusterFuture ...
[17:39:22.766] - result already collected: FutureResult
[17:39:22.766] result() for ClusterFuture ... done
[17:39:22.766] result() for ClusterFuture ...
[17:39:22.766] - result already collected: FutureResult
[17:39:22.766] result() for ClusterFuture ... done
[17:39:22.766] - relayed: [n=2] TRUE, TRUE
[17:39:22.766] - queued futures: [n=2] TRUE, TRUE
[17:39:22.766] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:22.767]  length: 0 (resolved future 2)
[17:39:22.767] Relaying remaining futures
[17:39:22.767] signalConditionsASAP(NULL, pos=0) ...
[17:39:22.767] - nx: 2
[17:39:22.767] - relay: TRUE
[17:39:22.767] - stdout: TRUE
[17:39:22.767] - signal: TRUE
[17:39:22.767] - resignal: FALSE
[17:39:22.767] - force: TRUE
[17:39:22.767] - relayed: [n=2] TRUE, TRUE
[17:39:22.767] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:22.768] - relayed: [n=2] TRUE, TRUE
[17:39:22.768] - queued futures: [n=2] TRUE, TRUE
[17:39:22.768] signalConditionsASAP(NULL, pos=0) ... done
[17:39:22.768] resolve() on list ... DONE
[17:39:22.768] result() for ClusterFuture ...
[17:39:22.768] - result already collected: FutureResult
[17:39:22.768] result() for ClusterFuture ... done
[17:39:22.768] result() for ClusterFuture ...
[17:39:22.768] - result already collected: FutureResult
[17:39:22.768] result() for ClusterFuture ... done
[17:39:22.768] result() for ClusterFuture ...
[17:39:22.769] - result already collected: FutureResult
[17:39:22.769] result() for ClusterFuture ... done
[17:39:22.769] result() for ClusterFuture ...
[17:39:22.769] - result already collected: FutureResult
[17:39:22.769] result() for ClusterFuture ... done
[17:39:22.769]  - Number of value chunks collected: 2
[17:39:22.769] Resolving 2 futures (chunks) ... DONE
[17:39:22.769] Reducing values from 2 chunks ...
[17:39:22.769]  - Number of values collected after concatenation: 2
[17:39:22.769]  - Number of values expected: 2
[17:39:22.769] Reducing values from 2 chunks ... DONE
[17:39:22.770] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:39:22.770] getGlobalsAndPackagesXApply() ...
[17:39:22.770]  - future.globals: TRUE
[17:39:22.770] getGlobalsAndPackages() ...
[17:39:22.770] Searching for globals...
[17:39:22.803] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:39:22.803] Searching for globals ... DONE
[17:39:22.803] Resolving globals: FALSE
[17:39:22.805] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:39:22.805] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:39:22.805] - globals: [1] ‘FUN’
[17:39:22.806] 
[17:39:22.806] getGlobalsAndPackages() ... DONE
[17:39:22.806]  - globals found/used: [n=1] ‘FUN’
[17:39:22.806]  - needed namespaces: [n=0] 
[17:39:22.806] Finding globals ... DONE
[17:39:22.806]  - use_args: TRUE
[17:39:22.806]  - Getting '...' globals ...
[17:39:22.806] resolve() on list ...
[17:39:22.807]  recursive: 0
[17:39:22.807]  length: 1
[17:39:22.807]  elements: ‘...’
[17:39:22.807]  length: 0 (resolved future 1)
[17:39:22.807] resolve() on list ... DONE
[17:39:22.807]    - '...' content: [n=0] 
[17:39:22.807] List of 1
[17:39:22.807]  $ ...: list()
[17:39:22.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:22.807]  - attr(*, "where")=List of 1
[17:39:22.807]   ..$ ...:<environment: 0x55c7958565b0> 
[17:39:22.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:22.807]  - attr(*, "resolved")= logi TRUE
[17:39:22.807]  - attr(*, "total_size")= num NA
[17:39:22.810]  - Getting '...' globals ... DONE
[17:39:22.810] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:22.810] List of 2
[17:39:22.810]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:22.810]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:22.810]  $ ...          : list()
[17:39:22.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:22.810]  - attr(*, "where")=List of 2
[17:39:22.810]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:22.810]   ..$ ...          :<environment: 0x55c7958565b0> 
[17:39:22.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:22.810]  - attr(*, "resolved")= logi FALSE
[17:39:22.810]  - attr(*, "total_size")= num 354224
[17:39:22.813] Packages to be attached in all futures: [n=0] 
[17:39:22.813] getGlobalsAndPackagesXApply() ... DONE
[17:39:22.817] future_lapply() ...
[17:39:22.853] Number of chunks: 2
[17:39:22.853] getGlobalsAndPackagesXApply() ...
[17:39:22.853]  - future.globals: <name-value list> with names ‘list()’
[17:39:22.853]  - use_args: TRUE
[17:39:22.854] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:22.854] List of 2
[17:39:22.854]  $ ...          : list()
[17:39:22.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:22.854]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:39:22.854]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:39:22.854]  - attr(*, "where")=List of 2
[17:39:22.854]   ..$ ...          :<environment: 0x55c7958565b0> 
[17:39:22.854]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:22.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:22.854]  - attr(*, "resolved")= logi FALSE
[17:39:22.854]  - attr(*, "total_size")= num NA
[17:39:22.857] Packages to be attached in all futures: [n=0] 
[17:39:22.858] getGlobalsAndPackagesXApply() ... DONE
[17:39:22.858] Number of futures (= number of chunks): 2
[17:39:22.858] Launching 2 futures (chunks) ...
[17:39:22.858] Chunk #1 of 2 ...
[17:39:22.858]  - seeds: <none>
[17:39:22.858] getGlobalsAndPackages() ...
[17:39:22.858] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:22.858] Resolving globals: FALSE
[17:39:22.859] Tweak future expression to call with '...' arguments ...
[17:39:22.859] {
[17:39:22.859]     do.call(function(...) {
[17:39:22.859]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.859]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:22.859]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.859]             on.exit(options(oopts), add = TRUE)
[17:39:22.859]         }
[17:39:22.859]         {
[17:39:22.859]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:22.859]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.859]                 ...future.FUN(...future.X_jj, ...)
[17:39:22.859]             })
[17:39:22.859]         }
[17:39:22.859]     }, args = future.call.arguments)
[17:39:22.859] }
[17:39:22.859] Tweak future expression to call with '...' arguments ... DONE
[17:39:22.859] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:22.859] 
[17:39:22.860] getGlobalsAndPackages() ... DONE
[17:39:22.860] run() for ‘Future’ ...
[17:39:22.860] - state: ‘created’
[17:39:22.860] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:22.875] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:22.875] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:22.875]   - Field: ‘node’
[17:39:22.875]   - Field: ‘label’
[17:39:22.875]   - Field: ‘local’
[17:39:22.875]   - Field: ‘owner’
[17:39:22.875]   - Field: ‘envir’
[17:39:22.875]   - Field: ‘workers’
[17:39:22.876]   - Field: ‘packages’
[17:39:22.876]   - Field: ‘gc’
[17:39:22.876]   - Field: ‘conditions’
[17:39:22.876]   - Field: ‘persistent’
[17:39:22.876]   - Field: ‘expr’
[17:39:22.876]   - Field: ‘uuid’
[17:39:22.876]   - Field: ‘seed’
[17:39:22.876]   - Field: ‘version’
[17:39:22.876]   - Field: ‘result’
[17:39:22.876]   - Field: ‘asynchronous’
[17:39:22.876]   - Field: ‘calls’
[17:39:22.877]   - Field: ‘globals’
[17:39:22.877]   - Field: ‘stdout’
[17:39:22.877]   - Field: ‘earlySignal’
[17:39:22.877]   - Field: ‘lazy’
[17:39:22.877]   - Field: ‘state’
[17:39:22.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:22.877] - Launch lazy future ...
[17:39:22.877] Packages needed by the future expression (n = 0): <none>
[17:39:22.878] Packages needed by future strategies (n = 0): <none>
[17:39:22.878] {
[17:39:22.878]     {
[17:39:22.878]         {
[17:39:22.878]             ...future.startTime <- base::Sys.time()
[17:39:22.878]             {
[17:39:22.878]                 {
[17:39:22.878]                   {
[17:39:22.878]                     {
[17:39:22.878]                       base::local({
[17:39:22.878]                         has_future <- base::requireNamespace("future", 
[17:39:22.878]                           quietly = TRUE)
[17:39:22.878]                         if (has_future) {
[17:39:22.878]                           ns <- base::getNamespace("future")
[17:39:22.878]                           version <- ns[[".package"]][["version"]]
[17:39:22.878]                           if (is.null(version)) 
[17:39:22.878]                             version <- utils::packageVersion("future")
[17:39:22.878]                         }
[17:39:22.878]                         else {
[17:39:22.878]                           version <- NULL
[17:39:22.878]                         }
[17:39:22.878]                         if (!has_future || version < "1.8.0") {
[17:39:22.878]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:22.878]                             "", base::R.version$version.string), 
[17:39:22.878]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:22.878]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:22.878]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:22.878]                               "release", "version")], collapse = " "), 
[17:39:22.878]                             hostname = base::Sys.info()[["nodename"]])
[17:39:22.878]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:22.878]                             info)
[17:39:22.878]                           info <- base::paste(info, collapse = "; ")
[17:39:22.878]                           if (!has_future) {
[17:39:22.878]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:22.878]                               info)
[17:39:22.878]                           }
[17:39:22.878]                           else {
[17:39:22.878]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:22.878]                               info, version)
[17:39:22.878]                           }
[17:39:22.878]                           base::stop(msg)
[17:39:22.878]                         }
[17:39:22.878]                       })
[17:39:22.878]                     }
[17:39:22.878]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:22.878]                     base::options(mc.cores = 1L)
[17:39:22.878]                   }
[17:39:22.878]                   options(future.plan = NULL)
[17:39:22.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:22.878]                 }
[17:39:22.878]                 ...future.workdir <- getwd()
[17:39:22.878]             }
[17:39:22.878]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:22.878]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:22.878]         }
[17:39:22.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:22.878]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:22.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:22.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:22.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:22.878]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:22.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:22.878]             base::names(...future.oldOptions))
[17:39:22.878]     }
[17:39:22.878]     if (FALSE) {
[17:39:22.878]     }
[17:39:22.878]     else {
[17:39:22.878]         if (TRUE) {
[17:39:22.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:22.878]                 open = "w")
[17:39:22.878]         }
[17:39:22.878]         else {
[17:39:22.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:22.878]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:22.878]         }
[17:39:22.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:22.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:22.878]             base::sink(type = "output", split = FALSE)
[17:39:22.878]             base::close(...future.stdout)
[17:39:22.878]         }, add = TRUE)
[17:39:22.878]     }
[17:39:22.878]     ...future.frame <- base::sys.nframe()
[17:39:22.878]     ...future.conditions <- base::list()
[17:39:22.878]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:22.878]     if (FALSE) {
[17:39:22.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:22.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:22.878]     }
[17:39:22.878]     ...future.result <- base::tryCatch({
[17:39:22.878]         base::withCallingHandlers({
[17:39:22.878]             ...future.value <- base::withVisible(base::local({
[17:39:22.878]                 ...future.makeSendCondition <- local({
[17:39:22.878]                   sendCondition <- NULL
[17:39:22.878]                   function(frame = 1L) {
[17:39:22.878]                     if (is.function(sendCondition)) 
[17:39:22.878]                       return(sendCondition)
[17:39:22.878]                     ns <- getNamespace("parallel")
[17:39:22.878]                     if (exists("sendData", mode = "function", 
[17:39:22.878]                       envir = ns)) {
[17:39:22.878]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:22.878]                         envir = ns)
[17:39:22.878]                       envir <- sys.frame(frame)
[17:39:22.878]                       master <- NULL
[17:39:22.878]                       while (!identical(envir, .GlobalEnv) && 
[17:39:22.878]                         !identical(envir, emptyenv())) {
[17:39:22.878]                         if (exists("master", mode = "list", envir = envir, 
[17:39:22.878]                           inherits = FALSE)) {
[17:39:22.878]                           master <- get("master", mode = "list", 
[17:39:22.878]                             envir = envir, inherits = FALSE)
[17:39:22.878]                           if (inherits(master, c("SOCKnode", 
[17:39:22.878]                             "SOCK0node"))) {
[17:39:22.878]                             sendCondition <<- function(cond) {
[17:39:22.878]                               data <- list(type = "VALUE", value = cond, 
[17:39:22.878]                                 success = TRUE)
[17:39:22.878]                               parallel_sendData(master, data)
[17:39:22.878]                             }
[17:39:22.878]                             return(sendCondition)
[17:39:22.878]                           }
[17:39:22.878]                         }
[17:39:22.878]                         frame <- frame + 1L
[17:39:22.878]                         envir <- sys.frame(frame)
[17:39:22.878]                       }
[17:39:22.878]                     }
[17:39:22.878]                     sendCondition <<- function(cond) NULL
[17:39:22.878]                   }
[17:39:22.878]                 })
[17:39:22.878]                 withCallingHandlers({
[17:39:22.878]                   {
[17:39:22.878]                     do.call(function(...) {
[17:39:22.878]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.878]                       if (!identical(...future.globals.maxSize.org, 
[17:39:22.878]                         ...future.globals.maxSize)) {
[17:39:22.878]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.878]                         on.exit(options(oopts), add = TRUE)
[17:39:22.878]                       }
[17:39:22.878]                       {
[17:39:22.878]                         lapply(seq_along(...future.elements_ii), 
[17:39:22.878]                           FUN = function(jj) {
[17:39:22.878]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.878]                             ...future.FUN(...future.X_jj, ...)
[17:39:22.878]                           })
[17:39:22.878]                       }
[17:39:22.878]                     }, args = future.call.arguments)
[17:39:22.878]                   }
[17:39:22.878]                 }, immediateCondition = function(cond) {
[17:39:22.878]                   sendCondition <- ...future.makeSendCondition()
[17:39:22.878]                   sendCondition(cond)
[17:39:22.878]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.878]                   {
[17:39:22.878]                     inherits <- base::inherits
[17:39:22.878]                     invokeRestart <- base::invokeRestart
[17:39:22.878]                     is.null <- base::is.null
[17:39:22.878]                     muffled <- FALSE
[17:39:22.878]                     if (inherits(cond, "message")) {
[17:39:22.878]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:22.878]                       if (muffled) 
[17:39:22.878]                         invokeRestart("muffleMessage")
[17:39:22.878]                     }
[17:39:22.878]                     else if (inherits(cond, "warning")) {
[17:39:22.878]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:22.878]                       if (muffled) 
[17:39:22.878]                         invokeRestart("muffleWarning")
[17:39:22.878]                     }
[17:39:22.878]                     else if (inherits(cond, "condition")) {
[17:39:22.878]                       if (!is.null(pattern)) {
[17:39:22.878]                         computeRestarts <- base::computeRestarts
[17:39:22.878]                         grepl <- base::grepl
[17:39:22.878]                         restarts <- computeRestarts(cond)
[17:39:22.878]                         for (restart in restarts) {
[17:39:22.878]                           name <- restart$name
[17:39:22.878]                           if (is.null(name)) 
[17:39:22.878]                             next
[17:39:22.878]                           if (!grepl(pattern, name)) 
[17:39:22.878]                             next
[17:39:22.878]                           invokeRestart(restart)
[17:39:22.878]                           muffled <- TRUE
[17:39:22.878]                           break
[17:39:22.878]                         }
[17:39:22.878]                       }
[17:39:22.878]                     }
[17:39:22.878]                     invisible(muffled)
[17:39:22.878]                   }
[17:39:22.878]                   muffleCondition(cond)
[17:39:22.878]                 })
[17:39:22.878]             }))
[17:39:22.878]             future::FutureResult(value = ...future.value$value, 
[17:39:22.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.878]                   ...future.rng), globalenv = if (FALSE) 
[17:39:22.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:22.878]                     ...future.globalenv.names))
[17:39:22.878]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:22.878]         }, condition = base::local({
[17:39:22.878]             c <- base::c
[17:39:22.878]             inherits <- base::inherits
[17:39:22.878]             invokeRestart <- base::invokeRestart
[17:39:22.878]             length <- base::length
[17:39:22.878]             list <- base::list
[17:39:22.878]             seq.int <- base::seq.int
[17:39:22.878]             signalCondition <- base::signalCondition
[17:39:22.878]             sys.calls <- base::sys.calls
[17:39:22.878]             `[[` <- base::`[[`
[17:39:22.878]             `+` <- base::`+`
[17:39:22.878]             `<<-` <- base::`<<-`
[17:39:22.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:22.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:22.878]                   3L)]
[17:39:22.878]             }
[17:39:22.878]             function(cond) {
[17:39:22.878]                 is_error <- inherits(cond, "error")
[17:39:22.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:22.878]                   NULL)
[17:39:22.878]                 if (is_error) {
[17:39:22.878]                   sessionInformation <- function() {
[17:39:22.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:22.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:22.878]                       search = base::search(), system = base::Sys.info())
[17:39:22.878]                   }
[17:39:22.878]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:22.878]                     cond$call), session = sessionInformation(), 
[17:39:22.878]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:22.878]                   signalCondition(cond)
[17:39:22.878]                 }
[17:39:22.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:22.878]                 "immediateCondition"))) {
[17:39:22.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:22.878]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:22.878]                   if (TRUE && !signal) {
[17:39:22.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.878]                     {
[17:39:22.878]                       inherits <- base::inherits
[17:39:22.878]                       invokeRestart <- base::invokeRestart
[17:39:22.878]                       is.null <- base::is.null
[17:39:22.878]                       muffled <- FALSE
[17:39:22.878]                       if (inherits(cond, "message")) {
[17:39:22.878]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.878]                         if (muffled) 
[17:39:22.878]                           invokeRestart("muffleMessage")
[17:39:22.878]                       }
[17:39:22.878]                       else if (inherits(cond, "warning")) {
[17:39:22.878]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.878]                         if (muffled) 
[17:39:22.878]                           invokeRestart("muffleWarning")
[17:39:22.878]                       }
[17:39:22.878]                       else if (inherits(cond, "condition")) {
[17:39:22.878]                         if (!is.null(pattern)) {
[17:39:22.878]                           computeRestarts <- base::computeRestarts
[17:39:22.878]                           grepl <- base::grepl
[17:39:22.878]                           restarts <- computeRestarts(cond)
[17:39:22.878]                           for (restart in restarts) {
[17:39:22.878]                             name <- restart$name
[17:39:22.878]                             if (is.null(name)) 
[17:39:22.878]                               next
[17:39:22.878]                             if (!grepl(pattern, name)) 
[17:39:22.878]                               next
[17:39:22.878]                             invokeRestart(restart)
[17:39:22.878]                             muffled <- TRUE
[17:39:22.878]                             break
[17:39:22.878]                           }
[17:39:22.878]                         }
[17:39:22.878]                       }
[17:39:22.878]                       invisible(muffled)
[17:39:22.878]                     }
[17:39:22.878]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.878]                   }
[17:39:22.878]                 }
[17:39:22.878]                 else {
[17:39:22.878]                   if (TRUE) {
[17:39:22.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.878]                     {
[17:39:22.878]                       inherits <- base::inherits
[17:39:22.878]                       invokeRestart <- base::invokeRestart
[17:39:22.878]                       is.null <- base::is.null
[17:39:22.878]                       muffled <- FALSE
[17:39:22.878]                       if (inherits(cond, "message")) {
[17:39:22.878]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.878]                         if (muffled) 
[17:39:22.878]                           invokeRestart("muffleMessage")
[17:39:22.878]                       }
[17:39:22.878]                       else if (inherits(cond, "warning")) {
[17:39:22.878]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.878]                         if (muffled) 
[17:39:22.878]                           invokeRestart("muffleWarning")
[17:39:22.878]                       }
[17:39:22.878]                       else if (inherits(cond, "condition")) {
[17:39:22.878]                         if (!is.null(pattern)) {
[17:39:22.878]                           computeRestarts <- base::computeRestarts
[17:39:22.878]                           grepl <- base::grepl
[17:39:22.878]                           restarts <- computeRestarts(cond)
[17:39:22.878]                           for (restart in restarts) {
[17:39:22.878]                             name <- restart$name
[17:39:22.878]                             if (is.null(name)) 
[17:39:22.878]                               next
[17:39:22.878]                             if (!grepl(pattern, name)) 
[17:39:22.878]                               next
[17:39:22.878]                             invokeRestart(restart)
[17:39:22.878]                             muffled <- TRUE
[17:39:22.878]                             break
[17:39:22.878]                           }
[17:39:22.878]                         }
[17:39:22.878]                       }
[17:39:22.878]                       invisible(muffled)
[17:39:22.878]                     }
[17:39:22.878]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.878]                   }
[17:39:22.878]                 }
[17:39:22.878]             }
[17:39:22.878]         }))
[17:39:22.878]     }, error = function(ex) {
[17:39:22.878]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:22.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.878]                 ...future.rng), started = ...future.startTime, 
[17:39:22.878]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:22.878]             version = "1.8"), class = "FutureResult")
[17:39:22.878]     }, finally = {
[17:39:22.878]         if (!identical(...future.workdir, getwd())) 
[17:39:22.878]             setwd(...future.workdir)
[17:39:22.878]         {
[17:39:22.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:22.878]                 ...future.oldOptions$nwarnings <- NULL
[17:39:22.878]             }
[17:39:22.878]             base::options(...future.oldOptions)
[17:39:22.878]             if (.Platform$OS.type == "windows") {
[17:39:22.878]                 old_names <- names(...future.oldEnvVars)
[17:39:22.878]                 envs <- base::Sys.getenv()
[17:39:22.878]                 names <- names(envs)
[17:39:22.878]                 common <- intersect(names, old_names)
[17:39:22.878]                 added <- setdiff(names, old_names)
[17:39:22.878]                 removed <- setdiff(old_names, names)
[17:39:22.878]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:22.878]                   envs[common]]
[17:39:22.878]                 NAMES <- toupper(changed)
[17:39:22.878]                 args <- list()
[17:39:22.878]                 for (kk in seq_along(NAMES)) {
[17:39:22.878]                   name <- changed[[kk]]
[17:39:22.878]                   NAME <- NAMES[[kk]]
[17:39:22.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.878]                     next
[17:39:22.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.878]                 }
[17:39:22.878]                 NAMES <- toupper(added)
[17:39:22.878]                 for (kk in seq_along(NAMES)) {
[17:39:22.878]                   name <- added[[kk]]
[17:39:22.878]                   NAME <- NAMES[[kk]]
[17:39:22.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.878]                     next
[17:39:22.878]                   args[[name]] <- ""
[17:39:22.878]                 }
[17:39:22.878]                 NAMES <- toupper(removed)
[17:39:22.878]                 for (kk in seq_along(NAMES)) {
[17:39:22.878]                   name <- removed[[kk]]
[17:39:22.878]                   NAME <- NAMES[[kk]]
[17:39:22.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.878]                     next
[17:39:22.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.878]                 }
[17:39:22.878]                 if (length(args) > 0) 
[17:39:22.878]                   base::do.call(base::Sys.setenv, args = args)
[17:39:22.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:22.878]             }
[17:39:22.878]             else {
[17:39:22.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:22.878]             }
[17:39:22.878]             {
[17:39:22.878]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:22.878]                   0L) {
[17:39:22.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:22.878]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:22.878]                   base::options(opts)
[17:39:22.878]                 }
[17:39:22.878]                 {
[17:39:22.878]                   {
[17:39:22.878]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:22.878]                     NULL
[17:39:22.878]                   }
[17:39:22.878]                   options(future.plan = NULL)
[17:39:22.878]                   if (is.na(NA_character_)) 
[17:39:22.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:22.878]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:22.878]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:22.878]                     envir = parent.frame()) 
[17:39:22.878]                   {
[17:39:22.878]                     if (is.function(workers)) 
[17:39:22.878]                       workers <- workers()
[17:39:22.878]                     workers <- structure(as.integer(workers), 
[17:39:22.878]                       class = class(workers))
[17:39:22.878]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:22.878]                       workers >= 1)
[17:39:22.878]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:22.878]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:22.878]                     }
[17:39:22.878]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:22.878]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:22.878]                       envir = envir)
[17:39:22.878]                     if (!future$lazy) 
[17:39:22.878]                       future <- run(future)
[17:39:22.878]                     invisible(future)
[17:39:22.878]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:22.878]                 }
[17:39:22.878]             }
[17:39:22.878]         }
[17:39:22.878]     })
[17:39:22.878]     if (TRUE) {
[17:39:22.878]         base::sink(type = "output", split = FALSE)
[17:39:22.878]         if (TRUE) {
[17:39:22.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:22.878]         }
[17:39:22.878]         else {
[17:39:22.878]             ...future.result["stdout"] <- base::list(NULL)
[17:39:22.878]         }
[17:39:22.878]         base::close(...future.stdout)
[17:39:22.878]         ...future.stdout <- NULL
[17:39:22.878]     }
[17:39:22.878]     ...future.result$conditions <- ...future.conditions
[17:39:22.878]     ...future.result$finished <- base::Sys.time()
[17:39:22.878]     ...future.result
[17:39:22.878] }
[17:39:22.881] Exporting 5 global objects (346.00 KiB) to cluster node #1 ...
[17:39:22.881] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:22.882] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:22.882] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[17:39:22.923] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[17:39:22.923] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:39:22.924] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:39:22.924] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:22.924] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:22.925] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:22.925] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:22.925] Exporting 5 global objects (346.00 KiB) to cluster node #1 ... DONE
[17:39:22.926] MultisessionFuture started
[17:39:22.926] - Launch lazy future ... done
[17:39:22.926] run() for ‘MultisessionFuture’ ... done
[17:39:22.926] Created future:
[17:39:22.926] MultisessionFuture:
[17:39:22.926] Label: ‘future_apply-1’
[17:39:22.926] Expression:
[17:39:22.926] {
[17:39:22.926]     do.call(function(...) {
[17:39:22.926]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.926]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:22.926]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.926]             on.exit(options(oopts), add = TRUE)
[17:39:22.926]         }
[17:39:22.926]         {
[17:39:22.926]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:22.926]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.926]                 ...future.FUN(...future.X_jj, ...)
[17:39:22.926]             })
[17:39:22.926]         }
[17:39:22.926]     }, args = future.call.arguments)
[17:39:22.926] }
[17:39:22.926] Lazy evaluation: FALSE
[17:39:22.926] Asynchronous evaluation: TRUE
[17:39:22.926] Local evaluation: TRUE
[17:39:22.926] Environment: R_GlobalEnv
[17:39:22.926] Capture standard output: TRUE
[17:39:22.926] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:22.926] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:22.926] Packages: <none>
[17:39:22.926] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:22.926] Resolved: FALSE
[17:39:22.926] Value: <not collected>
[17:39:22.926] Conditions captured: <none>
[17:39:22.926] Early signaling: FALSE
[17:39:22.926] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:22.926] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:22.938] Chunk #1 of 2 ... DONE
[17:39:22.938] Chunk #2 of 2 ...
[17:39:22.938]  - seeds: <none>
[17:39:22.938] getGlobalsAndPackages() ...
[17:39:22.938] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:22.939] Resolving globals: FALSE
[17:39:22.939] Tweak future expression to call with '...' arguments ...
[17:39:22.939] {
[17:39:22.939]     do.call(function(...) {
[17:39:22.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:22.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.939]             on.exit(options(oopts), add = TRUE)
[17:39:22.939]         }
[17:39:22.939]         {
[17:39:22.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:22.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.939]                 ...future.FUN(...future.X_jj, ...)
[17:39:22.939]             })
[17:39:22.939]         }
[17:39:22.939]     }, args = future.call.arguments)
[17:39:22.939] }
[17:39:22.939] Tweak future expression to call with '...' arguments ... DONE
[17:39:22.939] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:22.940] 
[17:39:22.940] getGlobalsAndPackages() ... DONE
[17:39:22.940] run() for ‘Future’ ...
[17:39:22.940] - state: ‘created’
[17:39:22.940] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:22.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:22.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:22.955]   - Field: ‘node’
[17:39:22.956]   - Field: ‘label’
[17:39:22.956]   - Field: ‘local’
[17:39:22.956]   - Field: ‘owner’
[17:39:22.956]   - Field: ‘envir’
[17:39:22.956]   - Field: ‘workers’
[17:39:22.956]   - Field: ‘packages’
[17:39:22.956]   - Field: ‘gc’
[17:39:22.956]   - Field: ‘conditions’
[17:39:22.956]   - Field: ‘persistent’
[17:39:22.956]   - Field: ‘expr’
[17:39:22.956]   - Field: ‘uuid’
[17:39:22.957]   - Field: ‘seed’
[17:39:22.957]   - Field: ‘version’
[17:39:22.957]   - Field: ‘result’
[17:39:22.957]   - Field: ‘asynchronous’
[17:39:22.957]   - Field: ‘calls’
[17:39:22.957]   - Field: ‘globals’
[17:39:22.957]   - Field: ‘stdout’
[17:39:22.957]   - Field: ‘earlySignal’
[17:39:22.957]   - Field: ‘lazy’
[17:39:22.957]   - Field: ‘state’
[17:39:22.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:22.958] - Launch lazy future ...
[17:39:22.958] Packages needed by the future expression (n = 0): <none>
[17:39:22.958] Packages needed by future strategies (n = 0): <none>
[17:39:22.958] {
[17:39:22.958]     {
[17:39:22.958]         {
[17:39:22.958]             ...future.startTime <- base::Sys.time()
[17:39:22.958]             {
[17:39:22.958]                 {
[17:39:22.958]                   {
[17:39:22.958]                     {
[17:39:22.958]                       base::local({
[17:39:22.958]                         has_future <- base::requireNamespace("future", 
[17:39:22.958]                           quietly = TRUE)
[17:39:22.958]                         if (has_future) {
[17:39:22.958]                           ns <- base::getNamespace("future")
[17:39:22.958]                           version <- ns[[".package"]][["version"]]
[17:39:22.958]                           if (is.null(version)) 
[17:39:22.958]                             version <- utils::packageVersion("future")
[17:39:22.958]                         }
[17:39:22.958]                         else {
[17:39:22.958]                           version <- NULL
[17:39:22.958]                         }
[17:39:22.958]                         if (!has_future || version < "1.8.0") {
[17:39:22.958]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:22.958]                             "", base::R.version$version.string), 
[17:39:22.958]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:22.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:22.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:22.958]                               "release", "version")], collapse = " "), 
[17:39:22.958]                             hostname = base::Sys.info()[["nodename"]])
[17:39:22.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:22.958]                             info)
[17:39:22.958]                           info <- base::paste(info, collapse = "; ")
[17:39:22.958]                           if (!has_future) {
[17:39:22.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:22.958]                               info)
[17:39:22.958]                           }
[17:39:22.958]                           else {
[17:39:22.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:22.958]                               info, version)
[17:39:22.958]                           }
[17:39:22.958]                           base::stop(msg)
[17:39:22.958]                         }
[17:39:22.958]                       })
[17:39:22.958]                     }
[17:39:22.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:22.958]                     base::options(mc.cores = 1L)
[17:39:22.958]                   }
[17:39:22.958]                   options(future.plan = NULL)
[17:39:22.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:22.958]                 }
[17:39:22.958]                 ...future.workdir <- getwd()
[17:39:22.958]             }
[17:39:22.958]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:22.958]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:22.958]         }
[17:39:22.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:22.958]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:22.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:22.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:22.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:22.958]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:22.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:22.958]             base::names(...future.oldOptions))
[17:39:22.958]     }
[17:39:22.958]     if (FALSE) {
[17:39:22.958]     }
[17:39:22.958]     else {
[17:39:22.958]         if (TRUE) {
[17:39:22.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:22.958]                 open = "w")
[17:39:22.958]         }
[17:39:22.958]         else {
[17:39:22.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:22.958]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:22.958]         }
[17:39:22.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:22.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:22.958]             base::sink(type = "output", split = FALSE)
[17:39:22.958]             base::close(...future.stdout)
[17:39:22.958]         }, add = TRUE)
[17:39:22.958]     }
[17:39:22.958]     ...future.frame <- base::sys.nframe()
[17:39:22.958]     ...future.conditions <- base::list()
[17:39:22.958]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:22.958]     if (FALSE) {
[17:39:22.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:22.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:22.958]     }
[17:39:22.958]     ...future.result <- base::tryCatch({
[17:39:22.958]         base::withCallingHandlers({
[17:39:22.958]             ...future.value <- base::withVisible(base::local({
[17:39:22.958]                 ...future.makeSendCondition <- local({
[17:39:22.958]                   sendCondition <- NULL
[17:39:22.958]                   function(frame = 1L) {
[17:39:22.958]                     if (is.function(sendCondition)) 
[17:39:22.958]                       return(sendCondition)
[17:39:22.958]                     ns <- getNamespace("parallel")
[17:39:22.958]                     if (exists("sendData", mode = "function", 
[17:39:22.958]                       envir = ns)) {
[17:39:22.958]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:22.958]                         envir = ns)
[17:39:22.958]                       envir <- sys.frame(frame)
[17:39:22.958]                       master <- NULL
[17:39:22.958]                       while (!identical(envir, .GlobalEnv) && 
[17:39:22.958]                         !identical(envir, emptyenv())) {
[17:39:22.958]                         if (exists("master", mode = "list", envir = envir, 
[17:39:22.958]                           inherits = FALSE)) {
[17:39:22.958]                           master <- get("master", mode = "list", 
[17:39:22.958]                             envir = envir, inherits = FALSE)
[17:39:22.958]                           if (inherits(master, c("SOCKnode", 
[17:39:22.958]                             "SOCK0node"))) {
[17:39:22.958]                             sendCondition <<- function(cond) {
[17:39:22.958]                               data <- list(type = "VALUE", value = cond, 
[17:39:22.958]                                 success = TRUE)
[17:39:22.958]                               parallel_sendData(master, data)
[17:39:22.958]                             }
[17:39:22.958]                             return(sendCondition)
[17:39:22.958]                           }
[17:39:22.958]                         }
[17:39:22.958]                         frame <- frame + 1L
[17:39:22.958]                         envir <- sys.frame(frame)
[17:39:22.958]                       }
[17:39:22.958]                     }
[17:39:22.958]                     sendCondition <<- function(cond) NULL
[17:39:22.958]                   }
[17:39:22.958]                 })
[17:39:22.958]                 withCallingHandlers({
[17:39:22.958]                   {
[17:39:22.958]                     do.call(function(...) {
[17:39:22.958]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:22.958]                       if (!identical(...future.globals.maxSize.org, 
[17:39:22.958]                         ...future.globals.maxSize)) {
[17:39:22.958]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:22.958]                         on.exit(options(oopts), add = TRUE)
[17:39:22.958]                       }
[17:39:22.958]                       {
[17:39:22.958]                         lapply(seq_along(...future.elements_ii), 
[17:39:22.958]                           FUN = function(jj) {
[17:39:22.958]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:22.958]                             ...future.FUN(...future.X_jj, ...)
[17:39:22.958]                           })
[17:39:22.958]                       }
[17:39:22.958]                     }, args = future.call.arguments)
[17:39:22.958]                   }
[17:39:22.958]                 }, immediateCondition = function(cond) {
[17:39:22.958]                   sendCondition <- ...future.makeSendCondition()
[17:39:22.958]                   sendCondition(cond)
[17:39:22.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.958]                   {
[17:39:22.958]                     inherits <- base::inherits
[17:39:22.958]                     invokeRestart <- base::invokeRestart
[17:39:22.958]                     is.null <- base::is.null
[17:39:22.958]                     muffled <- FALSE
[17:39:22.958]                     if (inherits(cond, "message")) {
[17:39:22.958]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:22.958]                       if (muffled) 
[17:39:22.958]                         invokeRestart("muffleMessage")
[17:39:22.958]                     }
[17:39:22.958]                     else if (inherits(cond, "warning")) {
[17:39:22.958]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:22.958]                       if (muffled) 
[17:39:22.958]                         invokeRestart("muffleWarning")
[17:39:22.958]                     }
[17:39:22.958]                     else if (inherits(cond, "condition")) {
[17:39:22.958]                       if (!is.null(pattern)) {
[17:39:22.958]                         computeRestarts <- base::computeRestarts
[17:39:22.958]                         grepl <- base::grepl
[17:39:22.958]                         restarts <- computeRestarts(cond)
[17:39:22.958]                         for (restart in restarts) {
[17:39:22.958]                           name <- restart$name
[17:39:22.958]                           if (is.null(name)) 
[17:39:22.958]                             next
[17:39:22.958]                           if (!grepl(pattern, name)) 
[17:39:22.958]                             next
[17:39:22.958]                           invokeRestart(restart)
[17:39:22.958]                           muffled <- TRUE
[17:39:22.958]                           break
[17:39:22.958]                         }
[17:39:22.958]                       }
[17:39:22.958]                     }
[17:39:22.958]                     invisible(muffled)
[17:39:22.958]                   }
[17:39:22.958]                   muffleCondition(cond)
[17:39:22.958]                 })
[17:39:22.958]             }))
[17:39:22.958]             future::FutureResult(value = ...future.value$value, 
[17:39:22.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.958]                   ...future.rng), globalenv = if (FALSE) 
[17:39:22.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:22.958]                     ...future.globalenv.names))
[17:39:22.958]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:22.958]         }, condition = base::local({
[17:39:22.958]             c <- base::c
[17:39:22.958]             inherits <- base::inherits
[17:39:22.958]             invokeRestart <- base::invokeRestart
[17:39:22.958]             length <- base::length
[17:39:22.958]             list <- base::list
[17:39:22.958]             seq.int <- base::seq.int
[17:39:22.958]             signalCondition <- base::signalCondition
[17:39:22.958]             sys.calls <- base::sys.calls
[17:39:22.958]             `[[` <- base::`[[`
[17:39:22.958]             `+` <- base::`+`
[17:39:22.958]             `<<-` <- base::`<<-`
[17:39:22.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:22.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:22.958]                   3L)]
[17:39:22.958]             }
[17:39:22.958]             function(cond) {
[17:39:22.958]                 is_error <- inherits(cond, "error")
[17:39:22.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:22.958]                   NULL)
[17:39:22.958]                 if (is_error) {
[17:39:22.958]                   sessionInformation <- function() {
[17:39:22.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:22.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:22.958]                       search = base::search(), system = base::Sys.info())
[17:39:22.958]                   }
[17:39:22.958]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:22.958]                     cond$call), session = sessionInformation(), 
[17:39:22.958]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:22.958]                   signalCondition(cond)
[17:39:22.958]                 }
[17:39:22.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:22.958]                 "immediateCondition"))) {
[17:39:22.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:22.958]                   ...future.conditions[[length(...future.conditions) + 
[17:39:22.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:22.958]                   if (TRUE && !signal) {
[17:39:22.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.958]                     {
[17:39:22.958]                       inherits <- base::inherits
[17:39:22.958]                       invokeRestart <- base::invokeRestart
[17:39:22.958]                       is.null <- base::is.null
[17:39:22.958]                       muffled <- FALSE
[17:39:22.958]                       if (inherits(cond, "message")) {
[17:39:22.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.958]                         if (muffled) 
[17:39:22.958]                           invokeRestart("muffleMessage")
[17:39:22.958]                       }
[17:39:22.958]                       else if (inherits(cond, "warning")) {
[17:39:22.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.958]                         if (muffled) 
[17:39:22.958]                           invokeRestart("muffleWarning")
[17:39:22.958]                       }
[17:39:22.958]                       else if (inherits(cond, "condition")) {
[17:39:22.958]                         if (!is.null(pattern)) {
[17:39:22.958]                           computeRestarts <- base::computeRestarts
[17:39:22.958]                           grepl <- base::grepl
[17:39:22.958]                           restarts <- computeRestarts(cond)
[17:39:22.958]                           for (restart in restarts) {
[17:39:22.958]                             name <- restart$name
[17:39:22.958]                             if (is.null(name)) 
[17:39:22.958]                               next
[17:39:22.958]                             if (!grepl(pattern, name)) 
[17:39:22.958]                               next
[17:39:22.958]                             invokeRestart(restart)
[17:39:22.958]                             muffled <- TRUE
[17:39:22.958]                             break
[17:39:22.958]                           }
[17:39:22.958]                         }
[17:39:22.958]                       }
[17:39:22.958]                       invisible(muffled)
[17:39:22.958]                     }
[17:39:22.958]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.958]                   }
[17:39:22.958]                 }
[17:39:22.958]                 else {
[17:39:22.958]                   if (TRUE) {
[17:39:22.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:22.958]                     {
[17:39:22.958]                       inherits <- base::inherits
[17:39:22.958]                       invokeRestart <- base::invokeRestart
[17:39:22.958]                       is.null <- base::is.null
[17:39:22.958]                       muffled <- FALSE
[17:39:22.958]                       if (inherits(cond, "message")) {
[17:39:22.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:22.958]                         if (muffled) 
[17:39:22.958]                           invokeRestart("muffleMessage")
[17:39:22.958]                       }
[17:39:22.958]                       else if (inherits(cond, "warning")) {
[17:39:22.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:22.958]                         if (muffled) 
[17:39:22.958]                           invokeRestart("muffleWarning")
[17:39:22.958]                       }
[17:39:22.958]                       else if (inherits(cond, "condition")) {
[17:39:22.958]                         if (!is.null(pattern)) {
[17:39:22.958]                           computeRestarts <- base::computeRestarts
[17:39:22.958]                           grepl <- base::grepl
[17:39:22.958]                           restarts <- computeRestarts(cond)
[17:39:22.958]                           for (restart in restarts) {
[17:39:22.958]                             name <- restart$name
[17:39:22.958]                             if (is.null(name)) 
[17:39:22.958]                               next
[17:39:22.958]                             if (!grepl(pattern, name)) 
[17:39:22.958]                               next
[17:39:22.958]                             invokeRestart(restart)
[17:39:22.958]                             muffled <- TRUE
[17:39:22.958]                             break
[17:39:22.958]                           }
[17:39:22.958]                         }
[17:39:22.958]                       }
[17:39:22.958]                       invisible(muffled)
[17:39:22.958]                     }
[17:39:22.958]                     muffleCondition(cond, pattern = "^muffle")
[17:39:22.958]                   }
[17:39:22.958]                 }
[17:39:22.958]             }
[17:39:22.958]         }))
[17:39:22.958]     }, error = function(ex) {
[17:39:22.958]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:22.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:22.958]                 ...future.rng), started = ...future.startTime, 
[17:39:22.958]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:22.958]             version = "1.8"), class = "FutureResult")
[17:39:22.958]     }, finally = {
[17:39:22.958]         if (!identical(...future.workdir, getwd())) 
[17:39:22.958]             setwd(...future.workdir)
[17:39:22.958]         {
[17:39:22.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:22.958]                 ...future.oldOptions$nwarnings <- NULL
[17:39:22.958]             }
[17:39:22.958]             base::options(...future.oldOptions)
[17:39:22.958]             if (.Platform$OS.type == "windows") {
[17:39:22.958]                 old_names <- names(...future.oldEnvVars)
[17:39:22.958]                 envs <- base::Sys.getenv()
[17:39:22.958]                 names <- names(envs)
[17:39:22.958]                 common <- intersect(names, old_names)
[17:39:22.958]                 added <- setdiff(names, old_names)
[17:39:22.958]                 removed <- setdiff(old_names, names)
[17:39:22.958]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:22.958]                   envs[common]]
[17:39:22.958]                 NAMES <- toupper(changed)
[17:39:22.958]                 args <- list()
[17:39:22.958]                 for (kk in seq_along(NAMES)) {
[17:39:22.958]                   name <- changed[[kk]]
[17:39:22.958]                   NAME <- NAMES[[kk]]
[17:39:22.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.958]                     next
[17:39:22.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.958]                 }
[17:39:22.958]                 NAMES <- toupper(added)
[17:39:22.958]                 for (kk in seq_along(NAMES)) {
[17:39:22.958]                   name <- added[[kk]]
[17:39:22.958]                   NAME <- NAMES[[kk]]
[17:39:22.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.958]                     next
[17:39:22.958]                   args[[name]] <- ""
[17:39:22.958]                 }
[17:39:22.958]                 NAMES <- toupper(removed)
[17:39:22.958]                 for (kk in seq_along(NAMES)) {
[17:39:22.958]                   name <- removed[[kk]]
[17:39:22.958]                   NAME <- NAMES[[kk]]
[17:39:22.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:22.958]                     next
[17:39:22.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:22.958]                 }
[17:39:22.958]                 if (length(args) > 0) 
[17:39:22.958]                   base::do.call(base::Sys.setenv, args = args)
[17:39:22.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:22.958]             }
[17:39:22.958]             else {
[17:39:22.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:22.958]             }
[17:39:22.958]             {
[17:39:22.958]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:22.958]                   0L) {
[17:39:22.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:22.958]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:22.958]                   base::options(opts)
[17:39:22.958]                 }
[17:39:22.958]                 {
[17:39:22.958]                   {
[17:39:22.958]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:22.958]                     NULL
[17:39:22.958]                   }
[17:39:22.958]                   options(future.plan = NULL)
[17:39:22.958]                   if (is.na(NA_character_)) 
[17:39:22.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:22.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:22.958]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:22.958]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:22.958]                     envir = parent.frame()) 
[17:39:22.958]                   {
[17:39:22.958]                     if (is.function(workers)) 
[17:39:22.958]                       workers <- workers()
[17:39:22.958]                     workers <- structure(as.integer(workers), 
[17:39:22.958]                       class = class(workers))
[17:39:22.958]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:22.958]                       workers >= 1)
[17:39:22.958]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:22.958]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:22.958]                     }
[17:39:22.958]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:22.958]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:22.958]                       envir = envir)
[17:39:22.958]                     if (!future$lazy) 
[17:39:22.958]                       future <- run(future)
[17:39:22.958]                     invisible(future)
[17:39:22.958]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:22.958]                 }
[17:39:22.958]             }
[17:39:22.958]         }
[17:39:22.958]     })
[17:39:22.958]     if (TRUE) {
[17:39:22.958]         base::sink(type = "output", split = FALSE)
[17:39:22.958]         if (TRUE) {
[17:39:22.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:22.958]         }
[17:39:22.958]         else {
[17:39:22.958]             ...future.result["stdout"] <- base::list(NULL)
[17:39:22.958]         }
[17:39:22.958]         base::close(...future.stdout)
[17:39:22.958]         ...future.stdout <- NULL
[17:39:22.958]     }
[17:39:22.958]     ...future.result$conditions <- ...future.conditions
[17:39:22.958]     ...future.result$finished <- base::Sys.time()
[17:39:22.958]     ...future.result
[17:39:22.958] }
[17:39:22.962] Exporting 5 global objects (346.00 KiB) to cluster node #2 ...
[17:39:22.962] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:22.963] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:22.963] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[17:39:23.007] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[17:39:23.007] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:39:23.008] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:39:23.008] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:23.009] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.009] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:23.009] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.009] Exporting 5 global objects (346.00 KiB) to cluster node #2 ... DONE
[17:39:23.010] MultisessionFuture started
[17:39:23.010] - Launch lazy future ... done
[17:39:23.010] run() for ‘MultisessionFuture’ ... done
[17:39:23.010] Created future:
[17:39:23.011] MultisessionFuture:
[17:39:23.011] Label: ‘future_apply-2’
[17:39:23.011] Expression:
[17:39:23.011] {
[17:39:23.011]     do.call(function(...) {
[17:39:23.011]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.011]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.011]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.011]             on.exit(options(oopts), add = TRUE)
[17:39:23.011]         }
[17:39:23.011]         {
[17:39:23.011]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.011]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.011]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.011]             })
[17:39:23.011]         }
[17:39:23.011]     }, args = future.call.arguments)
[17:39:23.011] }
[17:39:23.011] Lazy evaluation: FALSE
[17:39:23.011] Asynchronous evaluation: TRUE
[17:39:23.011] Local evaluation: TRUE
[17:39:23.011] Environment: R_GlobalEnv
[17:39:23.011] Capture standard output: TRUE
[17:39:23.011] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.011] Globals: 5 objects totaling 346.00 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.011] Packages: <none>
[17:39:23.011] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.011] Resolved: FALSE
[17:39:23.011] Value: <not collected>
[17:39:23.011] Conditions captured: <none>
[17:39:23.011] Early signaling: FALSE
[17:39:23.011] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.011] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.022] Chunk #2 of 2 ... DONE
[17:39:23.022] Launching 2 futures (chunks) ... DONE
[17:39:23.023] Resolving 2 futures (chunks) ...
[17:39:23.023] resolve() on list ...
[17:39:23.023]  recursive: 0
[17:39:23.023]  length: 2
[17:39:23.023] 
[17:39:23.024] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.024] - Validating connection of MultisessionFuture
[17:39:23.024] - received message: FutureResult
[17:39:23.024] - Received FutureResult
[17:39:23.024] - Erased future from FutureRegistry
[17:39:23.024] result() for ClusterFuture ...
[17:39:23.024] - result already collected: FutureResult
[17:39:23.024] result() for ClusterFuture ... done
[17:39:23.025] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.025] Future #1
[17:39:23.025] result() for ClusterFuture ...
[17:39:23.025] - result already collected: FutureResult
[17:39:23.025] result() for ClusterFuture ... done
[17:39:23.025] result() for ClusterFuture ...
[17:39:23.025] - result already collected: FutureResult
[17:39:23.025] result() for ClusterFuture ... done
[17:39:23.025] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:23.025] - nx: 2
[17:39:23.025] - relay: TRUE
[17:39:23.025] - stdout: TRUE
[17:39:23.026] - signal: TRUE
[17:39:23.026] - resignal: FALSE
[17:39:23.026] - force: TRUE
[17:39:23.026] - relayed: [n=2] FALSE, FALSE
[17:39:23.026] - queued futures: [n=2] FALSE, FALSE
[17:39:23.026]  - until=1
[17:39:23.026]  - relaying element #1
[17:39:23.026] result() for ClusterFuture ...
[17:39:23.026] - result already collected: FutureResult
[17:39:23.026] result() for ClusterFuture ... done
[17:39:23.027] result() for ClusterFuture ...
[17:39:23.027] - result already collected: FutureResult
[17:39:23.027] result() for ClusterFuture ... done
[17:39:23.027] result() for ClusterFuture ...
[17:39:23.027] - result already collected: FutureResult
[17:39:23.027] result() for ClusterFuture ... done
[17:39:23.027] result() for ClusterFuture ...
[17:39:23.027] - result already collected: FutureResult
[17:39:23.027] result() for ClusterFuture ... done
[17:39:23.027] - relayed: [n=2] TRUE, FALSE
[17:39:23.027] - queued futures: [n=2] TRUE, FALSE
[17:39:23.028] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:23.030]  length: 1 (resolved future 1)
[17:39:23.056] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.056] - Validating connection of MultisessionFuture
[17:39:23.056] - received message: FutureResult
[17:39:23.056] - Received FutureResult
[17:39:23.057] - Erased future from FutureRegistry
[17:39:23.057] result() for ClusterFuture ...
[17:39:23.057] - result already collected: FutureResult
[17:39:23.057] result() for ClusterFuture ... done
[17:39:23.057] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.057] Future #2
[17:39:23.057] result() for ClusterFuture ...
[17:39:23.057] - result already collected: FutureResult
[17:39:23.058] result() for ClusterFuture ... done
[17:39:23.058] result() for ClusterFuture ...
[17:39:23.058] - result already collected: FutureResult
[17:39:23.058] result() for ClusterFuture ... done
[17:39:23.058] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:23.058] - nx: 2
[17:39:23.058] - relay: TRUE
[17:39:23.058] - stdout: TRUE
[17:39:23.058] - signal: TRUE
[17:39:23.058] - resignal: FALSE
[17:39:23.058] - force: TRUE
[17:39:23.059] - relayed: [n=2] TRUE, FALSE
[17:39:23.059] - queued futures: [n=2] TRUE, FALSE
[17:39:23.059]  - until=2
[17:39:23.059]  - relaying element #2
[17:39:23.059] result() for ClusterFuture ...
[17:39:23.059] - result already collected: FutureResult
[17:39:23.059] result() for ClusterFuture ... done
[17:39:23.059] result() for ClusterFuture ...
[17:39:23.059] - result already collected: FutureResult
[17:39:23.059] result() for ClusterFuture ... done
[17:39:23.060] result() for ClusterFuture ...
[17:39:23.060] - result already collected: FutureResult
[17:39:23.060] result() for ClusterFuture ... done
[17:39:23.060] result() for ClusterFuture ...
[17:39:23.060] - result already collected: FutureResult
[17:39:23.060] result() for ClusterFuture ... done
[17:39:23.060] - relayed: [n=2] TRUE, TRUE
[17:39:23.060] - queued futures: [n=2] TRUE, TRUE
[17:39:23.060] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:23.060]  length: 0 (resolved future 2)
[17:39:23.060] Relaying remaining futures
[17:39:23.061] signalConditionsASAP(NULL, pos=0) ...
[17:39:23.061] - nx: 2
[17:39:23.061] - relay: TRUE
[17:39:23.061] - stdout: TRUE
[17:39:23.061] - signal: TRUE
[17:39:23.061] - resignal: FALSE
[17:39:23.061] - force: TRUE
[17:39:23.061] - relayed: [n=2] TRUE, TRUE
[17:39:23.061] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:23.061] - relayed: [n=2] TRUE, TRUE
[17:39:23.061] - queued futures: [n=2] TRUE, TRUE
[17:39:23.062] signalConditionsASAP(NULL, pos=0) ... done
[17:39:23.062] resolve() on list ... DONE
[17:39:23.062] result() for ClusterFuture ...
[17:39:23.062] - result already collected: FutureResult
[17:39:23.062] result() for ClusterFuture ... done
[17:39:23.062] result() for ClusterFuture ...
[17:39:23.062] - result already collected: FutureResult
[17:39:23.062] result() for ClusterFuture ... done
[17:39:23.062] result() for ClusterFuture ...
[17:39:23.062] - result already collected: FutureResult
[17:39:23.062] result() for ClusterFuture ... done
[17:39:23.062] result() for ClusterFuture ...
[17:39:23.063] - result already collected: FutureResult
[17:39:23.063] result() for ClusterFuture ... done
[17:39:23.063]  - Number of value chunks collected: 2
[17:39:23.063] Resolving 2 futures (chunks) ... DONE
[17:39:23.063] Reducing values from 2 chunks ...
[17:39:23.063]  - Number of values collected after concatenation: 2
[17:39:23.063]  - Number of values expected: 2
[17:39:23.063] Reducing values from 2 chunks ... DONE
[17:39:23.063] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:39:23.064] getGlobalsAndPackagesXApply() ...
[17:39:23.064]  - future.globals: TRUE
[17:39:23.064] getGlobalsAndPackages() ...
[17:39:23.064] Searching for globals...
[17:39:23.066] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:39:23.066] Searching for globals ... DONE
[17:39:23.066] Resolving globals: FALSE
[17:39:23.066] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:39:23.066] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:39:23.067] - globals: [1] ‘FUN’
[17:39:23.067] - packages: [1] ‘stats’
[17:39:23.067] getGlobalsAndPackages() ... DONE
[17:39:23.067]  - globals found/used: [n=1] ‘FUN’
[17:39:23.067]  - needed namespaces: [n=1] ‘stats’
[17:39:23.067] Finding globals ... DONE
[17:39:23.067]  - use_args: TRUE
[17:39:23.067]  - Getting '...' globals ...
[17:39:23.068] resolve() on list ...
[17:39:23.068]  recursive: 0
[17:39:23.068]  length: 1
[17:39:23.068]  elements: ‘...’
[17:39:23.068]  length: 0 (resolved future 1)
[17:39:23.068] resolve() on list ... DONE
[17:39:23.068]    - '...' content: [n=0] 
[17:39:23.068] List of 1
[17:39:23.068]  $ ...: list()
[17:39:23.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.068]  - attr(*, "where")=List of 1
[17:39:23.068]   ..$ ...:<environment: 0x55c796de5328> 
[17:39:23.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.068]  - attr(*, "resolved")= logi TRUE
[17:39:23.068]  - attr(*, "total_size")= num NA
[17:39:23.071]  - Getting '...' globals ... DONE
[17:39:23.071] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:23.071] List of 2
[17:39:23.071]  $ ...future.FUN:function (x, ...)  
[17:39:23.071]  $ ...          : list()
[17:39:23.071]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.071]  - attr(*, "where")=List of 2
[17:39:23.071]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:23.071]   ..$ ...          :<environment: 0x55c796de5328> 
[17:39:23.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.071]  - attr(*, "resolved")= logi FALSE
[17:39:23.071]  - attr(*, "total_size")= num 1248
[17:39:23.074] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:23.074] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.077] future_lapply() ...
[17:39:23.081] Number of chunks: 2
[17:39:23.081] getGlobalsAndPackagesXApply() ...
[17:39:23.081]  - future.globals: <name-value list> with names ‘list()’
[17:39:23.081]  - use_args: TRUE
[17:39:23.081] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:23.082] List of 2
[17:39:23.082]  $ ...          : list()
[17:39:23.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.082]  $ ...future.FUN:function (x, ...)  
[17:39:23.082]  - attr(*, "where")=List of 2
[17:39:23.082]   ..$ ...          :<environment: 0x55c796de5328> 
[17:39:23.082]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:39:23.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.082]  - attr(*, "resolved")= logi FALSE
[17:39:23.082]  - attr(*, "total_size")= num NA
[17:39:23.084] Packages to be attached in all futures: [n=1] ‘stats’
[17:39:23.084] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.085] Number of futures (= number of chunks): 2
[17:39:23.085] Launching 2 futures (chunks) ...
[17:39:23.085] Chunk #1 of 2 ...
[17:39:23.085]  - seeds: <none>
[17:39:23.085] getGlobalsAndPackages() ...
[17:39:23.085] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.085] Resolving globals: FALSE
[17:39:23.085] Tweak future expression to call with '...' arguments ...
[17:39:23.085] {
[17:39:23.085]     do.call(function(...) {
[17:39:23.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.085]             on.exit(options(oopts), add = TRUE)
[17:39:23.085]         }
[17:39:23.085]         {
[17:39:23.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.085]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.085]             })
[17:39:23.085]         }
[17:39:23.085]     }, args = future.call.arguments)
[17:39:23.085] }
[17:39:23.086] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.086] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.086] - packages: [1] ‘stats’
[17:39:23.086] getGlobalsAndPackages() ... DONE
[17:39:23.087] run() for ‘Future’ ...
[17:39:23.087] - state: ‘created’
[17:39:23.087] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.101] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.101]   - Field: ‘node’
[17:39:23.101]   - Field: ‘label’
[17:39:23.102]   - Field: ‘local’
[17:39:23.102]   - Field: ‘owner’
[17:39:23.102]   - Field: ‘envir’
[17:39:23.102]   - Field: ‘workers’
[17:39:23.102]   - Field: ‘packages’
[17:39:23.102]   - Field: ‘gc’
[17:39:23.102]   - Field: ‘conditions’
[17:39:23.102]   - Field: ‘persistent’
[17:39:23.102]   - Field: ‘expr’
[17:39:23.102]   - Field: ‘uuid’
[17:39:23.102]   - Field: ‘seed’
[17:39:23.103]   - Field: ‘version’
[17:39:23.103]   - Field: ‘result’
[17:39:23.103]   - Field: ‘asynchronous’
[17:39:23.103]   - Field: ‘calls’
[17:39:23.103]   - Field: ‘globals’
[17:39:23.103]   - Field: ‘stdout’
[17:39:23.103]   - Field: ‘earlySignal’
[17:39:23.103]   - Field: ‘lazy’
[17:39:23.103]   - Field: ‘state’
[17:39:23.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.104] - Launch lazy future ...
[17:39:23.104] Packages needed by the future expression (n = 1): ‘stats’
[17:39:23.104] Packages needed by future strategies (n = 0): <none>
[17:39:23.104] {
[17:39:23.104]     {
[17:39:23.104]         {
[17:39:23.104]             ...future.startTime <- base::Sys.time()
[17:39:23.104]             {
[17:39:23.104]                 {
[17:39:23.104]                   {
[17:39:23.104]                     {
[17:39:23.104]                       {
[17:39:23.104]                         base::local({
[17:39:23.104]                           has_future <- base::requireNamespace("future", 
[17:39:23.104]                             quietly = TRUE)
[17:39:23.104]                           if (has_future) {
[17:39:23.104]                             ns <- base::getNamespace("future")
[17:39:23.104]                             version <- ns[[".package"]][["version"]]
[17:39:23.104]                             if (is.null(version)) 
[17:39:23.104]                               version <- utils::packageVersion("future")
[17:39:23.104]                           }
[17:39:23.104]                           else {
[17:39:23.104]                             version <- NULL
[17:39:23.104]                           }
[17:39:23.104]                           if (!has_future || version < "1.8.0") {
[17:39:23.104]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.104]                               "", base::R.version$version.string), 
[17:39:23.104]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:23.104]                                 base::R.version$platform, 8 * 
[17:39:23.104]                                   base::.Machine$sizeof.pointer), 
[17:39:23.104]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.104]                                 "release", "version")], collapse = " "), 
[17:39:23.104]                               hostname = base::Sys.info()[["nodename"]])
[17:39:23.104]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.104]                               info)
[17:39:23.104]                             info <- base::paste(info, collapse = "; ")
[17:39:23.104]                             if (!has_future) {
[17:39:23.104]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.104]                                 info)
[17:39:23.104]                             }
[17:39:23.104]                             else {
[17:39:23.104]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.104]                                 info, version)
[17:39:23.104]                             }
[17:39:23.104]                             base::stop(msg)
[17:39:23.104]                           }
[17:39:23.104]                         })
[17:39:23.104]                       }
[17:39:23.104]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.104]                       base::options(mc.cores = 1L)
[17:39:23.104]                     }
[17:39:23.104]                     base::local({
[17:39:23.104]                       for (pkg in "stats") {
[17:39:23.104]                         base::loadNamespace(pkg)
[17:39:23.104]                         base::library(pkg, character.only = TRUE)
[17:39:23.104]                       }
[17:39:23.104]                     })
[17:39:23.104]                   }
[17:39:23.104]                   options(future.plan = NULL)
[17:39:23.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.104]                 }
[17:39:23.104]                 ...future.workdir <- getwd()
[17:39:23.104]             }
[17:39:23.104]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.104]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.104]         }
[17:39:23.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.104]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.104]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.104]             base::names(...future.oldOptions))
[17:39:23.104]     }
[17:39:23.104]     if (FALSE) {
[17:39:23.104]     }
[17:39:23.104]     else {
[17:39:23.104]         if (TRUE) {
[17:39:23.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.104]                 open = "w")
[17:39:23.104]         }
[17:39:23.104]         else {
[17:39:23.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.104]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.104]         }
[17:39:23.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.104]             base::sink(type = "output", split = FALSE)
[17:39:23.104]             base::close(...future.stdout)
[17:39:23.104]         }, add = TRUE)
[17:39:23.104]     }
[17:39:23.104]     ...future.frame <- base::sys.nframe()
[17:39:23.104]     ...future.conditions <- base::list()
[17:39:23.104]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.104]     if (FALSE) {
[17:39:23.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.104]     }
[17:39:23.104]     ...future.result <- base::tryCatch({
[17:39:23.104]         base::withCallingHandlers({
[17:39:23.104]             ...future.value <- base::withVisible(base::local({
[17:39:23.104]                 ...future.makeSendCondition <- local({
[17:39:23.104]                   sendCondition <- NULL
[17:39:23.104]                   function(frame = 1L) {
[17:39:23.104]                     if (is.function(sendCondition)) 
[17:39:23.104]                       return(sendCondition)
[17:39:23.104]                     ns <- getNamespace("parallel")
[17:39:23.104]                     if (exists("sendData", mode = "function", 
[17:39:23.104]                       envir = ns)) {
[17:39:23.104]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.104]                         envir = ns)
[17:39:23.104]                       envir <- sys.frame(frame)
[17:39:23.104]                       master <- NULL
[17:39:23.104]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.104]                         !identical(envir, emptyenv())) {
[17:39:23.104]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.104]                           inherits = FALSE)) {
[17:39:23.104]                           master <- get("master", mode = "list", 
[17:39:23.104]                             envir = envir, inherits = FALSE)
[17:39:23.104]                           if (inherits(master, c("SOCKnode", 
[17:39:23.104]                             "SOCK0node"))) {
[17:39:23.104]                             sendCondition <<- function(cond) {
[17:39:23.104]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.104]                                 success = TRUE)
[17:39:23.104]                               parallel_sendData(master, data)
[17:39:23.104]                             }
[17:39:23.104]                             return(sendCondition)
[17:39:23.104]                           }
[17:39:23.104]                         }
[17:39:23.104]                         frame <- frame + 1L
[17:39:23.104]                         envir <- sys.frame(frame)
[17:39:23.104]                       }
[17:39:23.104]                     }
[17:39:23.104]                     sendCondition <<- function(cond) NULL
[17:39:23.104]                   }
[17:39:23.104]                 })
[17:39:23.104]                 withCallingHandlers({
[17:39:23.104]                   {
[17:39:23.104]                     do.call(function(...) {
[17:39:23.104]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.104]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.104]                         ...future.globals.maxSize)) {
[17:39:23.104]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.104]                         on.exit(options(oopts), add = TRUE)
[17:39:23.104]                       }
[17:39:23.104]                       {
[17:39:23.104]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.104]                           FUN = function(jj) {
[17:39:23.104]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.104]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.104]                           })
[17:39:23.104]                       }
[17:39:23.104]                     }, args = future.call.arguments)
[17:39:23.104]                   }
[17:39:23.104]                 }, immediateCondition = function(cond) {
[17:39:23.104]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.104]                   sendCondition(cond)
[17:39:23.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.104]                   {
[17:39:23.104]                     inherits <- base::inherits
[17:39:23.104]                     invokeRestart <- base::invokeRestart
[17:39:23.104]                     is.null <- base::is.null
[17:39:23.104]                     muffled <- FALSE
[17:39:23.104]                     if (inherits(cond, "message")) {
[17:39:23.104]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.104]                       if (muffled) 
[17:39:23.104]                         invokeRestart("muffleMessage")
[17:39:23.104]                     }
[17:39:23.104]                     else if (inherits(cond, "warning")) {
[17:39:23.104]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.104]                       if (muffled) 
[17:39:23.104]                         invokeRestart("muffleWarning")
[17:39:23.104]                     }
[17:39:23.104]                     else if (inherits(cond, "condition")) {
[17:39:23.104]                       if (!is.null(pattern)) {
[17:39:23.104]                         computeRestarts <- base::computeRestarts
[17:39:23.104]                         grepl <- base::grepl
[17:39:23.104]                         restarts <- computeRestarts(cond)
[17:39:23.104]                         for (restart in restarts) {
[17:39:23.104]                           name <- restart$name
[17:39:23.104]                           if (is.null(name)) 
[17:39:23.104]                             next
[17:39:23.104]                           if (!grepl(pattern, name)) 
[17:39:23.104]                             next
[17:39:23.104]                           invokeRestart(restart)
[17:39:23.104]                           muffled <- TRUE
[17:39:23.104]                           break
[17:39:23.104]                         }
[17:39:23.104]                       }
[17:39:23.104]                     }
[17:39:23.104]                     invisible(muffled)
[17:39:23.104]                   }
[17:39:23.104]                   muffleCondition(cond)
[17:39:23.104]                 })
[17:39:23.104]             }))
[17:39:23.104]             future::FutureResult(value = ...future.value$value, 
[17:39:23.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.104]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.104]                     ...future.globalenv.names))
[17:39:23.104]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.104]         }, condition = base::local({
[17:39:23.104]             c <- base::c
[17:39:23.104]             inherits <- base::inherits
[17:39:23.104]             invokeRestart <- base::invokeRestart
[17:39:23.104]             length <- base::length
[17:39:23.104]             list <- base::list
[17:39:23.104]             seq.int <- base::seq.int
[17:39:23.104]             signalCondition <- base::signalCondition
[17:39:23.104]             sys.calls <- base::sys.calls
[17:39:23.104]             `[[` <- base::`[[`
[17:39:23.104]             `+` <- base::`+`
[17:39:23.104]             `<<-` <- base::`<<-`
[17:39:23.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.104]                   3L)]
[17:39:23.104]             }
[17:39:23.104]             function(cond) {
[17:39:23.104]                 is_error <- inherits(cond, "error")
[17:39:23.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.104]                   NULL)
[17:39:23.104]                 if (is_error) {
[17:39:23.104]                   sessionInformation <- function() {
[17:39:23.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.104]                       search = base::search(), system = base::Sys.info())
[17:39:23.104]                   }
[17:39:23.104]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.104]                     cond$call), session = sessionInformation(), 
[17:39:23.104]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.104]                   signalCondition(cond)
[17:39:23.104]                 }
[17:39:23.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.104]                 "immediateCondition"))) {
[17:39:23.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.104]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.104]                   if (TRUE && !signal) {
[17:39:23.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.104]                     {
[17:39:23.104]                       inherits <- base::inherits
[17:39:23.104]                       invokeRestart <- base::invokeRestart
[17:39:23.104]                       is.null <- base::is.null
[17:39:23.104]                       muffled <- FALSE
[17:39:23.104]                       if (inherits(cond, "message")) {
[17:39:23.104]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.104]                         if (muffled) 
[17:39:23.104]                           invokeRestart("muffleMessage")
[17:39:23.104]                       }
[17:39:23.104]                       else if (inherits(cond, "warning")) {
[17:39:23.104]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.104]                         if (muffled) 
[17:39:23.104]                           invokeRestart("muffleWarning")
[17:39:23.104]                       }
[17:39:23.104]                       else if (inherits(cond, "condition")) {
[17:39:23.104]                         if (!is.null(pattern)) {
[17:39:23.104]                           computeRestarts <- base::computeRestarts
[17:39:23.104]                           grepl <- base::grepl
[17:39:23.104]                           restarts <- computeRestarts(cond)
[17:39:23.104]                           for (restart in restarts) {
[17:39:23.104]                             name <- restart$name
[17:39:23.104]                             if (is.null(name)) 
[17:39:23.104]                               next
[17:39:23.104]                             if (!grepl(pattern, name)) 
[17:39:23.104]                               next
[17:39:23.104]                             invokeRestart(restart)
[17:39:23.104]                             muffled <- TRUE
[17:39:23.104]                             break
[17:39:23.104]                           }
[17:39:23.104]                         }
[17:39:23.104]                       }
[17:39:23.104]                       invisible(muffled)
[17:39:23.104]                     }
[17:39:23.104]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.104]                   }
[17:39:23.104]                 }
[17:39:23.104]                 else {
[17:39:23.104]                   if (TRUE) {
[17:39:23.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.104]                     {
[17:39:23.104]                       inherits <- base::inherits
[17:39:23.104]                       invokeRestart <- base::invokeRestart
[17:39:23.104]                       is.null <- base::is.null
[17:39:23.104]                       muffled <- FALSE
[17:39:23.104]                       if (inherits(cond, "message")) {
[17:39:23.104]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.104]                         if (muffled) 
[17:39:23.104]                           invokeRestart("muffleMessage")
[17:39:23.104]                       }
[17:39:23.104]                       else if (inherits(cond, "warning")) {
[17:39:23.104]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.104]                         if (muffled) 
[17:39:23.104]                           invokeRestart("muffleWarning")
[17:39:23.104]                       }
[17:39:23.104]                       else if (inherits(cond, "condition")) {
[17:39:23.104]                         if (!is.null(pattern)) {
[17:39:23.104]                           computeRestarts <- base::computeRestarts
[17:39:23.104]                           grepl <- base::grepl
[17:39:23.104]                           restarts <- computeRestarts(cond)
[17:39:23.104]                           for (restart in restarts) {
[17:39:23.104]                             name <- restart$name
[17:39:23.104]                             if (is.null(name)) 
[17:39:23.104]                               next
[17:39:23.104]                             if (!grepl(pattern, name)) 
[17:39:23.104]                               next
[17:39:23.104]                             invokeRestart(restart)
[17:39:23.104]                             muffled <- TRUE
[17:39:23.104]                             break
[17:39:23.104]                           }
[17:39:23.104]                         }
[17:39:23.104]                       }
[17:39:23.104]                       invisible(muffled)
[17:39:23.104]                     }
[17:39:23.104]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.104]                   }
[17:39:23.104]                 }
[17:39:23.104]             }
[17:39:23.104]         }))
[17:39:23.104]     }, error = function(ex) {
[17:39:23.104]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.104]                 ...future.rng), started = ...future.startTime, 
[17:39:23.104]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.104]             version = "1.8"), class = "FutureResult")
[17:39:23.104]     }, finally = {
[17:39:23.104]         if (!identical(...future.workdir, getwd())) 
[17:39:23.104]             setwd(...future.workdir)
[17:39:23.104]         {
[17:39:23.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.104]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.104]             }
[17:39:23.104]             base::options(...future.oldOptions)
[17:39:23.104]             if (.Platform$OS.type == "windows") {
[17:39:23.104]                 old_names <- names(...future.oldEnvVars)
[17:39:23.104]                 envs <- base::Sys.getenv()
[17:39:23.104]                 names <- names(envs)
[17:39:23.104]                 common <- intersect(names, old_names)
[17:39:23.104]                 added <- setdiff(names, old_names)
[17:39:23.104]                 removed <- setdiff(old_names, names)
[17:39:23.104]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.104]                   envs[common]]
[17:39:23.104]                 NAMES <- toupper(changed)
[17:39:23.104]                 args <- list()
[17:39:23.104]                 for (kk in seq_along(NAMES)) {
[17:39:23.104]                   name <- changed[[kk]]
[17:39:23.104]                   NAME <- NAMES[[kk]]
[17:39:23.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.104]                     next
[17:39:23.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.104]                 }
[17:39:23.104]                 NAMES <- toupper(added)
[17:39:23.104]                 for (kk in seq_along(NAMES)) {
[17:39:23.104]                   name <- added[[kk]]
[17:39:23.104]                   NAME <- NAMES[[kk]]
[17:39:23.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.104]                     next
[17:39:23.104]                   args[[name]] <- ""
[17:39:23.104]                 }
[17:39:23.104]                 NAMES <- toupper(removed)
[17:39:23.104]                 for (kk in seq_along(NAMES)) {
[17:39:23.104]                   name <- removed[[kk]]
[17:39:23.104]                   NAME <- NAMES[[kk]]
[17:39:23.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.104]                     next
[17:39:23.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.104]                 }
[17:39:23.104]                 if (length(args) > 0) 
[17:39:23.104]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.104]             }
[17:39:23.104]             else {
[17:39:23.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.104]             }
[17:39:23.104]             {
[17:39:23.104]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.104]                   0L) {
[17:39:23.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.104]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.104]                   base::options(opts)
[17:39:23.104]                 }
[17:39:23.104]                 {
[17:39:23.104]                   {
[17:39:23.104]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.104]                     NULL
[17:39:23.104]                   }
[17:39:23.104]                   options(future.plan = NULL)
[17:39:23.104]                   if (is.na(NA_character_)) 
[17:39:23.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.104]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.104]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.104]                     envir = parent.frame()) 
[17:39:23.104]                   {
[17:39:23.104]                     if (is.function(workers)) 
[17:39:23.104]                       workers <- workers()
[17:39:23.104]                     workers <- structure(as.integer(workers), 
[17:39:23.104]                       class = class(workers))
[17:39:23.104]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.104]                       workers >= 1)
[17:39:23.104]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.104]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.104]                     }
[17:39:23.104]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.104]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.104]                       envir = envir)
[17:39:23.104]                     if (!future$lazy) 
[17:39:23.104]                       future <- run(future)
[17:39:23.104]                     invisible(future)
[17:39:23.104]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.104]                 }
[17:39:23.104]             }
[17:39:23.104]         }
[17:39:23.104]     })
[17:39:23.104]     if (TRUE) {
[17:39:23.104]         base::sink(type = "output", split = FALSE)
[17:39:23.104]         if (TRUE) {
[17:39:23.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.104]         }
[17:39:23.104]         else {
[17:39:23.104]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.104]         }
[17:39:23.104]         base::close(...future.stdout)
[17:39:23.104]         ...future.stdout <- NULL
[17:39:23.104]     }
[17:39:23.104]     ...future.result$conditions <- ...future.conditions
[17:39:23.104]     ...future.result$finished <- base::Sys.time()
[17:39:23.104]     ...future.result
[17:39:23.104] }
[17:39:23.108] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[17:39:23.108] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:23.108] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.108] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:39:23.109] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:39:23.109] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:39:23.109] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:39:23.109] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:23.110] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.110] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:23.110] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.110] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[17:39:23.111] MultisessionFuture started
[17:39:23.111] - Launch lazy future ... done
[17:39:23.111] run() for ‘MultisessionFuture’ ... done
[17:39:23.111] Created future:
[17:39:23.112] MultisessionFuture:
[17:39:23.112] Label: ‘future_apply-1’
[17:39:23.112] Expression:
[17:39:23.112] {
[17:39:23.112]     do.call(function(...) {
[17:39:23.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.112]             on.exit(options(oopts), add = TRUE)
[17:39:23.112]         }
[17:39:23.112]         {
[17:39:23.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.112]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.112]             })
[17:39:23.112]         }
[17:39:23.112]     }, args = future.call.arguments)
[17:39:23.112] }
[17:39:23.112] Lazy evaluation: FALSE
[17:39:23.112] Asynchronous evaluation: TRUE
[17:39:23.112] Local evaluation: TRUE
[17:39:23.112] Environment: R_GlobalEnv
[17:39:23.112] Capture standard output: TRUE
[17:39:23.112] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.112] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.112] Packages: 1 packages (‘stats’)
[17:39:23.112] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.112] Resolved: FALSE
[17:39:23.112] Value: <not collected>
[17:39:23.112] Conditions captured: <none>
[17:39:23.112] Early signaling: FALSE
[17:39:23.112] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.112] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.123] Chunk #1 of 2 ... DONE
[17:39:23.123] Chunk #2 of 2 ...
[17:39:23.123]  - seeds: <none>
[17:39:23.123] getGlobalsAndPackages() ...
[17:39:23.123] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.124] Resolving globals: FALSE
[17:39:23.124] Tweak future expression to call with '...' arguments ...
[17:39:23.124] {
[17:39:23.124]     do.call(function(...) {
[17:39:23.124]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.124]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.124]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.124]             on.exit(options(oopts), add = TRUE)
[17:39:23.124]         }
[17:39:23.124]         {
[17:39:23.124]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.124]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.124]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.124]             })
[17:39:23.124]         }
[17:39:23.124]     }, args = future.call.arguments)
[17:39:23.124] }
[17:39:23.124] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.125] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.125] - packages: [1] ‘stats’
[17:39:23.125] getGlobalsAndPackages() ... DONE
[17:39:23.125] run() for ‘Future’ ...
[17:39:23.125] - state: ‘created’
[17:39:23.125] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.139] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.140]   - Field: ‘node’
[17:39:23.140]   - Field: ‘label’
[17:39:23.140]   - Field: ‘local’
[17:39:23.140]   - Field: ‘owner’
[17:39:23.140]   - Field: ‘envir’
[17:39:23.140]   - Field: ‘workers’
[17:39:23.140]   - Field: ‘packages’
[17:39:23.140]   - Field: ‘gc’
[17:39:23.140]   - Field: ‘conditions’
[17:39:23.141]   - Field: ‘persistent’
[17:39:23.141]   - Field: ‘expr’
[17:39:23.141]   - Field: ‘uuid’
[17:39:23.141]   - Field: ‘seed’
[17:39:23.141]   - Field: ‘version’
[17:39:23.141]   - Field: ‘result’
[17:39:23.141]   - Field: ‘asynchronous’
[17:39:23.141]   - Field: ‘calls’
[17:39:23.141]   - Field: ‘globals’
[17:39:23.141]   - Field: ‘stdout’
[17:39:23.141]   - Field: ‘earlySignal’
[17:39:23.142]   - Field: ‘lazy’
[17:39:23.142]   - Field: ‘state’
[17:39:23.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.142] - Launch lazy future ...
[17:39:23.142] Packages needed by the future expression (n = 1): ‘stats’
[17:39:23.142] Packages needed by future strategies (n = 0): <none>
[17:39:23.143] {
[17:39:23.143]     {
[17:39:23.143]         {
[17:39:23.143]             ...future.startTime <- base::Sys.time()
[17:39:23.143]             {
[17:39:23.143]                 {
[17:39:23.143]                   {
[17:39:23.143]                     {
[17:39:23.143]                       {
[17:39:23.143]                         base::local({
[17:39:23.143]                           has_future <- base::requireNamespace("future", 
[17:39:23.143]                             quietly = TRUE)
[17:39:23.143]                           if (has_future) {
[17:39:23.143]                             ns <- base::getNamespace("future")
[17:39:23.143]                             version <- ns[[".package"]][["version"]]
[17:39:23.143]                             if (is.null(version)) 
[17:39:23.143]                               version <- utils::packageVersion("future")
[17:39:23.143]                           }
[17:39:23.143]                           else {
[17:39:23.143]                             version <- NULL
[17:39:23.143]                           }
[17:39:23.143]                           if (!has_future || version < "1.8.0") {
[17:39:23.143]                             info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.143]                               "", base::R.version$version.string), 
[17:39:23.143]                               platform = base::sprintf("%s (%s-bit)", 
[17:39:23.143]                                 base::R.version$platform, 8 * 
[17:39:23.143]                                   base::.Machine$sizeof.pointer), 
[17:39:23.143]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.143]                                 "release", "version")], collapse = " "), 
[17:39:23.143]                               hostname = base::Sys.info()[["nodename"]])
[17:39:23.143]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.143]                               info)
[17:39:23.143]                             info <- base::paste(info, collapse = "; ")
[17:39:23.143]                             if (!has_future) {
[17:39:23.143]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.143]                                 info)
[17:39:23.143]                             }
[17:39:23.143]                             else {
[17:39:23.143]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.143]                                 info, version)
[17:39:23.143]                             }
[17:39:23.143]                             base::stop(msg)
[17:39:23.143]                           }
[17:39:23.143]                         })
[17:39:23.143]                       }
[17:39:23.143]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.143]                       base::options(mc.cores = 1L)
[17:39:23.143]                     }
[17:39:23.143]                     base::local({
[17:39:23.143]                       for (pkg in "stats") {
[17:39:23.143]                         base::loadNamespace(pkg)
[17:39:23.143]                         base::library(pkg, character.only = TRUE)
[17:39:23.143]                       }
[17:39:23.143]                     })
[17:39:23.143]                   }
[17:39:23.143]                   options(future.plan = NULL)
[17:39:23.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.143]                 }
[17:39:23.143]                 ...future.workdir <- getwd()
[17:39:23.143]             }
[17:39:23.143]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.143]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.143]         }
[17:39:23.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.143]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.143]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.143]             base::names(...future.oldOptions))
[17:39:23.143]     }
[17:39:23.143]     if (FALSE) {
[17:39:23.143]     }
[17:39:23.143]     else {
[17:39:23.143]         if (TRUE) {
[17:39:23.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.143]                 open = "w")
[17:39:23.143]         }
[17:39:23.143]         else {
[17:39:23.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.143]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.143]         }
[17:39:23.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.143]             base::sink(type = "output", split = FALSE)
[17:39:23.143]             base::close(...future.stdout)
[17:39:23.143]         }, add = TRUE)
[17:39:23.143]     }
[17:39:23.143]     ...future.frame <- base::sys.nframe()
[17:39:23.143]     ...future.conditions <- base::list()
[17:39:23.143]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.143]     if (FALSE) {
[17:39:23.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.143]     }
[17:39:23.143]     ...future.result <- base::tryCatch({
[17:39:23.143]         base::withCallingHandlers({
[17:39:23.143]             ...future.value <- base::withVisible(base::local({
[17:39:23.143]                 ...future.makeSendCondition <- local({
[17:39:23.143]                   sendCondition <- NULL
[17:39:23.143]                   function(frame = 1L) {
[17:39:23.143]                     if (is.function(sendCondition)) 
[17:39:23.143]                       return(sendCondition)
[17:39:23.143]                     ns <- getNamespace("parallel")
[17:39:23.143]                     if (exists("sendData", mode = "function", 
[17:39:23.143]                       envir = ns)) {
[17:39:23.143]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.143]                         envir = ns)
[17:39:23.143]                       envir <- sys.frame(frame)
[17:39:23.143]                       master <- NULL
[17:39:23.143]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.143]                         !identical(envir, emptyenv())) {
[17:39:23.143]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.143]                           inherits = FALSE)) {
[17:39:23.143]                           master <- get("master", mode = "list", 
[17:39:23.143]                             envir = envir, inherits = FALSE)
[17:39:23.143]                           if (inherits(master, c("SOCKnode", 
[17:39:23.143]                             "SOCK0node"))) {
[17:39:23.143]                             sendCondition <<- function(cond) {
[17:39:23.143]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.143]                                 success = TRUE)
[17:39:23.143]                               parallel_sendData(master, data)
[17:39:23.143]                             }
[17:39:23.143]                             return(sendCondition)
[17:39:23.143]                           }
[17:39:23.143]                         }
[17:39:23.143]                         frame <- frame + 1L
[17:39:23.143]                         envir <- sys.frame(frame)
[17:39:23.143]                       }
[17:39:23.143]                     }
[17:39:23.143]                     sendCondition <<- function(cond) NULL
[17:39:23.143]                   }
[17:39:23.143]                 })
[17:39:23.143]                 withCallingHandlers({
[17:39:23.143]                   {
[17:39:23.143]                     do.call(function(...) {
[17:39:23.143]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.143]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.143]                         ...future.globals.maxSize)) {
[17:39:23.143]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.143]                         on.exit(options(oopts), add = TRUE)
[17:39:23.143]                       }
[17:39:23.143]                       {
[17:39:23.143]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.143]                           FUN = function(jj) {
[17:39:23.143]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.143]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.143]                           })
[17:39:23.143]                       }
[17:39:23.143]                     }, args = future.call.arguments)
[17:39:23.143]                   }
[17:39:23.143]                 }, immediateCondition = function(cond) {
[17:39:23.143]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.143]                   sendCondition(cond)
[17:39:23.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.143]                   {
[17:39:23.143]                     inherits <- base::inherits
[17:39:23.143]                     invokeRestart <- base::invokeRestart
[17:39:23.143]                     is.null <- base::is.null
[17:39:23.143]                     muffled <- FALSE
[17:39:23.143]                     if (inherits(cond, "message")) {
[17:39:23.143]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.143]                       if (muffled) 
[17:39:23.143]                         invokeRestart("muffleMessage")
[17:39:23.143]                     }
[17:39:23.143]                     else if (inherits(cond, "warning")) {
[17:39:23.143]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.143]                       if (muffled) 
[17:39:23.143]                         invokeRestart("muffleWarning")
[17:39:23.143]                     }
[17:39:23.143]                     else if (inherits(cond, "condition")) {
[17:39:23.143]                       if (!is.null(pattern)) {
[17:39:23.143]                         computeRestarts <- base::computeRestarts
[17:39:23.143]                         grepl <- base::grepl
[17:39:23.143]                         restarts <- computeRestarts(cond)
[17:39:23.143]                         for (restart in restarts) {
[17:39:23.143]                           name <- restart$name
[17:39:23.143]                           if (is.null(name)) 
[17:39:23.143]                             next
[17:39:23.143]                           if (!grepl(pattern, name)) 
[17:39:23.143]                             next
[17:39:23.143]                           invokeRestart(restart)
[17:39:23.143]                           muffled <- TRUE
[17:39:23.143]                           break
[17:39:23.143]                         }
[17:39:23.143]                       }
[17:39:23.143]                     }
[17:39:23.143]                     invisible(muffled)
[17:39:23.143]                   }
[17:39:23.143]                   muffleCondition(cond)
[17:39:23.143]                 })
[17:39:23.143]             }))
[17:39:23.143]             future::FutureResult(value = ...future.value$value, 
[17:39:23.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.143]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.143]                     ...future.globalenv.names))
[17:39:23.143]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.143]         }, condition = base::local({
[17:39:23.143]             c <- base::c
[17:39:23.143]             inherits <- base::inherits
[17:39:23.143]             invokeRestart <- base::invokeRestart
[17:39:23.143]             length <- base::length
[17:39:23.143]             list <- base::list
[17:39:23.143]             seq.int <- base::seq.int
[17:39:23.143]             signalCondition <- base::signalCondition
[17:39:23.143]             sys.calls <- base::sys.calls
[17:39:23.143]             `[[` <- base::`[[`
[17:39:23.143]             `+` <- base::`+`
[17:39:23.143]             `<<-` <- base::`<<-`
[17:39:23.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.143]                   3L)]
[17:39:23.143]             }
[17:39:23.143]             function(cond) {
[17:39:23.143]                 is_error <- inherits(cond, "error")
[17:39:23.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.143]                   NULL)
[17:39:23.143]                 if (is_error) {
[17:39:23.143]                   sessionInformation <- function() {
[17:39:23.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.143]                       search = base::search(), system = base::Sys.info())
[17:39:23.143]                   }
[17:39:23.143]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.143]                     cond$call), session = sessionInformation(), 
[17:39:23.143]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.143]                   signalCondition(cond)
[17:39:23.143]                 }
[17:39:23.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.143]                 "immediateCondition"))) {
[17:39:23.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.143]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.143]                   if (TRUE && !signal) {
[17:39:23.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.143]                     {
[17:39:23.143]                       inherits <- base::inherits
[17:39:23.143]                       invokeRestart <- base::invokeRestart
[17:39:23.143]                       is.null <- base::is.null
[17:39:23.143]                       muffled <- FALSE
[17:39:23.143]                       if (inherits(cond, "message")) {
[17:39:23.143]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.143]                         if (muffled) 
[17:39:23.143]                           invokeRestart("muffleMessage")
[17:39:23.143]                       }
[17:39:23.143]                       else if (inherits(cond, "warning")) {
[17:39:23.143]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.143]                         if (muffled) 
[17:39:23.143]                           invokeRestart("muffleWarning")
[17:39:23.143]                       }
[17:39:23.143]                       else if (inherits(cond, "condition")) {
[17:39:23.143]                         if (!is.null(pattern)) {
[17:39:23.143]                           computeRestarts <- base::computeRestarts
[17:39:23.143]                           grepl <- base::grepl
[17:39:23.143]                           restarts <- computeRestarts(cond)
[17:39:23.143]                           for (restart in restarts) {
[17:39:23.143]                             name <- restart$name
[17:39:23.143]                             if (is.null(name)) 
[17:39:23.143]                               next
[17:39:23.143]                             if (!grepl(pattern, name)) 
[17:39:23.143]                               next
[17:39:23.143]                             invokeRestart(restart)
[17:39:23.143]                             muffled <- TRUE
[17:39:23.143]                             break
[17:39:23.143]                           }
[17:39:23.143]                         }
[17:39:23.143]                       }
[17:39:23.143]                       invisible(muffled)
[17:39:23.143]                     }
[17:39:23.143]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.143]                   }
[17:39:23.143]                 }
[17:39:23.143]                 else {
[17:39:23.143]                   if (TRUE) {
[17:39:23.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.143]                     {
[17:39:23.143]                       inherits <- base::inherits
[17:39:23.143]                       invokeRestart <- base::invokeRestart
[17:39:23.143]                       is.null <- base::is.null
[17:39:23.143]                       muffled <- FALSE
[17:39:23.143]                       if (inherits(cond, "message")) {
[17:39:23.143]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.143]                         if (muffled) 
[17:39:23.143]                           invokeRestart("muffleMessage")
[17:39:23.143]                       }
[17:39:23.143]                       else if (inherits(cond, "warning")) {
[17:39:23.143]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.143]                         if (muffled) 
[17:39:23.143]                           invokeRestart("muffleWarning")
[17:39:23.143]                       }
[17:39:23.143]                       else if (inherits(cond, "condition")) {
[17:39:23.143]                         if (!is.null(pattern)) {
[17:39:23.143]                           computeRestarts <- base::computeRestarts
[17:39:23.143]                           grepl <- base::grepl
[17:39:23.143]                           restarts <- computeRestarts(cond)
[17:39:23.143]                           for (restart in restarts) {
[17:39:23.143]                             name <- restart$name
[17:39:23.143]                             if (is.null(name)) 
[17:39:23.143]                               next
[17:39:23.143]                             if (!grepl(pattern, name)) 
[17:39:23.143]                               next
[17:39:23.143]                             invokeRestart(restart)
[17:39:23.143]                             muffled <- TRUE
[17:39:23.143]                             break
[17:39:23.143]                           }
[17:39:23.143]                         }
[17:39:23.143]                       }
[17:39:23.143]                       invisible(muffled)
[17:39:23.143]                     }
[17:39:23.143]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.143]                   }
[17:39:23.143]                 }
[17:39:23.143]             }
[17:39:23.143]         }))
[17:39:23.143]     }, error = function(ex) {
[17:39:23.143]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.143]                 ...future.rng), started = ...future.startTime, 
[17:39:23.143]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.143]             version = "1.8"), class = "FutureResult")
[17:39:23.143]     }, finally = {
[17:39:23.143]         if (!identical(...future.workdir, getwd())) 
[17:39:23.143]             setwd(...future.workdir)
[17:39:23.143]         {
[17:39:23.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.143]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.143]             }
[17:39:23.143]             base::options(...future.oldOptions)
[17:39:23.143]             if (.Platform$OS.type == "windows") {
[17:39:23.143]                 old_names <- names(...future.oldEnvVars)
[17:39:23.143]                 envs <- base::Sys.getenv()
[17:39:23.143]                 names <- names(envs)
[17:39:23.143]                 common <- intersect(names, old_names)
[17:39:23.143]                 added <- setdiff(names, old_names)
[17:39:23.143]                 removed <- setdiff(old_names, names)
[17:39:23.143]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.143]                   envs[common]]
[17:39:23.143]                 NAMES <- toupper(changed)
[17:39:23.143]                 args <- list()
[17:39:23.143]                 for (kk in seq_along(NAMES)) {
[17:39:23.143]                   name <- changed[[kk]]
[17:39:23.143]                   NAME <- NAMES[[kk]]
[17:39:23.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.143]                     next
[17:39:23.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.143]                 }
[17:39:23.143]                 NAMES <- toupper(added)
[17:39:23.143]                 for (kk in seq_along(NAMES)) {
[17:39:23.143]                   name <- added[[kk]]
[17:39:23.143]                   NAME <- NAMES[[kk]]
[17:39:23.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.143]                     next
[17:39:23.143]                   args[[name]] <- ""
[17:39:23.143]                 }
[17:39:23.143]                 NAMES <- toupper(removed)
[17:39:23.143]                 for (kk in seq_along(NAMES)) {
[17:39:23.143]                   name <- removed[[kk]]
[17:39:23.143]                   NAME <- NAMES[[kk]]
[17:39:23.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.143]                     next
[17:39:23.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.143]                 }
[17:39:23.143]                 if (length(args) > 0) 
[17:39:23.143]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.143]             }
[17:39:23.143]             else {
[17:39:23.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.143]             }
[17:39:23.143]             {
[17:39:23.143]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.143]                   0L) {
[17:39:23.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.143]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.143]                   base::options(opts)
[17:39:23.143]                 }
[17:39:23.143]                 {
[17:39:23.143]                   {
[17:39:23.143]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.143]                     NULL
[17:39:23.143]                   }
[17:39:23.143]                   options(future.plan = NULL)
[17:39:23.143]                   if (is.na(NA_character_)) 
[17:39:23.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.143]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.143]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.143]                     envir = parent.frame()) 
[17:39:23.143]                   {
[17:39:23.143]                     if (is.function(workers)) 
[17:39:23.143]                       workers <- workers()
[17:39:23.143]                     workers <- structure(as.integer(workers), 
[17:39:23.143]                       class = class(workers))
[17:39:23.143]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.143]                       workers >= 1)
[17:39:23.143]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.143]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.143]                     }
[17:39:23.143]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.143]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.143]                       envir = envir)
[17:39:23.143]                     if (!future$lazy) 
[17:39:23.143]                       future <- run(future)
[17:39:23.143]                     invisible(future)
[17:39:23.143]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.143]                 }
[17:39:23.143]             }
[17:39:23.143]         }
[17:39:23.143]     })
[17:39:23.143]     if (TRUE) {
[17:39:23.143]         base::sink(type = "output", split = FALSE)
[17:39:23.143]         if (TRUE) {
[17:39:23.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.143]         }
[17:39:23.143]         else {
[17:39:23.143]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.143]         }
[17:39:23.143]         base::close(...future.stdout)
[17:39:23.143]         ...future.stdout <- NULL
[17:39:23.143]     }
[17:39:23.143]     ...future.result$conditions <- ...future.conditions
[17:39:23.143]     ...future.result$finished <- base::Sys.time()
[17:39:23.143]     ...future.result
[17:39:23.143] }
[17:39:23.146] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[17:39:23.146] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:23.146] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.146] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:39:23.147] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:39:23.147] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:39:23.147] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:39:23.147] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:23.148] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.148] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:23.148] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.148] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[17:39:23.149] MultisessionFuture started
[17:39:23.149] - Launch lazy future ... done
[17:39:23.149] run() for ‘MultisessionFuture’ ... done
[17:39:23.149] Created future:
[17:39:23.149] MultisessionFuture:
[17:39:23.149] Label: ‘future_apply-2’
[17:39:23.149] Expression:
[17:39:23.149] {
[17:39:23.149]     do.call(function(...) {
[17:39:23.149]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.149]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.149]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.149]             on.exit(options(oopts), add = TRUE)
[17:39:23.149]         }
[17:39:23.149]         {
[17:39:23.149]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.149]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.149]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.149]             })
[17:39:23.149]         }
[17:39:23.149]     }, args = future.call.arguments)
[17:39:23.149] }
[17:39:23.149] Lazy evaluation: FALSE
[17:39:23.149] Asynchronous evaluation: TRUE
[17:39:23.149] Local evaluation: TRUE
[17:39:23.149] Environment: R_GlobalEnv
[17:39:23.149] Capture standard output: TRUE
[17:39:23.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.149] Globals: 5 objects totaling 1.30 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.149] Packages: 1 packages (‘stats’)
[17:39:23.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.149] Resolved: FALSE
[17:39:23.149] Value: <not collected>
[17:39:23.149] Conditions captured: <none>
[17:39:23.149] Early signaling: FALSE
[17:39:23.149] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.149] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.161] Chunk #2 of 2 ... DONE
[17:39:23.161] Launching 2 futures (chunks) ... DONE
[17:39:23.161] Resolving 2 futures (chunks) ...
[17:39:23.161] resolve() on list ...
[17:39:23.161]  recursive: 0
[17:39:23.161]  length: 2
[17:39:23.162] 
[17:39:23.162] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.163] - Validating connection of MultisessionFuture
[17:39:23.163] - received message: FutureResult
[17:39:23.163] - Received FutureResult
[17:39:23.163] - Erased future from FutureRegistry
[17:39:23.163] result() for ClusterFuture ...
[17:39:23.163] - result already collected: FutureResult
[17:39:23.163] result() for ClusterFuture ... done
[17:39:23.163] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.163] Future #1
[17:39:23.164] result() for ClusterFuture ...
[17:39:23.164] - result already collected: FutureResult
[17:39:23.164] result() for ClusterFuture ... done
[17:39:23.164] result() for ClusterFuture ...
[17:39:23.164] - result already collected: FutureResult
[17:39:23.164] result() for ClusterFuture ... done
[17:39:23.164] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:23.164] - nx: 2
[17:39:23.164] - relay: TRUE
[17:39:23.164] - stdout: TRUE
[17:39:23.164] - signal: TRUE
[17:39:23.165] - resignal: FALSE
[17:39:23.165] - force: TRUE
[17:39:23.165] - relayed: [n=2] FALSE, FALSE
[17:39:23.165] - queued futures: [n=2] FALSE, FALSE
[17:39:23.165]  - until=1
[17:39:23.165]  - relaying element #1
[17:39:23.165] result() for ClusterFuture ...
[17:39:23.165] - result already collected: FutureResult
[17:39:23.165] result() for ClusterFuture ... done
[17:39:23.165] result() for ClusterFuture ...
[17:39:23.165] - result already collected: FutureResult
[17:39:23.165] result() for ClusterFuture ... done
[17:39:23.166] result() for ClusterFuture ...
[17:39:23.166] - result already collected: FutureResult
[17:39:23.166] result() for ClusterFuture ... done
[17:39:23.166] result() for ClusterFuture ...
[17:39:23.166] - result already collected: FutureResult
[17:39:23.166] result() for ClusterFuture ... done
[17:39:23.166] - relayed: [n=2] TRUE, FALSE
[17:39:23.166] - queued futures: [n=2] TRUE, FALSE
[17:39:23.166] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:23.166]  length: 1 (resolved future 1)
[17:39:23.208] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.208] - Validating connection of MultisessionFuture
[17:39:23.208] - received message: FutureResult
[17:39:23.208] - Received FutureResult
[17:39:23.209] - Erased future from FutureRegistry
[17:39:23.209] result() for ClusterFuture ...
[17:39:23.209] - result already collected: FutureResult
[17:39:23.209] result() for ClusterFuture ... done
[17:39:23.209] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.209] Future #2
[17:39:23.209] result() for ClusterFuture ...
[17:39:23.209] - result already collected: FutureResult
[17:39:23.209] result() for ClusterFuture ... done
[17:39:23.209] result() for ClusterFuture ...
[17:39:23.210] - result already collected: FutureResult
[17:39:23.210] result() for ClusterFuture ... done
[17:39:23.210] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:23.210] - nx: 2
[17:39:23.210] - relay: TRUE
[17:39:23.210] - stdout: TRUE
[17:39:23.210] - signal: TRUE
[17:39:23.210] - resignal: FALSE
[17:39:23.210] - force: TRUE
[17:39:23.210] - relayed: [n=2] TRUE, FALSE
[17:39:23.210] - queued futures: [n=2] TRUE, FALSE
[17:39:23.210]  - until=2
[17:39:23.211]  - relaying element #2
[17:39:23.211] result() for ClusterFuture ...
[17:39:23.211] - result already collected: FutureResult
[17:39:23.211] result() for ClusterFuture ... done
[17:39:23.211] result() for ClusterFuture ...
[17:39:23.211] - result already collected: FutureResult
[17:39:23.211] result() for ClusterFuture ... done
[17:39:23.211] result() for ClusterFuture ...
[17:39:23.211] - result already collected: FutureResult
[17:39:23.211] result() for ClusterFuture ... done
[17:39:23.212] result() for ClusterFuture ...
[17:39:23.212] - result already collected: FutureResult
[17:39:23.212] result() for ClusterFuture ... done
[17:39:23.212] - relayed: [n=2] TRUE, TRUE
[17:39:23.212] - queued futures: [n=2] TRUE, TRUE
[17:39:23.212] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:23.212]  length: 0 (resolved future 2)
[17:39:23.212] Relaying remaining futures
[17:39:23.212] signalConditionsASAP(NULL, pos=0) ...
[17:39:23.212] - nx: 2
[17:39:23.212] - relay: TRUE
[17:39:23.212] - stdout: TRUE
[17:39:23.213] - signal: TRUE
[17:39:23.213] - resignal: FALSE
[17:39:23.213] - force: TRUE
[17:39:23.213] - relayed: [n=2] TRUE, TRUE
[17:39:23.213] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:23.213] - relayed: [n=2] TRUE, TRUE
[17:39:23.213] - queued futures: [n=2] TRUE, TRUE
[17:39:23.213] signalConditionsASAP(NULL, pos=0) ... done
[17:39:23.213] resolve() on list ... DONE
[17:39:23.213] result() for ClusterFuture ...
[17:39:23.213] - result already collected: FutureResult
[17:39:23.214] result() for ClusterFuture ... done
[17:39:23.214] result() for ClusterFuture ...
[17:39:23.214] - result already collected: FutureResult
[17:39:23.214] result() for ClusterFuture ... done
[17:39:23.214] result() for ClusterFuture ...
[17:39:23.214] - result already collected: FutureResult
[17:39:23.214] result() for ClusterFuture ... done
[17:39:23.214] result() for ClusterFuture ...
[17:39:23.214] - result already collected: FutureResult
[17:39:23.214] result() for ClusterFuture ... done
[17:39:23.214]  - Number of value chunks collected: 2
[17:39:23.215] Resolving 2 futures (chunks) ... DONE
[17:39:23.215] Reducing values from 2 chunks ...
[17:39:23.215]  - Number of values collected after concatenation: 2
[17:39:23.215]  - Number of values expected: 2
[17:39:23.215] Reducing values from 2 chunks ... DONE
[17:39:23.215] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:39:23.216] getGlobalsAndPackagesXApply() ...
[17:39:23.216]  - future.globals: TRUE
[17:39:23.216] getGlobalsAndPackages() ...
[17:39:23.216] Searching for globals...
[17:39:23.217] - globals found: [1] ‘FUN’
[17:39:23.217] Searching for globals ... DONE
[17:39:23.217] Resolving globals: FALSE
[17:39:23.217] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:23.218] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:23.218] - globals: [1] ‘FUN’
[17:39:23.218] 
[17:39:23.218] getGlobalsAndPackages() ... DONE
[17:39:23.218]  - globals found/used: [n=1] ‘FUN’
[17:39:23.218]  - needed namespaces: [n=0] 
[17:39:23.218] Finding globals ... DONE
[17:39:23.218]  - use_args: TRUE
[17:39:23.219]  - Getting '...' globals ...
[17:39:23.219] resolve() on list ...
[17:39:23.219]  recursive: 0
[17:39:23.219]  length: 1
[17:39:23.219]  elements: ‘...’
[17:39:23.219]  length: 0 (resolved future 1)
[17:39:23.219] resolve() on list ... DONE
[17:39:23.219]    - '...' content: [n=0] 
[17:39:23.220] List of 1
[17:39:23.220]  $ ...: list()
[17:39:23.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.220]  - attr(*, "where")=List of 1
[17:39:23.220]   ..$ ...:<environment: 0x55c798b8acd0> 
[17:39:23.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.220]  - attr(*, "resolved")= logi TRUE
[17:39:23.220]  - attr(*, "total_size")= num NA
[17:39:23.222]  - Getting '...' globals ... DONE
[17:39:23.222] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:23.222] List of 2
[17:39:23.222]  $ ...future.FUN:function (x)  
[17:39:23.222]  $ ...          : list()
[17:39:23.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.222]  - attr(*, "where")=List of 2
[17:39:23.222]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:23.222]   ..$ ...          :<environment: 0x55c798b8acd0> 
[17:39:23.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.222]  - attr(*, "resolved")= logi FALSE
[17:39:23.222]  - attr(*, "total_size")= num 848
[17:39:23.225] Packages to be attached in all futures: [n=0] 
[17:39:23.225] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.230] future_lapply() ...
[17:39:23.234] Number of chunks: 2
[17:39:23.234] getGlobalsAndPackagesXApply() ...
[17:39:23.234]  - future.globals: <name-value list> with names ‘list()’
[17:39:23.234]  - use_args: TRUE
[17:39:23.234] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:23.235] List of 2
[17:39:23.235]  $ ...          : list()
[17:39:23.235]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.235]  $ ...future.FUN:function (x)  
[17:39:23.235]  - attr(*, "where")=List of 2
[17:39:23.235]   ..$ ...          :<environment: 0x55c798b8acd0> 
[17:39:23.235]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:23.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.235]  - attr(*, "resolved")= logi FALSE
[17:39:23.235]  - attr(*, "total_size")= num NA
[17:39:23.238] Packages to be attached in all futures: [n=0] 
[17:39:23.238] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.238] Number of futures (= number of chunks): 2
[17:39:23.238] Launching 2 futures (chunks) ...
[17:39:23.238] Chunk #1 of 2 ...
[17:39:23.238]  - seeds: <none>
[17:39:23.238] getGlobalsAndPackages() ...
[17:39:23.239] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.239] Resolving globals: FALSE
[17:39:23.239] Tweak future expression to call with '...' arguments ...
[17:39:23.239] {
[17:39:23.239]     do.call(function(...) {
[17:39:23.239]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.239]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.239]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.239]             on.exit(options(oopts), add = TRUE)
[17:39:23.239]         }
[17:39:23.239]         {
[17:39:23.239]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.239]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.239]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.239]             })
[17:39:23.239]         }
[17:39:23.239]     }, args = future.call.arguments)
[17:39:23.239] }
[17:39:23.239] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.240] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.240] 
[17:39:23.240] getGlobalsAndPackages() ... DONE
[17:39:23.240] run() for ‘Future’ ...
[17:39:23.240] - state: ‘created’
[17:39:23.240] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.255] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.255] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.255]   - Field: ‘node’
[17:39:23.255]   - Field: ‘label’
[17:39:23.255]   - Field: ‘local’
[17:39:23.255]   - Field: ‘owner’
[17:39:23.256]   - Field: ‘envir’
[17:39:23.256]   - Field: ‘workers’
[17:39:23.256]   - Field: ‘packages’
[17:39:23.256]   - Field: ‘gc’
[17:39:23.256]   - Field: ‘conditions’
[17:39:23.256]   - Field: ‘persistent’
[17:39:23.256]   - Field: ‘expr’
[17:39:23.256]   - Field: ‘uuid’
[17:39:23.256]   - Field: ‘seed’
[17:39:23.256]   - Field: ‘version’
[17:39:23.256]   - Field: ‘result’
[17:39:23.257]   - Field: ‘asynchronous’
[17:39:23.257]   - Field: ‘calls’
[17:39:23.257]   - Field: ‘globals’
[17:39:23.257]   - Field: ‘stdout’
[17:39:23.257]   - Field: ‘earlySignal’
[17:39:23.257]   - Field: ‘lazy’
[17:39:23.257]   - Field: ‘state’
[17:39:23.257] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.257] - Launch lazy future ...
[17:39:23.258] Packages needed by the future expression (n = 0): <none>
[17:39:23.258] Packages needed by future strategies (n = 0): <none>
[17:39:23.258] {
[17:39:23.258]     {
[17:39:23.258]         {
[17:39:23.258]             ...future.startTime <- base::Sys.time()
[17:39:23.258]             {
[17:39:23.258]                 {
[17:39:23.258]                   {
[17:39:23.258]                     {
[17:39:23.258]                       base::local({
[17:39:23.258]                         has_future <- base::requireNamespace("future", 
[17:39:23.258]                           quietly = TRUE)
[17:39:23.258]                         if (has_future) {
[17:39:23.258]                           ns <- base::getNamespace("future")
[17:39:23.258]                           version <- ns[[".package"]][["version"]]
[17:39:23.258]                           if (is.null(version)) 
[17:39:23.258]                             version <- utils::packageVersion("future")
[17:39:23.258]                         }
[17:39:23.258]                         else {
[17:39:23.258]                           version <- NULL
[17:39:23.258]                         }
[17:39:23.258]                         if (!has_future || version < "1.8.0") {
[17:39:23.258]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.258]                             "", base::R.version$version.string), 
[17:39:23.258]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.258]                               "release", "version")], collapse = " "), 
[17:39:23.258]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.258]                             info)
[17:39:23.258]                           info <- base::paste(info, collapse = "; ")
[17:39:23.258]                           if (!has_future) {
[17:39:23.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.258]                               info)
[17:39:23.258]                           }
[17:39:23.258]                           else {
[17:39:23.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.258]                               info, version)
[17:39:23.258]                           }
[17:39:23.258]                           base::stop(msg)
[17:39:23.258]                         }
[17:39:23.258]                       })
[17:39:23.258]                     }
[17:39:23.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.258]                     base::options(mc.cores = 1L)
[17:39:23.258]                   }
[17:39:23.258]                   options(future.plan = NULL)
[17:39:23.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.258]                 }
[17:39:23.258]                 ...future.workdir <- getwd()
[17:39:23.258]             }
[17:39:23.258]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.258]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.258]         }
[17:39:23.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.258]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.258]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.258]             base::names(...future.oldOptions))
[17:39:23.258]     }
[17:39:23.258]     if (FALSE) {
[17:39:23.258]     }
[17:39:23.258]     else {
[17:39:23.258]         if (TRUE) {
[17:39:23.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.258]                 open = "w")
[17:39:23.258]         }
[17:39:23.258]         else {
[17:39:23.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.258]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.258]         }
[17:39:23.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.258]             base::sink(type = "output", split = FALSE)
[17:39:23.258]             base::close(...future.stdout)
[17:39:23.258]         }, add = TRUE)
[17:39:23.258]     }
[17:39:23.258]     ...future.frame <- base::sys.nframe()
[17:39:23.258]     ...future.conditions <- base::list()
[17:39:23.258]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.258]     if (FALSE) {
[17:39:23.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.258]     }
[17:39:23.258]     ...future.result <- base::tryCatch({
[17:39:23.258]         base::withCallingHandlers({
[17:39:23.258]             ...future.value <- base::withVisible(base::local({
[17:39:23.258]                 ...future.makeSendCondition <- local({
[17:39:23.258]                   sendCondition <- NULL
[17:39:23.258]                   function(frame = 1L) {
[17:39:23.258]                     if (is.function(sendCondition)) 
[17:39:23.258]                       return(sendCondition)
[17:39:23.258]                     ns <- getNamespace("parallel")
[17:39:23.258]                     if (exists("sendData", mode = "function", 
[17:39:23.258]                       envir = ns)) {
[17:39:23.258]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.258]                         envir = ns)
[17:39:23.258]                       envir <- sys.frame(frame)
[17:39:23.258]                       master <- NULL
[17:39:23.258]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.258]                         !identical(envir, emptyenv())) {
[17:39:23.258]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.258]                           inherits = FALSE)) {
[17:39:23.258]                           master <- get("master", mode = "list", 
[17:39:23.258]                             envir = envir, inherits = FALSE)
[17:39:23.258]                           if (inherits(master, c("SOCKnode", 
[17:39:23.258]                             "SOCK0node"))) {
[17:39:23.258]                             sendCondition <<- function(cond) {
[17:39:23.258]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.258]                                 success = TRUE)
[17:39:23.258]                               parallel_sendData(master, data)
[17:39:23.258]                             }
[17:39:23.258]                             return(sendCondition)
[17:39:23.258]                           }
[17:39:23.258]                         }
[17:39:23.258]                         frame <- frame + 1L
[17:39:23.258]                         envir <- sys.frame(frame)
[17:39:23.258]                       }
[17:39:23.258]                     }
[17:39:23.258]                     sendCondition <<- function(cond) NULL
[17:39:23.258]                   }
[17:39:23.258]                 })
[17:39:23.258]                 withCallingHandlers({
[17:39:23.258]                   {
[17:39:23.258]                     do.call(function(...) {
[17:39:23.258]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.258]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.258]                         ...future.globals.maxSize)) {
[17:39:23.258]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.258]                         on.exit(options(oopts), add = TRUE)
[17:39:23.258]                       }
[17:39:23.258]                       {
[17:39:23.258]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.258]                           FUN = function(jj) {
[17:39:23.258]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.258]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.258]                           })
[17:39:23.258]                       }
[17:39:23.258]                     }, args = future.call.arguments)
[17:39:23.258]                   }
[17:39:23.258]                 }, immediateCondition = function(cond) {
[17:39:23.258]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.258]                   sendCondition(cond)
[17:39:23.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.258]                   {
[17:39:23.258]                     inherits <- base::inherits
[17:39:23.258]                     invokeRestart <- base::invokeRestart
[17:39:23.258]                     is.null <- base::is.null
[17:39:23.258]                     muffled <- FALSE
[17:39:23.258]                     if (inherits(cond, "message")) {
[17:39:23.258]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.258]                       if (muffled) 
[17:39:23.258]                         invokeRestart("muffleMessage")
[17:39:23.258]                     }
[17:39:23.258]                     else if (inherits(cond, "warning")) {
[17:39:23.258]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.258]                       if (muffled) 
[17:39:23.258]                         invokeRestart("muffleWarning")
[17:39:23.258]                     }
[17:39:23.258]                     else if (inherits(cond, "condition")) {
[17:39:23.258]                       if (!is.null(pattern)) {
[17:39:23.258]                         computeRestarts <- base::computeRestarts
[17:39:23.258]                         grepl <- base::grepl
[17:39:23.258]                         restarts <- computeRestarts(cond)
[17:39:23.258]                         for (restart in restarts) {
[17:39:23.258]                           name <- restart$name
[17:39:23.258]                           if (is.null(name)) 
[17:39:23.258]                             next
[17:39:23.258]                           if (!grepl(pattern, name)) 
[17:39:23.258]                             next
[17:39:23.258]                           invokeRestart(restart)
[17:39:23.258]                           muffled <- TRUE
[17:39:23.258]                           break
[17:39:23.258]                         }
[17:39:23.258]                       }
[17:39:23.258]                     }
[17:39:23.258]                     invisible(muffled)
[17:39:23.258]                   }
[17:39:23.258]                   muffleCondition(cond)
[17:39:23.258]                 })
[17:39:23.258]             }))
[17:39:23.258]             future::FutureResult(value = ...future.value$value, 
[17:39:23.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.258]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.258]                     ...future.globalenv.names))
[17:39:23.258]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.258]         }, condition = base::local({
[17:39:23.258]             c <- base::c
[17:39:23.258]             inherits <- base::inherits
[17:39:23.258]             invokeRestart <- base::invokeRestart
[17:39:23.258]             length <- base::length
[17:39:23.258]             list <- base::list
[17:39:23.258]             seq.int <- base::seq.int
[17:39:23.258]             signalCondition <- base::signalCondition
[17:39:23.258]             sys.calls <- base::sys.calls
[17:39:23.258]             `[[` <- base::`[[`
[17:39:23.258]             `+` <- base::`+`
[17:39:23.258]             `<<-` <- base::`<<-`
[17:39:23.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.258]                   3L)]
[17:39:23.258]             }
[17:39:23.258]             function(cond) {
[17:39:23.258]                 is_error <- inherits(cond, "error")
[17:39:23.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.258]                   NULL)
[17:39:23.258]                 if (is_error) {
[17:39:23.258]                   sessionInformation <- function() {
[17:39:23.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.258]                       search = base::search(), system = base::Sys.info())
[17:39:23.258]                   }
[17:39:23.258]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.258]                     cond$call), session = sessionInformation(), 
[17:39:23.258]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.258]                   signalCondition(cond)
[17:39:23.258]                 }
[17:39:23.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.258]                 "immediateCondition"))) {
[17:39:23.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.258]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.258]                   if (TRUE && !signal) {
[17:39:23.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.258]                     {
[17:39:23.258]                       inherits <- base::inherits
[17:39:23.258]                       invokeRestart <- base::invokeRestart
[17:39:23.258]                       is.null <- base::is.null
[17:39:23.258]                       muffled <- FALSE
[17:39:23.258]                       if (inherits(cond, "message")) {
[17:39:23.258]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.258]                         if (muffled) 
[17:39:23.258]                           invokeRestart("muffleMessage")
[17:39:23.258]                       }
[17:39:23.258]                       else if (inherits(cond, "warning")) {
[17:39:23.258]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.258]                         if (muffled) 
[17:39:23.258]                           invokeRestart("muffleWarning")
[17:39:23.258]                       }
[17:39:23.258]                       else if (inherits(cond, "condition")) {
[17:39:23.258]                         if (!is.null(pattern)) {
[17:39:23.258]                           computeRestarts <- base::computeRestarts
[17:39:23.258]                           grepl <- base::grepl
[17:39:23.258]                           restarts <- computeRestarts(cond)
[17:39:23.258]                           for (restart in restarts) {
[17:39:23.258]                             name <- restart$name
[17:39:23.258]                             if (is.null(name)) 
[17:39:23.258]                               next
[17:39:23.258]                             if (!grepl(pattern, name)) 
[17:39:23.258]                               next
[17:39:23.258]                             invokeRestart(restart)
[17:39:23.258]                             muffled <- TRUE
[17:39:23.258]                             break
[17:39:23.258]                           }
[17:39:23.258]                         }
[17:39:23.258]                       }
[17:39:23.258]                       invisible(muffled)
[17:39:23.258]                     }
[17:39:23.258]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.258]                   }
[17:39:23.258]                 }
[17:39:23.258]                 else {
[17:39:23.258]                   if (TRUE) {
[17:39:23.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.258]                     {
[17:39:23.258]                       inherits <- base::inherits
[17:39:23.258]                       invokeRestart <- base::invokeRestart
[17:39:23.258]                       is.null <- base::is.null
[17:39:23.258]                       muffled <- FALSE
[17:39:23.258]                       if (inherits(cond, "message")) {
[17:39:23.258]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.258]                         if (muffled) 
[17:39:23.258]                           invokeRestart("muffleMessage")
[17:39:23.258]                       }
[17:39:23.258]                       else if (inherits(cond, "warning")) {
[17:39:23.258]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.258]                         if (muffled) 
[17:39:23.258]                           invokeRestart("muffleWarning")
[17:39:23.258]                       }
[17:39:23.258]                       else if (inherits(cond, "condition")) {
[17:39:23.258]                         if (!is.null(pattern)) {
[17:39:23.258]                           computeRestarts <- base::computeRestarts
[17:39:23.258]                           grepl <- base::grepl
[17:39:23.258]                           restarts <- computeRestarts(cond)
[17:39:23.258]                           for (restart in restarts) {
[17:39:23.258]                             name <- restart$name
[17:39:23.258]                             if (is.null(name)) 
[17:39:23.258]                               next
[17:39:23.258]                             if (!grepl(pattern, name)) 
[17:39:23.258]                               next
[17:39:23.258]                             invokeRestart(restart)
[17:39:23.258]                             muffled <- TRUE
[17:39:23.258]                             break
[17:39:23.258]                           }
[17:39:23.258]                         }
[17:39:23.258]                       }
[17:39:23.258]                       invisible(muffled)
[17:39:23.258]                     }
[17:39:23.258]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.258]                   }
[17:39:23.258]                 }
[17:39:23.258]             }
[17:39:23.258]         }))
[17:39:23.258]     }, error = function(ex) {
[17:39:23.258]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.258]                 ...future.rng), started = ...future.startTime, 
[17:39:23.258]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.258]             version = "1.8"), class = "FutureResult")
[17:39:23.258]     }, finally = {
[17:39:23.258]         if (!identical(...future.workdir, getwd())) 
[17:39:23.258]             setwd(...future.workdir)
[17:39:23.258]         {
[17:39:23.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.258]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.258]             }
[17:39:23.258]             base::options(...future.oldOptions)
[17:39:23.258]             if (.Platform$OS.type == "windows") {
[17:39:23.258]                 old_names <- names(...future.oldEnvVars)
[17:39:23.258]                 envs <- base::Sys.getenv()
[17:39:23.258]                 names <- names(envs)
[17:39:23.258]                 common <- intersect(names, old_names)
[17:39:23.258]                 added <- setdiff(names, old_names)
[17:39:23.258]                 removed <- setdiff(old_names, names)
[17:39:23.258]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.258]                   envs[common]]
[17:39:23.258]                 NAMES <- toupper(changed)
[17:39:23.258]                 args <- list()
[17:39:23.258]                 for (kk in seq_along(NAMES)) {
[17:39:23.258]                   name <- changed[[kk]]
[17:39:23.258]                   NAME <- NAMES[[kk]]
[17:39:23.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.258]                     next
[17:39:23.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.258]                 }
[17:39:23.258]                 NAMES <- toupper(added)
[17:39:23.258]                 for (kk in seq_along(NAMES)) {
[17:39:23.258]                   name <- added[[kk]]
[17:39:23.258]                   NAME <- NAMES[[kk]]
[17:39:23.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.258]                     next
[17:39:23.258]                   args[[name]] <- ""
[17:39:23.258]                 }
[17:39:23.258]                 NAMES <- toupper(removed)
[17:39:23.258]                 for (kk in seq_along(NAMES)) {
[17:39:23.258]                   name <- removed[[kk]]
[17:39:23.258]                   NAME <- NAMES[[kk]]
[17:39:23.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.258]                     next
[17:39:23.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.258]                 }
[17:39:23.258]                 if (length(args) > 0) 
[17:39:23.258]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.258]             }
[17:39:23.258]             else {
[17:39:23.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.258]             }
[17:39:23.258]             {
[17:39:23.258]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.258]                   0L) {
[17:39:23.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.258]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.258]                   base::options(opts)
[17:39:23.258]                 }
[17:39:23.258]                 {
[17:39:23.258]                   {
[17:39:23.258]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.258]                     NULL
[17:39:23.258]                   }
[17:39:23.258]                   options(future.plan = NULL)
[17:39:23.258]                   if (is.na(NA_character_)) 
[17:39:23.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.258]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.258]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.258]                     envir = parent.frame()) 
[17:39:23.258]                   {
[17:39:23.258]                     if (is.function(workers)) 
[17:39:23.258]                       workers <- workers()
[17:39:23.258]                     workers <- structure(as.integer(workers), 
[17:39:23.258]                       class = class(workers))
[17:39:23.258]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.258]                       workers >= 1)
[17:39:23.258]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.258]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.258]                     }
[17:39:23.258]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.258]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.258]                       envir = envir)
[17:39:23.258]                     if (!future$lazy) 
[17:39:23.258]                       future <- run(future)
[17:39:23.258]                     invisible(future)
[17:39:23.258]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.258]                 }
[17:39:23.258]             }
[17:39:23.258]         }
[17:39:23.258]     })
[17:39:23.258]     if (TRUE) {
[17:39:23.258]         base::sink(type = "output", split = FALSE)
[17:39:23.258]         if (TRUE) {
[17:39:23.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.258]         }
[17:39:23.258]         else {
[17:39:23.258]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.258]         }
[17:39:23.258]         base::close(...future.stdout)
[17:39:23.258]         ...future.stdout <- NULL
[17:39:23.258]     }
[17:39:23.258]     ...future.result$conditions <- ...future.conditions
[17:39:23.258]     ...future.result$finished <- base::Sys.time()
[17:39:23.258]     ...future.result
[17:39:23.258] }
[17:39:23.261] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[17:39:23.261] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:23.262] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.262] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:39:23.262] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:39:23.263] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:39:23.263] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:39:23.263] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:23.263] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.264] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:23.264] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.264] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[17:39:23.265] MultisessionFuture started
[17:39:23.265] - Launch lazy future ... done
[17:39:23.265] run() for ‘MultisessionFuture’ ... done
[17:39:23.265] Created future:
[17:39:23.265] MultisessionFuture:
[17:39:23.265] Label: ‘future_apply-1’
[17:39:23.265] Expression:
[17:39:23.265] {
[17:39:23.265]     do.call(function(...) {
[17:39:23.265]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.265]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.265]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.265]             on.exit(options(oopts), add = TRUE)
[17:39:23.265]         }
[17:39:23.265]         {
[17:39:23.265]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.265]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.265]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.265]             })
[17:39:23.265]         }
[17:39:23.265]     }, args = future.call.arguments)
[17:39:23.265] }
[17:39:23.265] Lazy evaluation: FALSE
[17:39:23.265] Asynchronous evaluation: TRUE
[17:39:23.265] Local evaluation: TRUE
[17:39:23.265] Environment: R_GlobalEnv
[17:39:23.265] Capture standard output: TRUE
[17:39:23.265] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.265] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.265] Packages: <none>
[17:39:23.265] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.265] Resolved: FALSE
[17:39:23.265] Value: <not collected>
[17:39:23.265] Conditions captured: <none>
[17:39:23.265] Early signaling: FALSE
[17:39:23.265] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.265] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.277] Chunk #1 of 2 ... DONE
[17:39:23.277] Chunk #2 of 2 ...
[17:39:23.277]  - seeds: <none>
[17:39:23.277] getGlobalsAndPackages() ...
[17:39:23.277] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.277] Resolving globals: FALSE
[17:39:23.278] Tweak future expression to call with '...' arguments ...
[17:39:23.278] {
[17:39:23.278]     do.call(function(...) {
[17:39:23.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.278]             on.exit(options(oopts), add = TRUE)
[17:39:23.278]         }
[17:39:23.278]         {
[17:39:23.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.278]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.278]             })
[17:39:23.278]         }
[17:39:23.278]     }, args = future.call.arguments)
[17:39:23.278] }
[17:39:23.278] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.278] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.279] 
[17:39:23.279] getGlobalsAndPackages() ... DONE
[17:39:23.279] run() for ‘Future’ ...
[17:39:23.279] - state: ‘created’
[17:39:23.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.294] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.295]   - Field: ‘node’
[17:39:23.295]   - Field: ‘label’
[17:39:23.295]   - Field: ‘local’
[17:39:23.295]   - Field: ‘owner’
[17:39:23.295]   - Field: ‘envir’
[17:39:23.295]   - Field: ‘workers’
[17:39:23.295]   - Field: ‘packages’
[17:39:23.295]   - Field: ‘gc’
[17:39:23.296]   - Field: ‘conditions’
[17:39:23.296]   - Field: ‘persistent’
[17:39:23.296]   - Field: ‘expr’
[17:39:23.296]   - Field: ‘uuid’
[17:39:23.296]   - Field: ‘seed’
[17:39:23.296]   - Field: ‘version’
[17:39:23.296]   - Field: ‘result’
[17:39:23.296]   - Field: ‘asynchronous’
[17:39:23.296]   - Field: ‘calls’
[17:39:23.296]   - Field: ‘globals’
[17:39:23.296]   - Field: ‘stdout’
[17:39:23.297]   - Field: ‘earlySignal’
[17:39:23.297]   - Field: ‘lazy’
[17:39:23.297]   - Field: ‘state’
[17:39:23.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.297] - Launch lazy future ...
[17:39:23.297] Packages needed by the future expression (n = 0): <none>
[17:39:23.297] Packages needed by future strategies (n = 0): <none>
[17:39:23.298] {
[17:39:23.298]     {
[17:39:23.298]         {
[17:39:23.298]             ...future.startTime <- base::Sys.time()
[17:39:23.298]             {
[17:39:23.298]                 {
[17:39:23.298]                   {
[17:39:23.298]                     {
[17:39:23.298]                       base::local({
[17:39:23.298]                         has_future <- base::requireNamespace("future", 
[17:39:23.298]                           quietly = TRUE)
[17:39:23.298]                         if (has_future) {
[17:39:23.298]                           ns <- base::getNamespace("future")
[17:39:23.298]                           version <- ns[[".package"]][["version"]]
[17:39:23.298]                           if (is.null(version)) 
[17:39:23.298]                             version <- utils::packageVersion("future")
[17:39:23.298]                         }
[17:39:23.298]                         else {
[17:39:23.298]                           version <- NULL
[17:39:23.298]                         }
[17:39:23.298]                         if (!has_future || version < "1.8.0") {
[17:39:23.298]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.298]                             "", base::R.version$version.string), 
[17:39:23.298]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.298]                               "release", "version")], collapse = " "), 
[17:39:23.298]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.298]                             info)
[17:39:23.298]                           info <- base::paste(info, collapse = "; ")
[17:39:23.298]                           if (!has_future) {
[17:39:23.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.298]                               info)
[17:39:23.298]                           }
[17:39:23.298]                           else {
[17:39:23.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.298]                               info, version)
[17:39:23.298]                           }
[17:39:23.298]                           base::stop(msg)
[17:39:23.298]                         }
[17:39:23.298]                       })
[17:39:23.298]                     }
[17:39:23.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.298]                     base::options(mc.cores = 1L)
[17:39:23.298]                   }
[17:39:23.298]                   options(future.plan = NULL)
[17:39:23.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.298]                 }
[17:39:23.298]                 ...future.workdir <- getwd()
[17:39:23.298]             }
[17:39:23.298]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.298]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.298]         }
[17:39:23.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.298]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.298]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.298]             base::names(...future.oldOptions))
[17:39:23.298]     }
[17:39:23.298]     if (FALSE) {
[17:39:23.298]     }
[17:39:23.298]     else {
[17:39:23.298]         if (TRUE) {
[17:39:23.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.298]                 open = "w")
[17:39:23.298]         }
[17:39:23.298]         else {
[17:39:23.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.298]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.298]         }
[17:39:23.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.298]             base::sink(type = "output", split = FALSE)
[17:39:23.298]             base::close(...future.stdout)
[17:39:23.298]         }, add = TRUE)
[17:39:23.298]     }
[17:39:23.298]     ...future.frame <- base::sys.nframe()
[17:39:23.298]     ...future.conditions <- base::list()
[17:39:23.298]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.298]     if (FALSE) {
[17:39:23.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.298]     }
[17:39:23.298]     ...future.result <- base::tryCatch({
[17:39:23.298]         base::withCallingHandlers({
[17:39:23.298]             ...future.value <- base::withVisible(base::local({
[17:39:23.298]                 ...future.makeSendCondition <- local({
[17:39:23.298]                   sendCondition <- NULL
[17:39:23.298]                   function(frame = 1L) {
[17:39:23.298]                     if (is.function(sendCondition)) 
[17:39:23.298]                       return(sendCondition)
[17:39:23.298]                     ns <- getNamespace("parallel")
[17:39:23.298]                     if (exists("sendData", mode = "function", 
[17:39:23.298]                       envir = ns)) {
[17:39:23.298]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.298]                         envir = ns)
[17:39:23.298]                       envir <- sys.frame(frame)
[17:39:23.298]                       master <- NULL
[17:39:23.298]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.298]                         !identical(envir, emptyenv())) {
[17:39:23.298]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.298]                           inherits = FALSE)) {
[17:39:23.298]                           master <- get("master", mode = "list", 
[17:39:23.298]                             envir = envir, inherits = FALSE)
[17:39:23.298]                           if (inherits(master, c("SOCKnode", 
[17:39:23.298]                             "SOCK0node"))) {
[17:39:23.298]                             sendCondition <<- function(cond) {
[17:39:23.298]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.298]                                 success = TRUE)
[17:39:23.298]                               parallel_sendData(master, data)
[17:39:23.298]                             }
[17:39:23.298]                             return(sendCondition)
[17:39:23.298]                           }
[17:39:23.298]                         }
[17:39:23.298]                         frame <- frame + 1L
[17:39:23.298]                         envir <- sys.frame(frame)
[17:39:23.298]                       }
[17:39:23.298]                     }
[17:39:23.298]                     sendCondition <<- function(cond) NULL
[17:39:23.298]                   }
[17:39:23.298]                 })
[17:39:23.298]                 withCallingHandlers({
[17:39:23.298]                   {
[17:39:23.298]                     do.call(function(...) {
[17:39:23.298]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.298]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.298]                         ...future.globals.maxSize)) {
[17:39:23.298]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.298]                         on.exit(options(oopts), add = TRUE)
[17:39:23.298]                       }
[17:39:23.298]                       {
[17:39:23.298]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.298]                           FUN = function(jj) {
[17:39:23.298]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.298]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.298]                           })
[17:39:23.298]                       }
[17:39:23.298]                     }, args = future.call.arguments)
[17:39:23.298]                   }
[17:39:23.298]                 }, immediateCondition = function(cond) {
[17:39:23.298]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.298]                   sendCondition(cond)
[17:39:23.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.298]                   {
[17:39:23.298]                     inherits <- base::inherits
[17:39:23.298]                     invokeRestart <- base::invokeRestart
[17:39:23.298]                     is.null <- base::is.null
[17:39:23.298]                     muffled <- FALSE
[17:39:23.298]                     if (inherits(cond, "message")) {
[17:39:23.298]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.298]                       if (muffled) 
[17:39:23.298]                         invokeRestart("muffleMessage")
[17:39:23.298]                     }
[17:39:23.298]                     else if (inherits(cond, "warning")) {
[17:39:23.298]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.298]                       if (muffled) 
[17:39:23.298]                         invokeRestart("muffleWarning")
[17:39:23.298]                     }
[17:39:23.298]                     else if (inherits(cond, "condition")) {
[17:39:23.298]                       if (!is.null(pattern)) {
[17:39:23.298]                         computeRestarts <- base::computeRestarts
[17:39:23.298]                         grepl <- base::grepl
[17:39:23.298]                         restarts <- computeRestarts(cond)
[17:39:23.298]                         for (restart in restarts) {
[17:39:23.298]                           name <- restart$name
[17:39:23.298]                           if (is.null(name)) 
[17:39:23.298]                             next
[17:39:23.298]                           if (!grepl(pattern, name)) 
[17:39:23.298]                             next
[17:39:23.298]                           invokeRestart(restart)
[17:39:23.298]                           muffled <- TRUE
[17:39:23.298]                           break
[17:39:23.298]                         }
[17:39:23.298]                       }
[17:39:23.298]                     }
[17:39:23.298]                     invisible(muffled)
[17:39:23.298]                   }
[17:39:23.298]                   muffleCondition(cond)
[17:39:23.298]                 })
[17:39:23.298]             }))
[17:39:23.298]             future::FutureResult(value = ...future.value$value, 
[17:39:23.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.298]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.298]                     ...future.globalenv.names))
[17:39:23.298]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.298]         }, condition = base::local({
[17:39:23.298]             c <- base::c
[17:39:23.298]             inherits <- base::inherits
[17:39:23.298]             invokeRestart <- base::invokeRestart
[17:39:23.298]             length <- base::length
[17:39:23.298]             list <- base::list
[17:39:23.298]             seq.int <- base::seq.int
[17:39:23.298]             signalCondition <- base::signalCondition
[17:39:23.298]             sys.calls <- base::sys.calls
[17:39:23.298]             `[[` <- base::`[[`
[17:39:23.298]             `+` <- base::`+`
[17:39:23.298]             `<<-` <- base::`<<-`
[17:39:23.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.298]                   3L)]
[17:39:23.298]             }
[17:39:23.298]             function(cond) {
[17:39:23.298]                 is_error <- inherits(cond, "error")
[17:39:23.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.298]                   NULL)
[17:39:23.298]                 if (is_error) {
[17:39:23.298]                   sessionInformation <- function() {
[17:39:23.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.298]                       search = base::search(), system = base::Sys.info())
[17:39:23.298]                   }
[17:39:23.298]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.298]                     cond$call), session = sessionInformation(), 
[17:39:23.298]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.298]                   signalCondition(cond)
[17:39:23.298]                 }
[17:39:23.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.298]                 "immediateCondition"))) {
[17:39:23.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.298]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.298]                   if (TRUE && !signal) {
[17:39:23.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.298]                     {
[17:39:23.298]                       inherits <- base::inherits
[17:39:23.298]                       invokeRestart <- base::invokeRestart
[17:39:23.298]                       is.null <- base::is.null
[17:39:23.298]                       muffled <- FALSE
[17:39:23.298]                       if (inherits(cond, "message")) {
[17:39:23.298]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.298]                         if (muffled) 
[17:39:23.298]                           invokeRestart("muffleMessage")
[17:39:23.298]                       }
[17:39:23.298]                       else if (inherits(cond, "warning")) {
[17:39:23.298]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.298]                         if (muffled) 
[17:39:23.298]                           invokeRestart("muffleWarning")
[17:39:23.298]                       }
[17:39:23.298]                       else if (inherits(cond, "condition")) {
[17:39:23.298]                         if (!is.null(pattern)) {
[17:39:23.298]                           computeRestarts <- base::computeRestarts
[17:39:23.298]                           grepl <- base::grepl
[17:39:23.298]                           restarts <- computeRestarts(cond)
[17:39:23.298]                           for (restart in restarts) {
[17:39:23.298]                             name <- restart$name
[17:39:23.298]                             if (is.null(name)) 
[17:39:23.298]                               next
[17:39:23.298]                             if (!grepl(pattern, name)) 
[17:39:23.298]                               next
[17:39:23.298]                             invokeRestart(restart)
[17:39:23.298]                             muffled <- TRUE
[17:39:23.298]                             break
[17:39:23.298]                           }
[17:39:23.298]                         }
[17:39:23.298]                       }
[17:39:23.298]                       invisible(muffled)
[17:39:23.298]                     }
[17:39:23.298]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.298]                   }
[17:39:23.298]                 }
[17:39:23.298]                 else {
[17:39:23.298]                   if (TRUE) {
[17:39:23.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.298]                     {
[17:39:23.298]                       inherits <- base::inherits
[17:39:23.298]                       invokeRestart <- base::invokeRestart
[17:39:23.298]                       is.null <- base::is.null
[17:39:23.298]                       muffled <- FALSE
[17:39:23.298]                       if (inherits(cond, "message")) {
[17:39:23.298]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.298]                         if (muffled) 
[17:39:23.298]                           invokeRestart("muffleMessage")
[17:39:23.298]                       }
[17:39:23.298]                       else if (inherits(cond, "warning")) {
[17:39:23.298]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.298]                         if (muffled) 
[17:39:23.298]                           invokeRestart("muffleWarning")
[17:39:23.298]                       }
[17:39:23.298]                       else if (inherits(cond, "condition")) {
[17:39:23.298]                         if (!is.null(pattern)) {
[17:39:23.298]                           computeRestarts <- base::computeRestarts
[17:39:23.298]                           grepl <- base::grepl
[17:39:23.298]                           restarts <- computeRestarts(cond)
[17:39:23.298]                           for (restart in restarts) {
[17:39:23.298]                             name <- restart$name
[17:39:23.298]                             if (is.null(name)) 
[17:39:23.298]                               next
[17:39:23.298]                             if (!grepl(pattern, name)) 
[17:39:23.298]                               next
[17:39:23.298]                             invokeRestart(restart)
[17:39:23.298]                             muffled <- TRUE
[17:39:23.298]                             break
[17:39:23.298]                           }
[17:39:23.298]                         }
[17:39:23.298]                       }
[17:39:23.298]                       invisible(muffled)
[17:39:23.298]                     }
[17:39:23.298]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.298]                   }
[17:39:23.298]                 }
[17:39:23.298]             }
[17:39:23.298]         }))
[17:39:23.298]     }, error = function(ex) {
[17:39:23.298]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.298]                 ...future.rng), started = ...future.startTime, 
[17:39:23.298]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.298]             version = "1.8"), class = "FutureResult")
[17:39:23.298]     }, finally = {
[17:39:23.298]         if (!identical(...future.workdir, getwd())) 
[17:39:23.298]             setwd(...future.workdir)
[17:39:23.298]         {
[17:39:23.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.298]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.298]             }
[17:39:23.298]             base::options(...future.oldOptions)
[17:39:23.298]             if (.Platform$OS.type == "windows") {
[17:39:23.298]                 old_names <- names(...future.oldEnvVars)
[17:39:23.298]                 envs <- base::Sys.getenv()
[17:39:23.298]                 names <- names(envs)
[17:39:23.298]                 common <- intersect(names, old_names)
[17:39:23.298]                 added <- setdiff(names, old_names)
[17:39:23.298]                 removed <- setdiff(old_names, names)
[17:39:23.298]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.298]                   envs[common]]
[17:39:23.298]                 NAMES <- toupper(changed)
[17:39:23.298]                 args <- list()
[17:39:23.298]                 for (kk in seq_along(NAMES)) {
[17:39:23.298]                   name <- changed[[kk]]
[17:39:23.298]                   NAME <- NAMES[[kk]]
[17:39:23.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.298]                     next
[17:39:23.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.298]                 }
[17:39:23.298]                 NAMES <- toupper(added)
[17:39:23.298]                 for (kk in seq_along(NAMES)) {
[17:39:23.298]                   name <- added[[kk]]
[17:39:23.298]                   NAME <- NAMES[[kk]]
[17:39:23.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.298]                     next
[17:39:23.298]                   args[[name]] <- ""
[17:39:23.298]                 }
[17:39:23.298]                 NAMES <- toupper(removed)
[17:39:23.298]                 for (kk in seq_along(NAMES)) {
[17:39:23.298]                   name <- removed[[kk]]
[17:39:23.298]                   NAME <- NAMES[[kk]]
[17:39:23.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.298]                     next
[17:39:23.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.298]                 }
[17:39:23.298]                 if (length(args) > 0) 
[17:39:23.298]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.298]             }
[17:39:23.298]             else {
[17:39:23.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.298]             }
[17:39:23.298]             {
[17:39:23.298]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.298]                   0L) {
[17:39:23.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.298]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.298]                   base::options(opts)
[17:39:23.298]                 }
[17:39:23.298]                 {
[17:39:23.298]                   {
[17:39:23.298]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.298]                     NULL
[17:39:23.298]                   }
[17:39:23.298]                   options(future.plan = NULL)
[17:39:23.298]                   if (is.na(NA_character_)) 
[17:39:23.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.298]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.298]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.298]                     envir = parent.frame()) 
[17:39:23.298]                   {
[17:39:23.298]                     if (is.function(workers)) 
[17:39:23.298]                       workers <- workers()
[17:39:23.298]                     workers <- structure(as.integer(workers), 
[17:39:23.298]                       class = class(workers))
[17:39:23.298]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.298]                       workers >= 1)
[17:39:23.298]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.298]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.298]                     }
[17:39:23.298]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.298]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.298]                       envir = envir)
[17:39:23.298]                     if (!future$lazy) 
[17:39:23.298]                       future <- run(future)
[17:39:23.298]                     invisible(future)
[17:39:23.298]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.298]                 }
[17:39:23.298]             }
[17:39:23.298]         }
[17:39:23.298]     })
[17:39:23.298]     if (TRUE) {
[17:39:23.298]         base::sink(type = "output", split = FALSE)
[17:39:23.298]         if (TRUE) {
[17:39:23.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.298]         }
[17:39:23.298]         else {
[17:39:23.298]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.298]         }
[17:39:23.298]         base::close(...future.stdout)
[17:39:23.298]         ...future.stdout <- NULL
[17:39:23.298]     }
[17:39:23.298]     ...future.result$conditions <- ...future.conditions
[17:39:23.298]     ...future.result$finished <- base::Sys.time()
[17:39:23.298]     ...future.result
[17:39:23.298] }
[17:39:23.301] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[17:39:23.301] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:23.301] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.302] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:39:23.302] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:39:23.302] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:39:23.302] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:39:23.303] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:23.303] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.303] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:23.304] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.304] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[17:39:23.304] MultisessionFuture started
[17:39:23.304] - Launch lazy future ... done
[17:39:23.305] run() for ‘MultisessionFuture’ ... done
[17:39:23.305] Created future:
[17:39:23.305] MultisessionFuture:
[17:39:23.305] Label: ‘future_apply-2’
[17:39:23.305] Expression:
[17:39:23.305] {
[17:39:23.305]     do.call(function(...) {
[17:39:23.305]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.305]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.305]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.305]             on.exit(options(oopts), add = TRUE)
[17:39:23.305]         }
[17:39:23.305]         {
[17:39:23.305]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.305]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.305]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.305]             })
[17:39:23.305]         }
[17:39:23.305]     }, args = future.call.arguments)
[17:39:23.305] }
[17:39:23.305] Lazy evaluation: FALSE
[17:39:23.305] Asynchronous evaluation: TRUE
[17:39:23.305] Local evaluation: TRUE
[17:39:23.305] Environment: R_GlobalEnv
[17:39:23.305] Capture standard output: TRUE
[17:39:23.305] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.305] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.305] Packages: <none>
[17:39:23.305] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.305] Resolved: FALSE
[17:39:23.305] Value: <not collected>
[17:39:23.305] Conditions captured: <none>
[17:39:23.305] Early signaling: FALSE
[17:39:23.305] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.305] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.316] Chunk #2 of 2 ... DONE
[17:39:23.316] Launching 2 futures (chunks) ... DONE
[17:39:23.316] Resolving 2 futures (chunks) ...
[17:39:23.317] resolve() on list ...
[17:39:23.317]  recursive: 0
[17:39:23.317]  length: 2
[17:39:23.317] 
[17:39:23.317] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.317] - Validating connection of MultisessionFuture
[17:39:23.318] - received message: FutureResult
[17:39:23.318] - Received FutureResult
[17:39:23.318] - Erased future from FutureRegistry
[17:39:23.318] result() for ClusterFuture ...
[17:39:23.318] - result already collected: FutureResult
[17:39:23.318] result() for ClusterFuture ... done
[17:39:23.318] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.318] Future #1
[17:39:23.318] result() for ClusterFuture ...
[17:39:23.318] - result already collected: FutureResult
[17:39:23.319] result() for ClusterFuture ... done
[17:39:23.319] result() for ClusterFuture ...
[17:39:23.319] - result already collected: FutureResult
[17:39:23.319] result() for ClusterFuture ... done
[17:39:23.319] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:23.319] - nx: 2
[17:39:23.319] - relay: TRUE
[17:39:23.319] - stdout: TRUE
[17:39:23.319] - signal: TRUE
[17:39:23.319] - resignal: FALSE
[17:39:23.319] - force: TRUE
[17:39:23.320] - relayed: [n=2] FALSE, FALSE
[17:39:23.320] - queued futures: [n=2] FALSE, FALSE
[17:39:23.320]  - until=1
[17:39:23.320]  - relaying element #1
[17:39:23.320] result() for ClusterFuture ...
[17:39:23.320] - result already collected: FutureResult
[17:39:23.320] result() for ClusterFuture ... done
[17:39:23.320] result() for ClusterFuture ...
[17:39:23.320] - result already collected: FutureResult
[17:39:23.320] result() for ClusterFuture ... done
[17:39:23.320] result() for ClusterFuture ...
[17:39:23.321] - result already collected: FutureResult
[17:39:23.321] result() for ClusterFuture ... done
[17:39:23.321] result() for ClusterFuture ...
[17:39:23.321] - result already collected: FutureResult
[17:39:23.321] result() for ClusterFuture ... done
[17:39:23.321] - relayed: [n=2] TRUE, FALSE
[17:39:23.321] - queued futures: [n=2] TRUE, FALSE
[17:39:23.321] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:23.321]  length: 1 (resolved future 1)
[17:39:23.363] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.363] - Validating connection of MultisessionFuture
[17:39:23.363] - received message: FutureResult
[17:39:23.363] - Received FutureResult
[17:39:23.363] - Erased future from FutureRegistry
[17:39:23.364] result() for ClusterFuture ...
[17:39:23.364] - result already collected: FutureResult
[17:39:23.364] result() for ClusterFuture ... done
[17:39:23.364] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.364] Future #2
[17:39:23.364] result() for ClusterFuture ...
[17:39:23.364] - result already collected: FutureResult
[17:39:23.364] result() for ClusterFuture ... done
[17:39:23.364] result() for ClusterFuture ...
[17:39:23.364] - result already collected: FutureResult
[17:39:23.364] result() for ClusterFuture ... done
[17:39:23.365] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:23.365] - nx: 2
[17:39:23.365] - relay: TRUE
[17:39:23.365] - stdout: TRUE
[17:39:23.365] - signal: TRUE
[17:39:23.365] - resignal: FALSE
[17:39:23.365] - force: TRUE
[17:39:23.365] - relayed: [n=2] TRUE, FALSE
[17:39:23.365] - queued futures: [n=2] TRUE, FALSE
[17:39:23.365]  - until=2
[17:39:23.365]  - relaying element #2
[17:39:23.366] result() for ClusterFuture ...
[17:39:23.366] - result already collected: FutureResult
[17:39:23.366] result() for ClusterFuture ... done
[17:39:23.366] result() for ClusterFuture ...
[17:39:23.366] - result already collected: FutureResult
[17:39:23.366] result() for ClusterFuture ... done
[17:39:23.366] result() for ClusterFuture ...
[17:39:23.366] - result already collected: FutureResult
[17:39:23.366] result() for ClusterFuture ... done
[17:39:23.366] result() for ClusterFuture ...
[17:39:23.366] - result already collected: FutureResult
[17:39:23.367] result() for ClusterFuture ... done
[17:39:23.367] - relayed: [n=2] TRUE, TRUE
[17:39:23.367] - queued futures: [n=2] TRUE, TRUE
[17:39:23.367] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:23.367]  length: 0 (resolved future 2)
[17:39:23.367] Relaying remaining futures
[17:39:23.367] signalConditionsASAP(NULL, pos=0) ...
[17:39:23.367] - nx: 2
[17:39:23.367] - relay: TRUE
[17:39:23.367] - stdout: TRUE
[17:39:23.367] - signal: TRUE
[17:39:23.368] - resignal: FALSE
[17:39:23.368] - force: TRUE
[17:39:23.368] - relayed: [n=2] TRUE, TRUE
[17:39:23.368] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:23.368] - relayed: [n=2] TRUE, TRUE
[17:39:23.368] - queued futures: [n=2] TRUE, TRUE
[17:39:23.368] signalConditionsASAP(NULL, pos=0) ... done
[17:39:23.368] resolve() on list ... DONE
[17:39:23.368] result() for ClusterFuture ...
[17:39:23.368] - result already collected: FutureResult
[17:39:23.368] result() for ClusterFuture ... done
[17:39:23.369] result() for ClusterFuture ...
[17:39:23.369] - result already collected: FutureResult
[17:39:23.369] result() for ClusterFuture ... done
[17:39:23.369] result() for ClusterFuture ...
[17:39:23.369] - result already collected: FutureResult
[17:39:23.369] result() for ClusterFuture ... done
[17:39:23.369] result() for ClusterFuture ...
[17:39:23.369] - result already collected: FutureResult
[17:39:23.369] result() for ClusterFuture ... done
[17:39:23.369]  - Number of value chunks collected: 2
[17:39:23.369] Resolving 2 futures (chunks) ... DONE
[17:39:23.370] Reducing values from 2 chunks ...
[17:39:23.370]  - Number of values collected after concatenation: 2
[17:39:23.370]  - Number of values expected: 2
[17:39:23.370] Reducing values from 2 chunks ... DONE
[17:39:23.370] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:39:23.370] getGlobalsAndPackagesXApply() ...
[17:39:23.370]  - future.globals: TRUE
[17:39:23.370] getGlobalsAndPackages() ...
[17:39:23.371] Searching for globals...
[17:39:23.372] - globals found: [1] ‘FUN’
[17:39:23.372] Searching for globals ... DONE
[17:39:23.372] Resolving globals: FALSE
[17:39:23.372] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:23.373] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:23.373] - globals: [1] ‘FUN’
[17:39:23.373] 
[17:39:23.373] getGlobalsAndPackages() ... DONE
[17:39:23.373]  - globals found/used: [n=1] ‘FUN’
[17:39:23.373]  - needed namespaces: [n=0] 
[17:39:23.373] Finding globals ... DONE
[17:39:23.373]  - use_args: TRUE
[17:39:23.373]  - Getting '...' globals ...
[17:39:23.374] resolve() on list ...
[17:39:23.374]  recursive: 0
[17:39:23.374]  length: 1
[17:39:23.374]  elements: ‘...’
[17:39:23.374]  length: 0 (resolved future 1)
[17:39:23.374] resolve() on list ... DONE
[17:39:23.374]    - '...' content: [n=0] 
[17:39:23.374] List of 1
[17:39:23.374]  $ ...: list()
[17:39:23.374]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.374]  - attr(*, "where")=List of 1
[17:39:23.374]   ..$ ...:<environment: 0x55c7982ee1c0> 
[17:39:23.374]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.374]  - attr(*, "resolved")= logi TRUE
[17:39:23.374]  - attr(*, "total_size")= num NA
[17:39:23.377]  - Getting '...' globals ... DONE
[17:39:23.377] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:23.377] List of 2
[17:39:23.377]  $ ...future.FUN:function (x)  
[17:39:23.377]  $ ...          : list()
[17:39:23.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.377]  - attr(*, "where")=List of 2
[17:39:23.377]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:23.377]   ..$ ...          :<environment: 0x55c7982ee1c0> 
[17:39:23.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.377]  - attr(*, "resolved")= logi FALSE
[17:39:23.377]  - attr(*, "total_size")= num 848
[17:39:23.380] Packages to be attached in all futures: [n=0] 
[17:39:23.380] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.383] future_lapply() ...
[17:39:23.387] Number of chunks: 2
[17:39:23.387] getGlobalsAndPackagesXApply() ...
[17:39:23.387]  - future.globals: <name-value list> with names ‘list()’
[17:39:23.387]  - use_args: TRUE
[17:39:23.388] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:23.388] List of 2
[17:39:23.388]  $ ...          : list()
[17:39:23.388]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.388]  $ ...future.FUN:function (x)  
[17:39:23.388]  - attr(*, "where")=List of 2
[17:39:23.388]   ..$ ...          :<environment: 0x55c7982ee1c0> 
[17:39:23.388]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:23.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.388]  - attr(*, "resolved")= logi FALSE
[17:39:23.388]  - attr(*, "total_size")= num NA
[17:39:23.391] Packages to be attached in all futures: [n=0] 
[17:39:23.391] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.391] Number of futures (= number of chunks): 2
[17:39:23.391] Launching 2 futures (chunks) ...
[17:39:23.391] Chunk #1 of 2 ...
[17:39:23.392]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[17:39:23.392]  - seeds: <none>
[17:39:23.392] getGlobalsAndPackages() ...
[17:39:23.392] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.392] Resolving globals: FALSE
[17:39:23.392] Tweak future expression to call with '...' arguments ...
[17:39:23.392] {
[17:39:23.392]     do.call(function(...) {
[17:39:23.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.392]             on.exit(options(oopts), add = TRUE)
[17:39:23.392]         }
[17:39:23.392]         {
[17:39:23.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.392]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.392]             })
[17:39:23.392]         }
[17:39:23.392]     }, args = future.call.arguments)
[17:39:23.392] }
[17:39:23.392] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.393] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.393] 
[17:39:23.393] getGlobalsAndPackages() ... DONE
[17:39:23.393] run() for ‘Future’ ...
[17:39:23.393] - state: ‘created’
[17:39:23.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.408] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.408]   - Field: ‘node’
[17:39:23.409]   - Field: ‘label’
[17:39:23.409]   - Field: ‘local’
[17:39:23.409]   - Field: ‘owner’
[17:39:23.409]   - Field: ‘envir’
[17:39:23.409]   - Field: ‘workers’
[17:39:23.409]   - Field: ‘packages’
[17:39:23.409]   - Field: ‘gc’
[17:39:23.409]   - Field: ‘conditions’
[17:39:23.409]   - Field: ‘persistent’
[17:39:23.409]   - Field: ‘expr’
[17:39:23.410]   - Field: ‘uuid’
[17:39:23.410]   - Field: ‘seed’
[17:39:23.410]   - Field: ‘version’
[17:39:23.410]   - Field: ‘result’
[17:39:23.410]   - Field: ‘asynchronous’
[17:39:23.410]   - Field: ‘calls’
[17:39:23.410]   - Field: ‘globals’
[17:39:23.410]   - Field: ‘stdout’
[17:39:23.410]   - Field: ‘earlySignal’
[17:39:23.410]   - Field: ‘lazy’
[17:39:23.410]   - Field: ‘state’
[17:39:23.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.411] - Launch lazy future ...
[17:39:23.411] Packages needed by the future expression (n = 0): <none>
[17:39:23.411] Packages needed by future strategies (n = 0): <none>
[17:39:23.411] {
[17:39:23.411]     {
[17:39:23.411]         {
[17:39:23.411]             ...future.startTime <- base::Sys.time()
[17:39:23.411]             {
[17:39:23.411]                 {
[17:39:23.411]                   {
[17:39:23.411]                     {
[17:39:23.411]                       base::local({
[17:39:23.411]                         has_future <- base::requireNamespace("future", 
[17:39:23.411]                           quietly = TRUE)
[17:39:23.411]                         if (has_future) {
[17:39:23.411]                           ns <- base::getNamespace("future")
[17:39:23.411]                           version <- ns[[".package"]][["version"]]
[17:39:23.411]                           if (is.null(version)) 
[17:39:23.411]                             version <- utils::packageVersion("future")
[17:39:23.411]                         }
[17:39:23.411]                         else {
[17:39:23.411]                           version <- NULL
[17:39:23.411]                         }
[17:39:23.411]                         if (!has_future || version < "1.8.0") {
[17:39:23.411]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.411]                             "", base::R.version$version.string), 
[17:39:23.411]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.411]                               "release", "version")], collapse = " "), 
[17:39:23.411]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.411]                             info)
[17:39:23.411]                           info <- base::paste(info, collapse = "; ")
[17:39:23.411]                           if (!has_future) {
[17:39:23.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.411]                               info)
[17:39:23.411]                           }
[17:39:23.411]                           else {
[17:39:23.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.411]                               info, version)
[17:39:23.411]                           }
[17:39:23.411]                           base::stop(msg)
[17:39:23.411]                         }
[17:39:23.411]                       })
[17:39:23.411]                     }
[17:39:23.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.411]                     base::options(mc.cores = 1L)
[17:39:23.411]                   }
[17:39:23.411]                   options(future.plan = NULL)
[17:39:23.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.411]                 }
[17:39:23.411]                 ...future.workdir <- getwd()
[17:39:23.411]             }
[17:39:23.411]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.411]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.411]         }
[17:39:23.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.411]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.411]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.411]             base::names(...future.oldOptions))
[17:39:23.411]     }
[17:39:23.411]     if (FALSE) {
[17:39:23.411]     }
[17:39:23.411]     else {
[17:39:23.411]         if (TRUE) {
[17:39:23.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.411]                 open = "w")
[17:39:23.411]         }
[17:39:23.411]         else {
[17:39:23.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.411]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.411]         }
[17:39:23.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.411]             base::sink(type = "output", split = FALSE)
[17:39:23.411]             base::close(...future.stdout)
[17:39:23.411]         }, add = TRUE)
[17:39:23.411]     }
[17:39:23.411]     ...future.frame <- base::sys.nframe()
[17:39:23.411]     ...future.conditions <- base::list()
[17:39:23.411]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.411]     if (FALSE) {
[17:39:23.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.411]     }
[17:39:23.411]     ...future.result <- base::tryCatch({
[17:39:23.411]         base::withCallingHandlers({
[17:39:23.411]             ...future.value <- base::withVisible(base::local({
[17:39:23.411]                 ...future.makeSendCondition <- local({
[17:39:23.411]                   sendCondition <- NULL
[17:39:23.411]                   function(frame = 1L) {
[17:39:23.411]                     if (is.function(sendCondition)) 
[17:39:23.411]                       return(sendCondition)
[17:39:23.411]                     ns <- getNamespace("parallel")
[17:39:23.411]                     if (exists("sendData", mode = "function", 
[17:39:23.411]                       envir = ns)) {
[17:39:23.411]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.411]                         envir = ns)
[17:39:23.411]                       envir <- sys.frame(frame)
[17:39:23.411]                       master <- NULL
[17:39:23.411]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.411]                         !identical(envir, emptyenv())) {
[17:39:23.411]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.411]                           inherits = FALSE)) {
[17:39:23.411]                           master <- get("master", mode = "list", 
[17:39:23.411]                             envir = envir, inherits = FALSE)
[17:39:23.411]                           if (inherits(master, c("SOCKnode", 
[17:39:23.411]                             "SOCK0node"))) {
[17:39:23.411]                             sendCondition <<- function(cond) {
[17:39:23.411]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.411]                                 success = TRUE)
[17:39:23.411]                               parallel_sendData(master, data)
[17:39:23.411]                             }
[17:39:23.411]                             return(sendCondition)
[17:39:23.411]                           }
[17:39:23.411]                         }
[17:39:23.411]                         frame <- frame + 1L
[17:39:23.411]                         envir <- sys.frame(frame)
[17:39:23.411]                       }
[17:39:23.411]                     }
[17:39:23.411]                     sendCondition <<- function(cond) NULL
[17:39:23.411]                   }
[17:39:23.411]                 })
[17:39:23.411]                 withCallingHandlers({
[17:39:23.411]                   {
[17:39:23.411]                     do.call(function(...) {
[17:39:23.411]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.411]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.411]                         ...future.globals.maxSize)) {
[17:39:23.411]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.411]                         on.exit(options(oopts), add = TRUE)
[17:39:23.411]                       }
[17:39:23.411]                       {
[17:39:23.411]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.411]                           FUN = function(jj) {
[17:39:23.411]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.411]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.411]                           })
[17:39:23.411]                       }
[17:39:23.411]                     }, args = future.call.arguments)
[17:39:23.411]                   }
[17:39:23.411]                 }, immediateCondition = function(cond) {
[17:39:23.411]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.411]                   sendCondition(cond)
[17:39:23.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.411]                   {
[17:39:23.411]                     inherits <- base::inherits
[17:39:23.411]                     invokeRestart <- base::invokeRestart
[17:39:23.411]                     is.null <- base::is.null
[17:39:23.411]                     muffled <- FALSE
[17:39:23.411]                     if (inherits(cond, "message")) {
[17:39:23.411]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.411]                       if (muffled) 
[17:39:23.411]                         invokeRestart("muffleMessage")
[17:39:23.411]                     }
[17:39:23.411]                     else if (inherits(cond, "warning")) {
[17:39:23.411]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.411]                       if (muffled) 
[17:39:23.411]                         invokeRestart("muffleWarning")
[17:39:23.411]                     }
[17:39:23.411]                     else if (inherits(cond, "condition")) {
[17:39:23.411]                       if (!is.null(pattern)) {
[17:39:23.411]                         computeRestarts <- base::computeRestarts
[17:39:23.411]                         grepl <- base::grepl
[17:39:23.411]                         restarts <- computeRestarts(cond)
[17:39:23.411]                         for (restart in restarts) {
[17:39:23.411]                           name <- restart$name
[17:39:23.411]                           if (is.null(name)) 
[17:39:23.411]                             next
[17:39:23.411]                           if (!grepl(pattern, name)) 
[17:39:23.411]                             next
[17:39:23.411]                           invokeRestart(restart)
[17:39:23.411]                           muffled <- TRUE
[17:39:23.411]                           break
[17:39:23.411]                         }
[17:39:23.411]                       }
[17:39:23.411]                     }
[17:39:23.411]                     invisible(muffled)
[17:39:23.411]                   }
[17:39:23.411]                   muffleCondition(cond)
[17:39:23.411]                 })
[17:39:23.411]             }))
[17:39:23.411]             future::FutureResult(value = ...future.value$value, 
[17:39:23.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.411]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.411]                     ...future.globalenv.names))
[17:39:23.411]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.411]         }, condition = base::local({
[17:39:23.411]             c <- base::c
[17:39:23.411]             inherits <- base::inherits
[17:39:23.411]             invokeRestart <- base::invokeRestart
[17:39:23.411]             length <- base::length
[17:39:23.411]             list <- base::list
[17:39:23.411]             seq.int <- base::seq.int
[17:39:23.411]             signalCondition <- base::signalCondition
[17:39:23.411]             sys.calls <- base::sys.calls
[17:39:23.411]             `[[` <- base::`[[`
[17:39:23.411]             `+` <- base::`+`
[17:39:23.411]             `<<-` <- base::`<<-`
[17:39:23.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.411]                   3L)]
[17:39:23.411]             }
[17:39:23.411]             function(cond) {
[17:39:23.411]                 is_error <- inherits(cond, "error")
[17:39:23.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.411]                   NULL)
[17:39:23.411]                 if (is_error) {
[17:39:23.411]                   sessionInformation <- function() {
[17:39:23.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.411]                       search = base::search(), system = base::Sys.info())
[17:39:23.411]                   }
[17:39:23.411]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.411]                     cond$call), session = sessionInformation(), 
[17:39:23.411]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.411]                   signalCondition(cond)
[17:39:23.411]                 }
[17:39:23.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.411]                 "immediateCondition"))) {
[17:39:23.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.411]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.411]                   if (TRUE && !signal) {
[17:39:23.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.411]                     {
[17:39:23.411]                       inherits <- base::inherits
[17:39:23.411]                       invokeRestart <- base::invokeRestart
[17:39:23.411]                       is.null <- base::is.null
[17:39:23.411]                       muffled <- FALSE
[17:39:23.411]                       if (inherits(cond, "message")) {
[17:39:23.411]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.411]                         if (muffled) 
[17:39:23.411]                           invokeRestart("muffleMessage")
[17:39:23.411]                       }
[17:39:23.411]                       else if (inherits(cond, "warning")) {
[17:39:23.411]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.411]                         if (muffled) 
[17:39:23.411]                           invokeRestart("muffleWarning")
[17:39:23.411]                       }
[17:39:23.411]                       else if (inherits(cond, "condition")) {
[17:39:23.411]                         if (!is.null(pattern)) {
[17:39:23.411]                           computeRestarts <- base::computeRestarts
[17:39:23.411]                           grepl <- base::grepl
[17:39:23.411]                           restarts <- computeRestarts(cond)
[17:39:23.411]                           for (restart in restarts) {
[17:39:23.411]                             name <- restart$name
[17:39:23.411]                             if (is.null(name)) 
[17:39:23.411]                               next
[17:39:23.411]                             if (!grepl(pattern, name)) 
[17:39:23.411]                               next
[17:39:23.411]                             invokeRestart(restart)
[17:39:23.411]                             muffled <- TRUE
[17:39:23.411]                             break
[17:39:23.411]                           }
[17:39:23.411]                         }
[17:39:23.411]                       }
[17:39:23.411]                       invisible(muffled)
[17:39:23.411]                     }
[17:39:23.411]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.411]                   }
[17:39:23.411]                 }
[17:39:23.411]                 else {
[17:39:23.411]                   if (TRUE) {
[17:39:23.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.411]                     {
[17:39:23.411]                       inherits <- base::inherits
[17:39:23.411]                       invokeRestart <- base::invokeRestart
[17:39:23.411]                       is.null <- base::is.null
[17:39:23.411]                       muffled <- FALSE
[17:39:23.411]                       if (inherits(cond, "message")) {
[17:39:23.411]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.411]                         if (muffled) 
[17:39:23.411]                           invokeRestart("muffleMessage")
[17:39:23.411]                       }
[17:39:23.411]                       else if (inherits(cond, "warning")) {
[17:39:23.411]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.411]                         if (muffled) 
[17:39:23.411]                           invokeRestart("muffleWarning")
[17:39:23.411]                       }
[17:39:23.411]                       else if (inherits(cond, "condition")) {
[17:39:23.411]                         if (!is.null(pattern)) {
[17:39:23.411]                           computeRestarts <- base::computeRestarts
[17:39:23.411]                           grepl <- base::grepl
[17:39:23.411]                           restarts <- computeRestarts(cond)
[17:39:23.411]                           for (restart in restarts) {
[17:39:23.411]                             name <- restart$name
[17:39:23.411]                             if (is.null(name)) 
[17:39:23.411]                               next
[17:39:23.411]                             if (!grepl(pattern, name)) 
[17:39:23.411]                               next
[17:39:23.411]                             invokeRestart(restart)
[17:39:23.411]                             muffled <- TRUE
[17:39:23.411]                             break
[17:39:23.411]                           }
[17:39:23.411]                         }
[17:39:23.411]                       }
[17:39:23.411]                       invisible(muffled)
[17:39:23.411]                     }
[17:39:23.411]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.411]                   }
[17:39:23.411]                 }
[17:39:23.411]             }
[17:39:23.411]         }))
[17:39:23.411]     }, error = function(ex) {
[17:39:23.411]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.411]                 ...future.rng), started = ...future.startTime, 
[17:39:23.411]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.411]             version = "1.8"), class = "FutureResult")
[17:39:23.411]     }, finally = {
[17:39:23.411]         if (!identical(...future.workdir, getwd())) 
[17:39:23.411]             setwd(...future.workdir)
[17:39:23.411]         {
[17:39:23.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.411]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.411]             }
[17:39:23.411]             base::options(...future.oldOptions)
[17:39:23.411]             if (.Platform$OS.type == "windows") {
[17:39:23.411]                 old_names <- names(...future.oldEnvVars)
[17:39:23.411]                 envs <- base::Sys.getenv()
[17:39:23.411]                 names <- names(envs)
[17:39:23.411]                 common <- intersect(names, old_names)
[17:39:23.411]                 added <- setdiff(names, old_names)
[17:39:23.411]                 removed <- setdiff(old_names, names)
[17:39:23.411]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.411]                   envs[common]]
[17:39:23.411]                 NAMES <- toupper(changed)
[17:39:23.411]                 args <- list()
[17:39:23.411]                 for (kk in seq_along(NAMES)) {
[17:39:23.411]                   name <- changed[[kk]]
[17:39:23.411]                   NAME <- NAMES[[kk]]
[17:39:23.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.411]                     next
[17:39:23.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.411]                 }
[17:39:23.411]                 NAMES <- toupper(added)
[17:39:23.411]                 for (kk in seq_along(NAMES)) {
[17:39:23.411]                   name <- added[[kk]]
[17:39:23.411]                   NAME <- NAMES[[kk]]
[17:39:23.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.411]                     next
[17:39:23.411]                   args[[name]] <- ""
[17:39:23.411]                 }
[17:39:23.411]                 NAMES <- toupper(removed)
[17:39:23.411]                 for (kk in seq_along(NAMES)) {
[17:39:23.411]                   name <- removed[[kk]]
[17:39:23.411]                   NAME <- NAMES[[kk]]
[17:39:23.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.411]                     next
[17:39:23.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.411]                 }
[17:39:23.411]                 if (length(args) > 0) 
[17:39:23.411]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.411]             }
[17:39:23.411]             else {
[17:39:23.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.411]             }
[17:39:23.411]             {
[17:39:23.411]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.411]                   0L) {
[17:39:23.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.411]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.411]                   base::options(opts)
[17:39:23.411]                 }
[17:39:23.411]                 {
[17:39:23.411]                   {
[17:39:23.411]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.411]                     NULL
[17:39:23.411]                   }
[17:39:23.411]                   options(future.plan = NULL)
[17:39:23.411]                   if (is.na(NA_character_)) 
[17:39:23.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.411]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.411]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.411]                     envir = parent.frame()) 
[17:39:23.411]                   {
[17:39:23.411]                     if (is.function(workers)) 
[17:39:23.411]                       workers <- workers()
[17:39:23.411]                     workers <- structure(as.integer(workers), 
[17:39:23.411]                       class = class(workers))
[17:39:23.411]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.411]                       workers >= 1)
[17:39:23.411]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.411]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.411]                     }
[17:39:23.411]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.411]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.411]                       envir = envir)
[17:39:23.411]                     if (!future$lazy) 
[17:39:23.411]                       future <- run(future)
[17:39:23.411]                     invisible(future)
[17:39:23.411]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.411]                 }
[17:39:23.411]             }
[17:39:23.411]         }
[17:39:23.411]     })
[17:39:23.411]     if (TRUE) {
[17:39:23.411]         base::sink(type = "output", split = FALSE)
[17:39:23.411]         if (TRUE) {
[17:39:23.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.411]         }
[17:39:23.411]         else {
[17:39:23.411]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.411]         }
[17:39:23.411]         base::close(...future.stdout)
[17:39:23.411]         ...future.stdout <- NULL
[17:39:23.411]     }
[17:39:23.411]     ...future.result$conditions <- ...future.conditions
[17:39:23.411]     ...future.result$finished <- base::Sys.time()
[17:39:23.411]     ...future.result
[17:39:23.411] }
[17:39:23.415] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:39:23.415] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:23.415] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.415] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:39:23.416] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:39:23.416] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:39:23.416] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:39:23.416] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:23.417] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.417] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:39:23.417] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:39:23.417] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:39:23.418] MultisessionFuture started
[17:39:23.418] - Launch lazy future ... done
[17:39:23.418] run() for ‘MultisessionFuture’ ... done
[17:39:23.419] Created future:
[17:39:23.419] MultisessionFuture:
[17:39:23.419] Label: ‘future_apply-1’
[17:39:23.419] Expression:
[17:39:23.419] {
[17:39:23.419]     do.call(function(...) {
[17:39:23.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.419]             on.exit(options(oopts), add = TRUE)
[17:39:23.419]         }
[17:39:23.419]         {
[17:39:23.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.419]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.419]             })
[17:39:23.419]         }
[17:39:23.419]     }, args = future.call.arguments)
[17:39:23.419] }
[17:39:23.419] Lazy evaluation: FALSE
[17:39:23.419] Asynchronous evaluation: TRUE
[17:39:23.419] Local evaluation: TRUE
[17:39:23.419] Environment: R_GlobalEnv
[17:39:23.419] Capture standard output: TRUE
[17:39:23.419] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.419] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:23.419] Packages: <none>
[17:39:23.419] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.419] Resolved: FALSE
[17:39:23.419] Value: <not collected>
[17:39:23.419] Conditions captured: <none>
[17:39:23.419] Early signaling: FALSE
[17:39:23.419] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.419] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.430] Chunk #1 of 2 ... DONE
[17:39:23.430] Chunk #2 of 2 ...
[17:39:23.431]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[17:39:23.431]  - seeds: <none>
[17:39:23.431] getGlobalsAndPackages() ...
[17:39:23.431] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.431] Resolving globals: FALSE
[17:39:23.431] Tweak future expression to call with '...' arguments ...
[17:39:23.431] {
[17:39:23.431]     do.call(function(...) {
[17:39:23.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.431]             on.exit(options(oopts), add = TRUE)
[17:39:23.431]         }
[17:39:23.431]         {
[17:39:23.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.431]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.431]             })
[17:39:23.431]         }
[17:39:23.431]     }, args = future.call.arguments)
[17:39:23.431] }
[17:39:23.432] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.432] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.432] 
[17:39:23.432] getGlobalsAndPackages() ... DONE
[17:39:23.434] run() for ‘Future’ ...
[17:39:23.435] - state: ‘created’
[17:39:23.435] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.449] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.449] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.450]   - Field: ‘node’
[17:39:23.450]   - Field: ‘label’
[17:39:23.450]   - Field: ‘local’
[17:39:23.450]   - Field: ‘owner’
[17:39:23.450]   - Field: ‘envir’
[17:39:23.450]   - Field: ‘workers’
[17:39:23.450]   - Field: ‘packages’
[17:39:23.450]   - Field: ‘gc’
[17:39:23.450]   - Field: ‘conditions’
[17:39:23.450]   - Field: ‘persistent’
[17:39:23.451]   - Field: ‘expr’
[17:39:23.451]   - Field: ‘uuid’
[17:39:23.451]   - Field: ‘seed’
[17:39:23.451]   - Field: ‘version’
[17:39:23.451]   - Field: ‘result’
[17:39:23.451]   - Field: ‘asynchronous’
[17:39:23.451]   - Field: ‘calls’
[17:39:23.451]   - Field: ‘globals’
[17:39:23.451]   - Field: ‘stdout’
[17:39:23.451]   - Field: ‘earlySignal’
[17:39:23.451]   - Field: ‘lazy’
[17:39:23.452]   - Field: ‘state’
[17:39:23.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.452] - Launch lazy future ...
[17:39:23.452] Packages needed by the future expression (n = 0): <none>
[17:39:23.452] Packages needed by future strategies (n = 0): <none>
[17:39:23.453] {
[17:39:23.453]     {
[17:39:23.453]         {
[17:39:23.453]             ...future.startTime <- base::Sys.time()
[17:39:23.453]             {
[17:39:23.453]                 {
[17:39:23.453]                   {
[17:39:23.453]                     {
[17:39:23.453]                       base::local({
[17:39:23.453]                         has_future <- base::requireNamespace("future", 
[17:39:23.453]                           quietly = TRUE)
[17:39:23.453]                         if (has_future) {
[17:39:23.453]                           ns <- base::getNamespace("future")
[17:39:23.453]                           version <- ns[[".package"]][["version"]]
[17:39:23.453]                           if (is.null(version)) 
[17:39:23.453]                             version <- utils::packageVersion("future")
[17:39:23.453]                         }
[17:39:23.453]                         else {
[17:39:23.453]                           version <- NULL
[17:39:23.453]                         }
[17:39:23.453]                         if (!has_future || version < "1.8.0") {
[17:39:23.453]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.453]                             "", base::R.version$version.string), 
[17:39:23.453]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.453]                               "release", "version")], collapse = " "), 
[17:39:23.453]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.453]                             info)
[17:39:23.453]                           info <- base::paste(info, collapse = "; ")
[17:39:23.453]                           if (!has_future) {
[17:39:23.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.453]                               info)
[17:39:23.453]                           }
[17:39:23.453]                           else {
[17:39:23.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.453]                               info, version)
[17:39:23.453]                           }
[17:39:23.453]                           base::stop(msg)
[17:39:23.453]                         }
[17:39:23.453]                       })
[17:39:23.453]                     }
[17:39:23.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.453]                     base::options(mc.cores = 1L)
[17:39:23.453]                   }
[17:39:23.453]                   options(future.plan = NULL)
[17:39:23.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.453]                 }
[17:39:23.453]                 ...future.workdir <- getwd()
[17:39:23.453]             }
[17:39:23.453]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.453]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.453]         }
[17:39:23.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.453]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.453]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.453]             base::names(...future.oldOptions))
[17:39:23.453]     }
[17:39:23.453]     if (FALSE) {
[17:39:23.453]     }
[17:39:23.453]     else {
[17:39:23.453]         if (TRUE) {
[17:39:23.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.453]                 open = "w")
[17:39:23.453]         }
[17:39:23.453]         else {
[17:39:23.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.453]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.453]         }
[17:39:23.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.453]             base::sink(type = "output", split = FALSE)
[17:39:23.453]             base::close(...future.stdout)
[17:39:23.453]         }, add = TRUE)
[17:39:23.453]     }
[17:39:23.453]     ...future.frame <- base::sys.nframe()
[17:39:23.453]     ...future.conditions <- base::list()
[17:39:23.453]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.453]     if (FALSE) {
[17:39:23.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.453]     }
[17:39:23.453]     ...future.result <- base::tryCatch({
[17:39:23.453]         base::withCallingHandlers({
[17:39:23.453]             ...future.value <- base::withVisible(base::local({
[17:39:23.453]                 ...future.makeSendCondition <- local({
[17:39:23.453]                   sendCondition <- NULL
[17:39:23.453]                   function(frame = 1L) {
[17:39:23.453]                     if (is.function(sendCondition)) 
[17:39:23.453]                       return(sendCondition)
[17:39:23.453]                     ns <- getNamespace("parallel")
[17:39:23.453]                     if (exists("sendData", mode = "function", 
[17:39:23.453]                       envir = ns)) {
[17:39:23.453]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.453]                         envir = ns)
[17:39:23.453]                       envir <- sys.frame(frame)
[17:39:23.453]                       master <- NULL
[17:39:23.453]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.453]                         !identical(envir, emptyenv())) {
[17:39:23.453]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.453]                           inherits = FALSE)) {
[17:39:23.453]                           master <- get("master", mode = "list", 
[17:39:23.453]                             envir = envir, inherits = FALSE)
[17:39:23.453]                           if (inherits(master, c("SOCKnode", 
[17:39:23.453]                             "SOCK0node"))) {
[17:39:23.453]                             sendCondition <<- function(cond) {
[17:39:23.453]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.453]                                 success = TRUE)
[17:39:23.453]                               parallel_sendData(master, data)
[17:39:23.453]                             }
[17:39:23.453]                             return(sendCondition)
[17:39:23.453]                           }
[17:39:23.453]                         }
[17:39:23.453]                         frame <- frame + 1L
[17:39:23.453]                         envir <- sys.frame(frame)
[17:39:23.453]                       }
[17:39:23.453]                     }
[17:39:23.453]                     sendCondition <<- function(cond) NULL
[17:39:23.453]                   }
[17:39:23.453]                 })
[17:39:23.453]                 withCallingHandlers({
[17:39:23.453]                   {
[17:39:23.453]                     do.call(function(...) {
[17:39:23.453]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.453]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.453]                         ...future.globals.maxSize)) {
[17:39:23.453]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.453]                         on.exit(options(oopts), add = TRUE)
[17:39:23.453]                       }
[17:39:23.453]                       {
[17:39:23.453]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.453]                           FUN = function(jj) {
[17:39:23.453]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.453]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.453]                           })
[17:39:23.453]                       }
[17:39:23.453]                     }, args = future.call.arguments)
[17:39:23.453]                   }
[17:39:23.453]                 }, immediateCondition = function(cond) {
[17:39:23.453]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.453]                   sendCondition(cond)
[17:39:23.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.453]                   {
[17:39:23.453]                     inherits <- base::inherits
[17:39:23.453]                     invokeRestart <- base::invokeRestart
[17:39:23.453]                     is.null <- base::is.null
[17:39:23.453]                     muffled <- FALSE
[17:39:23.453]                     if (inherits(cond, "message")) {
[17:39:23.453]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.453]                       if (muffled) 
[17:39:23.453]                         invokeRestart("muffleMessage")
[17:39:23.453]                     }
[17:39:23.453]                     else if (inherits(cond, "warning")) {
[17:39:23.453]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.453]                       if (muffled) 
[17:39:23.453]                         invokeRestart("muffleWarning")
[17:39:23.453]                     }
[17:39:23.453]                     else if (inherits(cond, "condition")) {
[17:39:23.453]                       if (!is.null(pattern)) {
[17:39:23.453]                         computeRestarts <- base::computeRestarts
[17:39:23.453]                         grepl <- base::grepl
[17:39:23.453]                         restarts <- computeRestarts(cond)
[17:39:23.453]                         for (restart in restarts) {
[17:39:23.453]                           name <- restart$name
[17:39:23.453]                           if (is.null(name)) 
[17:39:23.453]                             next
[17:39:23.453]                           if (!grepl(pattern, name)) 
[17:39:23.453]                             next
[17:39:23.453]                           invokeRestart(restart)
[17:39:23.453]                           muffled <- TRUE
[17:39:23.453]                           break
[17:39:23.453]                         }
[17:39:23.453]                       }
[17:39:23.453]                     }
[17:39:23.453]                     invisible(muffled)
[17:39:23.453]                   }
[17:39:23.453]                   muffleCondition(cond)
[17:39:23.453]                 })
[17:39:23.453]             }))
[17:39:23.453]             future::FutureResult(value = ...future.value$value, 
[17:39:23.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.453]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.453]                     ...future.globalenv.names))
[17:39:23.453]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.453]         }, condition = base::local({
[17:39:23.453]             c <- base::c
[17:39:23.453]             inherits <- base::inherits
[17:39:23.453]             invokeRestart <- base::invokeRestart
[17:39:23.453]             length <- base::length
[17:39:23.453]             list <- base::list
[17:39:23.453]             seq.int <- base::seq.int
[17:39:23.453]             signalCondition <- base::signalCondition
[17:39:23.453]             sys.calls <- base::sys.calls
[17:39:23.453]             `[[` <- base::`[[`
[17:39:23.453]             `+` <- base::`+`
[17:39:23.453]             `<<-` <- base::`<<-`
[17:39:23.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.453]                   3L)]
[17:39:23.453]             }
[17:39:23.453]             function(cond) {
[17:39:23.453]                 is_error <- inherits(cond, "error")
[17:39:23.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.453]                   NULL)
[17:39:23.453]                 if (is_error) {
[17:39:23.453]                   sessionInformation <- function() {
[17:39:23.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.453]                       search = base::search(), system = base::Sys.info())
[17:39:23.453]                   }
[17:39:23.453]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.453]                     cond$call), session = sessionInformation(), 
[17:39:23.453]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.453]                   signalCondition(cond)
[17:39:23.453]                 }
[17:39:23.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.453]                 "immediateCondition"))) {
[17:39:23.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.453]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.453]                   if (TRUE && !signal) {
[17:39:23.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.453]                     {
[17:39:23.453]                       inherits <- base::inherits
[17:39:23.453]                       invokeRestart <- base::invokeRestart
[17:39:23.453]                       is.null <- base::is.null
[17:39:23.453]                       muffled <- FALSE
[17:39:23.453]                       if (inherits(cond, "message")) {
[17:39:23.453]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.453]                         if (muffled) 
[17:39:23.453]                           invokeRestart("muffleMessage")
[17:39:23.453]                       }
[17:39:23.453]                       else if (inherits(cond, "warning")) {
[17:39:23.453]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.453]                         if (muffled) 
[17:39:23.453]                           invokeRestart("muffleWarning")
[17:39:23.453]                       }
[17:39:23.453]                       else if (inherits(cond, "condition")) {
[17:39:23.453]                         if (!is.null(pattern)) {
[17:39:23.453]                           computeRestarts <- base::computeRestarts
[17:39:23.453]                           grepl <- base::grepl
[17:39:23.453]                           restarts <- computeRestarts(cond)
[17:39:23.453]                           for (restart in restarts) {
[17:39:23.453]                             name <- restart$name
[17:39:23.453]                             if (is.null(name)) 
[17:39:23.453]                               next
[17:39:23.453]                             if (!grepl(pattern, name)) 
[17:39:23.453]                               next
[17:39:23.453]                             invokeRestart(restart)
[17:39:23.453]                             muffled <- TRUE
[17:39:23.453]                             break
[17:39:23.453]                           }
[17:39:23.453]                         }
[17:39:23.453]                       }
[17:39:23.453]                       invisible(muffled)
[17:39:23.453]                     }
[17:39:23.453]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.453]                   }
[17:39:23.453]                 }
[17:39:23.453]                 else {
[17:39:23.453]                   if (TRUE) {
[17:39:23.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.453]                     {
[17:39:23.453]                       inherits <- base::inherits
[17:39:23.453]                       invokeRestart <- base::invokeRestart
[17:39:23.453]                       is.null <- base::is.null
[17:39:23.453]                       muffled <- FALSE
[17:39:23.453]                       if (inherits(cond, "message")) {
[17:39:23.453]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.453]                         if (muffled) 
[17:39:23.453]                           invokeRestart("muffleMessage")
[17:39:23.453]                       }
[17:39:23.453]                       else if (inherits(cond, "warning")) {
[17:39:23.453]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.453]                         if (muffled) 
[17:39:23.453]                           invokeRestart("muffleWarning")
[17:39:23.453]                       }
[17:39:23.453]                       else if (inherits(cond, "condition")) {
[17:39:23.453]                         if (!is.null(pattern)) {
[17:39:23.453]                           computeRestarts <- base::computeRestarts
[17:39:23.453]                           grepl <- base::grepl
[17:39:23.453]                           restarts <- computeRestarts(cond)
[17:39:23.453]                           for (restart in restarts) {
[17:39:23.453]                             name <- restart$name
[17:39:23.453]                             if (is.null(name)) 
[17:39:23.453]                               next
[17:39:23.453]                             if (!grepl(pattern, name)) 
[17:39:23.453]                               next
[17:39:23.453]                             invokeRestart(restart)
[17:39:23.453]                             muffled <- TRUE
[17:39:23.453]                             break
[17:39:23.453]                           }
[17:39:23.453]                         }
[17:39:23.453]                       }
[17:39:23.453]                       invisible(muffled)
[17:39:23.453]                     }
[17:39:23.453]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.453]                   }
[17:39:23.453]                 }
[17:39:23.453]             }
[17:39:23.453]         }))
[17:39:23.453]     }, error = function(ex) {
[17:39:23.453]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.453]                 ...future.rng), started = ...future.startTime, 
[17:39:23.453]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.453]             version = "1.8"), class = "FutureResult")
[17:39:23.453]     }, finally = {
[17:39:23.453]         if (!identical(...future.workdir, getwd())) 
[17:39:23.453]             setwd(...future.workdir)
[17:39:23.453]         {
[17:39:23.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.453]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.453]             }
[17:39:23.453]             base::options(...future.oldOptions)
[17:39:23.453]             if (.Platform$OS.type == "windows") {
[17:39:23.453]                 old_names <- names(...future.oldEnvVars)
[17:39:23.453]                 envs <- base::Sys.getenv()
[17:39:23.453]                 names <- names(envs)
[17:39:23.453]                 common <- intersect(names, old_names)
[17:39:23.453]                 added <- setdiff(names, old_names)
[17:39:23.453]                 removed <- setdiff(old_names, names)
[17:39:23.453]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.453]                   envs[common]]
[17:39:23.453]                 NAMES <- toupper(changed)
[17:39:23.453]                 args <- list()
[17:39:23.453]                 for (kk in seq_along(NAMES)) {
[17:39:23.453]                   name <- changed[[kk]]
[17:39:23.453]                   NAME <- NAMES[[kk]]
[17:39:23.453]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.453]                     next
[17:39:23.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.453]                 }
[17:39:23.453]                 NAMES <- toupper(added)
[17:39:23.453]                 for (kk in seq_along(NAMES)) {
[17:39:23.453]                   name <- added[[kk]]
[17:39:23.453]                   NAME <- NAMES[[kk]]
[17:39:23.453]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.453]                     next
[17:39:23.453]                   args[[name]] <- ""
[17:39:23.453]                 }
[17:39:23.453]                 NAMES <- toupper(removed)
[17:39:23.453]                 for (kk in seq_along(NAMES)) {
[17:39:23.453]                   name <- removed[[kk]]
[17:39:23.453]                   NAME <- NAMES[[kk]]
[17:39:23.453]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.453]                     next
[17:39:23.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.453]                 }
[17:39:23.453]                 if (length(args) > 0) 
[17:39:23.453]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.453]             }
[17:39:23.453]             else {
[17:39:23.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.453]             }
[17:39:23.453]             {
[17:39:23.453]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.453]                   0L) {
[17:39:23.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.453]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.453]                   base::options(opts)
[17:39:23.453]                 }
[17:39:23.453]                 {
[17:39:23.453]                   {
[17:39:23.453]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.453]                     NULL
[17:39:23.453]                   }
[17:39:23.453]                   options(future.plan = NULL)
[17:39:23.453]                   if (is.na(NA_character_)) 
[17:39:23.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.453]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.453]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.453]                     envir = parent.frame()) 
[17:39:23.453]                   {
[17:39:23.453]                     if (is.function(workers)) 
[17:39:23.453]                       workers <- workers()
[17:39:23.453]                     workers <- structure(as.integer(workers), 
[17:39:23.453]                       class = class(workers))
[17:39:23.453]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.453]                       workers >= 1)
[17:39:23.453]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.453]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.453]                     }
[17:39:23.453]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.453]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.453]                       envir = envir)
[17:39:23.453]                     if (!future$lazy) 
[17:39:23.453]                       future <- run(future)
[17:39:23.453]                     invisible(future)
[17:39:23.453]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.453]                 }
[17:39:23.453]             }
[17:39:23.453]         }
[17:39:23.453]     })
[17:39:23.453]     if (TRUE) {
[17:39:23.453]         base::sink(type = "output", split = FALSE)
[17:39:23.453]         if (TRUE) {
[17:39:23.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.453]         }
[17:39:23.453]         else {
[17:39:23.453]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.453]         }
[17:39:23.453]         base::close(...future.stdout)
[17:39:23.453]         ...future.stdout <- NULL
[17:39:23.453]     }
[17:39:23.453]     ...future.result$conditions <- ...future.conditions
[17:39:23.453]     ...future.result$finished <- base::Sys.time()
[17:39:23.453]     ...future.result
[17:39:23.453] }
[17:39:23.456] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:39:23.456] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:23.456] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.456] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:39:23.457] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:39:23.457] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[17:39:23.457] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[17:39:23.457] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:23.457] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.458] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:39:23.458] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:39:23.458] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:39:23.458] MultisessionFuture started
[17:39:23.458] - Launch lazy future ... done
[17:39:23.459] run() for ‘MultisessionFuture’ ... done
[17:39:23.459] Created future:
[17:39:23.459] MultisessionFuture:
[17:39:23.459] Label: ‘future_apply-2’
[17:39:23.459] Expression:
[17:39:23.459] {
[17:39:23.459]     do.call(function(...) {
[17:39:23.459]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.459]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.459]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.459]             on.exit(options(oopts), add = TRUE)
[17:39:23.459]         }
[17:39:23.459]         {
[17:39:23.459]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.459]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.459]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.459]             })
[17:39:23.459]         }
[17:39:23.459]     }, args = future.call.arguments)
[17:39:23.459] }
[17:39:23.459] Lazy evaluation: FALSE
[17:39:23.459] Asynchronous evaluation: TRUE
[17:39:23.459] Local evaluation: TRUE
[17:39:23.459] Environment: R_GlobalEnv
[17:39:23.459] Capture standard output: TRUE
[17:39:23.459] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.459] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:23.459] Packages: <none>
[17:39:23.459] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.459] Resolved: FALSE
[17:39:23.459] Value: <not collected>
[17:39:23.459] Conditions captured: <none>
[17:39:23.459] Early signaling: FALSE
[17:39:23.459] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.459] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.471] Chunk #2 of 2 ... DONE
[17:39:23.471] Launching 2 futures (chunks) ... DONE
[17:39:23.471] Resolving 2 futures (chunks) ...
[17:39:23.471] resolve() on list ...
[17:39:23.471]  recursive: 0
[17:39:23.472]  length: 2
[17:39:23.472] 
[17:39:23.472] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.472] - Validating connection of MultisessionFuture
[17:39:23.472] - received message: FutureResult
[17:39:23.473] - Received FutureResult
[17:39:23.473] - Erased future from FutureRegistry
[17:39:23.473] result() for ClusterFuture ...
[17:39:23.473] - result already collected: FutureResult
[17:39:23.473] result() for ClusterFuture ... done
[17:39:23.473] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.473] Future #1
[17:39:23.473] result() for ClusterFuture ...
[17:39:23.473] - result already collected: FutureResult
[17:39:23.473] result() for ClusterFuture ... done
[17:39:23.473] result() for ClusterFuture ...
[17:39:23.474] - result already collected: FutureResult
[17:39:23.474] result() for ClusterFuture ... done
[17:39:23.474] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:23.474] - nx: 2
[17:39:23.474] - relay: TRUE
[17:39:23.474] - stdout: TRUE
[17:39:23.474] - signal: TRUE
[17:39:23.474] - resignal: FALSE
[17:39:23.474] - force: TRUE
[17:39:23.474] - relayed: [n=2] FALSE, FALSE
[17:39:23.474] - queued futures: [n=2] FALSE, FALSE
[17:39:23.474]  - until=1
[17:39:23.475]  - relaying element #1
[17:39:23.475] result() for ClusterFuture ...
[17:39:23.475] - result already collected: FutureResult
[17:39:23.475] result() for ClusterFuture ... done
[17:39:23.475] result() for ClusterFuture ...
[17:39:23.475] - result already collected: FutureResult
[17:39:23.475] result() for ClusterFuture ... done
[17:39:23.475] result() for ClusterFuture ...
[17:39:23.475] - result already collected: FutureResult
[17:39:23.475] result() for ClusterFuture ... done
[17:39:23.476] result() for ClusterFuture ...
[17:39:23.476] - result already collected: FutureResult
[17:39:23.476] result() for ClusterFuture ... done
[17:39:23.476] - relayed: [n=2] TRUE, FALSE
[17:39:23.476] - queued futures: [n=2] TRUE, FALSE
[17:39:23.476] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:23.476]  length: 1 (resolved future 1)
[17:39:23.503] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.504] - Validating connection of MultisessionFuture
[17:39:23.504] - received message: FutureResult
[17:39:23.504] - Received FutureResult
[17:39:23.504] - Erased future from FutureRegistry
[17:39:23.504] result() for ClusterFuture ...
[17:39:23.504] - result already collected: FutureResult
[17:39:23.504] result() for ClusterFuture ... done
[17:39:23.504] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.504] Future #2
[17:39:23.505] result() for ClusterFuture ...
[17:39:23.505] - result already collected: FutureResult
[17:39:23.505] result() for ClusterFuture ... done
[17:39:23.505] result() for ClusterFuture ...
[17:39:23.505] - result already collected: FutureResult
[17:39:23.505] result() for ClusterFuture ... done
[17:39:23.505] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:23.505] - nx: 2
[17:39:23.505] - relay: TRUE
[17:39:23.505] - stdout: TRUE
[17:39:23.505] - signal: TRUE
[17:39:23.505] - resignal: FALSE
[17:39:23.506] - force: TRUE
[17:39:23.506] - relayed: [n=2] TRUE, FALSE
[17:39:23.506] - queued futures: [n=2] TRUE, FALSE
[17:39:23.506]  - until=2
[17:39:23.506]  - relaying element #2
[17:39:23.506] result() for ClusterFuture ...
[17:39:23.506] - result already collected: FutureResult
[17:39:23.506] result() for ClusterFuture ... done
[17:39:23.506] result() for ClusterFuture ...
[17:39:23.506] - result already collected: FutureResult
[17:39:23.506] result() for ClusterFuture ... done
[17:39:23.507] result() for ClusterFuture ...
[17:39:23.507] - result already collected: FutureResult
[17:39:23.507] result() for ClusterFuture ... done
[17:39:23.507] result() for ClusterFuture ...
[17:39:23.507] - result already collected: FutureResult
[17:39:23.507] result() for ClusterFuture ... done
[17:39:23.507] - relayed: [n=2] TRUE, TRUE
[17:39:23.507] - queued futures: [n=2] TRUE, TRUE
[17:39:23.507] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:23.507]  length: 0 (resolved future 2)
[17:39:23.507] Relaying remaining futures
[17:39:23.508] signalConditionsASAP(NULL, pos=0) ...
[17:39:23.508] - nx: 2
[17:39:23.508] - relay: TRUE
[17:39:23.508] - stdout: TRUE
[17:39:23.508] - signal: TRUE
[17:39:23.508] - resignal: FALSE
[17:39:23.508] - force: TRUE
[17:39:23.508] - relayed: [n=2] TRUE, TRUE
[17:39:23.508] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:23.508] - relayed: [n=2] TRUE, TRUE
[17:39:23.508] - queued futures: [n=2] TRUE, TRUE
[17:39:23.509] signalConditionsASAP(NULL, pos=0) ... done
[17:39:23.509] resolve() on list ... DONE
[17:39:23.509] result() for ClusterFuture ...
[17:39:23.509] - result already collected: FutureResult
[17:39:23.509] result() for ClusterFuture ... done
[17:39:23.509] result() for ClusterFuture ...
[17:39:23.509] - result already collected: FutureResult
[17:39:23.509] result() for ClusterFuture ... done
[17:39:23.509] result() for ClusterFuture ...
[17:39:23.509] - result already collected: FutureResult
[17:39:23.509] result() for ClusterFuture ... done
[17:39:23.510] result() for ClusterFuture ...
[17:39:23.510] - result already collected: FutureResult
[17:39:23.510] result() for ClusterFuture ... done
[17:39:23.510]  - Number of value chunks collected: 2
[17:39:23.510] Resolving 2 futures (chunks) ... DONE
[17:39:23.510] Reducing values from 2 chunks ...
[17:39:23.510]  - Number of values collected after concatenation: 6
[17:39:23.510]  - Number of values expected: 6
[17:39:23.510] Reducing values from 2 chunks ... DONE
[17:39:23.510] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:39:23.511] getGlobalsAndPackagesXApply() ...
[17:39:23.511]  - future.globals: TRUE
[17:39:23.511] getGlobalsAndPackages() ...
[17:39:23.511] Searching for globals...
[17:39:23.512] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:39:23.513] Searching for globals ... DONE
[17:39:23.513] Resolving globals: FALSE
[17:39:23.513] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:39:23.513] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:39:23.514] - globals: [1] ‘FUN’
[17:39:23.514] 
[17:39:23.514] getGlobalsAndPackages() ... DONE
[17:39:23.514]  - globals found/used: [n=1] ‘FUN’
[17:39:23.514]  - needed namespaces: [n=0] 
[17:39:23.514] Finding globals ... DONE
[17:39:23.514]  - use_args: TRUE
[17:39:23.514]  - Getting '...' globals ...
[17:39:23.515] resolve() on list ...
[17:39:23.515]  recursive: 0
[17:39:23.515]  length: 1
[17:39:23.515]  elements: ‘...’
[17:39:23.515]  length: 0 (resolved future 1)
[17:39:23.515] resolve() on list ... DONE
[17:39:23.515]    - '...' content: [n=0] 
[17:39:23.515] List of 1
[17:39:23.515]  $ ...: list()
[17:39:23.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.515]  - attr(*, "where")=List of 1
[17:39:23.515]   ..$ ...:<environment: 0x55c794c089f0> 
[17:39:23.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.515]  - attr(*, "resolved")= logi TRUE
[17:39:23.515]  - attr(*, "total_size")= num NA
[17:39:23.518]  - Getting '...' globals ... DONE
[17:39:23.518] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:23.518] List of 2
[17:39:23.518]  $ ...future.FUN:function (x)  
[17:39:23.518]  $ ...          : list()
[17:39:23.518]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.518]  - attr(*, "where")=List of 2
[17:39:23.518]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:23.518]   ..$ ...          :<environment: 0x55c794c089f0> 
[17:39:23.518]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.518]  - attr(*, "resolved")= logi FALSE
[17:39:23.518]  - attr(*, "total_size")= num 1768
[17:39:23.521] Packages to be attached in all futures: [n=0] 
[17:39:23.521] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.524] future_lapply() ...
[17:39:23.528] Number of chunks: 2
[17:39:23.528] getGlobalsAndPackagesXApply() ...
[17:39:23.528]  - future.globals: <name-value list> with names ‘list()’
[17:39:23.528]  - use_args: TRUE
[17:39:23.529] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:23.529] List of 2
[17:39:23.529]  $ ...          : list()
[17:39:23.529]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.529]  $ ...future.FUN:function (x)  
[17:39:23.529]  - attr(*, "where")=List of 2
[17:39:23.529]   ..$ ...          :<environment: 0x55c794c089f0> 
[17:39:23.529]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:39:23.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.529]  - attr(*, "resolved")= logi FALSE
[17:39:23.529]  - attr(*, "total_size")= num NA
[17:39:23.531] Packages to be attached in all futures: [n=0] 
[17:39:23.531] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.532] Number of futures (= number of chunks): 2
[17:39:23.532] Launching 2 futures (chunks) ...
[17:39:23.532] Chunk #1 of 2 ...
[17:39:23.532]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[17:39:23.532]  - seeds: <none>
[17:39:23.532] getGlobalsAndPackages() ...
[17:39:23.532] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.532] Resolving globals: FALSE
[17:39:23.532] Tweak future expression to call with '...' arguments ...
[17:39:23.533] {
[17:39:23.533]     do.call(function(...) {
[17:39:23.533]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.533]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.533]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.533]             on.exit(options(oopts), add = TRUE)
[17:39:23.533]         }
[17:39:23.533]         {
[17:39:23.533]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.533]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.533]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.533]             })
[17:39:23.533]         }
[17:39:23.533]     }, args = future.call.arguments)
[17:39:23.533] }
[17:39:23.533] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.533] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.533] 
[17:39:23.533] getGlobalsAndPackages() ... DONE
[17:39:23.534] run() for ‘Future’ ...
[17:39:23.534] - state: ‘created’
[17:39:23.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.549]   - Field: ‘node’
[17:39:23.549]   - Field: ‘label’
[17:39:23.549]   - Field: ‘local’
[17:39:23.549]   - Field: ‘owner’
[17:39:23.549]   - Field: ‘envir’
[17:39:23.549]   - Field: ‘workers’
[17:39:23.549]   - Field: ‘packages’
[17:39:23.549]   - Field: ‘gc’
[17:39:23.549]   - Field: ‘conditions’
[17:39:23.549]   - Field: ‘persistent’
[17:39:23.549]   - Field: ‘expr’
[17:39:23.550]   - Field: ‘uuid’
[17:39:23.550]   - Field: ‘seed’
[17:39:23.550]   - Field: ‘version’
[17:39:23.550]   - Field: ‘result’
[17:39:23.550]   - Field: ‘asynchronous’
[17:39:23.550]   - Field: ‘calls’
[17:39:23.550]   - Field: ‘globals’
[17:39:23.550]   - Field: ‘stdout’
[17:39:23.550]   - Field: ‘earlySignal’
[17:39:23.550]   - Field: ‘lazy’
[17:39:23.550]   - Field: ‘state’
[17:39:23.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.551] - Launch lazy future ...
[17:39:23.551] Packages needed by the future expression (n = 0): <none>
[17:39:23.551] Packages needed by future strategies (n = 0): <none>
[17:39:23.552] {
[17:39:23.552]     {
[17:39:23.552]         {
[17:39:23.552]             ...future.startTime <- base::Sys.time()
[17:39:23.552]             {
[17:39:23.552]                 {
[17:39:23.552]                   {
[17:39:23.552]                     {
[17:39:23.552]                       base::local({
[17:39:23.552]                         has_future <- base::requireNamespace("future", 
[17:39:23.552]                           quietly = TRUE)
[17:39:23.552]                         if (has_future) {
[17:39:23.552]                           ns <- base::getNamespace("future")
[17:39:23.552]                           version <- ns[[".package"]][["version"]]
[17:39:23.552]                           if (is.null(version)) 
[17:39:23.552]                             version <- utils::packageVersion("future")
[17:39:23.552]                         }
[17:39:23.552]                         else {
[17:39:23.552]                           version <- NULL
[17:39:23.552]                         }
[17:39:23.552]                         if (!has_future || version < "1.8.0") {
[17:39:23.552]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.552]                             "", base::R.version$version.string), 
[17:39:23.552]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.552]                               "release", "version")], collapse = " "), 
[17:39:23.552]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.552]                             info)
[17:39:23.552]                           info <- base::paste(info, collapse = "; ")
[17:39:23.552]                           if (!has_future) {
[17:39:23.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.552]                               info)
[17:39:23.552]                           }
[17:39:23.552]                           else {
[17:39:23.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.552]                               info, version)
[17:39:23.552]                           }
[17:39:23.552]                           base::stop(msg)
[17:39:23.552]                         }
[17:39:23.552]                       })
[17:39:23.552]                     }
[17:39:23.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.552]                     base::options(mc.cores = 1L)
[17:39:23.552]                   }
[17:39:23.552]                   options(future.plan = NULL)
[17:39:23.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.552]                 }
[17:39:23.552]                 ...future.workdir <- getwd()
[17:39:23.552]             }
[17:39:23.552]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.552]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.552]         }
[17:39:23.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.552]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.552]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.552]             base::names(...future.oldOptions))
[17:39:23.552]     }
[17:39:23.552]     if (FALSE) {
[17:39:23.552]     }
[17:39:23.552]     else {
[17:39:23.552]         if (TRUE) {
[17:39:23.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.552]                 open = "w")
[17:39:23.552]         }
[17:39:23.552]         else {
[17:39:23.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.552]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.552]         }
[17:39:23.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.552]             base::sink(type = "output", split = FALSE)
[17:39:23.552]             base::close(...future.stdout)
[17:39:23.552]         }, add = TRUE)
[17:39:23.552]     }
[17:39:23.552]     ...future.frame <- base::sys.nframe()
[17:39:23.552]     ...future.conditions <- base::list()
[17:39:23.552]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.552]     if (FALSE) {
[17:39:23.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.552]     }
[17:39:23.552]     ...future.result <- base::tryCatch({
[17:39:23.552]         base::withCallingHandlers({
[17:39:23.552]             ...future.value <- base::withVisible(base::local({
[17:39:23.552]                 ...future.makeSendCondition <- local({
[17:39:23.552]                   sendCondition <- NULL
[17:39:23.552]                   function(frame = 1L) {
[17:39:23.552]                     if (is.function(sendCondition)) 
[17:39:23.552]                       return(sendCondition)
[17:39:23.552]                     ns <- getNamespace("parallel")
[17:39:23.552]                     if (exists("sendData", mode = "function", 
[17:39:23.552]                       envir = ns)) {
[17:39:23.552]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.552]                         envir = ns)
[17:39:23.552]                       envir <- sys.frame(frame)
[17:39:23.552]                       master <- NULL
[17:39:23.552]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.552]                         !identical(envir, emptyenv())) {
[17:39:23.552]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.552]                           inherits = FALSE)) {
[17:39:23.552]                           master <- get("master", mode = "list", 
[17:39:23.552]                             envir = envir, inherits = FALSE)
[17:39:23.552]                           if (inherits(master, c("SOCKnode", 
[17:39:23.552]                             "SOCK0node"))) {
[17:39:23.552]                             sendCondition <<- function(cond) {
[17:39:23.552]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.552]                                 success = TRUE)
[17:39:23.552]                               parallel_sendData(master, data)
[17:39:23.552]                             }
[17:39:23.552]                             return(sendCondition)
[17:39:23.552]                           }
[17:39:23.552]                         }
[17:39:23.552]                         frame <- frame + 1L
[17:39:23.552]                         envir <- sys.frame(frame)
[17:39:23.552]                       }
[17:39:23.552]                     }
[17:39:23.552]                     sendCondition <<- function(cond) NULL
[17:39:23.552]                   }
[17:39:23.552]                 })
[17:39:23.552]                 withCallingHandlers({
[17:39:23.552]                   {
[17:39:23.552]                     do.call(function(...) {
[17:39:23.552]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.552]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.552]                         ...future.globals.maxSize)) {
[17:39:23.552]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.552]                         on.exit(options(oopts), add = TRUE)
[17:39:23.552]                       }
[17:39:23.552]                       {
[17:39:23.552]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.552]                           FUN = function(jj) {
[17:39:23.552]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.552]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.552]                           })
[17:39:23.552]                       }
[17:39:23.552]                     }, args = future.call.arguments)
[17:39:23.552]                   }
[17:39:23.552]                 }, immediateCondition = function(cond) {
[17:39:23.552]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.552]                   sendCondition(cond)
[17:39:23.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.552]                   {
[17:39:23.552]                     inherits <- base::inherits
[17:39:23.552]                     invokeRestart <- base::invokeRestart
[17:39:23.552]                     is.null <- base::is.null
[17:39:23.552]                     muffled <- FALSE
[17:39:23.552]                     if (inherits(cond, "message")) {
[17:39:23.552]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.552]                       if (muffled) 
[17:39:23.552]                         invokeRestart("muffleMessage")
[17:39:23.552]                     }
[17:39:23.552]                     else if (inherits(cond, "warning")) {
[17:39:23.552]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.552]                       if (muffled) 
[17:39:23.552]                         invokeRestart("muffleWarning")
[17:39:23.552]                     }
[17:39:23.552]                     else if (inherits(cond, "condition")) {
[17:39:23.552]                       if (!is.null(pattern)) {
[17:39:23.552]                         computeRestarts <- base::computeRestarts
[17:39:23.552]                         grepl <- base::grepl
[17:39:23.552]                         restarts <- computeRestarts(cond)
[17:39:23.552]                         for (restart in restarts) {
[17:39:23.552]                           name <- restart$name
[17:39:23.552]                           if (is.null(name)) 
[17:39:23.552]                             next
[17:39:23.552]                           if (!grepl(pattern, name)) 
[17:39:23.552]                             next
[17:39:23.552]                           invokeRestart(restart)
[17:39:23.552]                           muffled <- TRUE
[17:39:23.552]                           break
[17:39:23.552]                         }
[17:39:23.552]                       }
[17:39:23.552]                     }
[17:39:23.552]                     invisible(muffled)
[17:39:23.552]                   }
[17:39:23.552]                   muffleCondition(cond)
[17:39:23.552]                 })
[17:39:23.552]             }))
[17:39:23.552]             future::FutureResult(value = ...future.value$value, 
[17:39:23.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.552]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.552]                     ...future.globalenv.names))
[17:39:23.552]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.552]         }, condition = base::local({
[17:39:23.552]             c <- base::c
[17:39:23.552]             inherits <- base::inherits
[17:39:23.552]             invokeRestart <- base::invokeRestart
[17:39:23.552]             length <- base::length
[17:39:23.552]             list <- base::list
[17:39:23.552]             seq.int <- base::seq.int
[17:39:23.552]             signalCondition <- base::signalCondition
[17:39:23.552]             sys.calls <- base::sys.calls
[17:39:23.552]             `[[` <- base::`[[`
[17:39:23.552]             `+` <- base::`+`
[17:39:23.552]             `<<-` <- base::`<<-`
[17:39:23.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.552]                   3L)]
[17:39:23.552]             }
[17:39:23.552]             function(cond) {
[17:39:23.552]                 is_error <- inherits(cond, "error")
[17:39:23.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.552]                   NULL)
[17:39:23.552]                 if (is_error) {
[17:39:23.552]                   sessionInformation <- function() {
[17:39:23.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.552]                       search = base::search(), system = base::Sys.info())
[17:39:23.552]                   }
[17:39:23.552]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.552]                     cond$call), session = sessionInformation(), 
[17:39:23.552]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.552]                   signalCondition(cond)
[17:39:23.552]                 }
[17:39:23.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.552]                 "immediateCondition"))) {
[17:39:23.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.552]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.552]                   if (TRUE && !signal) {
[17:39:23.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.552]                     {
[17:39:23.552]                       inherits <- base::inherits
[17:39:23.552]                       invokeRestart <- base::invokeRestart
[17:39:23.552]                       is.null <- base::is.null
[17:39:23.552]                       muffled <- FALSE
[17:39:23.552]                       if (inherits(cond, "message")) {
[17:39:23.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.552]                         if (muffled) 
[17:39:23.552]                           invokeRestart("muffleMessage")
[17:39:23.552]                       }
[17:39:23.552]                       else if (inherits(cond, "warning")) {
[17:39:23.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.552]                         if (muffled) 
[17:39:23.552]                           invokeRestart("muffleWarning")
[17:39:23.552]                       }
[17:39:23.552]                       else if (inherits(cond, "condition")) {
[17:39:23.552]                         if (!is.null(pattern)) {
[17:39:23.552]                           computeRestarts <- base::computeRestarts
[17:39:23.552]                           grepl <- base::grepl
[17:39:23.552]                           restarts <- computeRestarts(cond)
[17:39:23.552]                           for (restart in restarts) {
[17:39:23.552]                             name <- restart$name
[17:39:23.552]                             if (is.null(name)) 
[17:39:23.552]                               next
[17:39:23.552]                             if (!grepl(pattern, name)) 
[17:39:23.552]                               next
[17:39:23.552]                             invokeRestart(restart)
[17:39:23.552]                             muffled <- TRUE
[17:39:23.552]                             break
[17:39:23.552]                           }
[17:39:23.552]                         }
[17:39:23.552]                       }
[17:39:23.552]                       invisible(muffled)
[17:39:23.552]                     }
[17:39:23.552]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.552]                   }
[17:39:23.552]                 }
[17:39:23.552]                 else {
[17:39:23.552]                   if (TRUE) {
[17:39:23.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.552]                     {
[17:39:23.552]                       inherits <- base::inherits
[17:39:23.552]                       invokeRestart <- base::invokeRestart
[17:39:23.552]                       is.null <- base::is.null
[17:39:23.552]                       muffled <- FALSE
[17:39:23.552]                       if (inherits(cond, "message")) {
[17:39:23.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.552]                         if (muffled) 
[17:39:23.552]                           invokeRestart("muffleMessage")
[17:39:23.552]                       }
[17:39:23.552]                       else if (inherits(cond, "warning")) {
[17:39:23.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.552]                         if (muffled) 
[17:39:23.552]                           invokeRestart("muffleWarning")
[17:39:23.552]                       }
[17:39:23.552]                       else if (inherits(cond, "condition")) {
[17:39:23.552]                         if (!is.null(pattern)) {
[17:39:23.552]                           computeRestarts <- base::computeRestarts
[17:39:23.552]                           grepl <- base::grepl
[17:39:23.552]                           restarts <- computeRestarts(cond)
[17:39:23.552]                           for (restart in restarts) {
[17:39:23.552]                             name <- restart$name
[17:39:23.552]                             if (is.null(name)) 
[17:39:23.552]                               next
[17:39:23.552]                             if (!grepl(pattern, name)) 
[17:39:23.552]                               next
[17:39:23.552]                             invokeRestart(restart)
[17:39:23.552]                             muffled <- TRUE
[17:39:23.552]                             break
[17:39:23.552]                           }
[17:39:23.552]                         }
[17:39:23.552]                       }
[17:39:23.552]                       invisible(muffled)
[17:39:23.552]                     }
[17:39:23.552]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.552]                   }
[17:39:23.552]                 }
[17:39:23.552]             }
[17:39:23.552]         }))
[17:39:23.552]     }, error = function(ex) {
[17:39:23.552]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.552]                 ...future.rng), started = ...future.startTime, 
[17:39:23.552]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.552]             version = "1.8"), class = "FutureResult")
[17:39:23.552]     }, finally = {
[17:39:23.552]         if (!identical(...future.workdir, getwd())) 
[17:39:23.552]             setwd(...future.workdir)
[17:39:23.552]         {
[17:39:23.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.552]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.552]             }
[17:39:23.552]             base::options(...future.oldOptions)
[17:39:23.552]             if (.Platform$OS.type == "windows") {
[17:39:23.552]                 old_names <- names(...future.oldEnvVars)
[17:39:23.552]                 envs <- base::Sys.getenv()
[17:39:23.552]                 names <- names(envs)
[17:39:23.552]                 common <- intersect(names, old_names)
[17:39:23.552]                 added <- setdiff(names, old_names)
[17:39:23.552]                 removed <- setdiff(old_names, names)
[17:39:23.552]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.552]                   envs[common]]
[17:39:23.552]                 NAMES <- toupper(changed)
[17:39:23.552]                 args <- list()
[17:39:23.552]                 for (kk in seq_along(NAMES)) {
[17:39:23.552]                   name <- changed[[kk]]
[17:39:23.552]                   NAME <- NAMES[[kk]]
[17:39:23.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.552]                     next
[17:39:23.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.552]                 }
[17:39:23.552]                 NAMES <- toupper(added)
[17:39:23.552]                 for (kk in seq_along(NAMES)) {
[17:39:23.552]                   name <- added[[kk]]
[17:39:23.552]                   NAME <- NAMES[[kk]]
[17:39:23.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.552]                     next
[17:39:23.552]                   args[[name]] <- ""
[17:39:23.552]                 }
[17:39:23.552]                 NAMES <- toupper(removed)
[17:39:23.552]                 for (kk in seq_along(NAMES)) {
[17:39:23.552]                   name <- removed[[kk]]
[17:39:23.552]                   NAME <- NAMES[[kk]]
[17:39:23.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.552]                     next
[17:39:23.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.552]                 }
[17:39:23.552]                 if (length(args) > 0) 
[17:39:23.552]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.552]             }
[17:39:23.552]             else {
[17:39:23.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.552]             }
[17:39:23.552]             {
[17:39:23.552]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.552]                   0L) {
[17:39:23.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.552]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.552]                   base::options(opts)
[17:39:23.552]                 }
[17:39:23.552]                 {
[17:39:23.552]                   {
[17:39:23.552]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.552]                     NULL
[17:39:23.552]                   }
[17:39:23.552]                   options(future.plan = NULL)
[17:39:23.552]                   if (is.na(NA_character_)) 
[17:39:23.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.552]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.552]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.552]                     envir = parent.frame()) 
[17:39:23.552]                   {
[17:39:23.552]                     if (is.function(workers)) 
[17:39:23.552]                       workers <- workers()
[17:39:23.552]                     workers <- structure(as.integer(workers), 
[17:39:23.552]                       class = class(workers))
[17:39:23.552]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.552]                       workers >= 1)
[17:39:23.552]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.552]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.552]                     }
[17:39:23.552]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.552]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.552]                       envir = envir)
[17:39:23.552]                     if (!future$lazy) 
[17:39:23.552]                       future <- run(future)
[17:39:23.552]                     invisible(future)
[17:39:23.552]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.552]                 }
[17:39:23.552]             }
[17:39:23.552]         }
[17:39:23.552]     })
[17:39:23.552]     if (TRUE) {
[17:39:23.552]         base::sink(type = "output", split = FALSE)
[17:39:23.552]         if (TRUE) {
[17:39:23.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.552]         }
[17:39:23.552]         else {
[17:39:23.552]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.552]         }
[17:39:23.552]         base::close(...future.stdout)
[17:39:23.552]         ...future.stdout <- NULL
[17:39:23.552]     }
[17:39:23.552]     ...future.result$conditions <- ...future.conditions
[17:39:23.552]     ...future.result$finished <- base::Sys.time()
[17:39:23.552]     ...future.result
[17:39:23.552] }
[17:39:23.555] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[17:39:23.555] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:23.555] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.555] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[17:39:23.556] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[17:39:23.556] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[17:39:23.556] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[17:39:23.556] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:23.557] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.557] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:39:23.557] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:39:23.557] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[17:39:23.558] MultisessionFuture started
[17:39:23.558] - Launch lazy future ... done
[17:39:23.558] run() for ‘MultisessionFuture’ ... done
[17:39:23.558] Created future:
[17:39:23.558] MultisessionFuture:
[17:39:23.558] Label: ‘future_apply-1’
[17:39:23.558] Expression:
[17:39:23.558] {
[17:39:23.558]     do.call(function(...) {
[17:39:23.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.558]             on.exit(options(oopts), add = TRUE)
[17:39:23.558]         }
[17:39:23.558]         {
[17:39:23.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.558]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.558]             })
[17:39:23.558]         }
[17:39:23.558]     }, args = future.call.arguments)
[17:39:23.558] }
[17:39:23.558] Lazy evaluation: FALSE
[17:39:23.558] Asynchronous evaluation: TRUE
[17:39:23.558] Local evaluation: TRUE
[17:39:23.558] Environment: R_GlobalEnv
[17:39:23.558] Capture standard output: TRUE
[17:39:23.558] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.558] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:23.558] Packages: <none>
[17:39:23.558] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.558] Resolved: FALSE
[17:39:23.558] Value: <not collected>
[17:39:23.558] Conditions captured: <none>
[17:39:23.558] Early signaling: FALSE
[17:39:23.558] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.558] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.570] Chunk #1 of 2 ... DONE
[17:39:23.570] Chunk #2 of 2 ...
[17:39:23.570]  - Adjusted option 'future.globals.maxSize': Inf -> 3 * Inf = Inf (bytes)
[17:39:23.570]  - seeds: <none>
[17:39:23.570] getGlobalsAndPackages() ...
[17:39:23.570] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.570] Resolving globals: FALSE
[17:39:23.570] Tweak future expression to call with '...' arguments ...
[17:39:23.571] {
[17:39:23.571]     do.call(function(...) {
[17:39:23.571]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.571]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.571]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.571]             on.exit(options(oopts), add = TRUE)
[17:39:23.571]         }
[17:39:23.571]         {
[17:39:23.571]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.571]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.571]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.571]             })
[17:39:23.571]         }
[17:39:23.571]     }, args = future.call.arguments)
[17:39:23.571] }
[17:39:23.571] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.571] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.571] 
[17:39:23.571] getGlobalsAndPackages() ... DONE
[17:39:23.572] run() for ‘Future’ ...
[17:39:23.572] - state: ‘created’
[17:39:23.572] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.586] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.587]   - Field: ‘node’
[17:39:23.587]   - Field: ‘label’
[17:39:23.587]   - Field: ‘local’
[17:39:23.587]   - Field: ‘owner’
[17:39:23.587]   - Field: ‘envir’
[17:39:23.587]   - Field: ‘workers’
[17:39:23.587]   - Field: ‘packages’
[17:39:23.587]   - Field: ‘gc’
[17:39:23.587]   - Field: ‘conditions’
[17:39:23.587]   - Field: ‘persistent’
[17:39:23.588]   - Field: ‘expr’
[17:39:23.588]   - Field: ‘uuid’
[17:39:23.588]   - Field: ‘seed’
[17:39:23.588]   - Field: ‘version’
[17:39:23.588]   - Field: ‘result’
[17:39:23.588]   - Field: ‘asynchronous’
[17:39:23.588]   - Field: ‘calls’
[17:39:23.588]   - Field: ‘globals’
[17:39:23.588]   - Field: ‘stdout’
[17:39:23.588]   - Field: ‘earlySignal’
[17:39:23.588]   - Field: ‘lazy’
[17:39:23.589]   - Field: ‘state’
[17:39:23.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.589] - Launch lazy future ...
[17:39:23.589] Packages needed by the future expression (n = 0): <none>
[17:39:23.589] Packages needed by future strategies (n = 0): <none>
[17:39:23.590] {
[17:39:23.590]     {
[17:39:23.590]         {
[17:39:23.590]             ...future.startTime <- base::Sys.time()
[17:39:23.590]             {
[17:39:23.590]                 {
[17:39:23.590]                   {
[17:39:23.590]                     {
[17:39:23.590]                       base::local({
[17:39:23.590]                         has_future <- base::requireNamespace("future", 
[17:39:23.590]                           quietly = TRUE)
[17:39:23.590]                         if (has_future) {
[17:39:23.590]                           ns <- base::getNamespace("future")
[17:39:23.590]                           version <- ns[[".package"]][["version"]]
[17:39:23.590]                           if (is.null(version)) 
[17:39:23.590]                             version <- utils::packageVersion("future")
[17:39:23.590]                         }
[17:39:23.590]                         else {
[17:39:23.590]                           version <- NULL
[17:39:23.590]                         }
[17:39:23.590]                         if (!has_future || version < "1.8.0") {
[17:39:23.590]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.590]                             "", base::R.version$version.string), 
[17:39:23.590]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.590]                               "release", "version")], collapse = " "), 
[17:39:23.590]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.590]                             info)
[17:39:23.590]                           info <- base::paste(info, collapse = "; ")
[17:39:23.590]                           if (!has_future) {
[17:39:23.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.590]                               info)
[17:39:23.590]                           }
[17:39:23.590]                           else {
[17:39:23.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.590]                               info, version)
[17:39:23.590]                           }
[17:39:23.590]                           base::stop(msg)
[17:39:23.590]                         }
[17:39:23.590]                       })
[17:39:23.590]                     }
[17:39:23.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.590]                     base::options(mc.cores = 1L)
[17:39:23.590]                   }
[17:39:23.590]                   options(future.plan = NULL)
[17:39:23.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.590]                 }
[17:39:23.590]                 ...future.workdir <- getwd()
[17:39:23.590]             }
[17:39:23.590]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.590]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.590]         }
[17:39:23.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.590]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.590]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.590]             base::names(...future.oldOptions))
[17:39:23.590]     }
[17:39:23.590]     if (FALSE) {
[17:39:23.590]     }
[17:39:23.590]     else {
[17:39:23.590]         if (TRUE) {
[17:39:23.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.590]                 open = "w")
[17:39:23.590]         }
[17:39:23.590]         else {
[17:39:23.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.590]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.590]         }
[17:39:23.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.590]             base::sink(type = "output", split = FALSE)
[17:39:23.590]             base::close(...future.stdout)
[17:39:23.590]         }, add = TRUE)
[17:39:23.590]     }
[17:39:23.590]     ...future.frame <- base::sys.nframe()
[17:39:23.590]     ...future.conditions <- base::list()
[17:39:23.590]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.590]     if (FALSE) {
[17:39:23.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.590]     }
[17:39:23.590]     ...future.result <- base::tryCatch({
[17:39:23.590]         base::withCallingHandlers({
[17:39:23.590]             ...future.value <- base::withVisible(base::local({
[17:39:23.590]                 ...future.makeSendCondition <- local({
[17:39:23.590]                   sendCondition <- NULL
[17:39:23.590]                   function(frame = 1L) {
[17:39:23.590]                     if (is.function(sendCondition)) 
[17:39:23.590]                       return(sendCondition)
[17:39:23.590]                     ns <- getNamespace("parallel")
[17:39:23.590]                     if (exists("sendData", mode = "function", 
[17:39:23.590]                       envir = ns)) {
[17:39:23.590]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.590]                         envir = ns)
[17:39:23.590]                       envir <- sys.frame(frame)
[17:39:23.590]                       master <- NULL
[17:39:23.590]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.590]                         !identical(envir, emptyenv())) {
[17:39:23.590]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.590]                           inherits = FALSE)) {
[17:39:23.590]                           master <- get("master", mode = "list", 
[17:39:23.590]                             envir = envir, inherits = FALSE)
[17:39:23.590]                           if (inherits(master, c("SOCKnode", 
[17:39:23.590]                             "SOCK0node"))) {
[17:39:23.590]                             sendCondition <<- function(cond) {
[17:39:23.590]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.590]                                 success = TRUE)
[17:39:23.590]                               parallel_sendData(master, data)
[17:39:23.590]                             }
[17:39:23.590]                             return(sendCondition)
[17:39:23.590]                           }
[17:39:23.590]                         }
[17:39:23.590]                         frame <- frame + 1L
[17:39:23.590]                         envir <- sys.frame(frame)
[17:39:23.590]                       }
[17:39:23.590]                     }
[17:39:23.590]                     sendCondition <<- function(cond) NULL
[17:39:23.590]                   }
[17:39:23.590]                 })
[17:39:23.590]                 withCallingHandlers({
[17:39:23.590]                   {
[17:39:23.590]                     do.call(function(...) {
[17:39:23.590]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.590]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.590]                         ...future.globals.maxSize)) {
[17:39:23.590]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.590]                         on.exit(options(oopts), add = TRUE)
[17:39:23.590]                       }
[17:39:23.590]                       {
[17:39:23.590]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.590]                           FUN = function(jj) {
[17:39:23.590]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.590]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.590]                           })
[17:39:23.590]                       }
[17:39:23.590]                     }, args = future.call.arguments)
[17:39:23.590]                   }
[17:39:23.590]                 }, immediateCondition = function(cond) {
[17:39:23.590]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.590]                   sendCondition(cond)
[17:39:23.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.590]                   {
[17:39:23.590]                     inherits <- base::inherits
[17:39:23.590]                     invokeRestart <- base::invokeRestart
[17:39:23.590]                     is.null <- base::is.null
[17:39:23.590]                     muffled <- FALSE
[17:39:23.590]                     if (inherits(cond, "message")) {
[17:39:23.590]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.590]                       if (muffled) 
[17:39:23.590]                         invokeRestart("muffleMessage")
[17:39:23.590]                     }
[17:39:23.590]                     else if (inherits(cond, "warning")) {
[17:39:23.590]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.590]                       if (muffled) 
[17:39:23.590]                         invokeRestart("muffleWarning")
[17:39:23.590]                     }
[17:39:23.590]                     else if (inherits(cond, "condition")) {
[17:39:23.590]                       if (!is.null(pattern)) {
[17:39:23.590]                         computeRestarts <- base::computeRestarts
[17:39:23.590]                         grepl <- base::grepl
[17:39:23.590]                         restarts <- computeRestarts(cond)
[17:39:23.590]                         for (restart in restarts) {
[17:39:23.590]                           name <- restart$name
[17:39:23.590]                           if (is.null(name)) 
[17:39:23.590]                             next
[17:39:23.590]                           if (!grepl(pattern, name)) 
[17:39:23.590]                             next
[17:39:23.590]                           invokeRestart(restart)
[17:39:23.590]                           muffled <- TRUE
[17:39:23.590]                           break
[17:39:23.590]                         }
[17:39:23.590]                       }
[17:39:23.590]                     }
[17:39:23.590]                     invisible(muffled)
[17:39:23.590]                   }
[17:39:23.590]                   muffleCondition(cond)
[17:39:23.590]                 })
[17:39:23.590]             }))
[17:39:23.590]             future::FutureResult(value = ...future.value$value, 
[17:39:23.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.590]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.590]                     ...future.globalenv.names))
[17:39:23.590]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.590]         }, condition = base::local({
[17:39:23.590]             c <- base::c
[17:39:23.590]             inherits <- base::inherits
[17:39:23.590]             invokeRestart <- base::invokeRestart
[17:39:23.590]             length <- base::length
[17:39:23.590]             list <- base::list
[17:39:23.590]             seq.int <- base::seq.int
[17:39:23.590]             signalCondition <- base::signalCondition
[17:39:23.590]             sys.calls <- base::sys.calls
[17:39:23.590]             `[[` <- base::`[[`
[17:39:23.590]             `+` <- base::`+`
[17:39:23.590]             `<<-` <- base::`<<-`
[17:39:23.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.590]                   3L)]
[17:39:23.590]             }
[17:39:23.590]             function(cond) {
[17:39:23.590]                 is_error <- inherits(cond, "error")
[17:39:23.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.590]                   NULL)
[17:39:23.590]                 if (is_error) {
[17:39:23.590]                   sessionInformation <- function() {
[17:39:23.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.590]                       search = base::search(), system = base::Sys.info())
[17:39:23.590]                   }
[17:39:23.590]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.590]                     cond$call), session = sessionInformation(), 
[17:39:23.590]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.590]                   signalCondition(cond)
[17:39:23.590]                 }
[17:39:23.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.590]                 "immediateCondition"))) {
[17:39:23.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.590]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.590]                   if (TRUE && !signal) {
[17:39:23.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.590]                     {
[17:39:23.590]                       inherits <- base::inherits
[17:39:23.590]                       invokeRestart <- base::invokeRestart
[17:39:23.590]                       is.null <- base::is.null
[17:39:23.590]                       muffled <- FALSE
[17:39:23.590]                       if (inherits(cond, "message")) {
[17:39:23.590]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.590]                         if (muffled) 
[17:39:23.590]                           invokeRestart("muffleMessage")
[17:39:23.590]                       }
[17:39:23.590]                       else if (inherits(cond, "warning")) {
[17:39:23.590]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.590]                         if (muffled) 
[17:39:23.590]                           invokeRestart("muffleWarning")
[17:39:23.590]                       }
[17:39:23.590]                       else if (inherits(cond, "condition")) {
[17:39:23.590]                         if (!is.null(pattern)) {
[17:39:23.590]                           computeRestarts <- base::computeRestarts
[17:39:23.590]                           grepl <- base::grepl
[17:39:23.590]                           restarts <- computeRestarts(cond)
[17:39:23.590]                           for (restart in restarts) {
[17:39:23.590]                             name <- restart$name
[17:39:23.590]                             if (is.null(name)) 
[17:39:23.590]                               next
[17:39:23.590]                             if (!grepl(pattern, name)) 
[17:39:23.590]                               next
[17:39:23.590]                             invokeRestart(restart)
[17:39:23.590]                             muffled <- TRUE
[17:39:23.590]                             break
[17:39:23.590]                           }
[17:39:23.590]                         }
[17:39:23.590]                       }
[17:39:23.590]                       invisible(muffled)
[17:39:23.590]                     }
[17:39:23.590]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.590]                   }
[17:39:23.590]                 }
[17:39:23.590]                 else {
[17:39:23.590]                   if (TRUE) {
[17:39:23.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.590]                     {
[17:39:23.590]                       inherits <- base::inherits
[17:39:23.590]                       invokeRestart <- base::invokeRestart
[17:39:23.590]                       is.null <- base::is.null
[17:39:23.590]                       muffled <- FALSE
[17:39:23.590]                       if (inherits(cond, "message")) {
[17:39:23.590]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.590]                         if (muffled) 
[17:39:23.590]                           invokeRestart("muffleMessage")
[17:39:23.590]                       }
[17:39:23.590]                       else if (inherits(cond, "warning")) {
[17:39:23.590]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.590]                         if (muffled) 
[17:39:23.590]                           invokeRestart("muffleWarning")
[17:39:23.590]                       }
[17:39:23.590]                       else if (inherits(cond, "condition")) {
[17:39:23.590]                         if (!is.null(pattern)) {
[17:39:23.590]                           computeRestarts <- base::computeRestarts
[17:39:23.590]                           grepl <- base::grepl
[17:39:23.590]                           restarts <- computeRestarts(cond)
[17:39:23.590]                           for (restart in restarts) {
[17:39:23.590]                             name <- restart$name
[17:39:23.590]                             if (is.null(name)) 
[17:39:23.590]                               next
[17:39:23.590]                             if (!grepl(pattern, name)) 
[17:39:23.590]                               next
[17:39:23.590]                             invokeRestart(restart)
[17:39:23.590]                             muffled <- TRUE
[17:39:23.590]                             break
[17:39:23.590]                           }
[17:39:23.590]                         }
[17:39:23.590]                       }
[17:39:23.590]                       invisible(muffled)
[17:39:23.590]                     }
[17:39:23.590]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.590]                   }
[17:39:23.590]                 }
[17:39:23.590]             }
[17:39:23.590]         }))
[17:39:23.590]     }, error = function(ex) {
[17:39:23.590]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.590]                 ...future.rng), started = ...future.startTime, 
[17:39:23.590]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.590]             version = "1.8"), class = "FutureResult")
[17:39:23.590]     }, finally = {
[17:39:23.590]         if (!identical(...future.workdir, getwd())) 
[17:39:23.590]             setwd(...future.workdir)
[17:39:23.590]         {
[17:39:23.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.590]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.590]             }
[17:39:23.590]             base::options(...future.oldOptions)
[17:39:23.590]             if (.Platform$OS.type == "windows") {
[17:39:23.590]                 old_names <- names(...future.oldEnvVars)
[17:39:23.590]                 envs <- base::Sys.getenv()
[17:39:23.590]                 names <- names(envs)
[17:39:23.590]                 common <- intersect(names, old_names)
[17:39:23.590]                 added <- setdiff(names, old_names)
[17:39:23.590]                 removed <- setdiff(old_names, names)
[17:39:23.590]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.590]                   envs[common]]
[17:39:23.590]                 NAMES <- toupper(changed)
[17:39:23.590]                 args <- list()
[17:39:23.590]                 for (kk in seq_along(NAMES)) {
[17:39:23.590]                   name <- changed[[kk]]
[17:39:23.590]                   NAME <- NAMES[[kk]]
[17:39:23.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.590]                     next
[17:39:23.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.590]                 }
[17:39:23.590]                 NAMES <- toupper(added)
[17:39:23.590]                 for (kk in seq_along(NAMES)) {
[17:39:23.590]                   name <- added[[kk]]
[17:39:23.590]                   NAME <- NAMES[[kk]]
[17:39:23.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.590]                     next
[17:39:23.590]                   args[[name]] <- ""
[17:39:23.590]                 }
[17:39:23.590]                 NAMES <- toupper(removed)
[17:39:23.590]                 for (kk in seq_along(NAMES)) {
[17:39:23.590]                   name <- removed[[kk]]
[17:39:23.590]                   NAME <- NAMES[[kk]]
[17:39:23.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.590]                     next
[17:39:23.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.590]                 }
[17:39:23.590]                 if (length(args) > 0) 
[17:39:23.590]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.590]             }
[17:39:23.590]             else {
[17:39:23.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.590]             }
[17:39:23.590]             {
[17:39:23.590]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.590]                   0L) {
[17:39:23.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.590]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.590]                   base::options(opts)
[17:39:23.590]                 }
[17:39:23.590]                 {
[17:39:23.590]                   {
[17:39:23.590]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.590]                     NULL
[17:39:23.590]                   }
[17:39:23.590]                   options(future.plan = NULL)
[17:39:23.590]                   if (is.na(NA_character_)) 
[17:39:23.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.590]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.590]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.590]                     envir = parent.frame()) 
[17:39:23.590]                   {
[17:39:23.590]                     if (is.function(workers)) 
[17:39:23.590]                       workers <- workers()
[17:39:23.590]                     workers <- structure(as.integer(workers), 
[17:39:23.590]                       class = class(workers))
[17:39:23.590]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.590]                       workers >= 1)
[17:39:23.590]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.590]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.590]                     }
[17:39:23.590]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.590]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.590]                       envir = envir)
[17:39:23.590]                     if (!future$lazy) 
[17:39:23.590]                       future <- run(future)
[17:39:23.590]                     invisible(future)
[17:39:23.590]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.590]                 }
[17:39:23.590]             }
[17:39:23.590]         }
[17:39:23.590]     })
[17:39:23.590]     if (TRUE) {
[17:39:23.590]         base::sink(type = "output", split = FALSE)
[17:39:23.590]         if (TRUE) {
[17:39:23.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.590]         }
[17:39:23.590]         else {
[17:39:23.590]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.590]         }
[17:39:23.590]         base::close(...future.stdout)
[17:39:23.590]         ...future.stdout <- NULL
[17:39:23.590]     }
[17:39:23.590]     ...future.result$conditions <- ...future.conditions
[17:39:23.590]     ...future.result$finished <- base::Sys.time()
[17:39:23.590]     ...future.result
[17:39:23.590] }
[17:39:23.593] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[17:39:23.593] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:23.593] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.593] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[17:39:23.594] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[17:39:23.594] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[17:39:23.594] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[17:39:23.595] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:23.595] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.595] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:39:23.595] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:39:23.595] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[17:39:23.596] MultisessionFuture started
[17:39:23.596] - Launch lazy future ... done
[17:39:23.596] run() for ‘MultisessionFuture’ ... done
[17:39:23.597] Created future:
[17:39:23.597] MultisessionFuture:
[17:39:23.597] Label: ‘future_apply-2’
[17:39:23.597] Expression:
[17:39:23.597] {
[17:39:23.597]     do.call(function(...) {
[17:39:23.597]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.597]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.597]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.597]             on.exit(options(oopts), add = TRUE)
[17:39:23.597]         }
[17:39:23.597]         {
[17:39:23.597]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.597]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.597]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.597]             })
[17:39:23.597]         }
[17:39:23.597]     }, args = future.call.arguments)
[17:39:23.597] }
[17:39:23.597] Lazy evaluation: FALSE
[17:39:23.597] Asynchronous evaluation: TRUE
[17:39:23.597] Local evaluation: TRUE
[17:39:23.597] Environment: R_GlobalEnv
[17:39:23.597] Capture standard output: TRUE
[17:39:23.597] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.597] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:39:23.597] Packages: <none>
[17:39:23.597] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.597] Resolved: FALSE
[17:39:23.597] Value: <not collected>
[17:39:23.597] Conditions captured: <none>
[17:39:23.597] Early signaling: FALSE
[17:39:23.597] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.597] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.608] Chunk #2 of 2 ... DONE
[17:39:23.608] Launching 2 futures (chunks) ... DONE
[17:39:23.608] Resolving 2 futures (chunks) ...
[17:39:23.608] resolve() on list ...
[17:39:23.608]  recursive: 0
[17:39:23.609]  length: 2
[17:39:23.609] 
[17:39:23.609] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.609] - Validating connection of MultisessionFuture
[17:39:23.609] - received message: FutureResult
[17:39:23.610] - Received FutureResult
[17:39:23.610] - Erased future from FutureRegistry
[17:39:23.610] result() for ClusterFuture ...
[17:39:23.610] - result already collected: FutureResult
[17:39:23.610] result() for ClusterFuture ... done
[17:39:23.610] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.610] Future #1
[17:39:23.610] result() for ClusterFuture ...
[17:39:23.610] - result already collected: FutureResult
[17:39:23.610] result() for ClusterFuture ... done
[17:39:23.611] result() for ClusterFuture ...
[17:39:23.611] - result already collected: FutureResult
[17:39:23.611] result() for ClusterFuture ... done
[17:39:23.611] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:23.611] - nx: 2
[17:39:23.611] - relay: TRUE
[17:39:23.611] - stdout: TRUE
[17:39:23.611] - signal: TRUE
[17:39:23.611] - resignal: FALSE
[17:39:23.611] - force: TRUE
[17:39:23.611] - relayed: [n=2] FALSE, FALSE
[17:39:23.612] - queued futures: [n=2] FALSE, FALSE
[17:39:23.612]  - until=1
[17:39:23.612]  - relaying element #1
[17:39:23.612] result() for ClusterFuture ...
[17:39:23.612] - result already collected: FutureResult
[17:39:23.612] result() for ClusterFuture ... done
[17:39:23.612] result() for ClusterFuture ...
[17:39:23.612] - result already collected: FutureResult
[17:39:23.612] result() for ClusterFuture ... done
[17:39:23.612] result() for ClusterFuture ...
[17:39:23.612] - result already collected: FutureResult
[17:39:23.613] result() for ClusterFuture ... done
[17:39:23.613] result() for ClusterFuture ...
[17:39:23.613] - result already collected: FutureResult
[17:39:23.613] result() for ClusterFuture ... done
[17:39:23.613] - relayed: [n=2] TRUE, FALSE
[17:39:23.613] - queued futures: [n=2] TRUE, FALSE
[17:39:23.613] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:23.613]  length: 1 (resolved future 1)
[17:39:23.643] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.643] - Validating connection of MultisessionFuture
[17:39:23.644] - received message: FutureResult
[17:39:23.644] - Received FutureResult
[17:39:23.644] - Erased future from FutureRegistry
[17:39:23.644] result() for ClusterFuture ...
[17:39:23.644] - result already collected: FutureResult
[17:39:23.644] result() for ClusterFuture ... done
[17:39:23.644] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.644] Future #2
[17:39:23.644] result() for ClusterFuture ...
[17:39:23.645] - result already collected: FutureResult
[17:39:23.645] result() for ClusterFuture ... done
[17:39:23.645] result() for ClusterFuture ...
[17:39:23.645] - result already collected: FutureResult
[17:39:23.645] result() for ClusterFuture ... done
[17:39:23.645] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:23.645] - nx: 2
[17:39:23.645] - relay: TRUE
[17:39:23.645] - stdout: TRUE
[17:39:23.645] - signal: TRUE
[17:39:23.645] - resignal: FALSE
[17:39:23.646] - force: TRUE
[17:39:23.646] - relayed: [n=2] TRUE, FALSE
[17:39:23.646] - queued futures: [n=2] TRUE, FALSE
[17:39:23.646]  - until=2
[17:39:23.646]  - relaying element #2
[17:39:23.646] result() for ClusterFuture ...
[17:39:23.648] - result already collected: FutureResult
[17:39:23.648] result() for ClusterFuture ... done
[17:39:23.648] result() for ClusterFuture ...
[17:39:23.648] - result already collected: FutureResult
[17:39:23.649] result() for ClusterFuture ... done
[17:39:23.649] result() for ClusterFuture ...
[17:39:23.649] - result already collected: FutureResult
[17:39:23.649] result() for ClusterFuture ... done
[17:39:23.649] result() for ClusterFuture ...
[17:39:23.649] - result already collected: FutureResult
[17:39:23.649] result() for ClusterFuture ... done
[17:39:23.649] - relayed: [n=2] TRUE, TRUE
[17:39:23.649] - queued futures: [n=2] TRUE, TRUE
[17:39:23.649] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:23.649]  length: 0 (resolved future 2)
[17:39:23.650] Relaying remaining futures
[17:39:23.650] signalConditionsASAP(NULL, pos=0) ...
[17:39:23.650] - nx: 2
[17:39:23.650] - relay: TRUE
[17:39:23.650] - stdout: TRUE
[17:39:23.650] - signal: TRUE
[17:39:23.650] - resignal: FALSE
[17:39:23.650] - force: TRUE
[17:39:23.650] - relayed: [n=2] TRUE, TRUE
[17:39:23.650] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:23.650] - relayed: [n=2] TRUE, TRUE
[17:39:23.651] - queued futures: [n=2] TRUE, TRUE
[17:39:23.651] signalConditionsASAP(NULL, pos=0) ... done
[17:39:23.651] resolve() on list ... DONE
[17:39:23.651] result() for ClusterFuture ...
[17:39:23.651] - result already collected: FutureResult
[17:39:23.651] result() for ClusterFuture ... done
[17:39:23.651] result() for ClusterFuture ...
[17:39:23.651] - result already collected: FutureResult
[17:39:23.651] result() for ClusterFuture ... done
[17:39:23.651] result() for ClusterFuture ...
[17:39:23.651] - result already collected: FutureResult
[17:39:23.652] result() for ClusterFuture ... done
[17:39:23.652] result() for ClusterFuture ...
[17:39:23.652] - result already collected: FutureResult
[17:39:23.652] result() for ClusterFuture ... done
[17:39:23.652]  - Number of value chunks collected: 2
[17:39:23.652] Resolving 2 futures (chunks) ... DONE
[17:39:23.652] Reducing values from 2 chunks ...
[17:39:23.652]  - Number of values collected after concatenation: 6
[17:39:23.652]  - Number of values expected: 6
[17:39:23.652] Reducing values from 2 chunks ... DONE
[17:39:23.652] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:39:23.653] getGlobalsAndPackagesXApply() ...
[17:39:23.653]  - future.globals: TRUE
[17:39:23.653] getGlobalsAndPackages() ...
[17:39:23.653] Searching for globals...
[17:39:23.654] - globals found: [1] ‘FUN’
[17:39:23.654] Searching for globals ... DONE
[17:39:23.654] Resolving globals: FALSE
[17:39:23.655] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:23.655] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:23.655] - globals: [1] ‘FUN’
[17:39:23.655] 
[17:39:23.655] getGlobalsAndPackages() ... DONE
[17:39:23.655]  - globals found/used: [n=1] ‘FUN’
[17:39:23.655]  - needed namespaces: [n=0] 
[17:39:23.656] Finding globals ... DONE
[17:39:23.656]  - use_args: TRUE
[17:39:23.656]  - Getting '...' globals ...
[17:39:23.656] resolve() on list ...
[17:39:23.656]  recursive: 0
[17:39:23.656]  length: 1
[17:39:23.656]  elements: ‘...’
[17:39:23.656]  length: 0 (resolved future 1)
[17:39:23.656] resolve() on list ... DONE
[17:39:23.657]    - '...' content: [n=0] 
[17:39:23.657] List of 1
[17:39:23.657]  $ ...: list()
[17:39:23.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.657]  - attr(*, "where")=List of 1
[17:39:23.657]   ..$ ...:<environment: 0x55c7972e91c0> 
[17:39:23.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.657]  - attr(*, "resolved")= logi TRUE
[17:39:23.657]  - attr(*, "total_size")= num NA
[17:39:23.659]  - Getting '...' globals ... DONE
[17:39:23.659] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:23.659] List of 2
[17:39:23.659]  $ ...future.FUN:function (x)  
[17:39:23.659]  $ ...          : list()
[17:39:23.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.659]  - attr(*, "where")=List of 2
[17:39:23.659]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:23.659]   ..$ ...          :<environment: 0x55c7972e91c0> 
[17:39:23.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.659]  - attr(*, "resolved")= logi FALSE
[17:39:23.659]  - attr(*, "total_size")= num 848
[17:39:23.662] Packages to be attached in all futures: [n=0] 
[17:39:23.662] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.665] future_lapply() ...
[17:39:23.669] Number of chunks: 2
[17:39:23.669] getGlobalsAndPackagesXApply() ...
[17:39:23.669]  - future.globals: <name-value list> with names ‘list()’
[17:39:23.670]  - use_args: TRUE
[17:39:23.670] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:23.670] List of 2
[17:39:23.670]  $ ...          : list()
[17:39:23.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.670]  $ ...future.FUN:function (x)  
[17:39:23.670]  - attr(*, "where")=List of 2
[17:39:23.670]   ..$ ...          :<environment: 0x55c7972e91c0> 
[17:39:23.670]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:23.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.670]  - attr(*, "resolved")= logi FALSE
[17:39:23.670]  - attr(*, "total_size")= num NA
[17:39:23.673] Packages to be attached in all futures: [n=0] 
[17:39:23.673] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.673] Number of futures (= number of chunks): 2
[17:39:23.674] Launching 2 futures (chunks) ...
[17:39:23.674] Chunk #1 of 2 ...
[17:39:23.674]  - seeds: <none>
[17:39:23.674] getGlobalsAndPackages() ...
[17:39:23.674] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.674] Resolving globals: FALSE
[17:39:23.674] Tweak future expression to call with '...' arguments ...
[17:39:23.674] {
[17:39:23.674]     do.call(function(...) {
[17:39:23.674]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.674]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.674]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.674]             on.exit(options(oopts), add = TRUE)
[17:39:23.674]         }
[17:39:23.674]         {
[17:39:23.674]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.674]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.674]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.674]             })
[17:39:23.674]         }
[17:39:23.674]     }, args = future.call.arguments)
[17:39:23.674] }
[17:39:23.675] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.675] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.675] 
[17:39:23.675] getGlobalsAndPackages() ... DONE
[17:39:23.676] run() for ‘Future’ ...
[17:39:23.676] - state: ‘created’
[17:39:23.676] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.690] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.691]   - Field: ‘node’
[17:39:23.691]   - Field: ‘label’
[17:39:23.691]   - Field: ‘local’
[17:39:23.691]   - Field: ‘owner’
[17:39:23.691]   - Field: ‘envir’
[17:39:23.691]   - Field: ‘workers’
[17:39:23.691]   - Field: ‘packages’
[17:39:23.691]   - Field: ‘gc’
[17:39:23.692]   - Field: ‘conditions’
[17:39:23.692]   - Field: ‘persistent’
[17:39:23.692]   - Field: ‘expr’
[17:39:23.692]   - Field: ‘uuid’
[17:39:23.692]   - Field: ‘seed’
[17:39:23.692]   - Field: ‘version’
[17:39:23.692]   - Field: ‘result’
[17:39:23.692]   - Field: ‘asynchronous’
[17:39:23.692]   - Field: ‘calls’
[17:39:23.692]   - Field: ‘globals’
[17:39:23.692]   - Field: ‘stdout’
[17:39:23.693]   - Field: ‘earlySignal’
[17:39:23.693]   - Field: ‘lazy’
[17:39:23.693]   - Field: ‘state’
[17:39:23.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.693] - Launch lazy future ...
[17:39:23.693] Packages needed by the future expression (n = 0): <none>
[17:39:23.693] Packages needed by future strategies (n = 0): <none>
[17:39:23.694] {
[17:39:23.694]     {
[17:39:23.694]         {
[17:39:23.694]             ...future.startTime <- base::Sys.time()
[17:39:23.694]             {
[17:39:23.694]                 {
[17:39:23.694]                   {
[17:39:23.694]                     {
[17:39:23.694]                       base::local({
[17:39:23.694]                         has_future <- base::requireNamespace("future", 
[17:39:23.694]                           quietly = TRUE)
[17:39:23.694]                         if (has_future) {
[17:39:23.694]                           ns <- base::getNamespace("future")
[17:39:23.694]                           version <- ns[[".package"]][["version"]]
[17:39:23.694]                           if (is.null(version)) 
[17:39:23.694]                             version <- utils::packageVersion("future")
[17:39:23.694]                         }
[17:39:23.694]                         else {
[17:39:23.694]                           version <- NULL
[17:39:23.694]                         }
[17:39:23.694]                         if (!has_future || version < "1.8.0") {
[17:39:23.694]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.694]                             "", base::R.version$version.string), 
[17:39:23.694]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.694]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.694]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.694]                               "release", "version")], collapse = " "), 
[17:39:23.694]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.694]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.694]                             info)
[17:39:23.694]                           info <- base::paste(info, collapse = "; ")
[17:39:23.694]                           if (!has_future) {
[17:39:23.694]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.694]                               info)
[17:39:23.694]                           }
[17:39:23.694]                           else {
[17:39:23.694]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.694]                               info, version)
[17:39:23.694]                           }
[17:39:23.694]                           base::stop(msg)
[17:39:23.694]                         }
[17:39:23.694]                       })
[17:39:23.694]                     }
[17:39:23.694]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.694]                     base::options(mc.cores = 1L)
[17:39:23.694]                   }
[17:39:23.694]                   options(future.plan = NULL)
[17:39:23.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.694]                 }
[17:39:23.694]                 ...future.workdir <- getwd()
[17:39:23.694]             }
[17:39:23.694]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.694]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.694]         }
[17:39:23.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.694]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.694]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.694]             base::names(...future.oldOptions))
[17:39:23.694]     }
[17:39:23.694]     if (FALSE) {
[17:39:23.694]     }
[17:39:23.694]     else {
[17:39:23.694]         if (TRUE) {
[17:39:23.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.694]                 open = "w")
[17:39:23.694]         }
[17:39:23.694]         else {
[17:39:23.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.694]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.694]         }
[17:39:23.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.694]             base::sink(type = "output", split = FALSE)
[17:39:23.694]             base::close(...future.stdout)
[17:39:23.694]         }, add = TRUE)
[17:39:23.694]     }
[17:39:23.694]     ...future.frame <- base::sys.nframe()
[17:39:23.694]     ...future.conditions <- base::list()
[17:39:23.694]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.694]     if (FALSE) {
[17:39:23.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.694]     }
[17:39:23.694]     ...future.result <- base::tryCatch({
[17:39:23.694]         base::withCallingHandlers({
[17:39:23.694]             ...future.value <- base::withVisible(base::local({
[17:39:23.694]                 ...future.makeSendCondition <- local({
[17:39:23.694]                   sendCondition <- NULL
[17:39:23.694]                   function(frame = 1L) {
[17:39:23.694]                     if (is.function(sendCondition)) 
[17:39:23.694]                       return(sendCondition)
[17:39:23.694]                     ns <- getNamespace("parallel")
[17:39:23.694]                     if (exists("sendData", mode = "function", 
[17:39:23.694]                       envir = ns)) {
[17:39:23.694]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.694]                         envir = ns)
[17:39:23.694]                       envir <- sys.frame(frame)
[17:39:23.694]                       master <- NULL
[17:39:23.694]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.694]                         !identical(envir, emptyenv())) {
[17:39:23.694]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.694]                           inherits = FALSE)) {
[17:39:23.694]                           master <- get("master", mode = "list", 
[17:39:23.694]                             envir = envir, inherits = FALSE)
[17:39:23.694]                           if (inherits(master, c("SOCKnode", 
[17:39:23.694]                             "SOCK0node"))) {
[17:39:23.694]                             sendCondition <<- function(cond) {
[17:39:23.694]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.694]                                 success = TRUE)
[17:39:23.694]                               parallel_sendData(master, data)
[17:39:23.694]                             }
[17:39:23.694]                             return(sendCondition)
[17:39:23.694]                           }
[17:39:23.694]                         }
[17:39:23.694]                         frame <- frame + 1L
[17:39:23.694]                         envir <- sys.frame(frame)
[17:39:23.694]                       }
[17:39:23.694]                     }
[17:39:23.694]                     sendCondition <<- function(cond) NULL
[17:39:23.694]                   }
[17:39:23.694]                 })
[17:39:23.694]                 withCallingHandlers({
[17:39:23.694]                   {
[17:39:23.694]                     do.call(function(...) {
[17:39:23.694]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.694]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.694]                         ...future.globals.maxSize)) {
[17:39:23.694]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.694]                         on.exit(options(oopts), add = TRUE)
[17:39:23.694]                       }
[17:39:23.694]                       {
[17:39:23.694]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.694]                           FUN = function(jj) {
[17:39:23.694]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.694]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.694]                           })
[17:39:23.694]                       }
[17:39:23.694]                     }, args = future.call.arguments)
[17:39:23.694]                   }
[17:39:23.694]                 }, immediateCondition = function(cond) {
[17:39:23.694]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.694]                   sendCondition(cond)
[17:39:23.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.694]                   {
[17:39:23.694]                     inherits <- base::inherits
[17:39:23.694]                     invokeRestart <- base::invokeRestart
[17:39:23.694]                     is.null <- base::is.null
[17:39:23.694]                     muffled <- FALSE
[17:39:23.694]                     if (inherits(cond, "message")) {
[17:39:23.694]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.694]                       if (muffled) 
[17:39:23.694]                         invokeRestart("muffleMessage")
[17:39:23.694]                     }
[17:39:23.694]                     else if (inherits(cond, "warning")) {
[17:39:23.694]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.694]                       if (muffled) 
[17:39:23.694]                         invokeRestart("muffleWarning")
[17:39:23.694]                     }
[17:39:23.694]                     else if (inherits(cond, "condition")) {
[17:39:23.694]                       if (!is.null(pattern)) {
[17:39:23.694]                         computeRestarts <- base::computeRestarts
[17:39:23.694]                         grepl <- base::grepl
[17:39:23.694]                         restarts <- computeRestarts(cond)
[17:39:23.694]                         for (restart in restarts) {
[17:39:23.694]                           name <- restart$name
[17:39:23.694]                           if (is.null(name)) 
[17:39:23.694]                             next
[17:39:23.694]                           if (!grepl(pattern, name)) 
[17:39:23.694]                             next
[17:39:23.694]                           invokeRestart(restart)
[17:39:23.694]                           muffled <- TRUE
[17:39:23.694]                           break
[17:39:23.694]                         }
[17:39:23.694]                       }
[17:39:23.694]                     }
[17:39:23.694]                     invisible(muffled)
[17:39:23.694]                   }
[17:39:23.694]                   muffleCondition(cond)
[17:39:23.694]                 })
[17:39:23.694]             }))
[17:39:23.694]             future::FutureResult(value = ...future.value$value, 
[17:39:23.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.694]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.694]                     ...future.globalenv.names))
[17:39:23.694]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.694]         }, condition = base::local({
[17:39:23.694]             c <- base::c
[17:39:23.694]             inherits <- base::inherits
[17:39:23.694]             invokeRestart <- base::invokeRestart
[17:39:23.694]             length <- base::length
[17:39:23.694]             list <- base::list
[17:39:23.694]             seq.int <- base::seq.int
[17:39:23.694]             signalCondition <- base::signalCondition
[17:39:23.694]             sys.calls <- base::sys.calls
[17:39:23.694]             `[[` <- base::`[[`
[17:39:23.694]             `+` <- base::`+`
[17:39:23.694]             `<<-` <- base::`<<-`
[17:39:23.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.694]                   3L)]
[17:39:23.694]             }
[17:39:23.694]             function(cond) {
[17:39:23.694]                 is_error <- inherits(cond, "error")
[17:39:23.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.694]                   NULL)
[17:39:23.694]                 if (is_error) {
[17:39:23.694]                   sessionInformation <- function() {
[17:39:23.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.694]                       search = base::search(), system = base::Sys.info())
[17:39:23.694]                   }
[17:39:23.694]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.694]                     cond$call), session = sessionInformation(), 
[17:39:23.694]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.694]                   signalCondition(cond)
[17:39:23.694]                 }
[17:39:23.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.694]                 "immediateCondition"))) {
[17:39:23.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.694]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.694]                   if (TRUE && !signal) {
[17:39:23.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.694]                     {
[17:39:23.694]                       inherits <- base::inherits
[17:39:23.694]                       invokeRestart <- base::invokeRestart
[17:39:23.694]                       is.null <- base::is.null
[17:39:23.694]                       muffled <- FALSE
[17:39:23.694]                       if (inherits(cond, "message")) {
[17:39:23.694]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.694]                         if (muffled) 
[17:39:23.694]                           invokeRestart("muffleMessage")
[17:39:23.694]                       }
[17:39:23.694]                       else if (inherits(cond, "warning")) {
[17:39:23.694]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.694]                         if (muffled) 
[17:39:23.694]                           invokeRestart("muffleWarning")
[17:39:23.694]                       }
[17:39:23.694]                       else if (inherits(cond, "condition")) {
[17:39:23.694]                         if (!is.null(pattern)) {
[17:39:23.694]                           computeRestarts <- base::computeRestarts
[17:39:23.694]                           grepl <- base::grepl
[17:39:23.694]                           restarts <- computeRestarts(cond)
[17:39:23.694]                           for (restart in restarts) {
[17:39:23.694]                             name <- restart$name
[17:39:23.694]                             if (is.null(name)) 
[17:39:23.694]                               next
[17:39:23.694]                             if (!grepl(pattern, name)) 
[17:39:23.694]                               next
[17:39:23.694]                             invokeRestart(restart)
[17:39:23.694]                             muffled <- TRUE
[17:39:23.694]                             break
[17:39:23.694]                           }
[17:39:23.694]                         }
[17:39:23.694]                       }
[17:39:23.694]                       invisible(muffled)
[17:39:23.694]                     }
[17:39:23.694]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.694]                   }
[17:39:23.694]                 }
[17:39:23.694]                 else {
[17:39:23.694]                   if (TRUE) {
[17:39:23.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.694]                     {
[17:39:23.694]                       inherits <- base::inherits
[17:39:23.694]                       invokeRestart <- base::invokeRestart
[17:39:23.694]                       is.null <- base::is.null
[17:39:23.694]                       muffled <- FALSE
[17:39:23.694]                       if (inherits(cond, "message")) {
[17:39:23.694]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.694]                         if (muffled) 
[17:39:23.694]                           invokeRestart("muffleMessage")
[17:39:23.694]                       }
[17:39:23.694]                       else if (inherits(cond, "warning")) {
[17:39:23.694]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.694]                         if (muffled) 
[17:39:23.694]                           invokeRestart("muffleWarning")
[17:39:23.694]                       }
[17:39:23.694]                       else if (inherits(cond, "condition")) {
[17:39:23.694]                         if (!is.null(pattern)) {
[17:39:23.694]                           computeRestarts <- base::computeRestarts
[17:39:23.694]                           grepl <- base::grepl
[17:39:23.694]                           restarts <- computeRestarts(cond)
[17:39:23.694]                           for (restart in restarts) {
[17:39:23.694]                             name <- restart$name
[17:39:23.694]                             if (is.null(name)) 
[17:39:23.694]                               next
[17:39:23.694]                             if (!grepl(pattern, name)) 
[17:39:23.694]                               next
[17:39:23.694]                             invokeRestart(restart)
[17:39:23.694]                             muffled <- TRUE
[17:39:23.694]                             break
[17:39:23.694]                           }
[17:39:23.694]                         }
[17:39:23.694]                       }
[17:39:23.694]                       invisible(muffled)
[17:39:23.694]                     }
[17:39:23.694]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.694]                   }
[17:39:23.694]                 }
[17:39:23.694]             }
[17:39:23.694]         }))
[17:39:23.694]     }, error = function(ex) {
[17:39:23.694]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.694]                 ...future.rng), started = ...future.startTime, 
[17:39:23.694]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.694]             version = "1.8"), class = "FutureResult")
[17:39:23.694]     }, finally = {
[17:39:23.694]         if (!identical(...future.workdir, getwd())) 
[17:39:23.694]             setwd(...future.workdir)
[17:39:23.694]         {
[17:39:23.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.694]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.694]             }
[17:39:23.694]             base::options(...future.oldOptions)
[17:39:23.694]             if (.Platform$OS.type == "windows") {
[17:39:23.694]                 old_names <- names(...future.oldEnvVars)
[17:39:23.694]                 envs <- base::Sys.getenv()
[17:39:23.694]                 names <- names(envs)
[17:39:23.694]                 common <- intersect(names, old_names)
[17:39:23.694]                 added <- setdiff(names, old_names)
[17:39:23.694]                 removed <- setdiff(old_names, names)
[17:39:23.694]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.694]                   envs[common]]
[17:39:23.694]                 NAMES <- toupper(changed)
[17:39:23.694]                 args <- list()
[17:39:23.694]                 for (kk in seq_along(NAMES)) {
[17:39:23.694]                   name <- changed[[kk]]
[17:39:23.694]                   NAME <- NAMES[[kk]]
[17:39:23.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.694]                     next
[17:39:23.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.694]                 }
[17:39:23.694]                 NAMES <- toupper(added)
[17:39:23.694]                 for (kk in seq_along(NAMES)) {
[17:39:23.694]                   name <- added[[kk]]
[17:39:23.694]                   NAME <- NAMES[[kk]]
[17:39:23.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.694]                     next
[17:39:23.694]                   args[[name]] <- ""
[17:39:23.694]                 }
[17:39:23.694]                 NAMES <- toupper(removed)
[17:39:23.694]                 for (kk in seq_along(NAMES)) {
[17:39:23.694]                   name <- removed[[kk]]
[17:39:23.694]                   NAME <- NAMES[[kk]]
[17:39:23.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.694]                     next
[17:39:23.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.694]                 }
[17:39:23.694]                 if (length(args) > 0) 
[17:39:23.694]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.694]             }
[17:39:23.694]             else {
[17:39:23.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.694]             }
[17:39:23.694]             {
[17:39:23.694]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.694]                   0L) {
[17:39:23.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.694]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.694]                   base::options(opts)
[17:39:23.694]                 }
[17:39:23.694]                 {
[17:39:23.694]                   {
[17:39:23.694]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.694]                     NULL
[17:39:23.694]                   }
[17:39:23.694]                   options(future.plan = NULL)
[17:39:23.694]                   if (is.na(NA_character_)) 
[17:39:23.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.694]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.694]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.694]                     envir = parent.frame()) 
[17:39:23.694]                   {
[17:39:23.694]                     if (is.function(workers)) 
[17:39:23.694]                       workers <- workers()
[17:39:23.694]                     workers <- structure(as.integer(workers), 
[17:39:23.694]                       class = class(workers))
[17:39:23.694]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.694]                       workers >= 1)
[17:39:23.694]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.694]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.694]                     }
[17:39:23.694]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.694]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.694]                       envir = envir)
[17:39:23.694]                     if (!future$lazy) 
[17:39:23.694]                       future <- run(future)
[17:39:23.694]                     invisible(future)
[17:39:23.694]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.694]                 }
[17:39:23.694]             }
[17:39:23.694]         }
[17:39:23.694]     })
[17:39:23.694]     if (TRUE) {
[17:39:23.694]         base::sink(type = "output", split = FALSE)
[17:39:23.694]         if (TRUE) {
[17:39:23.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.694]         }
[17:39:23.694]         else {
[17:39:23.694]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.694]         }
[17:39:23.694]         base::close(...future.stdout)
[17:39:23.694]         ...future.stdout <- NULL
[17:39:23.694]     }
[17:39:23.694]     ...future.result$conditions <- ...future.conditions
[17:39:23.694]     ...future.result$finished <- base::Sys.time()
[17:39:23.694]     ...future.result
[17:39:23.694] }
[17:39:23.697] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[17:39:23.697] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:23.697] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.698] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:39:23.698] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:39:23.698] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:39:23.698] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:23.698] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:23.699] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.699] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:23.699] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.699] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[17:39:23.700] MultisessionFuture started
[17:39:23.700] - Launch lazy future ... done
[17:39:23.700] run() for ‘MultisessionFuture’ ... done
[17:39:23.700] Created future:
[17:39:23.700] MultisessionFuture:
[17:39:23.700] Label: ‘future_apply-1’
[17:39:23.700] Expression:
[17:39:23.700] {
[17:39:23.700]     do.call(function(...) {
[17:39:23.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.700]             on.exit(options(oopts), add = TRUE)
[17:39:23.700]         }
[17:39:23.700]         {
[17:39:23.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.700]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.700]             })
[17:39:23.700]         }
[17:39:23.700]     }, args = future.call.arguments)
[17:39:23.700] }
[17:39:23.700] Lazy evaluation: FALSE
[17:39:23.700] Asynchronous evaluation: TRUE
[17:39:23.700] Local evaluation: TRUE
[17:39:23.700] Environment: R_GlobalEnv
[17:39:23.700] Capture standard output: TRUE
[17:39:23.700] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.700] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.700] Packages: <none>
[17:39:23.700] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.700] Resolved: FALSE
[17:39:23.700] Value: <not collected>
[17:39:23.700] Conditions captured: <none>
[17:39:23.700] Early signaling: FALSE
[17:39:23.700] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.700] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.712] Chunk #1 of 2 ... DONE
[17:39:23.712] Chunk #2 of 2 ...
[17:39:23.712]  - seeds: <none>
[17:39:23.712] getGlobalsAndPackages() ...
[17:39:23.712] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.712] Resolving globals: FALSE
[17:39:23.712] Tweak future expression to call with '...' arguments ...
[17:39:23.713] {
[17:39:23.713]     do.call(function(...) {
[17:39:23.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.713]             on.exit(options(oopts), add = TRUE)
[17:39:23.713]         }
[17:39:23.713]         {
[17:39:23.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.713]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.713]             })
[17:39:23.713]         }
[17:39:23.713]     }, args = future.call.arguments)
[17:39:23.713] }
[17:39:23.713] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.713] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.713] 
[17:39:23.713] getGlobalsAndPackages() ... DONE
[17:39:23.714] run() for ‘Future’ ...
[17:39:23.714] - state: ‘created’
[17:39:23.714] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.728] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.728]   - Field: ‘node’
[17:39:23.728]   - Field: ‘label’
[17:39:23.729]   - Field: ‘local’
[17:39:23.729]   - Field: ‘owner’
[17:39:23.729]   - Field: ‘envir’
[17:39:23.729]   - Field: ‘workers’
[17:39:23.729]   - Field: ‘packages’
[17:39:23.729]   - Field: ‘gc’
[17:39:23.729]   - Field: ‘conditions’
[17:39:23.729]   - Field: ‘persistent’
[17:39:23.729]   - Field: ‘expr’
[17:39:23.729]   - Field: ‘uuid’
[17:39:23.730]   - Field: ‘seed’
[17:39:23.730]   - Field: ‘version’
[17:39:23.730]   - Field: ‘result’
[17:39:23.730]   - Field: ‘asynchronous’
[17:39:23.730]   - Field: ‘calls’
[17:39:23.730]   - Field: ‘globals’
[17:39:23.730]   - Field: ‘stdout’
[17:39:23.730]   - Field: ‘earlySignal’
[17:39:23.730]   - Field: ‘lazy’
[17:39:23.730]   - Field: ‘state’
[17:39:23.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.731] - Launch lazy future ...
[17:39:23.731] Packages needed by the future expression (n = 0): <none>
[17:39:23.731] Packages needed by future strategies (n = 0): <none>
[17:39:23.731] {
[17:39:23.731]     {
[17:39:23.731]         {
[17:39:23.731]             ...future.startTime <- base::Sys.time()
[17:39:23.731]             {
[17:39:23.731]                 {
[17:39:23.731]                   {
[17:39:23.731]                     {
[17:39:23.731]                       base::local({
[17:39:23.731]                         has_future <- base::requireNamespace("future", 
[17:39:23.731]                           quietly = TRUE)
[17:39:23.731]                         if (has_future) {
[17:39:23.731]                           ns <- base::getNamespace("future")
[17:39:23.731]                           version <- ns[[".package"]][["version"]]
[17:39:23.731]                           if (is.null(version)) 
[17:39:23.731]                             version <- utils::packageVersion("future")
[17:39:23.731]                         }
[17:39:23.731]                         else {
[17:39:23.731]                           version <- NULL
[17:39:23.731]                         }
[17:39:23.731]                         if (!has_future || version < "1.8.0") {
[17:39:23.731]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.731]                             "", base::R.version$version.string), 
[17:39:23.731]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.731]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.731]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.731]                               "release", "version")], collapse = " "), 
[17:39:23.731]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.731]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.731]                             info)
[17:39:23.731]                           info <- base::paste(info, collapse = "; ")
[17:39:23.731]                           if (!has_future) {
[17:39:23.731]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.731]                               info)
[17:39:23.731]                           }
[17:39:23.731]                           else {
[17:39:23.731]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.731]                               info, version)
[17:39:23.731]                           }
[17:39:23.731]                           base::stop(msg)
[17:39:23.731]                         }
[17:39:23.731]                       })
[17:39:23.731]                     }
[17:39:23.731]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.731]                     base::options(mc.cores = 1L)
[17:39:23.731]                   }
[17:39:23.731]                   options(future.plan = NULL)
[17:39:23.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.731]                 }
[17:39:23.731]                 ...future.workdir <- getwd()
[17:39:23.731]             }
[17:39:23.731]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.731]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.731]         }
[17:39:23.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.731]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.731]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.731]             base::names(...future.oldOptions))
[17:39:23.731]     }
[17:39:23.731]     if (FALSE) {
[17:39:23.731]     }
[17:39:23.731]     else {
[17:39:23.731]         if (TRUE) {
[17:39:23.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.731]                 open = "w")
[17:39:23.731]         }
[17:39:23.731]         else {
[17:39:23.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.731]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.731]         }
[17:39:23.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.731]             base::sink(type = "output", split = FALSE)
[17:39:23.731]             base::close(...future.stdout)
[17:39:23.731]         }, add = TRUE)
[17:39:23.731]     }
[17:39:23.731]     ...future.frame <- base::sys.nframe()
[17:39:23.731]     ...future.conditions <- base::list()
[17:39:23.731]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.731]     if (FALSE) {
[17:39:23.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.731]     }
[17:39:23.731]     ...future.result <- base::tryCatch({
[17:39:23.731]         base::withCallingHandlers({
[17:39:23.731]             ...future.value <- base::withVisible(base::local({
[17:39:23.731]                 ...future.makeSendCondition <- local({
[17:39:23.731]                   sendCondition <- NULL
[17:39:23.731]                   function(frame = 1L) {
[17:39:23.731]                     if (is.function(sendCondition)) 
[17:39:23.731]                       return(sendCondition)
[17:39:23.731]                     ns <- getNamespace("parallel")
[17:39:23.731]                     if (exists("sendData", mode = "function", 
[17:39:23.731]                       envir = ns)) {
[17:39:23.731]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.731]                         envir = ns)
[17:39:23.731]                       envir <- sys.frame(frame)
[17:39:23.731]                       master <- NULL
[17:39:23.731]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.731]                         !identical(envir, emptyenv())) {
[17:39:23.731]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.731]                           inherits = FALSE)) {
[17:39:23.731]                           master <- get("master", mode = "list", 
[17:39:23.731]                             envir = envir, inherits = FALSE)
[17:39:23.731]                           if (inherits(master, c("SOCKnode", 
[17:39:23.731]                             "SOCK0node"))) {
[17:39:23.731]                             sendCondition <<- function(cond) {
[17:39:23.731]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.731]                                 success = TRUE)
[17:39:23.731]                               parallel_sendData(master, data)
[17:39:23.731]                             }
[17:39:23.731]                             return(sendCondition)
[17:39:23.731]                           }
[17:39:23.731]                         }
[17:39:23.731]                         frame <- frame + 1L
[17:39:23.731]                         envir <- sys.frame(frame)
[17:39:23.731]                       }
[17:39:23.731]                     }
[17:39:23.731]                     sendCondition <<- function(cond) NULL
[17:39:23.731]                   }
[17:39:23.731]                 })
[17:39:23.731]                 withCallingHandlers({
[17:39:23.731]                   {
[17:39:23.731]                     do.call(function(...) {
[17:39:23.731]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.731]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.731]                         ...future.globals.maxSize)) {
[17:39:23.731]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.731]                         on.exit(options(oopts), add = TRUE)
[17:39:23.731]                       }
[17:39:23.731]                       {
[17:39:23.731]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.731]                           FUN = function(jj) {
[17:39:23.731]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.731]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.731]                           })
[17:39:23.731]                       }
[17:39:23.731]                     }, args = future.call.arguments)
[17:39:23.731]                   }
[17:39:23.731]                 }, immediateCondition = function(cond) {
[17:39:23.731]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.731]                   sendCondition(cond)
[17:39:23.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.731]                   {
[17:39:23.731]                     inherits <- base::inherits
[17:39:23.731]                     invokeRestart <- base::invokeRestart
[17:39:23.731]                     is.null <- base::is.null
[17:39:23.731]                     muffled <- FALSE
[17:39:23.731]                     if (inherits(cond, "message")) {
[17:39:23.731]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.731]                       if (muffled) 
[17:39:23.731]                         invokeRestart("muffleMessage")
[17:39:23.731]                     }
[17:39:23.731]                     else if (inherits(cond, "warning")) {
[17:39:23.731]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.731]                       if (muffled) 
[17:39:23.731]                         invokeRestart("muffleWarning")
[17:39:23.731]                     }
[17:39:23.731]                     else if (inherits(cond, "condition")) {
[17:39:23.731]                       if (!is.null(pattern)) {
[17:39:23.731]                         computeRestarts <- base::computeRestarts
[17:39:23.731]                         grepl <- base::grepl
[17:39:23.731]                         restarts <- computeRestarts(cond)
[17:39:23.731]                         for (restart in restarts) {
[17:39:23.731]                           name <- restart$name
[17:39:23.731]                           if (is.null(name)) 
[17:39:23.731]                             next
[17:39:23.731]                           if (!grepl(pattern, name)) 
[17:39:23.731]                             next
[17:39:23.731]                           invokeRestart(restart)
[17:39:23.731]                           muffled <- TRUE
[17:39:23.731]                           break
[17:39:23.731]                         }
[17:39:23.731]                       }
[17:39:23.731]                     }
[17:39:23.731]                     invisible(muffled)
[17:39:23.731]                   }
[17:39:23.731]                   muffleCondition(cond)
[17:39:23.731]                 })
[17:39:23.731]             }))
[17:39:23.731]             future::FutureResult(value = ...future.value$value, 
[17:39:23.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.731]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.731]                     ...future.globalenv.names))
[17:39:23.731]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.731]         }, condition = base::local({
[17:39:23.731]             c <- base::c
[17:39:23.731]             inherits <- base::inherits
[17:39:23.731]             invokeRestart <- base::invokeRestart
[17:39:23.731]             length <- base::length
[17:39:23.731]             list <- base::list
[17:39:23.731]             seq.int <- base::seq.int
[17:39:23.731]             signalCondition <- base::signalCondition
[17:39:23.731]             sys.calls <- base::sys.calls
[17:39:23.731]             `[[` <- base::`[[`
[17:39:23.731]             `+` <- base::`+`
[17:39:23.731]             `<<-` <- base::`<<-`
[17:39:23.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.731]                   3L)]
[17:39:23.731]             }
[17:39:23.731]             function(cond) {
[17:39:23.731]                 is_error <- inherits(cond, "error")
[17:39:23.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.731]                   NULL)
[17:39:23.731]                 if (is_error) {
[17:39:23.731]                   sessionInformation <- function() {
[17:39:23.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.731]                       search = base::search(), system = base::Sys.info())
[17:39:23.731]                   }
[17:39:23.731]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.731]                     cond$call), session = sessionInformation(), 
[17:39:23.731]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.731]                   signalCondition(cond)
[17:39:23.731]                 }
[17:39:23.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.731]                 "immediateCondition"))) {
[17:39:23.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.731]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.731]                   if (TRUE && !signal) {
[17:39:23.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.731]                     {
[17:39:23.731]                       inherits <- base::inherits
[17:39:23.731]                       invokeRestart <- base::invokeRestart
[17:39:23.731]                       is.null <- base::is.null
[17:39:23.731]                       muffled <- FALSE
[17:39:23.731]                       if (inherits(cond, "message")) {
[17:39:23.731]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.731]                         if (muffled) 
[17:39:23.731]                           invokeRestart("muffleMessage")
[17:39:23.731]                       }
[17:39:23.731]                       else if (inherits(cond, "warning")) {
[17:39:23.731]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.731]                         if (muffled) 
[17:39:23.731]                           invokeRestart("muffleWarning")
[17:39:23.731]                       }
[17:39:23.731]                       else if (inherits(cond, "condition")) {
[17:39:23.731]                         if (!is.null(pattern)) {
[17:39:23.731]                           computeRestarts <- base::computeRestarts
[17:39:23.731]                           grepl <- base::grepl
[17:39:23.731]                           restarts <- computeRestarts(cond)
[17:39:23.731]                           for (restart in restarts) {
[17:39:23.731]                             name <- restart$name
[17:39:23.731]                             if (is.null(name)) 
[17:39:23.731]                               next
[17:39:23.731]                             if (!grepl(pattern, name)) 
[17:39:23.731]                               next
[17:39:23.731]                             invokeRestart(restart)
[17:39:23.731]                             muffled <- TRUE
[17:39:23.731]                             break
[17:39:23.731]                           }
[17:39:23.731]                         }
[17:39:23.731]                       }
[17:39:23.731]                       invisible(muffled)
[17:39:23.731]                     }
[17:39:23.731]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.731]                   }
[17:39:23.731]                 }
[17:39:23.731]                 else {
[17:39:23.731]                   if (TRUE) {
[17:39:23.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.731]                     {
[17:39:23.731]                       inherits <- base::inherits
[17:39:23.731]                       invokeRestart <- base::invokeRestart
[17:39:23.731]                       is.null <- base::is.null
[17:39:23.731]                       muffled <- FALSE
[17:39:23.731]                       if (inherits(cond, "message")) {
[17:39:23.731]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.731]                         if (muffled) 
[17:39:23.731]                           invokeRestart("muffleMessage")
[17:39:23.731]                       }
[17:39:23.731]                       else if (inherits(cond, "warning")) {
[17:39:23.731]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.731]                         if (muffled) 
[17:39:23.731]                           invokeRestart("muffleWarning")
[17:39:23.731]                       }
[17:39:23.731]                       else if (inherits(cond, "condition")) {
[17:39:23.731]                         if (!is.null(pattern)) {
[17:39:23.731]                           computeRestarts <- base::computeRestarts
[17:39:23.731]                           grepl <- base::grepl
[17:39:23.731]                           restarts <- computeRestarts(cond)
[17:39:23.731]                           for (restart in restarts) {
[17:39:23.731]                             name <- restart$name
[17:39:23.731]                             if (is.null(name)) 
[17:39:23.731]                               next
[17:39:23.731]                             if (!grepl(pattern, name)) 
[17:39:23.731]                               next
[17:39:23.731]                             invokeRestart(restart)
[17:39:23.731]                             muffled <- TRUE
[17:39:23.731]                             break
[17:39:23.731]                           }
[17:39:23.731]                         }
[17:39:23.731]                       }
[17:39:23.731]                       invisible(muffled)
[17:39:23.731]                     }
[17:39:23.731]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.731]                   }
[17:39:23.731]                 }
[17:39:23.731]             }
[17:39:23.731]         }))
[17:39:23.731]     }, error = function(ex) {
[17:39:23.731]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.731]                 ...future.rng), started = ...future.startTime, 
[17:39:23.731]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.731]             version = "1.8"), class = "FutureResult")
[17:39:23.731]     }, finally = {
[17:39:23.731]         if (!identical(...future.workdir, getwd())) 
[17:39:23.731]             setwd(...future.workdir)
[17:39:23.731]         {
[17:39:23.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.731]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.731]             }
[17:39:23.731]             base::options(...future.oldOptions)
[17:39:23.731]             if (.Platform$OS.type == "windows") {
[17:39:23.731]                 old_names <- names(...future.oldEnvVars)
[17:39:23.731]                 envs <- base::Sys.getenv()
[17:39:23.731]                 names <- names(envs)
[17:39:23.731]                 common <- intersect(names, old_names)
[17:39:23.731]                 added <- setdiff(names, old_names)
[17:39:23.731]                 removed <- setdiff(old_names, names)
[17:39:23.731]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.731]                   envs[common]]
[17:39:23.731]                 NAMES <- toupper(changed)
[17:39:23.731]                 args <- list()
[17:39:23.731]                 for (kk in seq_along(NAMES)) {
[17:39:23.731]                   name <- changed[[kk]]
[17:39:23.731]                   NAME <- NAMES[[kk]]
[17:39:23.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.731]                     next
[17:39:23.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.731]                 }
[17:39:23.731]                 NAMES <- toupper(added)
[17:39:23.731]                 for (kk in seq_along(NAMES)) {
[17:39:23.731]                   name <- added[[kk]]
[17:39:23.731]                   NAME <- NAMES[[kk]]
[17:39:23.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.731]                     next
[17:39:23.731]                   args[[name]] <- ""
[17:39:23.731]                 }
[17:39:23.731]                 NAMES <- toupper(removed)
[17:39:23.731]                 for (kk in seq_along(NAMES)) {
[17:39:23.731]                   name <- removed[[kk]]
[17:39:23.731]                   NAME <- NAMES[[kk]]
[17:39:23.731]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.731]                     next
[17:39:23.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.731]                 }
[17:39:23.731]                 if (length(args) > 0) 
[17:39:23.731]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.731]             }
[17:39:23.731]             else {
[17:39:23.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.731]             }
[17:39:23.731]             {
[17:39:23.731]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.731]                   0L) {
[17:39:23.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.731]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.731]                   base::options(opts)
[17:39:23.731]                 }
[17:39:23.731]                 {
[17:39:23.731]                   {
[17:39:23.731]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.731]                     NULL
[17:39:23.731]                   }
[17:39:23.731]                   options(future.plan = NULL)
[17:39:23.731]                   if (is.na(NA_character_)) 
[17:39:23.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.731]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.731]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.731]                     envir = parent.frame()) 
[17:39:23.731]                   {
[17:39:23.731]                     if (is.function(workers)) 
[17:39:23.731]                       workers <- workers()
[17:39:23.731]                     workers <- structure(as.integer(workers), 
[17:39:23.731]                       class = class(workers))
[17:39:23.731]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.731]                       workers >= 1)
[17:39:23.731]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.731]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.731]                     }
[17:39:23.731]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.731]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.731]                       envir = envir)
[17:39:23.731]                     if (!future$lazy) 
[17:39:23.731]                       future <- run(future)
[17:39:23.731]                     invisible(future)
[17:39:23.731]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.731]                 }
[17:39:23.731]             }
[17:39:23.731]         }
[17:39:23.731]     })
[17:39:23.731]     if (TRUE) {
[17:39:23.731]         base::sink(type = "output", split = FALSE)
[17:39:23.731]         if (TRUE) {
[17:39:23.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.731]         }
[17:39:23.731]         else {
[17:39:23.731]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.731]         }
[17:39:23.731]         base::close(...future.stdout)
[17:39:23.731]         ...future.stdout <- NULL
[17:39:23.731]     }
[17:39:23.731]     ...future.result$conditions <- ...future.conditions
[17:39:23.731]     ...future.result$finished <- base::Sys.time()
[17:39:23.731]     ...future.result
[17:39:23.731] }
[17:39:23.734] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[17:39:23.734] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:23.735] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.735] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:39:23.735] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:39:23.735] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:39:23.736] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:39:23.736] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:23.736] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:23.737] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.737] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[17:39:23.737] MultisessionFuture started
[17:39:23.737] - Launch lazy future ... done
[17:39:23.737] run() for ‘MultisessionFuture’ ... done
[17:39:23.738] Created future:
[17:39:23.738] MultisessionFuture:
[17:39:23.738] Label: ‘future_apply-2’
[17:39:23.738] Expression:
[17:39:23.738] {
[17:39:23.738]     do.call(function(...) {
[17:39:23.738]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.738]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.738]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.738]             on.exit(options(oopts), add = TRUE)
[17:39:23.738]         }
[17:39:23.738]         {
[17:39:23.738]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.738]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.738]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.738]             })
[17:39:23.738]         }
[17:39:23.738]     }, args = future.call.arguments)
[17:39:23.738] }
[17:39:23.738] Lazy evaluation: FALSE
[17:39:23.738] Asynchronous evaluation: TRUE
[17:39:23.738] Local evaluation: TRUE
[17:39:23.738] Environment: R_GlobalEnv
[17:39:23.738] Capture standard output: TRUE
[17:39:23.738] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.738] Globals: 5 objects totaling 904 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.738] Packages: <none>
[17:39:23.738] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.738] Resolved: FALSE
[17:39:23.738] Value: <not collected>
[17:39:23.738] Conditions captured: <none>
[17:39:23.738] Early signaling: FALSE
[17:39:23.738] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.738] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.749] Chunk #2 of 2 ... DONE
[17:39:23.749] Launching 2 futures (chunks) ... DONE
[17:39:23.749] Resolving 2 futures (chunks) ...
[17:39:23.749] resolve() on list ...
[17:39:23.750]  recursive: 0
[17:39:23.750]  length: 2
[17:39:23.750] 
[17:39:23.752] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.752] - Validating connection of MultisessionFuture
[17:39:23.752] - received message: FutureResult
[17:39:23.752] - Received FutureResult
[17:39:23.752] - Erased future from FutureRegistry
[17:39:23.752] result() for ClusterFuture ...
[17:39:23.752] - result already collected: FutureResult
[17:39:23.752] result() for ClusterFuture ... done
[17:39:23.753] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.753] Future #1
[17:39:23.753] result() for ClusterFuture ...
[17:39:23.753] - result already collected: FutureResult
[17:39:23.753] result() for ClusterFuture ... done
[17:39:23.753] result() for ClusterFuture ...
[17:39:23.753] - result already collected: FutureResult
[17:39:23.753] result() for ClusterFuture ... done
[17:39:23.753] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:23.753] - nx: 2
[17:39:23.753] - relay: TRUE
[17:39:23.754] - stdout: TRUE
[17:39:23.754] - signal: TRUE
[17:39:23.754] - resignal: FALSE
[17:39:23.754] - force: TRUE
[17:39:23.754] - relayed: [n=2] FALSE, FALSE
[17:39:23.754] - queued futures: [n=2] FALSE, FALSE
[17:39:23.754]  - until=1
[17:39:23.754]  - relaying element #1
[17:39:23.754] result() for ClusterFuture ...
[17:39:23.754] - result already collected: FutureResult
[17:39:23.754] result() for ClusterFuture ... done
[17:39:23.754] result() for ClusterFuture ...
[17:39:23.755] - result already collected: FutureResult
[17:39:23.755] result() for ClusterFuture ... done
[17:39:23.755] result() for ClusterFuture ...
[17:39:23.755] - result already collected: FutureResult
[17:39:23.755] result() for ClusterFuture ... done
[17:39:23.755] result() for ClusterFuture ...
[17:39:23.755] - result already collected: FutureResult
[17:39:23.755] result() for ClusterFuture ... done
[17:39:23.755] - relayed: [n=2] TRUE, FALSE
[17:39:23.755] - queued futures: [n=2] TRUE, FALSE
[17:39:23.756] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:23.756]  length: 1 (resolved future 1)
[17:39:23.784] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.784] - Validating connection of MultisessionFuture
[17:39:23.784] - received message: FutureResult
[17:39:23.784] - Received FutureResult
[17:39:23.784] - Erased future from FutureRegistry
[17:39:23.784] result() for ClusterFuture ...
[17:39:23.784] - result already collected: FutureResult
[17:39:23.785] result() for ClusterFuture ... done
[17:39:23.785] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.785] Future #2
[17:39:23.785] result() for ClusterFuture ...
[17:39:23.785] - result already collected: FutureResult
[17:39:23.785] result() for ClusterFuture ... done
[17:39:23.785] result() for ClusterFuture ...
[17:39:23.785] - result already collected: FutureResult
[17:39:23.785] result() for ClusterFuture ... done
[17:39:23.785] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:23.785] - nx: 2
[17:39:23.786] - relay: TRUE
[17:39:23.786] - stdout: TRUE
[17:39:23.786] - signal: TRUE
[17:39:23.786] - resignal: FALSE
[17:39:23.786] - force: TRUE
[17:39:23.786] - relayed: [n=2] TRUE, FALSE
[17:39:23.786] - queued futures: [n=2] TRUE, FALSE
[17:39:23.786]  - until=2
[17:39:23.786]  - relaying element #2
[17:39:23.786] result() for ClusterFuture ...
[17:39:23.786] - result already collected: FutureResult
[17:39:23.787] result() for ClusterFuture ... done
[17:39:23.787] result() for ClusterFuture ...
[17:39:23.787] - result already collected: FutureResult
[17:39:23.787] result() for ClusterFuture ... done
[17:39:23.787] result() for ClusterFuture ...
[17:39:23.787] - result already collected: FutureResult
[17:39:23.787] result() for ClusterFuture ... done
[17:39:23.787] result() for ClusterFuture ...
[17:39:23.787] - result already collected: FutureResult
[17:39:23.787] result() for ClusterFuture ... done
[17:39:23.787] - relayed: [n=2] TRUE, TRUE
[17:39:23.788] - queued futures: [n=2] TRUE, TRUE
[17:39:23.788] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:23.788]  length: 0 (resolved future 2)
[17:39:23.788] Relaying remaining futures
[17:39:23.788] signalConditionsASAP(NULL, pos=0) ...
[17:39:23.788] - nx: 2
[17:39:23.788] - relay: TRUE
[17:39:23.788] - stdout: TRUE
[17:39:23.788] - signal: TRUE
[17:39:23.788] - resignal: FALSE
[17:39:23.788] - force: TRUE
[17:39:23.789] - relayed: [n=2] TRUE, TRUE
[17:39:23.789] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:23.789] - relayed: [n=2] TRUE, TRUE
[17:39:23.789] - queued futures: [n=2] TRUE, TRUE
[17:39:23.789] signalConditionsASAP(NULL, pos=0) ... done
[17:39:23.789] resolve() on list ... DONE
[17:39:23.789] result() for ClusterFuture ...
[17:39:23.789] - result already collected: FutureResult
[17:39:23.789] result() for ClusterFuture ... done
[17:39:23.789] result() for ClusterFuture ...
[17:39:23.789] - result already collected: FutureResult
[17:39:23.790] result() for ClusterFuture ... done
[17:39:23.790] result() for ClusterFuture ...
[17:39:23.790] - result already collected: FutureResult
[17:39:23.790] result() for ClusterFuture ... done
[17:39:23.790] result() for ClusterFuture ...
[17:39:23.790] - result already collected: FutureResult
[17:39:23.790] result() for ClusterFuture ... done
[17:39:23.790]  - Number of value chunks collected: 2
[17:39:23.790] Resolving 2 futures (chunks) ... DONE
[17:39:23.790] Reducing values from 2 chunks ...
[17:39:23.790]  - Number of values collected after concatenation: 2
[17:39:23.791]  - Number of values expected: 2
[17:39:23.791] Reducing values from 2 chunks ... DONE
[17:39:23.791] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:39:23.791] getGlobalsAndPackagesXApply() ...
[17:39:23.791]  - future.globals: TRUE
[17:39:23.791] getGlobalsAndPackages() ...
[17:39:23.791] Searching for globals...
[17:39:23.792] - globals found: [1] ‘FUN’
[17:39:23.792] Searching for globals ... DONE
[17:39:23.793] Resolving globals: FALSE
[17:39:23.793] The total size of the 1 globals is 848 bytes (848 bytes)
[17:39:23.793] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:39:23.793] - globals: [1] ‘FUN’
[17:39:23.793] 
[17:39:23.794] getGlobalsAndPackages() ... DONE
[17:39:23.794]  - globals found/used: [n=1] ‘FUN’
[17:39:23.794]  - needed namespaces: [n=0] 
[17:39:23.794] Finding globals ... DONE
[17:39:23.794]  - use_args: TRUE
[17:39:23.794]  - Getting '...' globals ...
[17:39:23.794] resolve() on list ...
[17:39:23.794]  recursive: 0
[17:39:23.795]  length: 1
[17:39:23.795]  elements: ‘...’
[17:39:23.795]  length: 0 (resolved future 1)
[17:39:23.795] resolve() on list ... DONE
[17:39:23.795]    - '...' content: [n=0] 
[17:39:23.795] List of 1
[17:39:23.795]  $ ...: list()
[17:39:23.795]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.795]  - attr(*, "where")=List of 1
[17:39:23.795]   ..$ ...:<environment: 0x55c79897c0a8> 
[17:39:23.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.795]  - attr(*, "resolved")= logi TRUE
[17:39:23.795]  - attr(*, "total_size")= num NA
[17:39:23.798]  - Getting '...' globals ... DONE
[17:39:23.798] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:23.798] List of 2
[17:39:23.798]  $ ...future.FUN:function (x)  
[17:39:23.798]  $ ...          : list()
[17:39:23.798]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.798]  - attr(*, "where")=List of 2
[17:39:23.798]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:23.798]   ..$ ...          :<environment: 0x55c79897c0a8> 
[17:39:23.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.798]  - attr(*, "resolved")= logi FALSE
[17:39:23.798]  - attr(*, "total_size")= num 848
[17:39:23.801] Packages to be attached in all futures: [n=0] 
[17:39:23.801] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.804] future_lapply() ...
[17:39:23.808] Number of chunks: 2
[17:39:23.808] getGlobalsAndPackagesXApply() ...
[17:39:23.808]  - future.globals: <name-value list> with names ‘list()’
[17:39:23.808]  - use_args: TRUE
[17:39:23.808] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:23.808] List of 2
[17:39:23.808]  $ ...          : list()
[17:39:23.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.808]  $ ...future.FUN:function (x)  
[17:39:23.808]  - attr(*, "where")=List of 2
[17:39:23.808]   ..$ ...          :<environment: 0x55c79897c0a8> 
[17:39:23.808]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:23.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.808]  - attr(*, "resolved")= logi FALSE
[17:39:23.808]  - attr(*, "total_size")= num NA
[17:39:23.814] Packages to be attached in all futures: [n=0] 
[17:39:23.814] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.814] Number of futures (= number of chunks): 2
[17:39:23.814] Launching 2 futures (chunks) ...
[17:39:23.814] Chunk #1 of 2 ...
[17:39:23.814]  - seeds: <none>
[17:39:23.814] getGlobalsAndPackages() ...
[17:39:23.814] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.815] Resolving globals: FALSE
[17:39:23.815] Tweak future expression to call with '...' arguments ...
[17:39:23.815] {
[17:39:23.815]     do.call(function(...) {
[17:39:23.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.815]             on.exit(options(oopts), add = TRUE)
[17:39:23.815]         }
[17:39:23.815]         {
[17:39:23.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.815]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.815]             })
[17:39:23.815]         }
[17:39:23.815]     }, args = future.call.arguments)
[17:39:23.815] }
[17:39:23.815] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.815] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.816] 
[17:39:23.816] getGlobalsAndPackages() ... DONE
[17:39:23.816] run() for ‘Future’ ...
[17:39:23.816] - state: ‘created’
[17:39:23.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.832] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.833]   - Field: ‘node’
[17:39:23.833]   - Field: ‘label’
[17:39:23.833]   - Field: ‘local’
[17:39:23.833]   - Field: ‘owner’
[17:39:23.833]   - Field: ‘envir’
[17:39:23.833]   - Field: ‘workers’
[17:39:23.833]   - Field: ‘packages’
[17:39:23.833]   - Field: ‘gc’
[17:39:23.833]   - Field: ‘conditions’
[17:39:23.833]   - Field: ‘persistent’
[17:39:23.833]   - Field: ‘expr’
[17:39:23.834]   - Field: ‘uuid’
[17:39:23.834]   - Field: ‘seed’
[17:39:23.834]   - Field: ‘version’
[17:39:23.834]   - Field: ‘result’
[17:39:23.834]   - Field: ‘asynchronous’
[17:39:23.834]   - Field: ‘calls’
[17:39:23.834]   - Field: ‘globals’
[17:39:23.834]   - Field: ‘stdout’
[17:39:23.834]   - Field: ‘earlySignal’
[17:39:23.834]   - Field: ‘lazy’
[17:39:23.834]   - Field: ‘state’
[17:39:23.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.835] - Launch lazy future ...
[17:39:23.835] Packages needed by the future expression (n = 0): <none>
[17:39:23.835] Packages needed by future strategies (n = 0): <none>
[17:39:23.835] {
[17:39:23.835]     {
[17:39:23.835]         {
[17:39:23.835]             ...future.startTime <- base::Sys.time()
[17:39:23.835]             {
[17:39:23.835]                 {
[17:39:23.835]                   {
[17:39:23.835]                     {
[17:39:23.835]                       base::local({
[17:39:23.835]                         has_future <- base::requireNamespace("future", 
[17:39:23.835]                           quietly = TRUE)
[17:39:23.835]                         if (has_future) {
[17:39:23.835]                           ns <- base::getNamespace("future")
[17:39:23.835]                           version <- ns[[".package"]][["version"]]
[17:39:23.835]                           if (is.null(version)) 
[17:39:23.835]                             version <- utils::packageVersion("future")
[17:39:23.835]                         }
[17:39:23.835]                         else {
[17:39:23.835]                           version <- NULL
[17:39:23.835]                         }
[17:39:23.835]                         if (!has_future || version < "1.8.0") {
[17:39:23.835]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.835]                             "", base::R.version$version.string), 
[17:39:23.835]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.835]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.835]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.835]                               "release", "version")], collapse = " "), 
[17:39:23.835]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.835]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.835]                             info)
[17:39:23.835]                           info <- base::paste(info, collapse = "; ")
[17:39:23.835]                           if (!has_future) {
[17:39:23.835]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.835]                               info)
[17:39:23.835]                           }
[17:39:23.835]                           else {
[17:39:23.835]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.835]                               info, version)
[17:39:23.835]                           }
[17:39:23.835]                           base::stop(msg)
[17:39:23.835]                         }
[17:39:23.835]                       })
[17:39:23.835]                     }
[17:39:23.835]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.835]                     base::options(mc.cores = 1L)
[17:39:23.835]                   }
[17:39:23.835]                   options(future.plan = NULL)
[17:39:23.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.835]                 }
[17:39:23.835]                 ...future.workdir <- getwd()
[17:39:23.835]             }
[17:39:23.835]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.835]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.835]         }
[17:39:23.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.835]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.835]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.835]             base::names(...future.oldOptions))
[17:39:23.835]     }
[17:39:23.835]     if (FALSE) {
[17:39:23.835]     }
[17:39:23.835]     else {
[17:39:23.835]         if (TRUE) {
[17:39:23.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.835]                 open = "w")
[17:39:23.835]         }
[17:39:23.835]         else {
[17:39:23.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.835]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.835]         }
[17:39:23.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.835]             base::sink(type = "output", split = FALSE)
[17:39:23.835]             base::close(...future.stdout)
[17:39:23.835]         }, add = TRUE)
[17:39:23.835]     }
[17:39:23.835]     ...future.frame <- base::sys.nframe()
[17:39:23.835]     ...future.conditions <- base::list()
[17:39:23.835]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.835]     if (FALSE) {
[17:39:23.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.835]     }
[17:39:23.835]     ...future.result <- base::tryCatch({
[17:39:23.835]         base::withCallingHandlers({
[17:39:23.835]             ...future.value <- base::withVisible(base::local({
[17:39:23.835]                 ...future.makeSendCondition <- local({
[17:39:23.835]                   sendCondition <- NULL
[17:39:23.835]                   function(frame = 1L) {
[17:39:23.835]                     if (is.function(sendCondition)) 
[17:39:23.835]                       return(sendCondition)
[17:39:23.835]                     ns <- getNamespace("parallel")
[17:39:23.835]                     if (exists("sendData", mode = "function", 
[17:39:23.835]                       envir = ns)) {
[17:39:23.835]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.835]                         envir = ns)
[17:39:23.835]                       envir <- sys.frame(frame)
[17:39:23.835]                       master <- NULL
[17:39:23.835]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.835]                         !identical(envir, emptyenv())) {
[17:39:23.835]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.835]                           inherits = FALSE)) {
[17:39:23.835]                           master <- get("master", mode = "list", 
[17:39:23.835]                             envir = envir, inherits = FALSE)
[17:39:23.835]                           if (inherits(master, c("SOCKnode", 
[17:39:23.835]                             "SOCK0node"))) {
[17:39:23.835]                             sendCondition <<- function(cond) {
[17:39:23.835]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.835]                                 success = TRUE)
[17:39:23.835]                               parallel_sendData(master, data)
[17:39:23.835]                             }
[17:39:23.835]                             return(sendCondition)
[17:39:23.835]                           }
[17:39:23.835]                         }
[17:39:23.835]                         frame <- frame + 1L
[17:39:23.835]                         envir <- sys.frame(frame)
[17:39:23.835]                       }
[17:39:23.835]                     }
[17:39:23.835]                     sendCondition <<- function(cond) NULL
[17:39:23.835]                   }
[17:39:23.835]                 })
[17:39:23.835]                 withCallingHandlers({
[17:39:23.835]                   {
[17:39:23.835]                     do.call(function(...) {
[17:39:23.835]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.835]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.835]                         ...future.globals.maxSize)) {
[17:39:23.835]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.835]                         on.exit(options(oopts), add = TRUE)
[17:39:23.835]                       }
[17:39:23.835]                       {
[17:39:23.835]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.835]                           FUN = function(jj) {
[17:39:23.835]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.835]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.835]                           })
[17:39:23.835]                       }
[17:39:23.835]                     }, args = future.call.arguments)
[17:39:23.835]                   }
[17:39:23.835]                 }, immediateCondition = function(cond) {
[17:39:23.835]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.835]                   sendCondition(cond)
[17:39:23.835]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.835]                   {
[17:39:23.835]                     inherits <- base::inherits
[17:39:23.835]                     invokeRestart <- base::invokeRestart
[17:39:23.835]                     is.null <- base::is.null
[17:39:23.835]                     muffled <- FALSE
[17:39:23.835]                     if (inherits(cond, "message")) {
[17:39:23.835]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.835]                       if (muffled) 
[17:39:23.835]                         invokeRestart("muffleMessage")
[17:39:23.835]                     }
[17:39:23.835]                     else if (inherits(cond, "warning")) {
[17:39:23.835]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.835]                       if (muffled) 
[17:39:23.835]                         invokeRestart("muffleWarning")
[17:39:23.835]                     }
[17:39:23.835]                     else if (inherits(cond, "condition")) {
[17:39:23.835]                       if (!is.null(pattern)) {
[17:39:23.835]                         computeRestarts <- base::computeRestarts
[17:39:23.835]                         grepl <- base::grepl
[17:39:23.835]                         restarts <- computeRestarts(cond)
[17:39:23.835]                         for (restart in restarts) {
[17:39:23.835]                           name <- restart$name
[17:39:23.835]                           if (is.null(name)) 
[17:39:23.835]                             next
[17:39:23.835]                           if (!grepl(pattern, name)) 
[17:39:23.835]                             next
[17:39:23.835]                           invokeRestart(restart)
[17:39:23.835]                           muffled <- TRUE
[17:39:23.835]                           break
[17:39:23.835]                         }
[17:39:23.835]                       }
[17:39:23.835]                     }
[17:39:23.835]                     invisible(muffled)
[17:39:23.835]                   }
[17:39:23.835]                   muffleCondition(cond)
[17:39:23.835]                 })
[17:39:23.835]             }))
[17:39:23.835]             future::FutureResult(value = ...future.value$value, 
[17:39:23.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.835]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.835]                     ...future.globalenv.names))
[17:39:23.835]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.835]         }, condition = base::local({
[17:39:23.835]             c <- base::c
[17:39:23.835]             inherits <- base::inherits
[17:39:23.835]             invokeRestart <- base::invokeRestart
[17:39:23.835]             length <- base::length
[17:39:23.835]             list <- base::list
[17:39:23.835]             seq.int <- base::seq.int
[17:39:23.835]             signalCondition <- base::signalCondition
[17:39:23.835]             sys.calls <- base::sys.calls
[17:39:23.835]             `[[` <- base::`[[`
[17:39:23.835]             `+` <- base::`+`
[17:39:23.835]             `<<-` <- base::`<<-`
[17:39:23.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.835]                   3L)]
[17:39:23.835]             }
[17:39:23.835]             function(cond) {
[17:39:23.835]                 is_error <- inherits(cond, "error")
[17:39:23.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.835]                   NULL)
[17:39:23.835]                 if (is_error) {
[17:39:23.835]                   sessionInformation <- function() {
[17:39:23.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.835]                       search = base::search(), system = base::Sys.info())
[17:39:23.835]                   }
[17:39:23.835]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.835]                     cond$call), session = sessionInformation(), 
[17:39:23.835]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.835]                   signalCondition(cond)
[17:39:23.835]                 }
[17:39:23.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.835]                 "immediateCondition"))) {
[17:39:23.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.835]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.835]                   if (TRUE && !signal) {
[17:39:23.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.835]                     {
[17:39:23.835]                       inherits <- base::inherits
[17:39:23.835]                       invokeRestart <- base::invokeRestart
[17:39:23.835]                       is.null <- base::is.null
[17:39:23.835]                       muffled <- FALSE
[17:39:23.835]                       if (inherits(cond, "message")) {
[17:39:23.835]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.835]                         if (muffled) 
[17:39:23.835]                           invokeRestart("muffleMessage")
[17:39:23.835]                       }
[17:39:23.835]                       else if (inherits(cond, "warning")) {
[17:39:23.835]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.835]                         if (muffled) 
[17:39:23.835]                           invokeRestart("muffleWarning")
[17:39:23.835]                       }
[17:39:23.835]                       else if (inherits(cond, "condition")) {
[17:39:23.835]                         if (!is.null(pattern)) {
[17:39:23.835]                           computeRestarts <- base::computeRestarts
[17:39:23.835]                           grepl <- base::grepl
[17:39:23.835]                           restarts <- computeRestarts(cond)
[17:39:23.835]                           for (restart in restarts) {
[17:39:23.835]                             name <- restart$name
[17:39:23.835]                             if (is.null(name)) 
[17:39:23.835]                               next
[17:39:23.835]                             if (!grepl(pattern, name)) 
[17:39:23.835]                               next
[17:39:23.835]                             invokeRestart(restart)
[17:39:23.835]                             muffled <- TRUE
[17:39:23.835]                             break
[17:39:23.835]                           }
[17:39:23.835]                         }
[17:39:23.835]                       }
[17:39:23.835]                       invisible(muffled)
[17:39:23.835]                     }
[17:39:23.835]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.835]                   }
[17:39:23.835]                 }
[17:39:23.835]                 else {
[17:39:23.835]                   if (TRUE) {
[17:39:23.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.835]                     {
[17:39:23.835]                       inherits <- base::inherits
[17:39:23.835]                       invokeRestart <- base::invokeRestart
[17:39:23.835]                       is.null <- base::is.null
[17:39:23.835]                       muffled <- FALSE
[17:39:23.835]                       if (inherits(cond, "message")) {
[17:39:23.835]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.835]                         if (muffled) 
[17:39:23.835]                           invokeRestart("muffleMessage")
[17:39:23.835]                       }
[17:39:23.835]                       else if (inherits(cond, "warning")) {
[17:39:23.835]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.835]                         if (muffled) 
[17:39:23.835]                           invokeRestart("muffleWarning")
[17:39:23.835]                       }
[17:39:23.835]                       else if (inherits(cond, "condition")) {
[17:39:23.835]                         if (!is.null(pattern)) {
[17:39:23.835]                           computeRestarts <- base::computeRestarts
[17:39:23.835]                           grepl <- base::grepl
[17:39:23.835]                           restarts <- computeRestarts(cond)
[17:39:23.835]                           for (restart in restarts) {
[17:39:23.835]                             name <- restart$name
[17:39:23.835]                             if (is.null(name)) 
[17:39:23.835]                               next
[17:39:23.835]                             if (!grepl(pattern, name)) 
[17:39:23.835]                               next
[17:39:23.835]                             invokeRestart(restart)
[17:39:23.835]                             muffled <- TRUE
[17:39:23.835]                             break
[17:39:23.835]                           }
[17:39:23.835]                         }
[17:39:23.835]                       }
[17:39:23.835]                       invisible(muffled)
[17:39:23.835]                     }
[17:39:23.835]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.835]                   }
[17:39:23.835]                 }
[17:39:23.835]             }
[17:39:23.835]         }))
[17:39:23.835]     }, error = function(ex) {
[17:39:23.835]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.835]                 ...future.rng), started = ...future.startTime, 
[17:39:23.835]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.835]             version = "1.8"), class = "FutureResult")
[17:39:23.835]     }, finally = {
[17:39:23.835]         if (!identical(...future.workdir, getwd())) 
[17:39:23.835]             setwd(...future.workdir)
[17:39:23.835]         {
[17:39:23.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.835]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.835]             }
[17:39:23.835]             base::options(...future.oldOptions)
[17:39:23.835]             if (.Platform$OS.type == "windows") {
[17:39:23.835]                 old_names <- names(...future.oldEnvVars)
[17:39:23.835]                 envs <- base::Sys.getenv()
[17:39:23.835]                 names <- names(envs)
[17:39:23.835]                 common <- intersect(names, old_names)
[17:39:23.835]                 added <- setdiff(names, old_names)
[17:39:23.835]                 removed <- setdiff(old_names, names)
[17:39:23.835]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.835]                   envs[common]]
[17:39:23.835]                 NAMES <- toupper(changed)
[17:39:23.835]                 args <- list()
[17:39:23.835]                 for (kk in seq_along(NAMES)) {
[17:39:23.835]                   name <- changed[[kk]]
[17:39:23.835]                   NAME <- NAMES[[kk]]
[17:39:23.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.835]                     next
[17:39:23.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.835]                 }
[17:39:23.835]                 NAMES <- toupper(added)
[17:39:23.835]                 for (kk in seq_along(NAMES)) {
[17:39:23.835]                   name <- added[[kk]]
[17:39:23.835]                   NAME <- NAMES[[kk]]
[17:39:23.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.835]                     next
[17:39:23.835]                   args[[name]] <- ""
[17:39:23.835]                 }
[17:39:23.835]                 NAMES <- toupper(removed)
[17:39:23.835]                 for (kk in seq_along(NAMES)) {
[17:39:23.835]                   name <- removed[[kk]]
[17:39:23.835]                   NAME <- NAMES[[kk]]
[17:39:23.835]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.835]                     next
[17:39:23.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.835]                 }
[17:39:23.835]                 if (length(args) > 0) 
[17:39:23.835]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.835]             }
[17:39:23.835]             else {
[17:39:23.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.835]             }
[17:39:23.835]             {
[17:39:23.835]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.835]                   0L) {
[17:39:23.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.835]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.835]                   base::options(opts)
[17:39:23.835]                 }
[17:39:23.835]                 {
[17:39:23.835]                   {
[17:39:23.835]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.835]                     NULL
[17:39:23.835]                   }
[17:39:23.835]                   options(future.plan = NULL)
[17:39:23.835]                   if (is.na(NA_character_)) 
[17:39:23.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.835]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.835]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.835]                     envir = parent.frame()) 
[17:39:23.835]                   {
[17:39:23.835]                     if (is.function(workers)) 
[17:39:23.835]                       workers <- workers()
[17:39:23.835]                     workers <- structure(as.integer(workers), 
[17:39:23.835]                       class = class(workers))
[17:39:23.835]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.835]                       workers >= 1)
[17:39:23.835]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.835]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.835]                     }
[17:39:23.835]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.835]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.835]                       envir = envir)
[17:39:23.835]                     if (!future$lazy) 
[17:39:23.835]                       future <- run(future)
[17:39:23.835]                     invisible(future)
[17:39:23.835]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.835]                 }
[17:39:23.835]             }
[17:39:23.835]         }
[17:39:23.835]     })
[17:39:23.835]     if (TRUE) {
[17:39:23.835]         base::sink(type = "output", split = FALSE)
[17:39:23.835]         if (TRUE) {
[17:39:23.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.835]         }
[17:39:23.835]         else {
[17:39:23.835]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.835]         }
[17:39:23.835]         base::close(...future.stdout)
[17:39:23.835]         ...future.stdout <- NULL
[17:39:23.835]     }
[17:39:23.835]     ...future.result$conditions <- ...future.conditions
[17:39:23.835]     ...future.result$finished <- base::Sys.time()
[17:39:23.835]     ...future.result
[17:39:23.835] }
[17:39:23.839] Exporting 5 global objects (1.07 KiB) to cluster node #1 ...
[17:39:23.839] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:23.839] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.839] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:39:23.840] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:39:23.840] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[17:39:23.840] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[17:39:23.840] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:23.840] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.841] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:23.841] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.841] Exporting 5 global objects (1.07 KiB) to cluster node #1 ... DONE
[17:39:23.841] MultisessionFuture started
[17:39:23.842] - Launch lazy future ... done
[17:39:23.842] run() for ‘MultisessionFuture’ ... done
[17:39:23.842] Created future:
[17:39:23.842] MultisessionFuture:
[17:39:23.842] Label: ‘future_apply-1’
[17:39:23.842] Expression:
[17:39:23.842] {
[17:39:23.842]     do.call(function(...) {
[17:39:23.842]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.842]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.842]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.842]             on.exit(options(oopts), add = TRUE)
[17:39:23.842]         }
[17:39:23.842]         {
[17:39:23.842]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.842]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.842]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.842]             })
[17:39:23.842]         }
[17:39:23.842]     }, args = future.call.arguments)
[17:39:23.842] }
[17:39:23.842] Lazy evaluation: FALSE
[17:39:23.842] Asynchronous evaluation: TRUE
[17:39:23.842] Local evaluation: TRUE
[17:39:23.842] Environment: R_GlobalEnv
[17:39:23.842] Capture standard output: TRUE
[17:39:23.842] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.842] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.842] Packages: <none>
[17:39:23.842] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.842] Resolved: FALSE
[17:39:23.842] Value: <not collected>
[17:39:23.842] Conditions captured: <none>
[17:39:23.842] Early signaling: FALSE
[17:39:23.842] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.842] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.853] Chunk #1 of 2 ... DONE
[17:39:23.853] Chunk #2 of 2 ...
[17:39:23.854]  - seeds: <none>
[17:39:23.854] getGlobalsAndPackages() ...
[17:39:23.854] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.854] Resolving globals: FALSE
[17:39:23.854] Tweak future expression to call with '...' arguments ...
[17:39:23.854] {
[17:39:23.854]     do.call(function(...) {
[17:39:23.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.854]             on.exit(options(oopts), add = TRUE)
[17:39:23.854]         }
[17:39:23.854]         {
[17:39:23.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.854]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.854]             })
[17:39:23.854]         }
[17:39:23.854]     }, args = future.call.arguments)
[17:39:23.854] }
[17:39:23.854] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.855] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.855] 
[17:39:23.855] getGlobalsAndPackages() ... DONE
[17:39:23.855] run() for ‘Future’ ...
[17:39:23.855] - state: ‘created’
[17:39:23.856] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.871] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.871] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.871]   - Field: ‘node’
[17:39:23.871]   - Field: ‘label’
[17:39:23.871]   - Field: ‘local’
[17:39:23.871]   - Field: ‘owner’
[17:39:23.871]   - Field: ‘envir’
[17:39:23.871]   - Field: ‘workers’
[17:39:23.871]   - Field: ‘packages’
[17:39:23.872]   - Field: ‘gc’
[17:39:23.872]   - Field: ‘conditions’
[17:39:23.872]   - Field: ‘persistent’
[17:39:23.872]   - Field: ‘expr’
[17:39:23.872]   - Field: ‘uuid’
[17:39:23.872]   - Field: ‘seed’
[17:39:23.872]   - Field: ‘version’
[17:39:23.872]   - Field: ‘result’
[17:39:23.872]   - Field: ‘asynchronous’
[17:39:23.872]   - Field: ‘calls’
[17:39:23.872]   - Field: ‘globals’
[17:39:23.873]   - Field: ‘stdout’
[17:39:23.873]   - Field: ‘earlySignal’
[17:39:23.873]   - Field: ‘lazy’
[17:39:23.873]   - Field: ‘state’
[17:39:23.873] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.873] - Launch lazy future ...
[17:39:23.873] Packages needed by the future expression (n = 0): <none>
[17:39:23.873] Packages needed by future strategies (n = 0): <none>
[17:39:23.874] {
[17:39:23.874]     {
[17:39:23.874]         {
[17:39:23.874]             ...future.startTime <- base::Sys.time()
[17:39:23.874]             {
[17:39:23.874]                 {
[17:39:23.874]                   {
[17:39:23.874]                     {
[17:39:23.874]                       base::local({
[17:39:23.874]                         has_future <- base::requireNamespace("future", 
[17:39:23.874]                           quietly = TRUE)
[17:39:23.874]                         if (has_future) {
[17:39:23.874]                           ns <- base::getNamespace("future")
[17:39:23.874]                           version <- ns[[".package"]][["version"]]
[17:39:23.874]                           if (is.null(version)) 
[17:39:23.874]                             version <- utils::packageVersion("future")
[17:39:23.874]                         }
[17:39:23.874]                         else {
[17:39:23.874]                           version <- NULL
[17:39:23.874]                         }
[17:39:23.874]                         if (!has_future || version < "1.8.0") {
[17:39:23.874]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.874]                             "", base::R.version$version.string), 
[17:39:23.874]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.874]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.874]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.874]                               "release", "version")], collapse = " "), 
[17:39:23.874]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.874]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.874]                             info)
[17:39:23.874]                           info <- base::paste(info, collapse = "; ")
[17:39:23.874]                           if (!has_future) {
[17:39:23.874]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.874]                               info)
[17:39:23.874]                           }
[17:39:23.874]                           else {
[17:39:23.874]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.874]                               info, version)
[17:39:23.874]                           }
[17:39:23.874]                           base::stop(msg)
[17:39:23.874]                         }
[17:39:23.874]                       })
[17:39:23.874]                     }
[17:39:23.874]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.874]                     base::options(mc.cores = 1L)
[17:39:23.874]                   }
[17:39:23.874]                   options(future.plan = NULL)
[17:39:23.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.874]                 }
[17:39:23.874]                 ...future.workdir <- getwd()
[17:39:23.874]             }
[17:39:23.874]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.874]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.874]         }
[17:39:23.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.874]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.874]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.874]             base::names(...future.oldOptions))
[17:39:23.874]     }
[17:39:23.874]     if (FALSE) {
[17:39:23.874]     }
[17:39:23.874]     else {
[17:39:23.874]         if (TRUE) {
[17:39:23.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.874]                 open = "w")
[17:39:23.874]         }
[17:39:23.874]         else {
[17:39:23.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.874]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.874]         }
[17:39:23.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.874]             base::sink(type = "output", split = FALSE)
[17:39:23.874]             base::close(...future.stdout)
[17:39:23.874]         }, add = TRUE)
[17:39:23.874]     }
[17:39:23.874]     ...future.frame <- base::sys.nframe()
[17:39:23.874]     ...future.conditions <- base::list()
[17:39:23.874]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.874]     if (FALSE) {
[17:39:23.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.874]     }
[17:39:23.874]     ...future.result <- base::tryCatch({
[17:39:23.874]         base::withCallingHandlers({
[17:39:23.874]             ...future.value <- base::withVisible(base::local({
[17:39:23.874]                 ...future.makeSendCondition <- local({
[17:39:23.874]                   sendCondition <- NULL
[17:39:23.874]                   function(frame = 1L) {
[17:39:23.874]                     if (is.function(sendCondition)) 
[17:39:23.874]                       return(sendCondition)
[17:39:23.874]                     ns <- getNamespace("parallel")
[17:39:23.874]                     if (exists("sendData", mode = "function", 
[17:39:23.874]                       envir = ns)) {
[17:39:23.874]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.874]                         envir = ns)
[17:39:23.874]                       envir <- sys.frame(frame)
[17:39:23.874]                       master <- NULL
[17:39:23.874]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.874]                         !identical(envir, emptyenv())) {
[17:39:23.874]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.874]                           inherits = FALSE)) {
[17:39:23.874]                           master <- get("master", mode = "list", 
[17:39:23.874]                             envir = envir, inherits = FALSE)
[17:39:23.874]                           if (inherits(master, c("SOCKnode", 
[17:39:23.874]                             "SOCK0node"))) {
[17:39:23.874]                             sendCondition <<- function(cond) {
[17:39:23.874]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.874]                                 success = TRUE)
[17:39:23.874]                               parallel_sendData(master, data)
[17:39:23.874]                             }
[17:39:23.874]                             return(sendCondition)
[17:39:23.874]                           }
[17:39:23.874]                         }
[17:39:23.874]                         frame <- frame + 1L
[17:39:23.874]                         envir <- sys.frame(frame)
[17:39:23.874]                       }
[17:39:23.874]                     }
[17:39:23.874]                     sendCondition <<- function(cond) NULL
[17:39:23.874]                   }
[17:39:23.874]                 })
[17:39:23.874]                 withCallingHandlers({
[17:39:23.874]                   {
[17:39:23.874]                     do.call(function(...) {
[17:39:23.874]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.874]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.874]                         ...future.globals.maxSize)) {
[17:39:23.874]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.874]                         on.exit(options(oopts), add = TRUE)
[17:39:23.874]                       }
[17:39:23.874]                       {
[17:39:23.874]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.874]                           FUN = function(jj) {
[17:39:23.874]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.874]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.874]                           })
[17:39:23.874]                       }
[17:39:23.874]                     }, args = future.call.arguments)
[17:39:23.874]                   }
[17:39:23.874]                 }, immediateCondition = function(cond) {
[17:39:23.874]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.874]                   sendCondition(cond)
[17:39:23.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.874]                   {
[17:39:23.874]                     inherits <- base::inherits
[17:39:23.874]                     invokeRestart <- base::invokeRestart
[17:39:23.874]                     is.null <- base::is.null
[17:39:23.874]                     muffled <- FALSE
[17:39:23.874]                     if (inherits(cond, "message")) {
[17:39:23.874]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.874]                       if (muffled) 
[17:39:23.874]                         invokeRestart("muffleMessage")
[17:39:23.874]                     }
[17:39:23.874]                     else if (inherits(cond, "warning")) {
[17:39:23.874]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.874]                       if (muffled) 
[17:39:23.874]                         invokeRestart("muffleWarning")
[17:39:23.874]                     }
[17:39:23.874]                     else if (inherits(cond, "condition")) {
[17:39:23.874]                       if (!is.null(pattern)) {
[17:39:23.874]                         computeRestarts <- base::computeRestarts
[17:39:23.874]                         grepl <- base::grepl
[17:39:23.874]                         restarts <- computeRestarts(cond)
[17:39:23.874]                         for (restart in restarts) {
[17:39:23.874]                           name <- restart$name
[17:39:23.874]                           if (is.null(name)) 
[17:39:23.874]                             next
[17:39:23.874]                           if (!grepl(pattern, name)) 
[17:39:23.874]                             next
[17:39:23.874]                           invokeRestart(restart)
[17:39:23.874]                           muffled <- TRUE
[17:39:23.874]                           break
[17:39:23.874]                         }
[17:39:23.874]                       }
[17:39:23.874]                     }
[17:39:23.874]                     invisible(muffled)
[17:39:23.874]                   }
[17:39:23.874]                   muffleCondition(cond)
[17:39:23.874]                 })
[17:39:23.874]             }))
[17:39:23.874]             future::FutureResult(value = ...future.value$value, 
[17:39:23.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.874]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.874]                     ...future.globalenv.names))
[17:39:23.874]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.874]         }, condition = base::local({
[17:39:23.874]             c <- base::c
[17:39:23.874]             inherits <- base::inherits
[17:39:23.874]             invokeRestart <- base::invokeRestart
[17:39:23.874]             length <- base::length
[17:39:23.874]             list <- base::list
[17:39:23.874]             seq.int <- base::seq.int
[17:39:23.874]             signalCondition <- base::signalCondition
[17:39:23.874]             sys.calls <- base::sys.calls
[17:39:23.874]             `[[` <- base::`[[`
[17:39:23.874]             `+` <- base::`+`
[17:39:23.874]             `<<-` <- base::`<<-`
[17:39:23.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.874]                   3L)]
[17:39:23.874]             }
[17:39:23.874]             function(cond) {
[17:39:23.874]                 is_error <- inherits(cond, "error")
[17:39:23.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.874]                   NULL)
[17:39:23.874]                 if (is_error) {
[17:39:23.874]                   sessionInformation <- function() {
[17:39:23.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.874]                       search = base::search(), system = base::Sys.info())
[17:39:23.874]                   }
[17:39:23.874]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.874]                     cond$call), session = sessionInformation(), 
[17:39:23.874]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.874]                   signalCondition(cond)
[17:39:23.874]                 }
[17:39:23.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.874]                 "immediateCondition"))) {
[17:39:23.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.874]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.874]                   if (TRUE && !signal) {
[17:39:23.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.874]                     {
[17:39:23.874]                       inherits <- base::inherits
[17:39:23.874]                       invokeRestart <- base::invokeRestart
[17:39:23.874]                       is.null <- base::is.null
[17:39:23.874]                       muffled <- FALSE
[17:39:23.874]                       if (inherits(cond, "message")) {
[17:39:23.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.874]                         if (muffled) 
[17:39:23.874]                           invokeRestart("muffleMessage")
[17:39:23.874]                       }
[17:39:23.874]                       else if (inherits(cond, "warning")) {
[17:39:23.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.874]                         if (muffled) 
[17:39:23.874]                           invokeRestart("muffleWarning")
[17:39:23.874]                       }
[17:39:23.874]                       else if (inherits(cond, "condition")) {
[17:39:23.874]                         if (!is.null(pattern)) {
[17:39:23.874]                           computeRestarts <- base::computeRestarts
[17:39:23.874]                           grepl <- base::grepl
[17:39:23.874]                           restarts <- computeRestarts(cond)
[17:39:23.874]                           for (restart in restarts) {
[17:39:23.874]                             name <- restart$name
[17:39:23.874]                             if (is.null(name)) 
[17:39:23.874]                               next
[17:39:23.874]                             if (!grepl(pattern, name)) 
[17:39:23.874]                               next
[17:39:23.874]                             invokeRestart(restart)
[17:39:23.874]                             muffled <- TRUE
[17:39:23.874]                             break
[17:39:23.874]                           }
[17:39:23.874]                         }
[17:39:23.874]                       }
[17:39:23.874]                       invisible(muffled)
[17:39:23.874]                     }
[17:39:23.874]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.874]                   }
[17:39:23.874]                 }
[17:39:23.874]                 else {
[17:39:23.874]                   if (TRUE) {
[17:39:23.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.874]                     {
[17:39:23.874]                       inherits <- base::inherits
[17:39:23.874]                       invokeRestart <- base::invokeRestart
[17:39:23.874]                       is.null <- base::is.null
[17:39:23.874]                       muffled <- FALSE
[17:39:23.874]                       if (inherits(cond, "message")) {
[17:39:23.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.874]                         if (muffled) 
[17:39:23.874]                           invokeRestart("muffleMessage")
[17:39:23.874]                       }
[17:39:23.874]                       else if (inherits(cond, "warning")) {
[17:39:23.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.874]                         if (muffled) 
[17:39:23.874]                           invokeRestart("muffleWarning")
[17:39:23.874]                       }
[17:39:23.874]                       else if (inherits(cond, "condition")) {
[17:39:23.874]                         if (!is.null(pattern)) {
[17:39:23.874]                           computeRestarts <- base::computeRestarts
[17:39:23.874]                           grepl <- base::grepl
[17:39:23.874]                           restarts <- computeRestarts(cond)
[17:39:23.874]                           for (restart in restarts) {
[17:39:23.874]                             name <- restart$name
[17:39:23.874]                             if (is.null(name)) 
[17:39:23.874]                               next
[17:39:23.874]                             if (!grepl(pattern, name)) 
[17:39:23.874]                               next
[17:39:23.874]                             invokeRestart(restart)
[17:39:23.874]                             muffled <- TRUE
[17:39:23.874]                             break
[17:39:23.874]                           }
[17:39:23.874]                         }
[17:39:23.874]                       }
[17:39:23.874]                       invisible(muffled)
[17:39:23.874]                     }
[17:39:23.874]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.874]                   }
[17:39:23.874]                 }
[17:39:23.874]             }
[17:39:23.874]         }))
[17:39:23.874]     }, error = function(ex) {
[17:39:23.874]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.874]                 ...future.rng), started = ...future.startTime, 
[17:39:23.874]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.874]             version = "1.8"), class = "FutureResult")
[17:39:23.874]     }, finally = {
[17:39:23.874]         if (!identical(...future.workdir, getwd())) 
[17:39:23.874]             setwd(...future.workdir)
[17:39:23.874]         {
[17:39:23.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.874]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.874]             }
[17:39:23.874]             base::options(...future.oldOptions)
[17:39:23.874]             if (.Platform$OS.type == "windows") {
[17:39:23.874]                 old_names <- names(...future.oldEnvVars)
[17:39:23.874]                 envs <- base::Sys.getenv()
[17:39:23.874]                 names <- names(envs)
[17:39:23.874]                 common <- intersect(names, old_names)
[17:39:23.874]                 added <- setdiff(names, old_names)
[17:39:23.874]                 removed <- setdiff(old_names, names)
[17:39:23.874]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.874]                   envs[common]]
[17:39:23.874]                 NAMES <- toupper(changed)
[17:39:23.874]                 args <- list()
[17:39:23.874]                 for (kk in seq_along(NAMES)) {
[17:39:23.874]                   name <- changed[[kk]]
[17:39:23.874]                   NAME <- NAMES[[kk]]
[17:39:23.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.874]                     next
[17:39:23.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.874]                 }
[17:39:23.874]                 NAMES <- toupper(added)
[17:39:23.874]                 for (kk in seq_along(NAMES)) {
[17:39:23.874]                   name <- added[[kk]]
[17:39:23.874]                   NAME <- NAMES[[kk]]
[17:39:23.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.874]                     next
[17:39:23.874]                   args[[name]] <- ""
[17:39:23.874]                 }
[17:39:23.874]                 NAMES <- toupper(removed)
[17:39:23.874]                 for (kk in seq_along(NAMES)) {
[17:39:23.874]                   name <- removed[[kk]]
[17:39:23.874]                   NAME <- NAMES[[kk]]
[17:39:23.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.874]                     next
[17:39:23.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.874]                 }
[17:39:23.874]                 if (length(args) > 0) 
[17:39:23.874]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.874]             }
[17:39:23.874]             else {
[17:39:23.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.874]             }
[17:39:23.874]             {
[17:39:23.874]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.874]                   0L) {
[17:39:23.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.874]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.874]                   base::options(opts)
[17:39:23.874]                 }
[17:39:23.874]                 {
[17:39:23.874]                   {
[17:39:23.874]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.874]                     NULL
[17:39:23.874]                   }
[17:39:23.874]                   options(future.plan = NULL)
[17:39:23.874]                   if (is.na(NA_character_)) 
[17:39:23.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.874]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.874]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.874]                     envir = parent.frame()) 
[17:39:23.874]                   {
[17:39:23.874]                     if (is.function(workers)) 
[17:39:23.874]                       workers <- workers()
[17:39:23.874]                     workers <- structure(as.integer(workers), 
[17:39:23.874]                       class = class(workers))
[17:39:23.874]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.874]                       workers >= 1)
[17:39:23.874]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.874]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.874]                     }
[17:39:23.874]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.874]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.874]                       envir = envir)
[17:39:23.874]                     if (!future$lazy) 
[17:39:23.874]                       future <- run(future)
[17:39:23.874]                     invisible(future)
[17:39:23.874]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.874]                 }
[17:39:23.874]             }
[17:39:23.874]         }
[17:39:23.874]     })
[17:39:23.874]     if (TRUE) {
[17:39:23.874]         base::sink(type = "output", split = FALSE)
[17:39:23.874]         if (TRUE) {
[17:39:23.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.874]         }
[17:39:23.874]         else {
[17:39:23.874]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.874]         }
[17:39:23.874]         base::close(...future.stdout)
[17:39:23.874]         ...future.stdout <- NULL
[17:39:23.874]     }
[17:39:23.874]     ...future.result$conditions <- ...future.conditions
[17:39:23.874]     ...future.result$finished <- base::Sys.time()
[17:39:23.874]     ...future.result
[17:39:23.874] }
[17:39:23.877] Exporting 5 global objects (1.07 KiB) to cluster node #2 ...
[17:39:23.877] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:23.878] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.878] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:39:23.878] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:39:23.878] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[17:39:23.879] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[17:39:23.879] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:23.879] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.879] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:23.880] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:23.880] Exporting 5 global objects (1.07 KiB) to cluster node #2 ... DONE
[17:39:23.880] MultisessionFuture started
[17:39:23.880] - Launch lazy future ... done
[17:39:23.881] run() for ‘MultisessionFuture’ ... done
[17:39:23.881] Created future:
[17:39:23.881] MultisessionFuture:
[17:39:23.881] Label: ‘future_apply-2’
[17:39:23.881] Expression:
[17:39:23.881] {
[17:39:23.881]     do.call(function(...) {
[17:39:23.881]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.881]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.881]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.881]             on.exit(options(oopts), add = TRUE)
[17:39:23.881]         }
[17:39:23.881]         {
[17:39:23.881]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.881]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.881]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.881]             })
[17:39:23.881]         }
[17:39:23.881]     }, args = future.call.arguments)
[17:39:23.881] }
[17:39:23.881] Lazy evaluation: FALSE
[17:39:23.881] Asynchronous evaluation: TRUE
[17:39:23.881] Local evaluation: TRUE
[17:39:23.881] Environment: R_GlobalEnv
[17:39:23.881] Capture standard output: TRUE
[17:39:23.881] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.881] Globals: 5 objects totaling 1.07 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.881] Packages: <none>
[17:39:23.881] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.881] Resolved: FALSE
[17:39:23.881] Value: <not collected>
[17:39:23.881] Conditions captured: <none>
[17:39:23.881] Early signaling: FALSE
[17:39:23.881] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.881] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.892] Chunk #2 of 2 ... DONE
[17:39:23.892] Launching 2 futures (chunks) ... DONE
[17:39:23.893] Resolving 2 futures (chunks) ...
[17:39:23.893] resolve() on list ...
[17:39:23.893]  recursive: 0
[17:39:23.893]  length: 2
[17:39:23.893] 
[17:39:23.893] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.894] - Validating connection of MultisessionFuture
[17:39:23.894] - received message: FutureResult
[17:39:23.894] - Received FutureResult
[17:39:23.894] - Erased future from FutureRegistry
[17:39:23.894] result() for ClusterFuture ...
[17:39:23.894] - result already collected: FutureResult
[17:39:23.894] result() for ClusterFuture ... done
[17:39:23.894] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.894] Future #1
[17:39:23.895] result() for ClusterFuture ...
[17:39:23.895] - result already collected: FutureResult
[17:39:23.895] result() for ClusterFuture ... done
[17:39:23.895] result() for ClusterFuture ...
[17:39:23.895] - result already collected: FutureResult
[17:39:23.895] result() for ClusterFuture ... done
[17:39:23.895] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:23.895] - nx: 2
[17:39:23.895] - relay: TRUE
[17:39:23.895] - stdout: TRUE
[17:39:23.895] - signal: TRUE
[17:39:23.896] - resignal: FALSE
[17:39:23.896] - force: TRUE
[17:39:23.896] - relayed: [n=2] FALSE, FALSE
[17:39:23.896] - queued futures: [n=2] FALSE, FALSE
[17:39:23.896]  - until=1
[17:39:23.896]  - relaying element #1
[17:39:23.896] result() for ClusterFuture ...
[17:39:23.896] - result already collected: FutureResult
[17:39:23.896] result() for ClusterFuture ... done
[17:39:23.896] result() for ClusterFuture ...
[17:39:23.896] - result already collected: FutureResult
[17:39:23.896] result() for ClusterFuture ... done
[17:39:23.897] result() for ClusterFuture ...
[17:39:23.897] - result already collected: FutureResult
[17:39:23.897] result() for ClusterFuture ... done
[17:39:23.897] result() for ClusterFuture ...
[17:39:23.897] - result already collected: FutureResult
[17:39:23.897] result() for ClusterFuture ... done
[17:39:23.897] - relayed: [n=2] TRUE, FALSE
[17:39:23.897] - queued futures: [n=2] TRUE, FALSE
[17:39:23.897] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:23.897]  length: 1 (resolved future 1)
[17:39:23.928] receiveMessageFromWorker() for ClusterFuture ...
[17:39:23.928] - Validating connection of MultisessionFuture
[17:39:23.928] - received message: FutureResult
[17:39:23.928] - Received FutureResult
[17:39:23.928] - Erased future from FutureRegistry
[17:39:23.928] result() for ClusterFuture ...
[17:39:23.928] - result already collected: FutureResult
[17:39:23.929] result() for ClusterFuture ... done
[17:39:23.929] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:23.929] Future #2
[17:39:23.929] result() for ClusterFuture ...
[17:39:23.929] - result already collected: FutureResult
[17:39:23.929] result() for ClusterFuture ... done
[17:39:23.929] result() for ClusterFuture ...
[17:39:23.929] - result already collected: FutureResult
[17:39:23.929] result() for ClusterFuture ... done
[17:39:23.929] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:23.930] - nx: 2
[17:39:23.930] - relay: TRUE
[17:39:23.930] - stdout: TRUE
[17:39:23.930] - signal: TRUE
[17:39:23.930] - resignal: FALSE
[17:39:23.930] - force: TRUE
[17:39:23.930] - relayed: [n=2] TRUE, FALSE
[17:39:23.930] - queued futures: [n=2] TRUE, FALSE
[17:39:23.930]  - until=2
[17:39:23.930]  - relaying element #2
[17:39:23.930] result() for ClusterFuture ...
[17:39:23.930] - result already collected: FutureResult
[17:39:23.931] result() for ClusterFuture ... done
[17:39:23.931] result() for ClusterFuture ...
[17:39:23.931] - result already collected: FutureResult
[17:39:23.931] result() for ClusterFuture ... done
[17:39:23.931] result() for ClusterFuture ...
[17:39:23.931] - result already collected: FutureResult
[17:39:23.931] result() for ClusterFuture ... done
[17:39:23.931] result() for ClusterFuture ...
[17:39:23.931] - result already collected: FutureResult
[17:39:23.931] result() for ClusterFuture ... done
[17:39:23.932] - relayed: [n=2] TRUE, TRUE
[17:39:23.932] - queued futures: [n=2] TRUE, TRUE
[17:39:23.932] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:23.932]  length: 0 (resolved future 2)
[17:39:23.932] Relaying remaining futures
[17:39:23.932] signalConditionsASAP(NULL, pos=0) ...
[17:39:23.932] - nx: 2
[17:39:23.932] - relay: TRUE
[17:39:23.932] - stdout: TRUE
[17:39:23.932] - signal: TRUE
[17:39:23.932] - resignal: FALSE
[17:39:23.933] - force: TRUE
[17:39:23.933] - relayed: [n=2] TRUE, TRUE
[17:39:23.933] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:23.933] - relayed: [n=2] TRUE, TRUE
[17:39:23.933] - queued futures: [n=2] TRUE, TRUE
[17:39:23.933] signalConditionsASAP(NULL, pos=0) ... done
[17:39:23.933] resolve() on list ... DONE
[17:39:23.933] result() for ClusterFuture ...
[17:39:23.933] - result already collected: FutureResult
[17:39:23.933] result() for ClusterFuture ... done
[17:39:23.933] result() for ClusterFuture ...
[17:39:23.934] - result already collected: FutureResult
[17:39:23.934] result() for ClusterFuture ... done
[17:39:23.934] result() for ClusterFuture ...
[17:39:23.934] - result already collected: FutureResult
[17:39:23.934] result() for ClusterFuture ... done
[17:39:23.934] result() for ClusterFuture ...
[17:39:23.934] - result already collected: FutureResult
[17:39:23.934] result() for ClusterFuture ... done
[17:39:23.934]  - Number of value chunks collected: 2
[17:39:23.934] Resolving 2 futures (chunks) ... DONE
[17:39:23.934] Reducing values from 2 chunks ...
[17:39:23.935]  - Number of values collected after concatenation: 2
[17:39:23.935]  - Number of values expected: 2
[17:39:23.935] Reducing values from 2 chunks ... DONE
[17:39:23.935] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:39:23.935] getGlobalsAndPackagesXApply() ...
[17:39:23.935]  - future.globals: TRUE
[17:39:23.935] getGlobalsAndPackages() ...
[17:39:23.936] Searching for globals...
[17:39:23.938] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:39:23.938] Searching for globals ... DONE
[17:39:23.938] Resolving globals: FALSE
[17:39:23.939] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:39:23.939] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:39:23.939] - globals: [1] ‘FUN’
[17:39:23.939] 
[17:39:23.940] getGlobalsAndPackages() ... DONE
[17:39:23.940]  - globals found/used: [n=1] ‘FUN’
[17:39:23.940]  - needed namespaces: [n=0] 
[17:39:23.940] Finding globals ... DONE
[17:39:23.940]  - use_args: TRUE
[17:39:23.940]  - Getting '...' globals ...
[17:39:23.940] resolve() on list ...
[17:39:23.940]  recursive: 0
[17:39:23.941]  length: 1
[17:39:23.941]  elements: ‘...’
[17:39:23.941]  length: 0 (resolved future 1)
[17:39:23.941] resolve() on list ... DONE
[17:39:23.941]    - '...' content: [n=0] 
[17:39:23.941] List of 1
[17:39:23.941]  $ ...: list()
[17:39:23.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.941]  - attr(*, "where")=List of 1
[17:39:23.941]   ..$ ...:<environment: 0x55c798153210> 
[17:39:23.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.941]  - attr(*, "resolved")= logi TRUE
[17:39:23.941]  - attr(*, "total_size")= num NA
[17:39:23.944]  - Getting '...' globals ... DONE
[17:39:23.944] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:23.944] List of 2
[17:39:23.944]  $ ...future.FUN:function (x)  
[17:39:23.944]  $ ...          : list()
[17:39:23.944]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.944]  - attr(*, "where")=List of 2
[17:39:23.944]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:23.944]   ..$ ...          :<environment: 0x55c798153210> 
[17:39:23.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.944]  - attr(*, "resolved")= logi FALSE
[17:39:23.944]  - attr(*, "total_size")= num 9888
[17:39:23.946] Packages to be attached in all futures: [n=0] 
[17:39:23.947] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.950] future_lapply() ...
[17:39:23.956] Number of chunks: 2
[17:39:23.956] getGlobalsAndPackagesXApply() ...
[17:39:23.956]  - future.globals: <name-value list> with names ‘list()’
[17:39:23.956]  - use_args: TRUE
[17:39:23.956] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:23.956] List of 2
[17:39:23.956]  $ ...          : list()
[17:39:23.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:23.956]  $ ...future.FUN:function (x)  
[17:39:23.956]  - attr(*, "where")=List of 2
[17:39:23.956]   ..$ ...          :<environment: 0x55c798153210> 
[17:39:23.956]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:39:23.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:23.956]  - attr(*, "resolved")= logi FALSE
[17:39:23.956]  - attr(*, "total_size")= num NA
[17:39:23.959] Packages to be attached in all futures: [n=0] 
[17:39:23.959] getGlobalsAndPackagesXApply() ... DONE
[17:39:23.959] Number of futures (= number of chunks): 2
[17:39:23.960] Launching 2 futures (chunks) ...
[17:39:23.960] Chunk #1 of 2 ...
[17:39:23.960]  - seeds: <none>
[17:39:23.960] getGlobalsAndPackages() ...
[17:39:23.960] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.960] Resolving globals: FALSE
[17:39:23.960] Tweak future expression to call with '...' arguments ...
[17:39:23.960] {
[17:39:23.960]     do.call(function(...) {
[17:39:23.960]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.960]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.960]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.960]             on.exit(options(oopts), add = TRUE)
[17:39:23.960]         }
[17:39:23.960]         {
[17:39:23.960]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.960]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.960]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.960]             })
[17:39:23.960]         }
[17:39:23.960]     }, args = future.call.arguments)
[17:39:23.960] }
[17:39:23.961] Tweak future expression to call with '...' arguments ... DONE
[17:39:23.961] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.961] 
[17:39:23.961] getGlobalsAndPackages() ... DONE
[17:39:23.961] run() for ‘Future’ ...
[17:39:23.962] - state: ‘created’
[17:39:23.962] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:23.976] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:23.977]   - Field: ‘node’
[17:39:23.977]   - Field: ‘label’
[17:39:23.977]   - Field: ‘local’
[17:39:23.977]   - Field: ‘owner’
[17:39:23.977]   - Field: ‘envir’
[17:39:23.977]   - Field: ‘workers’
[17:39:23.977]   - Field: ‘packages’
[17:39:23.977]   - Field: ‘gc’
[17:39:23.977]   - Field: ‘conditions’
[17:39:23.978]   - Field: ‘persistent’
[17:39:23.978]   - Field: ‘expr’
[17:39:23.978]   - Field: ‘uuid’
[17:39:23.978]   - Field: ‘seed’
[17:39:23.978]   - Field: ‘version’
[17:39:23.978]   - Field: ‘result’
[17:39:23.978]   - Field: ‘asynchronous’
[17:39:23.978]   - Field: ‘calls’
[17:39:23.978]   - Field: ‘globals’
[17:39:23.978]   - Field: ‘stdout’
[17:39:23.978]   - Field: ‘earlySignal’
[17:39:23.979]   - Field: ‘lazy’
[17:39:23.979]   - Field: ‘state’
[17:39:23.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:23.979] - Launch lazy future ...
[17:39:23.979] Packages needed by the future expression (n = 0): <none>
[17:39:23.979] Packages needed by future strategies (n = 0): <none>
[17:39:23.980] {
[17:39:23.980]     {
[17:39:23.980]         {
[17:39:23.980]             ...future.startTime <- base::Sys.time()
[17:39:23.980]             {
[17:39:23.980]                 {
[17:39:23.980]                   {
[17:39:23.980]                     {
[17:39:23.980]                       base::local({
[17:39:23.980]                         has_future <- base::requireNamespace("future", 
[17:39:23.980]                           quietly = TRUE)
[17:39:23.980]                         if (has_future) {
[17:39:23.980]                           ns <- base::getNamespace("future")
[17:39:23.980]                           version <- ns[[".package"]][["version"]]
[17:39:23.980]                           if (is.null(version)) 
[17:39:23.980]                             version <- utils::packageVersion("future")
[17:39:23.980]                         }
[17:39:23.980]                         else {
[17:39:23.980]                           version <- NULL
[17:39:23.980]                         }
[17:39:23.980]                         if (!has_future || version < "1.8.0") {
[17:39:23.980]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:23.980]                             "", base::R.version$version.string), 
[17:39:23.980]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:23.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:23.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:23.980]                               "release", "version")], collapse = " "), 
[17:39:23.980]                             hostname = base::Sys.info()[["nodename"]])
[17:39:23.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:23.980]                             info)
[17:39:23.980]                           info <- base::paste(info, collapse = "; ")
[17:39:23.980]                           if (!has_future) {
[17:39:23.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:23.980]                               info)
[17:39:23.980]                           }
[17:39:23.980]                           else {
[17:39:23.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:23.980]                               info, version)
[17:39:23.980]                           }
[17:39:23.980]                           base::stop(msg)
[17:39:23.980]                         }
[17:39:23.980]                       })
[17:39:23.980]                     }
[17:39:23.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:23.980]                     base::options(mc.cores = 1L)
[17:39:23.980]                   }
[17:39:23.980]                   options(future.plan = NULL)
[17:39:23.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:23.980]                 }
[17:39:23.980]                 ...future.workdir <- getwd()
[17:39:23.980]             }
[17:39:23.980]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:23.980]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:23.980]         }
[17:39:23.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:23.980]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:23.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:23.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:23.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:23.980]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:23.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:23.980]             base::names(...future.oldOptions))
[17:39:23.980]     }
[17:39:23.980]     if (FALSE) {
[17:39:23.980]     }
[17:39:23.980]     else {
[17:39:23.980]         if (TRUE) {
[17:39:23.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:23.980]                 open = "w")
[17:39:23.980]         }
[17:39:23.980]         else {
[17:39:23.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:23.980]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:23.980]         }
[17:39:23.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:23.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:23.980]             base::sink(type = "output", split = FALSE)
[17:39:23.980]             base::close(...future.stdout)
[17:39:23.980]         }, add = TRUE)
[17:39:23.980]     }
[17:39:23.980]     ...future.frame <- base::sys.nframe()
[17:39:23.980]     ...future.conditions <- base::list()
[17:39:23.980]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:23.980]     if (FALSE) {
[17:39:23.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:23.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:23.980]     }
[17:39:23.980]     ...future.result <- base::tryCatch({
[17:39:23.980]         base::withCallingHandlers({
[17:39:23.980]             ...future.value <- base::withVisible(base::local({
[17:39:23.980]                 ...future.makeSendCondition <- local({
[17:39:23.980]                   sendCondition <- NULL
[17:39:23.980]                   function(frame = 1L) {
[17:39:23.980]                     if (is.function(sendCondition)) 
[17:39:23.980]                       return(sendCondition)
[17:39:23.980]                     ns <- getNamespace("parallel")
[17:39:23.980]                     if (exists("sendData", mode = "function", 
[17:39:23.980]                       envir = ns)) {
[17:39:23.980]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:23.980]                         envir = ns)
[17:39:23.980]                       envir <- sys.frame(frame)
[17:39:23.980]                       master <- NULL
[17:39:23.980]                       while (!identical(envir, .GlobalEnv) && 
[17:39:23.980]                         !identical(envir, emptyenv())) {
[17:39:23.980]                         if (exists("master", mode = "list", envir = envir, 
[17:39:23.980]                           inherits = FALSE)) {
[17:39:23.980]                           master <- get("master", mode = "list", 
[17:39:23.980]                             envir = envir, inherits = FALSE)
[17:39:23.980]                           if (inherits(master, c("SOCKnode", 
[17:39:23.980]                             "SOCK0node"))) {
[17:39:23.980]                             sendCondition <<- function(cond) {
[17:39:23.980]                               data <- list(type = "VALUE", value = cond, 
[17:39:23.980]                                 success = TRUE)
[17:39:23.980]                               parallel_sendData(master, data)
[17:39:23.980]                             }
[17:39:23.980]                             return(sendCondition)
[17:39:23.980]                           }
[17:39:23.980]                         }
[17:39:23.980]                         frame <- frame + 1L
[17:39:23.980]                         envir <- sys.frame(frame)
[17:39:23.980]                       }
[17:39:23.980]                     }
[17:39:23.980]                     sendCondition <<- function(cond) NULL
[17:39:23.980]                   }
[17:39:23.980]                 })
[17:39:23.980]                 withCallingHandlers({
[17:39:23.980]                   {
[17:39:23.980]                     do.call(function(...) {
[17:39:23.980]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.980]                       if (!identical(...future.globals.maxSize.org, 
[17:39:23.980]                         ...future.globals.maxSize)) {
[17:39:23.980]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.980]                         on.exit(options(oopts), add = TRUE)
[17:39:23.980]                       }
[17:39:23.980]                       {
[17:39:23.980]                         lapply(seq_along(...future.elements_ii), 
[17:39:23.980]                           FUN = function(jj) {
[17:39:23.980]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.980]                             ...future.FUN(...future.X_jj, ...)
[17:39:23.980]                           })
[17:39:23.980]                       }
[17:39:23.980]                     }, args = future.call.arguments)
[17:39:23.980]                   }
[17:39:23.980]                 }, immediateCondition = function(cond) {
[17:39:23.980]                   sendCondition <- ...future.makeSendCondition()
[17:39:23.980]                   sendCondition(cond)
[17:39:23.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.980]                   {
[17:39:23.980]                     inherits <- base::inherits
[17:39:23.980]                     invokeRestart <- base::invokeRestart
[17:39:23.980]                     is.null <- base::is.null
[17:39:23.980]                     muffled <- FALSE
[17:39:23.980]                     if (inherits(cond, "message")) {
[17:39:23.980]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:23.980]                       if (muffled) 
[17:39:23.980]                         invokeRestart("muffleMessage")
[17:39:23.980]                     }
[17:39:23.980]                     else if (inherits(cond, "warning")) {
[17:39:23.980]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:23.980]                       if (muffled) 
[17:39:23.980]                         invokeRestart("muffleWarning")
[17:39:23.980]                     }
[17:39:23.980]                     else if (inherits(cond, "condition")) {
[17:39:23.980]                       if (!is.null(pattern)) {
[17:39:23.980]                         computeRestarts <- base::computeRestarts
[17:39:23.980]                         grepl <- base::grepl
[17:39:23.980]                         restarts <- computeRestarts(cond)
[17:39:23.980]                         for (restart in restarts) {
[17:39:23.980]                           name <- restart$name
[17:39:23.980]                           if (is.null(name)) 
[17:39:23.980]                             next
[17:39:23.980]                           if (!grepl(pattern, name)) 
[17:39:23.980]                             next
[17:39:23.980]                           invokeRestart(restart)
[17:39:23.980]                           muffled <- TRUE
[17:39:23.980]                           break
[17:39:23.980]                         }
[17:39:23.980]                       }
[17:39:23.980]                     }
[17:39:23.980]                     invisible(muffled)
[17:39:23.980]                   }
[17:39:23.980]                   muffleCondition(cond)
[17:39:23.980]                 })
[17:39:23.980]             }))
[17:39:23.980]             future::FutureResult(value = ...future.value$value, 
[17:39:23.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.980]                   ...future.rng), globalenv = if (FALSE) 
[17:39:23.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:23.980]                     ...future.globalenv.names))
[17:39:23.980]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:23.980]         }, condition = base::local({
[17:39:23.980]             c <- base::c
[17:39:23.980]             inherits <- base::inherits
[17:39:23.980]             invokeRestart <- base::invokeRestart
[17:39:23.980]             length <- base::length
[17:39:23.980]             list <- base::list
[17:39:23.980]             seq.int <- base::seq.int
[17:39:23.980]             signalCondition <- base::signalCondition
[17:39:23.980]             sys.calls <- base::sys.calls
[17:39:23.980]             `[[` <- base::`[[`
[17:39:23.980]             `+` <- base::`+`
[17:39:23.980]             `<<-` <- base::`<<-`
[17:39:23.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:23.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:23.980]                   3L)]
[17:39:23.980]             }
[17:39:23.980]             function(cond) {
[17:39:23.980]                 is_error <- inherits(cond, "error")
[17:39:23.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:23.980]                   NULL)
[17:39:23.980]                 if (is_error) {
[17:39:23.980]                   sessionInformation <- function() {
[17:39:23.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:23.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:23.980]                       search = base::search(), system = base::Sys.info())
[17:39:23.980]                   }
[17:39:23.980]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:23.980]                     cond$call), session = sessionInformation(), 
[17:39:23.980]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:23.980]                   signalCondition(cond)
[17:39:23.980]                 }
[17:39:23.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:23.980]                 "immediateCondition"))) {
[17:39:23.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:23.980]                   ...future.conditions[[length(...future.conditions) + 
[17:39:23.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:23.980]                   if (TRUE && !signal) {
[17:39:23.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.980]                     {
[17:39:23.980]                       inherits <- base::inherits
[17:39:23.980]                       invokeRestart <- base::invokeRestart
[17:39:23.980]                       is.null <- base::is.null
[17:39:23.980]                       muffled <- FALSE
[17:39:23.980]                       if (inherits(cond, "message")) {
[17:39:23.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.980]                         if (muffled) 
[17:39:23.980]                           invokeRestart("muffleMessage")
[17:39:23.980]                       }
[17:39:23.980]                       else if (inherits(cond, "warning")) {
[17:39:23.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.980]                         if (muffled) 
[17:39:23.980]                           invokeRestart("muffleWarning")
[17:39:23.980]                       }
[17:39:23.980]                       else if (inherits(cond, "condition")) {
[17:39:23.980]                         if (!is.null(pattern)) {
[17:39:23.980]                           computeRestarts <- base::computeRestarts
[17:39:23.980]                           grepl <- base::grepl
[17:39:23.980]                           restarts <- computeRestarts(cond)
[17:39:23.980]                           for (restart in restarts) {
[17:39:23.980]                             name <- restart$name
[17:39:23.980]                             if (is.null(name)) 
[17:39:23.980]                               next
[17:39:23.980]                             if (!grepl(pattern, name)) 
[17:39:23.980]                               next
[17:39:23.980]                             invokeRestart(restart)
[17:39:23.980]                             muffled <- TRUE
[17:39:23.980]                             break
[17:39:23.980]                           }
[17:39:23.980]                         }
[17:39:23.980]                       }
[17:39:23.980]                       invisible(muffled)
[17:39:23.980]                     }
[17:39:23.980]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.980]                   }
[17:39:23.980]                 }
[17:39:23.980]                 else {
[17:39:23.980]                   if (TRUE) {
[17:39:23.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:23.980]                     {
[17:39:23.980]                       inherits <- base::inherits
[17:39:23.980]                       invokeRestart <- base::invokeRestart
[17:39:23.980]                       is.null <- base::is.null
[17:39:23.980]                       muffled <- FALSE
[17:39:23.980]                       if (inherits(cond, "message")) {
[17:39:23.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:23.980]                         if (muffled) 
[17:39:23.980]                           invokeRestart("muffleMessage")
[17:39:23.980]                       }
[17:39:23.980]                       else if (inherits(cond, "warning")) {
[17:39:23.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:23.980]                         if (muffled) 
[17:39:23.980]                           invokeRestart("muffleWarning")
[17:39:23.980]                       }
[17:39:23.980]                       else if (inherits(cond, "condition")) {
[17:39:23.980]                         if (!is.null(pattern)) {
[17:39:23.980]                           computeRestarts <- base::computeRestarts
[17:39:23.980]                           grepl <- base::grepl
[17:39:23.980]                           restarts <- computeRestarts(cond)
[17:39:23.980]                           for (restart in restarts) {
[17:39:23.980]                             name <- restart$name
[17:39:23.980]                             if (is.null(name)) 
[17:39:23.980]                               next
[17:39:23.980]                             if (!grepl(pattern, name)) 
[17:39:23.980]                               next
[17:39:23.980]                             invokeRestart(restart)
[17:39:23.980]                             muffled <- TRUE
[17:39:23.980]                             break
[17:39:23.980]                           }
[17:39:23.980]                         }
[17:39:23.980]                       }
[17:39:23.980]                       invisible(muffled)
[17:39:23.980]                     }
[17:39:23.980]                     muffleCondition(cond, pattern = "^muffle")
[17:39:23.980]                   }
[17:39:23.980]                 }
[17:39:23.980]             }
[17:39:23.980]         }))
[17:39:23.980]     }, error = function(ex) {
[17:39:23.980]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:23.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:23.980]                 ...future.rng), started = ...future.startTime, 
[17:39:23.980]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:23.980]             version = "1.8"), class = "FutureResult")
[17:39:23.980]     }, finally = {
[17:39:23.980]         if (!identical(...future.workdir, getwd())) 
[17:39:23.980]             setwd(...future.workdir)
[17:39:23.980]         {
[17:39:23.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:23.980]                 ...future.oldOptions$nwarnings <- NULL
[17:39:23.980]             }
[17:39:23.980]             base::options(...future.oldOptions)
[17:39:23.980]             if (.Platform$OS.type == "windows") {
[17:39:23.980]                 old_names <- names(...future.oldEnvVars)
[17:39:23.980]                 envs <- base::Sys.getenv()
[17:39:23.980]                 names <- names(envs)
[17:39:23.980]                 common <- intersect(names, old_names)
[17:39:23.980]                 added <- setdiff(names, old_names)
[17:39:23.980]                 removed <- setdiff(old_names, names)
[17:39:23.980]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:23.980]                   envs[common]]
[17:39:23.980]                 NAMES <- toupper(changed)
[17:39:23.980]                 args <- list()
[17:39:23.980]                 for (kk in seq_along(NAMES)) {
[17:39:23.980]                   name <- changed[[kk]]
[17:39:23.980]                   NAME <- NAMES[[kk]]
[17:39:23.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.980]                     next
[17:39:23.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.980]                 }
[17:39:23.980]                 NAMES <- toupper(added)
[17:39:23.980]                 for (kk in seq_along(NAMES)) {
[17:39:23.980]                   name <- added[[kk]]
[17:39:23.980]                   NAME <- NAMES[[kk]]
[17:39:23.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.980]                     next
[17:39:23.980]                   args[[name]] <- ""
[17:39:23.980]                 }
[17:39:23.980]                 NAMES <- toupper(removed)
[17:39:23.980]                 for (kk in seq_along(NAMES)) {
[17:39:23.980]                   name <- removed[[kk]]
[17:39:23.980]                   NAME <- NAMES[[kk]]
[17:39:23.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:23.980]                     next
[17:39:23.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:23.980]                 }
[17:39:23.980]                 if (length(args) > 0) 
[17:39:23.980]                   base::do.call(base::Sys.setenv, args = args)
[17:39:23.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:23.980]             }
[17:39:23.980]             else {
[17:39:23.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:23.980]             }
[17:39:23.980]             {
[17:39:23.980]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:23.980]                   0L) {
[17:39:23.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:23.980]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:23.980]                   base::options(opts)
[17:39:23.980]                 }
[17:39:23.980]                 {
[17:39:23.980]                   {
[17:39:23.980]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:23.980]                     NULL
[17:39:23.980]                   }
[17:39:23.980]                   options(future.plan = NULL)
[17:39:23.980]                   if (is.na(NA_character_)) 
[17:39:23.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:23.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:23.980]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:23.980]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:23.980]                     envir = parent.frame()) 
[17:39:23.980]                   {
[17:39:23.980]                     if (is.function(workers)) 
[17:39:23.980]                       workers <- workers()
[17:39:23.980]                     workers <- structure(as.integer(workers), 
[17:39:23.980]                       class = class(workers))
[17:39:23.980]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:23.980]                       workers >= 1)
[17:39:23.980]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:23.980]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:23.980]                     }
[17:39:23.980]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:23.980]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:23.980]                       envir = envir)
[17:39:23.980]                     if (!future$lazy) 
[17:39:23.980]                       future <- run(future)
[17:39:23.980]                     invisible(future)
[17:39:23.980]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:23.980]                 }
[17:39:23.980]             }
[17:39:23.980]         }
[17:39:23.980]     })
[17:39:23.980]     if (TRUE) {
[17:39:23.980]         base::sink(type = "output", split = FALSE)
[17:39:23.980]         if (TRUE) {
[17:39:23.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:23.980]         }
[17:39:23.980]         else {
[17:39:23.980]             ...future.result["stdout"] <- base::list(NULL)
[17:39:23.980]         }
[17:39:23.980]         base::close(...future.stdout)
[17:39:23.980]         ...future.stdout <- NULL
[17:39:23.980]     }
[17:39:23.980]     ...future.result$conditions <- ...future.conditions
[17:39:23.980]     ...future.result$finished <- base::Sys.time()
[17:39:23.980]     ...future.result
[17:39:23.980] }
[17:39:23.983] Exporting 5 global objects (9.71 KiB) to cluster node #1 ...
[17:39:23.983] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:23.984] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.984] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[17:39:23.984] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[17:39:23.984] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:39:23.985] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:23.985] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:39:23.985] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.985] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:23.985] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:23.985] Exporting 5 global objects (9.71 KiB) to cluster node #1 ... DONE
[17:39:23.986] MultisessionFuture started
[17:39:23.986] - Launch lazy future ... done
[17:39:23.986] run() for ‘MultisessionFuture’ ... done
[17:39:23.986] Created future:
[17:39:23.986] MultisessionFuture:
[17:39:23.986] Label: ‘future_apply-1’
[17:39:23.986] Expression:
[17:39:23.986] {
[17:39:23.986]     do.call(function(...) {
[17:39:23.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.986]             on.exit(options(oopts), add = TRUE)
[17:39:23.986]         }
[17:39:23.986]         {
[17:39:23.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.986]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.986]             })
[17:39:23.986]         }
[17:39:23.986]     }, args = future.call.arguments)
[17:39:23.986] }
[17:39:23.986] Lazy evaluation: FALSE
[17:39:23.986] Asynchronous evaluation: TRUE
[17:39:23.986] Local evaluation: TRUE
[17:39:23.986] Environment: R_GlobalEnv
[17:39:23.986] Capture standard output: TRUE
[17:39:23.986] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:23.986] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:23.986] Packages: <none>
[17:39:23.986] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:23.986] Resolved: FALSE
[17:39:23.986] Value: <not collected>
[17:39:23.986] Conditions captured: <none>
[17:39:23.986] Early signaling: FALSE
[17:39:23.986] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:23.986] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:23.998] Chunk #1 of 2 ... DONE
[17:39:23.998] Chunk #2 of 2 ...
[17:39:23.998]  - seeds: <none>
[17:39:23.999] getGlobalsAndPackages() ...
[17:39:23.999] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:23.999] Resolving globals: FALSE
[17:39:23.999] Tweak future expression to call with '...' arguments ...
[17:39:23.999] {
[17:39:23.999]     do.call(function(...) {
[17:39:23.999]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:23.999]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:23.999]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:23.999]             on.exit(options(oopts), add = TRUE)
[17:39:23.999]         }
[17:39:23.999]         {
[17:39:23.999]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:23.999]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:23.999]                 ...future.FUN(...future.X_jj, ...)
[17:39:23.999]             })
[17:39:23.999]         }
[17:39:23.999]     }, args = future.call.arguments)
[17:39:23.999] }
[17:39:23.999] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.000] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.000] 
[17:39:24.000] getGlobalsAndPackages() ... DONE
[17:39:24.003] run() for ‘Future’ ...
[17:39:24.003] - state: ‘created’
[17:39:24.003] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:24.018] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:24.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:24.018]   - Field: ‘node’
[17:39:24.018]   - Field: ‘label’
[17:39:24.018]   - Field: ‘local’
[17:39:24.018]   - Field: ‘owner’
[17:39:24.018]   - Field: ‘envir’
[17:39:24.018]   - Field: ‘workers’
[17:39:24.019]   - Field: ‘packages’
[17:39:24.019]   - Field: ‘gc’
[17:39:24.019]   - Field: ‘conditions’
[17:39:24.019]   - Field: ‘persistent’
[17:39:24.019]   - Field: ‘expr’
[17:39:24.019]   - Field: ‘uuid’
[17:39:24.019]   - Field: ‘seed’
[17:39:24.019]   - Field: ‘version’
[17:39:24.019]   - Field: ‘result’
[17:39:24.019]   - Field: ‘asynchronous’
[17:39:24.020]   - Field: ‘calls’
[17:39:24.020]   - Field: ‘globals’
[17:39:24.020]   - Field: ‘stdout’
[17:39:24.020]   - Field: ‘earlySignal’
[17:39:24.020]   - Field: ‘lazy’
[17:39:24.020]   - Field: ‘state’
[17:39:24.020] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:24.020] - Launch lazy future ...
[17:39:24.020] Packages needed by the future expression (n = 0): <none>
[17:39:24.021] Packages needed by future strategies (n = 0): <none>
[17:39:24.021] {
[17:39:24.021]     {
[17:39:24.021]         {
[17:39:24.021]             ...future.startTime <- base::Sys.time()
[17:39:24.021]             {
[17:39:24.021]                 {
[17:39:24.021]                   {
[17:39:24.021]                     {
[17:39:24.021]                       base::local({
[17:39:24.021]                         has_future <- base::requireNamespace("future", 
[17:39:24.021]                           quietly = TRUE)
[17:39:24.021]                         if (has_future) {
[17:39:24.021]                           ns <- base::getNamespace("future")
[17:39:24.021]                           version <- ns[[".package"]][["version"]]
[17:39:24.021]                           if (is.null(version)) 
[17:39:24.021]                             version <- utils::packageVersion("future")
[17:39:24.021]                         }
[17:39:24.021]                         else {
[17:39:24.021]                           version <- NULL
[17:39:24.021]                         }
[17:39:24.021]                         if (!has_future || version < "1.8.0") {
[17:39:24.021]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.021]                             "", base::R.version$version.string), 
[17:39:24.021]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:24.021]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.021]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.021]                               "release", "version")], collapse = " "), 
[17:39:24.021]                             hostname = base::Sys.info()[["nodename"]])
[17:39:24.021]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.021]                             info)
[17:39:24.021]                           info <- base::paste(info, collapse = "; ")
[17:39:24.021]                           if (!has_future) {
[17:39:24.021]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.021]                               info)
[17:39:24.021]                           }
[17:39:24.021]                           else {
[17:39:24.021]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.021]                               info, version)
[17:39:24.021]                           }
[17:39:24.021]                           base::stop(msg)
[17:39:24.021]                         }
[17:39:24.021]                       })
[17:39:24.021]                     }
[17:39:24.021]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:24.021]                     base::options(mc.cores = 1L)
[17:39:24.021]                   }
[17:39:24.021]                   options(future.plan = NULL)
[17:39:24.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.021]                 }
[17:39:24.021]                 ...future.workdir <- getwd()
[17:39:24.021]             }
[17:39:24.021]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.021]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.021]         }
[17:39:24.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.021]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:24.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.021]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.021]             base::names(...future.oldOptions))
[17:39:24.021]     }
[17:39:24.021]     if (FALSE) {
[17:39:24.021]     }
[17:39:24.021]     else {
[17:39:24.021]         if (TRUE) {
[17:39:24.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.021]                 open = "w")
[17:39:24.021]         }
[17:39:24.021]         else {
[17:39:24.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.021]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.021]         }
[17:39:24.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.021]             base::sink(type = "output", split = FALSE)
[17:39:24.021]             base::close(...future.stdout)
[17:39:24.021]         }, add = TRUE)
[17:39:24.021]     }
[17:39:24.021]     ...future.frame <- base::sys.nframe()
[17:39:24.021]     ...future.conditions <- base::list()
[17:39:24.021]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.021]     if (FALSE) {
[17:39:24.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.021]     }
[17:39:24.021]     ...future.result <- base::tryCatch({
[17:39:24.021]         base::withCallingHandlers({
[17:39:24.021]             ...future.value <- base::withVisible(base::local({
[17:39:24.021]                 ...future.makeSendCondition <- local({
[17:39:24.021]                   sendCondition <- NULL
[17:39:24.021]                   function(frame = 1L) {
[17:39:24.021]                     if (is.function(sendCondition)) 
[17:39:24.021]                       return(sendCondition)
[17:39:24.021]                     ns <- getNamespace("parallel")
[17:39:24.021]                     if (exists("sendData", mode = "function", 
[17:39:24.021]                       envir = ns)) {
[17:39:24.021]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:24.021]                         envir = ns)
[17:39:24.021]                       envir <- sys.frame(frame)
[17:39:24.021]                       master <- NULL
[17:39:24.021]                       while (!identical(envir, .GlobalEnv) && 
[17:39:24.021]                         !identical(envir, emptyenv())) {
[17:39:24.021]                         if (exists("master", mode = "list", envir = envir, 
[17:39:24.021]                           inherits = FALSE)) {
[17:39:24.021]                           master <- get("master", mode = "list", 
[17:39:24.021]                             envir = envir, inherits = FALSE)
[17:39:24.021]                           if (inherits(master, c("SOCKnode", 
[17:39:24.021]                             "SOCK0node"))) {
[17:39:24.021]                             sendCondition <<- function(cond) {
[17:39:24.021]                               data <- list(type = "VALUE", value = cond, 
[17:39:24.021]                                 success = TRUE)
[17:39:24.021]                               parallel_sendData(master, data)
[17:39:24.021]                             }
[17:39:24.021]                             return(sendCondition)
[17:39:24.021]                           }
[17:39:24.021]                         }
[17:39:24.021]                         frame <- frame + 1L
[17:39:24.021]                         envir <- sys.frame(frame)
[17:39:24.021]                       }
[17:39:24.021]                     }
[17:39:24.021]                     sendCondition <<- function(cond) NULL
[17:39:24.021]                   }
[17:39:24.021]                 })
[17:39:24.021]                 withCallingHandlers({
[17:39:24.021]                   {
[17:39:24.021]                     do.call(function(...) {
[17:39:24.021]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.021]                       if (!identical(...future.globals.maxSize.org, 
[17:39:24.021]                         ...future.globals.maxSize)) {
[17:39:24.021]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.021]                         on.exit(options(oopts), add = TRUE)
[17:39:24.021]                       }
[17:39:24.021]                       {
[17:39:24.021]                         lapply(seq_along(...future.elements_ii), 
[17:39:24.021]                           FUN = function(jj) {
[17:39:24.021]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.021]                             ...future.FUN(...future.X_jj, ...)
[17:39:24.021]                           })
[17:39:24.021]                       }
[17:39:24.021]                     }, args = future.call.arguments)
[17:39:24.021]                   }
[17:39:24.021]                 }, immediateCondition = function(cond) {
[17:39:24.021]                   sendCondition <- ...future.makeSendCondition()
[17:39:24.021]                   sendCondition(cond)
[17:39:24.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.021]                   {
[17:39:24.021]                     inherits <- base::inherits
[17:39:24.021]                     invokeRestart <- base::invokeRestart
[17:39:24.021]                     is.null <- base::is.null
[17:39:24.021]                     muffled <- FALSE
[17:39:24.021]                     if (inherits(cond, "message")) {
[17:39:24.021]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:24.021]                       if (muffled) 
[17:39:24.021]                         invokeRestart("muffleMessage")
[17:39:24.021]                     }
[17:39:24.021]                     else if (inherits(cond, "warning")) {
[17:39:24.021]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:24.021]                       if (muffled) 
[17:39:24.021]                         invokeRestart("muffleWarning")
[17:39:24.021]                     }
[17:39:24.021]                     else if (inherits(cond, "condition")) {
[17:39:24.021]                       if (!is.null(pattern)) {
[17:39:24.021]                         computeRestarts <- base::computeRestarts
[17:39:24.021]                         grepl <- base::grepl
[17:39:24.021]                         restarts <- computeRestarts(cond)
[17:39:24.021]                         for (restart in restarts) {
[17:39:24.021]                           name <- restart$name
[17:39:24.021]                           if (is.null(name)) 
[17:39:24.021]                             next
[17:39:24.021]                           if (!grepl(pattern, name)) 
[17:39:24.021]                             next
[17:39:24.021]                           invokeRestart(restart)
[17:39:24.021]                           muffled <- TRUE
[17:39:24.021]                           break
[17:39:24.021]                         }
[17:39:24.021]                       }
[17:39:24.021]                     }
[17:39:24.021]                     invisible(muffled)
[17:39:24.021]                   }
[17:39:24.021]                   muffleCondition(cond)
[17:39:24.021]                 })
[17:39:24.021]             }))
[17:39:24.021]             future::FutureResult(value = ...future.value$value, 
[17:39:24.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.021]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.021]                     ...future.globalenv.names))
[17:39:24.021]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.021]         }, condition = base::local({
[17:39:24.021]             c <- base::c
[17:39:24.021]             inherits <- base::inherits
[17:39:24.021]             invokeRestart <- base::invokeRestart
[17:39:24.021]             length <- base::length
[17:39:24.021]             list <- base::list
[17:39:24.021]             seq.int <- base::seq.int
[17:39:24.021]             signalCondition <- base::signalCondition
[17:39:24.021]             sys.calls <- base::sys.calls
[17:39:24.021]             `[[` <- base::`[[`
[17:39:24.021]             `+` <- base::`+`
[17:39:24.021]             `<<-` <- base::`<<-`
[17:39:24.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.021]                   3L)]
[17:39:24.021]             }
[17:39:24.021]             function(cond) {
[17:39:24.021]                 is_error <- inherits(cond, "error")
[17:39:24.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.021]                   NULL)
[17:39:24.021]                 if (is_error) {
[17:39:24.021]                   sessionInformation <- function() {
[17:39:24.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.021]                       search = base::search(), system = base::Sys.info())
[17:39:24.021]                   }
[17:39:24.021]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.021]                     cond$call), session = sessionInformation(), 
[17:39:24.021]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.021]                   signalCondition(cond)
[17:39:24.021]                 }
[17:39:24.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:24.021]                 "immediateCondition"))) {
[17:39:24.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.021]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.021]                   if (TRUE && !signal) {
[17:39:24.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.021]                     {
[17:39:24.021]                       inherits <- base::inherits
[17:39:24.021]                       invokeRestart <- base::invokeRestart
[17:39:24.021]                       is.null <- base::is.null
[17:39:24.021]                       muffled <- FALSE
[17:39:24.021]                       if (inherits(cond, "message")) {
[17:39:24.021]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.021]                         if (muffled) 
[17:39:24.021]                           invokeRestart("muffleMessage")
[17:39:24.021]                       }
[17:39:24.021]                       else if (inherits(cond, "warning")) {
[17:39:24.021]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.021]                         if (muffled) 
[17:39:24.021]                           invokeRestart("muffleWarning")
[17:39:24.021]                       }
[17:39:24.021]                       else if (inherits(cond, "condition")) {
[17:39:24.021]                         if (!is.null(pattern)) {
[17:39:24.021]                           computeRestarts <- base::computeRestarts
[17:39:24.021]                           grepl <- base::grepl
[17:39:24.021]                           restarts <- computeRestarts(cond)
[17:39:24.021]                           for (restart in restarts) {
[17:39:24.021]                             name <- restart$name
[17:39:24.021]                             if (is.null(name)) 
[17:39:24.021]                               next
[17:39:24.021]                             if (!grepl(pattern, name)) 
[17:39:24.021]                               next
[17:39:24.021]                             invokeRestart(restart)
[17:39:24.021]                             muffled <- TRUE
[17:39:24.021]                             break
[17:39:24.021]                           }
[17:39:24.021]                         }
[17:39:24.021]                       }
[17:39:24.021]                       invisible(muffled)
[17:39:24.021]                     }
[17:39:24.021]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.021]                   }
[17:39:24.021]                 }
[17:39:24.021]                 else {
[17:39:24.021]                   if (TRUE) {
[17:39:24.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.021]                     {
[17:39:24.021]                       inherits <- base::inherits
[17:39:24.021]                       invokeRestart <- base::invokeRestart
[17:39:24.021]                       is.null <- base::is.null
[17:39:24.021]                       muffled <- FALSE
[17:39:24.021]                       if (inherits(cond, "message")) {
[17:39:24.021]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.021]                         if (muffled) 
[17:39:24.021]                           invokeRestart("muffleMessage")
[17:39:24.021]                       }
[17:39:24.021]                       else if (inherits(cond, "warning")) {
[17:39:24.021]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.021]                         if (muffled) 
[17:39:24.021]                           invokeRestart("muffleWarning")
[17:39:24.021]                       }
[17:39:24.021]                       else if (inherits(cond, "condition")) {
[17:39:24.021]                         if (!is.null(pattern)) {
[17:39:24.021]                           computeRestarts <- base::computeRestarts
[17:39:24.021]                           grepl <- base::grepl
[17:39:24.021]                           restarts <- computeRestarts(cond)
[17:39:24.021]                           for (restart in restarts) {
[17:39:24.021]                             name <- restart$name
[17:39:24.021]                             if (is.null(name)) 
[17:39:24.021]                               next
[17:39:24.021]                             if (!grepl(pattern, name)) 
[17:39:24.021]                               next
[17:39:24.021]                             invokeRestart(restart)
[17:39:24.021]                             muffled <- TRUE
[17:39:24.021]                             break
[17:39:24.021]                           }
[17:39:24.021]                         }
[17:39:24.021]                       }
[17:39:24.021]                       invisible(muffled)
[17:39:24.021]                     }
[17:39:24.021]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.021]                   }
[17:39:24.021]                 }
[17:39:24.021]             }
[17:39:24.021]         }))
[17:39:24.021]     }, error = function(ex) {
[17:39:24.021]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.021]                 ...future.rng), started = ...future.startTime, 
[17:39:24.021]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.021]             version = "1.8"), class = "FutureResult")
[17:39:24.021]     }, finally = {
[17:39:24.021]         if (!identical(...future.workdir, getwd())) 
[17:39:24.021]             setwd(...future.workdir)
[17:39:24.021]         {
[17:39:24.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.021]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.021]             }
[17:39:24.021]             base::options(...future.oldOptions)
[17:39:24.021]             if (.Platform$OS.type == "windows") {
[17:39:24.021]                 old_names <- names(...future.oldEnvVars)
[17:39:24.021]                 envs <- base::Sys.getenv()
[17:39:24.021]                 names <- names(envs)
[17:39:24.021]                 common <- intersect(names, old_names)
[17:39:24.021]                 added <- setdiff(names, old_names)
[17:39:24.021]                 removed <- setdiff(old_names, names)
[17:39:24.021]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.021]                   envs[common]]
[17:39:24.021]                 NAMES <- toupper(changed)
[17:39:24.021]                 args <- list()
[17:39:24.021]                 for (kk in seq_along(NAMES)) {
[17:39:24.021]                   name <- changed[[kk]]
[17:39:24.021]                   NAME <- NAMES[[kk]]
[17:39:24.021]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.021]                     next
[17:39:24.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.021]                 }
[17:39:24.021]                 NAMES <- toupper(added)
[17:39:24.021]                 for (kk in seq_along(NAMES)) {
[17:39:24.021]                   name <- added[[kk]]
[17:39:24.021]                   NAME <- NAMES[[kk]]
[17:39:24.021]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.021]                     next
[17:39:24.021]                   args[[name]] <- ""
[17:39:24.021]                 }
[17:39:24.021]                 NAMES <- toupper(removed)
[17:39:24.021]                 for (kk in seq_along(NAMES)) {
[17:39:24.021]                   name <- removed[[kk]]
[17:39:24.021]                   NAME <- NAMES[[kk]]
[17:39:24.021]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.021]                     next
[17:39:24.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.021]                 }
[17:39:24.021]                 if (length(args) > 0) 
[17:39:24.021]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.021]             }
[17:39:24.021]             else {
[17:39:24.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.021]             }
[17:39:24.021]             {
[17:39:24.021]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.021]                   0L) {
[17:39:24.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.021]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.021]                   base::options(opts)
[17:39:24.021]                 }
[17:39:24.021]                 {
[17:39:24.021]                   {
[17:39:24.021]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:24.021]                     NULL
[17:39:24.021]                   }
[17:39:24.021]                   options(future.plan = NULL)
[17:39:24.021]                   if (is.na(NA_character_)) 
[17:39:24.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.021]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:24.021]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:24.021]                     envir = parent.frame()) 
[17:39:24.021]                   {
[17:39:24.021]                     if (is.function(workers)) 
[17:39:24.021]                       workers <- workers()
[17:39:24.021]                     workers <- structure(as.integer(workers), 
[17:39:24.021]                       class = class(workers))
[17:39:24.021]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:24.021]                       workers >= 1)
[17:39:24.021]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:24.021]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:24.021]                     }
[17:39:24.021]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:24.021]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:24.021]                       envir = envir)
[17:39:24.021]                     if (!future$lazy) 
[17:39:24.021]                       future <- run(future)
[17:39:24.021]                     invisible(future)
[17:39:24.021]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.021]                 }
[17:39:24.021]             }
[17:39:24.021]         }
[17:39:24.021]     })
[17:39:24.021]     if (TRUE) {
[17:39:24.021]         base::sink(type = "output", split = FALSE)
[17:39:24.021]         if (TRUE) {
[17:39:24.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.021]         }
[17:39:24.021]         else {
[17:39:24.021]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.021]         }
[17:39:24.021]         base::close(...future.stdout)
[17:39:24.021]         ...future.stdout <- NULL
[17:39:24.021]     }
[17:39:24.021]     ...future.result$conditions <- ...future.conditions
[17:39:24.021]     ...future.result$finished <- base::Sys.time()
[17:39:24.021]     ...future.result
[17:39:24.021] }
[17:39:24.024] Exporting 5 global objects (9.71 KiB) to cluster node #2 ...
[17:39:24.025] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:24.025] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:24.025] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[17:39:24.025] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[17:39:24.026] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:39:24.026] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:39:24.026] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:39:24.026] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:39:24.026] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:24.027] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:24.027] Exporting 5 global objects (9.71 KiB) to cluster node #2 ... DONE
[17:39:24.027] MultisessionFuture started
[17:39:24.027] - Launch lazy future ... done
[17:39:24.028] run() for ‘MultisessionFuture’ ... done
[17:39:24.028] Created future:
[17:39:24.028] MultisessionFuture:
[17:39:24.028] Label: ‘future_apply-2’
[17:39:24.028] Expression:
[17:39:24.028] {
[17:39:24.028]     do.call(function(...) {
[17:39:24.028]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.028]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.028]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.028]             on.exit(options(oopts), add = TRUE)
[17:39:24.028]         }
[17:39:24.028]         {
[17:39:24.028]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.028]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.028]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.028]             })
[17:39:24.028]         }
[17:39:24.028]     }, args = future.call.arguments)
[17:39:24.028] }
[17:39:24.028] Lazy evaluation: FALSE
[17:39:24.028] Asynchronous evaluation: TRUE
[17:39:24.028] Local evaluation: TRUE
[17:39:24.028] Environment: R_GlobalEnv
[17:39:24.028] Capture standard output: TRUE
[17:39:24.028] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:39:24.028] Globals: 5 objects totaling 9.71 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:24.028] Packages: <none>
[17:39:24.028] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:39:24.028] Resolved: FALSE
[17:39:24.028] Value: <not collected>
[17:39:24.028] Conditions captured: <none>
[17:39:24.028] Early signaling: FALSE
[17:39:24.028] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:24.028] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:24.039] Chunk #2 of 2 ... DONE
[17:39:24.039] Launching 2 futures (chunks) ... DONE
[17:39:24.040] Resolving 2 futures (chunks) ...
[17:39:24.040] resolve() on list ...
[17:39:24.040]  recursive: 0
[17:39:24.040]  length: 2
[17:39:24.040] 
[17:39:24.041] receiveMessageFromWorker() for ClusterFuture ...
[17:39:24.041] - Validating connection of MultisessionFuture
[17:39:24.041] - received message: FutureResult
[17:39:24.041] - Received FutureResult
[17:39:24.041] - Erased future from FutureRegistry
[17:39:24.041] result() for ClusterFuture ...
[17:39:24.041] - result already collected: FutureResult
[17:39:24.041] result() for ClusterFuture ... done
[17:39:24.041] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:24.042] Future #1
[17:39:24.042] result() for ClusterFuture ...
[17:39:24.042] - result already collected: FutureResult
[17:39:24.042] result() for ClusterFuture ... done
[17:39:24.042] result() for ClusterFuture ...
[17:39:24.042] - result already collected: FutureResult
[17:39:24.042] result() for ClusterFuture ... done
[17:39:24.042] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:24.042] - nx: 2
[17:39:24.042] - relay: TRUE
[17:39:24.042] - stdout: TRUE
[17:39:24.043] - signal: TRUE
[17:39:24.043] - resignal: FALSE
[17:39:24.043] - force: TRUE
[17:39:24.043] - relayed: [n=2] FALSE, FALSE
[17:39:24.043] - queued futures: [n=2] FALSE, FALSE
[17:39:24.043]  - until=1
[17:39:24.043]  - relaying element #1
[17:39:24.043] result() for ClusterFuture ...
[17:39:24.043] - result already collected: FutureResult
[17:39:24.043] result() for ClusterFuture ... done
[17:39:24.043] result() for ClusterFuture ...
[17:39:24.044] - result already collected: FutureResult
[17:39:24.044] result() for ClusterFuture ... done
[17:39:24.044] result() for ClusterFuture ...
[17:39:24.044] - result already collected: FutureResult
[17:39:24.044] result() for ClusterFuture ... done
[17:39:24.044] result() for ClusterFuture ...
[17:39:24.044] - result already collected: FutureResult
[17:39:24.044] result() for ClusterFuture ... done
[17:39:24.044] - relayed: [n=2] TRUE, FALSE
[17:39:24.044] - queued futures: [n=2] TRUE, FALSE
[17:39:24.045] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:24.045]  length: 1 (resolved future 1)
[17:39:24.087] receiveMessageFromWorker() for ClusterFuture ...
[17:39:24.087] - Validating connection of MultisessionFuture
[17:39:24.087] - received message: FutureResult
[17:39:24.087] - Received FutureResult
[17:39:24.087] - Erased future from FutureRegistry
[17:39:24.087] result() for ClusterFuture ...
[17:39:24.088] - result already collected: FutureResult
[17:39:24.088] result() for ClusterFuture ... done
[17:39:24.088] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:24.088] Future #2
[17:39:24.088] result() for ClusterFuture ...
[17:39:24.088] - result already collected: FutureResult
[17:39:24.088] result() for ClusterFuture ... done
[17:39:24.088] result() for ClusterFuture ...
[17:39:24.088] - result already collected: FutureResult
[17:39:24.088] result() for ClusterFuture ... done
[17:39:24.088] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:24.089] - nx: 2
[17:39:24.089] - relay: TRUE
[17:39:24.089] - stdout: TRUE
[17:39:24.089] - signal: TRUE
[17:39:24.089] - resignal: FALSE
[17:39:24.089] - force: TRUE
[17:39:24.089] - relayed: [n=2] TRUE, FALSE
[17:39:24.089] - queued futures: [n=2] TRUE, FALSE
[17:39:24.089]  - until=2
[17:39:24.089]  - relaying element #2
[17:39:24.089] result() for ClusterFuture ...
[17:39:24.090] - result already collected: FutureResult
[17:39:24.090] result() for ClusterFuture ... done
[17:39:24.090] result() for ClusterFuture ...
[17:39:24.090] - result already collected: FutureResult
[17:39:24.090] result() for ClusterFuture ... done
[17:39:24.090] result() for ClusterFuture ...
[17:39:24.090] - result already collected: FutureResult
[17:39:24.090] result() for ClusterFuture ... done
[17:39:24.090] result() for ClusterFuture ...
[17:39:24.090] - result already collected: FutureResult
[17:39:24.090] result() for ClusterFuture ... done
[17:39:24.091] - relayed: [n=2] TRUE, TRUE
[17:39:24.091] - queued futures: [n=2] TRUE, TRUE
[17:39:24.091] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:24.091]  length: 0 (resolved future 2)
[17:39:24.091] Relaying remaining futures
[17:39:24.091] signalConditionsASAP(NULL, pos=0) ...
[17:39:24.091] - nx: 2
[17:39:24.091] - relay: TRUE
[17:39:24.091] - stdout: TRUE
[17:39:24.091] - signal: TRUE
[17:39:24.091] - resignal: FALSE
[17:39:24.092] - force: TRUE
[17:39:24.092] - relayed: [n=2] TRUE, TRUE
[17:39:24.092] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:24.092] - relayed: [n=2] TRUE, TRUE
[17:39:24.092] - queued futures: [n=2] TRUE, TRUE
[17:39:24.092] signalConditionsASAP(NULL, pos=0) ... done
[17:39:24.092] resolve() on list ... DONE
[17:39:24.092] result() for ClusterFuture ...
[17:39:24.092] - result already collected: FutureResult
[17:39:24.092] result() for ClusterFuture ... done
[17:39:24.093] result() for ClusterFuture ...
[17:39:24.093] - result already collected: FutureResult
[17:39:24.093] result() for ClusterFuture ... done
[17:39:24.093] result() for ClusterFuture ...
[17:39:24.093] - result already collected: FutureResult
[17:39:24.093] result() for ClusterFuture ... done
[17:39:24.093] result() for ClusterFuture ...
[17:39:24.093] - result already collected: FutureResult
[17:39:24.093] result() for ClusterFuture ... done
[17:39:24.093]  - Number of value chunks collected: 2
[17:39:24.093] Resolving 2 futures (chunks) ... DONE
[17:39:24.094] Reducing values from 2 chunks ...
[17:39:24.094]  - Number of values collected after concatenation: 2
[17:39:24.094]  - Number of values expected: 2
[17:39:24.094] Reducing values from 2 chunks ... DONE
[17:39:24.094] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:39:24.094] getGlobalsAndPackagesXApply() ...
[17:39:24.094]  - future.globals: TRUE
[17:39:24.094] getGlobalsAndPackages() ...
[17:39:24.094] Searching for globals...
[17:39:24.097] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:39:24.098] Searching for globals ... DONE
[17:39:24.098] Resolving globals: FALSE
[17:39:24.098] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:39:24.099] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:39:24.099] - globals: [1] ‘FUN’
[17:39:24.099] 
[17:39:24.099] getGlobalsAndPackages() ... DONE
[17:39:24.099]  - globals found/used: [n=1] ‘FUN’
[17:39:24.099]  - needed namespaces: [n=0] 
[17:39:24.099] Finding globals ... DONE
[17:39:24.099]  - use_args: TRUE
[17:39:24.099]  - Getting '...' globals ...
[17:39:24.100] resolve() on list ...
[17:39:24.100]  recursive: 0
[17:39:24.100]  length: 1
[17:39:24.100]  elements: ‘...’
[17:39:24.100]  length: 0 (resolved future 1)
[17:39:24.100] resolve() on list ... DONE
[17:39:24.100]    - '...' content: [n=0] 
[17:39:24.100] List of 1
[17:39:24.100]  $ ...: list()
[17:39:24.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.100]  - attr(*, "where")=List of 1
[17:39:24.100]   ..$ ...:<environment: 0x55c794b1cfd0> 
[17:39:24.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.100]  - attr(*, "resolved")= logi TRUE
[17:39:24.100]  - attr(*, "total_size")= num NA
[17:39:24.103]  - Getting '...' globals ... DONE
[17:39:24.103] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:39:24.103] List of 2
[17:39:24.103]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:39:24.103]  $ ...          : list()
[17:39:24.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.103]  - attr(*, "where")=List of 2
[17:39:24.103]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:39:24.103]   ..$ ...          :<environment: 0x55c794b1cfd0> 
[17:39:24.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.103]  - attr(*, "resolved")= logi FALSE
[17:39:24.103]  - attr(*, "total_size")= num 36296
[17:39:24.106] Packages to be attached in all futures: [n=0] 
[17:39:24.106] getGlobalsAndPackagesXApply() ... DONE
[17:39:24.110] future_lapply() ...
[17:39:24.112] Generating random seeds ...
[17:39:24.112] Generating random seed streams for 2 elements ...
[17:39:24.112] Generating random seed streams for 2 elements ... DONE
[17:39:24.112] Generating random seeds ... DONE
[17:39:24.112] Will set RNG state on exit: 10407, 1652188737, 1839734545, -249456322, -559973058, 1987318831, 1876506397
[17:39:24.115] Number of chunks: 2
[17:39:24.116] getGlobalsAndPackagesXApply() ...
[17:39:24.116]  - future.globals: <name-value list> with names ‘list()’
[17:39:24.116]  - use_args: TRUE
[17:39:24.116] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:39:24.116] List of 2
[17:39:24.116]  $ ...          : list()
[17:39:24.116]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:39:24.116]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:39:24.116]  - attr(*, "where")=List of 2
[17:39:24.116]   ..$ ...          :<environment: 0x55c794b1cfd0> 
[17:39:24.116]   ..$ ...future.FUN:<environment: namespace:base> 
[17:39:24.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:39:24.116]  - attr(*, "resolved")= logi FALSE
[17:39:24.116]  - attr(*, "total_size")= num NA
[17:39:24.119] Packages to be attached in all futures: [n=0] 
[17:39:24.120] getGlobalsAndPackagesXApply() ... DONE
[17:39:24.120] Number of futures (= number of chunks): 2
[17:39:24.120] Launching 2 futures (chunks) ...
[17:39:24.120] Chunk #1 of 2 ...
[17:39:24.120]  - seeds: [1] <seeds>
[17:39:24.120] getGlobalsAndPackages() ...
[17:39:24.120] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.120] Resolving globals: FALSE
[17:39:24.120] Tweak future expression to call with '...' arguments ...
[17:39:24.121] {
[17:39:24.121]     do.call(function(...) {
[17:39:24.121]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.121]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.121]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.121]             on.exit(options(oopts), add = TRUE)
[17:39:24.121]         }
[17:39:24.121]         {
[17:39:24.121]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.121]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.121]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:24.121]                   envir = globalenv(), inherits = FALSE)
[17:39:24.121]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.121]             })
[17:39:24.121]         }
[17:39:24.121]     }, args = future.call.arguments)
[17:39:24.121] }
[17:39:24.121] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.121] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.121] 
[17:39:24.121] getGlobalsAndPackages() ... DONE
[17:39:24.122] run() for ‘Future’ ...
[17:39:24.122] - state: ‘created’
[17:39:24.122] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:24.136] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:24.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:24.137]   - Field: ‘node’
[17:39:24.137]   - Field: ‘label’
[17:39:24.137]   - Field: ‘local’
[17:39:24.137]   - Field: ‘owner’
[17:39:24.137]   - Field: ‘envir’
[17:39:24.137]   - Field: ‘workers’
[17:39:24.137]   - Field: ‘packages’
[17:39:24.137]   - Field: ‘gc’
[17:39:24.137]   - Field: ‘conditions’
[17:39:24.138]   - Field: ‘persistent’
[17:39:24.138]   - Field: ‘expr’
[17:39:24.138]   - Field: ‘uuid’
[17:39:24.138]   - Field: ‘seed’
[17:39:24.138]   - Field: ‘version’
[17:39:24.138]   - Field: ‘result’
[17:39:24.138]   - Field: ‘asynchronous’
[17:39:24.138]   - Field: ‘calls’
[17:39:24.138]   - Field: ‘globals’
[17:39:24.138]   - Field: ‘stdout’
[17:39:24.138]   - Field: ‘earlySignal’
[17:39:24.139]   - Field: ‘lazy’
[17:39:24.139]   - Field: ‘state’
[17:39:24.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:24.139] - Launch lazy future ...
[17:39:24.139] Packages needed by the future expression (n = 0): <none>
[17:39:24.139] Packages needed by future strategies (n = 0): <none>
[17:39:24.140] {
[17:39:24.140]     {
[17:39:24.140]         {
[17:39:24.140]             ...future.startTime <- base::Sys.time()
[17:39:24.140]             {
[17:39:24.140]                 {
[17:39:24.140]                   {
[17:39:24.140]                     {
[17:39:24.140]                       base::local({
[17:39:24.140]                         has_future <- base::requireNamespace("future", 
[17:39:24.140]                           quietly = TRUE)
[17:39:24.140]                         if (has_future) {
[17:39:24.140]                           ns <- base::getNamespace("future")
[17:39:24.140]                           version <- ns[[".package"]][["version"]]
[17:39:24.140]                           if (is.null(version)) 
[17:39:24.140]                             version <- utils::packageVersion("future")
[17:39:24.140]                         }
[17:39:24.140]                         else {
[17:39:24.140]                           version <- NULL
[17:39:24.140]                         }
[17:39:24.140]                         if (!has_future || version < "1.8.0") {
[17:39:24.140]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.140]                             "", base::R.version$version.string), 
[17:39:24.140]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:24.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.140]                               "release", "version")], collapse = " "), 
[17:39:24.140]                             hostname = base::Sys.info()[["nodename"]])
[17:39:24.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.140]                             info)
[17:39:24.140]                           info <- base::paste(info, collapse = "; ")
[17:39:24.140]                           if (!has_future) {
[17:39:24.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.140]                               info)
[17:39:24.140]                           }
[17:39:24.140]                           else {
[17:39:24.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.140]                               info, version)
[17:39:24.140]                           }
[17:39:24.140]                           base::stop(msg)
[17:39:24.140]                         }
[17:39:24.140]                       })
[17:39:24.140]                     }
[17:39:24.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:24.140]                     base::options(mc.cores = 1L)
[17:39:24.140]                   }
[17:39:24.140]                   options(future.plan = NULL)
[17:39:24.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.140]                 }
[17:39:24.140]                 ...future.workdir <- getwd()
[17:39:24.140]             }
[17:39:24.140]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.140]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.140]         }
[17:39:24.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.140]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:24.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.140]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.140]             base::names(...future.oldOptions))
[17:39:24.140]     }
[17:39:24.140]     if (FALSE) {
[17:39:24.140]     }
[17:39:24.140]     else {
[17:39:24.140]         if (TRUE) {
[17:39:24.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.140]                 open = "w")
[17:39:24.140]         }
[17:39:24.140]         else {
[17:39:24.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.140]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.140]         }
[17:39:24.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.140]             base::sink(type = "output", split = FALSE)
[17:39:24.140]             base::close(...future.stdout)
[17:39:24.140]         }, add = TRUE)
[17:39:24.140]     }
[17:39:24.140]     ...future.frame <- base::sys.nframe()
[17:39:24.140]     ...future.conditions <- base::list()
[17:39:24.140]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.140]     if (FALSE) {
[17:39:24.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.140]     }
[17:39:24.140]     ...future.result <- base::tryCatch({
[17:39:24.140]         base::withCallingHandlers({
[17:39:24.140]             ...future.value <- base::withVisible(base::local({
[17:39:24.140]                 ...future.makeSendCondition <- local({
[17:39:24.140]                   sendCondition <- NULL
[17:39:24.140]                   function(frame = 1L) {
[17:39:24.140]                     if (is.function(sendCondition)) 
[17:39:24.140]                       return(sendCondition)
[17:39:24.140]                     ns <- getNamespace("parallel")
[17:39:24.140]                     if (exists("sendData", mode = "function", 
[17:39:24.140]                       envir = ns)) {
[17:39:24.140]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:24.140]                         envir = ns)
[17:39:24.140]                       envir <- sys.frame(frame)
[17:39:24.140]                       master <- NULL
[17:39:24.140]                       while (!identical(envir, .GlobalEnv) && 
[17:39:24.140]                         !identical(envir, emptyenv())) {
[17:39:24.140]                         if (exists("master", mode = "list", envir = envir, 
[17:39:24.140]                           inherits = FALSE)) {
[17:39:24.140]                           master <- get("master", mode = "list", 
[17:39:24.140]                             envir = envir, inherits = FALSE)
[17:39:24.140]                           if (inherits(master, c("SOCKnode", 
[17:39:24.140]                             "SOCK0node"))) {
[17:39:24.140]                             sendCondition <<- function(cond) {
[17:39:24.140]                               data <- list(type = "VALUE", value = cond, 
[17:39:24.140]                                 success = TRUE)
[17:39:24.140]                               parallel_sendData(master, data)
[17:39:24.140]                             }
[17:39:24.140]                             return(sendCondition)
[17:39:24.140]                           }
[17:39:24.140]                         }
[17:39:24.140]                         frame <- frame + 1L
[17:39:24.140]                         envir <- sys.frame(frame)
[17:39:24.140]                       }
[17:39:24.140]                     }
[17:39:24.140]                     sendCondition <<- function(cond) NULL
[17:39:24.140]                   }
[17:39:24.140]                 })
[17:39:24.140]                 withCallingHandlers({
[17:39:24.140]                   {
[17:39:24.140]                     do.call(function(...) {
[17:39:24.140]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.140]                       if (!identical(...future.globals.maxSize.org, 
[17:39:24.140]                         ...future.globals.maxSize)) {
[17:39:24.140]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.140]                         on.exit(options(oopts), add = TRUE)
[17:39:24.140]                       }
[17:39:24.140]                       {
[17:39:24.140]                         lapply(seq_along(...future.elements_ii), 
[17:39:24.140]                           FUN = function(jj) {
[17:39:24.140]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.140]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:24.140]                               envir = globalenv(), inherits = FALSE)
[17:39:24.140]                             ...future.FUN(...future.X_jj, ...)
[17:39:24.140]                           })
[17:39:24.140]                       }
[17:39:24.140]                     }, args = future.call.arguments)
[17:39:24.140]                   }
[17:39:24.140]                 }, immediateCondition = function(cond) {
[17:39:24.140]                   sendCondition <- ...future.makeSendCondition()
[17:39:24.140]                   sendCondition(cond)
[17:39:24.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.140]                   {
[17:39:24.140]                     inherits <- base::inherits
[17:39:24.140]                     invokeRestart <- base::invokeRestart
[17:39:24.140]                     is.null <- base::is.null
[17:39:24.140]                     muffled <- FALSE
[17:39:24.140]                     if (inherits(cond, "message")) {
[17:39:24.140]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:24.140]                       if (muffled) 
[17:39:24.140]                         invokeRestart("muffleMessage")
[17:39:24.140]                     }
[17:39:24.140]                     else if (inherits(cond, "warning")) {
[17:39:24.140]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:24.140]                       if (muffled) 
[17:39:24.140]                         invokeRestart("muffleWarning")
[17:39:24.140]                     }
[17:39:24.140]                     else if (inherits(cond, "condition")) {
[17:39:24.140]                       if (!is.null(pattern)) {
[17:39:24.140]                         computeRestarts <- base::computeRestarts
[17:39:24.140]                         grepl <- base::grepl
[17:39:24.140]                         restarts <- computeRestarts(cond)
[17:39:24.140]                         for (restart in restarts) {
[17:39:24.140]                           name <- restart$name
[17:39:24.140]                           if (is.null(name)) 
[17:39:24.140]                             next
[17:39:24.140]                           if (!grepl(pattern, name)) 
[17:39:24.140]                             next
[17:39:24.140]                           invokeRestart(restart)
[17:39:24.140]                           muffled <- TRUE
[17:39:24.140]                           break
[17:39:24.140]                         }
[17:39:24.140]                       }
[17:39:24.140]                     }
[17:39:24.140]                     invisible(muffled)
[17:39:24.140]                   }
[17:39:24.140]                   muffleCondition(cond)
[17:39:24.140]                 })
[17:39:24.140]             }))
[17:39:24.140]             future::FutureResult(value = ...future.value$value, 
[17:39:24.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.140]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.140]                     ...future.globalenv.names))
[17:39:24.140]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.140]         }, condition = base::local({
[17:39:24.140]             c <- base::c
[17:39:24.140]             inherits <- base::inherits
[17:39:24.140]             invokeRestart <- base::invokeRestart
[17:39:24.140]             length <- base::length
[17:39:24.140]             list <- base::list
[17:39:24.140]             seq.int <- base::seq.int
[17:39:24.140]             signalCondition <- base::signalCondition
[17:39:24.140]             sys.calls <- base::sys.calls
[17:39:24.140]             `[[` <- base::`[[`
[17:39:24.140]             `+` <- base::`+`
[17:39:24.140]             `<<-` <- base::`<<-`
[17:39:24.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.140]                   3L)]
[17:39:24.140]             }
[17:39:24.140]             function(cond) {
[17:39:24.140]                 is_error <- inherits(cond, "error")
[17:39:24.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.140]                   NULL)
[17:39:24.140]                 if (is_error) {
[17:39:24.140]                   sessionInformation <- function() {
[17:39:24.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.140]                       search = base::search(), system = base::Sys.info())
[17:39:24.140]                   }
[17:39:24.140]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.140]                     cond$call), session = sessionInformation(), 
[17:39:24.140]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.140]                   signalCondition(cond)
[17:39:24.140]                 }
[17:39:24.140]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:39:24.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.140]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.140]                   if (TRUE && !signal) {
[17:39:24.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.140]                     {
[17:39:24.140]                       inherits <- base::inherits
[17:39:24.140]                       invokeRestart <- base::invokeRestart
[17:39:24.140]                       is.null <- base::is.null
[17:39:24.140]                       muffled <- FALSE
[17:39:24.140]                       if (inherits(cond, "message")) {
[17:39:24.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.140]                         if (muffled) 
[17:39:24.140]                           invokeRestart("muffleMessage")
[17:39:24.140]                       }
[17:39:24.140]                       else if (inherits(cond, "warning")) {
[17:39:24.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.140]                         if (muffled) 
[17:39:24.140]                           invokeRestart("muffleWarning")
[17:39:24.140]                       }
[17:39:24.140]                       else if (inherits(cond, "condition")) {
[17:39:24.140]                         if (!is.null(pattern)) {
[17:39:24.140]                           computeRestarts <- base::computeRestarts
[17:39:24.140]                           grepl <- base::grepl
[17:39:24.140]                           restarts <- computeRestarts(cond)
[17:39:24.140]                           for (restart in restarts) {
[17:39:24.140]                             name <- restart$name
[17:39:24.140]                             if (is.null(name)) 
[17:39:24.140]                               next
[17:39:24.140]                             if (!grepl(pattern, name)) 
[17:39:24.140]                               next
[17:39:24.140]                             invokeRestart(restart)
[17:39:24.140]                             muffled <- TRUE
[17:39:24.140]                             break
[17:39:24.140]                           }
[17:39:24.140]                         }
[17:39:24.140]                       }
[17:39:24.140]                       invisible(muffled)
[17:39:24.140]                     }
[17:39:24.140]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.140]                   }
[17:39:24.140]                 }
[17:39:24.140]                 else {
[17:39:24.140]                   if (TRUE) {
[17:39:24.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.140]                     {
[17:39:24.140]                       inherits <- base::inherits
[17:39:24.140]                       invokeRestart <- base::invokeRestart
[17:39:24.140]                       is.null <- base::is.null
[17:39:24.140]                       muffled <- FALSE
[17:39:24.140]                       if (inherits(cond, "message")) {
[17:39:24.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.140]                         if (muffled) 
[17:39:24.140]                           invokeRestart("muffleMessage")
[17:39:24.140]                       }
[17:39:24.140]                       else if (inherits(cond, "warning")) {
[17:39:24.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.140]                         if (muffled) 
[17:39:24.140]                           invokeRestart("muffleWarning")
[17:39:24.140]                       }
[17:39:24.140]                       else if (inherits(cond, "condition")) {
[17:39:24.140]                         if (!is.null(pattern)) {
[17:39:24.140]                           computeRestarts <- base::computeRestarts
[17:39:24.140]                           grepl <- base::grepl
[17:39:24.140]                           restarts <- computeRestarts(cond)
[17:39:24.140]                           for (restart in restarts) {
[17:39:24.140]                             name <- restart$name
[17:39:24.140]                             if (is.null(name)) 
[17:39:24.140]                               next
[17:39:24.140]                             if (!grepl(pattern, name)) 
[17:39:24.140]                               next
[17:39:24.140]                             invokeRestart(restart)
[17:39:24.140]                             muffled <- TRUE
[17:39:24.140]                             break
[17:39:24.140]                           }
[17:39:24.140]                         }
[17:39:24.140]                       }
[17:39:24.140]                       invisible(muffled)
[17:39:24.140]                     }
[17:39:24.140]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.140]                   }
[17:39:24.140]                 }
[17:39:24.140]             }
[17:39:24.140]         }))
[17:39:24.140]     }, error = function(ex) {
[17:39:24.140]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.140]                 ...future.rng), started = ...future.startTime, 
[17:39:24.140]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.140]             version = "1.8"), class = "FutureResult")
[17:39:24.140]     }, finally = {
[17:39:24.140]         if (!identical(...future.workdir, getwd())) 
[17:39:24.140]             setwd(...future.workdir)
[17:39:24.140]         {
[17:39:24.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.140]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.140]             }
[17:39:24.140]             base::options(...future.oldOptions)
[17:39:24.140]             if (.Platform$OS.type == "windows") {
[17:39:24.140]                 old_names <- names(...future.oldEnvVars)
[17:39:24.140]                 envs <- base::Sys.getenv()
[17:39:24.140]                 names <- names(envs)
[17:39:24.140]                 common <- intersect(names, old_names)
[17:39:24.140]                 added <- setdiff(names, old_names)
[17:39:24.140]                 removed <- setdiff(old_names, names)
[17:39:24.140]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.140]                   envs[common]]
[17:39:24.140]                 NAMES <- toupper(changed)
[17:39:24.140]                 args <- list()
[17:39:24.140]                 for (kk in seq_along(NAMES)) {
[17:39:24.140]                   name <- changed[[kk]]
[17:39:24.140]                   NAME <- NAMES[[kk]]
[17:39:24.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.140]                     next
[17:39:24.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.140]                 }
[17:39:24.140]                 NAMES <- toupper(added)
[17:39:24.140]                 for (kk in seq_along(NAMES)) {
[17:39:24.140]                   name <- added[[kk]]
[17:39:24.140]                   NAME <- NAMES[[kk]]
[17:39:24.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.140]                     next
[17:39:24.140]                   args[[name]] <- ""
[17:39:24.140]                 }
[17:39:24.140]                 NAMES <- toupper(removed)
[17:39:24.140]                 for (kk in seq_along(NAMES)) {
[17:39:24.140]                   name <- removed[[kk]]
[17:39:24.140]                   NAME <- NAMES[[kk]]
[17:39:24.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.140]                     next
[17:39:24.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.140]                 }
[17:39:24.140]                 if (length(args) > 0) 
[17:39:24.140]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.140]             }
[17:39:24.140]             else {
[17:39:24.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.140]             }
[17:39:24.140]             {
[17:39:24.140]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.140]                   0L) {
[17:39:24.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.140]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.140]                   base::options(opts)
[17:39:24.140]                 }
[17:39:24.140]                 {
[17:39:24.140]                   {
[17:39:24.140]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:24.140]                     NULL
[17:39:24.140]                   }
[17:39:24.140]                   options(future.plan = NULL)
[17:39:24.140]                   if (is.na(NA_character_)) 
[17:39:24.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.140]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:24.140]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:24.140]                     envir = parent.frame()) 
[17:39:24.140]                   {
[17:39:24.140]                     if (is.function(workers)) 
[17:39:24.140]                       workers <- workers()
[17:39:24.140]                     workers <- structure(as.integer(workers), 
[17:39:24.140]                       class = class(workers))
[17:39:24.140]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:24.140]                       workers >= 1)
[17:39:24.140]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:24.140]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:24.140]                     }
[17:39:24.140]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:24.140]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:24.140]                       envir = envir)
[17:39:24.140]                     if (!future$lazy) 
[17:39:24.140]                       future <- run(future)
[17:39:24.140]                     invisible(future)
[17:39:24.140]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.140]                 }
[17:39:24.140]             }
[17:39:24.140]         }
[17:39:24.140]     })
[17:39:24.140]     if (TRUE) {
[17:39:24.140]         base::sink(type = "output", split = FALSE)
[17:39:24.140]         if (TRUE) {
[17:39:24.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.140]         }
[17:39:24.140]         else {
[17:39:24.140]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.140]         }
[17:39:24.140]         base::close(...future.stdout)
[17:39:24.140]         ...future.stdout <- NULL
[17:39:24.140]     }
[17:39:24.140]     ...future.result$conditions <- ...future.conditions
[17:39:24.140]     ...future.result$finished <- base::Sys.time()
[17:39:24.140]     ...future.result
[17:39:24.140] }
[17:39:24.143] Exporting 5 global objects (35.58 KiB) to cluster node #1 ...
[17:39:24.143] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:39:24.144] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:39:24.144] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[17:39:24.187] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[17:39:24.187] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:39:24.188] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:39:24.188] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[17:39:24.188] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[17:39:24.188] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:39:24.189] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:39:24.189] Exporting 5 global objects (35.58 KiB) to cluster node #1 ... DONE
[17:39:24.189] MultisessionFuture started
[17:39:24.189] - Launch lazy future ... done
[17:39:24.189] run() for ‘MultisessionFuture’ ... done
[17:39:24.190] Created future:
[17:39:24.190] MultisessionFuture:
[17:39:24.190] Label: ‘future_apply-1’
[17:39:24.190] Expression:
[17:39:24.190] {
[17:39:24.190]     do.call(function(...) {
[17:39:24.190]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.190]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.190]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.190]             on.exit(options(oopts), add = TRUE)
[17:39:24.190]         }
[17:39:24.190]         {
[17:39:24.190]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.190]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.190]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:24.190]                   envir = globalenv(), inherits = FALSE)
[17:39:24.190]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.190]             })
[17:39:24.190]         }
[17:39:24.190]     }, args = future.call.arguments)
[17:39:24.190] }
[17:39:24.190] Lazy evaluation: FALSE
[17:39:24.190] Asynchronous evaluation: TRUE
[17:39:24.190] Local evaluation: TRUE
[17:39:24.190] Environment: R_GlobalEnv
[17:39:24.190] Capture standard output: TRUE
[17:39:24.190] Capture condition classes: <none>
[17:39:24.190] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:24.190] Packages: <none>
[17:39:24.190] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:39:24.190] Resolved: FALSE
[17:39:24.190] Value: <not collected>
[17:39:24.190] Conditions captured: <none>
[17:39:24.190] Early signaling: FALSE
[17:39:24.190] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:24.190] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:24.202] Chunk #1 of 2 ... DONE
[17:39:24.202] Chunk #2 of 2 ...
[17:39:24.202]  - seeds: [1] <seeds>
[17:39:24.202] getGlobalsAndPackages() ...
[17:39:24.202] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.202] Resolving globals: FALSE
[17:39:24.203] Tweak future expression to call with '...' arguments ...
[17:39:24.203] {
[17:39:24.203]     do.call(function(...) {
[17:39:24.203]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.203]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.203]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.203]             on.exit(options(oopts), add = TRUE)
[17:39:24.203]         }
[17:39:24.203]         {
[17:39:24.203]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.203]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.203]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:24.203]                   envir = globalenv(), inherits = FALSE)
[17:39:24.203]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.203]             })
[17:39:24.203]         }
[17:39:24.203]     }, args = future.call.arguments)
[17:39:24.203] }
[17:39:24.203] Tweak future expression to call with '...' arguments ... DONE
[17:39:24.203] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:39:24.204] 
[17:39:24.204] getGlobalsAndPackages() ... DONE
[17:39:24.204] run() for ‘Future’ ...
[17:39:24.204] - state: ‘created’
[17:39:24.204] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:24.220] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:24.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:24.220]   - Field: ‘node’
[17:39:24.220]   - Field: ‘label’
[17:39:24.221]   - Field: ‘local’
[17:39:24.221]   - Field: ‘owner’
[17:39:24.221]   - Field: ‘envir’
[17:39:24.221]   - Field: ‘workers’
[17:39:24.221]   - Field: ‘packages’
[17:39:24.221]   - Field: ‘gc’
[17:39:24.221]   - Field: ‘conditions’
[17:39:24.222]   - Field: ‘persistent’
[17:39:24.222]   - Field: ‘expr’
[17:39:24.222]   - Field: ‘uuid’
[17:39:24.222]   - Field: ‘seed’
[17:39:24.222]   - Field: ‘version’
[17:39:24.222]   - Field: ‘result’
[17:39:24.222]   - Field: ‘asynchronous’
[17:39:24.222]   - Field: ‘calls’
[17:39:24.223]   - Field: ‘globals’
[17:39:24.223]   - Field: ‘stdout’
[17:39:24.223]   - Field: ‘earlySignal’
[17:39:24.223]   - Field: ‘lazy’
[17:39:24.223]   - Field: ‘state’
[17:39:24.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:24.223] - Launch lazy future ...
[17:39:24.224] Packages needed by the future expression (n = 0): <none>
[17:39:24.224] Packages needed by future strategies (n = 0): <none>
[17:39:24.225] {
[17:39:24.225]     {
[17:39:24.225]         {
[17:39:24.225]             ...future.startTime <- base::Sys.time()
[17:39:24.225]             {
[17:39:24.225]                 {
[17:39:24.225]                   {
[17:39:24.225]                     {
[17:39:24.225]                       base::local({
[17:39:24.225]                         has_future <- base::requireNamespace("future", 
[17:39:24.225]                           quietly = TRUE)
[17:39:24.225]                         if (has_future) {
[17:39:24.225]                           ns <- base::getNamespace("future")
[17:39:24.225]                           version <- ns[[".package"]][["version"]]
[17:39:24.225]                           if (is.null(version)) 
[17:39:24.225]                             version <- utils::packageVersion("future")
[17:39:24.225]                         }
[17:39:24.225]                         else {
[17:39:24.225]                           version <- NULL
[17:39:24.225]                         }
[17:39:24.225]                         if (!has_future || version < "1.8.0") {
[17:39:24.225]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:24.225]                             "", base::R.version$version.string), 
[17:39:24.225]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:24.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:24.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:24.225]                               "release", "version")], collapse = " "), 
[17:39:24.225]                             hostname = base::Sys.info()[["nodename"]])
[17:39:24.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:24.225]                             info)
[17:39:24.225]                           info <- base::paste(info, collapse = "; ")
[17:39:24.225]                           if (!has_future) {
[17:39:24.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:24.225]                               info)
[17:39:24.225]                           }
[17:39:24.225]                           else {
[17:39:24.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:24.225]                               info, version)
[17:39:24.225]                           }
[17:39:24.225]                           base::stop(msg)
[17:39:24.225]                         }
[17:39:24.225]                       })
[17:39:24.225]                     }
[17:39:24.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:24.225]                     base::options(mc.cores = 1L)
[17:39:24.225]                   }
[17:39:24.225]                   options(future.plan = NULL)
[17:39:24.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:24.225]                 }
[17:39:24.225]                 ...future.workdir <- getwd()
[17:39:24.225]             }
[17:39:24.225]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:24.225]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:24.225]         }
[17:39:24.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:24.225]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:39:24.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:24.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:24.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:24.225]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:24.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:24.225]             base::names(...future.oldOptions))
[17:39:24.225]     }
[17:39:24.225]     if (FALSE) {
[17:39:24.225]     }
[17:39:24.225]     else {
[17:39:24.225]         if (TRUE) {
[17:39:24.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:24.225]                 open = "w")
[17:39:24.225]         }
[17:39:24.225]         else {
[17:39:24.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:24.225]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:24.225]         }
[17:39:24.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:24.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:24.225]             base::sink(type = "output", split = FALSE)
[17:39:24.225]             base::close(...future.stdout)
[17:39:24.225]         }, add = TRUE)
[17:39:24.225]     }
[17:39:24.225]     ...future.frame <- base::sys.nframe()
[17:39:24.225]     ...future.conditions <- base::list()
[17:39:24.225]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:24.225]     if (FALSE) {
[17:39:24.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:24.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:24.225]     }
[17:39:24.225]     ...future.result <- base::tryCatch({
[17:39:24.225]         base::withCallingHandlers({
[17:39:24.225]             ...future.value <- base::withVisible(base::local({
[17:39:24.225]                 ...future.makeSendCondition <- local({
[17:39:24.225]                   sendCondition <- NULL
[17:39:24.225]                   function(frame = 1L) {
[17:39:24.225]                     if (is.function(sendCondition)) 
[17:39:24.225]                       return(sendCondition)
[17:39:24.225]                     ns <- getNamespace("parallel")
[17:39:24.225]                     if (exists("sendData", mode = "function", 
[17:39:24.225]                       envir = ns)) {
[17:39:24.225]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:24.225]                         envir = ns)
[17:39:24.225]                       envir <- sys.frame(frame)
[17:39:24.225]                       master <- NULL
[17:39:24.225]                       while (!identical(envir, .GlobalEnv) && 
[17:39:24.225]                         !identical(envir, emptyenv())) {
[17:39:24.225]                         if (exists("master", mode = "list", envir = envir, 
[17:39:24.225]                           inherits = FALSE)) {
[17:39:24.225]                           master <- get("master", mode = "list", 
[17:39:24.225]                             envir = envir, inherits = FALSE)
[17:39:24.225]                           if (inherits(master, c("SOCKnode", 
[17:39:24.225]                             "SOCK0node"))) {
[17:39:24.225]                             sendCondition <<- function(cond) {
[17:39:24.225]                               data <- list(type = "VALUE", value = cond, 
[17:39:24.225]                                 success = TRUE)
[17:39:24.225]                               parallel_sendData(master, data)
[17:39:24.225]                             }
[17:39:24.225]                             return(sendCondition)
[17:39:24.225]                           }
[17:39:24.225]                         }
[17:39:24.225]                         frame <- frame + 1L
[17:39:24.225]                         envir <- sys.frame(frame)
[17:39:24.225]                       }
[17:39:24.225]                     }
[17:39:24.225]                     sendCondition <<- function(cond) NULL
[17:39:24.225]                   }
[17:39:24.225]                 })
[17:39:24.225]                 withCallingHandlers({
[17:39:24.225]                   {
[17:39:24.225]                     do.call(function(...) {
[17:39:24.225]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.225]                       if (!identical(...future.globals.maxSize.org, 
[17:39:24.225]                         ...future.globals.maxSize)) {
[17:39:24.225]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.225]                         on.exit(options(oopts), add = TRUE)
[17:39:24.225]                       }
[17:39:24.225]                       {
[17:39:24.225]                         lapply(seq_along(...future.elements_ii), 
[17:39:24.225]                           FUN = function(jj) {
[17:39:24.225]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.225]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:24.225]                               envir = globalenv(), inherits = FALSE)
[17:39:24.225]                             ...future.FUN(...future.X_jj, ...)
[17:39:24.225]                           })
[17:39:24.225]                       }
[17:39:24.225]                     }, args = future.call.arguments)
[17:39:24.225]                   }
[17:39:24.225]                 }, immediateCondition = function(cond) {
[17:39:24.225]                   sendCondition <- ...future.makeSendCondition()
[17:39:24.225]                   sendCondition(cond)
[17:39:24.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.225]                   {
[17:39:24.225]                     inherits <- base::inherits
[17:39:24.225]                     invokeRestart <- base::invokeRestart
[17:39:24.225]                     is.null <- base::is.null
[17:39:24.225]                     muffled <- FALSE
[17:39:24.225]                     if (inherits(cond, "message")) {
[17:39:24.225]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:24.225]                       if (muffled) 
[17:39:24.225]                         invokeRestart("muffleMessage")
[17:39:24.225]                     }
[17:39:24.225]                     else if (inherits(cond, "warning")) {
[17:39:24.225]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:24.225]                       if (muffled) 
[17:39:24.225]                         invokeRestart("muffleWarning")
[17:39:24.225]                     }
[17:39:24.225]                     else if (inherits(cond, "condition")) {
[17:39:24.225]                       if (!is.null(pattern)) {
[17:39:24.225]                         computeRestarts <- base::computeRestarts
[17:39:24.225]                         grepl <- base::grepl
[17:39:24.225]                         restarts <- computeRestarts(cond)
[17:39:24.225]                         for (restart in restarts) {
[17:39:24.225]                           name <- restart$name
[17:39:24.225]                           if (is.null(name)) 
[17:39:24.225]                             next
[17:39:24.225]                           if (!grepl(pattern, name)) 
[17:39:24.225]                             next
[17:39:24.225]                           invokeRestart(restart)
[17:39:24.225]                           muffled <- TRUE
[17:39:24.225]                           break
[17:39:24.225]                         }
[17:39:24.225]                       }
[17:39:24.225]                     }
[17:39:24.225]                     invisible(muffled)
[17:39:24.225]                   }
[17:39:24.225]                   muffleCondition(cond)
[17:39:24.225]                 })
[17:39:24.225]             }))
[17:39:24.225]             future::FutureResult(value = ...future.value$value, 
[17:39:24.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.225]                   ...future.rng), globalenv = if (FALSE) 
[17:39:24.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:24.225]                     ...future.globalenv.names))
[17:39:24.225]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:24.225]         }, condition = base::local({
[17:39:24.225]             c <- base::c
[17:39:24.225]             inherits <- base::inherits
[17:39:24.225]             invokeRestart <- base::invokeRestart
[17:39:24.225]             length <- base::length
[17:39:24.225]             list <- base::list
[17:39:24.225]             seq.int <- base::seq.int
[17:39:24.225]             signalCondition <- base::signalCondition
[17:39:24.225]             sys.calls <- base::sys.calls
[17:39:24.225]             `[[` <- base::`[[`
[17:39:24.225]             `+` <- base::`+`
[17:39:24.225]             `<<-` <- base::`<<-`
[17:39:24.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:24.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:24.225]                   3L)]
[17:39:24.225]             }
[17:39:24.225]             function(cond) {
[17:39:24.225]                 is_error <- inherits(cond, "error")
[17:39:24.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:24.225]                   NULL)
[17:39:24.225]                 if (is_error) {
[17:39:24.225]                   sessionInformation <- function() {
[17:39:24.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:24.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:24.225]                       search = base::search(), system = base::Sys.info())
[17:39:24.225]                   }
[17:39:24.225]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:24.225]                     cond$call), session = sessionInformation(), 
[17:39:24.225]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:24.225]                   signalCondition(cond)
[17:39:24.225]                 }
[17:39:24.225]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:39:24.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:24.225]                   ...future.conditions[[length(...future.conditions) + 
[17:39:24.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:24.225]                   if (TRUE && !signal) {
[17:39:24.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.225]                     {
[17:39:24.225]                       inherits <- base::inherits
[17:39:24.225]                       invokeRestart <- base::invokeRestart
[17:39:24.225]                       is.null <- base::is.null
[17:39:24.225]                       muffled <- FALSE
[17:39:24.225]                       if (inherits(cond, "message")) {
[17:39:24.225]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.225]                         if (muffled) 
[17:39:24.225]                           invokeRestart("muffleMessage")
[17:39:24.225]                       }
[17:39:24.225]                       else if (inherits(cond, "warning")) {
[17:39:24.225]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.225]                         if (muffled) 
[17:39:24.225]                           invokeRestart("muffleWarning")
[17:39:24.225]                       }
[17:39:24.225]                       else if (inherits(cond, "condition")) {
[17:39:24.225]                         if (!is.null(pattern)) {
[17:39:24.225]                           computeRestarts <- base::computeRestarts
[17:39:24.225]                           grepl <- base::grepl
[17:39:24.225]                           restarts <- computeRestarts(cond)
[17:39:24.225]                           for (restart in restarts) {
[17:39:24.225]                             name <- restart$name
[17:39:24.225]                             if (is.null(name)) 
[17:39:24.225]                               next
[17:39:24.225]                             if (!grepl(pattern, name)) 
[17:39:24.225]                               next
[17:39:24.225]                             invokeRestart(restart)
[17:39:24.225]                             muffled <- TRUE
[17:39:24.225]                             break
[17:39:24.225]                           }
[17:39:24.225]                         }
[17:39:24.225]                       }
[17:39:24.225]                       invisible(muffled)
[17:39:24.225]                     }
[17:39:24.225]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.225]                   }
[17:39:24.225]                 }
[17:39:24.225]                 else {
[17:39:24.225]                   if (TRUE) {
[17:39:24.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:24.225]                     {
[17:39:24.225]                       inherits <- base::inherits
[17:39:24.225]                       invokeRestart <- base::invokeRestart
[17:39:24.225]                       is.null <- base::is.null
[17:39:24.225]                       muffled <- FALSE
[17:39:24.225]                       if (inherits(cond, "message")) {
[17:39:24.225]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:24.225]                         if (muffled) 
[17:39:24.225]                           invokeRestart("muffleMessage")
[17:39:24.225]                       }
[17:39:24.225]                       else if (inherits(cond, "warning")) {
[17:39:24.225]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:24.225]                         if (muffled) 
[17:39:24.225]                           invokeRestart("muffleWarning")
[17:39:24.225]                       }
[17:39:24.225]                       else if (inherits(cond, "condition")) {
[17:39:24.225]                         if (!is.null(pattern)) {
[17:39:24.225]                           computeRestarts <- base::computeRestarts
[17:39:24.225]                           grepl <- base::grepl
[17:39:24.225]                           restarts <- computeRestarts(cond)
[17:39:24.225]                           for (restart in restarts) {
[17:39:24.225]                             name <- restart$name
[17:39:24.225]                             if (is.null(name)) 
[17:39:24.225]                               next
[17:39:24.225]                             if (!grepl(pattern, name)) 
[17:39:24.225]                               next
[17:39:24.225]                             invokeRestart(restart)
[17:39:24.225]                             muffled <- TRUE
[17:39:24.225]                             break
[17:39:24.225]                           }
[17:39:24.225]                         }
[17:39:24.225]                       }
[17:39:24.225]                       invisible(muffled)
[17:39:24.225]                     }
[17:39:24.225]                     muffleCondition(cond, pattern = "^muffle")
[17:39:24.225]                   }
[17:39:24.225]                 }
[17:39:24.225]             }
[17:39:24.225]         }))
[17:39:24.225]     }, error = function(ex) {
[17:39:24.225]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:24.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:24.225]                 ...future.rng), started = ...future.startTime, 
[17:39:24.225]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:24.225]             version = "1.8"), class = "FutureResult")
[17:39:24.225]     }, finally = {
[17:39:24.225]         if (!identical(...future.workdir, getwd())) 
[17:39:24.225]             setwd(...future.workdir)
[17:39:24.225]         {
[17:39:24.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:24.225]                 ...future.oldOptions$nwarnings <- NULL
[17:39:24.225]             }
[17:39:24.225]             base::options(...future.oldOptions)
[17:39:24.225]             if (.Platform$OS.type == "windows") {
[17:39:24.225]                 old_names <- names(...future.oldEnvVars)
[17:39:24.225]                 envs <- base::Sys.getenv()
[17:39:24.225]                 names <- names(envs)
[17:39:24.225]                 common <- intersect(names, old_names)
[17:39:24.225]                 added <- setdiff(names, old_names)
[17:39:24.225]                 removed <- setdiff(old_names, names)
[17:39:24.225]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:24.225]                   envs[common]]
[17:39:24.225]                 NAMES <- toupper(changed)
[17:39:24.225]                 args <- list()
[17:39:24.225]                 for (kk in seq_along(NAMES)) {
[17:39:24.225]                   name <- changed[[kk]]
[17:39:24.225]                   NAME <- NAMES[[kk]]
[17:39:24.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.225]                     next
[17:39:24.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.225]                 }
[17:39:24.225]                 NAMES <- toupper(added)
[17:39:24.225]                 for (kk in seq_along(NAMES)) {
[17:39:24.225]                   name <- added[[kk]]
[17:39:24.225]                   NAME <- NAMES[[kk]]
[17:39:24.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.225]                     next
[17:39:24.225]                   args[[name]] <- ""
[17:39:24.225]                 }
[17:39:24.225]                 NAMES <- toupper(removed)
[17:39:24.225]                 for (kk in seq_along(NAMES)) {
[17:39:24.225]                   name <- removed[[kk]]
[17:39:24.225]                   NAME <- NAMES[[kk]]
[17:39:24.225]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:24.225]                     next
[17:39:24.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:24.225]                 }
[17:39:24.225]                 if (length(args) > 0) 
[17:39:24.225]                   base::do.call(base::Sys.setenv, args = args)
[17:39:24.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:24.225]             }
[17:39:24.225]             else {
[17:39:24.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:24.225]             }
[17:39:24.225]             {
[17:39:24.225]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:24.225]                   0L) {
[17:39:24.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:24.225]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:24.225]                   base::options(opts)
[17:39:24.225]                 }
[17:39:24.225]                 {
[17:39:24.225]                   {
[17:39:24.225]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:24.225]                     NULL
[17:39:24.225]                   }
[17:39:24.225]                   options(future.plan = NULL)
[17:39:24.225]                   if (is.na(NA_character_)) 
[17:39:24.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:24.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:24.225]                   future::plan(list(function (..., workers = availableCores(), 
[17:39:24.225]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:39:24.225]                     envir = parent.frame()) 
[17:39:24.225]                   {
[17:39:24.225]                     if (is.function(workers)) 
[17:39:24.225]                       workers <- workers()
[17:39:24.225]                     workers <- structure(as.integer(workers), 
[17:39:24.225]                       class = class(workers))
[17:39:24.225]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:39:24.225]                       workers >= 1)
[17:39:24.225]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:39:24.225]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:39:24.225]                     }
[17:39:24.225]                     future <- MultisessionFuture(..., workers = workers, 
[17:39:24.225]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:39:24.225]                       envir = envir)
[17:39:24.225]                     if (!future$lazy) 
[17:39:24.225]                       future <- run(future)
[17:39:24.225]                     invisible(future)
[17:39:24.225]                   }), .cleanup = FALSE, .init = FALSE)
[17:39:24.225]                 }
[17:39:24.225]             }
[17:39:24.225]         }
[17:39:24.225]     })
[17:39:24.225]     if (TRUE) {
[17:39:24.225]         base::sink(type = "output", split = FALSE)
[17:39:24.225]         if (TRUE) {
[17:39:24.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:24.225]         }
[17:39:24.225]         else {
[17:39:24.225]             ...future.result["stdout"] <- base::list(NULL)
[17:39:24.225]         }
[17:39:24.225]         base::close(...future.stdout)
[17:39:24.225]         ...future.stdout <- NULL
[17:39:24.225]     }
[17:39:24.225]     ...future.result$conditions <- ...future.conditions
[17:39:24.225]     ...future.result$finished <- base::Sys.time()
[17:39:24.225]     ...future.result
[17:39:24.225] }
[17:39:24.230] Exporting 5 global objects (35.58 KiB) to cluster node #2 ...
[17:39:24.230] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:39:24.231] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:39:24.231] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[17:39:24.279] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[17:39:24.279] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:39:24.280] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:39:24.280] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[17:39:24.280] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[17:39:24.281] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:39:24.281] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:39:24.281] Exporting 5 global objects (35.58 KiB) to cluster node #2 ... DONE
[17:39:24.282] MultisessionFuture started
[17:39:24.282] - Launch lazy future ... done
[17:39:24.282] run() for ‘MultisessionFuture’ ... done
[17:39:24.282] Created future:
[17:39:24.282] MultisessionFuture:
[17:39:24.282] Label: ‘future_apply-2’
[17:39:24.282] Expression:
[17:39:24.282] {
[17:39:24.282]     do.call(function(...) {
[17:39:24.282]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:39:24.282]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:39:24.282]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:39:24.282]             on.exit(options(oopts), add = TRUE)
[17:39:24.282]         }
[17:39:24.282]         {
[17:39:24.282]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:39:24.282]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:39:24.282]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:39:24.282]                   envir = globalenv(), inherits = FALSE)
[17:39:24.282]                 ...future.FUN(...future.X_jj, ...)
[17:39:24.282]             })
[17:39:24.282]         }
[17:39:24.282]     }, args = future.call.arguments)
[17:39:24.282] }
[17:39:24.282] Lazy evaluation: FALSE
[17:39:24.282] Asynchronous evaluation: TRUE
[17:39:24.282] Local evaluation: TRUE
[17:39:24.282] Environment: R_GlobalEnv
[17:39:24.282] Capture standard output: TRUE
[17:39:24.282] Capture condition classes: <none>
[17:39:24.282] Globals: 5 objects totaling 35.58 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:39:24.282] Packages: <none>
[17:39:24.282] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:39:24.282] Resolved: FALSE
[17:39:24.282] Value: <not collected>
[17:39:24.282] Conditions captured: <none>
[17:39:24.282] Early signaling: FALSE
[17:39:24.282] Owner process: e00bbe10-a8d2-bf0e-594f-ee72a102e451
[17:39:24.282] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:24.294] Chunk #2 of 2 ... DONE
[17:39:24.294] Launching 2 futures (chunks) ... DONE
[17:39:24.294] Resolving 2 futures (chunks) ...
[17:39:24.294] resolve() on list ...
[17:39:24.295]  recursive: 0
[17:39:24.295]  length: 2
[17:39:24.295] 
[17:39:24.295] receiveMessageFromWorker() for ClusterFuture ...
[17:39:24.296] - Validating connection of MultisessionFuture
[17:39:24.296] - received message: FutureResult
[17:39:24.296] - Received FutureResult
[17:39:24.296] - Erased future from FutureRegistry
[17:39:24.296] result() for ClusterFuture ...
[17:39:24.296] - result already collected: FutureResult
[17:39:24.296] result() for ClusterFuture ... done
[17:39:24.296] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:24.296] Future #1
[17:39:24.297] result() for ClusterFuture ...
[17:39:24.297] - result already collected: FutureResult
[17:39:24.297] result() for ClusterFuture ... done
[17:39:24.297] result() for ClusterFuture ...
[17:39:24.297] - result already collected: FutureResult
[17:39:24.297] result() for ClusterFuture ... done
[17:39:24.297] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:39:24.299] - nx: 2
[17:39:24.300] - relay: TRUE
[17:39:24.300] - stdout: TRUE
[17:39:24.300] - signal: TRUE
[17:39:24.300] - resignal: FALSE
[17:39:24.300] - force: TRUE
[17:39:24.300] - relayed: [n=2] FALSE, FALSE
[17:39:24.300] - queued futures: [n=2] FALSE, FALSE
[17:39:24.300]  - until=1
[17:39:24.300]  - relaying element #1
[17:39:24.300] result() for ClusterFuture ...
[17:39:24.300] - result already collected: FutureResult
[17:39:24.301] result() for ClusterFuture ... done
[17:39:24.301] result() for ClusterFuture ...
[17:39:24.301] - result already collected: FutureResult
[17:39:24.301] result() for ClusterFuture ... done
[17:39:24.301] result() for ClusterFuture ...
[17:39:24.301] - result already collected: FutureResult
[17:39:24.301] result() for ClusterFuture ... done
[17:39:24.301] result() for ClusterFuture ...
[17:39:24.301] - result already collected: FutureResult
[17:39:24.301] result() for ClusterFuture ... done
[17:39:24.301] - relayed: [n=2] TRUE, FALSE
[17:39:24.302] - queued futures: [n=2] TRUE, FALSE
[17:39:24.302] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:39:24.302]  length: 1 (resolved future 1)
[17:39:24.330] receiveMessageFromWorker() for ClusterFuture ...
[17:39:24.330] - Validating connection of MultisessionFuture
[17:39:24.330] - received message: FutureResult
[17:39:24.330] - Received FutureResult
[17:39:24.330] - Erased future from FutureRegistry
[17:39:24.331] result() for ClusterFuture ...
[17:39:24.331] - result already collected: FutureResult
[17:39:24.331] result() for ClusterFuture ... done
[17:39:24.331] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:24.331] Future #2
[17:39:24.331] result() for ClusterFuture ...
[17:39:24.331] - result already collected: FutureResult
[17:39:24.331] result() for ClusterFuture ... done
[17:39:24.331] result() for ClusterFuture ...
[17:39:24.331] - result already collected: FutureResult
[17:39:24.332] result() for ClusterFuture ... done
[17:39:24.332] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:24.332] - nx: 2
[17:39:24.332] - relay: TRUE
[17:39:24.332] - stdout: TRUE
[17:39:24.332] - signal: TRUE
[17:39:24.332] - resignal: FALSE
[17:39:24.332] - force: TRUE
[17:39:24.332] - relayed: [n=2] TRUE, FALSE
[17:39:24.332] - queued futures: [n=2] TRUE, FALSE
[17:39:24.332]  - until=2
[17:39:24.333]  - relaying element #2
[17:39:24.333] result() for ClusterFuture ...
[17:39:24.333] - result already collected: FutureResult
[17:39:24.333] result() for ClusterFuture ... done
[17:39:24.333] result() for ClusterFuture ...
[17:39:24.333] - result already collected: FutureResult
[17:39:24.333] result() for ClusterFuture ... done
[17:39:24.333] result() for ClusterFuture ...
[17:39:24.333] - result already collected: FutureResult
[17:39:24.333] result() for ClusterFuture ... done
[17:39:24.333] result() for ClusterFuture ...
[17:39:24.334] - result already collected: FutureResult
[17:39:24.334] result() for ClusterFuture ... done
[17:39:24.334] - relayed: [n=2] TRUE, TRUE
[17:39:24.334] - queued futures: [n=2] TRUE, TRUE
[17:39:24.334] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:24.334]  length: 0 (resolved future 2)
[17:39:24.334] Relaying remaining futures
[17:39:24.334] signalConditionsASAP(NULL, pos=0) ...
[17:39:24.334] - nx: 2
[17:39:24.334] - relay: TRUE
[17:39:24.334] - stdout: TRUE
[17:39:24.335] - signal: TRUE
[17:39:24.335] - resignal: FALSE
[17:39:24.335] - force: TRUE
[17:39:24.335] - relayed: [n=2] TRUE, TRUE
[17:39:24.335] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:39:24.335] - relayed: [n=2] TRUE, TRUE
[17:39:24.335] - queued futures: [n=2] TRUE, TRUE
[17:39:24.335] signalConditionsASAP(NULL, pos=0) ... done
[17:39:24.335] resolve() on list ... DONE
[17:39:24.335] result() for ClusterFuture ...
[17:39:24.335] - result already collected: FutureResult
[17:39:24.336] result() for ClusterFuture ... done
[17:39:24.336] result() for ClusterFuture ...
[17:39:24.336] - result already collected: FutureResult
[17:39:24.336] result() for ClusterFuture ... done
[17:39:24.336] result() for ClusterFuture ...
[17:39:24.336] - result already collected: FutureResult
[17:39:24.336] result() for ClusterFuture ... done
[17:39:24.336] result() for ClusterFuture ...
[17:39:24.336] - result already collected: FutureResult
[17:39:24.336] result() for ClusterFuture ... done
[17:39:24.336]  - Number of value chunks collected: 2
[17:39:24.337] Resolving 2 futures (chunks) ... DONE
[17:39:24.337] Reducing values from 2 chunks ...
[17:39:24.337]  - Number of values collected after concatenation: 2
[17:39:24.337]  - Number of values expected: 2
[17:39:24.337] Reducing values from 2 chunks ... DONE
[17:39:24.337] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:39:24.337] plan(): Setting new future strategy stack:
[17:39:24.337] List of future strategies:
[17:39:24.337] 1. sequential:
[17:39:24.337]    - args: function (..., envir = parent.frame())
[17:39:24.337]    - tweaked: FALSE
[17:39:24.337]    - call: plan(sequential)
[17:39:24.338] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[17:39:24.340] plan(): Setting new future strategy stack:
[17:39:24.340] List of future strategies:
[17:39:24.340] 1. FutureStrategy:
[17:39:24.340]    - args: function (..., envir = parent.frame())
[17:39:24.340]    - tweaked: FALSE
[17:39:24.340]    - call: future::plan(oplan)
[17:39:24.341] plan(): nbrOfWorkers() = 1
> 
