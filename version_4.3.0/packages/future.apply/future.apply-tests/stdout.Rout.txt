
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:11:11.838] plan(): Setting new future strategy stack:
[16:11:11.838] List of future strategies:
[16:11:11.838] 1. sequential:
[16:11:11.838]    - args: function (..., envir = parent.frame())
[16:11:11.838]    - tweaked: FALSE
[16:11:11.838]    - call: future::plan("sequential")
[16:11:11.848] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[16:11:11.887] plan(): Setting new future strategy stack:
[16:11:11.887] List of future strategies:
[16:11:11.887] 1. sequential:
[16:11:11.887]    - args: function (..., envir = parent.frame())
[16:11:11.887]    - tweaked: FALSE
[16:11:11.887]    - call: plan(strategy)
[16:11:11.909] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:11:11.909] future_lapply() ...
[16:11:11.917] Number of chunks: 1
[16:11:11.918] getGlobalsAndPackagesXApply() ...
[16:11:11.918]  - future.globals: TRUE
[16:11:11.919] getGlobalsAndPackages() ...
[16:11:11.921] Searching for globals...
[16:11:11.925] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:11.925] Searching for globals ... DONE
[16:11:11.925] Resolving globals: FALSE
[16:11:11.927] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:11.927] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:11.927] - globals: [1] ‘FUN’
[16:11:11.928] 
[16:11:11.928] getGlobalsAndPackages() ... DONE
[16:11:11.928]  - globals found/used: [n=1] ‘FUN’
[16:11:11.928]  - needed namespaces: [n=0] 
[16:11:11.928] Finding globals ... DONE
[16:11:11.928]  - use_args: TRUE
[16:11:11.929]  - Getting '...' globals ...
[16:11:11.930] resolve() on list ...
[16:11:11.930]  recursive: 0
[16:11:11.930]  length: 1
[16:11:11.931]  elements: ‘...’
[16:11:11.931]  length: 0 (resolved future 1)
[16:11:11.931] resolve() on list ... DONE
[16:11:11.931]    - '...' content: [n=0] 
[16:11:11.931] List of 1
[16:11:11.931]  $ ...: list()
[16:11:11.931]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:11.931]  - attr(*, "where")=List of 1
[16:11:11.931]   ..$ ...:<environment: 0x557e212ca4d0> 
[16:11:11.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:11.931]  - attr(*, "resolved")= logi TRUE
[16:11:11.931]  - attr(*, "total_size")= num NA
[16:11:11.938]  - Getting '...' globals ... DONE
[16:11:11.939] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:11.939] List of 2
[16:11:11.939]  $ ...future.FUN:function (x)  
[16:11:11.939]  $ ...          : list()
[16:11:11.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:11.939]  - attr(*, "where")=List of 2
[16:11:11.939]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:11.939]   ..$ ...          :<environment: 0x557e212ca4d0> 
[16:11:11.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:11.939]  - attr(*, "resolved")= logi FALSE
[16:11:11.939]  - attr(*, "total_size")= num 4720
[16:11:11.943] Packages to be attached in all futures: [n=0] 
[16:11:11.943] getGlobalsAndPackagesXApply() ... DONE
[16:11:11.944] Number of futures (= number of chunks): 1
[16:11:11.944] Launching 1 futures (chunks) ...
[16:11:11.944] Chunk #1 of 1 ...
[16:11:11.944]  - Finding globals in 'X' for chunk #1 ...
[16:11:11.945] getGlobalsAndPackages() ...
[16:11:11.945] Searching for globals...
[16:11:11.945] 
[16:11:11.945] Searching for globals ... DONE
[16:11:11.945] - globals: [0] <none>
[16:11:11.945] getGlobalsAndPackages() ... DONE
[16:11:11.945]    + additional globals found: [n=0] 
[16:11:11.946]    + additional namespaces needed: [n=0] 
[16:11:11.946]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:11.946]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:11.946]  - seeds: <none>
[16:11:11.946] getGlobalsAndPackages() ...
[16:11:11.946] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:11.946] Resolving globals: FALSE
[16:11:11.946] Tweak future expression to call with '...' arguments ...
[16:11:11.947] {
[16:11:11.947]     do.call(function(...) {
[16:11:11.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:11.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:11.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:11.947]             on.exit(options(oopts), add = TRUE)
[16:11:11.947]         }
[16:11:11.947]         {
[16:11:11.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:11.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:11.947]                 ...future.FUN(...future.X_jj, ...)
[16:11:11.947]             })
[16:11:11.947]         }
[16:11:11.947]     }, args = future.call.arguments)
[16:11:11.947] }
[16:11:11.947] Tweak future expression to call with '...' arguments ... DONE
[16:11:11.947] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:11.947] 
[16:11:11.947] getGlobalsAndPackages() ... DONE
[16:11:11.948] run() for ‘Future’ ...
[16:11:11.948] - state: ‘created’
[16:11:11.949] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:11.949] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:11.949] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:11.949]   - Field: ‘label’
[16:11:11.949]   - Field: ‘local’
[16:11:11.949]   - Field: ‘owner’
[16:11:11.949]   - Field: ‘envir’
[16:11:11.949]   - Field: ‘packages’
[16:11:11.950]   - Field: ‘gc’
[16:11:11.950]   - Field: ‘conditions’
[16:11:11.950]   - Field: ‘expr’
[16:11:11.950]   - Field: ‘uuid’
[16:11:11.950]   - Field: ‘seed’
[16:11:11.950]   - Field: ‘version’
[16:11:11.950]   - Field: ‘result’
[16:11:11.950]   - Field: ‘asynchronous’
[16:11:11.950]   - Field: ‘calls’
[16:11:11.950]   - Field: ‘globals’
[16:11:11.950]   - Field: ‘stdout’
[16:11:11.951]   - Field: ‘earlySignal’
[16:11:11.951]   - Field: ‘lazy’
[16:11:11.951]   - Field: ‘state’
[16:11:11.951] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:11.951] - Launch lazy future ...
[16:11:11.952] Packages needed by the future expression (n = 0): <none>
[16:11:11.952] Packages needed by future strategies (n = 0): <none>
[16:11:11.953] {
[16:11:11.953]     {
[16:11:11.953]         {
[16:11:11.953]             ...future.startTime <- base::Sys.time()
[16:11:11.953]             {
[16:11:11.953]                 {
[16:11:11.953]                   {
[16:11:11.953]                     base::local({
[16:11:11.953]                       has_future <- base::requireNamespace("future", 
[16:11:11.953]                         quietly = TRUE)
[16:11:11.953]                       if (has_future) {
[16:11:11.953]                         ns <- base::getNamespace("future")
[16:11:11.953]                         version <- ns[[".package"]][["version"]]
[16:11:11.953]                         if (is.null(version)) 
[16:11:11.953]                           version <- utils::packageVersion("future")
[16:11:11.953]                       }
[16:11:11.953]                       else {
[16:11:11.953]                         version <- NULL
[16:11:11.953]                       }
[16:11:11.953]                       if (!has_future || version < "1.8.0") {
[16:11:11.953]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:11.953]                           "", base::R.version$version.string), 
[16:11:11.953]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:11.953]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:11.953]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:11.953]                             "release", "version")], collapse = " "), 
[16:11:11.953]                           hostname = base::Sys.info()[["nodename"]])
[16:11:11.953]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:11.953]                           info)
[16:11:11.953]                         info <- base::paste(info, collapse = "; ")
[16:11:11.953]                         if (!has_future) {
[16:11:11.953]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:11.953]                             info)
[16:11:11.953]                         }
[16:11:11.953]                         else {
[16:11:11.953]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:11.953]                             info, version)
[16:11:11.953]                         }
[16:11:11.953]                         base::stop(msg)
[16:11:11.953]                       }
[16:11:11.953]                     })
[16:11:11.953]                   }
[16:11:11.953]                   options(future.plan = NULL)
[16:11:11.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:11.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:11.953]                 }
[16:11:11.953]                 ...future.workdir <- getwd()
[16:11:11.953]             }
[16:11:11.953]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:11.953]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:11.953]         }
[16:11:11.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:11.953]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:11.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:11.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:11.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:11.953]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:11.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:11.953]             base::names(...future.oldOptions))
[16:11:11.953]     }
[16:11:11.953]     if (FALSE) {
[16:11:11.953]     }
[16:11:11.953]     else {
[16:11:11.953]         if (FALSE) {
[16:11:11.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:11.953]                 open = "w")
[16:11:11.953]         }
[16:11:11.953]         else {
[16:11:11.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:11.953]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:11.953]         }
[16:11:11.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:11.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:11.953]             base::sink(type = "output", split = FALSE)
[16:11:11.953]             base::close(...future.stdout)
[16:11:11.953]         }, add = TRUE)
[16:11:11.953]     }
[16:11:11.953]     ...future.frame <- base::sys.nframe()
[16:11:11.953]     ...future.conditions <- base::list()
[16:11:11.953]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:11.953]     if (FALSE) {
[16:11:11.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:11.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:11.953]     }
[16:11:11.953]     ...future.result <- base::tryCatch({
[16:11:11.953]         base::withCallingHandlers({
[16:11:11.953]             ...future.value <- base::withVisible(base::local({
[16:11:11.953]                 do.call(function(...) {
[16:11:11.953]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:11.953]                   if (!identical(...future.globals.maxSize.org, 
[16:11:11.953]                     ...future.globals.maxSize)) {
[16:11:11.953]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:11.953]                     on.exit(options(oopts), add = TRUE)
[16:11:11.953]                   }
[16:11:11.953]                   {
[16:11:11.953]                     lapply(seq_along(...future.elements_ii), 
[16:11:11.953]                       FUN = function(jj) {
[16:11:11.953]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:11.953]                         ...future.FUN(...future.X_jj, ...)
[16:11:11.953]                       })
[16:11:11.953]                   }
[16:11:11.953]                 }, args = future.call.arguments)
[16:11:11.953]             }))
[16:11:11.953]             future::FutureResult(value = ...future.value$value, 
[16:11:11.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:11.953]                   ...future.rng), globalenv = if (FALSE) 
[16:11:11.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:11.953]                     ...future.globalenv.names))
[16:11:11.953]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:11.953]         }, condition = base::local({
[16:11:11.953]             c <- base::c
[16:11:11.953]             inherits <- base::inherits
[16:11:11.953]             invokeRestart <- base::invokeRestart
[16:11:11.953]             length <- base::length
[16:11:11.953]             list <- base::list
[16:11:11.953]             seq.int <- base::seq.int
[16:11:11.953]             signalCondition <- base::signalCondition
[16:11:11.953]             sys.calls <- base::sys.calls
[16:11:11.953]             `[[` <- base::`[[`
[16:11:11.953]             `+` <- base::`+`
[16:11:11.953]             `<<-` <- base::`<<-`
[16:11:11.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:11.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:11.953]                   3L)]
[16:11:11.953]             }
[16:11:11.953]             function(cond) {
[16:11:11.953]                 is_error <- inherits(cond, "error")
[16:11:11.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:11.953]                   NULL)
[16:11:11.953]                 if (is_error) {
[16:11:11.953]                   sessionInformation <- function() {
[16:11:11.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:11.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:11.953]                       search = base::search(), system = base::Sys.info())
[16:11:11.953]                   }
[16:11:11.953]                   ...future.conditions[[length(...future.conditions) + 
[16:11:11.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:11.953]                     cond$call), session = sessionInformation(), 
[16:11:11.953]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:11.953]                   signalCondition(cond)
[16:11:11.953]                 }
[16:11:11.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:11.953]                 "immediateCondition"))) {
[16:11:11.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:11.953]                   ...future.conditions[[length(...future.conditions) + 
[16:11:11.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:11.953]                   if (TRUE && !signal) {
[16:11:11.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:11.953]                     {
[16:11:11.953]                       inherits <- base::inherits
[16:11:11.953]                       invokeRestart <- base::invokeRestart
[16:11:11.953]                       is.null <- base::is.null
[16:11:11.953]                       muffled <- FALSE
[16:11:11.953]                       if (inherits(cond, "message")) {
[16:11:11.953]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:11.953]                         if (muffled) 
[16:11:11.953]                           invokeRestart("muffleMessage")
[16:11:11.953]                       }
[16:11:11.953]                       else if (inherits(cond, "warning")) {
[16:11:11.953]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:11.953]                         if (muffled) 
[16:11:11.953]                           invokeRestart("muffleWarning")
[16:11:11.953]                       }
[16:11:11.953]                       else if (inherits(cond, "condition")) {
[16:11:11.953]                         if (!is.null(pattern)) {
[16:11:11.953]                           computeRestarts <- base::computeRestarts
[16:11:11.953]                           grepl <- base::grepl
[16:11:11.953]                           restarts <- computeRestarts(cond)
[16:11:11.953]                           for (restart in restarts) {
[16:11:11.953]                             name <- restart$name
[16:11:11.953]                             if (is.null(name)) 
[16:11:11.953]                               next
[16:11:11.953]                             if (!grepl(pattern, name)) 
[16:11:11.953]                               next
[16:11:11.953]                             invokeRestart(restart)
[16:11:11.953]                             muffled <- TRUE
[16:11:11.953]                             break
[16:11:11.953]                           }
[16:11:11.953]                         }
[16:11:11.953]                       }
[16:11:11.953]                       invisible(muffled)
[16:11:11.953]                     }
[16:11:11.953]                     muffleCondition(cond, pattern = "^muffle")
[16:11:11.953]                   }
[16:11:11.953]                 }
[16:11:11.953]                 else {
[16:11:11.953]                   if (TRUE) {
[16:11:11.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:11.953]                     {
[16:11:11.953]                       inherits <- base::inherits
[16:11:11.953]                       invokeRestart <- base::invokeRestart
[16:11:11.953]                       is.null <- base::is.null
[16:11:11.953]                       muffled <- FALSE
[16:11:11.953]                       if (inherits(cond, "message")) {
[16:11:11.953]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:11.953]                         if (muffled) 
[16:11:11.953]                           invokeRestart("muffleMessage")
[16:11:11.953]                       }
[16:11:11.953]                       else if (inherits(cond, "warning")) {
[16:11:11.953]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:11.953]                         if (muffled) 
[16:11:11.953]                           invokeRestart("muffleWarning")
[16:11:11.953]                       }
[16:11:11.953]                       else if (inherits(cond, "condition")) {
[16:11:11.953]                         if (!is.null(pattern)) {
[16:11:11.953]                           computeRestarts <- base::computeRestarts
[16:11:11.953]                           grepl <- base::grepl
[16:11:11.953]                           restarts <- computeRestarts(cond)
[16:11:11.953]                           for (restart in restarts) {
[16:11:11.953]                             name <- restart$name
[16:11:11.953]                             if (is.null(name)) 
[16:11:11.953]                               next
[16:11:11.953]                             if (!grepl(pattern, name)) 
[16:11:11.953]                               next
[16:11:11.953]                             invokeRestart(restart)
[16:11:11.953]                             muffled <- TRUE
[16:11:11.953]                             break
[16:11:11.953]                           }
[16:11:11.953]                         }
[16:11:11.953]                       }
[16:11:11.953]                       invisible(muffled)
[16:11:11.953]                     }
[16:11:11.953]                     muffleCondition(cond, pattern = "^muffle")
[16:11:11.953]                   }
[16:11:11.953]                 }
[16:11:11.953]             }
[16:11:11.953]         }))
[16:11:11.953]     }, error = function(ex) {
[16:11:11.953]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:11.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:11.953]                 ...future.rng), started = ...future.startTime, 
[16:11:11.953]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:11.953]             version = "1.8"), class = "FutureResult")
[16:11:11.953]     }, finally = {
[16:11:11.953]         if (!identical(...future.workdir, getwd())) 
[16:11:11.953]             setwd(...future.workdir)
[16:11:11.953]         {
[16:11:11.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:11.953]                 ...future.oldOptions$nwarnings <- NULL
[16:11:11.953]             }
[16:11:11.953]             base::options(...future.oldOptions)
[16:11:11.953]             if (.Platform$OS.type == "windows") {
[16:11:11.953]                 old_names <- names(...future.oldEnvVars)
[16:11:11.953]                 envs <- base::Sys.getenv()
[16:11:11.953]                 names <- names(envs)
[16:11:11.953]                 common <- intersect(names, old_names)
[16:11:11.953]                 added <- setdiff(names, old_names)
[16:11:11.953]                 removed <- setdiff(old_names, names)
[16:11:11.953]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:11.953]                   envs[common]]
[16:11:11.953]                 NAMES <- toupper(changed)
[16:11:11.953]                 args <- list()
[16:11:11.953]                 for (kk in seq_along(NAMES)) {
[16:11:11.953]                   name <- changed[[kk]]
[16:11:11.953]                   NAME <- NAMES[[kk]]
[16:11:11.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:11.953]                     next
[16:11:11.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:11.953]                 }
[16:11:11.953]                 NAMES <- toupper(added)
[16:11:11.953]                 for (kk in seq_along(NAMES)) {
[16:11:11.953]                   name <- added[[kk]]
[16:11:11.953]                   NAME <- NAMES[[kk]]
[16:11:11.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:11.953]                     next
[16:11:11.953]                   args[[name]] <- ""
[16:11:11.953]                 }
[16:11:11.953]                 NAMES <- toupper(removed)
[16:11:11.953]                 for (kk in seq_along(NAMES)) {
[16:11:11.953]                   name <- removed[[kk]]
[16:11:11.953]                   NAME <- NAMES[[kk]]
[16:11:11.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:11.953]                     next
[16:11:11.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:11.953]                 }
[16:11:11.953]                 if (length(args) > 0) 
[16:11:11.953]                   base::do.call(base::Sys.setenv, args = args)
[16:11:11.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:11.953]             }
[16:11:11.953]             else {
[16:11:11.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:11.953]             }
[16:11:11.953]             {
[16:11:11.953]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:11.953]                   0L) {
[16:11:11.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:11.953]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:11.953]                   base::options(opts)
[16:11:11.953]                 }
[16:11:11.953]                 {
[16:11:11.953]                   {
[16:11:11.953]                     NULL
[16:11:11.953]                     RNGkind("Mersenne-Twister")
[16:11:11.953]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:11.953]                       inherits = FALSE)
[16:11:11.953]                   }
[16:11:11.953]                   options(future.plan = NULL)
[16:11:11.953]                   if (is.na(NA_character_)) 
[16:11:11.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:11.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:11.953]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:11.953]                   {
[16:11:11.953]                     future <- SequentialFuture(..., envir = envir)
[16:11:11.953]                     if (!future$lazy) 
[16:11:11.953]                       future <- run(future)
[16:11:11.953]                     invisible(future)
[16:11:11.953]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:11.953]                 }
[16:11:11.953]             }
[16:11:11.953]         }
[16:11:11.953]     })
[16:11:11.953]     if (TRUE) {
[16:11:11.953]         base::sink(type = "output", split = FALSE)
[16:11:11.953]         if (FALSE) {
[16:11:11.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:11.953]         }
[16:11:11.953]         else {
[16:11:11.953]             ...future.result["stdout"] <- base::list(NULL)
[16:11:11.953]         }
[16:11:11.953]         base::close(...future.stdout)
[16:11:11.953]         ...future.stdout <- NULL
[16:11:11.953]     }
[16:11:11.953]     ...future.result$conditions <- ...future.conditions
[16:11:11.953]     ...future.result$finished <- base::Sys.time()
[16:11:11.953]     ...future.result
[16:11:11.953] }
[16:11:11.955] assign_globals() ...
[16:11:11.955] List of 5
[16:11:11.955]  $ ...future.FUN            :function (x)  
[16:11:11.955]  $ future.call.arguments    : list()
[16:11:11.955]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:11.955]  $ ...future.elements_ii    :List of 2
[16:11:11.955]   ..$ : int 1
[16:11:11.955]   ..$ : int 0
[16:11:11.955]  $ ...future.seeds_ii       : NULL
[16:11:11.955]  $ ...future.globals.maxSize: NULL
[16:11:11.955]  - attr(*, "resolved")= logi FALSE
[16:11:11.955]  - attr(*, "total_size")= num 4720
[16:11:11.955]  - attr(*, "where")=List of 5
[16:11:11.955]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:11.955]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:11.955]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:11.955]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:11.955]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:11.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:11.955]  - attr(*, "already-done")= logi TRUE
[16:11:11.960] - reassign environment for ‘...future.FUN’
[16:11:11.960] - copied ‘...future.FUN’ to environment
[16:11:11.960] - copied ‘future.call.arguments’ to environment
[16:11:11.960] - copied ‘...future.elements_ii’ to environment
[16:11:11.960] - copied ‘...future.seeds_ii’ to environment
[16:11:11.960] - copied ‘...future.globals.maxSize’ to environment
[16:11:11.960] assign_globals() ... done
[16:11:11.960] plan(): Setting new future strategy stack:
[16:11:11.961] List of future strategies:
[16:11:11.961] 1. sequential:
[16:11:11.961]    - args: function (..., envir = parent.frame())
[16:11:11.961]    - tweaked: FALSE
[16:11:11.961]    - call: NULL
[16:11:11.961] plan(): nbrOfWorkers() = 1
[16:11:12.466] plan(): Setting new future strategy stack:
[16:11:12.466] List of future strategies:
[16:11:12.466] 1. sequential:
[16:11:12.466]    - args: function (..., envir = parent.frame())
[16:11:12.466]    - tweaked: FALSE
[16:11:12.466]    - call: plan(strategy)
[16:11:12.466] plan(): nbrOfWorkers() = 1
[16:11:12.466] SequentialFuture started (and completed)
[16:11:12.467] - Launch lazy future ... done
[16:11:12.467] run() for ‘SequentialFuture’ ... done
[16:11:12.467] Created future:
[16:11:12.467] SequentialFuture:
[16:11:12.467] Label: ‘future_lapply-1’
[16:11:12.467] Expression:
[16:11:12.467] {
[16:11:12.467]     do.call(function(...) {
[16:11:12.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:12.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:12.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:12.467]             on.exit(options(oopts), add = TRUE)
[16:11:12.467]         }
[16:11:12.467]         {
[16:11:12.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:12.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:12.467]                 ...future.FUN(...future.X_jj, ...)
[16:11:12.467]             })
[16:11:12.467]         }
[16:11:12.467]     }, args = future.call.arguments)
[16:11:12.467] }
[16:11:12.467] Lazy evaluation: FALSE
[16:11:12.467] Asynchronous evaluation: FALSE
[16:11:12.467] Local evaluation: TRUE
[16:11:12.467] Environment: R_GlobalEnv
[16:11:12.467] Capture standard output: FALSE
[16:11:12.467] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:12.467] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:12.467] Packages: <none>
[16:11:12.467] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:12.467] Resolved: TRUE
[16:11:12.467] Value: 112 bytes of class ‘list’
[16:11:12.467] Early signaling: FALSE
[16:11:12.467] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:12.467] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:12.469] Chunk #1 of 1 ... DONE
[16:11:12.469] Launching 1 futures (chunks) ... DONE
[16:11:12.469] Resolving 1 futures (chunks) ...
[16:11:12.469] resolve() on list ...
[16:11:12.470]  recursive: 0
[16:11:12.470]  length: 1
[16:11:12.470] 
[16:11:12.470] resolved() for ‘SequentialFuture’ ...
[16:11:12.470] - state: ‘finished’
[16:11:12.470] - run: TRUE
[16:11:12.470] - result: ‘FutureResult’
[16:11:12.470] resolved() for ‘SequentialFuture’ ... done
[16:11:12.470] Future #1
[16:11:12.471] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:12.471] - nx: 1
[16:11:12.471] - relay: TRUE
[16:11:12.471] - stdout: TRUE
[16:11:12.471] - signal: TRUE
[16:11:12.471] - resignal: FALSE
[16:11:12.471] - force: TRUE
[16:11:12.471] - relayed: [n=1] FALSE
[16:11:12.471] - queued futures: [n=1] FALSE
[16:11:12.472]  - until=1
[16:11:12.472]  - relaying element #1
[16:11:12.472] - relayed: [n=1] TRUE
[16:11:12.472] - queued futures: [n=1] TRUE
[16:11:12.472] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:12.472]  length: 0 (resolved future 1)
[16:11:12.472] Relaying remaining futures
[16:11:12.473] signalConditionsASAP(NULL, pos=0) ...
[16:11:12.473] - nx: 1
[16:11:12.473] - relay: TRUE
[16:11:12.473] - stdout: TRUE
[16:11:12.473] - signal: TRUE
[16:11:12.473] - resignal: FALSE
[16:11:12.473] - force: TRUE
[16:11:12.473] - relayed: [n=1] TRUE
[16:11:12.473] - queued futures: [n=1] TRUE
 - flush all
[16:11:12.473] - relayed: [n=1] TRUE
[16:11:12.473] - queued futures: [n=1] TRUE
[16:11:12.473] signalConditionsASAP(NULL, pos=0) ... done
[16:11:12.474] resolve() on list ... DONE
[16:11:12.474]  - Number of value chunks collected: 1
[16:11:12.474] Resolving 1 futures (chunks) ... DONE
[16:11:12.474] Reducing values from 1 chunks ...
[16:11:12.474]  - Number of values collected after concatenation: 2
[16:11:12.474]  - Number of values expected: 2
[16:11:12.474] Reducing values from 1 chunks ... DONE
[16:11:12.474] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:11:12.475] future_lapply() ...
[16:11:12.475] Number of chunks: 1
[16:11:12.476] getGlobalsAndPackagesXApply() ...
[16:11:12.476]  - future.globals: TRUE
[16:11:12.476] getGlobalsAndPackages() ...
[16:11:12.476] Searching for globals...
[16:11:12.477] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:12.477] Searching for globals ... DONE
[16:11:12.477] Resolving globals: FALSE
[16:11:12.478] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:12.478] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:12.478] - globals: [1] ‘FUN’
[16:11:12.478] 
[16:11:12.478] getGlobalsAndPackages() ... DONE
[16:11:12.479]  - globals found/used: [n=1] ‘FUN’
[16:11:12.479]  - needed namespaces: [n=0] 
[16:11:12.479] Finding globals ... DONE
[16:11:12.479]  - use_args: TRUE
[16:11:12.479]  - Getting '...' globals ...
[16:11:12.479] resolve() on list ...
[16:11:12.479]  recursive: 0
[16:11:12.479]  length: 1
[16:11:12.479]  elements: ‘...’
[16:11:12.480]  length: 0 (resolved future 1)
[16:11:12.480] resolve() on list ... DONE
[16:11:12.480]    - '...' content: [n=0] 
[16:11:12.480] List of 1
[16:11:12.480]  $ ...: list()
[16:11:12.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:12.480]  - attr(*, "where")=List of 1
[16:11:12.480]   ..$ ...:<environment: 0x557e20693e20> 
[16:11:12.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:12.480]  - attr(*, "resolved")= logi TRUE
[16:11:12.480]  - attr(*, "total_size")= num NA
[16:11:12.482]  - Getting '...' globals ... DONE
[16:11:12.483] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:12.483] List of 2
[16:11:12.483]  $ ...future.FUN:function (x)  
[16:11:12.483]  $ ...          : list()
[16:11:12.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:12.483]  - attr(*, "where")=List of 2
[16:11:12.483]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:12.483]   ..$ ...          :<environment: 0x557e20693e20> 
[16:11:12.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:12.483]  - attr(*, "resolved")= logi FALSE
[16:11:12.483]  - attr(*, "total_size")= num 4720
[16:11:12.486] Packages to be attached in all futures: [n=0] 
[16:11:12.486] getGlobalsAndPackagesXApply() ... DONE
[16:11:12.486] Number of futures (= number of chunks): 1
[16:11:12.486] Launching 1 futures (chunks) ...
[16:11:12.486] Chunk #1 of 1 ...
[16:11:12.486]  - Finding globals in 'X' for chunk #1 ...
[16:11:12.486] getGlobalsAndPackages() ...
[16:11:12.486] Searching for globals...
[16:11:12.487] 
[16:11:12.487] Searching for globals ... DONE
[16:11:12.487] - globals: [0] <none>
[16:11:12.487] getGlobalsAndPackages() ... DONE
[16:11:12.487]    + additional globals found: [n=0] 
[16:11:12.487]    + additional namespaces needed: [n=0] 
[16:11:12.487]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:12.487]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:12.487]  - seeds: <none>
[16:11:12.488] getGlobalsAndPackages() ...
[16:11:12.488] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:12.488] Resolving globals: FALSE
[16:11:12.488] Tweak future expression to call with '...' arguments ...
[16:11:12.488] {
[16:11:12.488]     do.call(function(...) {
[16:11:12.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:12.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:12.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:12.488]             on.exit(options(oopts), add = TRUE)
[16:11:12.488]         }
[16:11:12.488]         {
[16:11:12.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:12.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:12.488]                 ...future.FUN(...future.X_jj, ...)
[16:11:12.488]             })
[16:11:12.488]         }
[16:11:12.488]     }, args = future.call.arguments)
[16:11:12.488] }
[16:11:12.488] Tweak future expression to call with '...' arguments ... DONE
[16:11:12.489] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:12.489] 
[16:11:12.489] getGlobalsAndPackages() ... DONE
[16:11:12.489] run() for ‘Future’ ...
[16:11:12.489] - state: ‘created’
[16:11:12.489] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:12.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:12.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:12.490]   - Field: ‘label’
[16:11:12.490]   - Field: ‘local’
[16:11:12.490]   - Field: ‘owner’
[16:11:12.490]   - Field: ‘envir’
[16:11:12.490]   - Field: ‘packages’
[16:11:12.490]   - Field: ‘gc’
[16:11:12.490]   - Field: ‘conditions’
[16:11:12.490]   - Field: ‘expr’
[16:11:12.491]   - Field: ‘uuid’
[16:11:12.493]   - Field: ‘seed’
[16:11:12.493]   - Field: ‘version’
[16:11:12.493]   - Field: ‘result’
[16:11:12.493]   - Field: ‘asynchronous’
[16:11:12.493]   - Field: ‘calls’
[16:11:12.493]   - Field: ‘globals’
[16:11:12.493]   - Field: ‘stdout’
[16:11:12.493]   - Field: ‘earlySignal’
[16:11:12.493]   - Field: ‘lazy’
[16:11:12.494]   - Field: ‘state’
[16:11:12.494] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:12.494] - Launch lazy future ...
[16:11:12.494] Packages needed by the future expression (n = 0): <none>
[16:11:12.494] Packages needed by future strategies (n = 0): <none>
[16:11:12.495] {
[16:11:12.495]     {
[16:11:12.495]         {
[16:11:12.495]             ...future.startTime <- base::Sys.time()
[16:11:12.495]             {
[16:11:12.495]                 {
[16:11:12.495]                   {
[16:11:12.495]                     base::local({
[16:11:12.495]                       has_future <- base::requireNamespace("future", 
[16:11:12.495]                         quietly = TRUE)
[16:11:12.495]                       if (has_future) {
[16:11:12.495]                         ns <- base::getNamespace("future")
[16:11:12.495]                         version <- ns[[".package"]][["version"]]
[16:11:12.495]                         if (is.null(version)) 
[16:11:12.495]                           version <- utils::packageVersion("future")
[16:11:12.495]                       }
[16:11:12.495]                       else {
[16:11:12.495]                         version <- NULL
[16:11:12.495]                       }
[16:11:12.495]                       if (!has_future || version < "1.8.0") {
[16:11:12.495]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:12.495]                           "", base::R.version$version.string), 
[16:11:12.495]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:12.495]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:12.495]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:12.495]                             "release", "version")], collapse = " "), 
[16:11:12.495]                           hostname = base::Sys.info()[["nodename"]])
[16:11:12.495]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:12.495]                           info)
[16:11:12.495]                         info <- base::paste(info, collapse = "; ")
[16:11:12.495]                         if (!has_future) {
[16:11:12.495]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:12.495]                             info)
[16:11:12.495]                         }
[16:11:12.495]                         else {
[16:11:12.495]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:12.495]                             info, version)
[16:11:12.495]                         }
[16:11:12.495]                         base::stop(msg)
[16:11:12.495]                       }
[16:11:12.495]                     })
[16:11:12.495]                   }
[16:11:12.495]                   options(future.plan = NULL)
[16:11:12.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:12.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:12.495]                 }
[16:11:12.495]                 ...future.workdir <- getwd()
[16:11:12.495]             }
[16:11:12.495]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:12.495]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:12.495]         }
[16:11:12.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:12.495]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:12.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:12.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:12.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:12.495]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:12.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:12.495]             base::names(...future.oldOptions))
[16:11:12.495]     }
[16:11:12.495]     if (FALSE) {
[16:11:12.495]     }
[16:11:12.495]     else {
[16:11:12.495]         if (TRUE) {
[16:11:12.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:12.495]                 open = "w")
[16:11:12.495]         }
[16:11:12.495]         else {
[16:11:12.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:12.495]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:12.495]         }
[16:11:12.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:12.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:12.495]             base::sink(type = "output", split = FALSE)
[16:11:12.495]             base::close(...future.stdout)
[16:11:12.495]         }, add = TRUE)
[16:11:12.495]     }
[16:11:12.495]     ...future.frame <- base::sys.nframe()
[16:11:12.495]     ...future.conditions <- base::list()
[16:11:12.495]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:12.495]     if (FALSE) {
[16:11:12.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:12.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:12.495]     }
[16:11:12.495]     ...future.result <- base::tryCatch({
[16:11:12.495]         base::withCallingHandlers({
[16:11:12.495]             ...future.value <- base::withVisible(base::local({
[16:11:12.495]                 do.call(function(...) {
[16:11:12.495]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:12.495]                   if (!identical(...future.globals.maxSize.org, 
[16:11:12.495]                     ...future.globals.maxSize)) {
[16:11:12.495]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:12.495]                     on.exit(options(oopts), add = TRUE)
[16:11:12.495]                   }
[16:11:12.495]                   {
[16:11:12.495]                     lapply(seq_along(...future.elements_ii), 
[16:11:12.495]                       FUN = function(jj) {
[16:11:12.495]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:12.495]                         ...future.FUN(...future.X_jj, ...)
[16:11:12.495]                       })
[16:11:12.495]                   }
[16:11:12.495]                 }, args = future.call.arguments)
[16:11:12.495]             }))
[16:11:12.495]             future::FutureResult(value = ...future.value$value, 
[16:11:12.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:12.495]                   ...future.rng), globalenv = if (FALSE) 
[16:11:12.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:12.495]                     ...future.globalenv.names))
[16:11:12.495]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:12.495]         }, condition = base::local({
[16:11:12.495]             c <- base::c
[16:11:12.495]             inherits <- base::inherits
[16:11:12.495]             invokeRestart <- base::invokeRestart
[16:11:12.495]             length <- base::length
[16:11:12.495]             list <- base::list
[16:11:12.495]             seq.int <- base::seq.int
[16:11:12.495]             signalCondition <- base::signalCondition
[16:11:12.495]             sys.calls <- base::sys.calls
[16:11:12.495]             `[[` <- base::`[[`
[16:11:12.495]             `+` <- base::`+`
[16:11:12.495]             `<<-` <- base::`<<-`
[16:11:12.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:12.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:12.495]                   3L)]
[16:11:12.495]             }
[16:11:12.495]             function(cond) {
[16:11:12.495]                 is_error <- inherits(cond, "error")
[16:11:12.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:12.495]                   NULL)
[16:11:12.495]                 if (is_error) {
[16:11:12.495]                   sessionInformation <- function() {
[16:11:12.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:12.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:12.495]                       search = base::search(), system = base::Sys.info())
[16:11:12.495]                   }
[16:11:12.495]                   ...future.conditions[[length(...future.conditions) + 
[16:11:12.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:12.495]                     cond$call), session = sessionInformation(), 
[16:11:12.495]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:12.495]                   signalCondition(cond)
[16:11:12.495]                 }
[16:11:12.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:12.495]                 "immediateCondition"))) {
[16:11:12.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:12.495]                   ...future.conditions[[length(...future.conditions) + 
[16:11:12.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:12.495]                   if (TRUE && !signal) {
[16:11:12.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:12.495]                     {
[16:11:12.495]                       inherits <- base::inherits
[16:11:12.495]                       invokeRestart <- base::invokeRestart
[16:11:12.495]                       is.null <- base::is.null
[16:11:12.495]                       muffled <- FALSE
[16:11:12.495]                       if (inherits(cond, "message")) {
[16:11:12.495]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:12.495]                         if (muffled) 
[16:11:12.495]                           invokeRestart("muffleMessage")
[16:11:12.495]                       }
[16:11:12.495]                       else if (inherits(cond, "warning")) {
[16:11:12.495]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:12.495]                         if (muffled) 
[16:11:12.495]                           invokeRestart("muffleWarning")
[16:11:12.495]                       }
[16:11:12.495]                       else if (inherits(cond, "condition")) {
[16:11:12.495]                         if (!is.null(pattern)) {
[16:11:12.495]                           computeRestarts <- base::computeRestarts
[16:11:12.495]                           grepl <- base::grepl
[16:11:12.495]                           restarts <- computeRestarts(cond)
[16:11:12.495]                           for (restart in restarts) {
[16:11:12.495]                             name <- restart$name
[16:11:12.495]                             if (is.null(name)) 
[16:11:12.495]                               next
[16:11:12.495]                             if (!grepl(pattern, name)) 
[16:11:12.495]                               next
[16:11:12.495]                             invokeRestart(restart)
[16:11:12.495]                             muffled <- TRUE
[16:11:12.495]                             break
[16:11:12.495]                           }
[16:11:12.495]                         }
[16:11:12.495]                       }
[16:11:12.495]                       invisible(muffled)
[16:11:12.495]                     }
[16:11:12.495]                     muffleCondition(cond, pattern = "^muffle")
[16:11:12.495]                   }
[16:11:12.495]                 }
[16:11:12.495]                 else {
[16:11:12.495]                   if (TRUE) {
[16:11:12.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:12.495]                     {
[16:11:12.495]                       inherits <- base::inherits
[16:11:12.495]                       invokeRestart <- base::invokeRestart
[16:11:12.495]                       is.null <- base::is.null
[16:11:12.495]                       muffled <- FALSE
[16:11:12.495]                       if (inherits(cond, "message")) {
[16:11:12.495]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:12.495]                         if (muffled) 
[16:11:12.495]                           invokeRestart("muffleMessage")
[16:11:12.495]                       }
[16:11:12.495]                       else if (inherits(cond, "warning")) {
[16:11:12.495]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:12.495]                         if (muffled) 
[16:11:12.495]                           invokeRestart("muffleWarning")
[16:11:12.495]                       }
[16:11:12.495]                       else if (inherits(cond, "condition")) {
[16:11:12.495]                         if (!is.null(pattern)) {
[16:11:12.495]                           computeRestarts <- base::computeRestarts
[16:11:12.495]                           grepl <- base::grepl
[16:11:12.495]                           restarts <- computeRestarts(cond)
[16:11:12.495]                           for (restart in restarts) {
[16:11:12.495]                             name <- restart$name
[16:11:12.495]                             if (is.null(name)) 
[16:11:12.495]                               next
[16:11:12.495]                             if (!grepl(pattern, name)) 
[16:11:12.495]                               next
[16:11:12.495]                             invokeRestart(restart)
[16:11:12.495]                             muffled <- TRUE
[16:11:12.495]                             break
[16:11:12.495]                           }
[16:11:12.495]                         }
[16:11:12.495]                       }
[16:11:12.495]                       invisible(muffled)
[16:11:12.495]                     }
[16:11:12.495]                     muffleCondition(cond, pattern = "^muffle")
[16:11:12.495]                   }
[16:11:12.495]                 }
[16:11:12.495]             }
[16:11:12.495]         }))
[16:11:12.495]     }, error = function(ex) {
[16:11:12.495]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:12.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:12.495]                 ...future.rng), started = ...future.startTime, 
[16:11:12.495]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:12.495]             version = "1.8"), class = "FutureResult")
[16:11:12.495]     }, finally = {
[16:11:12.495]         if (!identical(...future.workdir, getwd())) 
[16:11:12.495]             setwd(...future.workdir)
[16:11:12.495]         {
[16:11:12.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:12.495]                 ...future.oldOptions$nwarnings <- NULL
[16:11:12.495]             }
[16:11:12.495]             base::options(...future.oldOptions)
[16:11:12.495]             if (.Platform$OS.type == "windows") {
[16:11:12.495]                 old_names <- names(...future.oldEnvVars)
[16:11:12.495]                 envs <- base::Sys.getenv()
[16:11:12.495]                 names <- names(envs)
[16:11:12.495]                 common <- intersect(names, old_names)
[16:11:12.495]                 added <- setdiff(names, old_names)
[16:11:12.495]                 removed <- setdiff(old_names, names)
[16:11:12.495]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:12.495]                   envs[common]]
[16:11:12.495]                 NAMES <- toupper(changed)
[16:11:12.495]                 args <- list()
[16:11:12.495]                 for (kk in seq_along(NAMES)) {
[16:11:12.495]                   name <- changed[[kk]]
[16:11:12.495]                   NAME <- NAMES[[kk]]
[16:11:12.495]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:12.495]                     next
[16:11:12.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:12.495]                 }
[16:11:12.495]                 NAMES <- toupper(added)
[16:11:12.495]                 for (kk in seq_along(NAMES)) {
[16:11:12.495]                   name <- added[[kk]]
[16:11:12.495]                   NAME <- NAMES[[kk]]
[16:11:12.495]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:12.495]                     next
[16:11:12.495]                   args[[name]] <- ""
[16:11:12.495]                 }
[16:11:12.495]                 NAMES <- toupper(removed)
[16:11:12.495]                 for (kk in seq_along(NAMES)) {
[16:11:12.495]                   name <- removed[[kk]]
[16:11:12.495]                   NAME <- NAMES[[kk]]
[16:11:12.495]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:12.495]                     next
[16:11:12.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:12.495]                 }
[16:11:12.495]                 if (length(args) > 0) 
[16:11:12.495]                   base::do.call(base::Sys.setenv, args = args)
[16:11:12.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:12.495]             }
[16:11:12.495]             else {
[16:11:12.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:12.495]             }
[16:11:12.495]             {
[16:11:12.495]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:12.495]                   0L) {
[16:11:12.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:12.495]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:12.495]                   base::options(opts)
[16:11:12.495]                 }
[16:11:12.495]                 {
[16:11:12.495]                   {
[16:11:12.495]                     NULL
[16:11:12.495]                     RNGkind("Mersenne-Twister")
[16:11:12.495]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:12.495]                       inherits = FALSE)
[16:11:12.495]                   }
[16:11:12.495]                   options(future.plan = NULL)
[16:11:12.495]                   if (is.na(NA_character_)) 
[16:11:12.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:12.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:12.495]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:12.495]                   {
[16:11:12.495]                     future <- SequentialFuture(..., envir = envir)
[16:11:12.495]                     if (!future$lazy) 
[16:11:12.495]                       future <- run(future)
[16:11:12.495]                     invisible(future)
[16:11:12.495]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:12.495]                 }
[16:11:12.495]             }
[16:11:12.495]         }
[16:11:12.495]     })
[16:11:12.495]     if (TRUE) {
[16:11:12.495]         base::sink(type = "output", split = FALSE)
[16:11:12.495]         if (TRUE) {
[16:11:12.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:12.495]         }
[16:11:12.495]         else {
[16:11:12.495]             ...future.result["stdout"] <- base::list(NULL)
[16:11:12.495]         }
[16:11:12.495]         base::close(...future.stdout)
[16:11:12.495]         ...future.stdout <- NULL
[16:11:12.495]     }
[16:11:12.495]     ...future.result$conditions <- ...future.conditions
[16:11:12.495]     ...future.result$finished <- base::Sys.time()
[16:11:12.495]     ...future.result
[16:11:12.495] }
[16:11:12.496] assign_globals() ...
[16:11:12.496] List of 5
[16:11:12.496]  $ ...future.FUN            :function (x)  
[16:11:12.496]  $ future.call.arguments    : list()
[16:11:12.496]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:12.496]  $ ...future.elements_ii    :List of 2
[16:11:12.496]   ..$ : int 1
[16:11:12.496]   ..$ : int 0
[16:11:12.496]  $ ...future.seeds_ii       : NULL
[16:11:12.496]  $ ...future.globals.maxSize: NULL
[16:11:12.496]  - attr(*, "resolved")= logi FALSE
[16:11:12.496]  - attr(*, "total_size")= num 4720
[16:11:12.496]  - attr(*, "where")=List of 5
[16:11:12.496]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:12.496]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:12.496]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:12.496]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:12.496]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:12.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:12.496]  - attr(*, "already-done")= logi TRUE
[16:11:12.501] - reassign environment for ‘...future.FUN’
[16:11:12.502] - copied ‘...future.FUN’ to environment
[16:11:12.502] - copied ‘future.call.arguments’ to environment
[16:11:12.502] - copied ‘...future.elements_ii’ to environment
[16:11:12.502] - copied ‘...future.seeds_ii’ to environment
[16:11:12.502] - copied ‘...future.globals.maxSize’ to environment
[16:11:12.502] assign_globals() ... done
[16:11:12.502] plan(): Setting new future strategy stack:
[16:11:12.502] List of future strategies:
[16:11:12.502] 1. sequential:
[16:11:12.502]    - args: function (..., envir = parent.frame())
[16:11:12.502]    - tweaked: FALSE
[16:11:12.502]    - call: NULL
[16:11:12.503] plan(): nbrOfWorkers() = 1
[16:11:13.004] plan(): Setting new future strategy stack:
[16:11:13.005] List of future strategies:
[16:11:13.005] 1. sequential:
[16:11:13.005]    - args: function (..., envir = parent.frame())
[16:11:13.005]    - tweaked: FALSE
[16:11:13.005]    - call: plan(strategy)
[16:11:13.005] plan(): nbrOfWorkers() = 1
[16:11:13.005] SequentialFuture started (and completed)
[16:11:13.006] - Launch lazy future ... done
[16:11:13.006] run() for ‘SequentialFuture’ ... done
[16:11:13.006] Created future:
[16:11:13.006] SequentialFuture:
[16:11:13.006] Label: ‘future_lapply-1’
[16:11:13.006] Expression:
[16:11:13.006] {
[16:11:13.006]     do.call(function(...) {
[16:11:13.006]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:13.006]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:13.006]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:13.006]             on.exit(options(oopts), add = TRUE)
[16:11:13.006]         }
[16:11:13.006]         {
[16:11:13.006]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:13.006]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:13.006]                 ...future.FUN(...future.X_jj, ...)
[16:11:13.006]             })
[16:11:13.006]         }
[16:11:13.006]     }, args = future.call.arguments)
[16:11:13.006] }
[16:11:13.006] Lazy evaluation: FALSE
[16:11:13.006] Asynchronous evaluation: FALSE
[16:11:13.006] Local evaluation: TRUE
[16:11:13.006] Environment: R_GlobalEnv
[16:11:13.006] Capture standard output: TRUE
[16:11:13.006] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:13.006] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:13.006] Packages: <none>
[16:11:13.006] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:13.006] Resolved: TRUE
[16:11:13.006] Value: 112 bytes of class ‘list’
[16:11:13.006] Early signaling: FALSE
[16:11:13.006] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:13.006] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:13.007] Chunk #1 of 1 ... DONE
[16:11:13.007] Launching 1 futures (chunks) ... DONE
[16:11:13.007] Resolving 1 futures (chunks) ...
[16:11:13.007] resolve() on list ...
[16:11:13.007]  recursive: 0
[16:11:13.007]  length: 1
[16:11:13.008] 
[16:11:13.008] resolved() for ‘SequentialFuture’ ...
[16:11:13.008] - state: ‘finished’
[16:11:13.008] - run: TRUE
[16:11:13.008] - result: ‘FutureResult’
[16:11:13.008] resolved() for ‘SequentialFuture’ ... done
[16:11:13.008] Future #1
[16:11:13.008] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:13.008] - nx: 1
[16:11:13.009] - relay: TRUE
[16:11:13.009] - stdout: TRUE
[16:11:13.009] - signal: TRUE
[16:11:13.009] - resignal: FALSE
[16:11:13.009] - force: TRUE
[16:11:13.009] - relayed: [n=1] FALSE
[16:11:13.009] - queued futures: [n=1] FALSE
[16:11:13.009]  - until=1
[16:11:13.009]  - relaying element #1
[16:11:13.009] - relayed: [n=1] TRUE
[16:11:13.009] - queued futures: [n=1] TRUE
[16:11:13.010] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:13.010]  length: 0 (resolved future 1)
[16:11:13.010] Relaying remaining futures
[16:11:13.010] signalConditionsASAP(NULL, pos=0) ...
[16:11:13.010] - nx: 1
[16:11:13.010] - relay: TRUE
[16:11:13.010] - stdout: TRUE
[16:11:13.010] - signal: TRUE
[16:11:13.010] - resignal: FALSE
[16:11:13.010] - force: TRUE
[16:11:13.010] - relayed: [n=1] TRUE
[16:11:13.011] - queued futures: [n=1] TRUE
 - flush all
[16:11:13.011] - relayed: [n=1] TRUE
[16:11:13.011] - queued futures: [n=1] TRUE
[16:11:13.011] signalConditionsASAP(NULL, pos=0) ... done
[16:11:13.011] resolve() on list ... DONE
[16:11:13.011]  - Number of value chunks collected: 1
[16:11:13.011] Resolving 1 futures (chunks) ... DONE
[16:11:13.011] Reducing values from 1 chunks ...
[16:11:13.011]  - Number of values collected after concatenation: 2
[16:11:13.011]  - Number of values expected: 2
[16:11:13.012] Reducing values from 1 chunks ... DONE
[16:11:13.012] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:11:13.012] future_lapply() ...
[16:11:13.013] Number of chunks: 1
[16:11:13.013] getGlobalsAndPackagesXApply() ...
[16:11:13.013]  - future.globals: TRUE
[16:11:13.013] getGlobalsAndPackages() ...
[16:11:13.013] Searching for globals...
[16:11:13.014] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:13.015] Searching for globals ... DONE
[16:11:13.015] Resolving globals: FALSE
[16:11:13.015] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:13.015] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:13.016] - globals: [1] ‘FUN’
[16:11:13.016] 
[16:11:13.016] getGlobalsAndPackages() ... DONE
[16:11:13.016]  - globals found/used: [n=1] ‘FUN’
[16:11:13.016]  - needed namespaces: [n=0] 
[16:11:13.016] Finding globals ... DONE
[16:11:13.016]  - use_args: TRUE
[16:11:13.016]  - Getting '...' globals ...
[16:11:13.017] resolve() on list ...
[16:11:13.017]  recursive: 0
[16:11:13.017]  length: 1
[16:11:13.017]  elements: ‘...’
[16:11:13.017]  length: 0 (resolved future 1)
[16:11:13.017] resolve() on list ... DONE
[16:11:13.017]    - '...' content: [n=0] 
[16:11:13.017] List of 1
[16:11:13.017]  $ ...: list()
[16:11:13.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:13.017]  - attr(*, "where")=List of 1
[16:11:13.017]   ..$ ...:<environment: 0x557e20e7c538> 
[16:11:13.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:13.017]  - attr(*, "resolved")= logi TRUE
[16:11:13.017]  - attr(*, "total_size")= num NA
[16:11:13.022]  - Getting '...' globals ... DONE
[16:11:13.022] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:13.022] List of 2
[16:11:13.022]  $ ...future.FUN:function (x)  
[16:11:13.022]  $ ...          : list()
[16:11:13.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:13.022]  - attr(*, "where")=List of 2
[16:11:13.022]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:13.022]   ..$ ...          :<environment: 0x557e20e7c538> 
[16:11:13.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:13.022]  - attr(*, "resolved")= logi FALSE
[16:11:13.022]  - attr(*, "total_size")= num 4720
[16:11:13.025] Packages to be attached in all futures: [n=0] 
[16:11:13.025] getGlobalsAndPackagesXApply() ... DONE
[16:11:13.025] Number of futures (= number of chunks): 1
[16:11:13.025] Launching 1 futures (chunks) ...
[16:11:13.025] Chunk #1 of 1 ...
[16:11:13.025]  - Finding globals in 'X' for chunk #1 ...
[16:11:13.025] getGlobalsAndPackages() ...
[16:11:13.025] Searching for globals...
[16:11:13.026] 
[16:11:13.026] Searching for globals ... DONE
[16:11:13.026] - globals: [0] <none>
[16:11:13.026] getGlobalsAndPackages() ... DONE
[16:11:13.026]    + additional globals found: [n=0] 
[16:11:13.026]    + additional namespaces needed: [n=0] 
[16:11:13.026]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:13.026]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:13.026]  - seeds: <none>
[16:11:13.027] getGlobalsAndPackages() ...
[16:11:13.027] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:13.027] Resolving globals: FALSE
[16:11:13.027] Tweak future expression to call with '...' arguments ...
[16:11:13.027] {
[16:11:13.027]     do.call(function(...) {
[16:11:13.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:13.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:13.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:13.027]             on.exit(options(oopts), add = TRUE)
[16:11:13.027]         }
[16:11:13.027]         {
[16:11:13.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:13.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:13.027]                 ...future.FUN(...future.X_jj, ...)
[16:11:13.027]             })
[16:11:13.027]         }
[16:11:13.027]     }, args = future.call.arguments)
[16:11:13.027] }
[16:11:13.027] Tweak future expression to call with '...' arguments ... DONE
[16:11:13.028] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:13.028] 
[16:11:13.028] getGlobalsAndPackages() ... DONE
[16:11:13.028] run() for ‘Future’ ...
[16:11:13.028] - state: ‘created’
[16:11:13.028] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:13.029] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:13.029] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:13.029]   - Field: ‘label’
[16:11:13.029]   - Field: ‘local’
[16:11:13.029]   - Field: ‘owner’
[16:11:13.029]   - Field: ‘envir’
[16:11:13.029]   - Field: ‘packages’
[16:11:13.029]   - Field: ‘gc’
[16:11:13.029]   - Field: ‘conditions’
[16:11:13.029]   - Field: ‘expr’
[16:11:13.030]   - Field: ‘uuid’
[16:11:13.030]   - Field: ‘seed’
[16:11:13.030]   - Field: ‘version’
[16:11:13.030]   - Field: ‘result’
[16:11:13.030]   - Field: ‘asynchronous’
[16:11:13.030]   - Field: ‘calls’
[16:11:13.030]   - Field: ‘globals’
[16:11:13.030]   - Field: ‘stdout’
[16:11:13.030]   - Field: ‘earlySignal’
[16:11:13.030]   - Field: ‘lazy’
[16:11:13.030]   - Field: ‘state’
[16:11:13.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:13.031] - Launch lazy future ...
[16:11:13.031] Packages needed by the future expression (n = 0): <none>
[16:11:13.031] Packages needed by future strategies (n = 0): <none>
[16:11:13.031] {
[16:11:13.031]     {
[16:11:13.031]         {
[16:11:13.031]             ...future.startTime <- base::Sys.time()
[16:11:13.031]             {
[16:11:13.031]                 {
[16:11:13.031]                   {
[16:11:13.031]                     base::local({
[16:11:13.031]                       has_future <- base::requireNamespace("future", 
[16:11:13.031]                         quietly = TRUE)
[16:11:13.031]                       if (has_future) {
[16:11:13.031]                         ns <- base::getNamespace("future")
[16:11:13.031]                         version <- ns[[".package"]][["version"]]
[16:11:13.031]                         if (is.null(version)) 
[16:11:13.031]                           version <- utils::packageVersion("future")
[16:11:13.031]                       }
[16:11:13.031]                       else {
[16:11:13.031]                         version <- NULL
[16:11:13.031]                       }
[16:11:13.031]                       if (!has_future || version < "1.8.0") {
[16:11:13.031]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:13.031]                           "", base::R.version$version.string), 
[16:11:13.031]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:13.031]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:13.031]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:13.031]                             "release", "version")], collapse = " "), 
[16:11:13.031]                           hostname = base::Sys.info()[["nodename"]])
[16:11:13.031]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:13.031]                           info)
[16:11:13.031]                         info <- base::paste(info, collapse = "; ")
[16:11:13.031]                         if (!has_future) {
[16:11:13.031]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:13.031]                             info)
[16:11:13.031]                         }
[16:11:13.031]                         else {
[16:11:13.031]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:13.031]                             info, version)
[16:11:13.031]                         }
[16:11:13.031]                         base::stop(msg)
[16:11:13.031]                       }
[16:11:13.031]                     })
[16:11:13.031]                   }
[16:11:13.031]                   options(future.plan = NULL)
[16:11:13.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:13.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:13.031]                 }
[16:11:13.031]                 ...future.workdir <- getwd()
[16:11:13.031]             }
[16:11:13.031]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:13.031]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:13.031]         }
[16:11:13.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:13.031]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:13.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:13.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:13.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:13.031]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:13.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:13.031]             base::names(...future.oldOptions))
[16:11:13.031]     }
[16:11:13.031]     if (TRUE) {
[16:11:13.031]     }
[16:11:13.031]     else {
[16:11:13.031]         if (NA) {
[16:11:13.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:13.031]                 open = "w")
[16:11:13.031]         }
[16:11:13.031]         else {
[16:11:13.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:13.031]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:13.031]         }
[16:11:13.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:13.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:13.031]             base::sink(type = "output", split = FALSE)
[16:11:13.031]             base::close(...future.stdout)
[16:11:13.031]         }, add = TRUE)
[16:11:13.031]     }
[16:11:13.031]     ...future.frame <- base::sys.nframe()
[16:11:13.031]     ...future.conditions <- base::list()
[16:11:13.031]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:13.031]     if (FALSE) {
[16:11:13.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:13.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:13.031]     }
[16:11:13.031]     ...future.result <- base::tryCatch({
[16:11:13.031]         base::withCallingHandlers({
[16:11:13.031]             ...future.value <- base::withVisible(base::local({
[16:11:13.031]                 do.call(function(...) {
[16:11:13.031]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:13.031]                   if (!identical(...future.globals.maxSize.org, 
[16:11:13.031]                     ...future.globals.maxSize)) {
[16:11:13.031]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:13.031]                     on.exit(options(oopts), add = TRUE)
[16:11:13.031]                   }
[16:11:13.031]                   {
[16:11:13.031]                     lapply(seq_along(...future.elements_ii), 
[16:11:13.031]                       FUN = function(jj) {
[16:11:13.031]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:13.031]                         ...future.FUN(...future.X_jj, ...)
[16:11:13.031]                       })
[16:11:13.031]                   }
[16:11:13.031]                 }, args = future.call.arguments)
[16:11:13.031]             }))
[16:11:13.031]             future::FutureResult(value = ...future.value$value, 
[16:11:13.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:13.031]                   ...future.rng), globalenv = if (FALSE) 
[16:11:13.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:13.031]                     ...future.globalenv.names))
[16:11:13.031]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:13.031]         }, condition = base::local({
[16:11:13.031]             c <- base::c
[16:11:13.031]             inherits <- base::inherits
[16:11:13.031]             invokeRestart <- base::invokeRestart
[16:11:13.031]             length <- base::length
[16:11:13.031]             list <- base::list
[16:11:13.031]             seq.int <- base::seq.int
[16:11:13.031]             signalCondition <- base::signalCondition
[16:11:13.031]             sys.calls <- base::sys.calls
[16:11:13.031]             `[[` <- base::`[[`
[16:11:13.031]             `+` <- base::`+`
[16:11:13.031]             `<<-` <- base::`<<-`
[16:11:13.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:13.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:13.031]                   3L)]
[16:11:13.031]             }
[16:11:13.031]             function(cond) {
[16:11:13.031]                 is_error <- inherits(cond, "error")
[16:11:13.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:13.031]                   NULL)
[16:11:13.031]                 if (is_error) {
[16:11:13.031]                   sessionInformation <- function() {
[16:11:13.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:13.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:13.031]                       search = base::search(), system = base::Sys.info())
[16:11:13.031]                   }
[16:11:13.031]                   ...future.conditions[[length(...future.conditions) + 
[16:11:13.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:13.031]                     cond$call), session = sessionInformation(), 
[16:11:13.031]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:13.031]                   signalCondition(cond)
[16:11:13.031]                 }
[16:11:13.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:13.031]                 "immediateCondition"))) {
[16:11:13.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:13.031]                   ...future.conditions[[length(...future.conditions) + 
[16:11:13.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:13.031]                   if (TRUE && !signal) {
[16:11:13.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:13.031]                     {
[16:11:13.031]                       inherits <- base::inherits
[16:11:13.031]                       invokeRestart <- base::invokeRestart
[16:11:13.031]                       is.null <- base::is.null
[16:11:13.031]                       muffled <- FALSE
[16:11:13.031]                       if (inherits(cond, "message")) {
[16:11:13.031]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:13.031]                         if (muffled) 
[16:11:13.031]                           invokeRestart("muffleMessage")
[16:11:13.031]                       }
[16:11:13.031]                       else if (inherits(cond, "warning")) {
[16:11:13.031]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:13.031]                         if (muffled) 
[16:11:13.031]                           invokeRestart("muffleWarning")
[16:11:13.031]                       }
[16:11:13.031]                       else if (inherits(cond, "condition")) {
[16:11:13.031]                         if (!is.null(pattern)) {
[16:11:13.031]                           computeRestarts <- base::computeRestarts
[16:11:13.031]                           grepl <- base::grepl
[16:11:13.031]                           restarts <- computeRestarts(cond)
[16:11:13.031]                           for (restart in restarts) {
[16:11:13.031]                             name <- restart$name
[16:11:13.031]                             if (is.null(name)) 
[16:11:13.031]                               next
[16:11:13.031]                             if (!grepl(pattern, name)) 
[16:11:13.031]                               next
[16:11:13.031]                             invokeRestart(restart)
[16:11:13.031]                             muffled <- TRUE
[16:11:13.031]                             break
[16:11:13.031]                           }
[16:11:13.031]                         }
[16:11:13.031]                       }
[16:11:13.031]                       invisible(muffled)
[16:11:13.031]                     }
[16:11:13.031]                     muffleCondition(cond, pattern = "^muffle")
[16:11:13.031]                   }
[16:11:13.031]                 }
[16:11:13.031]                 else {
[16:11:13.031]                   if (TRUE) {
[16:11:13.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:13.031]                     {
[16:11:13.031]                       inherits <- base::inherits
[16:11:13.031]                       invokeRestart <- base::invokeRestart
[16:11:13.031]                       is.null <- base::is.null
[16:11:13.031]                       muffled <- FALSE
[16:11:13.031]                       if (inherits(cond, "message")) {
[16:11:13.031]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:13.031]                         if (muffled) 
[16:11:13.031]                           invokeRestart("muffleMessage")
[16:11:13.031]                       }
[16:11:13.031]                       else if (inherits(cond, "warning")) {
[16:11:13.031]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:13.031]                         if (muffled) 
[16:11:13.031]                           invokeRestart("muffleWarning")
[16:11:13.031]                       }
[16:11:13.031]                       else if (inherits(cond, "condition")) {
[16:11:13.031]                         if (!is.null(pattern)) {
[16:11:13.031]                           computeRestarts <- base::computeRestarts
[16:11:13.031]                           grepl <- base::grepl
[16:11:13.031]                           restarts <- computeRestarts(cond)
[16:11:13.031]                           for (restart in restarts) {
[16:11:13.031]                             name <- restart$name
[16:11:13.031]                             if (is.null(name)) 
[16:11:13.031]                               next
[16:11:13.031]                             if (!grepl(pattern, name)) 
[16:11:13.031]                               next
[16:11:13.031]                             invokeRestart(restart)
[16:11:13.031]                             muffled <- TRUE
[16:11:13.031]                             break
[16:11:13.031]                           }
[16:11:13.031]                         }
[16:11:13.031]                       }
[16:11:13.031]                       invisible(muffled)
[16:11:13.031]                     }
[16:11:13.031]                     muffleCondition(cond, pattern = "^muffle")
[16:11:13.031]                   }
[16:11:13.031]                 }
[16:11:13.031]             }
[16:11:13.031]         }))
[16:11:13.031]     }, error = function(ex) {
[16:11:13.031]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:13.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:13.031]                 ...future.rng), started = ...future.startTime, 
[16:11:13.031]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:13.031]             version = "1.8"), class = "FutureResult")
[16:11:13.031]     }, finally = {
[16:11:13.031]         if (!identical(...future.workdir, getwd())) 
[16:11:13.031]             setwd(...future.workdir)
[16:11:13.031]         {
[16:11:13.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:13.031]                 ...future.oldOptions$nwarnings <- NULL
[16:11:13.031]             }
[16:11:13.031]             base::options(...future.oldOptions)
[16:11:13.031]             if (.Platform$OS.type == "windows") {
[16:11:13.031]                 old_names <- names(...future.oldEnvVars)
[16:11:13.031]                 envs <- base::Sys.getenv()
[16:11:13.031]                 names <- names(envs)
[16:11:13.031]                 common <- intersect(names, old_names)
[16:11:13.031]                 added <- setdiff(names, old_names)
[16:11:13.031]                 removed <- setdiff(old_names, names)
[16:11:13.031]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:13.031]                   envs[common]]
[16:11:13.031]                 NAMES <- toupper(changed)
[16:11:13.031]                 args <- list()
[16:11:13.031]                 for (kk in seq_along(NAMES)) {
[16:11:13.031]                   name <- changed[[kk]]
[16:11:13.031]                   NAME <- NAMES[[kk]]
[16:11:13.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:13.031]                     next
[16:11:13.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:13.031]                 }
[16:11:13.031]                 NAMES <- toupper(added)
[16:11:13.031]                 for (kk in seq_along(NAMES)) {
[16:11:13.031]                   name <- added[[kk]]
[16:11:13.031]                   NAME <- NAMES[[kk]]
[16:11:13.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:13.031]                     next
[16:11:13.031]                   args[[name]] <- ""
[16:11:13.031]                 }
[16:11:13.031]                 NAMES <- toupper(removed)
[16:11:13.031]                 for (kk in seq_along(NAMES)) {
[16:11:13.031]                   name <- removed[[kk]]
[16:11:13.031]                   NAME <- NAMES[[kk]]
[16:11:13.031]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:13.031]                     next
[16:11:13.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:13.031]                 }
[16:11:13.031]                 if (length(args) > 0) 
[16:11:13.031]                   base::do.call(base::Sys.setenv, args = args)
[16:11:13.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:13.031]             }
[16:11:13.031]             else {
[16:11:13.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:13.031]             }
[16:11:13.031]             {
[16:11:13.031]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:13.031]                   0L) {
[16:11:13.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:13.031]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:13.031]                   base::options(opts)
[16:11:13.031]                 }
[16:11:13.031]                 {
[16:11:13.031]                   {
[16:11:13.031]                     NULL
[16:11:13.031]                     RNGkind("Mersenne-Twister")
[16:11:13.031]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:13.031]                       inherits = FALSE)
[16:11:13.031]                   }
[16:11:13.031]                   options(future.plan = NULL)
[16:11:13.031]                   if (is.na(NA_character_)) 
[16:11:13.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:13.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:13.031]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:13.031]                   {
[16:11:13.031]                     future <- SequentialFuture(..., envir = envir)
[16:11:13.031]                     if (!future$lazy) 
[16:11:13.031]                       future <- run(future)
[16:11:13.031]                     invisible(future)
[16:11:13.031]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:13.031]                 }
[16:11:13.031]             }
[16:11:13.031]         }
[16:11:13.031]     })
[16:11:13.031]     if (FALSE) {
[16:11:13.031]         base::sink(type = "output", split = FALSE)
[16:11:13.031]         if (NA) {
[16:11:13.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:13.031]         }
[16:11:13.031]         else {
[16:11:13.031]             ...future.result["stdout"] <- base::list(NULL)
[16:11:13.031]         }
[16:11:13.031]         base::close(...future.stdout)
[16:11:13.031]         ...future.stdout <- NULL
[16:11:13.031]     }
[16:11:13.031]     ...future.result$conditions <- ...future.conditions
[16:11:13.031]     ...future.result$finished <- base::Sys.time()
[16:11:13.031]     ...future.result
[16:11:13.031] }
[16:11:13.033] assign_globals() ...
[16:11:13.033] List of 5
[16:11:13.033]  $ ...future.FUN            :function (x)  
[16:11:13.033]  $ future.call.arguments    : list()
[16:11:13.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:13.033]  $ ...future.elements_ii    :List of 2
[16:11:13.033]   ..$ : int 1
[16:11:13.033]   ..$ : int 0
[16:11:13.033]  $ ...future.seeds_ii       : NULL
[16:11:13.033]  $ ...future.globals.maxSize: NULL
[16:11:13.033]  - attr(*, "resolved")= logi FALSE
[16:11:13.033]  - attr(*, "total_size")= num 4720
[16:11:13.033]  - attr(*, "where")=List of 5
[16:11:13.033]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:13.033]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:13.033]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:13.033]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:13.033]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:13.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:13.033]  - attr(*, "already-done")= logi TRUE
[16:11:13.038] - reassign environment for ‘...future.FUN’
[16:11:13.038] - copied ‘...future.FUN’ to environment
[16:11:13.038] - copied ‘future.call.arguments’ to environment
[16:11:13.038] - copied ‘...future.elements_ii’ to environment
[16:11:13.038] - copied ‘...future.seeds_ii’ to environment
[16:11:13.039] - copied ‘...future.globals.maxSize’ to environment
[16:11:13.039] assign_globals() ... done
[16:11:13.039] plan(): Setting new future strategy stack:
[16:11:13.039] List of future strategies:
[16:11:13.039] 1. sequential:
[16:11:13.039]    - args: function (..., envir = parent.frame())
[16:11:13.039]    - tweaked: FALSE
[16:11:13.039]    - call: NULL
[16:11:13.039] plan(): nbrOfWorkers() = 1
[16:11:13.541] plan(): Setting new future strategy stack:
[16:11:13.541] List of future strategies:
[16:11:13.541] 1. sequential:
[16:11:13.541]    - args: function (..., envir = parent.frame())
[16:11:13.541]    - tweaked: FALSE
[16:11:13.541]    - call: plan(strategy)
[16:11:13.542] plan(): nbrOfWorkers() = 1
[16:11:13.542] SequentialFuture started (and completed)
[16:11:13.542] - Launch lazy future ... done
[16:11:13.542] run() for ‘SequentialFuture’ ... done
[16:11:13.542] Created future:
[16:11:13.542] SequentialFuture:
[16:11:13.542] Label: ‘future_lapply-1’
[16:11:13.542] Expression:
[16:11:13.542] {
[16:11:13.542]     do.call(function(...) {
[16:11:13.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:13.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:13.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:13.542]             on.exit(options(oopts), add = TRUE)
[16:11:13.542]         }
[16:11:13.542]         {
[16:11:13.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:13.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:13.542]                 ...future.FUN(...future.X_jj, ...)
[16:11:13.542]             })
[16:11:13.542]         }
[16:11:13.542]     }, args = future.call.arguments)
[16:11:13.542] }
[16:11:13.542] Lazy evaluation: FALSE
[16:11:13.542] Asynchronous evaluation: FALSE
[16:11:13.542] Local evaluation: TRUE
[16:11:13.542] Environment: R_GlobalEnv
[16:11:13.542] Capture standard output: NA
[16:11:13.542] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:13.542] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:13.542] Packages: <none>
[16:11:13.542] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:13.542] Resolved: TRUE
[16:11:13.542] Value: 112 bytes of class ‘list’
[16:11:13.542] Early signaling: FALSE
[16:11:13.542] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:13.542] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:13.543] Chunk #1 of 1 ... DONE
[16:11:13.544] Launching 1 futures (chunks) ... DONE
[16:11:13.544] Resolving 1 futures (chunks) ...
[16:11:13.544] resolve() on list ...
[16:11:13.544]  recursive: 0
[16:11:13.544]  length: 1
[16:11:13.544] 
[16:11:13.544] resolved() for ‘SequentialFuture’ ...
[16:11:13.544] - state: ‘finished’
[16:11:13.544] - run: TRUE
[16:11:13.544] - result: ‘FutureResult’
[16:11:13.545] resolved() for ‘SequentialFuture’ ... done
[16:11:13.545] Future #1
[16:11:13.545] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:13.545] - nx: 1
[16:11:13.545] - relay: TRUE
[16:11:13.545] - stdout: TRUE
[16:11:13.545] - signal: TRUE
[16:11:13.545] - resignal: FALSE
[16:11:13.545] - force: TRUE
[16:11:13.545] - relayed: [n=1] FALSE
[16:11:13.546] - queued futures: [n=1] FALSE
[16:11:13.546]  - until=1
[16:11:13.546]  - relaying element #1
[16:11:13.546] - relayed: [n=1] TRUE
[16:11:13.546] - queued futures: [n=1] TRUE
[16:11:13.546] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:13.546]  length: 0 (resolved future 1)
[16:11:13.548] Relaying remaining futures
[16:11:13.548] signalConditionsASAP(NULL, pos=0) ...
[16:11:13.548] - nx: 1
[16:11:13.548] - relay: TRUE
[16:11:13.548] - stdout: TRUE
[16:11:13.548] - signal: TRUE
[16:11:13.548] - resignal: FALSE
[16:11:13.549] - force: TRUE
[16:11:13.549] - relayed: [n=1] TRUE
[16:11:13.549] - queued futures: [n=1] TRUE
 - flush all
[16:11:13.549] - relayed: [n=1] TRUE
[16:11:13.549] - queued futures: [n=1] TRUE
[16:11:13.549] signalConditionsASAP(NULL, pos=0) ... done
[16:11:13.549] resolve() on list ... DONE
[16:11:13.549]  - Number of value chunks collected: 1
[16:11:13.549] Resolving 1 futures (chunks) ... DONE
[16:11:13.549] Reducing values from 1 chunks ...
[16:11:13.550]  - Number of values collected after concatenation: 2
[16:11:13.550]  - Number of values expected: 2
[16:11:13.550] Reducing values from 1 chunks ... DONE
[16:11:13.550] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:11:13.550] future_mapply() ...
[16:11:13.550] Number of chunks: 1
[16:11:13.550] getGlobalsAndPackagesXApply() ...
[16:11:13.551]  - future.globals: TRUE
[16:11:13.551] getGlobalsAndPackages() ...
[16:11:13.551] Searching for globals...
[16:11:13.552] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:13.553] Searching for globals ... DONE
[16:11:13.553] Resolving globals: FALSE
[16:11:13.553] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:13.553] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:13.554] - globals: [1] ‘FUN’
[16:11:13.554] 
[16:11:13.554] getGlobalsAndPackages() ... DONE
[16:11:13.554]  - globals found/used: [n=1] ‘FUN’
[16:11:13.554]  - needed namespaces: [n=0] 
[16:11:13.554] Finding globals ... DONE
[16:11:13.554] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:13.554] List of 2
[16:11:13.554]  $ ...future.FUN:function (x, y)  
[16:11:13.554]  $ MoreArgs     : NULL
[16:11:13.554]  - attr(*, "where")=List of 2
[16:11:13.554]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:13.554]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:13.554]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:13.554]  - attr(*, "resolved")= logi FALSE
[16:11:13.554]  - attr(*, "total_size")= num NA
[16:11:13.557] Packages to be attached in all futures: [n=0] 
[16:11:13.557] getGlobalsAndPackagesXApply() ... DONE
[16:11:13.557] Number of futures (= number of chunks): 1
[16:11:13.557] Launching 1 futures (chunks) ...
[16:11:13.557] Chunk #1 of 1 ...
[16:11:13.558]  - Finding globals in '...' for chunk #1 ...
[16:11:13.558] getGlobalsAndPackages() ...
[16:11:13.558] Searching for globals...
[16:11:13.558] 
[16:11:13.558] Searching for globals ... DONE
[16:11:13.558] - globals: [0] <none>
[16:11:13.558] getGlobalsAndPackages() ... DONE
[16:11:13.558]    + additional globals found: [n=0] 
[16:11:13.558]    + additional namespaces needed: [n=0] 
[16:11:13.559]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:13.559]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:13.559]  - seeds: <none>
[16:11:13.559] getGlobalsAndPackages() ...
[16:11:13.559] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:13.559] Resolving globals: FALSE
[16:11:13.560] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:13.560] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:13.560] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:13.560] 
[16:11:13.560] getGlobalsAndPackages() ... DONE
[16:11:13.561] run() for ‘Future’ ...
[16:11:13.561] - state: ‘created’
[16:11:13.561] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:13.561] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:13.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:13.561]   - Field: ‘label’
[16:11:13.562]   - Field: ‘local’
[16:11:13.562]   - Field: ‘owner’
[16:11:13.562]   - Field: ‘envir’
[16:11:13.562]   - Field: ‘packages’
[16:11:13.562]   - Field: ‘gc’
[16:11:13.562]   - Field: ‘conditions’
[16:11:13.562]   - Field: ‘expr’
[16:11:13.562]   - Field: ‘uuid’
[16:11:13.562]   - Field: ‘seed’
[16:11:13.562]   - Field: ‘version’
[16:11:13.563]   - Field: ‘result’
[16:11:13.563]   - Field: ‘asynchronous’
[16:11:13.563]   - Field: ‘calls’
[16:11:13.563]   - Field: ‘globals’
[16:11:13.563]   - Field: ‘stdout’
[16:11:13.563]   - Field: ‘earlySignal’
[16:11:13.563]   - Field: ‘lazy’
[16:11:13.563]   - Field: ‘state’
[16:11:13.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:13.563] - Launch lazy future ...
[16:11:13.564] Packages needed by the future expression (n = 0): <none>
[16:11:13.564] Packages needed by future strategies (n = 0): <none>
[16:11:13.564] {
[16:11:13.564]     {
[16:11:13.564]         {
[16:11:13.564]             ...future.startTime <- base::Sys.time()
[16:11:13.564]             {
[16:11:13.564]                 {
[16:11:13.564]                   {
[16:11:13.564]                     base::local({
[16:11:13.564]                       has_future <- base::requireNamespace("future", 
[16:11:13.564]                         quietly = TRUE)
[16:11:13.564]                       if (has_future) {
[16:11:13.564]                         ns <- base::getNamespace("future")
[16:11:13.564]                         version <- ns[[".package"]][["version"]]
[16:11:13.564]                         if (is.null(version)) 
[16:11:13.564]                           version <- utils::packageVersion("future")
[16:11:13.564]                       }
[16:11:13.564]                       else {
[16:11:13.564]                         version <- NULL
[16:11:13.564]                       }
[16:11:13.564]                       if (!has_future || version < "1.8.0") {
[16:11:13.564]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:13.564]                           "", base::R.version$version.string), 
[16:11:13.564]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:13.564]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:13.564]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:13.564]                             "release", "version")], collapse = " "), 
[16:11:13.564]                           hostname = base::Sys.info()[["nodename"]])
[16:11:13.564]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:13.564]                           info)
[16:11:13.564]                         info <- base::paste(info, collapse = "; ")
[16:11:13.564]                         if (!has_future) {
[16:11:13.564]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:13.564]                             info)
[16:11:13.564]                         }
[16:11:13.564]                         else {
[16:11:13.564]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:13.564]                             info, version)
[16:11:13.564]                         }
[16:11:13.564]                         base::stop(msg)
[16:11:13.564]                       }
[16:11:13.564]                     })
[16:11:13.564]                   }
[16:11:13.564]                   options(future.plan = NULL)
[16:11:13.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:13.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:13.564]                 }
[16:11:13.564]                 ...future.workdir <- getwd()
[16:11:13.564]             }
[16:11:13.564]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:13.564]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:13.564]         }
[16:11:13.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:13.564]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:13.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:13.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:13.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:13.564]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:13.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:13.564]             base::names(...future.oldOptions))
[16:11:13.564]     }
[16:11:13.564]     if (FALSE) {
[16:11:13.564]     }
[16:11:13.564]     else {
[16:11:13.564]         if (FALSE) {
[16:11:13.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:13.564]                 open = "w")
[16:11:13.564]         }
[16:11:13.564]         else {
[16:11:13.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:13.564]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:13.564]         }
[16:11:13.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:13.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:13.564]             base::sink(type = "output", split = FALSE)
[16:11:13.564]             base::close(...future.stdout)
[16:11:13.564]         }, add = TRUE)
[16:11:13.564]     }
[16:11:13.564]     ...future.frame <- base::sys.nframe()
[16:11:13.564]     ...future.conditions <- base::list()
[16:11:13.564]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:13.564]     if (FALSE) {
[16:11:13.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:13.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:13.564]     }
[16:11:13.564]     ...future.result <- base::tryCatch({
[16:11:13.564]         base::withCallingHandlers({
[16:11:13.564]             ...future.value <- base::withVisible(base::local({
[16:11:13.564]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:13.564]                 if (!identical(...future.globals.maxSize.org, 
[16:11:13.564]                   ...future.globals.maxSize)) {
[16:11:13.564]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:13.564]                   on.exit(options(oopts), add = TRUE)
[16:11:13.564]                 }
[16:11:13.564]                 {
[16:11:13.564]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:13.564]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:13.564]                     USE.NAMES = FALSE)
[16:11:13.564]                   do.call(mapply, args = args)
[16:11:13.564]                 }
[16:11:13.564]             }))
[16:11:13.564]             future::FutureResult(value = ...future.value$value, 
[16:11:13.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:13.564]                   ...future.rng), globalenv = if (FALSE) 
[16:11:13.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:13.564]                     ...future.globalenv.names))
[16:11:13.564]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:13.564]         }, condition = base::local({
[16:11:13.564]             c <- base::c
[16:11:13.564]             inherits <- base::inherits
[16:11:13.564]             invokeRestart <- base::invokeRestart
[16:11:13.564]             length <- base::length
[16:11:13.564]             list <- base::list
[16:11:13.564]             seq.int <- base::seq.int
[16:11:13.564]             signalCondition <- base::signalCondition
[16:11:13.564]             sys.calls <- base::sys.calls
[16:11:13.564]             `[[` <- base::`[[`
[16:11:13.564]             `+` <- base::`+`
[16:11:13.564]             `<<-` <- base::`<<-`
[16:11:13.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:13.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:13.564]                   3L)]
[16:11:13.564]             }
[16:11:13.564]             function(cond) {
[16:11:13.564]                 is_error <- inherits(cond, "error")
[16:11:13.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:13.564]                   NULL)
[16:11:13.564]                 if (is_error) {
[16:11:13.564]                   sessionInformation <- function() {
[16:11:13.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:13.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:13.564]                       search = base::search(), system = base::Sys.info())
[16:11:13.564]                   }
[16:11:13.564]                   ...future.conditions[[length(...future.conditions) + 
[16:11:13.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:13.564]                     cond$call), session = sessionInformation(), 
[16:11:13.564]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:13.564]                   signalCondition(cond)
[16:11:13.564]                 }
[16:11:13.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:13.564]                 "immediateCondition"))) {
[16:11:13.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:13.564]                   ...future.conditions[[length(...future.conditions) + 
[16:11:13.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:13.564]                   if (TRUE && !signal) {
[16:11:13.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:13.564]                     {
[16:11:13.564]                       inherits <- base::inherits
[16:11:13.564]                       invokeRestart <- base::invokeRestart
[16:11:13.564]                       is.null <- base::is.null
[16:11:13.564]                       muffled <- FALSE
[16:11:13.564]                       if (inherits(cond, "message")) {
[16:11:13.564]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:13.564]                         if (muffled) 
[16:11:13.564]                           invokeRestart("muffleMessage")
[16:11:13.564]                       }
[16:11:13.564]                       else if (inherits(cond, "warning")) {
[16:11:13.564]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:13.564]                         if (muffled) 
[16:11:13.564]                           invokeRestart("muffleWarning")
[16:11:13.564]                       }
[16:11:13.564]                       else if (inherits(cond, "condition")) {
[16:11:13.564]                         if (!is.null(pattern)) {
[16:11:13.564]                           computeRestarts <- base::computeRestarts
[16:11:13.564]                           grepl <- base::grepl
[16:11:13.564]                           restarts <- computeRestarts(cond)
[16:11:13.564]                           for (restart in restarts) {
[16:11:13.564]                             name <- restart$name
[16:11:13.564]                             if (is.null(name)) 
[16:11:13.564]                               next
[16:11:13.564]                             if (!grepl(pattern, name)) 
[16:11:13.564]                               next
[16:11:13.564]                             invokeRestart(restart)
[16:11:13.564]                             muffled <- TRUE
[16:11:13.564]                             break
[16:11:13.564]                           }
[16:11:13.564]                         }
[16:11:13.564]                       }
[16:11:13.564]                       invisible(muffled)
[16:11:13.564]                     }
[16:11:13.564]                     muffleCondition(cond, pattern = "^muffle")
[16:11:13.564]                   }
[16:11:13.564]                 }
[16:11:13.564]                 else {
[16:11:13.564]                   if (TRUE) {
[16:11:13.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:13.564]                     {
[16:11:13.564]                       inherits <- base::inherits
[16:11:13.564]                       invokeRestart <- base::invokeRestart
[16:11:13.564]                       is.null <- base::is.null
[16:11:13.564]                       muffled <- FALSE
[16:11:13.564]                       if (inherits(cond, "message")) {
[16:11:13.564]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:13.564]                         if (muffled) 
[16:11:13.564]                           invokeRestart("muffleMessage")
[16:11:13.564]                       }
[16:11:13.564]                       else if (inherits(cond, "warning")) {
[16:11:13.564]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:13.564]                         if (muffled) 
[16:11:13.564]                           invokeRestart("muffleWarning")
[16:11:13.564]                       }
[16:11:13.564]                       else if (inherits(cond, "condition")) {
[16:11:13.564]                         if (!is.null(pattern)) {
[16:11:13.564]                           computeRestarts <- base::computeRestarts
[16:11:13.564]                           grepl <- base::grepl
[16:11:13.564]                           restarts <- computeRestarts(cond)
[16:11:13.564]                           for (restart in restarts) {
[16:11:13.564]                             name <- restart$name
[16:11:13.564]                             if (is.null(name)) 
[16:11:13.564]                               next
[16:11:13.564]                             if (!grepl(pattern, name)) 
[16:11:13.564]                               next
[16:11:13.564]                             invokeRestart(restart)
[16:11:13.564]                             muffled <- TRUE
[16:11:13.564]                             break
[16:11:13.564]                           }
[16:11:13.564]                         }
[16:11:13.564]                       }
[16:11:13.564]                       invisible(muffled)
[16:11:13.564]                     }
[16:11:13.564]                     muffleCondition(cond, pattern = "^muffle")
[16:11:13.564]                   }
[16:11:13.564]                 }
[16:11:13.564]             }
[16:11:13.564]         }))
[16:11:13.564]     }, error = function(ex) {
[16:11:13.564]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:13.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:13.564]                 ...future.rng), started = ...future.startTime, 
[16:11:13.564]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:13.564]             version = "1.8"), class = "FutureResult")
[16:11:13.564]     }, finally = {
[16:11:13.564]         if (!identical(...future.workdir, getwd())) 
[16:11:13.564]             setwd(...future.workdir)
[16:11:13.564]         {
[16:11:13.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:13.564]                 ...future.oldOptions$nwarnings <- NULL
[16:11:13.564]             }
[16:11:13.564]             base::options(...future.oldOptions)
[16:11:13.564]             if (.Platform$OS.type == "windows") {
[16:11:13.564]                 old_names <- names(...future.oldEnvVars)
[16:11:13.564]                 envs <- base::Sys.getenv()
[16:11:13.564]                 names <- names(envs)
[16:11:13.564]                 common <- intersect(names, old_names)
[16:11:13.564]                 added <- setdiff(names, old_names)
[16:11:13.564]                 removed <- setdiff(old_names, names)
[16:11:13.564]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:13.564]                   envs[common]]
[16:11:13.564]                 NAMES <- toupper(changed)
[16:11:13.564]                 args <- list()
[16:11:13.564]                 for (kk in seq_along(NAMES)) {
[16:11:13.564]                   name <- changed[[kk]]
[16:11:13.564]                   NAME <- NAMES[[kk]]
[16:11:13.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:13.564]                     next
[16:11:13.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:13.564]                 }
[16:11:13.564]                 NAMES <- toupper(added)
[16:11:13.564]                 for (kk in seq_along(NAMES)) {
[16:11:13.564]                   name <- added[[kk]]
[16:11:13.564]                   NAME <- NAMES[[kk]]
[16:11:13.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:13.564]                     next
[16:11:13.564]                   args[[name]] <- ""
[16:11:13.564]                 }
[16:11:13.564]                 NAMES <- toupper(removed)
[16:11:13.564]                 for (kk in seq_along(NAMES)) {
[16:11:13.564]                   name <- removed[[kk]]
[16:11:13.564]                   NAME <- NAMES[[kk]]
[16:11:13.564]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:13.564]                     next
[16:11:13.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:13.564]                 }
[16:11:13.564]                 if (length(args) > 0) 
[16:11:13.564]                   base::do.call(base::Sys.setenv, args = args)
[16:11:13.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:13.564]             }
[16:11:13.564]             else {
[16:11:13.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:13.564]             }
[16:11:13.564]             {
[16:11:13.564]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:13.564]                   0L) {
[16:11:13.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:13.564]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:13.564]                   base::options(opts)
[16:11:13.564]                 }
[16:11:13.564]                 {
[16:11:13.564]                   {
[16:11:13.564]                     NULL
[16:11:13.564]                     RNGkind("Mersenne-Twister")
[16:11:13.564]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:13.564]                       inherits = FALSE)
[16:11:13.564]                   }
[16:11:13.564]                   options(future.plan = NULL)
[16:11:13.564]                   if (is.na(NA_character_)) 
[16:11:13.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:13.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:13.564]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:13.564]                   {
[16:11:13.564]                     future <- SequentialFuture(..., envir = envir)
[16:11:13.564]                     if (!future$lazy) 
[16:11:13.564]                       future <- run(future)
[16:11:13.564]                     invisible(future)
[16:11:13.564]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:13.564]                 }
[16:11:13.564]             }
[16:11:13.564]         }
[16:11:13.564]     })
[16:11:13.564]     if (TRUE) {
[16:11:13.564]         base::sink(type = "output", split = FALSE)
[16:11:13.564]         if (FALSE) {
[16:11:13.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:13.564]         }
[16:11:13.564]         else {
[16:11:13.564]             ...future.result["stdout"] <- base::list(NULL)
[16:11:13.564]         }
[16:11:13.564]         base::close(...future.stdout)
[16:11:13.564]         ...future.stdout <- NULL
[16:11:13.564]     }
[16:11:13.564]     ...future.result$conditions <- ...future.conditions
[16:11:13.564]     ...future.result$finished <- base::Sys.time()
[16:11:13.564]     ...future.result
[16:11:13.564] }
[16:11:13.566] assign_globals() ...
[16:11:13.566] List of 5
[16:11:13.566]  $ ...future.FUN            :function (x, y)  
[16:11:13.566]  $ MoreArgs                 : NULL
[16:11:13.566]  $ ...future.elements_ii    :List of 2
[16:11:13.566]   ..$ :List of 2
[16:11:13.566]   .. ..$ : int 1
[16:11:13.566]   .. ..$ : int 0
[16:11:13.566]   ..$ :List of 2
[16:11:13.566]   .. ..$ : int 0
[16:11:13.566]   .. ..$ : int 1
[16:11:13.566]  $ ...future.seeds_ii       : NULL
[16:11:13.566]  $ ...future.globals.maxSize: NULL
[16:11:13.566]  - attr(*, "resolved")= logi FALSE
[16:11:13.566]  - attr(*, "total_size")= num 6480
[16:11:13.566]  - attr(*, "where")=List of 5
[16:11:13.566]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:13.566]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:13.566]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:13.566]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:13.566]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:13.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:13.566]  - attr(*, "already-done")= logi TRUE
[16:11:13.572] - reassign environment for ‘...future.FUN’
[16:11:13.572] - copied ‘...future.FUN’ to environment
[16:11:13.572] - copied ‘MoreArgs’ to environment
[16:11:13.572] - copied ‘...future.elements_ii’ to environment
[16:11:13.574] - copied ‘...future.seeds_ii’ to environment
[16:11:13.574] - copied ‘...future.globals.maxSize’ to environment
[16:11:13.574] assign_globals() ... done
[16:11:13.574] plan(): Setting new future strategy stack:
[16:11:13.574] List of future strategies:
[16:11:13.574] 1. sequential:
[16:11:13.574]    - args: function (..., envir = parent.frame())
[16:11:13.574]    - tweaked: FALSE
[16:11:13.574]    - call: NULL
[16:11:13.575] plan(): nbrOfWorkers() = 1
[16:11:14.077] plan(): Setting new future strategy stack:
[16:11:14.077] List of future strategies:
[16:11:14.077] 1. sequential:
[16:11:14.077]    - args: function (..., envir = parent.frame())
[16:11:14.077]    - tweaked: FALSE
[16:11:14.077]    - call: plan(strategy)
[16:11:14.077] plan(): nbrOfWorkers() = 1
[16:11:14.077] SequentialFuture started (and completed)
[16:11:14.078] - Launch lazy future ... done
[16:11:14.078] run() for ‘SequentialFuture’ ... done
[16:11:14.078] Created future:
[16:11:14.078] SequentialFuture:
[16:11:14.078] Label: ‘future_mapply-1’
[16:11:14.078] Expression:
[16:11:14.078] {
[16:11:14.078]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:14.078]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:14.078]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:14.078]         on.exit(options(oopts), add = TRUE)
[16:11:14.078]     }
[16:11:14.078]     {
[16:11:14.078]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:14.078]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:14.078]         do.call(mapply, args = args)
[16:11:14.078]     }
[16:11:14.078] }
[16:11:14.078] Lazy evaluation: FALSE
[16:11:14.078] Asynchronous evaluation: FALSE
[16:11:14.078] Local evaluation: TRUE
[16:11:14.078] Environment: R_GlobalEnv
[16:11:14.078] Capture standard output: FALSE
[16:11:14.078] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:14.078] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:14.078] Packages: <none>
[16:11:14.078] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:14.078] Resolved: TRUE
[16:11:14.078] Value: 224 bytes of class ‘list’
[16:11:14.078] Early signaling: FALSE
[16:11:14.078] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:14.078] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:14.079] Chunk #1 of 1 ... DONE
[16:11:14.079] Launching 1 futures (chunks) ... DONE
[16:11:14.079] Resolving 1 futures (chunks) ...
[16:11:14.079] resolve() on list ...
[16:11:14.079]  recursive: 0
[16:11:14.079]  length: 1
[16:11:14.079] 
[16:11:14.080] resolved() for ‘SequentialFuture’ ...
[16:11:14.080] - state: ‘finished’
[16:11:14.080] - run: TRUE
[16:11:14.080] - result: ‘FutureResult’
[16:11:14.080] resolved() for ‘SequentialFuture’ ... done
[16:11:14.080] Future #1
[16:11:14.080] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:14.080] - nx: 1
[16:11:14.080] - relay: TRUE
[16:11:14.081] - stdout: TRUE
[16:11:14.081] - signal: TRUE
[16:11:14.081] - resignal: FALSE
[16:11:14.081] - force: TRUE
[16:11:14.081] - relayed: [n=1] FALSE
[16:11:14.081] - queued futures: [n=1] FALSE
[16:11:14.081]  - until=1
[16:11:14.081]  - relaying element #1
[16:11:14.081] - relayed: [n=1] TRUE
[16:11:14.081] - queued futures: [n=1] TRUE
[16:11:14.082] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:14.082]  length: 0 (resolved future 1)
[16:11:14.082] Relaying remaining futures
[16:11:14.082] signalConditionsASAP(NULL, pos=0) ...
[16:11:14.082] - nx: 1
[16:11:14.082] - relay: TRUE
[16:11:14.082] - stdout: TRUE
[16:11:14.082] - signal: TRUE
[16:11:14.082] - resignal: FALSE
[16:11:14.082] - force: TRUE
[16:11:14.082] - relayed: [n=1] TRUE
[16:11:14.082] - queued futures: [n=1] TRUE
 - flush all
[16:11:14.083] - relayed: [n=1] TRUE
[16:11:14.083] - queued futures: [n=1] TRUE
[16:11:14.083] signalConditionsASAP(NULL, pos=0) ... done
[16:11:14.083] resolve() on list ... DONE
[16:11:14.083]  - Number of value chunks collected: 1
[16:11:14.083] Resolving 1 futures (chunks) ... DONE
[16:11:14.083] Reducing values from 1 chunks ...
[16:11:14.083]  - Number of values collected after concatenation: 2
[16:11:14.083]  - Number of values expected: 2
[16:11:14.083] Reducing values from 1 chunks ... DONE
[16:11:14.084] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:11:14.084] future_mapply() ...
[16:11:14.084] Number of chunks: 1
[16:11:14.084] getGlobalsAndPackagesXApply() ...
[16:11:14.084]  - future.globals: TRUE
[16:11:14.084] getGlobalsAndPackages() ...
[16:11:14.085] Searching for globals...
[16:11:14.086] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:14.086] Searching for globals ... DONE
[16:11:14.086] Resolving globals: FALSE
[16:11:14.087] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:14.087] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:14.087] - globals: [1] ‘FUN’
[16:11:14.087] 
[16:11:14.087] getGlobalsAndPackages() ... DONE
[16:11:14.087]  - globals found/used: [n=1] ‘FUN’
[16:11:14.088]  - needed namespaces: [n=0] 
[16:11:14.088] Finding globals ... DONE
[16:11:14.088] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:14.088] List of 2
[16:11:14.088]  $ ...future.FUN:function (x, y)  
[16:11:14.088]  $ MoreArgs     : NULL
[16:11:14.088]  - attr(*, "where")=List of 2
[16:11:14.088]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:14.088]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:14.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:14.088]  - attr(*, "resolved")= logi FALSE
[16:11:14.088]  - attr(*, "total_size")= num NA
[16:11:14.091] Packages to be attached in all futures: [n=0] 
[16:11:14.091] getGlobalsAndPackagesXApply() ... DONE
[16:11:14.091] Number of futures (= number of chunks): 1
[16:11:14.091] Launching 1 futures (chunks) ...
[16:11:14.091] Chunk #1 of 1 ...
[16:11:14.091]  - Finding globals in '...' for chunk #1 ...
[16:11:14.091] getGlobalsAndPackages() ...
[16:11:14.091] Searching for globals...
[16:11:14.092] 
[16:11:14.092] Searching for globals ... DONE
[16:11:14.092] - globals: [0] <none>
[16:11:14.092] getGlobalsAndPackages() ... DONE
[16:11:14.092]    + additional globals found: [n=0] 
[16:11:14.092]    + additional namespaces needed: [n=0] 
[16:11:14.092]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:14.092]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:14.092]  - seeds: <none>
[16:11:14.093] getGlobalsAndPackages() ...
[16:11:14.093] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:14.093] Resolving globals: FALSE
[16:11:14.093] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:14.094] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:14.094] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:14.094] 
[16:11:14.094] getGlobalsAndPackages() ... DONE
[16:11:14.094] run() for ‘Future’ ...
[16:11:14.094] - state: ‘created’
[16:11:14.094] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:14.095] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:14.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:14.095]   - Field: ‘label’
[16:11:14.095]   - Field: ‘local’
[16:11:14.095]   - Field: ‘owner’
[16:11:14.095]   - Field: ‘envir’
[16:11:14.095]   - Field: ‘packages’
[16:11:14.095]   - Field: ‘gc’
[16:11:14.096]   - Field: ‘conditions’
[16:11:14.096]   - Field: ‘expr’
[16:11:14.096]   - Field: ‘uuid’
[16:11:14.096]   - Field: ‘seed’
[16:11:14.096]   - Field: ‘version’
[16:11:14.096]   - Field: ‘result’
[16:11:14.096]   - Field: ‘asynchronous’
[16:11:14.096]   - Field: ‘calls’
[16:11:14.096]   - Field: ‘globals’
[16:11:14.096]   - Field: ‘stdout’
[16:11:14.096]   - Field: ‘earlySignal’
[16:11:14.097]   - Field: ‘lazy’
[16:11:14.097]   - Field: ‘state’
[16:11:14.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:14.097] - Launch lazy future ...
[16:11:14.097] Packages needed by the future expression (n = 0): <none>
[16:11:14.097] Packages needed by future strategies (n = 0): <none>
[16:11:14.098] {
[16:11:14.098]     {
[16:11:14.098]         {
[16:11:14.098]             ...future.startTime <- base::Sys.time()
[16:11:14.098]             {
[16:11:14.098]                 {
[16:11:14.098]                   {
[16:11:14.098]                     base::local({
[16:11:14.098]                       has_future <- base::requireNamespace("future", 
[16:11:14.098]                         quietly = TRUE)
[16:11:14.098]                       if (has_future) {
[16:11:14.098]                         ns <- base::getNamespace("future")
[16:11:14.098]                         version <- ns[[".package"]][["version"]]
[16:11:14.098]                         if (is.null(version)) 
[16:11:14.098]                           version <- utils::packageVersion("future")
[16:11:14.098]                       }
[16:11:14.098]                       else {
[16:11:14.098]                         version <- NULL
[16:11:14.098]                       }
[16:11:14.098]                       if (!has_future || version < "1.8.0") {
[16:11:14.098]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:14.098]                           "", base::R.version$version.string), 
[16:11:14.098]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:14.098]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:14.098]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:14.098]                             "release", "version")], collapse = " "), 
[16:11:14.098]                           hostname = base::Sys.info()[["nodename"]])
[16:11:14.098]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:14.098]                           info)
[16:11:14.098]                         info <- base::paste(info, collapse = "; ")
[16:11:14.098]                         if (!has_future) {
[16:11:14.098]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:14.098]                             info)
[16:11:14.098]                         }
[16:11:14.098]                         else {
[16:11:14.098]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:14.098]                             info, version)
[16:11:14.098]                         }
[16:11:14.098]                         base::stop(msg)
[16:11:14.098]                       }
[16:11:14.098]                     })
[16:11:14.098]                   }
[16:11:14.098]                   options(future.plan = NULL)
[16:11:14.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:14.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:14.098]                 }
[16:11:14.098]                 ...future.workdir <- getwd()
[16:11:14.098]             }
[16:11:14.098]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:14.098]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:14.098]         }
[16:11:14.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:14.098]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:14.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:14.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:14.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:14.098]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:14.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:14.098]             base::names(...future.oldOptions))
[16:11:14.098]     }
[16:11:14.098]     if (FALSE) {
[16:11:14.098]     }
[16:11:14.098]     else {
[16:11:14.098]         if (TRUE) {
[16:11:14.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:14.098]                 open = "w")
[16:11:14.098]         }
[16:11:14.098]         else {
[16:11:14.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:14.098]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:14.098]         }
[16:11:14.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:14.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:14.098]             base::sink(type = "output", split = FALSE)
[16:11:14.098]             base::close(...future.stdout)
[16:11:14.098]         }, add = TRUE)
[16:11:14.098]     }
[16:11:14.098]     ...future.frame <- base::sys.nframe()
[16:11:14.098]     ...future.conditions <- base::list()
[16:11:14.098]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:14.098]     if (FALSE) {
[16:11:14.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:14.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:14.098]     }
[16:11:14.098]     ...future.result <- base::tryCatch({
[16:11:14.098]         base::withCallingHandlers({
[16:11:14.098]             ...future.value <- base::withVisible(base::local({
[16:11:14.098]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:14.098]                 if (!identical(...future.globals.maxSize.org, 
[16:11:14.098]                   ...future.globals.maxSize)) {
[16:11:14.098]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:14.098]                   on.exit(options(oopts), add = TRUE)
[16:11:14.098]                 }
[16:11:14.098]                 {
[16:11:14.098]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:14.098]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:14.098]                     USE.NAMES = FALSE)
[16:11:14.098]                   do.call(mapply, args = args)
[16:11:14.098]                 }
[16:11:14.098]             }))
[16:11:14.098]             future::FutureResult(value = ...future.value$value, 
[16:11:14.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:14.098]                   ...future.rng), globalenv = if (FALSE) 
[16:11:14.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:14.098]                     ...future.globalenv.names))
[16:11:14.098]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:14.098]         }, condition = base::local({
[16:11:14.098]             c <- base::c
[16:11:14.098]             inherits <- base::inherits
[16:11:14.098]             invokeRestart <- base::invokeRestart
[16:11:14.098]             length <- base::length
[16:11:14.098]             list <- base::list
[16:11:14.098]             seq.int <- base::seq.int
[16:11:14.098]             signalCondition <- base::signalCondition
[16:11:14.098]             sys.calls <- base::sys.calls
[16:11:14.098]             `[[` <- base::`[[`
[16:11:14.098]             `+` <- base::`+`
[16:11:14.098]             `<<-` <- base::`<<-`
[16:11:14.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:14.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:14.098]                   3L)]
[16:11:14.098]             }
[16:11:14.098]             function(cond) {
[16:11:14.098]                 is_error <- inherits(cond, "error")
[16:11:14.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:14.098]                   NULL)
[16:11:14.098]                 if (is_error) {
[16:11:14.098]                   sessionInformation <- function() {
[16:11:14.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:14.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:14.098]                       search = base::search(), system = base::Sys.info())
[16:11:14.098]                   }
[16:11:14.098]                   ...future.conditions[[length(...future.conditions) + 
[16:11:14.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:14.098]                     cond$call), session = sessionInformation(), 
[16:11:14.098]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:14.098]                   signalCondition(cond)
[16:11:14.098]                 }
[16:11:14.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:14.098]                 "immediateCondition"))) {
[16:11:14.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:14.098]                   ...future.conditions[[length(...future.conditions) + 
[16:11:14.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:14.098]                   if (TRUE && !signal) {
[16:11:14.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:14.098]                     {
[16:11:14.098]                       inherits <- base::inherits
[16:11:14.098]                       invokeRestart <- base::invokeRestart
[16:11:14.098]                       is.null <- base::is.null
[16:11:14.098]                       muffled <- FALSE
[16:11:14.098]                       if (inherits(cond, "message")) {
[16:11:14.098]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:14.098]                         if (muffled) 
[16:11:14.098]                           invokeRestart("muffleMessage")
[16:11:14.098]                       }
[16:11:14.098]                       else if (inherits(cond, "warning")) {
[16:11:14.098]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:14.098]                         if (muffled) 
[16:11:14.098]                           invokeRestart("muffleWarning")
[16:11:14.098]                       }
[16:11:14.098]                       else if (inherits(cond, "condition")) {
[16:11:14.098]                         if (!is.null(pattern)) {
[16:11:14.098]                           computeRestarts <- base::computeRestarts
[16:11:14.098]                           grepl <- base::grepl
[16:11:14.098]                           restarts <- computeRestarts(cond)
[16:11:14.098]                           for (restart in restarts) {
[16:11:14.098]                             name <- restart$name
[16:11:14.098]                             if (is.null(name)) 
[16:11:14.098]                               next
[16:11:14.098]                             if (!grepl(pattern, name)) 
[16:11:14.098]                               next
[16:11:14.098]                             invokeRestart(restart)
[16:11:14.098]                             muffled <- TRUE
[16:11:14.098]                             break
[16:11:14.098]                           }
[16:11:14.098]                         }
[16:11:14.098]                       }
[16:11:14.098]                       invisible(muffled)
[16:11:14.098]                     }
[16:11:14.098]                     muffleCondition(cond, pattern = "^muffle")
[16:11:14.098]                   }
[16:11:14.098]                 }
[16:11:14.098]                 else {
[16:11:14.098]                   if (TRUE) {
[16:11:14.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:14.098]                     {
[16:11:14.098]                       inherits <- base::inherits
[16:11:14.098]                       invokeRestart <- base::invokeRestart
[16:11:14.098]                       is.null <- base::is.null
[16:11:14.098]                       muffled <- FALSE
[16:11:14.098]                       if (inherits(cond, "message")) {
[16:11:14.098]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:14.098]                         if (muffled) 
[16:11:14.098]                           invokeRestart("muffleMessage")
[16:11:14.098]                       }
[16:11:14.098]                       else if (inherits(cond, "warning")) {
[16:11:14.098]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:14.098]                         if (muffled) 
[16:11:14.098]                           invokeRestart("muffleWarning")
[16:11:14.098]                       }
[16:11:14.098]                       else if (inherits(cond, "condition")) {
[16:11:14.098]                         if (!is.null(pattern)) {
[16:11:14.098]                           computeRestarts <- base::computeRestarts
[16:11:14.098]                           grepl <- base::grepl
[16:11:14.098]                           restarts <- computeRestarts(cond)
[16:11:14.098]                           for (restart in restarts) {
[16:11:14.098]                             name <- restart$name
[16:11:14.098]                             if (is.null(name)) 
[16:11:14.098]                               next
[16:11:14.098]                             if (!grepl(pattern, name)) 
[16:11:14.098]                               next
[16:11:14.098]                             invokeRestart(restart)
[16:11:14.098]                             muffled <- TRUE
[16:11:14.098]                             break
[16:11:14.098]                           }
[16:11:14.098]                         }
[16:11:14.098]                       }
[16:11:14.098]                       invisible(muffled)
[16:11:14.098]                     }
[16:11:14.098]                     muffleCondition(cond, pattern = "^muffle")
[16:11:14.098]                   }
[16:11:14.098]                 }
[16:11:14.098]             }
[16:11:14.098]         }))
[16:11:14.098]     }, error = function(ex) {
[16:11:14.098]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:14.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:14.098]                 ...future.rng), started = ...future.startTime, 
[16:11:14.098]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:14.098]             version = "1.8"), class = "FutureResult")
[16:11:14.098]     }, finally = {
[16:11:14.098]         if (!identical(...future.workdir, getwd())) 
[16:11:14.098]             setwd(...future.workdir)
[16:11:14.098]         {
[16:11:14.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:14.098]                 ...future.oldOptions$nwarnings <- NULL
[16:11:14.098]             }
[16:11:14.098]             base::options(...future.oldOptions)
[16:11:14.098]             if (.Platform$OS.type == "windows") {
[16:11:14.098]                 old_names <- names(...future.oldEnvVars)
[16:11:14.098]                 envs <- base::Sys.getenv()
[16:11:14.098]                 names <- names(envs)
[16:11:14.098]                 common <- intersect(names, old_names)
[16:11:14.098]                 added <- setdiff(names, old_names)
[16:11:14.098]                 removed <- setdiff(old_names, names)
[16:11:14.098]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:14.098]                   envs[common]]
[16:11:14.098]                 NAMES <- toupper(changed)
[16:11:14.098]                 args <- list()
[16:11:14.098]                 for (kk in seq_along(NAMES)) {
[16:11:14.098]                   name <- changed[[kk]]
[16:11:14.098]                   NAME <- NAMES[[kk]]
[16:11:14.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:14.098]                     next
[16:11:14.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:14.098]                 }
[16:11:14.098]                 NAMES <- toupper(added)
[16:11:14.098]                 for (kk in seq_along(NAMES)) {
[16:11:14.098]                   name <- added[[kk]]
[16:11:14.098]                   NAME <- NAMES[[kk]]
[16:11:14.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:14.098]                     next
[16:11:14.098]                   args[[name]] <- ""
[16:11:14.098]                 }
[16:11:14.098]                 NAMES <- toupper(removed)
[16:11:14.098]                 for (kk in seq_along(NAMES)) {
[16:11:14.098]                   name <- removed[[kk]]
[16:11:14.098]                   NAME <- NAMES[[kk]]
[16:11:14.098]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:14.098]                     next
[16:11:14.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:14.098]                 }
[16:11:14.098]                 if (length(args) > 0) 
[16:11:14.098]                   base::do.call(base::Sys.setenv, args = args)
[16:11:14.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:14.098]             }
[16:11:14.098]             else {
[16:11:14.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:14.098]             }
[16:11:14.098]             {
[16:11:14.098]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:14.098]                   0L) {
[16:11:14.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:14.098]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:14.098]                   base::options(opts)
[16:11:14.098]                 }
[16:11:14.098]                 {
[16:11:14.098]                   {
[16:11:14.098]                     NULL
[16:11:14.098]                     RNGkind("Mersenne-Twister")
[16:11:14.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:14.098]                       inherits = FALSE)
[16:11:14.098]                   }
[16:11:14.098]                   options(future.plan = NULL)
[16:11:14.098]                   if (is.na(NA_character_)) 
[16:11:14.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:14.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:14.098]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:14.098]                   {
[16:11:14.098]                     future <- SequentialFuture(..., envir = envir)
[16:11:14.098]                     if (!future$lazy) 
[16:11:14.098]                       future <- run(future)
[16:11:14.098]                     invisible(future)
[16:11:14.098]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:14.098]                 }
[16:11:14.098]             }
[16:11:14.098]         }
[16:11:14.098]     })
[16:11:14.098]     if (TRUE) {
[16:11:14.098]         base::sink(type = "output", split = FALSE)
[16:11:14.098]         if (TRUE) {
[16:11:14.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:14.098]         }
[16:11:14.098]         else {
[16:11:14.098]             ...future.result["stdout"] <- base::list(NULL)
[16:11:14.098]         }
[16:11:14.098]         base::close(...future.stdout)
[16:11:14.098]         ...future.stdout <- NULL
[16:11:14.098]     }
[16:11:14.098]     ...future.result$conditions <- ...future.conditions
[16:11:14.098]     ...future.result$finished <- base::Sys.time()
[16:11:14.098]     ...future.result
[16:11:14.098] }
[16:11:14.099] assign_globals() ...
[16:11:14.099] List of 5
[16:11:14.099]  $ ...future.FUN            :function (x, y)  
[16:11:14.099]  $ MoreArgs                 : NULL
[16:11:14.099]  $ ...future.elements_ii    :List of 2
[16:11:14.099]   ..$ :List of 2
[16:11:14.099]   .. ..$ : int 1
[16:11:14.099]   .. ..$ : int 0
[16:11:14.099]   ..$ :List of 2
[16:11:14.099]   .. ..$ : int 0
[16:11:14.099]   .. ..$ : int 1
[16:11:14.099]  $ ...future.seeds_ii       : NULL
[16:11:14.099]  $ ...future.globals.maxSize: NULL
[16:11:14.099]  - attr(*, "resolved")= logi FALSE
[16:11:14.099]  - attr(*, "total_size")= num 6480
[16:11:14.099]  - attr(*, "where")=List of 5
[16:11:14.099]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:14.099]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:14.099]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:14.099]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:14.099]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:14.099]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:14.099]  - attr(*, "already-done")= logi TRUE
[16:11:14.107] - reassign environment for ‘...future.FUN’
[16:11:14.107] - copied ‘...future.FUN’ to environment
[16:11:14.107] - copied ‘MoreArgs’ to environment
[16:11:14.107] - copied ‘...future.elements_ii’ to environment
[16:11:14.107] - copied ‘...future.seeds_ii’ to environment
[16:11:14.107] - copied ‘...future.globals.maxSize’ to environment
[16:11:14.107] assign_globals() ... done
[16:11:14.108] plan(): Setting new future strategy stack:
[16:11:14.108] List of future strategies:
[16:11:14.108] 1. sequential:
[16:11:14.108]    - args: function (..., envir = parent.frame())
[16:11:14.108]    - tweaked: FALSE
[16:11:14.108]    - call: NULL
[16:11:14.108] plan(): nbrOfWorkers() = 1
[16:11:14.610] plan(): Setting new future strategy stack:
[16:11:14.610] List of future strategies:
[16:11:14.610] 1. sequential:
[16:11:14.610]    - args: function (..., envir = parent.frame())
[16:11:14.610]    - tweaked: FALSE
[16:11:14.610]    - call: plan(strategy)
[16:11:14.610] plan(): nbrOfWorkers() = 1
[16:11:14.611] SequentialFuture started (and completed)
[16:11:14.611] - Launch lazy future ... done
[16:11:14.611] run() for ‘SequentialFuture’ ... done
[16:11:14.611] Created future:
[16:11:14.611] SequentialFuture:
[16:11:14.611] Label: ‘future_mapply-1’
[16:11:14.611] Expression:
[16:11:14.611] {
[16:11:14.611]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:14.611]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:14.611]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:14.611]         on.exit(options(oopts), add = TRUE)
[16:11:14.611]     }
[16:11:14.611]     {
[16:11:14.611]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:14.611]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:14.611]         do.call(mapply, args = args)
[16:11:14.611]     }
[16:11:14.611] }
[16:11:14.611] Lazy evaluation: FALSE
[16:11:14.611] Asynchronous evaluation: FALSE
[16:11:14.611] Local evaluation: TRUE
[16:11:14.611] Environment: R_GlobalEnv
[16:11:14.611] Capture standard output: TRUE
[16:11:14.611] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:14.611] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:14.611] Packages: <none>
[16:11:14.611] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:14.611] Resolved: TRUE
[16:11:14.611] Value: 224 bytes of class ‘list’
[16:11:14.611] Early signaling: FALSE
[16:11:14.611] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:14.611] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:14.612] Chunk #1 of 1 ... DONE
[16:11:14.612] Launching 1 futures (chunks) ... DONE
[16:11:14.612] Resolving 1 futures (chunks) ...
[16:11:14.613] resolve() on list ...
[16:11:14.613]  recursive: 0
[16:11:14.613]  length: 1
[16:11:14.613] 
[16:11:14.613] resolved() for ‘SequentialFuture’ ...
[16:11:14.613] - state: ‘finished’
[16:11:14.613] - run: TRUE
[16:11:14.613] - result: ‘FutureResult’
[16:11:14.613] resolved() for ‘SequentialFuture’ ... done
[16:11:14.613] Future #1
[16:11:14.614] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:14.614] - nx: 1
[16:11:14.614] - relay: TRUE
[16:11:14.614] - stdout: TRUE
[16:11:14.614] - signal: TRUE
[16:11:14.614] - resignal: FALSE
[16:11:14.614] - force: TRUE
[16:11:14.614] - relayed: [n=1] FALSE
[16:11:14.614] - queued futures: [n=1] FALSE
[16:11:14.614]  - until=1
[16:11:14.614]  - relaying element #1
[16:11:14.615] - relayed: [n=1] TRUE
[16:11:14.615] - queued futures: [n=1] TRUE
[16:11:14.615] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:14.615]  length: 0 (resolved future 1)
[16:11:14.615] Relaying remaining futures
[16:11:14.615] signalConditionsASAP(NULL, pos=0) ...
[16:11:14.615] - nx: 1
[16:11:14.615] - relay: TRUE
[16:11:14.615] - stdout: TRUE
[16:11:14.615] - signal: TRUE
[16:11:14.616] - resignal: FALSE
[16:11:14.616] - force: TRUE
[16:11:14.616] - relayed: [n=1] TRUE
[16:11:14.616] - queued futures: [n=1] TRUE
 - flush all
[16:11:14.616] - relayed: [n=1] TRUE
[16:11:14.616] - queued futures: [n=1] TRUE
[16:11:14.616] signalConditionsASAP(NULL, pos=0) ... done
[16:11:14.616] resolve() on list ... DONE
[16:11:14.616]  - Number of value chunks collected: 1
[16:11:14.616] Resolving 1 futures (chunks) ... DONE
[16:11:14.617] Reducing values from 1 chunks ...
[16:11:14.617]  - Number of values collected after concatenation: 2
[16:11:14.617]  - Number of values expected: 2
[16:11:14.617] Reducing values from 1 chunks ... DONE
[16:11:14.617] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:11:14.617] future_mapply() ...
[16:11:14.618] Number of chunks: 1
[16:11:14.618] getGlobalsAndPackagesXApply() ...
[16:11:14.618]  - future.globals: TRUE
[16:11:14.618] getGlobalsAndPackages() ...
[16:11:14.618] Searching for globals...
[16:11:14.619] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:14.619] Searching for globals ... DONE
[16:11:14.620] Resolving globals: FALSE
[16:11:14.620] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:14.620] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:14.621] - globals: [1] ‘FUN’
[16:11:14.621] 
[16:11:14.621] getGlobalsAndPackages() ... DONE
[16:11:14.621]  - globals found/used: [n=1] ‘FUN’
[16:11:14.621]  - needed namespaces: [n=0] 
[16:11:14.621] Finding globals ... DONE
[16:11:14.621] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:14.621] List of 2
[16:11:14.621]  $ ...future.FUN:function (x, y)  
[16:11:14.621]  $ MoreArgs     : NULL
[16:11:14.621]  - attr(*, "where")=List of 2
[16:11:14.621]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:14.621]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:14.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:14.621]  - attr(*, "resolved")= logi FALSE
[16:11:14.621]  - attr(*, "total_size")= num NA
[16:11:14.624] Packages to be attached in all futures: [n=0] 
[16:11:14.624] getGlobalsAndPackagesXApply() ... DONE
[16:11:14.624] Number of futures (= number of chunks): 1
[16:11:14.624] Launching 1 futures (chunks) ...
[16:11:14.624] Chunk #1 of 1 ...
[16:11:14.624]  - Finding globals in '...' for chunk #1 ...
[16:11:14.625] getGlobalsAndPackages() ...
[16:11:14.625] Searching for globals...
[16:11:14.625] 
[16:11:14.625] Searching for globals ... DONE
[16:11:14.625] - globals: [0] <none>
[16:11:14.625] getGlobalsAndPackages() ... DONE
[16:11:14.627]    + additional globals found: [n=0] 
[16:11:14.627]    + additional namespaces needed: [n=0] 
[16:11:14.627]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:14.627]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:14.628]  - seeds: <none>
[16:11:14.628] getGlobalsAndPackages() ...
[16:11:14.628] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:14.628] Resolving globals: FALSE
[16:11:14.628] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:14.629] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:14.629] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:14.629] 
[16:11:14.629] getGlobalsAndPackages() ... DONE
[16:11:14.629] run() for ‘Future’ ...
[16:11:14.630] - state: ‘created’
[16:11:14.630] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:14.630] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:14.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:14.630]   - Field: ‘label’
[16:11:14.630]   - Field: ‘local’
[16:11:14.630]   - Field: ‘owner’
[16:11:14.630]   - Field: ‘envir’
[16:11:14.631]   - Field: ‘packages’
[16:11:14.631]   - Field: ‘gc’
[16:11:14.631]   - Field: ‘conditions’
[16:11:14.631]   - Field: ‘expr’
[16:11:14.631]   - Field: ‘uuid’
[16:11:14.631]   - Field: ‘seed’
[16:11:14.631]   - Field: ‘version’
[16:11:14.631]   - Field: ‘result’
[16:11:14.631]   - Field: ‘asynchronous’
[16:11:14.631]   - Field: ‘calls’
[16:11:14.632]   - Field: ‘globals’
[16:11:14.632]   - Field: ‘stdout’
[16:11:14.632]   - Field: ‘earlySignal’
[16:11:14.632]   - Field: ‘lazy’
[16:11:14.632]   - Field: ‘state’
[16:11:14.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:14.632] - Launch lazy future ...
[16:11:14.632] Packages needed by the future expression (n = 0): <none>
[16:11:14.632] Packages needed by future strategies (n = 0): <none>
[16:11:14.633] {
[16:11:14.633]     {
[16:11:14.633]         {
[16:11:14.633]             ...future.startTime <- base::Sys.time()
[16:11:14.633]             {
[16:11:14.633]                 {
[16:11:14.633]                   {
[16:11:14.633]                     base::local({
[16:11:14.633]                       has_future <- base::requireNamespace("future", 
[16:11:14.633]                         quietly = TRUE)
[16:11:14.633]                       if (has_future) {
[16:11:14.633]                         ns <- base::getNamespace("future")
[16:11:14.633]                         version <- ns[[".package"]][["version"]]
[16:11:14.633]                         if (is.null(version)) 
[16:11:14.633]                           version <- utils::packageVersion("future")
[16:11:14.633]                       }
[16:11:14.633]                       else {
[16:11:14.633]                         version <- NULL
[16:11:14.633]                       }
[16:11:14.633]                       if (!has_future || version < "1.8.0") {
[16:11:14.633]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:14.633]                           "", base::R.version$version.string), 
[16:11:14.633]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:14.633]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:14.633]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:14.633]                             "release", "version")], collapse = " "), 
[16:11:14.633]                           hostname = base::Sys.info()[["nodename"]])
[16:11:14.633]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:14.633]                           info)
[16:11:14.633]                         info <- base::paste(info, collapse = "; ")
[16:11:14.633]                         if (!has_future) {
[16:11:14.633]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:14.633]                             info)
[16:11:14.633]                         }
[16:11:14.633]                         else {
[16:11:14.633]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:14.633]                             info, version)
[16:11:14.633]                         }
[16:11:14.633]                         base::stop(msg)
[16:11:14.633]                       }
[16:11:14.633]                     })
[16:11:14.633]                   }
[16:11:14.633]                   options(future.plan = NULL)
[16:11:14.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:14.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:14.633]                 }
[16:11:14.633]                 ...future.workdir <- getwd()
[16:11:14.633]             }
[16:11:14.633]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:14.633]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:14.633]         }
[16:11:14.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:14.633]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:14.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:14.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:14.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:14.633]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:14.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:14.633]             base::names(...future.oldOptions))
[16:11:14.633]     }
[16:11:14.633]     if (TRUE) {
[16:11:14.633]     }
[16:11:14.633]     else {
[16:11:14.633]         if (NA) {
[16:11:14.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:14.633]                 open = "w")
[16:11:14.633]         }
[16:11:14.633]         else {
[16:11:14.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:14.633]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:14.633]         }
[16:11:14.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:14.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:14.633]             base::sink(type = "output", split = FALSE)
[16:11:14.633]             base::close(...future.stdout)
[16:11:14.633]         }, add = TRUE)
[16:11:14.633]     }
[16:11:14.633]     ...future.frame <- base::sys.nframe()
[16:11:14.633]     ...future.conditions <- base::list()
[16:11:14.633]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:14.633]     if (FALSE) {
[16:11:14.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:14.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:14.633]     }
[16:11:14.633]     ...future.result <- base::tryCatch({
[16:11:14.633]         base::withCallingHandlers({
[16:11:14.633]             ...future.value <- base::withVisible(base::local({
[16:11:14.633]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:14.633]                 if (!identical(...future.globals.maxSize.org, 
[16:11:14.633]                   ...future.globals.maxSize)) {
[16:11:14.633]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:14.633]                   on.exit(options(oopts), add = TRUE)
[16:11:14.633]                 }
[16:11:14.633]                 {
[16:11:14.633]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:14.633]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:14.633]                     USE.NAMES = FALSE)
[16:11:14.633]                   do.call(mapply, args = args)
[16:11:14.633]                 }
[16:11:14.633]             }))
[16:11:14.633]             future::FutureResult(value = ...future.value$value, 
[16:11:14.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:14.633]                   ...future.rng), globalenv = if (FALSE) 
[16:11:14.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:14.633]                     ...future.globalenv.names))
[16:11:14.633]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:14.633]         }, condition = base::local({
[16:11:14.633]             c <- base::c
[16:11:14.633]             inherits <- base::inherits
[16:11:14.633]             invokeRestart <- base::invokeRestart
[16:11:14.633]             length <- base::length
[16:11:14.633]             list <- base::list
[16:11:14.633]             seq.int <- base::seq.int
[16:11:14.633]             signalCondition <- base::signalCondition
[16:11:14.633]             sys.calls <- base::sys.calls
[16:11:14.633]             `[[` <- base::`[[`
[16:11:14.633]             `+` <- base::`+`
[16:11:14.633]             `<<-` <- base::`<<-`
[16:11:14.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:14.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:14.633]                   3L)]
[16:11:14.633]             }
[16:11:14.633]             function(cond) {
[16:11:14.633]                 is_error <- inherits(cond, "error")
[16:11:14.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:14.633]                   NULL)
[16:11:14.633]                 if (is_error) {
[16:11:14.633]                   sessionInformation <- function() {
[16:11:14.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:14.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:14.633]                       search = base::search(), system = base::Sys.info())
[16:11:14.633]                   }
[16:11:14.633]                   ...future.conditions[[length(...future.conditions) + 
[16:11:14.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:14.633]                     cond$call), session = sessionInformation(), 
[16:11:14.633]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:14.633]                   signalCondition(cond)
[16:11:14.633]                 }
[16:11:14.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:14.633]                 "immediateCondition"))) {
[16:11:14.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:14.633]                   ...future.conditions[[length(...future.conditions) + 
[16:11:14.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:14.633]                   if (TRUE && !signal) {
[16:11:14.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:14.633]                     {
[16:11:14.633]                       inherits <- base::inherits
[16:11:14.633]                       invokeRestart <- base::invokeRestart
[16:11:14.633]                       is.null <- base::is.null
[16:11:14.633]                       muffled <- FALSE
[16:11:14.633]                       if (inherits(cond, "message")) {
[16:11:14.633]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:14.633]                         if (muffled) 
[16:11:14.633]                           invokeRestart("muffleMessage")
[16:11:14.633]                       }
[16:11:14.633]                       else if (inherits(cond, "warning")) {
[16:11:14.633]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:14.633]                         if (muffled) 
[16:11:14.633]                           invokeRestart("muffleWarning")
[16:11:14.633]                       }
[16:11:14.633]                       else if (inherits(cond, "condition")) {
[16:11:14.633]                         if (!is.null(pattern)) {
[16:11:14.633]                           computeRestarts <- base::computeRestarts
[16:11:14.633]                           grepl <- base::grepl
[16:11:14.633]                           restarts <- computeRestarts(cond)
[16:11:14.633]                           for (restart in restarts) {
[16:11:14.633]                             name <- restart$name
[16:11:14.633]                             if (is.null(name)) 
[16:11:14.633]                               next
[16:11:14.633]                             if (!grepl(pattern, name)) 
[16:11:14.633]                               next
[16:11:14.633]                             invokeRestart(restart)
[16:11:14.633]                             muffled <- TRUE
[16:11:14.633]                             break
[16:11:14.633]                           }
[16:11:14.633]                         }
[16:11:14.633]                       }
[16:11:14.633]                       invisible(muffled)
[16:11:14.633]                     }
[16:11:14.633]                     muffleCondition(cond, pattern = "^muffle")
[16:11:14.633]                   }
[16:11:14.633]                 }
[16:11:14.633]                 else {
[16:11:14.633]                   if (TRUE) {
[16:11:14.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:14.633]                     {
[16:11:14.633]                       inherits <- base::inherits
[16:11:14.633]                       invokeRestart <- base::invokeRestart
[16:11:14.633]                       is.null <- base::is.null
[16:11:14.633]                       muffled <- FALSE
[16:11:14.633]                       if (inherits(cond, "message")) {
[16:11:14.633]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:14.633]                         if (muffled) 
[16:11:14.633]                           invokeRestart("muffleMessage")
[16:11:14.633]                       }
[16:11:14.633]                       else if (inherits(cond, "warning")) {
[16:11:14.633]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:14.633]                         if (muffled) 
[16:11:14.633]                           invokeRestart("muffleWarning")
[16:11:14.633]                       }
[16:11:14.633]                       else if (inherits(cond, "condition")) {
[16:11:14.633]                         if (!is.null(pattern)) {
[16:11:14.633]                           computeRestarts <- base::computeRestarts
[16:11:14.633]                           grepl <- base::grepl
[16:11:14.633]                           restarts <- computeRestarts(cond)
[16:11:14.633]                           for (restart in restarts) {
[16:11:14.633]                             name <- restart$name
[16:11:14.633]                             if (is.null(name)) 
[16:11:14.633]                               next
[16:11:14.633]                             if (!grepl(pattern, name)) 
[16:11:14.633]                               next
[16:11:14.633]                             invokeRestart(restart)
[16:11:14.633]                             muffled <- TRUE
[16:11:14.633]                             break
[16:11:14.633]                           }
[16:11:14.633]                         }
[16:11:14.633]                       }
[16:11:14.633]                       invisible(muffled)
[16:11:14.633]                     }
[16:11:14.633]                     muffleCondition(cond, pattern = "^muffle")
[16:11:14.633]                   }
[16:11:14.633]                 }
[16:11:14.633]             }
[16:11:14.633]         }))
[16:11:14.633]     }, error = function(ex) {
[16:11:14.633]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:14.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:14.633]                 ...future.rng), started = ...future.startTime, 
[16:11:14.633]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:14.633]             version = "1.8"), class = "FutureResult")
[16:11:14.633]     }, finally = {
[16:11:14.633]         if (!identical(...future.workdir, getwd())) 
[16:11:14.633]             setwd(...future.workdir)
[16:11:14.633]         {
[16:11:14.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:14.633]                 ...future.oldOptions$nwarnings <- NULL
[16:11:14.633]             }
[16:11:14.633]             base::options(...future.oldOptions)
[16:11:14.633]             if (.Platform$OS.type == "windows") {
[16:11:14.633]                 old_names <- names(...future.oldEnvVars)
[16:11:14.633]                 envs <- base::Sys.getenv()
[16:11:14.633]                 names <- names(envs)
[16:11:14.633]                 common <- intersect(names, old_names)
[16:11:14.633]                 added <- setdiff(names, old_names)
[16:11:14.633]                 removed <- setdiff(old_names, names)
[16:11:14.633]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:14.633]                   envs[common]]
[16:11:14.633]                 NAMES <- toupper(changed)
[16:11:14.633]                 args <- list()
[16:11:14.633]                 for (kk in seq_along(NAMES)) {
[16:11:14.633]                   name <- changed[[kk]]
[16:11:14.633]                   NAME <- NAMES[[kk]]
[16:11:14.633]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:14.633]                     next
[16:11:14.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:14.633]                 }
[16:11:14.633]                 NAMES <- toupper(added)
[16:11:14.633]                 for (kk in seq_along(NAMES)) {
[16:11:14.633]                   name <- added[[kk]]
[16:11:14.633]                   NAME <- NAMES[[kk]]
[16:11:14.633]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:14.633]                     next
[16:11:14.633]                   args[[name]] <- ""
[16:11:14.633]                 }
[16:11:14.633]                 NAMES <- toupper(removed)
[16:11:14.633]                 for (kk in seq_along(NAMES)) {
[16:11:14.633]                   name <- removed[[kk]]
[16:11:14.633]                   NAME <- NAMES[[kk]]
[16:11:14.633]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:14.633]                     next
[16:11:14.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:14.633]                 }
[16:11:14.633]                 if (length(args) > 0) 
[16:11:14.633]                   base::do.call(base::Sys.setenv, args = args)
[16:11:14.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:14.633]             }
[16:11:14.633]             else {
[16:11:14.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:14.633]             }
[16:11:14.633]             {
[16:11:14.633]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:14.633]                   0L) {
[16:11:14.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:14.633]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:14.633]                   base::options(opts)
[16:11:14.633]                 }
[16:11:14.633]                 {
[16:11:14.633]                   {
[16:11:14.633]                     NULL
[16:11:14.633]                     RNGkind("Mersenne-Twister")
[16:11:14.633]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:14.633]                       inherits = FALSE)
[16:11:14.633]                   }
[16:11:14.633]                   options(future.plan = NULL)
[16:11:14.633]                   if (is.na(NA_character_)) 
[16:11:14.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:14.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:14.633]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:14.633]                   {
[16:11:14.633]                     future <- SequentialFuture(..., envir = envir)
[16:11:14.633]                     if (!future$lazy) 
[16:11:14.633]                       future <- run(future)
[16:11:14.633]                     invisible(future)
[16:11:14.633]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:14.633]                 }
[16:11:14.633]             }
[16:11:14.633]         }
[16:11:14.633]     })
[16:11:14.633]     if (FALSE) {
[16:11:14.633]         base::sink(type = "output", split = FALSE)
[16:11:14.633]         if (NA) {
[16:11:14.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:14.633]         }
[16:11:14.633]         else {
[16:11:14.633]             ...future.result["stdout"] <- base::list(NULL)
[16:11:14.633]         }
[16:11:14.633]         base::close(...future.stdout)
[16:11:14.633]         ...future.stdout <- NULL
[16:11:14.633]     }
[16:11:14.633]     ...future.result$conditions <- ...future.conditions
[16:11:14.633]     ...future.result$finished <- base::Sys.time()
[16:11:14.633]     ...future.result
[16:11:14.633] }
[16:11:14.635] assign_globals() ...
[16:11:14.635] List of 5
[16:11:14.635]  $ ...future.FUN            :function (x, y)  
[16:11:14.635]  $ MoreArgs                 : NULL
[16:11:14.635]  $ ...future.elements_ii    :List of 2
[16:11:14.635]   ..$ :List of 2
[16:11:14.635]   .. ..$ : int 1
[16:11:14.635]   .. ..$ : int 0
[16:11:14.635]   ..$ :List of 2
[16:11:14.635]   .. ..$ : int 0
[16:11:14.635]   .. ..$ : int 1
[16:11:14.635]  $ ...future.seeds_ii       : NULL
[16:11:14.635]  $ ...future.globals.maxSize: NULL
[16:11:14.635]  - attr(*, "resolved")= logi FALSE
[16:11:14.635]  - attr(*, "total_size")= num 6480
[16:11:14.635]  - attr(*, "where")=List of 5
[16:11:14.635]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:14.635]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:14.635]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:14.635]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:14.635]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:14.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:14.635]  - attr(*, "already-done")= logi TRUE
[16:11:14.640] - reassign environment for ‘...future.FUN’
[16:11:14.640] - copied ‘...future.FUN’ to environment
[16:11:14.640] - copied ‘MoreArgs’ to environment
[16:11:14.640] - copied ‘...future.elements_ii’ to environment
[16:11:14.640] - copied ‘...future.seeds_ii’ to environment
[16:11:14.641] - copied ‘...future.globals.maxSize’ to environment
[16:11:14.641] assign_globals() ... done
[16:11:14.641] plan(): Setting new future strategy stack:
[16:11:14.641] List of future strategies:
[16:11:14.641] 1. sequential:
[16:11:14.641]    - args: function (..., envir = parent.frame())
[16:11:14.641]    - tweaked: FALSE
[16:11:14.641]    - call: NULL
[16:11:14.641] plan(): nbrOfWorkers() = 1
[16:11:15.143] plan(): Setting new future strategy stack:
[16:11:15.143] List of future strategies:
[16:11:15.143] 1. sequential:
[16:11:15.143]    - args: function (..., envir = parent.frame())
[16:11:15.143]    - tweaked: FALSE
[16:11:15.143]    - call: plan(strategy)
[16:11:15.144] plan(): nbrOfWorkers() = 1
[16:11:15.144] SequentialFuture started (and completed)
[16:11:15.144] - Launch lazy future ... done
[16:11:15.144] run() for ‘SequentialFuture’ ... done
[16:11:15.144] Created future:
[16:11:15.144] SequentialFuture:
[16:11:15.144] Label: ‘future_mapply-1’
[16:11:15.144] Expression:
[16:11:15.144] {
[16:11:15.144]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:15.144]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:15.144]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:15.144]         on.exit(options(oopts), add = TRUE)
[16:11:15.144]     }
[16:11:15.144]     {
[16:11:15.144]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:15.144]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:15.144]         do.call(mapply, args = args)
[16:11:15.144]     }
[16:11:15.144] }
[16:11:15.144] Lazy evaluation: FALSE
[16:11:15.144] Asynchronous evaluation: FALSE
[16:11:15.144] Local evaluation: TRUE
[16:11:15.144] Environment: R_GlobalEnv
[16:11:15.144] Capture standard output: NA
[16:11:15.144] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:15.144] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:15.144] Packages: <none>
[16:11:15.144] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:15.144] Resolved: TRUE
[16:11:15.144] Value: 224 bytes of class ‘list’
[16:11:15.144] Early signaling: FALSE
[16:11:15.144] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:15.144] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:15.145] Chunk #1 of 1 ... DONE
[16:11:15.146] Launching 1 futures (chunks) ... DONE
[16:11:15.146] Resolving 1 futures (chunks) ...
[16:11:15.146] resolve() on list ...
[16:11:15.146]  recursive: 0
[16:11:15.146]  length: 1
[16:11:15.146] 
[16:11:15.146] resolved() for ‘SequentialFuture’ ...
[16:11:15.146] - state: ‘finished’
[16:11:15.146] - run: TRUE
[16:11:15.146] - result: ‘FutureResult’
[16:11:15.147] resolved() for ‘SequentialFuture’ ... done
[16:11:15.147] Future #1
[16:11:15.147] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:15.147] - nx: 1
[16:11:15.147] - relay: TRUE
[16:11:15.147] - stdout: TRUE
[16:11:15.147] - signal: TRUE
[16:11:15.147] - resignal: FALSE
[16:11:15.147] - force: TRUE
[16:11:15.147] - relayed: [n=1] FALSE
[16:11:15.147] - queued futures: [n=1] FALSE
[16:11:15.148]  - until=1
[16:11:15.148]  - relaying element #1
[16:11:15.148] - relayed: [n=1] TRUE
[16:11:15.148] - queued futures: [n=1] TRUE
[16:11:15.148] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:15.148]  length: 0 (resolved future 1)
[16:11:15.148] Relaying remaining futures
[16:11:15.148] signalConditionsASAP(NULL, pos=0) ...
[16:11:15.148] - nx: 1
[16:11:15.148] - relay: TRUE
[16:11:15.149] - stdout: TRUE
[16:11:15.149] - signal: TRUE
[16:11:15.149] - resignal: FALSE
[16:11:15.149] - force: TRUE
[16:11:15.149] - relayed: [n=1] TRUE
[16:11:15.149] - queued futures: [n=1] TRUE
 - flush all
[16:11:15.149] - relayed: [n=1] TRUE
[16:11:15.149] - queued futures: [n=1] TRUE
[16:11:15.149] signalConditionsASAP(NULL, pos=0) ... done
[16:11:15.149] resolve() on list ... DONE
[16:11:15.150]  - Number of value chunks collected: 1
[16:11:15.150] Resolving 1 futures (chunks) ... DONE
[16:11:15.150] Reducing values from 1 chunks ...
[16:11:15.150]  - Number of values collected after concatenation: 2
[16:11:15.150]  - Number of values expected: 2
[16:11:15.150] Reducing values from 1 chunks ... DONE
[16:11:15.150] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[16:11:15.151] plan(): Setting new future strategy stack:
[16:11:15.151] List of future strategies:
[16:11:15.151] 1. multicore:
[16:11:15.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:15.151]    - tweaked: FALSE
[16:11:15.151]    - call: plan(strategy)
[16:11:15.155] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:11:15.157] future_lapply() ...
[16:11:15.161] Number of chunks: 1
[16:11:15.161] getGlobalsAndPackagesXApply() ...
[16:11:15.161]  - future.globals: TRUE
[16:11:15.162] getGlobalsAndPackages() ...
[16:11:15.162] Searching for globals...
[16:11:15.163] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:15.163] Searching for globals ... DONE
[16:11:15.163] Resolving globals: FALSE
[16:11:15.164] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:15.164] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:15.164] - globals: [1] ‘FUN’
[16:11:15.164] 
[16:11:15.164] getGlobalsAndPackages() ... DONE
[16:11:15.164]  - globals found/used: [n=1] ‘FUN’
[16:11:15.165]  - needed namespaces: [n=0] 
[16:11:15.165] Finding globals ... DONE
[16:11:15.165]  - use_args: TRUE
[16:11:15.165]  - Getting '...' globals ...
[16:11:15.165] resolve() on list ...
[16:11:15.165]  recursive: 0
[16:11:15.165]  length: 1
[16:11:15.165]  elements: ‘...’
[16:11:15.166]  length: 0 (resolved future 1)
[16:11:15.166] resolve() on list ... DONE
[16:11:15.166]    - '...' content: [n=0] 
[16:11:15.166] List of 1
[16:11:15.166]  $ ...: list()
[16:11:15.166]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:15.166]  - attr(*, "where")=List of 1
[16:11:15.166]   ..$ ...:<environment: 0x557e20333880> 
[16:11:15.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:15.166]  - attr(*, "resolved")= logi TRUE
[16:11:15.166]  - attr(*, "total_size")= num NA
[16:11:15.168]  - Getting '...' globals ... DONE
[16:11:15.169] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:15.169] List of 2
[16:11:15.169]  $ ...future.FUN:function (x)  
[16:11:15.169]  $ ...          : list()
[16:11:15.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:15.169]  - attr(*, "where")=List of 2
[16:11:15.169]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:15.169]   ..$ ...          :<environment: 0x557e20333880> 
[16:11:15.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:15.169]  - attr(*, "resolved")= logi FALSE
[16:11:15.169]  - attr(*, "total_size")= num 4720
[16:11:15.171] Packages to be attached in all futures: [n=0] 
[16:11:15.171] getGlobalsAndPackagesXApply() ... DONE
[16:11:15.172] Number of futures (= number of chunks): 1
[16:11:15.172] Launching 1 futures (chunks) ...
[16:11:15.172] Chunk #1 of 1 ...
[16:11:15.172]  - Finding globals in 'X' for chunk #1 ...
[16:11:15.172] getGlobalsAndPackages() ...
[16:11:15.172] Searching for globals...
[16:11:15.172] 
[16:11:15.172] Searching for globals ... DONE
[16:11:15.173] - globals: [0] <none>
[16:11:15.173] getGlobalsAndPackages() ... DONE
[16:11:15.173]    + additional globals found: [n=0] 
[16:11:15.173]    + additional namespaces needed: [n=0] 
[16:11:15.173]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:15.173]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:15.173]  - seeds: <none>
[16:11:15.173] getGlobalsAndPackages() ...
[16:11:15.173] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:15.173] Resolving globals: FALSE
[16:11:15.174] Tweak future expression to call with '...' arguments ...
[16:11:15.174] {
[16:11:15.174]     do.call(function(...) {
[16:11:15.174]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:15.174]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:15.174]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:15.174]             on.exit(options(oopts), add = TRUE)
[16:11:15.174]         }
[16:11:15.174]         {
[16:11:15.174]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:15.174]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:15.174]                 ...future.FUN(...future.X_jj, ...)
[16:11:15.174]             })
[16:11:15.174]         }
[16:11:15.174]     }, args = future.call.arguments)
[16:11:15.174] }
[16:11:15.174] Tweak future expression to call with '...' arguments ... DONE
[16:11:15.174] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:15.174] 
[16:11:15.174] getGlobalsAndPackages() ... DONE
[16:11:15.175] run() for ‘Future’ ...
[16:11:15.175] - state: ‘created’
[16:11:15.175] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:15.179] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:15.179] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:15.179]   - Field: ‘label’
[16:11:15.179]   - Field: ‘local’
[16:11:15.179]   - Field: ‘owner’
[16:11:15.179]   - Field: ‘envir’
[16:11:15.179]   - Field: ‘packages’
[16:11:15.179]   - Field: ‘gc’
[16:11:15.179]   - Field: ‘conditions’
[16:11:15.180]   - Field: ‘expr’
[16:11:15.180]   - Field: ‘uuid’
[16:11:15.180]   - Field: ‘seed’
[16:11:15.180]   - Field: ‘version’
[16:11:15.180]   - Field: ‘result’
[16:11:15.180]   - Field: ‘asynchronous’
[16:11:15.180]   - Field: ‘calls’
[16:11:15.180]   - Field: ‘globals’
[16:11:15.180]   - Field: ‘stdout’
[16:11:15.180]   - Field: ‘earlySignal’
[16:11:15.181]   - Field: ‘lazy’
[16:11:15.181]   - Field: ‘state’
[16:11:15.181] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:15.181] - Launch lazy future ...
[16:11:15.181] Packages needed by the future expression (n = 0): <none>
[16:11:15.181] Packages needed by future strategies (n = 0): <none>
[16:11:15.182] {
[16:11:15.182]     {
[16:11:15.182]         {
[16:11:15.182]             ...future.startTime <- base::Sys.time()
[16:11:15.182]             {
[16:11:15.182]                 {
[16:11:15.182]                   {
[16:11:15.182]                     base::local({
[16:11:15.182]                       has_future <- base::requireNamespace("future", 
[16:11:15.182]                         quietly = TRUE)
[16:11:15.182]                       if (has_future) {
[16:11:15.182]                         ns <- base::getNamespace("future")
[16:11:15.182]                         version <- ns[[".package"]][["version"]]
[16:11:15.182]                         if (is.null(version)) 
[16:11:15.182]                           version <- utils::packageVersion("future")
[16:11:15.182]                       }
[16:11:15.182]                       else {
[16:11:15.182]                         version <- NULL
[16:11:15.182]                       }
[16:11:15.182]                       if (!has_future || version < "1.8.0") {
[16:11:15.182]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:15.182]                           "", base::R.version$version.string), 
[16:11:15.182]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:15.182]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:15.182]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:15.182]                             "release", "version")], collapse = " "), 
[16:11:15.182]                           hostname = base::Sys.info()[["nodename"]])
[16:11:15.182]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:15.182]                           info)
[16:11:15.182]                         info <- base::paste(info, collapse = "; ")
[16:11:15.182]                         if (!has_future) {
[16:11:15.182]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:15.182]                             info)
[16:11:15.182]                         }
[16:11:15.182]                         else {
[16:11:15.182]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:15.182]                             info, version)
[16:11:15.182]                         }
[16:11:15.182]                         base::stop(msg)
[16:11:15.182]                       }
[16:11:15.182]                     })
[16:11:15.182]                   }
[16:11:15.182]                   options(future.plan = NULL)
[16:11:15.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:15.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:15.182]                 }
[16:11:15.182]                 ...future.workdir <- getwd()
[16:11:15.182]             }
[16:11:15.182]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:15.182]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:15.182]         }
[16:11:15.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:15.182]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:15.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:15.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:15.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:15.182]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:15.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:15.182]             base::names(...future.oldOptions))
[16:11:15.182]     }
[16:11:15.182]     if (FALSE) {
[16:11:15.182]     }
[16:11:15.182]     else {
[16:11:15.182]         if (FALSE) {
[16:11:15.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:15.182]                 open = "w")
[16:11:15.182]         }
[16:11:15.182]         else {
[16:11:15.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:15.182]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:15.182]         }
[16:11:15.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:15.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:15.182]             base::sink(type = "output", split = FALSE)
[16:11:15.182]             base::close(...future.stdout)
[16:11:15.182]         }, add = TRUE)
[16:11:15.182]     }
[16:11:15.182]     ...future.frame <- base::sys.nframe()
[16:11:15.182]     ...future.conditions <- base::list()
[16:11:15.182]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:15.182]     if (FALSE) {
[16:11:15.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:15.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:15.182]     }
[16:11:15.182]     ...future.result <- base::tryCatch({
[16:11:15.182]         base::withCallingHandlers({
[16:11:15.182]             ...future.value <- base::withVisible(base::local({
[16:11:15.182]                 do.call(function(...) {
[16:11:15.182]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:15.182]                   if (!identical(...future.globals.maxSize.org, 
[16:11:15.182]                     ...future.globals.maxSize)) {
[16:11:15.182]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:15.182]                     on.exit(options(oopts), add = TRUE)
[16:11:15.182]                   }
[16:11:15.182]                   {
[16:11:15.182]                     lapply(seq_along(...future.elements_ii), 
[16:11:15.182]                       FUN = function(jj) {
[16:11:15.182]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:15.182]                         ...future.FUN(...future.X_jj, ...)
[16:11:15.182]                       })
[16:11:15.182]                   }
[16:11:15.182]                 }, args = future.call.arguments)
[16:11:15.182]             }))
[16:11:15.182]             future::FutureResult(value = ...future.value$value, 
[16:11:15.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:15.182]                   ...future.rng), globalenv = if (FALSE) 
[16:11:15.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:15.182]                     ...future.globalenv.names))
[16:11:15.182]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:15.182]         }, condition = base::local({
[16:11:15.182]             c <- base::c
[16:11:15.182]             inherits <- base::inherits
[16:11:15.182]             invokeRestart <- base::invokeRestart
[16:11:15.182]             length <- base::length
[16:11:15.182]             list <- base::list
[16:11:15.182]             seq.int <- base::seq.int
[16:11:15.182]             signalCondition <- base::signalCondition
[16:11:15.182]             sys.calls <- base::sys.calls
[16:11:15.182]             `[[` <- base::`[[`
[16:11:15.182]             `+` <- base::`+`
[16:11:15.182]             `<<-` <- base::`<<-`
[16:11:15.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:15.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:15.182]                   3L)]
[16:11:15.182]             }
[16:11:15.182]             function(cond) {
[16:11:15.182]                 is_error <- inherits(cond, "error")
[16:11:15.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:15.182]                   NULL)
[16:11:15.182]                 if (is_error) {
[16:11:15.182]                   sessionInformation <- function() {
[16:11:15.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:15.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:15.182]                       search = base::search(), system = base::Sys.info())
[16:11:15.182]                   }
[16:11:15.182]                   ...future.conditions[[length(...future.conditions) + 
[16:11:15.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:15.182]                     cond$call), session = sessionInformation(), 
[16:11:15.182]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:15.182]                   signalCondition(cond)
[16:11:15.182]                 }
[16:11:15.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:15.182]                 "immediateCondition"))) {
[16:11:15.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:15.182]                   ...future.conditions[[length(...future.conditions) + 
[16:11:15.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:15.182]                   if (TRUE && !signal) {
[16:11:15.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:15.182]                     {
[16:11:15.182]                       inherits <- base::inherits
[16:11:15.182]                       invokeRestart <- base::invokeRestart
[16:11:15.182]                       is.null <- base::is.null
[16:11:15.182]                       muffled <- FALSE
[16:11:15.182]                       if (inherits(cond, "message")) {
[16:11:15.182]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:15.182]                         if (muffled) 
[16:11:15.182]                           invokeRestart("muffleMessage")
[16:11:15.182]                       }
[16:11:15.182]                       else if (inherits(cond, "warning")) {
[16:11:15.182]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:15.182]                         if (muffled) 
[16:11:15.182]                           invokeRestart("muffleWarning")
[16:11:15.182]                       }
[16:11:15.182]                       else if (inherits(cond, "condition")) {
[16:11:15.182]                         if (!is.null(pattern)) {
[16:11:15.182]                           computeRestarts <- base::computeRestarts
[16:11:15.182]                           grepl <- base::grepl
[16:11:15.182]                           restarts <- computeRestarts(cond)
[16:11:15.182]                           for (restart in restarts) {
[16:11:15.182]                             name <- restart$name
[16:11:15.182]                             if (is.null(name)) 
[16:11:15.182]                               next
[16:11:15.182]                             if (!grepl(pattern, name)) 
[16:11:15.182]                               next
[16:11:15.182]                             invokeRestart(restart)
[16:11:15.182]                             muffled <- TRUE
[16:11:15.182]                             break
[16:11:15.182]                           }
[16:11:15.182]                         }
[16:11:15.182]                       }
[16:11:15.182]                       invisible(muffled)
[16:11:15.182]                     }
[16:11:15.182]                     muffleCondition(cond, pattern = "^muffle")
[16:11:15.182]                   }
[16:11:15.182]                 }
[16:11:15.182]                 else {
[16:11:15.182]                   if (TRUE) {
[16:11:15.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:15.182]                     {
[16:11:15.182]                       inherits <- base::inherits
[16:11:15.182]                       invokeRestart <- base::invokeRestart
[16:11:15.182]                       is.null <- base::is.null
[16:11:15.182]                       muffled <- FALSE
[16:11:15.182]                       if (inherits(cond, "message")) {
[16:11:15.182]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:15.182]                         if (muffled) 
[16:11:15.182]                           invokeRestart("muffleMessage")
[16:11:15.182]                       }
[16:11:15.182]                       else if (inherits(cond, "warning")) {
[16:11:15.182]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:15.182]                         if (muffled) 
[16:11:15.182]                           invokeRestart("muffleWarning")
[16:11:15.182]                       }
[16:11:15.182]                       else if (inherits(cond, "condition")) {
[16:11:15.182]                         if (!is.null(pattern)) {
[16:11:15.182]                           computeRestarts <- base::computeRestarts
[16:11:15.182]                           grepl <- base::grepl
[16:11:15.182]                           restarts <- computeRestarts(cond)
[16:11:15.182]                           for (restart in restarts) {
[16:11:15.182]                             name <- restart$name
[16:11:15.182]                             if (is.null(name)) 
[16:11:15.182]                               next
[16:11:15.182]                             if (!grepl(pattern, name)) 
[16:11:15.182]                               next
[16:11:15.182]                             invokeRestart(restart)
[16:11:15.182]                             muffled <- TRUE
[16:11:15.182]                             break
[16:11:15.182]                           }
[16:11:15.182]                         }
[16:11:15.182]                       }
[16:11:15.182]                       invisible(muffled)
[16:11:15.182]                     }
[16:11:15.182]                     muffleCondition(cond, pattern = "^muffle")
[16:11:15.182]                   }
[16:11:15.182]                 }
[16:11:15.182]             }
[16:11:15.182]         }))
[16:11:15.182]     }, error = function(ex) {
[16:11:15.182]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:15.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:15.182]                 ...future.rng), started = ...future.startTime, 
[16:11:15.182]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:15.182]             version = "1.8"), class = "FutureResult")
[16:11:15.182]     }, finally = {
[16:11:15.182]         if (!identical(...future.workdir, getwd())) 
[16:11:15.182]             setwd(...future.workdir)
[16:11:15.182]         {
[16:11:15.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:15.182]                 ...future.oldOptions$nwarnings <- NULL
[16:11:15.182]             }
[16:11:15.182]             base::options(...future.oldOptions)
[16:11:15.182]             if (.Platform$OS.type == "windows") {
[16:11:15.182]                 old_names <- names(...future.oldEnvVars)
[16:11:15.182]                 envs <- base::Sys.getenv()
[16:11:15.182]                 names <- names(envs)
[16:11:15.182]                 common <- intersect(names, old_names)
[16:11:15.182]                 added <- setdiff(names, old_names)
[16:11:15.182]                 removed <- setdiff(old_names, names)
[16:11:15.182]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:15.182]                   envs[common]]
[16:11:15.182]                 NAMES <- toupper(changed)
[16:11:15.182]                 args <- list()
[16:11:15.182]                 for (kk in seq_along(NAMES)) {
[16:11:15.182]                   name <- changed[[kk]]
[16:11:15.182]                   NAME <- NAMES[[kk]]
[16:11:15.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:15.182]                     next
[16:11:15.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:15.182]                 }
[16:11:15.182]                 NAMES <- toupper(added)
[16:11:15.182]                 for (kk in seq_along(NAMES)) {
[16:11:15.182]                   name <- added[[kk]]
[16:11:15.182]                   NAME <- NAMES[[kk]]
[16:11:15.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:15.182]                     next
[16:11:15.182]                   args[[name]] <- ""
[16:11:15.182]                 }
[16:11:15.182]                 NAMES <- toupper(removed)
[16:11:15.182]                 for (kk in seq_along(NAMES)) {
[16:11:15.182]                   name <- removed[[kk]]
[16:11:15.182]                   NAME <- NAMES[[kk]]
[16:11:15.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:15.182]                     next
[16:11:15.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:15.182]                 }
[16:11:15.182]                 if (length(args) > 0) 
[16:11:15.182]                   base::do.call(base::Sys.setenv, args = args)
[16:11:15.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:15.182]             }
[16:11:15.182]             else {
[16:11:15.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:15.182]             }
[16:11:15.182]             {
[16:11:15.182]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:15.182]                   0L) {
[16:11:15.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:15.182]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:15.182]                   base::options(opts)
[16:11:15.182]                 }
[16:11:15.182]                 {
[16:11:15.182]                   {
[16:11:15.182]                     NULL
[16:11:15.182]                     RNGkind("Mersenne-Twister")
[16:11:15.182]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:15.182]                       inherits = FALSE)
[16:11:15.182]                   }
[16:11:15.182]                   options(future.plan = NULL)
[16:11:15.182]                   if (is.na(NA_character_)) 
[16:11:15.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:15.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:15.182]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:15.182]                     envir = parent.frame()) 
[16:11:15.182]                   {
[16:11:15.182]                     default_workers <- missing(workers)
[16:11:15.182]                     if (is.function(workers)) 
[16:11:15.182]                       workers <- workers()
[16:11:15.182]                     workers <- structure(as.integer(workers), 
[16:11:15.182]                       class = class(workers))
[16:11:15.182]                     stop_if_not(is.finite(workers), workers >= 
[16:11:15.182]                       1L)
[16:11:15.182]                     if ((workers == 1L && !inherits(workers, 
[16:11:15.182]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:15.182]                       if (default_workers) 
[16:11:15.182]                         supportsMulticore(warn = TRUE)
[16:11:15.182]                       return(sequential(..., envir = envir))
[16:11:15.182]                     }
[16:11:15.182]                     oopts <- options(mc.cores = workers)
[16:11:15.182]                     on.exit(options(oopts))
[16:11:15.182]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:15.182]                       envir = envir)
[16:11:15.182]                     if (!future$lazy) 
[16:11:15.182]                       future <- run(future)
[16:11:15.182]                     invisible(future)
[16:11:15.182]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:15.182]                 }
[16:11:15.182]             }
[16:11:15.182]         }
[16:11:15.182]     })
[16:11:15.182]     if (TRUE) {
[16:11:15.182]         base::sink(type = "output", split = FALSE)
[16:11:15.182]         if (FALSE) {
[16:11:15.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:15.182]         }
[16:11:15.182]         else {
[16:11:15.182]             ...future.result["stdout"] <- base::list(NULL)
[16:11:15.182]         }
[16:11:15.182]         base::close(...future.stdout)
[16:11:15.182]         ...future.stdout <- NULL
[16:11:15.182]     }
[16:11:15.182]     ...future.result$conditions <- ...future.conditions
[16:11:15.182]     ...future.result$finished <- base::Sys.time()
[16:11:15.182]     ...future.result
[16:11:15.182] }
[16:11:15.183] assign_globals() ...
[16:11:15.184] List of 5
[16:11:15.184]  $ ...future.FUN            :function (x)  
[16:11:15.184]  $ future.call.arguments    : list()
[16:11:15.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:15.184]  $ ...future.elements_ii    :List of 2
[16:11:15.184]   ..$ : int 1
[16:11:15.184]   ..$ : int 0
[16:11:15.184]  $ ...future.seeds_ii       : NULL
[16:11:15.184]  $ ...future.globals.maxSize: NULL
[16:11:15.184]  - attr(*, "resolved")= logi FALSE
[16:11:15.184]  - attr(*, "total_size")= num 4720
[16:11:15.184]  - attr(*, "where")=List of 5
[16:11:15.184]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:15.184]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:15.184]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:15.184]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:15.184]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:15.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:15.184]  - attr(*, "already-done")= logi TRUE
[16:11:15.190] - reassign environment for ‘...future.FUN’
[16:11:15.191] - copied ‘...future.FUN’ to environment
[16:11:15.191] - copied ‘future.call.arguments’ to environment
[16:11:15.191] - copied ‘...future.elements_ii’ to environment
[16:11:15.191] - copied ‘...future.seeds_ii’ to environment
[16:11:15.191] - copied ‘...future.globals.maxSize’ to environment
[16:11:15.191] assign_globals() ... done
[16:11:15.191] plan(): Setting new future strategy stack:
[16:11:15.191] List of future strategies:
[16:11:15.191] 1. sequential:
[16:11:15.191]    - args: function (..., envir = parent.frame())
[16:11:15.191]    - tweaked: FALSE
[16:11:15.191]    - call: NULL
[16:11:15.192] plan(): nbrOfWorkers() = 1
[16:11:15.693] plan(): Setting new future strategy stack:
[16:11:15.694] List of future strategies:
[16:11:15.694] 1. multicore:
[16:11:15.694]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:15.694]    - tweaked: FALSE
[16:11:15.694]    - call: plan(strategy)
[16:11:15.697] plan(): nbrOfWorkers() = 1
[16:11:15.698] SequentialFuture started (and completed)
[16:11:15.698] - Launch lazy future ... done
[16:11:15.698] run() for ‘SequentialFuture’ ... done
[16:11:15.698] Created future:
[16:11:15.698] SequentialFuture:
[16:11:15.698] Label: ‘future_lapply-1’
[16:11:15.698] Expression:
[16:11:15.698] {
[16:11:15.698]     do.call(function(...) {
[16:11:15.698]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:15.698]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:15.698]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:15.698]             on.exit(options(oopts), add = TRUE)
[16:11:15.698]         }
[16:11:15.698]         {
[16:11:15.698]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:15.698]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:15.698]                 ...future.FUN(...future.X_jj, ...)
[16:11:15.698]             })
[16:11:15.698]         }
[16:11:15.698]     }, args = future.call.arguments)
[16:11:15.698] }
[16:11:15.698] Lazy evaluation: FALSE
[16:11:15.698] Asynchronous evaluation: FALSE
[16:11:15.698] Local evaluation: TRUE
[16:11:15.698] Environment: R_GlobalEnv
[16:11:15.698] Capture standard output: FALSE
[16:11:15.698] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:15.698] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:15.698] Packages: <none>
[16:11:15.698] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:15.698] Resolved: TRUE
[16:11:15.698] Value: 112 bytes of class ‘list’
[16:11:15.698] Early signaling: FALSE
[16:11:15.698] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:15.698] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:15.699] Chunk #1 of 1 ... DONE
[16:11:15.699] Launching 1 futures (chunks) ... DONE
[16:11:15.699] Resolving 1 futures (chunks) ...
[16:11:15.700] resolve() on list ...
[16:11:15.700]  recursive: 0
[16:11:15.700]  length: 1
[16:11:15.700] 
[16:11:15.700] resolved() for ‘SequentialFuture’ ...
[16:11:15.700] - state: ‘finished’
[16:11:15.700] - run: TRUE
[16:11:15.700] - result: ‘FutureResult’
[16:11:15.700] resolved() for ‘SequentialFuture’ ... done
[16:11:15.700] Future #1
[16:11:15.701] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:15.701] - nx: 1
[16:11:15.701] - relay: TRUE
[16:11:15.701] - stdout: TRUE
[16:11:15.701] - signal: TRUE
[16:11:15.701] - resignal: FALSE
[16:11:15.701] - force: TRUE
[16:11:15.701] - relayed: [n=1] FALSE
[16:11:15.701] - queued futures: [n=1] FALSE
[16:11:15.701]  - until=1
[16:11:15.701]  - relaying element #1
[16:11:15.702] - relayed: [n=1] TRUE
[16:11:15.702] - queued futures: [n=1] TRUE
[16:11:15.702] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:15.702]  length: 0 (resolved future 1)
[16:11:15.702] Relaying remaining futures
[16:11:15.702] signalConditionsASAP(NULL, pos=0) ...
[16:11:15.702] - nx: 1
[16:11:15.702] - relay: TRUE
[16:11:15.702] - stdout: TRUE
[16:11:15.702] - signal: TRUE
[16:11:15.703] - resignal: FALSE
[16:11:15.703] - force: TRUE
[16:11:15.703] - relayed: [n=1] TRUE
[16:11:15.703] - queued futures: [n=1] TRUE
 - flush all
[16:11:15.703] - relayed: [n=1] TRUE
[16:11:15.703] - queued futures: [n=1] TRUE
[16:11:15.703] signalConditionsASAP(NULL, pos=0) ... done
[16:11:15.703] resolve() on list ... DONE
[16:11:15.703]  - Number of value chunks collected: 1
[16:11:15.703] Resolving 1 futures (chunks) ... DONE
[16:11:15.704] Reducing values from 1 chunks ...
[16:11:15.704]  - Number of values collected after concatenation: 2
[16:11:15.704]  - Number of values expected: 2
[16:11:15.704] Reducing values from 1 chunks ... DONE
[16:11:15.704] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:11:15.704] future_lapply() ...
[16:11:15.708] Number of chunks: 1
[16:11:15.708] getGlobalsAndPackagesXApply() ...
[16:11:15.708]  - future.globals: TRUE
[16:11:15.708] getGlobalsAndPackages() ...
[16:11:15.709] Searching for globals...
[16:11:15.710] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:15.710] Searching for globals ... DONE
[16:11:15.710] Resolving globals: FALSE
[16:11:15.710] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:15.711] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:15.711] - globals: [1] ‘FUN’
[16:11:15.711] 
[16:11:15.711] getGlobalsAndPackages() ... DONE
[16:11:15.711]  - globals found/used: [n=1] ‘FUN’
[16:11:15.711]  - needed namespaces: [n=0] 
[16:11:15.711] Finding globals ... DONE
[16:11:15.712]  - use_args: TRUE
[16:11:15.712]  - Getting '...' globals ...
[16:11:15.712] resolve() on list ...
[16:11:15.712]  recursive: 0
[16:11:15.712]  length: 1
[16:11:15.712]  elements: ‘...’
[16:11:15.712]  length: 0 (resolved future 1)
[16:11:15.712] resolve() on list ... DONE
[16:11:15.713]    - '...' content: [n=0] 
[16:11:15.713] List of 1
[16:11:15.713]  $ ...: list()
[16:11:15.713]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:15.713]  - attr(*, "where")=List of 1
[16:11:15.713]   ..$ ...:<environment: 0x557e20c111c8> 
[16:11:15.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:15.713]  - attr(*, "resolved")= logi TRUE
[16:11:15.713]  - attr(*, "total_size")= num NA
[16:11:15.715]  - Getting '...' globals ... DONE
[16:11:15.715] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:15.715] List of 2
[16:11:15.715]  $ ...future.FUN:function (x)  
[16:11:15.715]  $ ...          : list()
[16:11:15.715]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:15.715]  - attr(*, "where")=List of 2
[16:11:15.715]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:15.715]   ..$ ...          :<environment: 0x557e20c111c8> 
[16:11:15.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:15.715]  - attr(*, "resolved")= logi FALSE
[16:11:15.715]  - attr(*, "total_size")= num 4720
[16:11:15.720] Packages to be attached in all futures: [n=0] 
[16:11:15.720] getGlobalsAndPackagesXApply() ... DONE
[16:11:15.720] Number of futures (= number of chunks): 1
[16:11:15.720] Launching 1 futures (chunks) ...
[16:11:15.721] Chunk #1 of 1 ...
[16:11:15.721]  - Finding globals in 'X' for chunk #1 ...
[16:11:15.721] getGlobalsAndPackages() ...
[16:11:15.721] Searching for globals...
[16:11:15.721] 
[16:11:15.721] Searching for globals ... DONE
[16:11:15.721] - globals: [0] <none>
[16:11:15.721] getGlobalsAndPackages() ... DONE
[16:11:15.721]    + additional globals found: [n=0] 
[16:11:15.722]    + additional namespaces needed: [n=0] 
[16:11:15.722]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:15.722]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:15.722]  - seeds: <none>
[16:11:15.722] getGlobalsAndPackages() ...
[16:11:15.722] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:15.722] Resolving globals: FALSE
[16:11:15.722] Tweak future expression to call with '...' arguments ...
[16:11:15.722] {
[16:11:15.722]     do.call(function(...) {
[16:11:15.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:15.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:15.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:15.722]             on.exit(options(oopts), add = TRUE)
[16:11:15.722]         }
[16:11:15.722]         {
[16:11:15.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:15.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:15.722]                 ...future.FUN(...future.X_jj, ...)
[16:11:15.722]             })
[16:11:15.722]         }
[16:11:15.722]     }, args = future.call.arguments)
[16:11:15.722] }
[16:11:15.723] Tweak future expression to call with '...' arguments ... DONE
[16:11:15.723] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:15.723] 
[16:11:15.723] getGlobalsAndPackages() ... DONE
[16:11:15.723] run() for ‘Future’ ...
[16:11:15.723] - state: ‘created’
[16:11:15.724] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:15.727] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:15.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:15.727]   - Field: ‘label’
[16:11:15.727]   - Field: ‘local’
[16:11:15.727]   - Field: ‘owner’
[16:11:15.727]   - Field: ‘envir’
[16:11:15.728]   - Field: ‘packages’
[16:11:15.728]   - Field: ‘gc’
[16:11:15.728]   - Field: ‘conditions’
[16:11:15.728]   - Field: ‘expr’
[16:11:15.728]   - Field: ‘uuid’
[16:11:15.728]   - Field: ‘seed’
[16:11:15.728]   - Field: ‘version’
[16:11:15.728]   - Field: ‘result’
[16:11:15.728]   - Field: ‘asynchronous’
[16:11:15.728]   - Field: ‘calls’
[16:11:15.729]   - Field: ‘globals’
[16:11:15.729]   - Field: ‘stdout’
[16:11:15.729]   - Field: ‘earlySignal’
[16:11:15.729]   - Field: ‘lazy’
[16:11:15.729]   - Field: ‘state’
[16:11:15.729] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:15.729] - Launch lazy future ...
[16:11:15.729] Packages needed by the future expression (n = 0): <none>
[16:11:15.729] Packages needed by future strategies (n = 0): <none>
[16:11:15.730] {
[16:11:15.730]     {
[16:11:15.730]         {
[16:11:15.730]             ...future.startTime <- base::Sys.time()
[16:11:15.730]             {
[16:11:15.730]                 {
[16:11:15.730]                   {
[16:11:15.730]                     base::local({
[16:11:15.730]                       has_future <- base::requireNamespace("future", 
[16:11:15.730]                         quietly = TRUE)
[16:11:15.730]                       if (has_future) {
[16:11:15.730]                         ns <- base::getNamespace("future")
[16:11:15.730]                         version <- ns[[".package"]][["version"]]
[16:11:15.730]                         if (is.null(version)) 
[16:11:15.730]                           version <- utils::packageVersion("future")
[16:11:15.730]                       }
[16:11:15.730]                       else {
[16:11:15.730]                         version <- NULL
[16:11:15.730]                       }
[16:11:15.730]                       if (!has_future || version < "1.8.0") {
[16:11:15.730]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:15.730]                           "", base::R.version$version.string), 
[16:11:15.730]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:15.730]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:15.730]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:15.730]                             "release", "version")], collapse = " "), 
[16:11:15.730]                           hostname = base::Sys.info()[["nodename"]])
[16:11:15.730]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:15.730]                           info)
[16:11:15.730]                         info <- base::paste(info, collapse = "; ")
[16:11:15.730]                         if (!has_future) {
[16:11:15.730]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:15.730]                             info)
[16:11:15.730]                         }
[16:11:15.730]                         else {
[16:11:15.730]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:15.730]                             info, version)
[16:11:15.730]                         }
[16:11:15.730]                         base::stop(msg)
[16:11:15.730]                       }
[16:11:15.730]                     })
[16:11:15.730]                   }
[16:11:15.730]                   options(future.plan = NULL)
[16:11:15.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:15.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:15.730]                 }
[16:11:15.730]                 ...future.workdir <- getwd()
[16:11:15.730]             }
[16:11:15.730]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:15.730]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:15.730]         }
[16:11:15.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:15.730]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:15.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:15.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:15.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:15.730]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:15.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:15.730]             base::names(...future.oldOptions))
[16:11:15.730]     }
[16:11:15.730]     if (FALSE) {
[16:11:15.730]     }
[16:11:15.730]     else {
[16:11:15.730]         if (TRUE) {
[16:11:15.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:15.730]                 open = "w")
[16:11:15.730]         }
[16:11:15.730]         else {
[16:11:15.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:15.730]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:15.730]         }
[16:11:15.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:15.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:15.730]             base::sink(type = "output", split = FALSE)
[16:11:15.730]             base::close(...future.stdout)
[16:11:15.730]         }, add = TRUE)
[16:11:15.730]     }
[16:11:15.730]     ...future.frame <- base::sys.nframe()
[16:11:15.730]     ...future.conditions <- base::list()
[16:11:15.730]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:15.730]     if (FALSE) {
[16:11:15.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:15.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:15.730]     }
[16:11:15.730]     ...future.result <- base::tryCatch({
[16:11:15.730]         base::withCallingHandlers({
[16:11:15.730]             ...future.value <- base::withVisible(base::local({
[16:11:15.730]                 do.call(function(...) {
[16:11:15.730]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:15.730]                   if (!identical(...future.globals.maxSize.org, 
[16:11:15.730]                     ...future.globals.maxSize)) {
[16:11:15.730]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:15.730]                     on.exit(options(oopts), add = TRUE)
[16:11:15.730]                   }
[16:11:15.730]                   {
[16:11:15.730]                     lapply(seq_along(...future.elements_ii), 
[16:11:15.730]                       FUN = function(jj) {
[16:11:15.730]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:15.730]                         ...future.FUN(...future.X_jj, ...)
[16:11:15.730]                       })
[16:11:15.730]                   }
[16:11:15.730]                 }, args = future.call.arguments)
[16:11:15.730]             }))
[16:11:15.730]             future::FutureResult(value = ...future.value$value, 
[16:11:15.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:15.730]                   ...future.rng), globalenv = if (FALSE) 
[16:11:15.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:15.730]                     ...future.globalenv.names))
[16:11:15.730]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:15.730]         }, condition = base::local({
[16:11:15.730]             c <- base::c
[16:11:15.730]             inherits <- base::inherits
[16:11:15.730]             invokeRestart <- base::invokeRestart
[16:11:15.730]             length <- base::length
[16:11:15.730]             list <- base::list
[16:11:15.730]             seq.int <- base::seq.int
[16:11:15.730]             signalCondition <- base::signalCondition
[16:11:15.730]             sys.calls <- base::sys.calls
[16:11:15.730]             `[[` <- base::`[[`
[16:11:15.730]             `+` <- base::`+`
[16:11:15.730]             `<<-` <- base::`<<-`
[16:11:15.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:15.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:15.730]                   3L)]
[16:11:15.730]             }
[16:11:15.730]             function(cond) {
[16:11:15.730]                 is_error <- inherits(cond, "error")
[16:11:15.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:15.730]                   NULL)
[16:11:15.730]                 if (is_error) {
[16:11:15.730]                   sessionInformation <- function() {
[16:11:15.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:15.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:15.730]                       search = base::search(), system = base::Sys.info())
[16:11:15.730]                   }
[16:11:15.730]                   ...future.conditions[[length(...future.conditions) + 
[16:11:15.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:15.730]                     cond$call), session = sessionInformation(), 
[16:11:15.730]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:15.730]                   signalCondition(cond)
[16:11:15.730]                 }
[16:11:15.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:15.730]                 "immediateCondition"))) {
[16:11:15.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:15.730]                   ...future.conditions[[length(...future.conditions) + 
[16:11:15.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:15.730]                   if (TRUE && !signal) {
[16:11:15.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:15.730]                     {
[16:11:15.730]                       inherits <- base::inherits
[16:11:15.730]                       invokeRestart <- base::invokeRestart
[16:11:15.730]                       is.null <- base::is.null
[16:11:15.730]                       muffled <- FALSE
[16:11:15.730]                       if (inherits(cond, "message")) {
[16:11:15.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:15.730]                         if (muffled) 
[16:11:15.730]                           invokeRestart("muffleMessage")
[16:11:15.730]                       }
[16:11:15.730]                       else if (inherits(cond, "warning")) {
[16:11:15.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:15.730]                         if (muffled) 
[16:11:15.730]                           invokeRestart("muffleWarning")
[16:11:15.730]                       }
[16:11:15.730]                       else if (inherits(cond, "condition")) {
[16:11:15.730]                         if (!is.null(pattern)) {
[16:11:15.730]                           computeRestarts <- base::computeRestarts
[16:11:15.730]                           grepl <- base::grepl
[16:11:15.730]                           restarts <- computeRestarts(cond)
[16:11:15.730]                           for (restart in restarts) {
[16:11:15.730]                             name <- restart$name
[16:11:15.730]                             if (is.null(name)) 
[16:11:15.730]                               next
[16:11:15.730]                             if (!grepl(pattern, name)) 
[16:11:15.730]                               next
[16:11:15.730]                             invokeRestart(restart)
[16:11:15.730]                             muffled <- TRUE
[16:11:15.730]                             break
[16:11:15.730]                           }
[16:11:15.730]                         }
[16:11:15.730]                       }
[16:11:15.730]                       invisible(muffled)
[16:11:15.730]                     }
[16:11:15.730]                     muffleCondition(cond, pattern = "^muffle")
[16:11:15.730]                   }
[16:11:15.730]                 }
[16:11:15.730]                 else {
[16:11:15.730]                   if (TRUE) {
[16:11:15.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:15.730]                     {
[16:11:15.730]                       inherits <- base::inherits
[16:11:15.730]                       invokeRestart <- base::invokeRestart
[16:11:15.730]                       is.null <- base::is.null
[16:11:15.730]                       muffled <- FALSE
[16:11:15.730]                       if (inherits(cond, "message")) {
[16:11:15.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:15.730]                         if (muffled) 
[16:11:15.730]                           invokeRestart("muffleMessage")
[16:11:15.730]                       }
[16:11:15.730]                       else if (inherits(cond, "warning")) {
[16:11:15.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:15.730]                         if (muffled) 
[16:11:15.730]                           invokeRestart("muffleWarning")
[16:11:15.730]                       }
[16:11:15.730]                       else if (inherits(cond, "condition")) {
[16:11:15.730]                         if (!is.null(pattern)) {
[16:11:15.730]                           computeRestarts <- base::computeRestarts
[16:11:15.730]                           grepl <- base::grepl
[16:11:15.730]                           restarts <- computeRestarts(cond)
[16:11:15.730]                           for (restart in restarts) {
[16:11:15.730]                             name <- restart$name
[16:11:15.730]                             if (is.null(name)) 
[16:11:15.730]                               next
[16:11:15.730]                             if (!grepl(pattern, name)) 
[16:11:15.730]                               next
[16:11:15.730]                             invokeRestart(restart)
[16:11:15.730]                             muffled <- TRUE
[16:11:15.730]                             break
[16:11:15.730]                           }
[16:11:15.730]                         }
[16:11:15.730]                       }
[16:11:15.730]                       invisible(muffled)
[16:11:15.730]                     }
[16:11:15.730]                     muffleCondition(cond, pattern = "^muffle")
[16:11:15.730]                   }
[16:11:15.730]                 }
[16:11:15.730]             }
[16:11:15.730]         }))
[16:11:15.730]     }, error = function(ex) {
[16:11:15.730]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:15.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:15.730]                 ...future.rng), started = ...future.startTime, 
[16:11:15.730]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:15.730]             version = "1.8"), class = "FutureResult")
[16:11:15.730]     }, finally = {
[16:11:15.730]         if (!identical(...future.workdir, getwd())) 
[16:11:15.730]             setwd(...future.workdir)
[16:11:15.730]         {
[16:11:15.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:15.730]                 ...future.oldOptions$nwarnings <- NULL
[16:11:15.730]             }
[16:11:15.730]             base::options(...future.oldOptions)
[16:11:15.730]             if (.Platform$OS.type == "windows") {
[16:11:15.730]                 old_names <- names(...future.oldEnvVars)
[16:11:15.730]                 envs <- base::Sys.getenv()
[16:11:15.730]                 names <- names(envs)
[16:11:15.730]                 common <- intersect(names, old_names)
[16:11:15.730]                 added <- setdiff(names, old_names)
[16:11:15.730]                 removed <- setdiff(old_names, names)
[16:11:15.730]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:15.730]                   envs[common]]
[16:11:15.730]                 NAMES <- toupper(changed)
[16:11:15.730]                 args <- list()
[16:11:15.730]                 for (kk in seq_along(NAMES)) {
[16:11:15.730]                   name <- changed[[kk]]
[16:11:15.730]                   NAME <- NAMES[[kk]]
[16:11:15.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:15.730]                     next
[16:11:15.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:15.730]                 }
[16:11:15.730]                 NAMES <- toupper(added)
[16:11:15.730]                 for (kk in seq_along(NAMES)) {
[16:11:15.730]                   name <- added[[kk]]
[16:11:15.730]                   NAME <- NAMES[[kk]]
[16:11:15.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:15.730]                     next
[16:11:15.730]                   args[[name]] <- ""
[16:11:15.730]                 }
[16:11:15.730]                 NAMES <- toupper(removed)
[16:11:15.730]                 for (kk in seq_along(NAMES)) {
[16:11:15.730]                   name <- removed[[kk]]
[16:11:15.730]                   NAME <- NAMES[[kk]]
[16:11:15.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:15.730]                     next
[16:11:15.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:15.730]                 }
[16:11:15.730]                 if (length(args) > 0) 
[16:11:15.730]                   base::do.call(base::Sys.setenv, args = args)
[16:11:15.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:15.730]             }
[16:11:15.730]             else {
[16:11:15.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:15.730]             }
[16:11:15.730]             {
[16:11:15.730]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:15.730]                   0L) {
[16:11:15.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:15.730]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:15.730]                   base::options(opts)
[16:11:15.730]                 }
[16:11:15.730]                 {
[16:11:15.730]                   {
[16:11:15.730]                     NULL
[16:11:15.730]                     RNGkind("Mersenne-Twister")
[16:11:15.730]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:15.730]                       inherits = FALSE)
[16:11:15.730]                   }
[16:11:15.730]                   options(future.plan = NULL)
[16:11:15.730]                   if (is.na(NA_character_)) 
[16:11:15.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:15.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:15.730]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:15.730]                     envir = parent.frame()) 
[16:11:15.730]                   {
[16:11:15.730]                     default_workers <- missing(workers)
[16:11:15.730]                     if (is.function(workers)) 
[16:11:15.730]                       workers <- workers()
[16:11:15.730]                     workers <- structure(as.integer(workers), 
[16:11:15.730]                       class = class(workers))
[16:11:15.730]                     stop_if_not(is.finite(workers), workers >= 
[16:11:15.730]                       1L)
[16:11:15.730]                     if ((workers == 1L && !inherits(workers, 
[16:11:15.730]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:15.730]                       if (default_workers) 
[16:11:15.730]                         supportsMulticore(warn = TRUE)
[16:11:15.730]                       return(sequential(..., envir = envir))
[16:11:15.730]                     }
[16:11:15.730]                     oopts <- options(mc.cores = workers)
[16:11:15.730]                     on.exit(options(oopts))
[16:11:15.730]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:15.730]                       envir = envir)
[16:11:15.730]                     if (!future$lazy) 
[16:11:15.730]                       future <- run(future)
[16:11:15.730]                     invisible(future)
[16:11:15.730]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:15.730]                 }
[16:11:15.730]             }
[16:11:15.730]         }
[16:11:15.730]     })
[16:11:15.730]     if (TRUE) {
[16:11:15.730]         base::sink(type = "output", split = FALSE)
[16:11:15.730]         if (TRUE) {
[16:11:15.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:15.730]         }
[16:11:15.730]         else {
[16:11:15.730]             ...future.result["stdout"] <- base::list(NULL)
[16:11:15.730]         }
[16:11:15.730]         base::close(...future.stdout)
[16:11:15.730]         ...future.stdout <- NULL
[16:11:15.730]     }
[16:11:15.730]     ...future.result$conditions <- ...future.conditions
[16:11:15.730]     ...future.result$finished <- base::Sys.time()
[16:11:15.730]     ...future.result
[16:11:15.730] }
[16:11:15.732] assign_globals() ...
[16:11:15.732] List of 5
[16:11:15.732]  $ ...future.FUN            :function (x)  
[16:11:15.732]  $ future.call.arguments    : list()
[16:11:15.732]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:15.732]  $ ...future.elements_ii    :List of 2
[16:11:15.732]   ..$ : int 1
[16:11:15.732]   ..$ : int 0
[16:11:15.732]  $ ...future.seeds_ii       : NULL
[16:11:15.732]  $ ...future.globals.maxSize: NULL
[16:11:15.732]  - attr(*, "resolved")= logi FALSE
[16:11:15.732]  - attr(*, "total_size")= num 4720
[16:11:15.732]  - attr(*, "where")=List of 5
[16:11:15.732]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:15.732]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:15.732]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:15.732]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:15.732]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:15.732]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:15.732]  - attr(*, "already-done")= logi TRUE
[16:11:15.736] - reassign environment for ‘...future.FUN’
[16:11:15.736] - copied ‘...future.FUN’ to environment
[16:11:15.737] - copied ‘future.call.arguments’ to environment
[16:11:15.737] - copied ‘...future.elements_ii’ to environment
[16:11:15.737] - copied ‘...future.seeds_ii’ to environment
[16:11:15.737] - copied ‘...future.globals.maxSize’ to environment
[16:11:15.737] assign_globals() ... done
[16:11:15.737] plan(): Setting new future strategy stack:
[16:11:15.737] List of future strategies:
[16:11:15.737] 1. sequential:
[16:11:15.737]    - args: function (..., envir = parent.frame())
[16:11:15.737]    - tweaked: FALSE
[16:11:15.737]    - call: NULL
[16:11:15.738] plan(): nbrOfWorkers() = 1
[16:11:16.239] plan(): Setting new future strategy stack:
[16:11:16.239] List of future strategies:
[16:11:16.239] 1. multicore:
[16:11:16.239]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:16.239]    - tweaked: FALSE
[16:11:16.239]    - call: plan(strategy)
[16:11:16.244] plan(): nbrOfWorkers() = 1
[16:11:16.244] SequentialFuture started (and completed)
[16:11:16.244] - Launch lazy future ... done
[16:11:16.244] run() for ‘SequentialFuture’ ... done
[16:11:16.244] Created future:
[16:11:16.244] SequentialFuture:
[16:11:16.244] Label: ‘future_lapply-1’
[16:11:16.244] Expression:
[16:11:16.244] {
[16:11:16.244]     do.call(function(...) {
[16:11:16.244]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:16.244]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:16.244]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:16.244]             on.exit(options(oopts), add = TRUE)
[16:11:16.244]         }
[16:11:16.244]         {
[16:11:16.244]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:16.244]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:16.244]                 ...future.FUN(...future.X_jj, ...)
[16:11:16.244]             })
[16:11:16.244]         }
[16:11:16.244]     }, args = future.call.arguments)
[16:11:16.244] }
[16:11:16.244] Lazy evaluation: FALSE
[16:11:16.244] Asynchronous evaluation: FALSE
[16:11:16.244] Local evaluation: TRUE
[16:11:16.244] Environment: R_GlobalEnv
[16:11:16.244] Capture standard output: TRUE
[16:11:16.244] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:16.244] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:16.244] Packages: <none>
[16:11:16.244] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:16.244] Resolved: TRUE
[16:11:16.244] Value: 112 bytes of class ‘list’
[16:11:16.244] Early signaling: FALSE
[16:11:16.244] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:16.244] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:16.245] Chunk #1 of 1 ... DONE
[16:11:16.246] Launching 1 futures (chunks) ... DONE
[16:11:16.246] Resolving 1 futures (chunks) ...
[16:11:16.246] resolve() on list ...
[16:11:16.246]  recursive: 0
[16:11:16.246]  length: 1
[16:11:16.246] 
[16:11:16.246] resolved() for ‘SequentialFuture’ ...
[16:11:16.246] - state: ‘finished’
[16:11:16.246] - run: TRUE
[16:11:16.246] - result: ‘FutureResult’
[16:11:16.247] resolved() for ‘SequentialFuture’ ... done
[16:11:16.247] Future #1
[16:11:16.249] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:16.249] - nx: 1
[16:11:16.249] - relay: TRUE
[16:11:16.249] - stdout: TRUE
[16:11:16.249] - signal: TRUE
[16:11:16.249] - resignal: FALSE
[16:11:16.249] - force: TRUE
[16:11:16.249] - relayed: [n=1] FALSE
[16:11:16.249] - queued futures: [n=1] FALSE
[16:11:16.249]  - until=1
[16:11:16.250]  - relaying element #1
[16:11:16.250] - relayed: [n=1] TRUE
[16:11:16.250] - queued futures: [n=1] TRUE
[16:11:16.250] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:16.250]  length: 0 (resolved future 1)
[16:11:16.250] Relaying remaining futures
[16:11:16.250] signalConditionsASAP(NULL, pos=0) ...
[16:11:16.250] - nx: 1
[16:11:16.250] - relay: TRUE
[16:11:16.250] - stdout: TRUE
[16:11:16.251] - signal: TRUE
[16:11:16.251] - resignal: FALSE
[16:11:16.251] - force: TRUE
[16:11:16.251] - relayed: [n=1] TRUE
[16:11:16.251] - queued futures: [n=1] TRUE
 - flush all
[16:11:16.251] - relayed: [n=1] TRUE
[16:11:16.251] - queued futures: [n=1] TRUE
[16:11:16.251] signalConditionsASAP(NULL, pos=0) ... done
[16:11:16.251] resolve() on list ... DONE
[16:11:16.251]  - Number of value chunks collected: 1
[16:11:16.252] Resolving 1 futures (chunks) ... DONE
[16:11:16.252] Reducing values from 1 chunks ...
[16:11:16.252]  - Number of values collected after concatenation: 2
[16:11:16.252]  - Number of values expected: 2
[16:11:16.252] Reducing values from 1 chunks ... DONE
[16:11:16.252] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:11:16.252] future_lapply() ...
[16:11:16.256] Number of chunks: 1
[16:11:16.257] getGlobalsAndPackagesXApply() ...
[16:11:16.257]  - future.globals: TRUE
[16:11:16.257] getGlobalsAndPackages() ...
[16:11:16.257] Searching for globals...
[16:11:16.258] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:16.258] Searching for globals ... DONE
[16:11:16.258] Resolving globals: FALSE
[16:11:16.259] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:16.259] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:16.259] - globals: [1] ‘FUN’
[16:11:16.259] 
[16:11:16.260] getGlobalsAndPackages() ... DONE
[16:11:16.260]  - globals found/used: [n=1] ‘FUN’
[16:11:16.260]  - needed namespaces: [n=0] 
[16:11:16.260] Finding globals ... DONE
[16:11:16.260]  - use_args: TRUE
[16:11:16.260]  - Getting '...' globals ...
[16:11:16.260] resolve() on list ...
[16:11:16.260]  recursive: 0
[16:11:16.261]  length: 1
[16:11:16.261]  elements: ‘...’
[16:11:16.261]  length: 0 (resolved future 1)
[16:11:16.261] resolve() on list ... DONE
[16:11:16.261]    - '...' content: [n=0] 
[16:11:16.261] List of 1
[16:11:16.261]  $ ...: list()
[16:11:16.261]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:16.261]  - attr(*, "where")=List of 1
[16:11:16.261]   ..$ ...:<environment: 0x557e1eb3dee8> 
[16:11:16.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:16.261]  - attr(*, "resolved")= logi TRUE
[16:11:16.261]  - attr(*, "total_size")= num NA
[16:11:16.264]  - Getting '...' globals ... DONE
[16:11:16.264] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:16.264] List of 2
[16:11:16.264]  $ ...future.FUN:function (x)  
[16:11:16.264]  $ ...          : list()
[16:11:16.264]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:16.264]  - attr(*, "where")=List of 2
[16:11:16.264]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:16.264]   ..$ ...          :<environment: 0x557e1eb3dee8> 
[16:11:16.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:16.264]  - attr(*, "resolved")= logi FALSE
[16:11:16.264]  - attr(*, "total_size")= num 4720
[16:11:16.267] Packages to be attached in all futures: [n=0] 
[16:11:16.267] getGlobalsAndPackagesXApply() ... DONE
[16:11:16.267] Number of futures (= number of chunks): 1
[16:11:16.267] Launching 1 futures (chunks) ...
[16:11:16.267] Chunk #1 of 1 ...
[16:11:16.267]  - Finding globals in 'X' for chunk #1 ...
[16:11:16.267] getGlobalsAndPackages() ...
[16:11:16.267] Searching for globals...
[16:11:16.268] 
[16:11:16.268] Searching for globals ... DONE
[16:11:16.268] - globals: [0] <none>
[16:11:16.268] getGlobalsAndPackages() ... DONE
[16:11:16.268]    + additional globals found: [n=0] 
[16:11:16.268]    + additional namespaces needed: [n=0] 
[16:11:16.268]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:16.268]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:16.269]  - seeds: <none>
[16:11:16.269] getGlobalsAndPackages() ...
[16:11:16.269] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:16.269] Resolving globals: FALSE
[16:11:16.269] Tweak future expression to call with '...' arguments ...
[16:11:16.269] {
[16:11:16.269]     do.call(function(...) {
[16:11:16.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:16.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:16.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:16.269]             on.exit(options(oopts), add = TRUE)
[16:11:16.269]         }
[16:11:16.269]         {
[16:11:16.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:16.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:16.269]                 ...future.FUN(...future.X_jj, ...)
[16:11:16.269]             })
[16:11:16.269]         }
[16:11:16.269]     }, args = future.call.arguments)
[16:11:16.269] }
[16:11:16.269] Tweak future expression to call with '...' arguments ... DONE
[16:11:16.270] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:16.270] 
[16:11:16.270] getGlobalsAndPackages() ... DONE
[16:11:16.270] run() for ‘Future’ ...
[16:11:16.270] - state: ‘created’
[16:11:16.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:16.274] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:16.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:16.275]   - Field: ‘label’
[16:11:16.275]   - Field: ‘local’
[16:11:16.275]   - Field: ‘owner’
[16:11:16.275]   - Field: ‘envir’
[16:11:16.275]   - Field: ‘packages’
[16:11:16.275]   - Field: ‘gc’
[16:11:16.275]   - Field: ‘conditions’
[16:11:16.275]   - Field: ‘expr’
[16:11:16.276]   - Field: ‘uuid’
[16:11:16.276]   - Field: ‘seed’
[16:11:16.278]   - Field: ‘version’
[16:11:16.278]   - Field: ‘result’
[16:11:16.278]   - Field: ‘asynchronous’
[16:11:16.278]   - Field: ‘calls’
[16:11:16.278]   - Field: ‘globals’
[16:11:16.278]   - Field: ‘stdout’
[16:11:16.278]   - Field: ‘earlySignal’
[16:11:16.278]   - Field: ‘lazy’
[16:11:16.278]   - Field: ‘state’
[16:11:16.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:16.279] - Launch lazy future ...
[16:11:16.279] Packages needed by the future expression (n = 0): <none>
[16:11:16.279] Packages needed by future strategies (n = 0): <none>
[16:11:16.279] {
[16:11:16.279]     {
[16:11:16.279]         {
[16:11:16.279]             ...future.startTime <- base::Sys.time()
[16:11:16.279]             {
[16:11:16.279]                 {
[16:11:16.279]                   {
[16:11:16.279]                     base::local({
[16:11:16.279]                       has_future <- base::requireNamespace("future", 
[16:11:16.279]                         quietly = TRUE)
[16:11:16.279]                       if (has_future) {
[16:11:16.279]                         ns <- base::getNamespace("future")
[16:11:16.279]                         version <- ns[[".package"]][["version"]]
[16:11:16.279]                         if (is.null(version)) 
[16:11:16.279]                           version <- utils::packageVersion("future")
[16:11:16.279]                       }
[16:11:16.279]                       else {
[16:11:16.279]                         version <- NULL
[16:11:16.279]                       }
[16:11:16.279]                       if (!has_future || version < "1.8.0") {
[16:11:16.279]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:16.279]                           "", base::R.version$version.string), 
[16:11:16.279]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:16.279]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:16.279]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:16.279]                             "release", "version")], collapse = " "), 
[16:11:16.279]                           hostname = base::Sys.info()[["nodename"]])
[16:11:16.279]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:16.279]                           info)
[16:11:16.279]                         info <- base::paste(info, collapse = "; ")
[16:11:16.279]                         if (!has_future) {
[16:11:16.279]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:16.279]                             info)
[16:11:16.279]                         }
[16:11:16.279]                         else {
[16:11:16.279]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:16.279]                             info, version)
[16:11:16.279]                         }
[16:11:16.279]                         base::stop(msg)
[16:11:16.279]                       }
[16:11:16.279]                     })
[16:11:16.279]                   }
[16:11:16.279]                   options(future.plan = NULL)
[16:11:16.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:16.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:16.279]                 }
[16:11:16.279]                 ...future.workdir <- getwd()
[16:11:16.279]             }
[16:11:16.279]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:16.279]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:16.279]         }
[16:11:16.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:16.279]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:16.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:16.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:16.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:16.279]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:16.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:16.279]             base::names(...future.oldOptions))
[16:11:16.279]     }
[16:11:16.279]     if (TRUE) {
[16:11:16.279]     }
[16:11:16.279]     else {
[16:11:16.279]         if (NA) {
[16:11:16.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:16.279]                 open = "w")
[16:11:16.279]         }
[16:11:16.279]         else {
[16:11:16.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:16.279]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:16.279]         }
[16:11:16.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:16.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:16.279]             base::sink(type = "output", split = FALSE)
[16:11:16.279]             base::close(...future.stdout)
[16:11:16.279]         }, add = TRUE)
[16:11:16.279]     }
[16:11:16.279]     ...future.frame <- base::sys.nframe()
[16:11:16.279]     ...future.conditions <- base::list()
[16:11:16.279]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:16.279]     if (FALSE) {
[16:11:16.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:16.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:16.279]     }
[16:11:16.279]     ...future.result <- base::tryCatch({
[16:11:16.279]         base::withCallingHandlers({
[16:11:16.279]             ...future.value <- base::withVisible(base::local({
[16:11:16.279]                 do.call(function(...) {
[16:11:16.279]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:16.279]                   if (!identical(...future.globals.maxSize.org, 
[16:11:16.279]                     ...future.globals.maxSize)) {
[16:11:16.279]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:16.279]                     on.exit(options(oopts), add = TRUE)
[16:11:16.279]                   }
[16:11:16.279]                   {
[16:11:16.279]                     lapply(seq_along(...future.elements_ii), 
[16:11:16.279]                       FUN = function(jj) {
[16:11:16.279]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:16.279]                         ...future.FUN(...future.X_jj, ...)
[16:11:16.279]                       })
[16:11:16.279]                   }
[16:11:16.279]                 }, args = future.call.arguments)
[16:11:16.279]             }))
[16:11:16.279]             future::FutureResult(value = ...future.value$value, 
[16:11:16.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:16.279]                   ...future.rng), globalenv = if (FALSE) 
[16:11:16.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:16.279]                     ...future.globalenv.names))
[16:11:16.279]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:16.279]         }, condition = base::local({
[16:11:16.279]             c <- base::c
[16:11:16.279]             inherits <- base::inherits
[16:11:16.279]             invokeRestart <- base::invokeRestart
[16:11:16.279]             length <- base::length
[16:11:16.279]             list <- base::list
[16:11:16.279]             seq.int <- base::seq.int
[16:11:16.279]             signalCondition <- base::signalCondition
[16:11:16.279]             sys.calls <- base::sys.calls
[16:11:16.279]             `[[` <- base::`[[`
[16:11:16.279]             `+` <- base::`+`
[16:11:16.279]             `<<-` <- base::`<<-`
[16:11:16.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:16.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:16.279]                   3L)]
[16:11:16.279]             }
[16:11:16.279]             function(cond) {
[16:11:16.279]                 is_error <- inherits(cond, "error")
[16:11:16.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:16.279]                   NULL)
[16:11:16.279]                 if (is_error) {
[16:11:16.279]                   sessionInformation <- function() {
[16:11:16.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:16.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:16.279]                       search = base::search(), system = base::Sys.info())
[16:11:16.279]                   }
[16:11:16.279]                   ...future.conditions[[length(...future.conditions) + 
[16:11:16.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:16.279]                     cond$call), session = sessionInformation(), 
[16:11:16.279]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:16.279]                   signalCondition(cond)
[16:11:16.279]                 }
[16:11:16.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:16.279]                 "immediateCondition"))) {
[16:11:16.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:16.279]                   ...future.conditions[[length(...future.conditions) + 
[16:11:16.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:16.279]                   if (TRUE && !signal) {
[16:11:16.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:16.279]                     {
[16:11:16.279]                       inherits <- base::inherits
[16:11:16.279]                       invokeRestart <- base::invokeRestart
[16:11:16.279]                       is.null <- base::is.null
[16:11:16.279]                       muffled <- FALSE
[16:11:16.279]                       if (inherits(cond, "message")) {
[16:11:16.279]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:16.279]                         if (muffled) 
[16:11:16.279]                           invokeRestart("muffleMessage")
[16:11:16.279]                       }
[16:11:16.279]                       else if (inherits(cond, "warning")) {
[16:11:16.279]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:16.279]                         if (muffled) 
[16:11:16.279]                           invokeRestart("muffleWarning")
[16:11:16.279]                       }
[16:11:16.279]                       else if (inherits(cond, "condition")) {
[16:11:16.279]                         if (!is.null(pattern)) {
[16:11:16.279]                           computeRestarts <- base::computeRestarts
[16:11:16.279]                           grepl <- base::grepl
[16:11:16.279]                           restarts <- computeRestarts(cond)
[16:11:16.279]                           for (restart in restarts) {
[16:11:16.279]                             name <- restart$name
[16:11:16.279]                             if (is.null(name)) 
[16:11:16.279]                               next
[16:11:16.279]                             if (!grepl(pattern, name)) 
[16:11:16.279]                               next
[16:11:16.279]                             invokeRestart(restart)
[16:11:16.279]                             muffled <- TRUE
[16:11:16.279]                             break
[16:11:16.279]                           }
[16:11:16.279]                         }
[16:11:16.279]                       }
[16:11:16.279]                       invisible(muffled)
[16:11:16.279]                     }
[16:11:16.279]                     muffleCondition(cond, pattern = "^muffle")
[16:11:16.279]                   }
[16:11:16.279]                 }
[16:11:16.279]                 else {
[16:11:16.279]                   if (TRUE) {
[16:11:16.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:16.279]                     {
[16:11:16.279]                       inherits <- base::inherits
[16:11:16.279]                       invokeRestart <- base::invokeRestart
[16:11:16.279]                       is.null <- base::is.null
[16:11:16.279]                       muffled <- FALSE
[16:11:16.279]                       if (inherits(cond, "message")) {
[16:11:16.279]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:16.279]                         if (muffled) 
[16:11:16.279]                           invokeRestart("muffleMessage")
[16:11:16.279]                       }
[16:11:16.279]                       else if (inherits(cond, "warning")) {
[16:11:16.279]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:16.279]                         if (muffled) 
[16:11:16.279]                           invokeRestart("muffleWarning")
[16:11:16.279]                       }
[16:11:16.279]                       else if (inherits(cond, "condition")) {
[16:11:16.279]                         if (!is.null(pattern)) {
[16:11:16.279]                           computeRestarts <- base::computeRestarts
[16:11:16.279]                           grepl <- base::grepl
[16:11:16.279]                           restarts <- computeRestarts(cond)
[16:11:16.279]                           for (restart in restarts) {
[16:11:16.279]                             name <- restart$name
[16:11:16.279]                             if (is.null(name)) 
[16:11:16.279]                               next
[16:11:16.279]                             if (!grepl(pattern, name)) 
[16:11:16.279]                               next
[16:11:16.279]                             invokeRestart(restart)
[16:11:16.279]                             muffled <- TRUE
[16:11:16.279]                             break
[16:11:16.279]                           }
[16:11:16.279]                         }
[16:11:16.279]                       }
[16:11:16.279]                       invisible(muffled)
[16:11:16.279]                     }
[16:11:16.279]                     muffleCondition(cond, pattern = "^muffle")
[16:11:16.279]                   }
[16:11:16.279]                 }
[16:11:16.279]             }
[16:11:16.279]         }))
[16:11:16.279]     }, error = function(ex) {
[16:11:16.279]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:16.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:16.279]                 ...future.rng), started = ...future.startTime, 
[16:11:16.279]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:16.279]             version = "1.8"), class = "FutureResult")
[16:11:16.279]     }, finally = {
[16:11:16.279]         if (!identical(...future.workdir, getwd())) 
[16:11:16.279]             setwd(...future.workdir)
[16:11:16.279]         {
[16:11:16.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:16.279]                 ...future.oldOptions$nwarnings <- NULL
[16:11:16.279]             }
[16:11:16.279]             base::options(...future.oldOptions)
[16:11:16.279]             if (.Platform$OS.type == "windows") {
[16:11:16.279]                 old_names <- names(...future.oldEnvVars)
[16:11:16.279]                 envs <- base::Sys.getenv()
[16:11:16.279]                 names <- names(envs)
[16:11:16.279]                 common <- intersect(names, old_names)
[16:11:16.279]                 added <- setdiff(names, old_names)
[16:11:16.279]                 removed <- setdiff(old_names, names)
[16:11:16.279]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:16.279]                   envs[common]]
[16:11:16.279]                 NAMES <- toupper(changed)
[16:11:16.279]                 args <- list()
[16:11:16.279]                 for (kk in seq_along(NAMES)) {
[16:11:16.279]                   name <- changed[[kk]]
[16:11:16.279]                   NAME <- NAMES[[kk]]
[16:11:16.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:16.279]                     next
[16:11:16.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:16.279]                 }
[16:11:16.279]                 NAMES <- toupper(added)
[16:11:16.279]                 for (kk in seq_along(NAMES)) {
[16:11:16.279]                   name <- added[[kk]]
[16:11:16.279]                   NAME <- NAMES[[kk]]
[16:11:16.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:16.279]                     next
[16:11:16.279]                   args[[name]] <- ""
[16:11:16.279]                 }
[16:11:16.279]                 NAMES <- toupper(removed)
[16:11:16.279]                 for (kk in seq_along(NAMES)) {
[16:11:16.279]                   name <- removed[[kk]]
[16:11:16.279]                   NAME <- NAMES[[kk]]
[16:11:16.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:16.279]                     next
[16:11:16.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:16.279]                 }
[16:11:16.279]                 if (length(args) > 0) 
[16:11:16.279]                   base::do.call(base::Sys.setenv, args = args)
[16:11:16.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:16.279]             }
[16:11:16.279]             else {
[16:11:16.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:16.279]             }
[16:11:16.279]             {
[16:11:16.279]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:16.279]                   0L) {
[16:11:16.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:16.279]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:16.279]                   base::options(opts)
[16:11:16.279]                 }
[16:11:16.279]                 {
[16:11:16.279]                   {
[16:11:16.279]                     NULL
[16:11:16.279]                     RNGkind("Mersenne-Twister")
[16:11:16.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:16.279]                       inherits = FALSE)
[16:11:16.279]                   }
[16:11:16.279]                   options(future.plan = NULL)
[16:11:16.279]                   if (is.na(NA_character_)) 
[16:11:16.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:16.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:16.279]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:16.279]                     envir = parent.frame()) 
[16:11:16.279]                   {
[16:11:16.279]                     default_workers <- missing(workers)
[16:11:16.279]                     if (is.function(workers)) 
[16:11:16.279]                       workers <- workers()
[16:11:16.279]                     workers <- structure(as.integer(workers), 
[16:11:16.279]                       class = class(workers))
[16:11:16.279]                     stop_if_not(is.finite(workers), workers >= 
[16:11:16.279]                       1L)
[16:11:16.279]                     if ((workers == 1L && !inherits(workers, 
[16:11:16.279]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:16.279]                       if (default_workers) 
[16:11:16.279]                         supportsMulticore(warn = TRUE)
[16:11:16.279]                       return(sequential(..., envir = envir))
[16:11:16.279]                     }
[16:11:16.279]                     oopts <- options(mc.cores = workers)
[16:11:16.279]                     on.exit(options(oopts))
[16:11:16.279]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:16.279]                       envir = envir)
[16:11:16.279]                     if (!future$lazy) 
[16:11:16.279]                       future <- run(future)
[16:11:16.279]                     invisible(future)
[16:11:16.279]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:16.279]                 }
[16:11:16.279]             }
[16:11:16.279]         }
[16:11:16.279]     })
[16:11:16.279]     if (FALSE) {
[16:11:16.279]         base::sink(type = "output", split = FALSE)
[16:11:16.279]         if (NA) {
[16:11:16.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:16.279]         }
[16:11:16.279]         else {
[16:11:16.279]             ...future.result["stdout"] <- base::list(NULL)
[16:11:16.279]         }
[16:11:16.279]         base::close(...future.stdout)
[16:11:16.279]         ...future.stdout <- NULL
[16:11:16.279]     }
[16:11:16.279]     ...future.result$conditions <- ...future.conditions
[16:11:16.279]     ...future.result$finished <- base::Sys.time()
[16:11:16.279]     ...future.result
[16:11:16.279] }
[16:11:16.281] assign_globals() ...
[16:11:16.281] List of 5
[16:11:16.281]  $ ...future.FUN            :function (x)  
[16:11:16.281]  $ future.call.arguments    : list()
[16:11:16.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:16.281]  $ ...future.elements_ii    :List of 2
[16:11:16.281]   ..$ : int 1
[16:11:16.281]   ..$ : int 0
[16:11:16.281]  $ ...future.seeds_ii       : NULL
[16:11:16.281]  $ ...future.globals.maxSize: NULL
[16:11:16.281]  - attr(*, "resolved")= logi FALSE
[16:11:16.281]  - attr(*, "total_size")= num 4720
[16:11:16.281]  - attr(*, "where")=List of 5
[16:11:16.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:16.281]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:16.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:16.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:16.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:16.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:16.281]  - attr(*, "already-done")= logi TRUE
[16:11:16.287] - reassign environment for ‘...future.FUN’
[16:11:16.287] - copied ‘...future.FUN’ to environment
[16:11:16.287] - copied ‘future.call.arguments’ to environment
[16:11:16.287] - copied ‘...future.elements_ii’ to environment
[16:11:16.287] - copied ‘...future.seeds_ii’ to environment
[16:11:16.287] - copied ‘...future.globals.maxSize’ to environment
[16:11:16.287] assign_globals() ... done
[16:11:16.287] plan(): Setting new future strategy stack:
[16:11:16.288] List of future strategies:
[16:11:16.288] 1. sequential:
[16:11:16.288]    - args: function (..., envir = parent.frame())
[16:11:16.288]    - tweaked: FALSE
[16:11:16.288]    - call: NULL
[16:11:16.288] plan(): nbrOfWorkers() = 1
[16:11:16.790] plan(): Setting new future strategy stack:
[16:11:16.790] List of future strategies:
[16:11:16.790] 1. multicore:
[16:11:16.790]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:16.790]    - tweaked: FALSE
[16:11:16.790]    - call: plan(strategy)
[16:11:16.794] plan(): nbrOfWorkers() = 1
[16:11:16.794] SequentialFuture started (and completed)
[16:11:16.794] - Launch lazy future ... done
[16:11:16.794] run() for ‘SequentialFuture’ ... done
[16:11:16.794] Created future:
[16:11:16.794] SequentialFuture:
[16:11:16.794] Label: ‘future_lapply-1’
[16:11:16.794] Expression:
[16:11:16.794] {
[16:11:16.794]     do.call(function(...) {
[16:11:16.794]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:16.794]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:16.794]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:16.794]             on.exit(options(oopts), add = TRUE)
[16:11:16.794]         }
[16:11:16.794]         {
[16:11:16.794]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:16.794]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:16.794]                 ...future.FUN(...future.X_jj, ...)
[16:11:16.794]             })
[16:11:16.794]         }
[16:11:16.794]     }, args = future.call.arguments)
[16:11:16.794] }
[16:11:16.794] Lazy evaluation: FALSE
[16:11:16.794] Asynchronous evaluation: FALSE
[16:11:16.794] Local evaluation: TRUE
[16:11:16.794] Environment: R_GlobalEnv
[16:11:16.794] Capture standard output: NA
[16:11:16.794] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:16.794] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:16.794] Packages: <none>
[16:11:16.794] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:16.794] Resolved: TRUE
[16:11:16.794] Value: 112 bytes of class ‘list’
[16:11:16.794] Early signaling: FALSE
[16:11:16.794] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:16.794] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:16.796] Chunk #1 of 1 ... DONE
[16:11:16.796] Launching 1 futures (chunks) ... DONE
[16:11:16.796] Resolving 1 futures (chunks) ...
[16:11:16.796] resolve() on list ...
[16:11:16.796]  recursive: 0
[16:11:16.796]  length: 1
[16:11:16.796] 
[16:11:16.796] resolved() for ‘SequentialFuture’ ...
[16:11:16.796] - state: ‘finished’
[16:11:16.796] - run: TRUE
[16:11:16.797] - result: ‘FutureResult’
[16:11:16.797] resolved() for ‘SequentialFuture’ ... done
[16:11:16.797] Future #1
[16:11:16.797] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:16.797] - nx: 1
[16:11:16.797] - relay: TRUE
[16:11:16.797] - stdout: TRUE
[16:11:16.797] - signal: TRUE
[16:11:16.797] - resignal: FALSE
[16:11:16.797] - force: TRUE
[16:11:16.797] - relayed: [n=1] FALSE
[16:11:16.798] - queued futures: [n=1] FALSE
[16:11:16.798]  - until=1
[16:11:16.798]  - relaying element #1
[16:11:16.798] - relayed: [n=1] TRUE
[16:11:16.798] - queued futures: [n=1] TRUE
[16:11:16.798] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:16.798]  length: 0 (resolved future 1)
[16:11:16.798] Relaying remaining futures
[16:11:16.798] signalConditionsASAP(NULL, pos=0) ...
[16:11:16.798] - nx: 1
[16:11:16.799] - relay: TRUE
[16:11:16.799] - stdout: TRUE
[16:11:16.799] - signal: TRUE
[16:11:16.799] - resignal: FALSE
[16:11:16.799] - force: TRUE
[16:11:16.799] - relayed: [n=1] TRUE
[16:11:16.799] - queued futures: [n=1] TRUE
 - flush all
[16:11:16.799] - relayed: [n=1] TRUE
[16:11:16.799] - queued futures: [n=1] TRUE
[16:11:16.799] signalConditionsASAP(NULL, pos=0) ... done
[16:11:16.799] resolve() on list ... DONE
[16:11:16.800]  - Number of value chunks collected: 1
[16:11:16.800] Resolving 1 futures (chunks) ... DONE
[16:11:16.800] Reducing values from 1 chunks ...
[16:11:16.800]  - Number of values collected after concatenation: 2
[16:11:16.800]  - Number of values expected: 2
[16:11:16.800] Reducing values from 1 chunks ... DONE
[16:11:16.800] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:11:16.801] future_mapply() ...
[16:11:16.804] Number of chunks: 1
[16:11:16.804] getGlobalsAndPackagesXApply() ...
[16:11:16.804]  - future.globals: TRUE
[16:11:16.804] getGlobalsAndPackages() ...
[16:11:16.804] Searching for globals...
[16:11:16.806] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:16.806] Searching for globals ... DONE
[16:11:16.806] Resolving globals: FALSE
[16:11:16.806] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:16.807] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:16.807] - globals: [1] ‘FUN’
[16:11:16.807] 
[16:11:16.807] getGlobalsAndPackages() ... DONE
[16:11:16.807]  - globals found/used: [n=1] ‘FUN’
[16:11:16.807]  - needed namespaces: [n=0] 
[16:11:16.807] Finding globals ... DONE
[16:11:16.809] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:16.809] List of 2
[16:11:16.809]  $ ...future.FUN:function (x, y)  
[16:11:16.809]  $ MoreArgs     : NULL
[16:11:16.809]  - attr(*, "where")=List of 2
[16:11:16.809]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:16.809]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:16.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:16.809]  - attr(*, "resolved")= logi FALSE
[16:11:16.809]  - attr(*, "total_size")= num NA
[16:11:16.812] Packages to be attached in all futures: [n=0] 
[16:11:16.812] getGlobalsAndPackagesXApply() ... DONE
[16:11:16.812] Number of futures (= number of chunks): 1
[16:11:16.812] Launching 1 futures (chunks) ...
[16:11:16.813] Chunk #1 of 1 ...
[16:11:16.813]  - Finding globals in '...' for chunk #1 ...
[16:11:16.813] getGlobalsAndPackages() ...
[16:11:16.813] Searching for globals...
[16:11:16.813] 
[16:11:16.813] Searching for globals ... DONE
[16:11:16.813] - globals: [0] <none>
[16:11:16.813] getGlobalsAndPackages() ... DONE
[16:11:16.814]    + additional globals found: [n=0] 
[16:11:16.814]    + additional namespaces needed: [n=0] 
[16:11:16.814]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:16.814]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:16.814]  - seeds: <none>
[16:11:16.814] getGlobalsAndPackages() ...
[16:11:16.814] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:16.814] Resolving globals: FALSE
[16:11:16.815] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:16.815] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:16.815] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:16.815] 
[16:11:16.815] getGlobalsAndPackages() ... DONE
[16:11:16.816] run() for ‘Future’ ...
[16:11:16.816] - state: ‘created’
[16:11:16.816] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:16.819] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:16.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:16.820]   - Field: ‘label’
[16:11:16.820]   - Field: ‘local’
[16:11:16.820]   - Field: ‘owner’
[16:11:16.820]   - Field: ‘envir’
[16:11:16.820]   - Field: ‘packages’
[16:11:16.820]   - Field: ‘gc’
[16:11:16.820]   - Field: ‘conditions’
[16:11:16.820]   - Field: ‘expr’
[16:11:16.820]   - Field: ‘uuid’
[16:11:16.820]   - Field: ‘seed’
[16:11:16.820]   - Field: ‘version’
[16:11:16.821]   - Field: ‘result’
[16:11:16.821]   - Field: ‘asynchronous’
[16:11:16.821]   - Field: ‘calls’
[16:11:16.821]   - Field: ‘globals’
[16:11:16.821]   - Field: ‘stdout’
[16:11:16.821]   - Field: ‘earlySignal’
[16:11:16.821]   - Field: ‘lazy’
[16:11:16.821]   - Field: ‘state’
[16:11:16.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:16.821] - Launch lazy future ...
[16:11:16.822] Packages needed by the future expression (n = 0): <none>
[16:11:16.822] Packages needed by future strategies (n = 0): <none>
[16:11:16.822] {
[16:11:16.822]     {
[16:11:16.822]         {
[16:11:16.822]             ...future.startTime <- base::Sys.time()
[16:11:16.822]             {
[16:11:16.822]                 {
[16:11:16.822]                   {
[16:11:16.822]                     base::local({
[16:11:16.822]                       has_future <- base::requireNamespace("future", 
[16:11:16.822]                         quietly = TRUE)
[16:11:16.822]                       if (has_future) {
[16:11:16.822]                         ns <- base::getNamespace("future")
[16:11:16.822]                         version <- ns[[".package"]][["version"]]
[16:11:16.822]                         if (is.null(version)) 
[16:11:16.822]                           version <- utils::packageVersion("future")
[16:11:16.822]                       }
[16:11:16.822]                       else {
[16:11:16.822]                         version <- NULL
[16:11:16.822]                       }
[16:11:16.822]                       if (!has_future || version < "1.8.0") {
[16:11:16.822]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:16.822]                           "", base::R.version$version.string), 
[16:11:16.822]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:16.822]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:16.822]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:16.822]                             "release", "version")], collapse = " "), 
[16:11:16.822]                           hostname = base::Sys.info()[["nodename"]])
[16:11:16.822]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:16.822]                           info)
[16:11:16.822]                         info <- base::paste(info, collapse = "; ")
[16:11:16.822]                         if (!has_future) {
[16:11:16.822]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:16.822]                             info)
[16:11:16.822]                         }
[16:11:16.822]                         else {
[16:11:16.822]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:16.822]                             info, version)
[16:11:16.822]                         }
[16:11:16.822]                         base::stop(msg)
[16:11:16.822]                       }
[16:11:16.822]                     })
[16:11:16.822]                   }
[16:11:16.822]                   options(future.plan = NULL)
[16:11:16.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:16.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:16.822]                 }
[16:11:16.822]                 ...future.workdir <- getwd()
[16:11:16.822]             }
[16:11:16.822]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:16.822]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:16.822]         }
[16:11:16.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:16.822]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:16.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:16.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:16.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:16.822]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:16.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:16.822]             base::names(...future.oldOptions))
[16:11:16.822]     }
[16:11:16.822]     if (FALSE) {
[16:11:16.822]     }
[16:11:16.822]     else {
[16:11:16.822]         if (FALSE) {
[16:11:16.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:16.822]                 open = "w")
[16:11:16.822]         }
[16:11:16.822]         else {
[16:11:16.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:16.822]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:16.822]         }
[16:11:16.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:16.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:16.822]             base::sink(type = "output", split = FALSE)
[16:11:16.822]             base::close(...future.stdout)
[16:11:16.822]         }, add = TRUE)
[16:11:16.822]     }
[16:11:16.822]     ...future.frame <- base::sys.nframe()
[16:11:16.822]     ...future.conditions <- base::list()
[16:11:16.822]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:16.822]     if (FALSE) {
[16:11:16.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:16.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:16.822]     }
[16:11:16.822]     ...future.result <- base::tryCatch({
[16:11:16.822]         base::withCallingHandlers({
[16:11:16.822]             ...future.value <- base::withVisible(base::local({
[16:11:16.822]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:16.822]                 if (!identical(...future.globals.maxSize.org, 
[16:11:16.822]                   ...future.globals.maxSize)) {
[16:11:16.822]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:16.822]                   on.exit(options(oopts), add = TRUE)
[16:11:16.822]                 }
[16:11:16.822]                 {
[16:11:16.822]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:16.822]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:16.822]                     USE.NAMES = FALSE)
[16:11:16.822]                   do.call(mapply, args = args)
[16:11:16.822]                 }
[16:11:16.822]             }))
[16:11:16.822]             future::FutureResult(value = ...future.value$value, 
[16:11:16.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:16.822]                   ...future.rng), globalenv = if (FALSE) 
[16:11:16.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:16.822]                     ...future.globalenv.names))
[16:11:16.822]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:16.822]         }, condition = base::local({
[16:11:16.822]             c <- base::c
[16:11:16.822]             inherits <- base::inherits
[16:11:16.822]             invokeRestart <- base::invokeRestart
[16:11:16.822]             length <- base::length
[16:11:16.822]             list <- base::list
[16:11:16.822]             seq.int <- base::seq.int
[16:11:16.822]             signalCondition <- base::signalCondition
[16:11:16.822]             sys.calls <- base::sys.calls
[16:11:16.822]             `[[` <- base::`[[`
[16:11:16.822]             `+` <- base::`+`
[16:11:16.822]             `<<-` <- base::`<<-`
[16:11:16.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:16.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:16.822]                   3L)]
[16:11:16.822]             }
[16:11:16.822]             function(cond) {
[16:11:16.822]                 is_error <- inherits(cond, "error")
[16:11:16.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:16.822]                   NULL)
[16:11:16.822]                 if (is_error) {
[16:11:16.822]                   sessionInformation <- function() {
[16:11:16.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:16.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:16.822]                       search = base::search(), system = base::Sys.info())
[16:11:16.822]                   }
[16:11:16.822]                   ...future.conditions[[length(...future.conditions) + 
[16:11:16.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:16.822]                     cond$call), session = sessionInformation(), 
[16:11:16.822]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:16.822]                   signalCondition(cond)
[16:11:16.822]                 }
[16:11:16.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:16.822]                 "immediateCondition"))) {
[16:11:16.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:16.822]                   ...future.conditions[[length(...future.conditions) + 
[16:11:16.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:16.822]                   if (TRUE && !signal) {
[16:11:16.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:16.822]                     {
[16:11:16.822]                       inherits <- base::inherits
[16:11:16.822]                       invokeRestart <- base::invokeRestart
[16:11:16.822]                       is.null <- base::is.null
[16:11:16.822]                       muffled <- FALSE
[16:11:16.822]                       if (inherits(cond, "message")) {
[16:11:16.822]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:16.822]                         if (muffled) 
[16:11:16.822]                           invokeRestart("muffleMessage")
[16:11:16.822]                       }
[16:11:16.822]                       else if (inherits(cond, "warning")) {
[16:11:16.822]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:16.822]                         if (muffled) 
[16:11:16.822]                           invokeRestart("muffleWarning")
[16:11:16.822]                       }
[16:11:16.822]                       else if (inherits(cond, "condition")) {
[16:11:16.822]                         if (!is.null(pattern)) {
[16:11:16.822]                           computeRestarts <- base::computeRestarts
[16:11:16.822]                           grepl <- base::grepl
[16:11:16.822]                           restarts <- computeRestarts(cond)
[16:11:16.822]                           for (restart in restarts) {
[16:11:16.822]                             name <- restart$name
[16:11:16.822]                             if (is.null(name)) 
[16:11:16.822]                               next
[16:11:16.822]                             if (!grepl(pattern, name)) 
[16:11:16.822]                               next
[16:11:16.822]                             invokeRestart(restart)
[16:11:16.822]                             muffled <- TRUE
[16:11:16.822]                             break
[16:11:16.822]                           }
[16:11:16.822]                         }
[16:11:16.822]                       }
[16:11:16.822]                       invisible(muffled)
[16:11:16.822]                     }
[16:11:16.822]                     muffleCondition(cond, pattern = "^muffle")
[16:11:16.822]                   }
[16:11:16.822]                 }
[16:11:16.822]                 else {
[16:11:16.822]                   if (TRUE) {
[16:11:16.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:16.822]                     {
[16:11:16.822]                       inherits <- base::inherits
[16:11:16.822]                       invokeRestart <- base::invokeRestart
[16:11:16.822]                       is.null <- base::is.null
[16:11:16.822]                       muffled <- FALSE
[16:11:16.822]                       if (inherits(cond, "message")) {
[16:11:16.822]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:16.822]                         if (muffled) 
[16:11:16.822]                           invokeRestart("muffleMessage")
[16:11:16.822]                       }
[16:11:16.822]                       else if (inherits(cond, "warning")) {
[16:11:16.822]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:16.822]                         if (muffled) 
[16:11:16.822]                           invokeRestart("muffleWarning")
[16:11:16.822]                       }
[16:11:16.822]                       else if (inherits(cond, "condition")) {
[16:11:16.822]                         if (!is.null(pattern)) {
[16:11:16.822]                           computeRestarts <- base::computeRestarts
[16:11:16.822]                           grepl <- base::grepl
[16:11:16.822]                           restarts <- computeRestarts(cond)
[16:11:16.822]                           for (restart in restarts) {
[16:11:16.822]                             name <- restart$name
[16:11:16.822]                             if (is.null(name)) 
[16:11:16.822]                               next
[16:11:16.822]                             if (!grepl(pattern, name)) 
[16:11:16.822]                               next
[16:11:16.822]                             invokeRestart(restart)
[16:11:16.822]                             muffled <- TRUE
[16:11:16.822]                             break
[16:11:16.822]                           }
[16:11:16.822]                         }
[16:11:16.822]                       }
[16:11:16.822]                       invisible(muffled)
[16:11:16.822]                     }
[16:11:16.822]                     muffleCondition(cond, pattern = "^muffle")
[16:11:16.822]                   }
[16:11:16.822]                 }
[16:11:16.822]             }
[16:11:16.822]         }))
[16:11:16.822]     }, error = function(ex) {
[16:11:16.822]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:16.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:16.822]                 ...future.rng), started = ...future.startTime, 
[16:11:16.822]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:16.822]             version = "1.8"), class = "FutureResult")
[16:11:16.822]     }, finally = {
[16:11:16.822]         if (!identical(...future.workdir, getwd())) 
[16:11:16.822]             setwd(...future.workdir)
[16:11:16.822]         {
[16:11:16.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:16.822]                 ...future.oldOptions$nwarnings <- NULL
[16:11:16.822]             }
[16:11:16.822]             base::options(...future.oldOptions)
[16:11:16.822]             if (.Platform$OS.type == "windows") {
[16:11:16.822]                 old_names <- names(...future.oldEnvVars)
[16:11:16.822]                 envs <- base::Sys.getenv()
[16:11:16.822]                 names <- names(envs)
[16:11:16.822]                 common <- intersect(names, old_names)
[16:11:16.822]                 added <- setdiff(names, old_names)
[16:11:16.822]                 removed <- setdiff(old_names, names)
[16:11:16.822]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:16.822]                   envs[common]]
[16:11:16.822]                 NAMES <- toupper(changed)
[16:11:16.822]                 args <- list()
[16:11:16.822]                 for (kk in seq_along(NAMES)) {
[16:11:16.822]                   name <- changed[[kk]]
[16:11:16.822]                   NAME <- NAMES[[kk]]
[16:11:16.822]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:16.822]                     next
[16:11:16.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:16.822]                 }
[16:11:16.822]                 NAMES <- toupper(added)
[16:11:16.822]                 for (kk in seq_along(NAMES)) {
[16:11:16.822]                   name <- added[[kk]]
[16:11:16.822]                   NAME <- NAMES[[kk]]
[16:11:16.822]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:16.822]                     next
[16:11:16.822]                   args[[name]] <- ""
[16:11:16.822]                 }
[16:11:16.822]                 NAMES <- toupper(removed)
[16:11:16.822]                 for (kk in seq_along(NAMES)) {
[16:11:16.822]                   name <- removed[[kk]]
[16:11:16.822]                   NAME <- NAMES[[kk]]
[16:11:16.822]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:16.822]                     next
[16:11:16.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:16.822]                 }
[16:11:16.822]                 if (length(args) > 0) 
[16:11:16.822]                   base::do.call(base::Sys.setenv, args = args)
[16:11:16.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:16.822]             }
[16:11:16.822]             else {
[16:11:16.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:16.822]             }
[16:11:16.822]             {
[16:11:16.822]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:16.822]                   0L) {
[16:11:16.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:16.822]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:16.822]                   base::options(opts)
[16:11:16.822]                 }
[16:11:16.822]                 {
[16:11:16.822]                   {
[16:11:16.822]                     NULL
[16:11:16.822]                     RNGkind("Mersenne-Twister")
[16:11:16.822]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:16.822]                       inherits = FALSE)
[16:11:16.822]                   }
[16:11:16.822]                   options(future.plan = NULL)
[16:11:16.822]                   if (is.na(NA_character_)) 
[16:11:16.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:16.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:16.822]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:16.822]                     envir = parent.frame()) 
[16:11:16.822]                   {
[16:11:16.822]                     default_workers <- missing(workers)
[16:11:16.822]                     if (is.function(workers)) 
[16:11:16.822]                       workers <- workers()
[16:11:16.822]                     workers <- structure(as.integer(workers), 
[16:11:16.822]                       class = class(workers))
[16:11:16.822]                     stop_if_not(is.finite(workers), workers >= 
[16:11:16.822]                       1L)
[16:11:16.822]                     if ((workers == 1L && !inherits(workers, 
[16:11:16.822]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:16.822]                       if (default_workers) 
[16:11:16.822]                         supportsMulticore(warn = TRUE)
[16:11:16.822]                       return(sequential(..., envir = envir))
[16:11:16.822]                     }
[16:11:16.822]                     oopts <- options(mc.cores = workers)
[16:11:16.822]                     on.exit(options(oopts))
[16:11:16.822]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:16.822]                       envir = envir)
[16:11:16.822]                     if (!future$lazy) 
[16:11:16.822]                       future <- run(future)
[16:11:16.822]                     invisible(future)
[16:11:16.822]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:16.822]                 }
[16:11:16.822]             }
[16:11:16.822]         }
[16:11:16.822]     })
[16:11:16.822]     if (TRUE) {
[16:11:16.822]         base::sink(type = "output", split = FALSE)
[16:11:16.822]         if (FALSE) {
[16:11:16.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:16.822]         }
[16:11:16.822]         else {
[16:11:16.822]             ...future.result["stdout"] <- base::list(NULL)
[16:11:16.822]         }
[16:11:16.822]         base::close(...future.stdout)
[16:11:16.822]         ...future.stdout <- NULL
[16:11:16.822]     }
[16:11:16.822]     ...future.result$conditions <- ...future.conditions
[16:11:16.822]     ...future.result$finished <- base::Sys.time()
[16:11:16.822]     ...future.result
[16:11:16.822] }
[16:11:16.824] assign_globals() ...
[16:11:16.824] List of 5
[16:11:16.824]  $ ...future.FUN            :function (x, y)  
[16:11:16.824]  $ MoreArgs                 : NULL
[16:11:16.824]  $ ...future.elements_ii    :List of 2
[16:11:16.824]   ..$ :List of 2
[16:11:16.824]   .. ..$ : int 1
[16:11:16.824]   .. ..$ : int 0
[16:11:16.824]   ..$ :List of 2
[16:11:16.824]   .. ..$ : int 0
[16:11:16.824]   .. ..$ : int 1
[16:11:16.824]  $ ...future.seeds_ii       : NULL
[16:11:16.824]  $ ...future.globals.maxSize: NULL
[16:11:16.824]  - attr(*, "resolved")= logi FALSE
[16:11:16.824]  - attr(*, "total_size")= num 6480
[16:11:16.824]  - attr(*, "where")=List of 5
[16:11:16.824]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:16.824]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:16.824]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:16.824]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:16.824]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:16.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:16.824]  - attr(*, "already-done")= logi TRUE
[16:11:16.829] - reassign environment for ‘...future.FUN’
[16:11:16.829] - copied ‘...future.FUN’ to environment
[16:11:16.830] - copied ‘MoreArgs’ to environment
[16:11:16.830] - copied ‘...future.elements_ii’ to environment
[16:11:16.830] - copied ‘...future.seeds_ii’ to environment
[16:11:16.830] - copied ‘...future.globals.maxSize’ to environment
[16:11:16.830] assign_globals() ... done
[16:11:16.830] plan(): Setting new future strategy stack:
[16:11:16.830] List of future strategies:
[16:11:16.830] 1. sequential:
[16:11:16.830]    - args: function (..., envir = parent.frame())
[16:11:16.830]    - tweaked: FALSE
[16:11:16.830]    - call: NULL
[16:11:16.831] plan(): nbrOfWorkers() = 1
[16:11:17.332] plan(): Setting new future strategy stack:
[16:11:17.332] List of future strategies:
[16:11:17.332] 1. multicore:
[16:11:17.332]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:17.332]    - tweaked: FALSE
[16:11:17.332]    - call: plan(strategy)
[16:11:17.336] plan(): nbrOfWorkers() = 1
[16:11:17.337] SequentialFuture started (and completed)
[16:11:17.337] - Launch lazy future ... done
[16:11:17.337] run() for ‘SequentialFuture’ ... done
[16:11:17.337] Created future:
[16:11:17.337] SequentialFuture:
[16:11:17.337] Label: ‘future_mapply-1’
[16:11:17.337] Expression:
[16:11:17.337] {
[16:11:17.337]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:17.337]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:17.337]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:17.337]         on.exit(options(oopts), add = TRUE)
[16:11:17.337]     }
[16:11:17.337]     {
[16:11:17.337]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:17.337]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:17.337]         do.call(mapply, args = args)
[16:11:17.337]     }
[16:11:17.337] }
[16:11:17.337] Lazy evaluation: FALSE
[16:11:17.337] Asynchronous evaluation: FALSE
[16:11:17.337] Local evaluation: TRUE
[16:11:17.337] Environment: R_GlobalEnv
[16:11:17.337] Capture standard output: FALSE
[16:11:17.337] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:17.337] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:17.337] Packages: <none>
[16:11:17.337] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:17.337] Resolved: TRUE
[16:11:17.337] Value: 224 bytes of class ‘list’
[16:11:17.337] Early signaling: FALSE
[16:11:17.337] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:17.337] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:17.340] Chunk #1 of 1 ... DONE
[16:11:17.340] Launching 1 futures (chunks) ... DONE
[16:11:17.340] Resolving 1 futures (chunks) ...
[16:11:17.340] resolve() on list ...
[16:11:17.341]  recursive: 0
[16:11:17.341]  length: 1
[16:11:17.341] 
[16:11:17.341] resolved() for ‘SequentialFuture’ ...
[16:11:17.341] - state: ‘finished’
[16:11:17.341] - run: TRUE
[16:11:17.341] - result: ‘FutureResult’
[16:11:17.341] resolved() for ‘SequentialFuture’ ... done
[16:11:17.341] Future #1
[16:11:17.342] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:17.342] - nx: 1
[16:11:17.342] - relay: TRUE
[16:11:17.342] - stdout: TRUE
[16:11:17.342] - signal: TRUE
[16:11:17.342] - resignal: FALSE
[16:11:17.342] - force: TRUE
[16:11:17.342] - relayed: [n=1] FALSE
[16:11:17.342] - queued futures: [n=1] FALSE
[16:11:17.342]  - until=1
[16:11:17.342]  - relaying element #1
[16:11:17.343] - relayed: [n=1] TRUE
[16:11:17.343] - queued futures: [n=1] TRUE
[16:11:17.343] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:17.343]  length: 0 (resolved future 1)
[16:11:17.343] Relaying remaining futures
[16:11:17.343] signalConditionsASAP(NULL, pos=0) ...
[16:11:17.343] - nx: 1
[16:11:17.343] - relay: TRUE
[16:11:17.343] - stdout: TRUE
[16:11:17.343] - signal: TRUE
[16:11:17.343] - resignal: FALSE
[16:11:17.344] - force: TRUE
[16:11:17.344] - relayed: [n=1] TRUE
[16:11:17.344] - queued futures: [n=1] TRUE
 - flush all
[16:11:17.344] - relayed: [n=1] TRUE
[16:11:17.344] - queued futures: [n=1] TRUE
[16:11:17.344] signalConditionsASAP(NULL, pos=0) ... done
[16:11:17.344] resolve() on list ... DONE
[16:11:17.344]  - Number of value chunks collected: 1
[16:11:17.344] Resolving 1 futures (chunks) ... DONE
[16:11:17.344] Reducing values from 1 chunks ...
[16:11:17.345]  - Number of values collected after concatenation: 2
[16:11:17.345]  - Number of values expected: 2
[16:11:17.345] Reducing values from 1 chunks ... DONE
[16:11:17.345] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:11:17.345] future_mapply() ...
[16:11:17.349] Number of chunks: 1
[16:11:17.349] getGlobalsAndPackagesXApply() ...
[16:11:17.349]  - future.globals: TRUE
[16:11:17.349] getGlobalsAndPackages() ...
[16:11:17.349] Searching for globals...
[16:11:17.351] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:17.351] Searching for globals ... DONE
[16:11:17.351] Resolving globals: FALSE
[16:11:17.351] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:17.352] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:17.352] - globals: [1] ‘FUN’
[16:11:17.352] 
[16:11:17.352] getGlobalsAndPackages() ... DONE
[16:11:17.352]  - globals found/used: [n=1] ‘FUN’
[16:11:17.352]  - needed namespaces: [n=0] 
[16:11:17.352] Finding globals ... DONE
[16:11:17.352] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:17.353] List of 2
[16:11:17.353]  $ ...future.FUN:function (x, y)  
[16:11:17.353]  $ MoreArgs     : NULL
[16:11:17.353]  - attr(*, "where")=List of 2
[16:11:17.353]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:17.353]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:17.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:17.353]  - attr(*, "resolved")= logi FALSE
[16:11:17.353]  - attr(*, "total_size")= num NA
[16:11:17.355] Packages to be attached in all futures: [n=0] 
[16:11:17.355] getGlobalsAndPackagesXApply() ... DONE
[16:11:17.355] Number of futures (= number of chunks): 1
[16:11:17.355] Launching 1 futures (chunks) ...
[16:11:17.356] Chunk #1 of 1 ...
[16:11:17.356]  - Finding globals in '...' for chunk #1 ...
[16:11:17.356] getGlobalsAndPackages() ...
[16:11:17.356] Searching for globals...
[16:11:17.356] 
[16:11:17.356] Searching for globals ... DONE
[16:11:17.356] - globals: [0] <none>
[16:11:17.356] getGlobalsAndPackages() ... DONE
[16:11:17.357]    + additional globals found: [n=0] 
[16:11:17.357]    + additional namespaces needed: [n=0] 
[16:11:17.357]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:17.357]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:17.357]  - seeds: <none>
[16:11:17.357] getGlobalsAndPackages() ...
[16:11:17.357] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:17.357] Resolving globals: FALSE
[16:11:17.358] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:17.358] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:17.358] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:17.358] 
[16:11:17.359] getGlobalsAndPackages() ... DONE
[16:11:17.359] run() for ‘Future’ ...
[16:11:17.359] - state: ‘created’
[16:11:17.359] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:17.363] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:17.363] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:17.363]   - Field: ‘label’
[16:11:17.364]   - Field: ‘local’
[16:11:17.364]   - Field: ‘owner’
[16:11:17.364]   - Field: ‘envir’
[16:11:17.364]   - Field: ‘packages’
[16:11:17.364]   - Field: ‘gc’
[16:11:17.364]   - Field: ‘conditions’
[16:11:17.364]   - Field: ‘expr’
[16:11:17.364]   - Field: ‘uuid’
[16:11:17.364]   - Field: ‘seed’
[16:11:17.365]   - Field: ‘version’
[16:11:17.365]   - Field: ‘result’
[16:11:17.365]   - Field: ‘asynchronous’
[16:11:17.365]   - Field: ‘calls’
[16:11:17.365]   - Field: ‘globals’
[16:11:17.365]   - Field: ‘stdout’
[16:11:17.365]   - Field: ‘earlySignal’
[16:11:17.365]   - Field: ‘lazy’
[16:11:17.365]   - Field: ‘state’
[16:11:17.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:17.366] - Launch lazy future ...
[16:11:17.366] Packages needed by the future expression (n = 0): <none>
[16:11:17.366] Packages needed by future strategies (n = 0): <none>
[16:11:17.366] {
[16:11:17.366]     {
[16:11:17.366]         {
[16:11:17.366]             ...future.startTime <- base::Sys.time()
[16:11:17.366]             {
[16:11:17.366]                 {
[16:11:17.366]                   {
[16:11:17.366]                     base::local({
[16:11:17.366]                       has_future <- base::requireNamespace("future", 
[16:11:17.366]                         quietly = TRUE)
[16:11:17.366]                       if (has_future) {
[16:11:17.366]                         ns <- base::getNamespace("future")
[16:11:17.366]                         version <- ns[[".package"]][["version"]]
[16:11:17.366]                         if (is.null(version)) 
[16:11:17.366]                           version <- utils::packageVersion("future")
[16:11:17.366]                       }
[16:11:17.366]                       else {
[16:11:17.366]                         version <- NULL
[16:11:17.366]                       }
[16:11:17.366]                       if (!has_future || version < "1.8.0") {
[16:11:17.366]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:17.366]                           "", base::R.version$version.string), 
[16:11:17.366]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:17.366]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:17.366]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:17.366]                             "release", "version")], collapse = " "), 
[16:11:17.366]                           hostname = base::Sys.info()[["nodename"]])
[16:11:17.366]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:17.366]                           info)
[16:11:17.366]                         info <- base::paste(info, collapse = "; ")
[16:11:17.366]                         if (!has_future) {
[16:11:17.366]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:17.366]                             info)
[16:11:17.366]                         }
[16:11:17.366]                         else {
[16:11:17.366]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:17.366]                             info, version)
[16:11:17.366]                         }
[16:11:17.366]                         base::stop(msg)
[16:11:17.366]                       }
[16:11:17.366]                     })
[16:11:17.366]                   }
[16:11:17.366]                   options(future.plan = NULL)
[16:11:17.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:17.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:17.366]                 }
[16:11:17.366]                 ...future.workdir <- getwd()
[16:11:17.366]             }
[16:11:17.366]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:17.366]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:17.366]         }
[16:11:17.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:17.366]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:17.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:17.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:17.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:17.366]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:17.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:17.366]             base::names(...future.oldOptions))
[16:11:17.366]     }
[16:11:17.366]     if (FALSE) {
[16:11:17.366]     }
[16:11:17.366]     else {
[16:11:17.366]         if (TRUE) {
[16:11:17.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:17.366]                 open = "w")
[16:11:17.366]         }
[16:11:17.366]         else {
[16:11:17.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:17.366]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:17.366]         }
[16:11:17.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:17.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:17.366]             base::sink(type = "output", split = FALSE)
[16:11:17.366]             base::close(...future.stdout)
[16:11:17.366]         }, add = TRUE)
[16:11:17.366]     }
[16:11:17.366]     ...future.frame <- base::sys.nframe()
[16:11:17.366]     ...future.conditions <- base::list()
[16:11:17.366]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:17.366]     if (FALSE) {
[16:11:17.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:17.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:17.366]     }
[16:11:17.366]     ...future.result <- base::tryCatch({
[16:11:17.366]         base::withCallingHandlers({
[16:11:17.366]             ...future.value <- base::withVisible(base::local({
[16:11:17.366]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:17.366]                 if (!identical(...future.globals.maxSize.org, 
[16:11:17.366]                   ...future.globals.maxSize)) {
[16:11:17.366]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:17.366]                   on.exit(options(oopts), add = TRUE)
[16:11:17.366]                 }
[16:11:17.366]                 {
[16:11:17.366]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:17.366]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:17.366]                     USE.NAMES = FALSE)
[16:11:17.366]                   do.call(mapply, args = args)
[16:11:17.366]                 }
[16:11:17.366]             }))
[16:11:17.366]             future::FutureResult(value = ...future.value$value, 
[16:11:17.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:17.366]                   ...future.rng), globalenv = if (FALSE) 
[16:11:17.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:17.366]                     ...future.globalenv.names))
[16:11:17.366]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:17.366]         }, condition = base::local({
[16:11:17.366]             c <- base::c
[16:11:17.366]             inherits <- base::inherits
[16:11:17.366]             invokeRestart <- base::invokeRestart
[16:11:17.366]             length <- base::length
[16:11:17.366]             list <- base::list
[16:11:17.366]             seq.int <- base::seq.int
[16:11:17.366]             signalCondition <- base::signalCondition
[16:11:17.366]             sys.calls <- base::sys.calls
[16:11:17.366]             `[[` <- base::`[[`
[16:11:17.366]             `+` <- base::`+`
[16:11:17.366]             `<<-` <- base::`<<-`
[16:11:17.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:17.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:17.366]                   3L)]
[16:11:17.366]             }
[16:11:17.366]             function(cond) {
[16:11:17.366]                 is_error <- inherits(cond, "error")
[16:11:17.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:17.366]                   NULL)
[16:11:17.366]                 if (is_error) {
[16:11:17.366]                   sessionInformation <- function() {
[16:11:17.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:17.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:17.366]                       search = base::search(), system = base::Sys.info())
[16:11:17.366]                   }
[16:11:17.366]                   ...future.conditions[[length(...future.conditions) + 
[16:11:17.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:17.366]                     cond$call), session = sessionInformation(), 
[16:11:17.366]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:17.366]                   signalCondition(cond)
[16:11:17.366]                 }
[16:11:17.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:17.366]                 "immediateCondition"))) {
[16:11:17.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:17.366]                   ...future.conditions[[length(...future.conditions) + 
[16:11:17.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:17.366]                   if (TRUE && !signal) {
[16:11:17.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:17.366]                     {
[16:11:17.366]                       inherits <- base::inherits
[16:11:17.366]                       invokeRestart <- base::invokeRestart
[16:11:17.366]                       is.null <- base::is.null
[16:11:17.366]                       muffled <- FALSE
[16:11:17.366]                       if (inherits(cond, "message")) {
[16:11:17.366]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:17.366]                         if (muffled) 
[16:11:17.366]                           invokeRestart("muffleMessage")
[16:11:17.366]                       }
[16:11:17.366]                       else if (inherits(cond, "warning")) {
[16:11:17.366]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:17.366]                         if (muffled) 
[16:11:17.366]                           invokeRestart("muffleWarning")
[16:11:17.366]                       }
[16:11:17.366]                       else if (inherits(cond, "condition")) {
[16:11:17.366]                         if (!is.null(pattern)) {
[16:11:17.366]                           computeRestarts <- base::computeRestarts
[16:11:17.366]                           grepl <- base::grepl
[16:11:17.366]                           restarts <- computeRestarts(cond)
[16:11:17.366]                           for (restart in restarts) {
[16:11:17.366]                             name <- restart$name
[16:11:17.366]                             if (is.null(name)) 
[16:11:17.366]                               next
[16:11:17.366]                             if (!grepl(pattern, name)) 
[16:11:17.366]                               next
[16:11:17.366]                             invokeRestart(restart)
[16:11:17.366]                             muffled <- TRUE
[16:11:17.366]                             break
[16:11:17.366]                           }
[16:11:17.366]                         }
[16:11:17.366]                       }
[16:11:17.366]                       invisible(muffled)
[16:11:17.366]                     }
[16:11:17.366]                     muffleCondition(cond, pattern = "^muffle")
[16:11:17.366]                   }
[16:11:17.366]                 }
[16:11:17.366]                 else {
[16:11:17.366]                   if (TRUE) {
[16:11:17.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:17.366]                     {
[16:11:17.366]                       inherits <- base::inherits
[16:11:17.366]                       invokeRestart <- base::invokeRestart
[16:11:17.366]                       is.null <- base::is.null
[16:11:17.366]                       muffled <- FALSE
[16:11:17.366]                       if (inherits(cond, "message")) {
[16:11:17.366]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:17.366]                         if (muffled) 
[16:11:17.366]                           invokeRestart("muffleMessage")
[16:11:17.366]                       }
[16:11:17.366]                       else if (inherits(cond, "warning")) {
[16:11:17.366]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:17.366]                         if (muffled) 
[16:11:17.366]                           invokeRestart("muffleWarning")
[16:11:17.366]                       }
[16:11:17.366]                       else if (inherits(cond, "condition")) {
[16:11:17.366]                         if (!is.null(pattern)) {
[16:11:17.366]                           computeRestarts <- base::computeRestarts
[16:11:17.366]                           grepl <- base::grepl
[16:11:17.366]                           restarts <- computeRestarts(cond)
[16:11:17.366]                           for (restart in restarts) {
[16:11:17.366]                             name <- restart$name
[16:11:17.366]                             if (is.null(name)) 
[16:11:17.366]                               next
[16:11:17.366]                             if (!grepl(pattern, name)) 
[16:11:17.366]                               next
[16:11:17.366]                             invokeRestart(restart)
[16:11:17.366]                             muffled <- TRUE
[16:11:17.366]                             break
[16:11:17.366]                           }
[16:11:17.366]                         }
[16:11:17.366]                       }
[16:11:17.366]                       invisible(muffled)
[16:11:17.366]                     }
[16:11:17.366]                     muffleCondition(cond, pattern = "^muffle")
[16:11:17.366]                   }
[16:11:17.366]                 }
[16:11:17.366]             }
[16:11:17.366]         }))
[16:11:17.366]     }, error = function(ex) {
[16:11:17.366]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:17.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:17.366]                 ...future.rng), started = ...future.startTime, 
[16:11:17.366]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:17.366]             version = "1.8"), class = "FutureResult")
[16:11:17.366]     }, finally = {
[16:11:17.366]         if (!identical(...future.workdir, getwd())) 
[16:11:17.366]             setwd(...future.workdir)
[16:11:17.366]         {
[16:11:17.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:17.366]                 ...future.oldOptions$nwarnings <- NULL
[16:11:17.366]             }
[16:11:17.366]             base::options(...future.oldOptions)
[16:11:17.366]             if (.Platform$OS.type == "windows") {
[16:11:17.366]                 old_names <- names(...future.oldEnvVars)
[16:11:17.366]                 envs <- base::Sys.getenv()
[16:11:17.366]                 names <- names(envs)
[16:11:17.366]                 common <- intersect(names, old_names)
[16:11:17.366]                 added <- setdiff(names, old_names)
[16:11:17.366]                 removed <- setdiff(old_names, names)
[16:11:17.366]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:17.366]                   envs[common]]
[16:11:17.366]                 NAMES <- toupper(changed)
[16:11:17.366]                 args <- list()
[16:11:17.366]                 for (kk in seq_along(NAMES)) {
[16:11:17.366]                   name <- changed[[kk]]
[16:11:17.366]                   NAME <- NAMES[[kk]]
[16:11:17.366]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:17.366]                     next
[16:11:17.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:17.366]                 }
[16:11:17.366]                 NAMES <- toupper(added)
[16:11:17.366]                 for (kk in seq_along(NAMES)) {
[16:11:17.366]                   name <- added[[kk]]
[16:11:17.366]                   NAME <- NAMES[[kk]]
[16:11:17.366]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:17.366]                     next
[16:11:17.366]                   args[[name]] <- ""
[16:11:17.366]                 }
[16:11:17.366]                 NAMES <- toupper(removed)
[16:11:17.366]                 for (kk in seq_along(NAMES)) {
[16:11:17.366]                   name <- removed[[kk]]
[16:11:17.366]                   NAME <- NAMES[[kk]]
[16:11:17.366]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:17.366]                     next
[16:11:17.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:17.366]                 }
[16:11:17.366]                 if (length(args) > 0) 
[16:11:17.366]                   base::do.call(base::Sys.setenv, args = args)
[16:11:17.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:17.366]             }
[16:11:17.366]             else {
[16:11:17.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:17.366]             }
[16:11:17.366]             {
[16:11:17.366]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:17.366]                   0L) {
[16:11:17.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:17.366]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:17.366]                   base::options(opts)
[16:11:17.366]                 }
[16:11:17.366]                 {
[16:11:17.366]                   {
[16:11:17.366]                     NULL
[16:11:17.366]                     RNGkind("Mersenne-Twister")
[16:11:17.366]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:17.366]                       inherits = FALSE)
[16:11:17.366]                   }
[16:11:17.366]                   options(future.plan = NULL)
[16:11:17.366]                   if (is.na(NA_character_)) 
[16:11:17.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:17.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:17.366]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:17.366]                     envir = parent.frame()) 
[16:11:17.366]                   {
[16:11:17.366]                     default_workers <- missing(workers)
[16:11:17.366]                     if (is.function(workers)) 
[16:11:17.366]                       workers <- workers()
[16:11:17.366]                     workers <- structure(as.integer(workers), 
[16:11:17.366]                       class = class(workers))
[16:11:17.366]                     stop_if_not(is.finite(workers), workers >= 
[16:11:17.366]                       1L)
[16:11:17.366]                     if ((workers == 1L && !inherits(workers, 
[16:11:17.366]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:17.366]                       if (default_workers) 
[16:11:17.366]                         supportsMulticore(warn = TRUE)
[16:11:17.366]                       return(sequential(..., envir = envir))
[16:11:17.366]                     }
[16:11:17.366]                     oopts <- options(mc.cores = workers)
[16:11:17.366]                     on.exit(options(oopts))
[16:11:17.366]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:17.366]                       envir = envir)
[16:11:17.366]                     if (!future$lazy) 
[16:11:17.366]                       future <- run(future)
[16:11:17.366]                     invisible(future)
[16:11:17.366]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:17.366]                 }
[16:11:17.366]             }
[16:11:17.366]         }
[16:11:17.366]     })
[16:11:17.366]     if (TRUE) {
[16:11:17.366]         base::sink(type = "output", split = FALSE)
[16:11:17.366]         if (TRUE) {
[16:11:17.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:17.366]         }
[16:11:17.366]         else {
[16:11:17.366]             ...future.result["stdout"] <- base::list(NULL)
[16:11:17.366]         }
[16:11:17.366]         base::close(...future.stdout)
[16:11:17.366]         ...future.stdout <- NULL
[16:11:17.366]     }
[16:11:17.366]     ...future.result$conditions <- ...future.conditions
[16:11:17.366]     ...future.result$finished <- base::Sys.time()
[16:11:17.366]     ...future.result
[16:11:17.366] }
[16:11:17.368] assign_globals() ...
[16:11:17.368] List of 5
[16:11:17.368]  $ ...future.FUN            :function (x, y)  
[16:11:17.368]  $ MoreArgs                 : NULL
[16:11:17.368]  $ ...future.elements_ii    :List of 2
[16:11:17.368]   ..$ :List of 2
[16:11:17.368]   .. ..$ : int 1
[16:11:17.368]   .. ..$ : int 0
[16:11:17.368]   ..$ :List of 2
[16:11:17.368]   .. ..$ : int 0
[16:11:17.368]   .. ..$ : int 1
[16:11:17.368]  $ ...future.seeds_ii       : NULL
[16:11:17.368]  $ ...future.globals.maxSize: NULL
[16:11:17.368]  - attr(*, "resolved")= logi FALSE
[16:11:17.368]  - attr(*, "total_size")= num 6480
[16:11:17.368]  - attr(*, "where")=List of 5
[16:11:17.368]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:17.368]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:17.368]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:17.368]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:17.368]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:17.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:17.368]  - attr(*, "already-done")= logi TRUE
[16:11:17.376] - reassign environment for ‘...future.FUN’
[16:11:17.376] - copied ‘...future.FUN’ to environment
[16:11:17.376] - copied ‘MoreArgs’ to environment
[16:11:17.377] - copied ‘...future.elements_ii’ to environment
[16:11:17.377] - copied ‘...future.seeds_ii’ to environment
[16:11:17.377] - copied ‘...future.globals.maxSize’ to environment
[16:11:17.377] assign_globals() ... done
[16:11:17.377] plan(): Setting new future strategy stack:
[16:11:17.377] List of future strategies:
[16:11:17.377] 1. sequential:
[16:11:17.377]    - args: function (..., envir = parent.frame())
[16:11:17.377]    - tweaked: FALSE
[16:11:17.377]    - call: NULL
[16:11:17.378] plan(): nbrOfWorkers() = 1
[16:11:17.879] plan(): Setting new future strategy stack:
[16:11:17.879] List of future strategies:
[16:11:17.879] 1. multicore:
[16:11:17.879]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:17.879]    - tweaked: FALSE
[16:11:17.879]    - call: plan(strategy)
[16:11:17.883] plan(): nbrOfWorkers() = 1
[16:11:17.884] SequentialFuture started (and completed)
[16:11:17.884] - Launch lazy future ... done
[16:11:17.884] run() for ‘SequentialFuture’ ... done
[16:11:17.884] Created future:
[16:11:17.884] SequentialFuture:
[16:11:17.884] Label: ‘future_mapply-1’
[16:11:17.884] Expression:
[16:11:17.884] {
[16:11:17.884]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:17.884]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:17.884]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:17.884]         on.exit(options(oopts), add = TRUE)
[16:11:17.884]     }
[16:11:17.884]     {
[16:11:17.884]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:17.884]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:17.884]         do.call(mapply, args = args)
[16:11:17.884]     }
[16:11:17.884] }
[16:11:17.884] Lazy evaluation: FALSE
[16:11:17.884] Asynchronous evaluation: FALSE
[16:11:17.884] Local evaluation: TRUE
[16:11:17.884] Environment: R_GlobalEnv
[16:11:17.884] Capture standard output: TRUE
[16:11:17.884] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:17.884] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:17.884] Packages: <none>
[16:11:17.884] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:17.884] Resolved: TRUE
[16:11:17.884] Value: 224 bytes of class ‘list’
[16:11:17.884] Early signaling: FALSE
[16:11:17.884] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:17.884] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:17.885] Chunk #1 of 1 ... DONE
[16:11:17.885] Launching 1 futures (chunks) ... DONE
[16:11:17.885] Resolving 1 futures (chunks) ...
[16:11:17.885] resolve() on list ...
[16:11:17.885]  recursive: 0
[16:11:17.886]  length: 1
[16:11:17.886] 
[16:11:17.886] resolved() for ‘SequentialFuture’ ...
[16:11:17.886] - state: ‘finished’
[16:11:17.886] - run: TRUE
[16:11:17.886] - result: ‘FutureResult’
[16:11:17.886] resolved() for ‘SequentialFuture’ ... done
[16:11:17.886] Future #1
[16:11:17.886] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:17.886] - nx: 1
[16:11:17.887] - relay: TRUE
[16:11:17.887] - stdout: TRUE
[16:11:17.887] - signal: TRUE
[16:11:17.887] - resignal: FALSE
[16:11:17.887] - force: TRUE
[16:11:17.887] - relayed: [n=1] FALSE
[16:11:17.887] - queued futures: [n=1] FALSE
[16:11:17.887]  - until=1
[16:11:17.887]  - relaying element #1
[16:11:17.887] - relayed: [n=1] TRUE
[16:11:17.888] - queued futures: [n=1] TRUE
[16:11:17.888] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:17.888]  length: 0 (resolved future 1)
[16:11:17.888] Relaying remaining futures
[16:11:17.888] signalConditionsASAP(NULL, pos=0) ...
[16:11:17.888] - nx: 1
[16:11:17.888] - relay: TRUE
[16:11:17.888] - stdout: TRUE
[16:11:17.888] - signal: TRUE
[16:11:17.888] - resignal: FALSE
[16:11:17.888] - force: TRUE
[16:11:17.889] - relayed: [n=1] TRUE
[16:11:17.889] - queued futures: [n=1] TRUE
 - flush all
[16:11:17.889] - relayed: [n=1] TRUE
[16:11:17.889] - queued futures: [n=1] TRUE
[16:11:17.889] signalConditionsASAP(NULL, pos=0) ... done
[16:11:17.889] resolve() on list ... DONE
[16:11:17.889]  - Number of value chunks collected: 1
[16:11:17.889] Resolving 1 futures (chunks) ... DONE
[16:11:17.889] Reducing values from 1 chunks ...
[16:11:17.889]  - Number of values collected after concatenation: 2
[16:11:17.890]  - Number of values expected: 2
[16:11:17.890] Reducing values from 1 chunks ... DONE
[16:11:17.890] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:11:17.890] future_mapply() ...
[16:11:17.893] Number of chunks: 1
[16:11:17.894] getGlobalsAndPackagesXApply() ...
[16:11:17.894]  - future.globals: TRUE
[16:11:17.894] getGlobalsAndPackages() ...
[16:11:17.894] Searching for globals...
[16:11:17.895] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:17.896] Searching for globals ... DONE
[16:11:17.896] Resolving globals: FALSE
[16:11:17.896] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:17.896] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:17.897] - globals: [1] ‘FUN’
[16:11:17.897] 
[16:11:17.897] getGlobalsAndPackages() ... DONE
[16:11:17.897]  - globals found/used: [n=1] ‘FUN’
[16:11:17.897]  - needed namespaces: [n=0] 
[16:11:17.897] Finding globals ... DONE
[16:11:17.897] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:17.897] List of 2
[16:11:17.897]  $ ...future.FUN:function (x, y)  
[16:11:17.897]  $ MoreArgs     : NULL
[16:11:17.897]  - attr(*, "where")=List of 2
[16:11:17.897]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:17.897]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:17.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:17.897]  - attr(*, "resolved")= logi FALSE
[16:11:17.897]  - attr(*, "total_size")= num NA
[16:11:17.902] Packages to be attached in all futures: [n=0] 
[16:11:17.902] getGlobalsAndPackagesXApply() ... DONE
[16:11:17.902] Number of futures (= number of chunks): 1
[16:11:17.902] Launching 1 futures (chunks) ...
[16:11:17.903] Chunk #1 of 1 ...
[16:11:17.903]  - Finding globals in '...' for chunk #1 ...
[16:11:17.903] getGlobalsAndPackages() ...
[16:11:17.903] Searching for globals...
[16:11:17.903] 
[16:11:17.903] Searching for globals ... DONE
[16:11:17.903] - globals: [0] <none>
[16:11:17.903] getGlobalsAndPackages() ... DONE
[16:11:17.904]    + additional globals found: [n=0] 
[16:11:17.904]    + additional namespaces needed: [n=0] 
[16:11:17.904]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:17.904]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:17.904]  - seeds: <none>
[16:11:17.904] getGlobalsAndPackages() ...
[16:11:17.904] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:17.904] Resolving globals: FALSE
[16:11:17.905] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:17.905] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:17.905] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:17.905] 
[16:11:17.906] getGlobalsAndPackages() ... DONE
[16:11:17.906] run() for ‘Future’ ...
[16:11:17.906] - state: ‘created’
[16:11:17.906] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:17.910] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:17.910] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:17.910]   - Field: ‘label’
[16:11:17.910]   - Field: ‘local’
[16:11:17.910]   - Field: ‘owner’
[16:11:17.910]   - Field: ‘envir’
[16:11:17.910]   - Field: ‘packages’
[16:11:17.910]   - Field: ‘gc’
[16:11:17.910]   - Field: ‘conditions’
[16:11:17.910]   - Field: ‘expr’
[16:11:17.911]   - Field: ‘uuid’
[16:11:17.911]   - Field: ‘seed’
[16:11:17.911]   - Field: ‘version’
[16:11:17.911]   - Field: ‘result’
[16:11:17.911]   - Field: ‘asynchronous’
[16:11:17.911]   - Field: ‘calls’
[16:11:17.911]   - Field: ‘globals’
[16:11:17.911]   - Field: ‘stdout’
[16:11:17.911]   - Field: ‘earlySignal’
[16:11:17.911]   - Field: ‘lazy’
[16:11:17.911]   - Field: ‘state’
[16:11:17.912] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:17.912] - Launch lazy future ...
[16:11:17.912] Packages needed by the future expression (n = 0): <none>
[16:11:17.912] Packages needed by future strategies (n = 0): <none>
[16:11:17.912] {
[16:11:17.912]     {
[16:11:17.912]         {
[16:11:17.912]             ...future.startTime <- base::Sys.time()
[16:11:17.912]             {
[16:11:17.912]                 {
[16:11:17.912]                   {
[16:11:17.912]                     base::local({
[16:11:17.912]                       has_future <- base::requireNamespace("future", 
[16:11:17.912]                         quietly = TRUE)
[16:11:17.912]                       if (has_future) {
[16:11:17.912]                         ns <- base::getNamespace("future")
[16:11:17.912]                         version <- ns[[".package"]][["version"]]
[16:11:17.912]                         if (is.null(version)) 
[16:11:17.912]                           version <- utils::packageVersion("future")
[16:11:17.912]                       }
[16:11:17.912]                       else {
[16:11:17.912]                         version <- NULL
[16:11:17.912]                       }
[16:11:17.912]                       if (!has_future || version < "1.8.0") {
[16:11:17.912]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:17.912]                           "", base::R.version$version.string), 
[16:11:17.912]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:17.912]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:17.912]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:17.912]                             "release", "version")], collapse = " "), 
[16:11:17.912]                           hostname = base::Sys.info()[["nodename"]])
[16:11:17.912]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:17.912]                           info)
[16:11:17.912]                         info <- base::paste(info, collapse = "; ")
[16:11:17.912]                         if (!has_future) {
[16:11:17.912]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:17.912]                             info)
[16:11:17.912]                         }
[16:11:17.912]                         else {
[16:11:17.912]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:17.912]                             info, version)
[16:11:17.912]                         }
[16:11:17.912]                         base::stop(msg)
[16:11:17.912]                       }
[16:11:17.912]                     })
[16:11:17.912]                   }
[16:11:17.912]                   options(future.plan = NULL)
[16:11:17.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:17.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:17.912]                 }
[16:11:17.912]                 ...future.workdir <- getwd()
[16:11:17.912]             }
[16:11:17.912]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:17.912]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:17.912]         }
[16:11:17.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:17.912]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:17.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:17.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:17.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:17.912]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:17.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:17.912]             base::names(...future.oldOptions))
[16:11:17.912]     }
[16:11:17.912]     if (TRUE) {
[16:11:17.912]     }
[16:11:17.912]     else {
[16:11:17.912]         if (NA) {
[16:11:17.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:17.912]                 open = "w")
[16:11:17.912]         }
[16:11:17.912]         else {
[16:11:17.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:17.912]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:17.912]         }
[16:11:17.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:17.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:17.912]             base::sink(type = "output", split = FALSE)
[16:11:17.912]             base::close(...future.stdout)
[16:11:17.912]         }, add = TRUE)
[16:11:17.912]     }
[16:11:17.912]     ...future.frame <- base::sys.nframe()
[16:11:17.912]     ...future.conditions <- base::list()
[16:11:17.912]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:17.912]     if (FALSE) {
[16:11:17.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:17.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:17.912]     }
[16:11:17.912]     ...future.result <- base::tryCatch({
[16:11:17.912]         base::withCallingHandlers({
[16:11:17.912]             ...future.value <- base::withVisible(base::local({
[16:11:17.912]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:17.912]                 if (!identical(...future.globals.maxSize.org, 
[16:11:17.912]                   ...future.globals.maxSize)) {
[16:11:17.912]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:17.912]                   on.exit(options(oopts), add = TRUE)
[16:11:17.912]                 }
[16:11:17.912]                 {
[16:11:17.912]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:17.912]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:17.912]                     USE.NAMES = FALSE)
[16:11:17.912]                   do.call(mapply, args = args)
[16:11:17.912]                 }
[16:11:17.912]             }))
[16:11:17.912]             future::FutureResult(value = ...future.value$value, 
[16:11:17.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:17.912]                   ...future.rng), globalenv = if (FALSE) 
[16:11:17.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:17.912]                     ...future.globalenv.names))
[16:11:17.912]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:17.912]         }, condition = base::local({
[16:11:17.912]             c <- base::c
[16:11:17.912]             inherits <- base::inherits
[16:11:17.912]             invokeRestart <- base::invokeRestart
[16:11:17.912]             length <- base::length
[16:11:17.912]             list <- base::list
[16:11:17.912]             seq.int <- base::seq.int
[16:11:17.912]             signalCondition <- base::signalCondition
[16:11:17.912]             sys.calls <- base::sys.calls
[16:11:17.912]             `[[` <- base::`[[`
[16:11:17.912]             `+` <- base::`+`
[16:11:17.912]             `<<-` <- base::`<<-`
[16:11:17.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:17.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:17.912]                   3L)]
[16:11:17.912]             }
[16:11:17.912]             function(cond) {
[16:11:17.912]                 is_error <- inherits(cond, "error")
[16:11:17.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:17.912]                   NULL)
[16:11:17.912]                 if (is_error) {
[16:11:17.912]                   sessionInformation <- function() {
[16:11:17.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:17.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:17.912]                       search = base::search(), system = base::Sys.info())
[16:11:17.912]                   }
[16:11:17.912]                   ...future.conditions[[length(...future.conditions) + 
[16:11:17.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:17.912]                     cond$call), session = sessionInformation(), 
[16:11:17.912]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:17.912]                   signalCondition(cond)
[16:11:17.912]                 }
[16:11:17.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:17.912]                 "immediateCondition"))) {
[16:11:17.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:17.912]                   ...future.conditions[[length(...future.conditions) + 
[16:11:17.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:17.912]                   if (TRUE && !signal) {
[16:11:17.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:17.912]                     {
[16:11:17.912]                       inherits <- base::inherits
[16:11:17.912]                       invokeRestart <- base::invokeRestart
[16:11:17.912]                       is.null <- base::is.null
[16:11:17.912]                       muffled <- FALSE
[16:11:17.912]                       if (inherits(cond, "message")) {
[16:11:17.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:17.912]                         if (muffled) 
[16:11:17.912]                           invokeRestart("muffleMessage")
[16:11:17.912]                       }
[16:11:17.912]                       else if (inherits(cond, "warning")) {
[16:11:17.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:17.912]                         if (muffled) 
[16:11:17.912]                           invokeRestart("muffleWarning")
[16:11:17.912]                       }
[16:11:17.912]                       else if (inherits(cond, "condition")) {
[16:11:17.912]                         if (!is.null(pattern)) {
[16:11:17.912]                           computeRestarts <- base::computeRestarts
[16:11:17.912]                           grepl <- base::grepl
[16:11:17.912]                           restarts <- computeRestarts(cond)
[16:11:17.912]                           for (restart in restarts) {
[16:11:17.912]                             name <- restart$name
[16:11:17.912]                             if (is.null(name)) 
[16:11:17.912]                               next
[16:11:17.912]                             if (!grepl(pattern, name)) 
[16:11:17.912]                               next
[16:11:17.912]                             invokeRestart(restart)
[16:11:17.912]                             muffled <- TRUE
[16:11:17.912]                             break
[16:11:17.912]                           }
[16:11:17.912]                         }
[16:11:17.912]                       }
[16:11:17.912]                       invisible(muffled)
[16:11:17.912]                     }
[16:11:17.912]                     muffleCondition(cond, pattern = "^muffle")
[16:11:17.912]                   }
[16:11:17.912]                 }
[16:11:17.912]                 else {
[16:11:17.912]                   if (TRUE) {
[16:11:17.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:17.912]                     {
[16:11:17.912]                       inherits <- base::inherits
[16:11:17.912]                       invokeRestart <- base::invokeRestart
[16:11:17.912]                       is.null <- base::is.null
[16:11:17.912]                       muffled <- FALSE
[16:11:17.912]                       if (inherits(cond, "message")) {
[16:11:17.912]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:17.912]                         if (muffled) 
[16:11:17.912]                           invokeRestart("muffleMessage")
[16:11:17.912]                       }
[16:11:17.912]                       else if (inherits(cond, "warning")) {
[16:11:17.912]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:17.912]                         if (muffled) 
[16:11:17.912]                           invokeRestart("muffleWarning")
[16:11:17.912]                       }
[16:11:17.912]                       else if (inherits(cond, "condition")) {
[16:11:17.912]                         if (!is.null(pattern)) {
[16:11:17.912]                           computeRestarts <- base::computeRestarts
[16:11:17.912]                           grepl <- base::grepl
[16:11:17.912]                           restarts <- computeRestarts(cond)
[16:11:17.912]                           for (restart in restarts) {
[16:11:17.912]                             name <- restart$name
[16:11:17.912]                             if (is.null(name)) 
[16:11:17.912]                               next
[16:11:17.912]                             if (!grepl(pattern, name)) 
[16:11:17.912]                               next
[16:11:17.912]                             invokeRestart(restart)
[16:11:17.912]                             muffled <- TRUE
[16:11:17.912]                             break
[16:11:17.912]                           }
[16:11:17.912]                         }
[16:11:17.912]                       }
[16:11:17.912]                       invisible(muffled)
[16:11:17.912]                     }
[16:11:17.912]                     muffleCondition(cond, pattern = "^muffle")
[16:11:17.912]                   }
[16:11:17.912]                 }
[16:11:17.912]             }
[16:11:17.912]         }))
[16:11:17.912]     }, error = function(ex) {
[16:11:17.912]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:17.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:17.912]                 ...future.rng), started = ...future.startTime, 
[16:11:17.912]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:17.912]             version = "1.8"), class = "FutureResult")
[16:11:17.912]     }, finally = {
[16:11:17.912]         if (!identical(...future.workdir, getwd())) 
[16:11:17.912]             setwd(...future.workdir)
[16:11:17.912]         {
[16:11:17.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:17.912]                 ...future.oldOptions$nwarnings <- NULL
[16:11:17.912]             }
[16:11:17.912]             base::options(...future.oldOptions)
[16:11:17.912]             if (.Platform$OS.type == "windows") {
[16:11:17.912]                 old_names <- names(...future.oldEnvVars)
[16:11:17.912]                 envs <- base::Sys.getenv()
[16:11:17.912]                 names <- names(envs)
[16:11:17.912]                 common <- intersect(names, old_names)
[16:11:17.912]                 added <- setdiff(names, old_names)
[16:11:17.912]                 removed <- setdiff(old_names, names)
[16:11:17.912]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:17.912]                   envs[common]]
[16:11:17.912]                 NAMES <- toupper(changed)
[16:11:17.912]                 args <- list()
[16:11:17.912]                 for (kk in seq_along(NAMES)) {
[16:11:17.912]                   name <- changed[[kk]]
[16:11:17.912]                   NAME <- NAMES[[kk]]
[16:11:17.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:17.912]                     next
[16:11:17.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:17.912]                 }
[16:11:17.912]                 NAMES <- toupper(added)
[16:11:17.912]                 for (kk in seq_along(NAMES)) {
[16:11:17.912]                   name <- added[[kk]]
[16:11:17.912]                   NAME <- NAMES[[kk]]
[16:11:17.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:17.912]                     next
[16:11:17.912]                   args[[name]] <- ""
[16:11:17.912]                 }
[16:11:17.912]                 NAMES <- toupper(removed)
[16:11:17.912]                 for (kk in seq_along(NAMES)) {
[16:11:17.912]                   name <- removed[[kk]]
[16:11:17.912]                   NAME <- NAMES[[kk]]
[16:11:17.912]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:17.912]                     next
[16:11:17.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:17.912]                 }
[16:11:17.912]                 if (length(args) > 0) 
[16:11:17.912]                   base::do.call(base::Sys.setenv, args = args)
[16:11:17.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:17.912]             }
[16:11:17.912]             else {
[16:11:17.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:17.912]             }
[16:11:17.912]             {
[16:11:17.912]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:17.912]                   0L) {
[16:11:17.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:17.912]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:17.912]                   base::options(opts)
[16:11:17.912]                 }
[16:11:17.912]                 {
[16:11:17.912]                   {
[16:11:17.912]                     NULL
[16:11:17.912]                     RNGkind("Mersenne-Twister")
[16:11:17.912]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:17.912]                       inherits = FALSE)
[16:11:17.912]                   }
[16:11:17.912]                   options(future.plan = NULL)
[16:11:17.912]                   if (is.na(NA_character_)) 
[16:11:17.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:17.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:17.912]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:17.912]                     envir = parent.frame()) 
[16:11:17.912]                   {
[16:11:17.912]                     default_workers <- missing(workers)
[16:11:17.912]                     if (is.function(workers)) 
[16:11:17.912]                       workers <- workers()
[16:11:17.912]                     workers <- structure(as.integer(workers), 
[16:11:17.912]                       class = class(workers))
[16:11:17.912]                     stop_if_not(is.finite(workers), workers >= 
[16:11:17.912]                       1L)
[16:11:17.912]                     if ((workers == 1L && !inherits(workers, 
[16:11:17.912]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:17.912]                       if (default_workers) 
[16:11:17.912]                         supportsMulticore(warn = TRUE)
[16:11:17.912]                       return(sequential(..., envir = envir))
[16:11:17.912]                     }
[16:11:17.912]                     oopts <- options(mc.cores = workers)
[16:11:17.912]                     on.exit(options(oopts))
[16:11:17.912]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:17.912]                       envir = envir)
[16:11:17.912]                     if (!future$lazy) 
[16:11:17.912]                       future <- run(future)
[16:11:17.912]                     invisible(future)
[16:11:17.912]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:17.912]                 }
[16:11:17.912]             }
[16:11:17.912]         }
[16:11:17.912]     })
[16:11:17.912]     if (FALSE) {
[16:11:17.912]         base::sink(type = "output", split = FALSE)
[16:11:17.912]         if (NA) {
[16:11:17.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:17.912]         }
[16:11:17.912]         else {
[16:11:17.912]             ...future.result["stdout"] <- base::list(NULL)
[16:11:17.912]         }
[16:11:17.912]         base::close(...future.stdout)
[16:11:17.912]         ...future.stdout <- NULL
[16:11:17.912]     }
[16:11:17.912]     ...future.result$conditions <- ...future.conditions
[16:11:17.912]     ...future.result$finished <- base::Sys.time()
[16:11:17.912]     ...future.result
[16:11:17.912] }
[16:11:17.914] assign_globals() ...
[16:11:17.914] List of 5
[16:11:17.914]  $ ...future.FUN            :function (x, y)  
[16:11:17.914]  $ MoreArgs                 : NULL
[16:11:17.914]  $ ...future.elements_ii    :List of 2
[16:11:17.914]   ..$ :List of 2
[16:11:17.914]   .. ..$ : int 1
[16:11:17.914]   .. ..$ : int 0
[16:11:17.914]   ..$ :List of 2
[16:11:17.914]   .. ..$ : int 0
[16:11:17.914]   .. ..$ : int 1
[16:11:17.914]  $ ...future.seeds_ii       : NULL
[16:11:17.914]  $ ...future.globals.maxSize: NULL
[16:11:17.914]  - attr(*, "resolved")= logi FALSE
[16:11:17.914]  - attr(*, "total_size")= num 6480
[16:11:17.914]  - attr(*, "where")=List of 5
[16:11:17.914]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:17.914]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:17.914]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:17.914]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:17.914]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:17.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:17.914]  - attr(*, "already-done")= logi TRUE
[16:11:17.920] - reassign environment for ‘...future.FUN’
[16:11:17.920] - copied ‘...future.FUN’ to environment
[16:11:17.920] - copied ‘MoreArgs’ to environment
[16:11:17.920] - copied ‘...future.elements_ii’ to environment
[16:11:17.920] - copied ‘...future.seeds_ii’ to environment
[16:11:17.920] - copied ‘...future.globals.maxSize’ to environment
[16:11:17.920] assign_globals() ... done
[16:11:17.921] plan(): Setting new future strategy stack:
[16:11:17.921] List of future strategies:
[16:11:17.921] 1. sequential:
[16:11:17.921]    - args: function (..., envir = parent.frame())
[16:11:17.921]    - tweaked: FALSE
[16:11:17.921]    - call: NULL
[16:11:17.921] plan(): nbrOfWorkers() = 1
[16:11:18.423] plan(): Setting new future strategy stack:
[16:11:18.423] List of future strategies:
[16:11:18.423] 1. multicore:
[16:11:18.423]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:18.423]    - tweaked: FALSE
[16:11:18.423]    - call: plan(strategy)
[16:11:18.427] plan(): nbrOfWorkers() = 1
[16:11:18.427] SequentialFuture started (and completed)
[16:11:18.427] - Launch lazy future ... done
[16:11:18.427] run() for ‘SequentialFuture’ ... done
[16:11:18.427] Created future:
[16:11:18.427] SequentialFuture:
[16:11:18.427] Label: ‘future_mapply-1’
[16:11:18.427] Expression:
[16:11:18.427] {
[16:11:18.427]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:18.427]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:18.427]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:18.427]         on.exit(options(oopts), add = TRUE)
[16:11:18.427]     }
[16:11:18.427]     {
[16:11:18.427]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:18.427]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:18.427]         do.call(mapply, args = args)
[16:11:18.427]     }
[16:11:18.427] }
[16:11:18.427] Lazy evaluation: FALSE
[16:11:18.427] Asynchronous evaluation: FALSE
[16:11:18.427] Local evaluation: TRUE
[16:11:18.427] Environment: R_GlobalEnv
[16:11:18.427] Capture standard output: NA
[16:11:18.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:18.427] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:18.427] Packages: <none>
[16:11:18.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:18.427] Resolved: TRUE
[16:11:18.427] Value: 224 bytes of class ‘list’
[16:11:18.427] Early signaling: FALSE
[16:11:18.427] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:18.427] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:18.429] Chunk #1 of 1 ... DONE
[16:11:18.429] Launching 1 futures (chunks) ... DONE
[16:11:18.429] Resolving 1 futures (chunks) ...
[16:11:18.454] resolve() on list ...
[16:11:18.454]  recursive: 0
[16:11:18.454]  length: 1
[16:11:18.454] 
[16:11:18.454] resolved() for ‘SequentialFuture’ ...
[16:11:18.454] - state: ‘finished’
[16:11:18.454] - run: TRUE
[16:11:18.454] - result: ‘FutureResult’
[16:11:18.455] resolved() for ‘SequentialFuture’ ... done
[16:11:18.455] Future #1
[16:11:18.455] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:18.455] - nx: 1
[16:11:18.455] - relay: TRUE
[16:11:18.455] - stdout: TRUE
[16:11:18.455] - signal: TRUE
[16:11:18.455] - resignal: FALSE
[16:11:18.455] - force: TRUE
[16:11:18.455] - relayed: [n=1] FALSE
[16:11:18.456] - queued futures: [n=1] FALSE
[16:11:18.456]  - until=1
[16:11:18.456]  - relaying element #1
[16:11:18.456] - relayed: [n=1] TRUE
[16:11:18.456] - queued futures: [n=1] TRUE
[16:11:18.456] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:18.456]  length: 0 (resolved future 1)
[16:11:18.456] Relaying remaining futures
[16:11:18.456] signalConditionsASAP(NULL, pos=0) ...
[16:11:18.457] - nx: 1
[16:11:18.457] - relay: TRUE
[16:11:18.457] - stdout: TRUE
[16:11:18.457] - signal: TRUE
[16:11:18.457] - resignal: FALSE
[16:11:18.457] - force: TRUE
[16:11:18.457] - relayed: [n=1] TRUE
[16:11:18.457] - queued futures: [n=1] TRUE
 - flush all
[16:11:18.457] - relayed: [n=1] TRUE
[16:11:18.457] - queued futures: [n=1] TRUE
[16:11:18.457] signalConditionsASAP(NULL, pos=0) ... done
[16:11:18.458] resolve() on list ... DONE
[16:11:18.458]  - Number of value chunks collected: 1
[16:11:18.458] Resolving 1 futures (chunks) ... DONE
[16:11:18.458] Reducing values from 1 chunks ...
[16:11:18.458]  - Number of values collected after concatenation: 2
[16:11:18.458]  - Number of values expected: 2
[16:11:18.458] Reducing values from 1 chunks ... DONE
[16:11:18.458] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[16:11:18.459] plan(): Setting new future strategy stack:
[16:11:18.459] List of future strategies:
[16:11:18.459] 1. multisession:
[16:11:18.459]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:18.459]    - tweaked: FALSE
[16:11:18.459]    - call: plan(strategy)
[16:11:18.459] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:11:18.459] multisession:
[16:11:18.459] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:18.459] - tweaked: FALSE
[16:11:18.459] - call: plan(strategy)
[16:11:18.463] getGlobalsAndPackages() ...
[16:11:18.463] Not searching for globals
[16:11:18.464] - globals: [0] <none>
[16:11:18.464] getGlobalsAndPackages() ... DONE
[16:11:18.464] Packages needed by the future expression (n = 0): <none>
[16:11:18.464] Packages needed by future strategies (n = 0): <none>
[16:11:18.465] {
[16:11:18.465]     {
[16:11:18.465]         {
[16:11:18.465]             ...future.startTime <- base::Sys.time()
[16:11:18.465]             {
[16:11:18.465]                 {
[16:11:18.465]                   {
[16:11:18.465]                     base::local({
[16:11:18.465]                       has_future <- base::requireNamespace("future", 
[16:11:18.465]                         quietly = TRUE)
[16:11:18.465]                       if (has_future) {
[16:11:18.465]                         ns <- base::getNamespace("future")
[16:11:18.465]                         version <- ns[[".package"]][["version"]]
[16:11:18.465]                         if (is.null(version)) 
[16:11:18.465]                           version <- utils::packageVersion("future")
[16:11:18.465]                       }
[16:11:18.465]                       else {
[16:11:18.465]                         version <- NULL
[16:11:18.465]                       }
[16:11:18.465]                       if (!has_future || version < "1.8.0") {
[16:11:18.465]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:18.465]                           "", base::R.version$version.string), 
[16:11:18.465]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:18.465]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:18.465]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:18.465]                             "release", "version")], collapse = " "), 
[16:11:18.465]                           hostname = base::Sys.info()[["nodename"]])
[16:11:18.465]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:18.465]                           info)
[16:11:18.465]                         info <- base::paste(info, collapse = "; ")
[16:11:18.465]                         if (!has_future) {
[16:11:18.465]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:18.465]                             info)
[16:11:18.465]                         }
[16:11:18.465]                         else {
[16:11:18.465]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:18.465]                             info, version)
[16:11:18.465]                         }
[16:11:18.465]                         base::stop(msg)
[16:11:18.465]                       }
[16:11:18.465]                     })
[16:11:18.465]                   }
[16:11:18.465]                   options(future.plan = NULL)
[16:11:18.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:18.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:18.465]                 }
[16:11:18.465]                 ...future.workdir <- getwd()
[16:11:18.465]             }
[16:11:18.465]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:18.465]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:18.465]         }
[16:11:18.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:18.465]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:18.465]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:18.465]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:18.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:18.465]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:18.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:18.465]             base::names(...future.oldOptions))
[16:11:18.465]     }
[16:11:18.465]     if (FALSE) {
[16:11:18.465]     }
[16:11:18.465]     else {
[16:11:18.465]         if (TRUE) {
[16:11:18.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:18.465]                 open = "w")
[16:11:18.465]         }
[16:11:18.465]         else {
[16:11:18.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:18.465]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:18.465]         }
[16:11:18.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:18.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:18.465]             base::sink(type = "output", split = FALSE)
[16:11:18.465]             base::close(...future.stdout)
[16:11:18.465]         }, add = TRUE)
[16:11:18.465]     }
[16:11:18.465]     ...future.frame <- base::sys.nframe()
[16:11:18.465]     ...future.conditions <- base::list()
[16:11:18.465]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:18.465]     if (FALSE) {
[16:11:18.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:18.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:18.465]     }
[16:11:18.465]     ...future.result <- base::tryCatch({
[16:11:18.465]         base::withCallingHandlers({
[16:11:18.465]             ...future.value <- base::withVisible(base::local(NA))
[16:11:18.465]             future::FutureResult(value = ...future.value$value, 
[16:11:18.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:18.465]                   ...future.rng), globalenv = if (FALSE) 
[16:11:18.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:18.465]                     ...future.globalenv.names))
[16:11:18.465]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:18.465]         }, condition = base::local({
[16:11:18.465]             c <- base::c
[16:11:18.465]             inherits <- base::inherits
[16:11:18.465]             invokeRestart <- base::invokeRestart
[16:11:18.465]             length <- base::length
[16:11:18.465]             list <- base::list
[16:11:18.465]             seq.int <- base::seq.int
[16:11:18.465]             signalCondition <- base::signalCondition
[16:11:18.465]             sys.calls <- base::sys.calls
[16:11:18.465]             `[[` <- base::`[[`
[16:11:18.465]             `+` <- base::`+`
[16:11:18.465]             `<<-` <- base::`<<-`
[16:11:18.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:18.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:18.465]                   3L)]
[16:11:18.465]             }
[16:11:18.465]             function(cond) {
[16:11:18.465]                 is_error <- inherits(cond, "error")
[16:11:18.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:18.465]                   NULL)
[16:11:18.465]                 if (is_error) {
[16:11:18.465]                   sessionInformation <- function() {
[16:11:18.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:18.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:18.465]                       search = base::search(), system = base::Sys.info())
[16:11:18.465]                   }
[16:11:18.465]                   ...future.conditions[[length(...future.conditions) + 
[16:11:18.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:18.465]                     cond$call), session = sessionInformation(), 
[16:11:18.465]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:18.465]                   signalCondition(cond)
[16:11:18.465]                 }
[16:11:18.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:18.465]                 "immediateCondition"))) {
[16:11:18.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:18.465]                   ...future.conditions[[length(...future.conditions) + 
[16:11:18.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:18.465]                   if (TRUE && !signal) {
[16:11:18.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:18.465]                     {
[16:11:18.465]                       inherits <- base::inherits
[16:11:18.465]                       invokeRestart <- base::invokeRestart
[16:11:18.465]                       is.null <- base::is.null
[16:11:18.465]                       muffled <- FALSE
[16:11:18.465]                       if (inherits(cond, "message")) {
[16:11:18.465]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:18.465]                         if (muffled) 
[16:11:18.465]                           invokeRestart("muffleMessage")
[16:11:18.465]                       }
[16:11:18.465]                       else if (inherits(cond, "warning")) {
[16:11:18.465]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:18.465]                         if (muffled) 
[16:11:18.465]                           invokeRestart("muffleWarning")
[16:11:18.465]                       }
[16:11:18.465]                       else if (inherits(cond, "condition")) {
[16:11:18.465]                         if (!is.null(pattern)) {
[16:11:18.465]                           computeRestarts <- base::computeRestarts
[16:11:18.465]                           grepl <- base::grepl
[16:11:18.465]                           restarts <- computeRestarts(cond)
[16:11:18.465]                           for (restart in restarts) {
[16:11:18.465]                             name <- restart$name
[16:11:18.465]                             if (is.null(name)) 
[16:11:18.465]                               next
[16:11:18.465]                             if (!grepl(pattern, name)) 
[16:11:18.465]                               next
[16:11:18.465]                             invokeRestart(restart)
[16:11:18.465]                             muffled <- TRUE
[16:11:18.465]                             break
[16:11:18.465]                           }
[16:11:18.465]                         }
[16:11:18.465]                       }
[16:11:18.465]                       invisible(muffled)
[16:11:18.465]                     }
[16:11:18.465]                     muffleCondition(cond, pattern = "^muffle")
[16:11:18.465]                   }
[16:11:18.465]                 }
[16:11:18.465]                 else {
[16:11:18.465]                   if (TRUE) {
[16:11:18.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:18.465]                     {
[16:11:18.465]                       inherits <- base::inherits
[16:11:18.465]                       invokeRestart <- base::invokeRestart
[16:11:18.465]                       is.null <- base::is.null
[16:11:18.465]                       muffled <- FALSE
[16:11:18.465]                       if (inherits(cond, "message")) {
[16:11:18.465]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:18.465]                         if (muffled) 
[16:11:18.465]                           invokeRestart("muffleMessage")
[16:11:18.465]                       }
[16:11:18.465]                       else if (inherits(cond, "warning")) {
[16:11:18.465]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:18.465]                         if (muffled) 
[16:11:18.465]                           invokeRestart("muffleWarning")
[16:11:18.465]                       }
[16:11:18.465]                       else if (inherits(cond, "condition")) {
[16:11:18.465]                         if (!is.null(pattern)) {
[16:11:18.465]                           computeRestarts <- base::computeRestarts
[16:11:18.465]                           grepl <- base::grepl
[16:11:18.465]                           restarts <- computeRestarts(cond)
[16:11:18.465]                           for (restart in restarts) {
[16:11:18.465]                             name <- restart$name
[16:11:18.465]                             if (is.null(name)) 
[16:11:18.465]                               next
[16:11:18.465]                             if (!grepl(pattern, name)) 
[16:11:18.465]                               next
[16:11:18.465]                             invokeRestart(restart)
[16:11:18.465]                             muffled <- TRUE
[16:11:18.465]                             break
[16:11:18.465]                           }
[16:11:18.465]                         }
[16:11:18.465]                       }
[16:11:18.465]                       invisible(muffled)
[16:11:18.465]                     }
[16:11:18.465]                     muffleCondition(cond, pattern = "^muffle")
[16:11:18.465]                   }
[16:11:18.465]                 }
[16:11:18.465]             }
[16:11:18.465]         }))
[16:11:18.465]     }, error = function(ex) {
[16:11:18.465]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:18.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:18.465]                 ...future.rng), started = ...future.startTime, 
[16:11:18.465]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:18.465]             version = "1.8"), class = "FutureResult")
[16:11:18.465]     }, finally = {
[16:11:18.465]         if (!identical(...future.workdir, getwd())) 
[16:11:18.465]             setwd(...future.workdir)
[16:11:18.465]         {
[16:11:18.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:18.465]                 ...future.oldOptions$nwarnings <- NULL
[16:11:18.465]             }
[16:11:18.465]             base::options(...future.oldOptions)
[16:11:18.465]             if (.Platform$OS.type == "windows") {
[16:11:18.465]                 old_names <- names(...future.oldEnvVars)
[16:11:18.465]                 envs <- base::Sys.getenv()
[16:11:18.465]                 names <- names(envs)
[16:11:18.465]                 common <- intersect(names, old_names)
[16:11:18.465]                 added <- setdiff(names, old_names)
[16:11:18.465]                 removed <- setdiff(old_names, names)
[16:11:18.465]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:18.465]                   envs[common]]
[16:11:18.465]                 NAMES <- toupper(changed)
[16:11:18.465]                 args <- list()
[16:11:18.465]                 for (kk in seq_along(NAMES)) {
[16:11:18.465]                   name <- changed[[kk]]
[16:11:18.465]                   NAME <- NAMES[[kk]]
[16:11:18.465]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:18.465]                     next
[16:11:18.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:18.465]                 }
[16:11:18.465]                 NAMES <- toupper(added)
[16:11:18.465]                 for (kk in seq_along(NAMES)) {
[16:11:18.465]                   name <- added[[kk]]
[16:11:18.465]                   NAME <- NAMES[[kk]]
[16:11:18.465]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:18.465]                     next
[16:11:18.465]                   args[[name]] <- ""
[16:11:18.465]                 }
[16:11:18.465]                 NAMES <- toupper(removed)
[16:11:18.465]                 for (kk in seq_along(NAMES)) {
[16:11:18.465]                   name <- removed[[kk]]
[16:11:18.465]                   NAME <- NAMES[[kk]]
[16:11:18.465]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:18.465]                     next
[16:11:18.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:18.465]                 }
[16:11:18.465]                 if (length(args) > 0) 
[16:11:18.465]                   base::do.call(base::Sys.setenv, args = args)
[16:11:18.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:18.465]             }
[16:11:18.465]             else {
[16:11:18.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:18.465]             }
[16:11:18.465]             {
[16:11:18.465]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:18.465]                   0L) {
[16:11:18.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:18.465]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:18.465]                   base::options(opts)
[16:11:18.465]                 }
[16:11:18.465]                 {
[16:11:18.465]                   {
[16:11:18.465]                     NULL
[16:11:18.465]                     RNGkind("Mersenne-Twister")
[16:11:18.465]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:18.465]                       inherits = FALSE)
[16:11:18.465]                   }
[16:11:18.465]                   options(future.plan = NULL)
[16:11:18.465]                   if (is.na(NA_character_)) 
[16:11:18.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:18.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:18.465]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:18.465]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:18.465]                     envir = parent.frame()) 
[16:11:18.465]                   {
[16:11:18.465]                     if (is.function(workers)) 
[16:11:18.465]                       workers <- workers()
[16:11:18.465]                     workers <- structure(as.integer(workers), 
[16:11:18.465]                       class = class(workers))
[16:11:18.465]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:18.465]                       workers >= 1)
[16:11:18.465]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:18.465]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:18.465]                     }
[16:11:18.465]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:18.465]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:18.465]                       envir = envir)
[16:11:18.465]                     if (!future$lazy) 
[16:11:18.465]                       future <- run(future)
[16:11:18.465]                     invisible(future)
[16:11:18.465]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:18.465]                 }
[16:11:18.465]             }
[16:11:18.465]         }
[16:11:18.465]     })
[16:11:18.465]     if (TRUE) {
[16:11:18.465]         base::sink(type = "output", split = FALSE)
[16:11:18.465]         if (TRUE) {
[16:11:18.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:18.465]         }
[16:11:18.465]         else {
[16:11:18.465]             ...future.result["stdout"] <- base::list(NULL)
[16:11:18.465]         }
[16:11:18.465]         base::close(...future.stdout)
[16:11:18.465]         ...future.stdout <- NULL
[16:11:18.465]     }
[16:11:18.465]     ...future.result$conditions <- ...future.conditions
[16:11:18.465]     ...future.result$finished <- base::Sys.time()
[16:11:18.465]     ...future.result
[16:11:18.465] }
[16:11:18.467] plan(): Setting new future strategy stack:
[16:11:18.467] List of future strategies:
[16:11:18.467] 1. sequential:
[16:11:18.467]    - args: function (..., envir = parent.frame())
[16:11:18.467]    - tweaked: FALSE
[16:11:18.467]    - call: NULL
[16:11:18.467] plan(): nbrOfWorkers() = 1
[16:11:18.468] plan(): Setting new future strategy stack:
[16:11:18.468] List of future strategies:
[16:11:18.468] 1. multisession:
[16:11:18.468]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:18.468]    - tweaked: FALSE
[16:11:18.468]    - call: plan(strategy)
[16:11:18.471] plan(): nbrOfWorkers() = 1
[16:11:18.471] SequentialFuture started (and completed)
[16:11:18.472] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:11:18.475] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:11:18.475] future_lapply() ...
[16:11:18.478] Number of chunks: 1
[16:11:18.479] getGlobalsAndPackagesXApply() ...
[16:11:18.479]  - future.globals: TRUE
[16:11:18.479] getGlobalsAndPackages() ...
[16:11:18.479] Searching for globals...
[16:11:18.480] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:18.480] Searching for globals ... DONE
[16:11:18.480] Resolving globals: FALSE
[16:11:18.481] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:18.481] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:18.481] - globals: [1] ‘FUN’
[16:11:18.481] 
[16:11:18.482] getGlobalsAndPackages() ... DONE
[16:11:18.482]  - globals found/used: [n=1] ‘FUN’
[16:11:18.482]  - needed namespaces: [n=0] 
[16:11:18.482] Finding globals ... DONE
[16:11:18.482]  - use_args: TRUE
[16:11:18.482]  - Getting '...' globals ...
[16:11:18.482] resolve() on list ...
[16:11:18.482]  recursive: 0
[16:11:18.482]  length: 1
[16:11:18.483]  elements: ‘...’
[16:11:18.483]  length: 0 (resolved future 1)
[16:11:18.483] resolve() on list ... DONE
[16:11:18.483]    - '...' content: [n=0] 
[16:11:18.483] List of 1
[16:11:18.483]  $ ...: list()
[16:11:18.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:18.483]  - attr(*, "where")=List of 1
[16:11:18.483]   ..$ ...:<environment: 0x557e20842540> 
[16:11:18.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:18.483]  - attr(*, "resolved")= logi TRUE
[16:11:18.483]  - attr(*, "total_size")= num NA
[16:11:18.485]  - Getting '...' globals ... DONE
[16:11:18.486] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:18.486] List of 2
[16:11:18.486]  $ ...future.FUN:function (x)  
[16:11:18.486]  $ ...          : list()
[16:11:18.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:18.486]  - attr(*, "where")=List of 2
[16:11:18.486]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:18.486]   ..$ ...          :<environment: 0x557e20842540> 
[16:11:18.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:18.486]  - attr(*, "resolved")= logi FALSE
[16:11:18.486]  - attr(*, "total_size")= num 4720
[16:11:18.488] Packages to be attached in all futures: [n=0] 
[16:11:18.489] getGlobalsAndPackagesXApply() ... DONE
[16:11:18.490] Number of futures (= number of chunks): 1
[16:11:18.490] Launching 1 futures (chunks) ...
[16:11:18.490] Chunk #1 of 1 ...
[16:11:18.490]  - Finding globals in 'X' for chunk #1 ...
[16:11:18.490] getGlobalsAndPackages() ...
[16:11:18.490] Searching for globals...
[16:11:18.491] 
[16:11:18.491] Searching for globals ... DONE
[16:11:18.491] - globals: [0] <none>
[16:11:18.491] getGlobalsAndPackages() ... DONE
[16:11:18.491]    + additional globals found: [n=0] 
[16:11:18.491]    + additional namespaces needed: [n=0] 
[16:11:18.491]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:18.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:18.491]  - seeds: <none>
[16:11:18.492] getGlobalsAndPackages() ...
[16:11:18.492] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:18.492] Resolving globals: FALSE
[16:11:18.492] Tweak future expression to call with '...' arguments ...
[16:11:18.492] {
[16:11:18.492]     do.call(function(...) {
[16:11:18.492]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:18.492]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:18.492]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:18.492]             on.exit(options(oopts), add = TRUE)
[16:11:18.492]         }
[16:11:18.492]         {
[16:11:18.492]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:18.492]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:18.492]                 ...future.FUN(...future.X_jj, ...)
[16:11:18.492]             })
[16:11:18.492]         }
[16:11:18.492]     }, args = future.call.arguments)
[16:11:18.492] }
[16:11:18.492] Tweak future expression to call with '...' arguments ... DONE
[16:11:18.493] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:18.493] 
[16:11:18.493] getGlobalsAndPackages() ... DONE
[16:11:18.493] run() for ‘Future’ ...
[16:11:18.493] - state: ‘created’
[16:11:18.493] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:18.497] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:18.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:18.497]   - Field: ‘label’
[16:11:18.497]   - Field: ‘local’
[16:11:18.497]   - Field: ‘owner’
[16:11:18.497]   - Field: ‘envir’
[16:11:18.497]   - Field: ‘packages’
[16:11:18.497]   - Field: ‘gc’
[16:11:18.498]   - Field: ‘conditions’
[16:11:18.498]   - Field: ‘expr’
[16:11:18.498]   - Field: ‘uuid’
[16:11:18.498]   - Field: ‘seed’
[16:11:18.498]   - Field: ‘version’
[16:11:18.498]   - Field: ‘result’
[16:11:18.498]   - Field: ‘asynchronous’
[16:11:18.498]   - Field: ‘calls’
[16:11:18.498]   - Field: ‘globals’
[16:11:18.498]   - Field: ‘stdout’
[16:11:18.498]   - Field: ‘earlySignal’
[16:11:18.499]   - Field: ‘lazy’
[16:11:18.499]   - Field: ‘state’
[16:11:18.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:18.499] - Launch lazy future ...
[16:11:18.499] Packages needed by the future expression (n = 0): <none>
[16:11:18.499] Packages needed by future strategies (n = 0): <none>
[16:11:18.500] {
[16:11:18.500]     {
[16:11:18.500]         {
[16:11:18.500]             ...future.startTime <- base::Sys.time()
[16:11:18.500]             {
[16:11:18.500]                 {
[16:11:18.500]                   {
[16:11:18.500]                     base::local({
[16:11:18.500]                       has_future <- base::requireNamespace("future", 
[16:11:18.500]                         quietly = TRUE)
[16:11:18.500]                       if (has_future) {
[16:11:18.500]                         ns <- base::getNamespace("future")
[16:11:18.500]                         version <- ns[[".package"]][["version"]]
[16:11:18.500]                         if (is.null(version)) 
[16:11:18.500]                           version <- utils::packageVersion("future")
[16:11:18.500]                       }
[16:11:18.500]                       else {
[16:11:18.500]                         version <- NULL
[16:11:18.500]                       }
[16:11:18.500]                       if (!has_future || version < "1.8.0") {
[16:11:18.500]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:18.500]                           "", base::R.version$version.string), 
[16:11:18.500]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:18.500]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:18.500]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:18.500]                             "release", "version")], collapse = " "), 
[16:11:18.500]                           hostname = base::Sys.info()[["nodename"]])
[16:11:18.500]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:18.500]                           info)
[16:11:18.500]                         info <- base::paste(info, collapse = "; ")
[16:11:18.500]                         if (!has_future) {
[16:11:18.500]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:18.500]                             info)
[16:11:18.500]                         }
[16:11:18.500]                         else {
[16:11:18.500]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:18.500]                             info, version)
[16:11:18.500]                         }
[16:11:18.500]                         base::stop(msg)
[16:11:18.500]                       }
[16:11:18.500]                     })
[16:11:18.500]                   }
[16:11:18.500]                   options(future.plan = NULL)
[16:11:18.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:18.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:18.500]                 }
[16:11:18.500]                 ...future.workdir <- getwd()
[16:11:18.500]             }
[16:11:18.500]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:18.500]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:18.500]         }
[16:11:18.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:18.500]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:18.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:18.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:18.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:18.500]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:18.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:18.500]             base::names(...future.oldOptions))
[16:11:18.500]     }
[16:11:18.500]     if (FALSE) {
[16:11:18.500]     }
[16:11:18.500]     else {
[16:11:18.500]         if (FALSE) {
[16:11:18.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:18.500]                 open = "w")
[16:11:18.500]         }
[16:11:18.500]         else {
[16:11:18.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:18.500]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:18.500]         }
[16:11:18.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:18.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:18.500]             base::sink(type = "output", split = FALSE)
[16:11:18.500]             base::close(...future.stdout)
[16:11:18.500]         }, add = TRUE)
[16:11:18.500]     }
[16:11:18.500]     ...future.frame <- base::sys.nframe()
[16:11:18.500]     ...future.conditions <- base::list()
[16:11:18.500]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:18.500]     if (FALSE) {
[16:11:18.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:18.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:18.500]     }
[16:11:18.500]     ...future.result <- base::tryCatch({
[16:11:18.500]         base::withCallingHandlers({
[16:11:18.500]             ...future.value <- base::withVisible(base::local({
[16:11:18.500]                 do.call(function(...) {
[16:11:18.500]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:18.500]                   if (!identical(...future.globals.maxSize.org, 
[16:11:18.500]                     ...future.globals.maxSize)) {
[16:11:18.500]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:18.500]                     on.exit(options(oopts), add = TRUE)
[16:11:18.500]                   }
[16:11:18.500]                   {
[16:11:18.500]                     lapply(seq_along(...future.elements_ii), 
[16:11:18.500]                       FUN = function(jj) {
[16:11:18.500]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:18.500]                         ...future.FUN(...future.X_jj, ...)
[16:11:18.500]                       })
[16:11:18.500]                   }
[16:11:18.500]                 }, args = future.call.arguments)
[16:11:18.500]             }))
[16:11:18.500]             future::FutureResult(value = ...future.value$value, 
[16:11:18.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:18.500]                   ...future.rng), globalenv = if (FALSE) 
[16:11:18.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:18.500]                     ...future.globalenv.names))
[16:11:18.500]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:18.500]         }, condition = base::local({
[16:11:18.500]             c <- base::c
[16:11:18.500]             inherits <- base::inherits
[16:11:18.500]             invokeRestart <- base::invokeRestart
[16:11:18.500]             length <- base::length
[16:11:18.500]             list <- base::list
[16:11:18.500]             seq.int <- base::seq.int
[16:11:18.500]             signalCondition <- base::signalCondition
[16:11:18.500]             sys.calls <- base::sys.calls
[16:11:18.500]             `[[` <- base::`[[`
[16:11:18.500]             `+` <- base::`+`
[16:11:18.500]             `<<-` <- base::`<<-`
[16:11:18.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:18.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:18.500]                   3L)]
[16:11:18.500]             }
[16:11:18.500]             function(cond) {
[16:11:18.500]                 is_error <- inherits(cond, "error")
[16:11:18.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:18.500]                   NULL)
[16:11:18.500]                 if (is_error) {
[16:11:18.500]                   sessionInformation <- function() {
[16:11:18.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:18.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:18.500]                       search = base::search(), system = base::Sys.info())
[16:11:18.500]                   }
[16:11:18.500]                   ...future.conditions[[length(...future.conditions) + 
[16:11:18.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:18.500]                     cond$call), session = sessionInformation(), 
[16:11:18.500]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:18.500]                   signalCondition(cond)
[16:11:18.500]                 }
[16:11:18.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:18.500]                 "immediateCondition"))) {
[16:11:18.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:18.500]                   ...future.conditions[[length(...future.conditions) + 
[16:11:18.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:18.500]                   if (TRUE && !signal) {
[16:11:18.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:18.500]                     {
[16:11:18.500]                       inherits <- base::inherits
[16:11:18.500]                       invokeRestart <- base::invokeRestart
[16:11:18.500]                       is.null <- base::is.null
[16:11:18.500]                       muffled <- FALSE
[16:11:18.500]                       if (inherits(cond, "message")) {
[16:11:18.500]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:18.500]                         if (muffled) 
[16:11:18.500]                           invokeRestart("muffleMessage")
[16:11:18.500]                       }
[16:11:18.500]                       else if (inherits(cond, "warning")) {
[16:11:18.500]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:18.500]                         if (muffled) 
[16:11:18.500]                           invokeRestart("muffleWarning")
[16:11:18.500]                       }
[16:11:18.500]                       else if (inherits(cond, "condition")) {
[16:11:18.500]                         if (!is.null(pattern)) {
[16:11:18.500]                           computeRestarts <- base::computeRestarts
[16:11:18.500]                           grepl <- base::grepl
[16:11:18.500]                           restarts <- computeRestarts(cond)
[16:11:18.500]                           for (restart in restarts) {
[16:11:18.500]                             name <- restart$name
[16:11:18.500]                             if (is.null(name)) 
[16:11:18.500]                               next
[16:11:18.500]                             if (!grepl(pattern, name)) 
[16:11:18.500]                               next
[16:11:18.500]                             invokeRestart(restart)
[16:11:18.500]                             muffled <- TRUE
[16:11:18.500]                             break
[16:11:18.500]                           }
[16:11:18.500]                         }
[16:11:18.500]                       }
[16:11:18.500]                       invisible(muffled)
[16:11:18.500]                     }
[16:11:18.500]                     muffleCondition(cond, pattern = "^muffle")
[16:11:18.500]                   }
[16:11:18.500]                 }
[16:11:18.500]                 else {
[16:11:18.500]                   if (TRUE) {
[16:11:18.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:18.500]                     {
[16:11:18.500]                       inherits <- base::inherits
[16:11:18.500]                       invokeRestart <- base::invokeRestart
[16:11:18.500]                       is.null <- base::is.null
[16:11:18.500]                       muffled <- FALSE
[16:11:18.500]                       if (inherits(cond, "message")) {
[16:11:18.500]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:18.500]                         if (muffled) 
[16:11:18.500]                           invokeRestart("muffleMessage")
[16:11:18.500]                       }
[16:11:18.500]                       else if (inherits(cond, "warning")) {
[16:11:18.500]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:18.500]                         if (muffled) 
[16:11:18.500]                           invokeRestart("muffleWarning")
[16:11:18.500]                       }
[16:11:18.500]                       else if (inherits(cond, "condition")) {
[16:11:18.500]                         if (!is.null(pattern)) {
[16:11:18.500]                           computeRestarts <- base::computeRestarts
[16:11:18.500]                           grepl <- base::grepl
[16:11:18.500]                           restarts <- computeRestarts(cond)
[16:11:18.500]                           for (restart in restarts) {
[16:11:18.500]                             name <- restart$name
[16:11:18.500]                             if (is.null(name)) 
[16:11:18.500]                               next
[16:11:18.500]                             if (!grepl(pattern, name)) 
[16:11:18.500]                               next
[16:11:18.500]                             invokeRestart(restart)
[16:11:18.500]                             muffled <- TRUE
[16:11:18.500]                             break
[16:11:18.500]                           }
[16:11:18.500]                         }
[16:11:18.500]                       }
[16:11:18.500]                       invisible(muffled)
[16:11:18.500]                     }
[16:11:18.500]                     muffleCondition(cond, pattern = "^muffle")
[16:11:18.500]                   }
[16:11:18.500]                 }
[16:11:18.500]             }
[16:11:18.500]         }))
[16:11:18.500]     }, error = function(ex) {
[16:11:18.500]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:18.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:18.500]                 ...future.rng), started = ...future.startTime, 
[16:11:18.500]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:18.500]             version = "1.8"), class = "FutureResult")
[16:11:18.500]     }, finally = {
[16:11:18.500]         if (!identical(...future.workdir, getwd())) 
[16:11:18.500]             setwd(...future.workdir)
[16:11:18.500]         {
[16:11:18.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:18.500]                 ...future.oldOptions$nwarnings <- NULL
[16:11:18.500]             }
[16:11:18.500]             base::options(...future.oldOptions)
[16:11:18.500]             if (.Platform$OS.type == "windows") {
[16:11:18.500]                 old_names <- names(...future.oldEnvVars)
[16:11:18.500]                 envs <- base::Sys.getenv()
[16:11:18.500]                 names <- names(envs)
[16:11:18.500]                 common <- intersect(names, old_names)
[16:11:18.500]                 added <- setdiff(names, old_names)
[16:11:18.500]                 removed <- setdiff(old_names, names)
[16:11:18.500]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:18.500]                   envs[common]]
[16:11:18.500]                 NAMES <- toupper(changed)
[16:11:18.500]                 args <- list()
[16:11:18.500]                 for (kk in seq_along(NAMES)) {
[16:11:18.500]                   name <- changed[[kk]]
[16:11:18.500]                   NAME <- NAMES[[kk]]
[16:11:18.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:18.500]                     next
[16:11:18.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:18.500]                 }
[16:11:18.500]                 NAMES <- toupper(added)
[16:11:18.500]                 for (kk in seq_along(NAMES)) {
[16:11:18.500]                   name <- added[[kk]]
[16:11:18.500]                   NAME <- NAMES[[kk]]
[16:11:18.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:18.500]                     next
[16:11:18.500]                   args[[name]] <- ""
[16:11:18.500]                 }
[16:11:18.500]                 NAMES <- toupper(removed)
[16:11:18.500]                 for (kk in seq_along(NAMES)) {
[16:11:18.500]                   name <- removed[[kk]]
[16:11:18.500]                   NAME <- NAMES[[kk]]
[16:11:18.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:18.500]                     next
[16:11:18.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:18.500]                 }
[16:11:18.500]                 if (length(args) > 0) 
[16:11:18.500]                   base::do.call(base::Sys.setenv, args = args)
[16:11:18.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:18.500]             }
[16:11:18.500]             else {
[16:11:18.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:18.500]             }
[16:11:18.500]             {
[16:11:18.500]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:18.500]                   0L) {
[16:11:18.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:18.500]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:18.500]                   base::options(opts)
[16:11:18.500]                 }
[16:11:18.500]                 {
[16:11:18.500]                   {
[16:11:18.500]                     NULL
[16:11:18.500]                     RNGkind("Mersenne-Twister")
[16:11:18.500]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:18.500]                       inherits = FALSE)
[16:11:18.500]                   }
[16:11:18.500]                   options(future.plan = NULL)
[16:11:18.500]                   if (is.na(NA_character_)) 
[16:11:18.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:18.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:18.500]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:18.500]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:18.500]                     envir = parent.frame()) 
[16:11:18.500]                   {
[16:11:18.500]                     if (is.function(workers)) 
[16:11:18.500]                       workers <- workers()
[16:11:18.500]                     workers <- structure(as.integer(workers), 
[16:11:18.500]                       class = class(workers))
[16:11:18.500]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:18.500]                       workers >= 1)
[16:11:18.500]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:18.500]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:18.500]                     }
[16:11:18.500]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:18.500]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:18.500]                       envir = envir)
[16:11:18.500]                     if (!future$lazy) 
[16:11:18.500]                       future <- run(future)
[16:11:18.500]                     invisible(future)
[16:11:18.500]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:18.500]                 }
[16:11:18.500]             }
[16:11:18.500]         }
[16:11:18.500]     })
[16:11:18.500]     if (TRUE) {
[16:11:18.500]         base::sink(type = "output", split = FALSE)
[16:11:18.500]         if (FALSE) {
[16:11:18.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:18.500]         }
[16:11:18.500]         else {
[16:11:18.500]             ...future.result["stdout"] <- base::list(NULL)
[16:11:18.500]         }
[16:11:18.500]         base::close(...future.stdout)
[16:11:18.500]         ...future.stdout <- NULL
[16:11:18.500]     }
[16:11:18.500]     ...future.result$conditions <- ...future.conditions
[16:11:18.500]     ...future.result$finished <- base::Sys.time()
[16:11:18.500]     ...future.result
[16:11:18.500] }
[16:11:18.501] assign_globals() ...
[16:11:18.501] List of 5
[16:11:18.501]  $ ...future.FUN            :function (x)  
[16:11:18.501]  $ future.call.arguments    : list()
[16:11:18.501]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:18.501]  $ ...future.elements_ii    :List of 2
[16:11:18.501]   ..$ : int 1
[16:11:18.501]   ..$ : int 0
[16:11:18.501]  $ ...future.seeds_ii       : NULL
[16:11:18.501]  $ ...future.globals.maxSize: NULL
[16:11:18.501]  - attr(*, "resolved")= logi FALSE
[16:11:18.501]  - attr(*, "total_size")= num 4720
[16:11:18.501]  - attr(*, "where")=List of 5
[16:11:18.501]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:18.501]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:18.501]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:18.501]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:18.501]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:18.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:18.501]  - attr(*, "already-done")= logi TRUE
[16:11:18.506] - reassign environment for ‘...future.FUN’
[16:11:18.506] - copied ‘...future.FUN’ to environment
[16:11:18.506] - copied ‘future.call.arguments’ to environment
[16:11:18.506] - copied ‘...future.elements_ii’ to environment
[16:11:18.507] - copied ‘...future.seeds_ii’ to environment
[16:11:18.507] - copied ‘...future.globals.maxSize’ to environment
[16:11:18.507] assign_globals() ... done
[16:11:18.507] plan(): Setting new future strategy stack:
[16:11:18.507] List of future strategies:
[16:11:18.507] 1. sequential:
[16:11:18.507]    - args: function (..., envir = parent.frame())
[16:11:18.507]    - tweaked: FALSE
[16:11:18.507]    - call: NULL
[16:11:18.507] plan(): nbrOfWorkers() = 1
[16:11:19.009] plan(): Setting new future strategy stack:
[16:11:19.009] List of future strategies:
[16:11:19.009] 1. multisession:
[16:11:19.009]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:19.009]    - tweaked: FALSE
[16:11:19.009]    - call: plan(strategy)
[16:11:19.014] plan(): nbrOfWorkers() = 1
[16:11:19.014] SequentialFuture started (and completed)
[16:11:19.014] - Launch lazy future ... done
[16:11:19.014] run() for ‘SequentialFuture’ ... done
[16:11:19.014] Created future:
[16:11:19.015] SequentialFuture:
[16:11:19.015] Label: ‘future_lapply-1’
[16:11:19.015] Expression:
[16:11:19.015] {
[16:11:19.015]     do.call(function(...) {
[16:11:19.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:19.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:19.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:19.015]             on.exit(options(oopts), add = TRUE)
[16:11:19.015]         }
[16:11:19.015]         {
[16:11:19.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:19.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:19.015]                 ...future.FUN(...future.X_jj, ...)
[16:11:19.015]             })
[16:11:19.015]         }
[16:11:19.015]     }, args = future.call.arguments)
[16:11:19.015] }
[16:11:19.015] Lazy evaluation: FALSE
[16:11:19.015] Asynchronous evaluation: FALSE
[16:11:19.015] Local evaluation: TRUE
[16:11:19.015] Environment: R_GlobalEnv
[16:11:19.015] Capture standard output: FALSE
[16:11:19.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:19.015] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:19.015] Packages: <none>
[16:11:19.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:19.015] Resolved: TRUE
[16:11:19.015] Value: 112 bytes of class ‘list’
[16:11:19.015] Early signaling: FALSE
[16:11:19.015] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:19.015] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:19.016] Chunk #1 of 1 ... DONE
[16:11:19.016] Launching 1 futures (chunks) ... DONE
[16:11:19.016] Resolving 1 futures (chunks) ...
[16:11:19.016] resolve() on list ...
[16:11:19.016]  recursive: 0
[16:11:19.016]  length: 1
[16:11:19.016] 
[16:11:19.017] resolved() for ‘SequentialFuture’ ...
[16:11:19.017] - state: ‘finished’
[16:11:19.017] - run: TRUE
[16:11:19.017] - result: ‘FutureResult’
[16:11:19.017] resolved() for ‘SequentialFuture’ ... done
[16:11:19.017] Future #1
[16:11:19.017] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:19.017] - nx: 1
[16:11:19.017] - relay: TRUE
[16:11:19.017] - stdout: TRUE
[16:11:19.018] - signal: TRUE
[16:11:19.018] - resignal: FALSE
[16:11:19.018] - force: TRUE
[16:11:19.018] - relayed: [n=1] FALSE
[16:11:19.018] - queued futures: [n=1] FALSE
[16:11:19.018]  - until=1
[16:11:19.018]  - relaying element #1
[16:11:19.018] - relayed: [n=1] TRUE
[16:11:19.018] - queued futures: [n=1] TRUE
[16:11:19.018] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:19.019]  length: 0 (resolved future 1)
[16:11:19.019] Relaying remaining futures
[16:11:19.019] signalConditionsASAP(NULL, pos=0) ...
[16:11:19.019] - nx: 1
[16:11:19.019] - relay: TRUE
[16:11:19.019] - stdout: TRUE
[16:11:19.019] - signal: TRUE
[16:11:19.019] - resignal: FALSE
[16:11:19.019] - force: TRUE
[16:11:19.019] - relayed: [n=1] TRUE
[16:11:19.019] - queued futures: [n=1] TRUE
 - flush all
[16:11:19.020] - relayed: [n=1] TRUE
[16:11:19.020] - queued futures: [n=1] TRUE
[16:11:19.020] signalConditionsASAP(NULL, pos=0) ... done
[16:11:19.020] resolve() on list ... DONE
[16:11:19.020]  - Number of value chunks collected: 1
[16:11:19.020] Resolving 1 futures (chunks) ... DONE
[16:11:19.020] Reducing values from 1 chunks ...
[16:11:19.020]  - Number of values collected after concatenation: 2
[16:11:19.020]  - Number of values expected: 2
[16:11:19.020] Reducing values from 1 chunks ... DONE
[16:11:19.021] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:11:19.021] future_lapply() ...
[16:11:19.026] Number of chunks: 1
[16:11:19.026] getGlobalsAndPackagesXApply() ...
[16:11:19.026]  - future.globals: TRUE
[16:11:19.026] getGlobalsAndPackages() ...
[16:11:19.027] Searching for globals...
[16:11:19.028] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:19.028] Searching for globals ... DONE
[16:11:19.028] Resolving globals: FALSE
[16:11:19.029] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:19.029] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:19.029] - globals: [1] ‘FUN’
[16:11:19.029] 
[16:11:19.029] getGlobalsAndPackages() ... DONE
[16:11:19.029]  - globals found/used: [n=1] ‘FUN’
[16:11:19.030]  - needed namespaces: [n=0] 
[16:11:19.030] Finding globals ... DONE
[16:11:19.030]  - use_args: TRUE
[16:11:19.030]  - Getting '...' globals ...
[16:11:19.030] resolve() on list ...
[16:11:19.030]  recursive: 0
[16:11:19.030]  length: 1
[16:11:19.030]  elements: ‘...’
[16:11:19.031]  length: 0 (resolved future 1)
[16:11:19.031] resolve() on list ... DONE
[16:11:19.031]    - '...' content: [n=0] 
[16:11:19.031] List of 1
[16:11:19.031]  $ ...: list()
[16:11:19.031]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:19.031]  - attr(*, "where")=List of 1
[16:11:19.031]   ..$ ...:<environment: 0x557e211601c8> 
[16:11:19.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:19.031]  - attr(*, "resolved")= logi TRUE
[16:11:19.031]  - attr(*, "total_size")= num NA
[16:11:19.033]  - Getting '...' globals ... DONE
[16:11:19.034] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:19.034] List of 2
[16:11:19.034]  $ ...future.FUN:function (x)  
[16:11:19.034]  $ ...          : list()
[16:11:19.034]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:19.034]  - attr(*, "where")=List of 2
[16:11:19.034]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:19.034]   ..$ ...          :<environment: 0x557e211601c8> 
[16:11:19.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:19.034]  - attr(*, "resolved")= logi FALSE
[16:11:19.034]  - attr(*, "total_size")= num 4720
[16:11:19.036] Packages to be attached in all futures: [n=0] 
[16:11:19.037] getGlobalsAndPackagesXApply() ... DONE
[16:11:19.037] Number of futures (= number of chunks): 1
[16:11:19.037] Launching 1 futures (chunks) ...
[16:11:19.037] Chunk #1 of 1 ...
[16:11:19.037]  - Finding globals in 'X' for chunk #1 ...
[16:11:19.037] getGlobalsAndPackages() ...
[16:11:19.037] Searching for globals...
[16:11:19.037] 
[16:11:19.038] Searching for globals ... DONE
[16:11:19.038] - globals: [0] <none>
[16:11:19.038] getGlobalsAndPackages() ... DONE
[16:11:19.038]    + additional globals found: [n=0] 
[16:11:19.038]    + additional namespaces needed: [n=0] 
[16:11:19.038]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:19.038]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:19.038]  - seeds: <none>
[16:11:19.038] getGlobalsAndPackages() ...
[16:11:19.038] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:19.039] Resolving globals: FALSE
[16:11:19.039] Tweak future expression to call with '...' arguments ...
[16:11:19.039] {
[16:11:19.039]     do.call(function(...) {
[16:11:19.039]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:19.039]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:19.039]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:19.039]             on.exit(options(oopts), add = TRUE)
[16:11:19.039]         }
[16:11:19.039]         {
[16:11:19.039]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:19.039]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:19.039]                 ...future.FUN(...future.X_jj, ...)
[16:11:19.039]             })
[16:11:19.039]         }
[16:11:19.039]     }, args = future.call.arguments)
[16:11:19.039] }
[16:11:19.039] Tweak future expression to call with '...' arguments ... DONE
[16:11:19.039] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:19.039] 
[16:11:19.040] getGlobalsAndPackages() ... DONE
[16:11:19.040] run() for ‘Future’ ...
[16:11:19.040] - state: ‘created’
[16:11:19.040] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:19.043] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:19.043] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:19.044]   - Field: ‘label’
[16:11:19.044]   - Field: ‘local’
[16:11:19.044]   - Field: ‘owner’
[16:11:19.044]   - Field: ‘envir’
[16:11:19.044]   - Field: ‘packages’
[16:11:19.044]   - Field: ‘gc’
[16:11:19.044]   - Field: ‘conditions’
[16:11:19.044]   - Field: ‘expr’
[16:11:19.044]   - Field: ‘uuid’
[16:11:19.044]   - Field: ‘seed’
[16:11:19.045]   - Field: ‘version’
[16:11:19.045]   - Field: ‘result’
[16:11:19.045]   - Field: ‘asynchronous’
[16:11:19.045]   - Field: ‘calls’
[16:11:19.045]   - Field: ‘globals’
[16:11:19.045]   - Field: ‘stdout’
[16:11:19.045]   - Field: ‘earlySignal’
[16:11:19.045]   - Field: ‘lazy’
[16:11:19.045]   - Field: ‘state’
[16:11:19.045] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:19.045] - Launch lazy future ...
[16:11:19.046] Packages needed by the future expression (n = 0): <none>
[16:11:19.046] Packages needed by future strategies (n = 0): <none>
[16:11:19.046] {
[16:11:19.046]     {
[16:11:19.046]         {
[16:11:19.046]             ...future.startTime <- base::Sys.time()
[16:11:19.046]             {
[16:11:19.046]                 {
[16:11:19.046]                   {
[16:11:19.046]                     base::local({
[16:11:19.046]                       has_future <- base::requireNamespace("future", 
[16:11:19.046]                         quietly = TRUE)
[16:11:19.046]                       if (has_future) {
[16:11:19.046]                         ns <- base::getNamespace("future")
[16:11:19.046]                         version <- ns[[".package"]][["version"]]
[16:11:19.046]                         if (is.null(version)) 
[16:11:19.046]                           version <- utils::packageVersion("future")
[16:11:19.046]                       }
[16:11:19.046]                       else {
[16:11:19.046]                         version <- NULL
[16:11:19.046]                       }
[16:11:19.046]                       if (!has_future || version < "1.8.0") {
[16:11:19.046]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:19.046]                           "", base::R.version$version.string), 
[16:11:19.046]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:19.046]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:19.046]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:19.046]                             "release", "version")], collapse = " "), 
[16:11:19.046]                           hostname = base::Sys.info()[["nodename"]])
[16:11:19.046]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:19.046]                           info)
[16:11:19.046]                         info <- base::paste(info, collapse = "; ")
[16:11:19.046]                         if (!has_future) {
[16:11:19.046]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:19.046]                             info)
[16:11:19.046]                         }
[16:11:19.046]                         else {
[16:11:19.046]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:19.046]                             info, version)
[16:11:19.046]                         }
[16:11:19.046]                         base::stop(msg)
[16:11:19.046]                       }
[16:11:19.046]                     })
[16:11:19.046]                   }
[16:11:19.046]                   options(future.plan = NULL)
[16:11:19.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:19.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:19.046]                 }
[16:11:19.046]                 ...future.workdir <- getwd()
[16:11:19.046]             }
[16:11:19.046]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:19.046]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:19.046]         }
[16:11:19.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:19.046]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:19.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:19.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:19.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:19.046]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:19.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:19.046]             base::names(...future.oldOptions))
[16:11:19.046]     }
[16:11:19.046]     if (FALSE) {
[16:11:19.046]     }
[16:11:19.046]     else {
[16:11:19.046]         if (TRUE) {
[16:11:19.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:19.046]                 open = "w")
[16:11:19.046]         }
[16:11:19.046]         else {
[16:11:19.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:19.046]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:19.046]         }
[16:11:19.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:19.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:19.046]             base::sink(type = "output", split = FALSE)
[16:11:19.046]             base::close(...future.stdout)
[16:11:19.046]         }, add = TRUE)
[16:11:19.046]     }
[16:11:19.046]     ...future.frame <- base::sys.nframe()
[16:11:19.046]     ...future.conditions <- base::list()
[16:11:19.046]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:19.046]     if (FALSE) {
[16:11:19.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:19.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:19.046]     }
[16:11:19.046]     ...future.result <- base::tryCatch({
[16:11:19.046]         base::withCallingHandlers({
[16:11:19.046]             ...future.value <- base::withVisible(base::local({
[16:11:19.046]                 do.call(function(...) {
[16:11:19.046]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:19.046]                   if (!identical(...future.globals.maxSize.org, 
[16:11:19.046]                     ...future.globals.maxSize)) {
[16:11:19.046]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:19.046]                     on.exit(options(oopts), add = TRUE)
[16:11:19.046]                   }
[16:11:19.046]                   {
[16:11:19.046]                     lapply(seq_along(...future.elements_ii), 
[16:11:19.046]                       FUN = function(jj) {
[16:11:19.046]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:19.046]                         ...future.FUN(...future.X_jj, ...)
[16:11:19.046]                       })
[16:11:19.046]                   }
[16:11:19.046]                 }, args = future.call.arguments)
[16:11:19.046]             }))
[16:11:19.046]             future::FutureResult(value = ...future.value$value, 
[16:11:19.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:19.046]                   ...future.rng), globalenv = if (FALSE) 
[16:11:19.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:19.046]                     ...future.globalenv.names))
[16:11:19.046]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:19.046]         }, condition = base::local({
[16:11:19.046]             c <- base::c
[16:11:19.046]             inherits <- base::inherits
[16:11:19.046]             invokeRestart <- base::invokeRestart
[16:11:19.046]             length <- base::length
[16:11:19.046]             list <- base::list
[16:11:19.046]             seq.int <- base::seq.int
[16:11:19.046]             signalCondition <- base::signalCondition
[16:11:19.046]             sys.calls <- base::sys.calls
[16:11:19.046]             `[[` <- base::`[[`
[16:11:19.046]             `+` <- base::`+`
[16:11:19.046]             `<<-` <- base::`<<-`
[16:11:19.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:19.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:19.046]                   3L)]
[16:11:19.046]             }
[16:11:19.046]             function(cond) {
[16:11:19.046]                 is_error <- inherits(cond, "error")
[16:11:19.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:19.046]                   NULL)
[16:11:19.046]                 if (is_error) {
[16:11:19.046]                   sessionInformation <- function() {
[16:11:19.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:19.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:19.046]                       search = base::search(), system = base::Sys.info())
[16:11:19.046]                   }
[16:11:19.046]                   ...future.conditions[[length(...future.conditions) + 
[16:11:19.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:19.046]                     cond$call), session = sessionInformation(), 
[16:11:19.046]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:19.046]                   signalCondition(cond)
[16:11:19.046]                 }
[16:11:19.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:19.046]                 "immediateCondition"))) {
[16:11:19.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:19.046]                   ...future.conditions[[length(...future.conditions) + 
[16:11:19.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:19.046]                   if (TRUE && !signal) {
[16:11:19.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:19.046]                     {
[16:11:19.046]                       inherits <- base::inherits
[16:11:19.046]                       invokeRestart <- base::invokeRestart
[16:11:19.046]                       is.null <- base::is.null
[16:11:19.046]                       muffled <- FALSE
[16:11:19.046]                       if (inherits(cond, "message")) {
[16:11:19.046]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:19.046]                         if (muffled) 
[16:11:19.046]                           invokeRestart("muffleMessage")
[16:11:19.046]                       }
[16:11:19.046]                       else if (inherits(cond, "warning")) {
[16:11:19.046]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:19.046]                         if (muffled) 
[16:11:19.046]                           invokeRestart("muffleWarning")
[16:11:19.046]                       }
[16:11:19.046]                       else if (inherits(cond, "condition")) {
[16:11:19.046]                         if (!is.null(pattern)) {
[16:11:19.046]                           computeRestarts <- base::computeRestarts
[16:11:19.046]                           grepl <- base::grepl
[16:11:19.046]                           restarts <- computeRestarts(cond)
[16:11:19.046]                           for (restart in restarts) {
[16:11:19.046]                             name <- restart$name
[16:11:19.046]                             if (is.null(name)) 
[16:11:19.046]                               next
[16:11:19.046]                             if (!grepl(pattern, name)) 
[16:11:19.046]                               next
[16:11:19.046]                             invokeRestart(restart)
[16:11:19.046]                             muffled <- TRUE
[16:11:19.046]                             break
[16:11:19.046]                           }
[16:11:19.046]                         }
[16:11:19.046]                       }
[16:11:19.046]                       invisible(muffled)
[16:11:19.046]                     }
[16:11:19.046]                     muffleCondition(cond, pattern = "^muffle")
[16:11:19.046]                   }
[16:11:19.046]                 }
[16:11:19.046]                 else {
[16:11:19.046]                   if (TRUE) {
[16:11:19.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:19.046]                     {
[16:11:19.046]                       inherits <- base::inherits
[16:11:19.046]                       invokeRestart <- base::invokeRestart
[16:11:19.046]                       is.null <- base::is.null
[16:11:19.046]                       muffled <- FALSE
[16:11:19.046]                       if (inherits(cond, "message")) {
[16:11:19.046]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:19.046]                         if (muffled) 
[16:11:19.046]                           invokeRestart("muffleMessage")
[16:11:19.046]                       }
[16:11:19.046]                       else if (inherits(cond, "warning")) {
[16:11:19.046]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:19.046]                         if (muffled) 
[16:11:19.046]                           invokeRestart("muffleWarning")
[16:11:19.046]                       }
[16:11:19.046]                       else if (inherits(cond, "condition")) {
[16:11:19.046]                         if (!is.null(pattern)) {
[16:11:19.046]                           computeRestarts <- base::computeRestarts
[16:11:19.046]                           grepl <- base::grepl
[16:11:19.046]                           restarts <- computeRestarts(cond)
[16:11:19.046]                           for (restart in restarts) {
[16:11:19.046]                             name <- restart$name
[16:11:19.046]                             if (is.null(name)) 
[16:11:19.046]                               next
[16:11:19.046]                             if (!grepl(pattern, name)) 
[16:11:19.046]                               next
[16:11:19.046]                             invokeRestart(restart)
[16:11:19.046]                             muffled <- TRUE
[16:11:19.046]                             break
[16:11:19.046]                           }
[16:11:19.046]                         }
[16:11:19.046]                       }
[16:11:19.046]                       invisible(muffled)
[16:11:19.046]                     }
[16:11:19.046]                     muffleCondition(cond, pattern = "^muffle")
[16:11:19.046]                   }
[16:11:19.046]                 }
[16:11:19.046]             }
[16:11:19.046]         }))
[16:11:19.046]     }, error = function(ex) {
[16:11:19.046]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:19.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:19.046]                 ...future.rng), started = ...future.startTime, 
[16:11:19.046]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:19.046]             version = "1.8"), class = "FutureResult")
[16:11:19.046]     }, finally = {
[16:11:19.046]         if (!identical(...future.workdir, getwd())) 
[16:11:19.046]             setwd(...future.workdir)
[16:11:19.046]         {
[16:11:19.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:19.046]                 ...future.oldOptions$nwarnings <- NULL
[16:11:19.046]             }
[16:11:19.046]             base::options(...future.oldOptions)
[16:11:19.046]             if (.Platform$OS.type == "windows") {
[16:11:19.046]                 old_names <- names(...future.oldEnvVars)
[16:11:19.046]                 envs <- base::Sys.getenv()
[16:11:19.046]                 names <- names(envs)
[16:11:19.046]                 common <- intersect(names, old_names)
[16:11:19.046]                 added <- setdiff(names, old_names)
[16:11:19.046]                 removed <- setdiff(old_names, names)
[16:11:19.046]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:19.046]                   envs[common]]
[16:11:19.046]                 NAMES <- toupper(changed)
[16:11:19.046]                 args <- list()
[16:11:19.046]                 for (kk in seq_along(NAMES)) {
[16:11:19.046]                   name <- changed[[kk]]
[16:11:19.046]                   NAME <- NAMES[[kk]]
[16:11:19.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:19.046]                     next
[16:11:19.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:19.046]                 }
[16:11:19.046]                 NAMES <- toupper(added)
[16:11:19.046]                 for (kk in seq_along(NAMES)) {
[16:11:19.046]                   name <- added[[kk]]
[16:11:19.046]                   NAME <- NAMES[[kk]]
[16:11:19.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:19.046]                     next
[16:11:19.046]                   args[[name]] <- ""
[16:11:19.046]                 }
[16:11:19.046]                 NAMES <- toupper(removed)
[16:11:19.046]                 for (kk in seq_along(NAMES)) {
[16:11:19.046]                   name <- removed[[kk]]
[16:11:19.046]                   NAME <- NAMES[[kk]]
[16:11:19.046]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:19.046]                     next
[16:11:19.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:19.046]                 }
[16:11:19.046]                 if (length(args) > 0) 
[16:11:19.046]                   base::do.call(base::Sys.setenv, args = args)
[16:11:19.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:19.046]             }
[16:11:19.046]             else {
[16:11:19.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:19.046]             }
[16:11:19.046]             {
[16:11:19.046]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:19.046]                   0L) {
[16:11:19.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:19.046]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:19.046]                   base::options(opts)
[16:11:19.046]                 }
[16:11:19.046]                 {
[16:11:19.046]                   {
[16:11:19.046]                     NULL
[16:11:19.046]                     RNGkind("Mersenne-Twister")
[16:11:19.046]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:19.046]                       inherits = FALSE)
[16:11:19.046]                   }
[16:11:19.046]                   options(future.plan = NULL)
[16:11:19.046]                   if (is.na(NA_character_)) 
[16:11:19.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:19.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:19.046]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:19.046]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:19.046]                     envir = parent.frame()) 
[16:11:19.046]                   {
[16:11:19.046]                     if (is.function(workers)) 
[16:11:19.046]                       workers <- workers()
[16:11:19.046]                     workers <- structure(as.integer(workers), 
[16:11:19.046]                       class = class(workers))
[16:11:19.046]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:19.046]                       workers >= 1)
[16:11:19.046]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:19.046]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:19.046]                     }
[16:11:19.046]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:19.046]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:19.046]                       envir = envir)
[16:11:19.046]                     if (!future$lazy) 
[16:11:19.046]                       future <- run(future)
[16:11:19.046]                     invisible(future)
[16:11:19.046]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:19.046]                 }
[16:11:19.046]             }
[16:11:19.046]         }
[16:11:19.046]     })
[16:11:19.046]     if (TRUE) {
[16:11:19.046]         base::sink(type = "output", split = FALSE)
[16:11:19.046]         if (TRUE) {
[16:11:19.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:19.046]         }
[16:11:19.046]         else {
[16:11:19.046]             ...future.result["stdout"] <- base::list(NULL)
[16:11:19.046]         }
[16:11:19.046]         base::close(...future.stdout)
[16:11:19.046]         ...future.stdout <- NULL
[16:11:19.046]     }
[16:11:19.046]     ...future.result$conditions <- ...future.conditions
[16:11:19.046]     ...future.result$finished <- base::Sys.time()
[16:11:19.046]     ...future.result
[16:11:19.046] }
[16:11:19.048] assign_globals() ...
[16:11:19.048] List of 5
[16:11:19.048]  $ ...future.FUN            :function (x)  
[16:11:19.048]  $ future.call.arguments    : list()
[16:11:19.048]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:19.048]  $ ...future.elements_ii    :List of 2
[16:11:19.048]   ..$ : int 1
[16:11:19.048]   ..$ : int 0
[16:11:19.048]  $ ...future.seeds_ii       : NULL
[16:11:19.048]  $ ...future.globals.maxSize: NULL
[16:11:19.048]  - attr(*, "resolved")= logi FALSE
[16:11:19.048]  - attr(*, "total_size")= num 4720
[16:11:19.048]  - attr(*, "where")=List of 5
[16:11:19.048]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:19.048]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:19.048]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:19.048]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:19.048]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:19.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:19.048]  - attr(*, "already-done")= logi TRUE
[16:11:19.053] - reassign environment for ‘...future.FUN’
[16:11:19.054] - copied ‘...future.FUN’ to environment
[16:11:19.054] - copied ‘future.call.arguments’ to environment
[16:11:19.054] - copied ‘...future.elements_ii’ to environment
[16:11:19.054] - copied ‘...future.seeds_ii’ to environment
[16:11:19.054] - copied ‘...future.globals.maxSize’ to environment
[16:11:19.054] assign_globals() ... done
[16:11:19.055] plan(): Setting new future strategy stack:
[16:11:19.055] List of future strategies:
[16:11:19.055] 1. sequential:
[16:11:19.055]    - args: function (..., envir = parent.frame())
[16:11:19.055]    - tweaked: FALSE
[16:11:19.055]    - call: NULL
[16:11:19.055] plan(): nbrOfWorkers() = 1
[16:11:19.557] plan(): Setting new future strategy stack:
[16:11:19.557] List of future strategies:
[16:11:19.557] 1. multisession:
[16:11:19.557]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:19.557]    - tweaked: FALSE
[16:11:19.557]    - call: plan(strategy)
[16:11:19.561] plan(): nbrOfWorkers() = 1
[16:11:19.561] SequentialFuture started (and completed)
[16:11:19.561] - Launch lazy future ... done
[16:11:19.561] run() for ‘SequentialFuture’ ... done
[16:11:19.561] Created future:
[16:11:19.562] SequentialFuture:
[16:11:19.562] Label: ‘future_lapply-1’
[16:11:19.562] Expression:
[16:11:19.562] {
[16:11:19.562]     do.call(function(...) {
[16:11:19.562]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:19.562]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:19.562]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:19.562]             on.exit(options(oopts), add = TRUE)
[16:11:19.562]         }
[16:11:19.562]         {
[16:11:19.562]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:19.562]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:19.562]                 ...future.FUN(...future.X_jj, ...)
[16:11:19.562]             })
[16:11:19.562]         }
[16:11:19.562]     }, args = future.call.arguments)
[16:11:19.562] }
[16:11:19.562] Lazy evaluation: FALSE
[16:11:19.562] Asynchronous evaluation: FALSE
[16:11:19.562] Local evaluation: TRUE
[16:11:19.562] Environment: R_GlobalEnv
[16:11:19.562] Capture standard output: TRUE
[16:11:19.562] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:19.562] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:19.562] Packages: <none>
[16:11:19.562] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:19.562] Resolved: TRUE
[16:11:19.562] Value: 112 bytes of class ‘list’
[16:11:19.562] Early signaling: FALSE
[16:11:19.562] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:19.562] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:19.563] Chunk #1 of 1 ... DONE
[16:11:19.563] Launching 1 futures (chunks) ... DONE
[16:11:19.563] Resolving 1 futures (chunks) ...
[16:11:19.563] resolve() on list ...
[16:11:19.563]  recursive: 0
[16:11:19.563]  length: 1
[16:11:19.563] 
[16:11:19.563] resolved() for ‘SequentialFuture’ ...
[16:11:19.564] - state: ‘finished’
[16:11:19.564] - run: TRUE
[16:11:19.564] - result: ‘FutureResult’
[16:11:19.564] resolved() for ‘SequentialFuture’ ... done
[16:11:19.564] Future #1
[16:11:19.564] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:19.564] - nx: 1
[16:11:19.564] - relay: TRUE
[16:11:19.564] - stdout: TRUE
[16:11:19.565] - signal: TRUE
[16:11:19.565] - resignal: FALSE
[16:11:19.565] - force: TRUE
[16:11:19.565] - relayed: [n=1] FALSE
[16:11:19.565] - queued futures: [n=1] FALSE
[16:11:19.565]  - until=1
[16:11:19.565]  - relaying element #1
[16:11:19.565] - relayed: [n=1] TRUE
[16:11:19.565] - queued futures: [n=1] TRUE
[16:11:19.566] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:19.566]  length: 0 (resolved future 1)
[16:11:19.566] Relaying remaining futures
[16:11:19.566] signalConditionsASAP(NULL, pos=0) ...
[16:11:19.566] - nx: 1
[16:11:19.566] - relay: TRUE
[16:11:19.566] - stdout: TRUE
[16:11:19.566] - signal: TRUE
[16:11:19.566] - resignal: FALSE
[16:11:19.566] - force: TRUE
[16:11:19.566] - relayed: [n=1] TRUE
[16:11:19.567] - queued futures: [n=1] TRUE
 - flush all
[16:11:19.567] - relayed: [n=1] TRUE
[16:11:19.567] - queued futures: [n=1] TRUE
[16:11:19.567] signalConditionsASAP(NULL, pos=0) ... done
[16:11:19.567] resolve() on list ... DONE
[16:11:19.567]  - Number of value chunks collected: 1
[16:11:19.567] Resolving 1 futures (chunks) ... DONE
[16:11:19.567] Reducing values from 1 chunks ...
[16:11:19.567]  - Number of values collected after concatenation: 2
[16:11:19.567]  - Number of values expected: 2
[16:11:19.568] Reducing values from 1 chunks ... DONE
[16:11:19.568] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:11:19.568] future_lapply() ...
[16:11:19.572] Number of chunks: 1
[16:11:19.572] getGlobalsAndPackagesXApply() ...
[16:11:19.572]  - future.globals: TRUE
[16:11:19.572] getGlobalsAndPackages() ...
[16:11:19.572] Searching for globals...
[16:11:19.573] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:19.574] Searching for globals ... DONE
[16:11:19.574] Resolving globals: FALSE
[16:11:19.574] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:19.574] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:19.575] - globals: [1] ‘FUN’
[16:11:19.575] 
[16:11:19.575] getGlobalsAndPackages() ... DONE
[16:11:19.575]  - globals found/used: [n=1] ‘FUN’
[16:11:19.575]  - needed namespaces: [n=0] 
[16:11:19.575] Finding globals ... DONE
[16:11:19.575]  - use_args: TRUE
[16:11:19.575]  - Getting '...' globals ...
[16:11:19.575] resolve() on list ...
[16:11:19.576]  recursive: 0
[16:11:19.576]  length: 1
[16:11:19.576]  elements: ‘...’
[16:11:19.576]  length: 0 (resolved future 1)
[16:11:19.576] resolve() on list ... DONE
[16:11:19.576]    - '...' content: [n=0] 
[16:11:19.576] List of 1
[16:11:19.576]  $ ...: list()
[16:11:19.576]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:19.576]  - attr(*, "where")=List of 1
[16:11:19.576]   ..$ ...:<environment: 0x557e20722c80> 
[16:11:19.576]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:19.576]  - attr(*, "resolved")= logi TRUE
[16:11:19.576]  - attr(*, "total_size")= num NA
[16:11:19.579]  - Getting '...' globals ... DONE
[16:11:19.579] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:19.579] List of 2
[16:11:19.579]  $ ...future.FUN:function (x)  
[16:11:19.579]  $ ...          : list()
[16:11:19.579]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:19.579]  - attr(*, "where")=List of 2
[16:11:19.579]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:19.579]   ..$ ...          :<environment: 0x557e20722c80> 
[16:11:19.579]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:19.579]  - attr(*, "resolved")= logi FALSE
[16:11:19.579]  - attr(*, "total_size")= num 4720
[16:11:19.582] Packages to be attached in all futures: [n=0] 
[16:11:19.582] getGlobalsAndPackagesXApply() ... DONE
[16:11:19.582] Number of futures (= number of chunks): 1
[16:11:19.582] Launching 1 futures (chunks) ...
[16:11:19.582] Chunk #1 of 1 ...
[16:11:19.582]  - Finding globals in 'X' for chunk #1 ...
[16:11:19.582] getGlobalsAndPackages() ...
[16:11:19.583] Searching for globals...
[16:11:19.583] 
[16:11:19.583] Searching for globals ... DONE
[16:11:19.583] - globals: [0] <none>
[16:11:19.583] getGlobalsAndPackages() ... DONE
[16:11:19.583]    + additional globals found: [n=0] 
[16:11:19.583]    + additional namespaces needed: [n=0] 
[16:11:19.583]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:19.583]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:19.584]  - seeds: <none>
[16:11:19.584] getGlobalsAndPackages() ...
[16:11:19.584] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:19.584] Resolving globals: FALSE
[16:11:19.586] Tweak future expression to call with '...' arguments ...
[16:11:19.586] {
[16:11:19.586]     do.call(function(...) {
[16:11:19.586]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:19.586]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:19.586]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:19.586]             on.exit(options(oopts), add = TRUE)
[16:11:19.586]         }
[16:11:19.586]         {
[16:11:19.586]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:19.586]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:19.586]                 ...future.FUN(...future.X_jj, ...)
[16:11:19.586]             })
[16:11:19.586]         }
[16:11:19.586]     }, args = future.call.arguments)
[16:11:19.586] }
[16:11:19.586] Tweak future expression to call with '...' arguments ... DONE
[16:11:19.586] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:19.587] 
[16:11:19.587] getGlobalsAndPackages() ... DONE
[16:11:19.587] run() for ‘Future’ ...
[16:11:19.587] - state: ‘created’
[16:11:19.587] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:19.591] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:19.591] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:19.591]   - Field: ‘label’
[16:11:19.591]   - Field: ‘local’
[16:11:19.591]   - Field: ‘owner’
[16:11:19.591]   - Field: ‘envir’
[16:11:19.591]   - Field: ‘packages’
[16:11:19.592]   - Field: ‘gc’
[16:11:19.592]   - Field: ‘conditions’
[16:11:19.592]   - Field: ‘expr’
[16:11:19.592]   - Field: ‘uuid’
[16:11:19.592]   - Field: ‘seed’
[16:11:19.592]   - Field: ‘version’
[16:11:19.592]   - Field: ‘result’
[16:11:19.592]   - Field: ‘asynchronous’
[16:11:19.592]   - Field: ‘calls’
[16:11:19.592]   - Field: ‘globals’
[16:11:19.593]   - Field: ‘stdout’
[16:11:19.593]   - Field: ‘earlySignal’
[16:11:19.593]   - Field: ‘lazy’
[16:11:19.593]   - Field: ‘state’
[16:11:19.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:19.593] - Launch lazy future ...
[16:11:19.593] Packages needed by the future expression (n = 0): <none>
[16:11:19.593] Packages needed by future strategies (n = 0): <none>
[16:11:19.594] {
[16:11:19.594]     {
[16:11:19.594]         {
[16:11:19.594]             ...future.startTime <- base::Sys.time()
[16:11:19.594]             {
[16:11:19.594]                 {
[16:11:19.594]                   {
[16:11:19.594]                     base::local({
[16:11:19.594]                       has_future <- base::requireNamespace("future", 
[16:11:19.594]                         quietly = TRUE)
[16:11:19.594]                       if (has_future) {
[16:11:19.594]                         ns <- base::getNamespace("future")
[16:11:19.594]                         version <- ns[[".package"]][["version"]]
[16:11:19.594]                         if (is.null(version)) 
[16:11:19.594]                           version <- utils::packageVersion("future")
[16:11:19.594]                       }
[16:11:19.594]                       else {
[16:11:19.594]                         version <- NULL
[16:11:19.594]                       }
[16:11:19.594]                       if (!has_future || version < "1.8.0") {
[16:11:19.594]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:19.594]                           "", base::R.version$version.string), 
[16:11:19.594]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:19.594]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:19.594]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:19.594]                             "release", "version")], collapse = " "), 
[16:11:19.594]                           hostname = base::Sys.info()[["nodename"]])
[16:11:19.594]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:19.594]                           info)
[16:11:19.594]                         info <- base::paste(info, collapse = "; ")
[16:11:19.594]                         if (!has_future) {
[16:11:19.594]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:19.594]                             info)
[16:11:19.594]                         }
[16:11:19.594]                         else {
[16:11:19.594]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:19.594]                             info, version)
[16:11:19.594]                         }
[16:11:19.594]                         base::stop(msg)
[16:11:19.594]                       }
[16:11:19.594]                     })
[16:11:19.594]                   }
[16:11:19.594]                   options(future.plan = NULL)
[16:11:19.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:19.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:19.594]                 }
[16:11:19.594]                 ...future.workdir <- getwd()
[16:11:19.594]             }
[16:11:19.594]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:19.594]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:19.594]         }
[16:11:19.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:19.594]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:19.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:19.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:19.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:19.594]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:19.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:19.594]             base::names(...future.oldOptions))
[16:11:19.594]     }
[16:11:19.594]     if (TRUE) {
[16:11:19.594]     }
[16:11:19.594]     else {
[16:11:19.594]         if (NA) {
[16:11:19.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:19.594]                 open = "w")
[16:11:19.594]         }
[16:11:19.594]         else {
[16:11:19.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:19.594]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:19.594]         }
[16:11:19.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:19.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:19.594]             base::sink(type = "output", split = FALSE)
[16:11:19.594]             base::close(...future.stdout)
[16:11:19.594]         }, add = TRUE)
[16:11:19.594]     }
[16:11:19.594]     ...future.frame <- base::sys.nframe()
[16:11:19.594]     ...future.conditions <- base::list()
[16:11:19.594]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:19.594]     if (FALSE) {
[16:11:19.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:19.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:19.594]     }
[16:11:19.594]     ...future.result <- base::tryCatch({
[16:11:19.594]         base::withCallingHandlers({
[16:11:19.594]             ...future.value <- base::withVisible(base::local({
[16:11:19.594]                 do.call(function(...) {
[16:11:19.594]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:19.594]                   if (!identical(...future.globals.maxSize.org, 
[16:11:19.594]                     ...future.globals.maxSize)) {
[16:11:19.594]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:19.594]                     on.exit(options(oopts), add = TRUE)
[16:11:19.594]                   }
[16:11:19.594]                   {
[16:11:19.594]                     lapply(seq_along(...future.elements_ii), 
[16:11:19.594]                       FUN = function(jj) {
[16:11:19.594]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:19.594]                         ...future.FUN(...future.X_jj, ...)
[16:11:19.594]                       })
[16:11:19.594]                   }
[16:11:19.594]                 }, args = future.call.arguments)
[16:11:19.594]             }))
[16:11:19.594]             future::FutureResult(value = ...future.value$value, 
[16:11:19.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:19.594]                   ...future.rng), globalenv = if (FALSE) 
[16:11:19.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:19.594]                     ...future.globalenv.names))
[16:11:19.594]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:19.594]         }, condition = base::local({
[16:11:19.594]             c <- base::c
[16:11:19.594]             inherits <- base::inherits
[16:11:19.594]             invokeRestart <- base::invokeRestart
[16:11:19.594]             length <- base::length
[16:11:19.594]             list <- base::list
[16:11:19.594]             seq.int <- base::seq.int
[16:11:19.594]             signalCondition <- base::signalCondition
[16:11:19.594]             sys.calls <- base::sys.calls
[16:11:19.594]             `[[` <- base::`[[`
[16:11:19.594]             `+` <- base::`+`
[16:11:19.594]             `<<-` <- base::`<<-`
[16:11:19.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:19.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:19.594]                   3L)]
[16:11:19.594]             }
[16:11:19.594]             function(cond) {
[16:11:19.594]                 is_error <- inherits(cond, "error")
[16:11:19.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:19.594]                   NULL)
[16:11:19.594]                 if (is_error) {
[16:11:19.594]                   sessionInformation <- function() {
[16:11:19.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:19.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:19.594]                       search = base::search(), system = base::Sys.info())
[16:11:19.594]                   }
[16:11:19.594]                   ...future.conditions[[length(...future.conditions) + 
[16:11:19.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:19.594]                     cond$call), session = sessionInformation(), 
[16:11:19.594]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:19.594]                   signalCondition(cond)
[16:11:19.594]                 }
[16:11:19.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:19.594]                 "immediateCondition"))) {
[16:11:19.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:19.594]                   ...future.conditions[[length(...future.conditions) + 
[16:11:19.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:19.594]                   if (TRUE && !signal) {
[16:11:19.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:19.594]                     {
[16:11:19.594]                       inherits <- base::inherits
[16:11:19.594]                       invokeRestart <- base::invokeRestart
[16:11:19.594]                       is.null <- base::is.null
[16:11:19.594]                       muffled <- FALSE
[16:11:19.594]                       if (inherits(cond, "message")) {
[16:11:19.594]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:19.594]                         if (muffled) 
[16:11:19.594]                           invokeRestart("muffleMessage")
[16:11:19.594]                       }
[16:11:19.594]                       else if (inherits(cond, "warning")) {
[16:11:19.594]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:19.594]                         if (muffled) 
[16:11:19.594]                           invokeRestart("muffleWarning")
[16:11:19.594]                       }
[16:11:19.594]                       else if (inherits(cond, "condition")) {
[16:11:19.594]                         if (!is.null(pattern)) {
[16:11:19.594]                           computeRestarts <- base::computeRestarts
[16:11:19.594]                           grepl <- base::grepl
[16:11:19.594]                           restarts <- computeRestarts(cond)
[16:11:19.594]                           for (restart in restarts) {
[16:11:19.594]                             name <- restart$name
[16:11:19.594]                             if (is.null(name)) 
[16:11:19.594]                               next
[16:11:19.594]                             if (!grepl(pattern, name)) 
[16:11:19.594]                               next
[16:11:19.594]                             invokeRestart(restart)
[16:11:19.594]                             muffled <- TRUE
[16:11:19.594]                             break
[16:11:19.594]                           }
[16:11:19.594]                         }
[16:11:19.594]                       }
[16:11:19.594]                       invisible(muffled)
[16:11:19.594]                     }
[16:11:19.594]                     muffleCondition(cond, pattern = "^muffle")
[16:11:19.594]                   }
[16:11:19.594]                 }
[16:11:19.594]                 else {
[16:11:19.594]                   if (TRUE) {
[16:11:19.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:19.594]                     {
[16:11:19.594]                       inherits <- base::inherits
[16:11:19.594]                       invokeRestart <- base::invokeRestart
[16:11:19.594]                       is.null <- base::is.null
[16:11:19.594]                       muffled <- FALSE
[16:11:19.594]                       if (inherits(cond, "message")) {
[16:11:19.594]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:19.594]                         if (muffled) 
[16:11:19.594]                           invokeRestart("muffleMessage")
[16:11:19.594]                       }
[16:11:19.594]                       else if (inherits(cond, "warning")) {
[16:11:19.594]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:19.594]                         if (muffled) 
[16:11:19.594]                           invokeRestart("muffleWarning")
[16:11:19.594]                       }
[16:11:19.594]                       else if (inherits(cond, "condition")) {
[16:11:19.594]                         if (!is.null(pattern)) {
[16:11:19.594]                           computeRestarts <- base::computeRestarts
[16:11:19.594]                           grepl <- base::grepl
[16:11:19.594]                           restarts <- computeRestarts(cond)
[16:11:19.594]                           for (restart in restarts) {
[16:11:19.594]                             name <- restart$name
[16:11:19.594]                             if (is.null(name)) 
[16:11:19.594]                               next
[16:11:19.594]                             if (!grepl(pattern, name)) 
[16:11:19.594]                               next
[16:11:19.594]                             invokeRestart(restart)
[16:11:19.594]                             muffled <- TRUE
[16:11:19.594]                             break
[16:11:19.594]                           }
[16:11:19.594]                         }
[16:11:19.594]                       }
[16:11:19.594]                       invisible(muffled)
[16:11:19.594]                     }
[16:11:19.594]                     muffleCondition(cond, pattern = "^muffle")
[16:11:19.594]                   }
[16:11:19.594]                 }
[16:11:19.594]             }
[16:11:19.594]         }))
[16:11:19.594]     }, error = function(ex) {
[16:11:19.594]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:19.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:19.594]                 ...future.rng), started = ...future.startTime, 
[16:11:19.594]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:19.594]             version = "1.8"), class = "FutureResult")
[16:11:19.594]     }, finally = {
[16:11:19.594]         if (!identical(...future.workdir, getwd())) 
[16:11:19.594]             setwd(...future.workdir)
[16:11:19.594]         {
[16:11:19.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:19.594]                 ...future.oldOptions$nwarnings <- NULL
[16:11:19.594]             }
[16:11:19.594]             base::options(...future.oldOptions)
[16:11:19.594]             if (.Platform$OS.type == "windows") {
[16:11:19.594]                 old_names <- names(...future.oldEnvVars)
[16:11:19.594]                 envs <- base::Sys.getenv()
[16:11:19.594]                 names <- names(envs)
[16:11:19.594]                 common <- intersect(names, old_names)
[16:11:19.594]                 added <- setdiff(names, old_names)
[16:11:19.594]                 removed <- setdiff(old_names, names)
[16:11:19.594]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:19.594]                   envs[common]]
[16:11:19.594]                 NAMES <- toupper(changed)
[16:11:19.594]                 args <- list()
[16:11:19.594]                 for (kk in seq_along(NAMES)) {
[16:11:19.594]                   name <- changed[[kk]]
[16:11:19.594]                   NAME <- NAMES[[kk]]
[16:11:19.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:19.594]                     next
[16:11:19.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:19.594]                 }
[16:11:19.594]                 NAMES <- toupper(added)
[16:11:19.594]                 for (kk in seq_along(NAMES)) {
[16:11:19.594]                   name <- added[[kk]]
[16:11:19.594]                   NAME <- NAMES[[kk]]
[16:11:19.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:19.594]                     next
[16:11:19.594]                   args[[name]] <- ""
[16:11:19.594]                 }
[16:11:19.594]                 NAMES <- toupper(removed)
[16:11:19.594]                 for (kk in seq_along(NAMES)) {
[16:11:19.594]                   name <- removed[[kk]]
[16:11:19.594]                   NAME <- NAMES[[kk]]
[16:11:19.594]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:19.594]                     next
[16:11:19.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:19.594]                 }
[16:11:19.594]                 if (length(args) > 0) 
[16:11:19.594]                   base::do.call(base::Sys.setenv, args = args)
[16:11:19.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:19.594]             }
[16:11:19.594]             else {
[16:11:19.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:19.594]             }
[16:11:19.594]             {
[16:11:19.594]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:19.594]                   0L) {
[16:11:19.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:19.594]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:19.594]                   base::options(opts)
[16:11:19.594]                 }
[16:11:19.594]                 {
[16:11:19.594]                   {
[16:11:19.594]                     NULL
[16:11:19.594]                     RNGkind("Mersenne-Twister")
[16:11:19.594]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:19.594]                       inherits = FALSE)
[16:11:19.594]                   }
[16:11:19.594]                   options(future.plan = NULL)
[16:11:19.594]                   if (is.na(NA_character_)) 
[16:11:19.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:19.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:19.594]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:19.594]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:19.594]                     envir = parent.frame()) 
[16:11:19.594]                   {
[16:11:19.594]                     if (is.function(workers)) 
[16:11:19.594]                       workers <- workers()
[16:11:19.594]                     workers <- structure(as.integer(workers), 
[16:11:19.594]                       class = class(workers))
[16:11:19.594]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:19.594]                       workers >= 1)
[16:11:19.594]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:19.594]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:19.594]                     }
[16:11:19.594]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:19.594]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:19.594]                       envir = envir)
[16:11:19.594]                     if (!future$lazy) 
[16:11:19.594]                       future <- run(future)
[16:11:19.594]                     invisible(future)
[16:11:19.594]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:19.594]                 }
[16:11:19.594]             }
[16:11:19.594]         }
[16:11:19.594]     })
[16:11:19.594]     if (FALSE) {
[16:11:19.594]         base::sink(type = "output", split = FALSE)
[16:11:19.594]         if (NA) {
[16:11:19.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:19.594]         }
[16:11:19.594]         else {
[16:11:19.594]             ...future.result["stdout"] <- base::list(NULL)
[16:11:19.594]         }
[16:11:19.594]         base::close(...future.stdout)
[16:11:19.594]         ...future.stdout <- NULL
[16:11:19.594]     }
[16:11:19.594]     ...future.result$conditions <- ...future.conditions
[16:11:19.594]     ...future.result$finished <- base::Sys.time()
[16:11:19.594]     ...future.result
[16:11:19.594] }
[16:11:19.596] assign_globals() ...
[16:11:19.596] List of 5
[16:11:19.596]  $ ...future.FUN            :function (x)  
[16:11:19.596]  $ future.call.arguments    : list()
[16:11:19.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:19.596]  $ ...future.elements_ii    :List of 2
[16:11:19.596]   ..$ : int 1
[16:11:19.596]   ..$ : int 0
[16:11:19.596]  $ ...future.seeds_ii       : NULL
[16:11:19.596]  $ ...future.globals.maxSize: NULL
[16:11:19.596]  - attr(*, "resolved")= logi FALSE
[16:11:19.596]  - attr(*, "total_size")= num 4720
[16:11:19.596]  - attr(*, "where")=List of 5
[16:11:19.596]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:19.596]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:19.596]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:19.596]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:19.596]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:19.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:19.596]  - attr(*, "already-done")= logi TRUE
[16:11:19.600] - reassign environment for ‘...future.FUN’
[16:11:19.601] - copied ‘...future.FUN’ to environment
[16:11:19.601] - copied ‘future.call.arguments’ to environment
[16:11:19.601] - copied ‘...future.elements_ii’ to environment
[16:11:19.601] - copied ‘...future.seeds_ii’ to environment
[16:11:19.601] - copied ‘...future.globals.maxSize’ to environment
[16:11:19.601] assign_globals() ... done
[16:11:19.601] plan(): Setting new future strategy stack:
[16:11:19.601] List of future strategies:
[16:11:19.601] 1. sequential:
[16:11:19.601]    - args: function (..., envir = parent.frame())
[16:11:19.601]    - tweaked: FALSE
[16:11:19.601]    - call: NULL
[16:11:19.602] plan(): nbrOfWorkers() = 1
[16:11:20.103] plan(): Setting new future strategy stack:
[16:11:20.103] List of future strategies:
[16:11:20.103] 1. multisession:
[16:11:20.103]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:20.103]    - tweaked: FALSE
[16:11:20.103]    - call: plan(strategy)
[16:11:20.107] plan(): nbrOfWorkers() = 1
[16:11:20.107] SequentialFuture started (and completed)
[16:11:20.108] - Launch lazy future ... done
[16:11:20.108] run() for ‘SequentialFuture’ ... done
[16:11:20.108] Created future:
[16:11:20.108] SequentialFuture:
[16:11:20.108] Label: ‘future_lapply-1’
[16:11:20.108] Expression:
[16:11:20.108] {
[16:11:20.108]     do.call(function(...) {
[16:11:20.108]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:20.108]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:20.108]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:20.108]             on.exit(options(oopts), add = TRUE)
[16:11:20.108]         }
[16:11:20.108]         {
[16:11:20.108]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:20.108]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:20.108]                 ...future.FUN(...future.X_jj, ...)
[16:11:20.108]             })
[16:11:20.108]         }
[16:11:20.108]     }, args = future.call.arguments)
[16:11:20.108] }
[16:11:20.108] Lazy evaluation: FALSE
[16:11:20.108] Asynchronous evaluation: FALSE
[16:11:20.108] Local evaluation: TRUE
[16:11:20.108] Environment: R_GlobalEnv
[16:11:20.108] Capture standard output: NA
[16:11:20.108] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:20.108] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:20.108] Packages: <none>
[16:11:20.108] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:20.108] Resolved: TRUE
[16:11:20.108] Value: 112 bytes of class ‘list’
[16:11:20.108] Early signaling: FALSE
[16:11:20.108] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:20.108] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:20.109] Chunk #1 of 1 ... DONE
[16:11:20.109] Launching 1 futures (chunks) ... DONE
[16:11:20.109] Resolving 1 futures (chunks) ...
[16:11:20.109] resolve() on list ...
[16:11:20.109]  recursive: 0
[16:11:20.110]  length: 1
[16:11:20.110] 
[16:11:20.110] resolved() for ‘SequentialFuture’ ...
[16:11:20.110] - state: ‘finished’
[16:11:20.110] - run: TRUE
[16:11:20.110] - result: ‘FutureResult’
[16:11:20.110] resolved() for ‘SequentialFuture’ ... done
[16:11:20.110] Future #1
[16:11:20.110] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:20.110] - nx: 1
[16:11:20.111] - relay: TRUE
[16:11:20.111] - stdout: TRUE
[16:11:20.111] - signal: TRUE
[16:11:20.111] - resignal: FALSE
[16:11:20.111] - force: TRUE
[16:11:20.111] - relayed: [n=1] FALSE
[16:11:20.111] - queued futures: [n=1] FALSE
[16:11:20.111]  - until=1
[16:11:20.111]  - relaying element #1
[16:11:20.111] - relayed: [n=1] TRUE
[16:11:20.112] - queued futures: [n=1] TRUE
[16:11:20.112] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:20.112]  length: 0 (resolved future 1)
[16:11:20.112] Relaying remaining futures
[16:11:20.112] signalConditionsASAP(NULL, pos=0) ...
[16:11:20.112] - nx: 1
[16:11:20.112] - relay: TRUE
[16:11:20.112] - stdout: TRUE
[16:11:20.112] - signal: TRUE
[16:11:20.112] - resignal: FALSE
[16:11:20.112] - force: TRUE
[16:11:20.113] - relayed: [n=1] TRUE
[16:11:20.113] - queued futures: [n=1] TRUE
 - flush all
[16:11:20.113] - relayed: [n=1] TRUE
[16:11:20.113] - queued futures: [n=1] TRUE
[16:11:20.113] signalConditionsASAP(NULL, pos=0) ... done
[16:11:20.113] resolve() on list ... DONE
[16:11:20.113]  - Number of value chunks collected: 1
[16:11:20.113] Resolving 1 futures (chunks) ... DONE
[16:11:20.113] Reducing values from 1 chunks ...
[16:11:20.113]  - Number of values collected after concatenation: 2
[16:11:20.114]  - Number of values expected: 2
[16:11:20.114] Reducing values from 1 chunks ... DONE
[16:11:20.114] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:11:20.114] future_mapply() ...
[16:11:20.117] Number of chunks: 1
[16:11:20.117] getGlobalsAndPackagesXApply() ...
[16:11:20.118]  - future.globals: TRUE
[16:11:20.118] getGlobalsAndPackages() ...
[16:11:20.118] Searching for globals...
[16:11:20.121] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:20.121] Searching for globals ... DONE
[16:11:20.121] Resolving globals: FALSE
[16:11:20.122] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:20.122] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:20.122] - globals: [1] ‘FUN’
[16:11:20.122] 
[16:11:20.123] getGlobalsAndPackages() ... DONE
[16:11:20.123]  - globals found/used: [n=1] ‘FUN’
[16:11:20.123]  - needed namespaces: [n=0] 
[16:11:20.123] Finding globals ... DONE
[16:11:20.123] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:20.123] List of 2
[16:11:20.123]  $ ...future.FUN:function (x, y)  
[16:11:20.123]  $ MoreArgs     : NULL
[16:11:20.123]  - attr(*, "where")=List of 2
[16:11:20.123]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:20.123]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:20.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:20.123]  - attr(*, "resolved")= logi FALSE
[16:11:20.123]  - attr(*, "total_size")= num NA
[16:11:20.126] Packages to be attached in all futures: [n=0] 
[16:11:20.126] getGlobalsAndPackagesXApply() ... DONE
[16:11:20.126] Number of futures (= number of chunks): 1
[16:11:20.126] Launching 1 futures (chunks) ...
[16:11:20.126] Chunk #1 of 1 ...
[16:11:20.126]  - Finding globals in '...' for chunk #1 ...
[16:11:20.127] getGlobalsAndPackages() ...
[16:11:20.127] Searching for globals...
[16:11:20.127] 
[16:11:20.127] Searching for globals ... DONE
[16:11:20.127] - globals: [0] <none>
[16:11:20.127] getGlobalsAndPackages() ... DONE
[16:11:20.127]    + additional globals found: [n=0] 
[16:11:20.127]    + additional namespaces needed: [n=0] 
[16:11:20.128]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:20.128]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:20.128]  - seeds: <none>
[16:11:20.128] getGlobalsAndPackages() ...
[16:11:20.128] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:20.128] Resolving globals: FALSE
[16:11:20.129] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:20.129] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:20.129] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:20.129] 
[16:11:20.129] getGlobalsAndPackages() ... DONE
[16:11:20.130] run() for ‘Future’ ...
[16:11:20.130] - state: ‘created’
[16:11:20.130] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:20.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:20.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:20.133]   - Field: ‘label’
[16:11:20.134]   - Field: ‘local’
[16:11:20.134]   - Field: ‘owner’
[16:11:20.134]   - Field: ‘envir’
[16:11:20.134]   - Field: ‘packages’
[16:11:20.134]   - Field: ‘gc’
[16:11:20.134]   - Field: ‘conditions’
[16:11:20.134]   - Field: ‘expr’
[16:11:20.134]   - Field: ‘uuid’
[16:11:20.134]   - Field: ‘seed’
[16:11:20.134]   - Field: ‘version’
[16:11:20.134]   - Field: ‘result’
[16:11:20.135]   - Field: ‘asynchronous’
[16:11:20.135]   - Field: ‘calls’
[16:11:20.135]   - Field: ‘globals’
[16:11:20.135]   - Field: ‘stdout’
[16:11:20.135]   - Field: ‘earlySignal’
[16:11:20.135]   - Field: ‘lazy’
[16:11:20.135]   - Field: ‘state’
[16:11:20.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:20.135] - Launch lazy future ...
[16:11:20.135] Packages needed by the future expression (n = 0): <none>
[16:11:20.136] Packages needed by future strategies (n = 0): <none>
[16:11:20.136] {
[16:11:20.136]     {
[16:11:20.136]         {
[16:11:20.136]             ...future.startTime <- base::Sys.time()
[16:11:20.136]             {
[16:11:20.136]                 {
[16:11:20.136]                   {
[16:11:20.136]                     base::local({
[16:11:20.136]                       has_future <- base::requireNamespace("future", 
[16:11:20.136]                         quietly = TRUE)
[16:11:20.136]                       if (has_future) {
[16:11:20.136]                         ns <- base::getNamespace("future")
[16:11:20.136]                         version <- ns[[".package"]][["version"]]
[16:11:20.136]                         if (is.null(version)) 
[16:11:20.136]                           version <- utils::packageVersion("future")
[16:11:20.136]                       }
[16:11:20.136]                       else {
[16:11:20.136]                         version <- NULL
[16:11:20.136]                       }
[16:11:20.136]                       if (!has_future || version < "1.8.0") {
[16:11:20.136]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:20.136]                           "", base::R.version$version.string), 
[16:11:20.136]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:20.136]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:20.136]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:20.136]                             "release", "version")], collapse = " "), 
[16:11:20.136]                           hostname = base::Sys.info()[["nodename"]])
[16:11:20.136]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:20.136]                           info)
[16:11:20.136]                         info <- base::paste(info, collapse = "; ")
[16:11:20.136]                         if (!has_future) {
[16:11:20.136]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:20.136]                             info)
[16:11:20.136]                         }
[16:11:20.136]                         else {
[16:11:20.136]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:20.136]                             info, version)
[16:11:20.136]                         }
[16:11:20.136]                         base::stop(msg)
[16:11:20.136]                       }
[16:11:20.136]                     })
[16:11:20.136]                   }
[16:11:20.136]                   options(future.plan = NULL)
[16:11:20.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:20.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:20.136]                 }
[16:11:20.136]                 ...future.workdir <- getwd()
[16:11:20.136]             }
[16:11:20.136]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:20.136]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:20.136]         }
[16:11:20.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:20.136]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:20.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:20.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:20.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:20.136]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:20.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:20.136]             base::names(...future.oldOptions))
[16:11:20.136]     }
[16:11:20.136]     if (FALSE) {
[16:11:20.136]     }
[16:11:20.136]     else {
[16:11:20.136]         if (FALSE) {
[16:11:20.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:20.136]                 open = "w")
[16:11:20.136]         }
[16:11:20.136]         else {
[16:11:20.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:20.136]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:20.136]         }
[16:11:20.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:20.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:20.136]             base::sink(type = "output", split = FALSE)
[16:11:20.136]             base::close(...future.stdout)
[16:11:20.136]         }, add = TRUE)
[16:11:20.136]     }
[16:11:20.136]     ...future.frame <- base::sys.nframe()
[16:11:20.136]     ...future.conditions <- base::list()
[16:11:20.136]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:20.136]     if (FALSE) {
[16:11:20.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:20.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:20.136]     }
[16:11:20.136]     ...future.result <- base::tryCatch({
[16:11:20.136]         base::withCallingHandlers({
[16:11:20.136]             ...future.value <- base::withVisible(base::local({
[16:11:20.136]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:20.136]                 if (!identical(...future.globals.maxSize.org, 
[16:11:20.136]                   ...future.globals.maxSize)) {
[16:11:20.136]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:20.136]                   on.exit(options(oopts), add = TRUE)
[16:11:20.136]                 }
[16:11:20.136]                 {
[16:11:20.136]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:20.136]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:20.136]                     USE.NAMES = FALSE)
[16:11:20.136]                   do.call(mapply, args = args)
[16:11:20.136]                 }
[16:11:20.136]             }))
[16:11:20.136]             future::FutureResult(value = ...future.value$value, 
[16:11:20.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:20.136]                   ...future.rng), globalenv = if (FALSE) 
[16:11:20.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:20.136]                     ...future.globalenv.names))
[16:11:20.136]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:20.136]         }, condition = base::local({
[16:11:20.136]             c <- base::c
[16:11:20.136]             inherits <- base::inherits
[16:11:20.136]             invokeRestart <- base::invokeRestart
[16:11:20.136]             length <- base::length
[16:11:20.136]             list <- base::list
[16:11:20.136]             seq.int <- base::seq.int
[16:11:20.136]             signalCondition <- base::signalCondition
[16:11:20.136]             sys.calls <- base::sys.calls
[16:11:20.136]             `[[` <- base::`[[`
[16:11:20.136]             `+` <- base::`+`
[16:11:20.136]             `<<-` <- base::`<<-`
[16:11:20.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:20.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:20.136]                   3L)]
[16:11:20.136]             }
[16:11:20.136]             function(cond) {
[16:11:20.136]                 is_error <- inherits(cond, "error")
[16:11:20.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:20.136]                   NULL)
[16:11:20.136]                 if (is_error) {
[16:11:20.136]                   sessionInformation <- function() {
[16:11:20.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:20.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:20.136]                       search = base::search(), system = base::Sys.info())
[16:11:20.136]                   }
[16:11:20.136]                   ...future.conditions[[length(...future.conditions) + 
[16:11:20.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:20.136]                     cond$call), session = sessionInformation(), 
[16:11:20.136]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:20.136]                   signalCondition(cond)
[16:11:20.136]                 }
[16:11:20.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:20.136]                 "immediateCondition"))) {
[16:11:20.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:20.136]                   ...future.conditions[[length(...future.conditions) + 
[16:11:20.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:20.136]                   if (TRUE && !signal) {
[16:11:20.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:20.136]                     {
[16:11:20.136]                       inherits <- base::inherits
[16:11:20.136]                       invokeRestart <- base::invokeRestart
[16:11:20.136]                       is.null <- base::is.null
[16:11:20.136]                       muffled <- FALSE
[16:11:20.136]                       if (inherits(cond, "message")) {
[16:11:20.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:20.136]                         if (muffled) 
[16:11:20.136]                           invokeRestart("muffleMessage")
[16:11:20.136]                       }
[16:11:20.136]                       else if (inherits(cond, "warning")) {
[16:11:20.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:20.136]                         if (muffled) 
[16:11:20.136]                           invokeRestart("muffleWarning")
[16:11:20.136]                       }
[16:11:20.136]                       else if (inherits(cond, "condition")) {
[16:11:20.136]                         if (!is.null(pattern)) {
[16:11:20.136]                           computeRestarts <- base::computeRestarts
[16:11:20.136]                           grepl <- base::grepl
[16:11:20.136]                           restarts <- computeRestarts(cond)
[16:11:20.136]                           for (restart in restarts) {
[16:11:20.136]                             name <- restart$name
[16:11:20.136]                             if (is.null(name)) 
[16:11:20.136]                               next
[16:11:20.136]                             if (!grepl(pattern, name)) 
[16:11:20.136]                               next
[16:11:20.136]                             invokeRestart(restart)
[16:11:20.136]                             muffled <- TRUE
[16:11:20.136]                             break
[16:11:20.136]                           }
[16:11:20.136]                         }
[16:11:20.136]                       }
[16:11:20.136]                       invisible(muffled)
[16:11:20.136]                     }
[16:11:20.136]                     muffleCondition(cond, pattern = "^muffle")
[16:11:20.136]                   }
[16:11:20.136]                 }
[16:11:20.136]                 else {
[16:11:20.136]                   if (TRUE) {
[16:11:20.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:20.136]                     {
[16:11:20.136]                       inherits <- base::inherits
[16:11:20.136]                       invokeRestart <- base::invokeRestart
[16:11:20.136]                       is.null <- base::is.null
[16:11:20.136]                       muffled <- FALSE
[16:11:20.136]                       if (inherits(cond, "message")) {
[16:11:20.136]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:20.136]                         if (muffled) 
[16:11:20.136]                           invokeRestart("muffleMessage")
[16:11:20.136]                       }
[16:11:20.136]                       else if (inherits(cond, "warning")) {
[16:11:20.136]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:20.136]                         if (muffled) 
[16:11:20.136]                           invokeRestart("muffleWarning")
[16:11:20.136]                       }
[16:11:20.136]                       else if (inherits(cond, "condition")) {
[16:11:20.136]                         if (!is.null(pattern)) {
[16:11:20.136]                           computeRestarts <- base::computeRestarts
[16:11:20.136]                           grepl <- base::grepl
[16:11:20.136]                           restarts <- computeRestarts(cond)
[16:11:20.136]                           for (restart in restarts) {
[16:11:20.136]                             name <- restart$name
[16:11:20.136]                             if (is.null(name)) 
[16:11:20.136]                               next
[16:11:20.136]                             if (!grepl(pattern, name)) 
[16:11:20.136]                               next
[16:11:20.136]                             invokeRestart(restart)
[16:11:20.136]                             muffled <- TRUE
[16:11:20.136]                             break
[16:11:20.136]                           }
[16:11:20.136]                         }
[16:11:20.136]                       }
[16:11:20.136]                       invisible(muffled)
[16:11:20.136]                     }
[16:11:20.136]                     muffleCondition(cond, pattern = "^muffle")
[16:11:20.136]                   }
[16:11:20.136]                 }
[16:11:20.136]             }
[16:11:20.136]         }))
[16:11:20.136]     }, error = function(ex) {
[16:11:20.136]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:20.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:20.136]                 ...future.rng), started = ...future.startTime, 
[16:11:20.136]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:20.136]             version = "1.8"), class = "FutureResult")
[16:11:20.136]     }, finally = {
[16:11:20.136]         if (!identical(...future.workdir, getwd())) 
[16:11:20.136]             setwd(...future.workdir)
[16:11:20.136]         {
[16:11:20.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:20.136]                 ...future.oldOptions$nwarnings <- NULL
[16:11:20.136]             }
[16:11:20.136]             base::options(...future.oldOptions)
[16:11:20.136]             if (.Platform$OS.type == "windows") {
[16:11:20.136]                 old_names <- names(...future.oldEnvVars)
[16:11:20.136]                 envs <- base::Sys.getenv()
[16:11:20.136]                 names <- names(envs)
[16:11:20.136]                 common <- intersect(names, old_names)
[16:11:20.136]                 added <- setdiff(names, old_names)
[16:11:20.136]                 removed <- setdiff(old_names, names)
[16:11:20.136]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:20.136]                   envs[common]]
[16:11:20.136]                 NAMES <- toupper(changed)
[16:11:20.136]                 args <- list()
[16:11:20.136]                 for (kk in seq_along(NAMES)) {
[16:11:20.136]                   name <- changed[[kk]]
[16:11:20.136]                   NAME <- NAMES[[kk]]
[16:11:20.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:20.136]                     next
[16:11:20.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:20.136]                 }
[16:11:20.136]                 NAMES <- toupper(added)
[16:11:20.136]                 for (kk in seq_along(NAMES)) {
[16:11:20.136]                   name <- added[[kk]]
[16:11:20.136]                   NAME <- NAMES[[kk]]
[16:11:20.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:20.136]                     next
[16:11:20.136]                   args[[name]] <- ""
[16:11:20.136]                 }
[16:11:20.136]                 NAMES <- toupper(removed)
[16:11:20.136]                 for (kk in seq_along(NAMES)) {
[16:11:20.136]                   name <- removed[[kk]]
[16:11:20.136]                   NAME <- NAMES[[kk]]
[16:11:20.136]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:20.136]                     next
[16:11:20.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:20.136]                 }
[16:11:20.136]                 if (length(args) > 0) 
[16:11:20.136]                   base::do.call(base::Sys.setenv, args = args)
[16:11:20.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:20.136]             }
[16:11:20.136]             else {
[16:11:20.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:20.136]             }
[16:11:20.136]             {
[16:11:20.136]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:20.136]                   0L) {
[16:11:20.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:20.136]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:20.136]                   base::options(opts)
[16:11:20.136]                 }
[16:11:20.136]                 {
[16:11:20.136]                   {
[16:11:20.136]                     NULL
[16:11:20.136]                     RNGkind("Mersenne-Twister")
[16:11:20.136]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:20.136]                       inherits = FALSE)
[16:11:20.136]                   }
[16:11:20.136]                   options(future.plan = NULL)
[16:11:20.136]                   if (is.na(NA_character_)) 
[16:11:20.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:20.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:20.136]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:20.136]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:20.136]                     envir = parent.frame()) 
[16:11:20.136]                   {
[16:11:20.136]                     if (is.function(workers)) 
[16:11:20.136]                       workers <- workers()
[16:11:20.136]                     workers <- structure(as.integer(workers), 
[16:11:20.136]                       class = class(workers))
[16:11:20.136]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:20.136]                       workers >= 1)
[16:11:20.136]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:20.136]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:20.136]                     }
[16:11:20.136]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:20.136]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:20.136]                       envir = envir)
[16:11:20.136]                     if (!future$lazy) 
[16:11:20.136]                       future <- run(future)
[16:11:20.136]                     invisible(future)
[16:11:20.136]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:20.136]                 }
[16:11:20.136]             }
[16:11:20.136]         }
[16:11:20.136]     })
[16:11:20.136]     if (TRUE) {
[16:11:20.136]         base::sink(type = "output", split = FALSE)
[16:11:20.136]         if (FALSE) {
[16:11:20.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:20.136]         }
[16:11:20.136]         else {
[16:11:20.136]             ...future.result["stdout"] <- base::list(NULL)
[16:11:20.136]         }
[16:11:20.136]         base::close(...future.stdout)
[16:11:20.136]         ...future.stdout <- NULL
[16:11:20.136]     }
[16:11:20.136]     ...future.result$conditions <- ...future.conditions
[16:11:20.136]     ...future.result$finished <- base::Sys.time()
[16:11:20.136]     ...future.result
[16:11:20.136] }
[16:11:20.138] assign_globals() ...
[16:11:20.138] List of 5
[16:11:20.138]  $ ...future.FUN            :function (x, y)  
[16:11:20.138]  $ MoreArgs                 : NULL
[16:11:20.138]  $ ...future.elements_ii    :List of 2
[16:11:20.138]   ..$ :List of 2
[16:11:20.138]   .. ..$ : int 1
[16:11:20.138]   .. ..$ : int 0
[16:11:20.138]   ..$ :List of 2
[16:11:20.138]   .. ..$ : int 0
[16:11:20.138]   .. ..$ : int 1
[16:11:20.138]  $ ...future.seeds_ii       : NULL
[16:11:20.138]  $ ...future.globals.maxSize: NULL
[16:11:20.138]  - attr(*, "resolved")= logi FALSE
[16:11:20.138]  - attr(*, "total_size")= num 6480
[16:11:20.138]  - attr(*, "where")=List of 5
[16:11:20.138]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:20.138]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:20.138]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:20.138]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:20.138]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:20.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:20.138]  - attr(*, "already-done")= logi TRUE
[16:11:20.143] - reassign environment for ‘...future.FUN’
[16:11:20.144] - copied ‘...future.FUN’ to environment
[16:11:20.144] - copied ‘MoreArgs’ to environment
[16:11:20.144] - copied ‘...future.elements_ii’ to environment
[16:11:20.144] - copied ‘...future.seeds_ii’ to environment
[16:11:20.144] - copied ‘...future.globals.maxSize’ to environment
[16:11:20.144] assign_globals() ... done
[16:11:20.144] plan(): Setting new future strategy stack:
[16:11:20.144] List of future strategies:
[16:11:20.144] 1. sequential:
[16:11:20.144]    - args: function (..., envir = parent.frame())
[16:11:20.144]    - tweaked: FALSE
[16:11:20.144]    - call: NULL
[16:11:20.145] plan(): nbrOfWorkers() = 1
[16:11:20.646] plan(): Setting new future strategy stack:
[16:11:20.647] List of future strategies:
[16:11:20.647] 1. multisession:
[16:11:20.647]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:20.647]    - tweaked: FALSE
[16:11:20.647]    - call: plan(strategy)
[16:11:20.651] plan(): nbrOfWorkers() = 1
[16:11:20.651] SequentialFuture started (and completed)
[16:11:20.651] - Launch lazy future ... done
[16:11:20.651] run() for ‘SequentialFuture’ ... done
[16:11:20.651] Created future:
[16:11:20.651] SequentialFuture:
[16:11:20.651] Label: ‘future_mapply-1’
[16:11:20.651] Expression:
[16:11:20.651] {
[16:11:20.651]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:20.651]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:20.651]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:20.651]         on.exit(options(oopts), add = TRUE)
[16:11:20.651]     }
[16:11:20.651]     {
[16:11:20.651]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:20.651]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:20.651]         do.call(mapply, args = args)
[16:11:20.651]     }
[16:11:20.651] }
[16:11:20.651] Lazy evaluation: FALSE
[16:11:20.651] Asynchronous evaluation: FALSE
[16:11:20.651] Local evaluation: TRUE
[16:11:20.651] Environment: R_GlobalEnv
[16:11:20.651] Capture standard output: FALSE
[16:11:20.651] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:20.651] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:20.651] Packages: <none>
[16:11:20.651] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:20.651] Resolved: TRUE
[16:11:20.651] Value: 224 bytes of class ‘list’
[16:11:20.651] Early signaling: FALSE
[16:11:20.651] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:20.651] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:20.652] Chunk #1 of 1 ... DONE
[16:11:20.652] Launching 1 futures (chunks) ... DONE
[16:11:20.653] Resolving 1 futures (chunks) ...
[16:11:20.654] resolve() on list ...
[16:11:20.654]  recursive: 0
[16:11:20.654]  length: 1
[16:11:20.655] 
[16:11:20.655] resolved() for ‘SequentialFuture’ ...
[16:11:20.655] - state: ‘finished’
[16:11:20.655] - run: TRUE
[16:11:20.655] - result: ‘FutureResult’
[16:11:20.655] resolved() for ‘SequentialFuture’ ... done
[16:11:20.655] Future #1
[16:11:20.656] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:20.656] - nx: 1
[16:11:20.656] - relay: TRUE
[16:11:20.656] - stdout: TRUE
[16:11:20.656] - signal: TRUE
[16:11:20.656] - resignal: FALSE
[16:11:20.656] - force: TRUE
[16:11:20.656] - relayed: [n=1] FALSE
[16:11:20.656] - queued futures: [n=1] FALSE
[16:11:20.656]  - until=1
[16:11:20.657]  - relaying element #1
[16:11:20.657] - relayed: [n=1] TRUE
[16:11:20.657] - queued futures: [n=1] TRUE
[16:11:20.657] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:20.657]  length: 0 (resolved future 1)
[16:11:20.657] Relaying remaining futures
[16:11:20.657] signalConditionsASAP(NULL, pos=0) ...
[16:11:20.657] - nx: 1
[16:11:20.657] - relay: TRUE
[16:11:20.657] - stdout: TRUE
[16:11:20.658] - signal: TRUE
[16:11:20.658] - resignal: FALSE
[16:11:20.658] - force: TRUE
[16:11:20.658] - relayed: [n=1] TRUE
[16:11:20.658] - queued futures: [n=1] TRUE
 - flush all
[16:11:20.658] - relayed: [n=1] TRUE
[16:11:20.658] - queued futures: [n=1] TRUE
[16:11:20.658] signalConditionsASAP(NULL, pos=0) ... done
[16:11:20.658] resolve() on list ... DONE
[16:11:20.658]  - Number of value chunks collected: 1
[16:11:20.659] Resolving 1 futures (chunks) ... DONE
[16:11:20.659] Reducing values from 1 chunks ...
[16:11:20.659]  - Number of values collected after concatenation: 2
[16:11:20.659]  - Number of values expected: 2
[16:11:20.659] Reducing values from 1 chunks ... DONE
[16:11:20.659] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:11:20.659] future_mapply() ...
[16:11:20.663] Number of chunks: 1
[16:11:20.663] getGlobalsAndPackagesXApply() ...
[16:11:20.663]  - future.globals: TRUE
[16:11:20.663] getGlobalsAndPackages() ...
[16:11:20.663] Searching for globals...
[16:11:20.665] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:20.665] Searching for globals ... DONE
[16:11:20.665] Resolving globals: FALSE
[16:11:20.665] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:20.666] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:20.666] - globals: [1] ‘FUN’
[16:11:20.666] 
[16:11:20.666] getGlobalsAndPackages() ... DONE
[16:11:20.666]  - globals found/used: [n=1] ‘FUN’
[16:11:20.666]  - needed namespaces: [n=0] 
[16:11:20.666] Finding globals ... DONE
[16:11:20.666] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:20.667] List of 2
[16:11:20.667]  $ ...future.FUN:function (x, y)  
[16:11:20.667]  $ MoreArgs     : NULL
[16:11:20.667]  - attr(*, "where")=List of 2
[16:11:20.667]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:20.667]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:20.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:20.667]  - attr(*, "resolved")= logi FALSE
[16:11:20.667]  - attr(*, "total_size")= num NA
[16:11:20.669] Packages to be attached in all futures: [n=0] 
[16:11:20.669] getGlobalsAndPackagesXApply() ... DONE
[16:11:20.669] Number of futures (= number of chunks): 1
[16:11:20.669] Launching 1 futures (chunks) ...
[16:11:20.670] Chunk #1 of 1 ...
[16:11:20.670]  - Finding globals in '...' for chunk #1 ...
[16:11:20.670] getGlobalsAndPackages() ...
[16:11:20.670] Searching for globals...
[16:11:20.670] 
[16:11:20.670] Searching for globals ... DONE
[16:11:20.670] - globals: [0] <none>
[16:11:20.670] getGlobalsAndPackages() ... DONE
[16:11:20.670]    + additional globals found: [n=0] 
[16:11:20.671]    + additional namespaces needed: [n=0] 
[16:11:20.671]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:20.671]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:20.671]  - seeds: <none>
[16:11:20.671] getGlobalsAndPackages() ...
[16:11:20.671] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:20.671] Resolving globals: FALSE
[16:11:20.672] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:20.672] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:20.672] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:20.672] 
[16:11:20.672] getGlobalsAndPackages() ... DONE
[16:11:20.673] run() for ‘Future’ ...
[16:11:20.673] - state: ‘created’
[16:11:20.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:20.676] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:20.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:20.677]   - Field: ‘label’
[16:11:20.677]   - Field: ‘local’
[16:11:20.677]   - Field: ‘owner’
[16:11:20.677]   - Field: ‘envir’
[16:11:20.677]   - Field: ‘packages’
[16:11:20.677]   - Field: ‘gc’
[16:11:20.677]   - Field: ‘conditions’
[16:11:20.677]   - Field: ‘expr’
[16:11:20.677]   - Field: ‘uuid’
[16:11:20.677]   - Field: ‘seed’
[16:11:20.677]   - Field: ‘version’
[16:11:20.678]   - Field: ‘result’
[16:11:20.678]   - Field: ‘asynchronous’
[16:11:20.678]   - Field: ‘calls’
[16:11:20.678]   - Field: ‘globals’
[16:11:20.678]   - Field: ‘stdout’
[16:11:20.678]   - Field: ‘earlySignal’
[16:11:20.678]   - Field: ‘lazy’
[16:11:20.678]   - Field: ‘state’
[16:11:20.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:20.678] - Launch lazy future ...
[16:11:20.679] Packages needed by the future expression (n = 0): <none>
[16:11:20.679] Packages needed by future strategies (n = 0): <none>
[16:11:20.679] {
[16:11:20.679]     {
[16:11:20.679]         {
[16:11:20.679]             ...future.startTime <- base::Sys.time()
[16:11:20.679]             {
[16:11:20.679]                 {
[16:11:20.679]                   {
[16:11:20.679]                     base::local({
[16:11:20.679]                       has_future <- base::requireNamespace("future", 
[16:11:20.679]                         quietly = TRUE)
[16:11:20.679]                       if (has_future) {
[16:11:20.679]                         ns <- base::getNamespace("future")
[16:11:20.679]                         version <- ns[[".package"]][["version"]]
[16:11:20.679]                         if (is.null(version)) 
[16:11:20.679]                           version <- utils::packageVersion("future")
[16:11:20.679]                       }
[16:11:20.679]                       else {
[16:11:20.679]                         version <- NULL
[16:11:20.679]                       }
[16:11:20.679]                       if (!has_future || version < "1.8.0") {
[16:11:20.679]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:20.679]                           "", base::R.version$version.string), 
[16:11:20.679]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:20.679]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:20.679]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:20.679]                             "release", "version")], collapse = " "), 
[16:11:20.679]                           hostname = base::Sys.info()[["nodename"]])
[16:11:20.679]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:20.679]                           info)
[16:11:20.679]                         info <- base::paste(info, collapse = "; ")
[16:11:20.679]                         if (!has_future) {
[16:11:20.679]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:20.679]                             info)
[16:11:20.679]                         }
[16:11:20.679]                         else {
[16:11:20.679]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:20.679]                             info, version)
[16:11:20.679]                         }
[16:11:20.679]                         base::stop(msg)
[16:11:20.679]                       }
[16:11:20.679]                     })
[16:11:20.679]                   }
[16:11:20.679]                   options(future.plan = NULL)
[16:11:20.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:20.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:20.679]                 }
[16:11:20.679]                 ...future.workdir <- getwd()
[16:11:20.679]             }
[16:11:20.679]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:20.679]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:20.679]         }
[16:11:20.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:20.679]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:20.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:20.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:20.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:20.679]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:20.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:20.679]             base::names(...future.oldOptions))
[16:11:20.679]     }
[16:11:20.679]     if (FALSE) {
[16:11:20.679]     }
[16:11:20.679]     else {
[16:11:20.679]         if (TRUE) {
[16:11:20.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:20.679]                 open = "w")
[16:11:20.679]         }
[16:11:20.679]         else {
[16:11:20.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:20.679]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:20.679]         }
[16:11:20.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:20.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:20.679]             base::sink(type = "output", split = FALSE)
[16:11:20.679]             base::close(...future.stdout)
[16:11:20.679]         }, add = TRUE)
[16:11:20.679]     }
[16:11:20.679]     ...future.frame <- base::sys.nframe()
[16:11:20.679]     ...future.conditions <- base::list()
[16:11:20.679]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:20.679]     if (FALSE) {
[16:11:20.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:20.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:20.679]     }
[16:11:20.679]     ...future.result <- base::tryCatch({
[16:11:20.679]         base::withCallingHandlers({
[16:11:20.679]             ...future.value <- base::withVisible(base::local({
[16:11:20.679]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:20.679]                 if (!identical(...future.globals.maxSize.org, 
[16:11:20.679]                   ...future.globals.maxSize)) {
[16:11:20.679]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:20.679]                   on.exit(options(oopts), add = TRUE)
[16:11:20.679]                 }
[16:11:20.679]                 {
[16:11:20.679]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:20.679]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:20.679]                     USE.NAMES = FALSE)
[16:11:20.679]                   do.call(mapply, args = args)
[16:11:20.679]                 }
[16:11:20.679]             }))
[16:11:20.679]             future::FutureResult(value = ...future.value$value, 
[16:11:20.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:20.679]                   ...future.rng), globalenv = if (FALSE) 
[16:11:20.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:20.679]                     ...future.globalenv.names))
[16:11:20.679]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:20.679]         }, condition = base::local({
[16:11:20.679]             c <- base::c
[16:11:20.679]             inherits <- base::inherits
[16:11:20.679]             invokeRestart <- base::invokeRestart
[16:11:20.679]             length <- base::length
[16:11:20.679]             list <- base::list
[16:11:20.679]             seq.int <- base::seq.int
[16:11:20.679]             signalCondition <- base::signalCondition
[16:11:20.679]             sys.calls <- base::sys.calls
[16:11:20.679]             `[[` <- base::`[[`
[16:11:20.679]             `+` <- base::`+`
[16:11:20.679]             `<<-` <- base::`<<-`
[16:11:20.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:20.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:20.679]                   3L)]
[16:11:20.679]             }
[16:11:20.679]             function(cond) {
[16:11:20.679]                 is_error <- inherits(cond, "error")
[16:11:20.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:20.679]                   NULL)
[16:11:20.679]                 if (is_error) {
[16:11:20.679]                   sessionInformation <- function() {
[16:11:20.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:20.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:20.679]                       search = base::search(), system = base::Sys.info())
[16:11:20.679]                   }
[16:11:20.679]                   ...future.conditions[[length(...future.conditions) + 
[16:11:20.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:20.679]                     cond$call), session = sessionInformation(), 
[16:11:20.679]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:20.679]                   signalCondition(cond)
[16:11:20.679]                 }
[16:11:20.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:20.679]                 "immediateCondition"))) {
[16:11:20.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:20.679]                   ...future.conditions[[length(...future.conditions) + 
[16:11:20.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:20.679]                   if (TRUE && !signal) {
[16:11:20.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:20.679]                     {
[16:11:20.679]                       inherits <- base::inherits
[16:11:20.679]                       invokeRestart <- base::invokeRestart
[16:11:20.679]                       is.null <- base::is.null
[16:11:20.679]                       muffled <- FALSE
[16:11:20.679]                       if (inherits(cond, "message")) {
[16:11:20.679]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:20.679]                         if (muffled) 
[16:11:20.679]                           invokeRestart("muffleMessage")
[16:11:20.679]                       }
[16:11:20.679]                       else if (inherits(cond, "warning")) {
[16:11:20.679]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:20.679]                         if (muffled) 
[16:11:20.679]                           invokeRestart("muffleWarning")
[16:11:20.679]                       }
[16:11:20.679]                       else if (inherits(cond, "condition")) {
[16:11:20.679]                         if (!is.null(pattern)) {
[16:11:20.679]                           computeRestarts <- base::computeRestarts
[16:11:20.679]                           grepl <- base::grepl
[16:11:20.679]                           restarts <- computeRestarts(cond)
[16:11:20.679]                           for (restart in restarts) {
[16:11:20.679]                             name <- restart$name
[16:11:20.679]                             if (is.null(name)) 
[16:11:20.679]                               next
[16:11:20.679]                             if (!grepl(pattern, name)) 
[16:11:20.679]                               next
[16:11:20.679]                             invokeRestart(restart)
[16:11:20.679]                             muffled <- TRUE
[16:11:20.679]                             break
[16:11:20.679]                           }
[16:11:20.679]                         }
[16:11:20.679]                       }
[16:11:20.679]                       invisible(muffled)
[16:11:20.679]                     }
[16:11:20.679]                     muffleCondition(cond, pattern = "^muffle")
[16:11:20.679]                   }
[16:11:20.679]                 }
[16:11:20.679]                 else {
[16:11:20.679]                   if (TRUE) {
[16:11:20.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:20.679]                     {
[16:11:20.679]                       inherits <- base::inherits
[16:11:20.679]                       invokeRestart <- base::invokeRestart
[16:11:20.679]                       is.null <- base::is.null
[16:11:20.679]                       muffled <- FALSE
[16:11:20.679]                       if (inherits(cond, "message")) {
[16:11:20.679]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:20.679]                         if (muffled) 
[16:11:20.679]                           invokeRestart("muffleMessage")
[16:11:20.679]                       }
[16:11:20.679]                       else if (inherits(cond, "warning")) {
[16:11:20.679]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:20.679]                         if (muffled) 
[16:11:20.679]                           invokeRestart("muffleWarning")
[16:11:20.679]                       }
[16:11:20.679]                       else if (inherits(cond, "condition")) {
[16:11:20.679]                         if (!is.null(pattern)) {
[16:11:20.679]                           computeRestarts <- base::computeRestarts
[16:11:20.679]                           grepl <- base::grepl
[16:11:20.679]                           restarts <- computeRestarts(cond)
[16:11:20.679]                           for (restart in restarts) {
[16:11:20.679]                             name <- restart$name
[16:11:20.679]                             if (is.null(name)) 
[16:11:20.679]                               next
[16:11:20.679]                             if (!grepl(pattern, name)) 
[16:11:20.679]                               next
[16:11:20.679]                             invokeRestart(restart)
[16:11:20.679]                             muffled <- TRUE
[16:11:20.679]                             break
[16:11:20.679]                           }
[16:11:20.679]                         }
[16:11:20.679]                       }
[16:11:20.679]                       invisible(muffled)
[16:11:20.679]                     }
[16:11:20.679]                     muffleCondition(cond, pattern = "^muffle")
[16:11:20.679]                   }
[16:11:20.679]                 }
[16:11:20.679]             }
[16:11:20.679]         }))
[16:11:20.679]     }, error = function(ex) {
[16:11:20.679]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:20.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:20.679]                 ...future.rng), started = ...future.startTime, 
[16:11:20.679]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:20.679]             version = "1.8"), class = "FutureResult")
[16:11:20.679]     }, finally = {
[16:11:20.679]         if (!identical(...future.workdir, getwd())) 
[16:11:20.679]             setwd(...future.workdir)
[16:11:20.679]         {
[16:11:20.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:20.679]                 ...future.oldOptions$nwarnings <- NULL
[16:11:20.679]             }
[16:11:20.679]             base::options(...future.oldOptions)
[16:11:20.679]             if (.Platform$OS.type == "windows") {
[16:11:20.679]                 old_names <- names(...future.oldEnvVars)
[16:11:20.679]                 envs <- base::Sys.getenv()
[16:11:20.679]                 names <- names(envs)
[16:11:20.679]                 common <- intersect(names, old_names)
[16:11:20.679]                 added <- setdiff(names, old_names)
[16:11:20.679]                 removed <- setdiff(old_names, names)
[16:11:20.679]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:20.679]                   envs[common]]
[16:11:20.679]                 NAMES <- toupper(changed)
[16:11:20.679]                 args <- list()
[16:11:20.679]                 for (kk in seq_along(NAMES)) {
[16:11:20.679]                   name <- changed[[kk]]
[16:11:20.679]                   NAME <- NAMES[[kk]]
[16:11:20.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:20.679]                     next
[16:11:20.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:20.679]                 }
[16:11:20.679]                 NAMES <- toupper(added)
[16:11:20.679]                 for (kk in seq_along(NAMES)) {
[16:11:20.679]                   name <- added[[kk]]
[16:11:20.679]                   NAME <- NAMES[[kk]]
[16:11:20.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:20.679]                     next
[16:11:20.679]                   args[[name]] <- ""
[16:11:20.679]                 }
[16:11:20.679]                 NAMES <- toupper(removed)
[16:11:20.679]                 for (kk in seq_along(NAMES)) {
[16:11:20.679]                   name <- removed[[kk]]
[16:11:20.679]                   NAME <- NAMES[[kk]]
[16:11:20.679]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:20.679]                     next
[16:11:20.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:20.679]                 }
[16:11:20.679]                 if (length(args) > 0) 
[16:11:20.679]                   base::do.call(base::Sys.setenv, args = args)
[16:11:20.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:20.679]             }
[16:11:20.679]             else {
[16:11:20.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:20.679]             }
[16:11:20.679]             {
[16:11:20.679]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:20.679]                   0L) {
[16:11:20.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:20.679]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:20.679]                   base::options(opts)
[16:11:20.679]                 }
[16:11:20.679]                 {
[16:11:20.679]                   {
[16:11:20.679]                     NULL
[16:11:20.679]                     RNGkind("Mersenne-Twister")
[16:11:20.679]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:20.679]                       inherits = FALSE)
[16:11:20.679]                   }
[16:11:20.679]                   options(future.plan = NULL)
[16:11:20.679]                   if (is.na(NA_character_)) 
[16:11:20.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:20.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:20.679]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:20.679]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:20.679]                     envir = parent.frame()) 
[16:11:20.679]                   {
[16:11:20.679]                     if (is.function(workers)) 
[16:11:20.679]                       workers <- workers()
[16:11:20.679]                     workers <- structure(as.integer(workers), 
[16:11:20.679]                       class = class(workers))
[16:11:20.679]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:20.679]                       workers >= 1)
[16:11:20.679]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:20.679]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:20.679]                     }
[16:11:20.679]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:20.679]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:20.679]                       envir = envir)
[16:11:20.679]                     if (!future$lazy) 
[16:11:20.679]                       future <- run(future)
[16:11:20.679]                     invisible(future)
[16:11:20.679]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:20.679]                 }
[16:11:20.679]             }
[16:11:20.679]         }
[16:11:20.679]     })
[16:11:20.679]     if (TRUE) {
[16:11:20.679]         base::sink(type = "output", split = FALSE)
[16:11:20.679]         if (TRUE) {
[16:11:20.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:20.679]         }
[16:11:20.679]         else {
[16:11:20.679]             ...future.result["stdout"] <- base::list(NULL)
[16:11:20.679]         }
[16:11:20.679]         base::close(...future.stdout)
[16:11:20.679]         ...future.stdout <- NULL
[16:11:20.679]     }
[16:11:20.679]     ...future.result$conditions <- ...future.conditions
[16:11:20.679]     ...future.result$finished <- base::Sys.time()
[16:11:20.679]     ...future.result
[16:11:20.679] }
[16:11:20.681] assign_globals() ...
[16:11:20.681] List of 5
[16:11:20.681]  $ ...future.FUN            :function (x, y)  
[16:11:20.681]  $ MoreArgs                 : NULL
[16:11:20.681]  $ ...future.elements_ii    :List of 2
[16:11:20.681]   ..$ :List of 2
[16:11:20.681]   .. ..$ : int 1
[16:11:20.681]   .. ..$ : int 0
[16:11:20.681]   ..$ :List of 2
[16:11:20.681]   .. ..$ : int 0
[16:11:20.681]   .. ..$ : int 1
[16:11:20.681]  $ ...future.seeds_ii       : NULL
[16:11:20.681]  $ ...future.globals.maxSize: NULL
[16:11:20.681]  - attr(*, "resolved")= logi FALSE
[16:11:20.681]  - attr(*, "total_size")= num 6480
[16:11:20.681]  - attr(*, "where")=List of 5
[16:11:20.681]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:20.681]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:20.681]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:20.681]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:20.681]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:20.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:20.681]  - attr(*, "already-done")= logi TRUE
[16:11:20.688] - reassign environment for ‘...future.FUN’
[16:11:20.688] - copied ‘...future.FUN’ to environment
[16:11:20.688] - copied ‘MoreArgs’ to environment
[16:11:20.688] - copied ‘...future.elements_ii’ to environment
[16:11:20.688] - copied ‘...future.seeds_ii’ to environment
[16:11:20.688] - copied ‘...future.globals.maxSize’ to environment
[16:11:20.689] assign_globals() ... done
[16:11:20.689] plan(): Setting new future strategy stack:
[16:11:20.689] List of future strategies:
[16:11:20.689] 1. sequential:
[16:11:20.689]    - args: function (..., envir = parent.frame())
[16:11:20.689]    - tweaked: FALSE
[16:11:20.689]    - call: NULL
[16:11:20.689] plan(): nbrOfWorkers() = 1
[16:11:21.191] plan(): Setting new future strategy stack:
[16:11:21.191] List of future strategies:
[16:11:21.191] 1. multisession:
[16:11:21.191]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:21.191]    - tweaked: FALSE
[16:11:21.191]    - call: plan(strategy)
[16:11:21.195] plan(): nbrOfWorkers() = 1
[16:11:21.195] SequentialFuture started (and completed)
[16:11:21.195] - Launch lazy future ... done
[16:11:21.195] run() for ‘SequentialFuture’ ... done
[16:11:21.196] Created future:
[16:11:21.196] SequentialFuture:
[16:11:21.196] Label: ‘future_mapply-1’
[16:11:21.196] Expression:
[16:11:21.196] {
[16:11:21.196]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.196]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:21.196]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.196]         on.exit(options(oopts), add = TRUE)
[16:11:21.196]     }
[16:11:21.196]     {
[16:11:21.196]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:21.196]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:21.196]         do.call(mapply, args = args)
[16:11:21.196]     }
[16:11:21.196] }
[16:11:21.196] Lazy evaluation: FALSE
[16:11:21.196] Asynchronous evaluation: FALSE
[16:11:21.196] Local evaluation: TRUE
[16:11:21.196] Environment: R_GlobalEnv
[16:11:21.196] Capture standard output: TRUE
[16:11:21.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:21.196] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:21.196] Packages: <none>
[16:11:21.196] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:21.196] Resolved: TRUE
[16:11:21.196] Value: 224 bytes of class ‘list’
[16:11:21.196] Early signaling: FALSE
[16:11:21.196] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:21.196] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:21.197] Chunk #1 of 1 ... DONE
[16:11:21.197] Launching 1 futures (chunks) ... DONE
[16:11:21.197] Resolving 1 futures (chunks) ...
[16:11:21.197] resolve() on list ...
[16:11:21.197]  recursive: 0
[16:11:21.197]  length: 1
[16:11:21.197] 
[16:11:21.197] resolved() for ‘SequentialFuture’ ...
[16:11:21.198] - state: ‘finished’
[16:11:21.198] - run: TRUE
[16:11:21.198] - result: ‘FutureResult’
[16:11:21.198] resolved() for ‘SequentialFuture’ ... done
[16:11:21.198] Future #1
[16:11:21.198] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:21.198] - nx: 1
[16:11:21.198] - relay: TRUE
[16:11:21.198] - stdout: TRUE
[16:11:21.198] - signal: TRUE
[16:11:21.198] - resignal: FALSE
[16:11:21.199] - force: TRUE
[16:11:21.199] - relayed: [n=1] FALSE
[16:11:21.199] - queued futures: [n=1] FALSE
[16:11:21.199]  - until=1
[16:11:21.199]  - relaying element #1
[16:11:21.199] - relayed: [n=1] TRUE
[16:11:21.199] - queued futures: [n=1] TRUE
[16:11:21.199] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:21.199]  length: 0 (resolved future 1)
[16:11:21.199] Relaying remaining futures
[16:11:21.200] signalConditionsASAP(NULL, pos=0) ...
[16:11:21.200] - nx: 1
[16:11:21.200] - relay: TRUE
[16:11:21.200] - stdout: TRUE
[16:11:21.200] - signal: TRUE
[16:11:21.200] - resignal: FALSE
[16:11:21.200] - force: TRUE
[16:11:21.200] - relayed: [n=1] TRUE
[16:11:21.200] - queued futures: [n=1] TRUE
 - flush all
[16:11:21.200] - relayed: [n=1] TRUE
[16:11:21.200] - queued futures: [n=1] TRUE
[16:11:21.201] signalConditionsASAP(NULL, pos=0) ... done
[16:11:21.201] resolve() on list ... DONE
[16:11:21.201]  - Number of value chunks collected: 1
[16:11:21.201] Resolving 1 futures (chunks) ... DONE
[16:11:21.201] Reducing values from 1 chunks ...
[16:11:21.201]  - Number of values collected after concatenation: 2
[16:11:21.201]  - Number of values expected: 2
[16:11:21.201] Reducing values from 1 chunks ... DONE
[16:11:21.201] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:11:21.202] future_mapply() ...
[16:11:21.205] Number of chunks: 1
[16:11:21.205] getGlobalsAndPackagesXApply() ...
[16:11:21.205]  - future.globals: TRUE
[16:11:21.205] getGlobalsAndPackages() ...
[16:11:21.205] Searching for globals...
[16:11:21.207] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:21.207] Searching for globals ... DONE
[16:11:21.207] Resolving globals: FALSE
[16:11:21.207] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:21.208] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:21.208] - globals: [1] ‘FUN’
[16:11:21.208] 
[16:11:21.208] getGlobalsAndPackages() ... DONE
[16:11:21.208]  - globals found/used: [n=1] ‘FUN’
[16:11:21.208]  - needed namespaces: [n=0] 
[16:11:21.209] Finding globals ... DONE
[16:11:21.209] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:21.209] List of 2
[16:11:21.209]  $ ...future.FUN:function (x, y)  
[16:11:21.209]  $ MoreArgs     : NULL
[16:11:21.209]  - attr(*, "where")=List of 2
[16:11:21.209]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:21.209]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:21.209]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:21.209]  - attr(*, "resolved")= logi FALSE
[16:11:21.209]  - attr(*, "total_size")= num NA
[16:11:21.211] Packages to be attached in all futures: [n=0] 
[16:11:21.211] getGlobalsAndPackagesXApply() ... DONE
[16:11:21.212] Number of futures (= number of chunks): 1
[16:11:21.212] Launching 1 futures (chunks) ...
[16:11:21.212] Chunk #1 of 1 ...
[16:11:21.212]  - Finding globals in '...' for chunk #1 ...
[16:11:21.212] getGlobalsAndPackages() ...
[16:11:21.212] Searching for globals...
[16:11:21.213] 
[16:11:21.213] Searching for globals ... DONE
[16:11:21.213] - globals: [0] <none>
[16:11:21.213] getGlobalsAndPackages() ... DONE
[16:11:21.213]    + additional globals found: [n=0] 
[16:11:21.213]    + additional namespaces needed: [n=0] 
[16:11:21.213]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:21.213]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:21.213]  - seeds: <none>
[16:11:21.213] getGlobalsAndPackages() ...
[16:11:21.213] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:21.214] Resolving globals: FALSE
[16:11:21.216] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:11:21.216] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:21.216] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:21.217] 
[16:11:21.217] getGlobalsAndPackages() ... DONE
[16:11:21.217] run() for ‘Future’ ...
[16:11:21.217] - state: ‘created’
[16:11:21.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:21.221] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:21.221] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:21.221]   - Field: ‘label’
[16:11:21.221]   - Field: ‘local’
[16:11:21.221]   - Field: ‘owner’
[16:11:21.221]   - Field: ‘envir’
[16:11:21.221]   - Field: ‘packages’
[16:11:21.222]   - Field: ‘gc’
[16:11:21.222]   - Field: ‘conditions’
[16:11:21.222]   - Field: ‘expr’
[16:11:21.222]   - Field: ‘uuid’
[16:11:21.222]   - Field: ‘seed’
[16:11:21.222]   - Field: ‘version’
[16:11:21.222]   - Field: ‘result’
[16:11:21.222]   - Field: ‘asynchronous’
[16:11:21.222]   - Field: ‘calls’
[16:11:21.222]   - Field: ‘globals’
[16:11:21.222]   - Field: ‘stdout’
[16:11:21.223]   - Field: ‘earlySignal’
[16:11:21.223]   - Field: ‘lazy’
[16:11:21.223]   - Field: ‘state’
[16:11:21.223] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:21.223] - Launch lazy future ...
[16:11:21.223] Packages needed by the future expression (n = 0): <none>
[16:11:21.223] Packages needed by future strategies (n = 0): <none>
[16:11:21.224] {
[16:11:21.224]     {
[16:11:21.224]         {
[16:11:21.224]             ...future.startTime <- base::Sys.time()
[16:11:21.224]             {
[16:11:21.224]                 {
[16:11:21.224]                   {
[16:11:21.224]                     base::local({
[16:11:21.224]                       has_future <- base::requireNamespace("future", 
[16:11:21.224]                         quietly = TRUE)
[16:11:21.224]                       if (has_future) {
[16:11:21.224]                         ns <- base::getNamespace("future")
[16:11:21.224]                         version <- ns[[".package"]][["version"]]
[16:11:21.224]                         if (is.null(version)) 
[16:11:21.224]                           version <- utils::packageVersion("future")
[16:11:21.224]                       }
[16:11:21.224]                       else {
[16:11:21.224]                         version <- NULL
[16:11:21.224]                       }
[16:11:21.224]                       if (!has_future || version < "1.8.0") {
[16:11:21.224]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:21.224]                           "", base::R.version$version.string), 
[16:11:21.224]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:21.224]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:21.224]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:21.224]                             "release", "version")], collapse = " "), 
[16:11:21.224]                           hostname = base::Sys.info()[["nodename"]])
[16:11:21.224]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:21.224]                           info)
[16:11:21.224]                         info <- base::paste(info, collapse = "; ")
[16:11:21.224]                         if (!has_future) {
[16:11:21.224]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:21.224]                             info)
[16:11:21.224]                         }
[16:11:21.224]                         else {
[16:11:21.224]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:21.224]                             info, version)
[16:11:21.224]                         }
[16:11:21.224]                         base::stop(msg)
[16:11:21.224]                       }
[16:11:21.224]                     })
[16:11:21.224]                   }
[16:11:21.224]                   options(future.plan = NULL)
[16:11:21.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:21.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:21.224]                 }
[16:11:21.224]                 ...future.workdir <- getwd()
[16:11:21.224]             }
[16:11:21.224]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:21.224]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:21.224]         }
[16:11:21.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:21.224]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:21.224]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:21.224]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:21.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:21.224]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:21.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:21.224]             base::names(...future.oldOptions))
[16:11:21.224]     }
[16:11:21.224]     if (TRUE) {
[16:11:21.224]     }
[16:11:21.224]     else {
[16:11:21.224]         if (NA) {
[16:11:21.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:21.224]                 open = "w")
[16:11:21.224]         }
[16:11:21.224]         else {
[16:11:21.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:21.224]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:21.224]         }
[16:11:21.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:21.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:21.224]             base::sink(type = "output", split = FALSE)
[16:11:21.224]             base::close(...future.stdout)
[16:11:21.224]         }, add = TRUE)
[16:11:21.224]     }
[16:11:21.224]     ...future.frame <- base::sys.nframe()
[16:11:21.224]     ...future.conditions <- base::list()
[16:11:21.224]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:21.224]     if (FALSE) {
[16:11:21.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:21.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:21.224]     }
[16:11:21.224]     ...future.result <- base::tryCatch({
[16:11:21.224]         base::withCallingHandlers({
[16:11:21.224]             ...future.value <- base::withVisible(base::local({
[16:11:21.224]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.224]                 if (!identical(...future.globals.maxSize.org, 
[16:11:21.224]                   ...future.globals.maxSize)) {
[16:11:21.224]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.224]                   on.exit(options(oopts), add = TRUE)
[16:11:21.224]                 }
[16:11:21.224]                 {
[16:11:21.224]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:21.224]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:21.224]                     USE.NAMES = FALSE)
[16:11:21.224]                   do.call(mapply, args = args)
[16:11:21.224]                 }
[16:11:21.224]             }))
[16:11:21.224]             future::FutureResult(value = ...future.value$value, 
[16:11:21.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:21.224]                   ...future.rng), globalenv = if (FALSE) 
[16:11:21.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:21.224]                     ...future.globalenv.names))
[16:11:21.224]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:21.224]         }, condition = base::local({
[16:11:21.224]             c <- base::c
[16:11:21.224]             inherits <- base::inherits
[16:11:21.224]             invokeRestart <- base::invokeRestart
[16:11:21.224]             length <- base::length
[16:11:21.224]             list <- base::list
[16:11:21.224]             seq.int <- base::seq.int
[16:11:21.224]             signalCondition <- base::signalCondition
[16:11:21.224]             sys.calls <- base::sys.calls
[16:11:21.224]             `[[` <- base::`[[`
[16:11:21.224]             `+` <- base::`+`
[16:11:21.224]             `<<-` <- base::`<<-`
[16:11:21.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:21.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:21.224]                   3L)]
[16:11:21.224]             }
[16:11:21.224]             function(cond) {
[16:11:21.224]                 is_error <- inherits(cond, "error")
[16:11:21.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:21.224]                   NULL)
[16:11:21.224]                 if (is_error) {
[16:11:21.224]                   sessionInformation <- function() {
[16:11:21.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:21.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:21.224]                       search = base::search(), system = base::Sys.info())
[16:11:21.224]                   }
[16:11:21.224]                   ...future.conditions[[length(...future.conditions) + 
[16:11:21.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:21.224]                     cond$call), session = sessionInformation(), 
[16:11:21.224]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:21.224]                   signalCondition(cond)
[16:11:21.224]                 }
[16:11:21.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:21.224]                 "immediateCondition"))) {
[16:11:21.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:21.224]                   ...future.conditions[[length(...future.conditions) + 
[16:11:21.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:21.224]                   if (TRUE && !signal) {
[16:11:21.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:21.224]                     {
[16:11:21.224]                       inherits <- base::inherits
[16:11:21.224]                       invokeRestart <- base::invokeRestart
[16:11:21.224]                       is.null <- base::is.null
[16:11:21.224]                       muffled <- FALSE
[16:11:21.224]                       if (inherits(cond, "message")) {
[16:11:21.224]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:21.224]                         if (muffled) 
[16:11:21.224]                           invokeRestart("muffleMessage")
[16:11:21.224]                       }
[16:11:21.224]                       else if (inherits(cond, "warning")) {
[16:11:21.224]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:21.224]                         if (muffled) 
[16:11:21.224]                           invokeRestart("muffleWarning")
[16:11:21.224]                       }
[16:11:21.224]                       else if (inherits(cond, "condition")) {
[16:11:21.224]                         if (!is.null(pattern)) {
[16:11:21.224]                           computeRestarts <- base::computeRestarts
[16:11:21.224]                           grepl <- base::grepl
[16:11:21.224]                           restarts <- computeRestarts(cond)
[16:11:21.224]                           for (restart in restarts) {
[16:11:21.224]                             name <- restart$name
[16:11:21.224]                             if (is.null(name)) 
[16:11:21.224]                               next
[16:11:21.224]                             if (!grepl(pattern, name)) 
[16:11:21.224]                               next
[16:11:21.224]                             invokeRestart(restart)
[16:11:21.224]                             muffled <- TRUE
[16:11:21.224]                             break
[16:11:21.224]                           }
[16:11:21.224]                         }
[16:11:21.224]                       }
[16:11:21.224]                       invisible(muffled)
[16:11:21.224]                     }
[16:11:21.224]                     muffleCondition(cond, pattern = "^muffle")
[16:11:21.224]                   }
[16:11:21.224]                 }
[16:11:21.224]                 else {
[16:11:21.224]                   if (TRUE) {
[16:11:21.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:21.224]                     {
[16:11:21.224]                       inherits <- base::inherits
[16:11:21.224]                       invokeRestart <- base::invokeRestart
[16:11:21.224]                       is.null <- base::is.null
[16:11:21.224]                       muffled <- FALSE
[16:11:21.224]                       if (inherits(cond, "message")) {
[16:11:21.224]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:21.224]                         if (muffled) 
[16:11:21.224]                           invokeRestart("muffleMessage")
[16:11:21.224]                       }
[16:11:21.224]                       else if (inherits(cond, "warning")) {
[16:11:21.224]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:21.224]                         if (muffled) 
[16:11:21.224]                           invokeRestart("muffleWarning")
[16:11:21.224]                       }
[16:11:21.224]                       else if (inherits(cond, "condition")) {
[16:11:21.224]                         if (!is.null(pattern)) {
[16:11:21.224]                           computeRestarts <- base::computeRestarts
[16:11:21.224]                           grepl <- base::grepl
[16:11:21.224]                           restarts <- computeRestarts(cond)
[16:11:21.224]                           for (restart in restarts) {
[16:11:21.224]                             name <- restart$name
[16:11:21.224]                             if (is.null(name)) 
[16:11:21.224]                               next
[16:11:21.224]                             if (!grepl(pattern, name)) 
[16:11:21.224]                               next
[16:11:21.224]                             invokeRestart(restart)
[16:11:21.224]                             muffled <- TRUE
[16:11:21.224]                             break
[16:11:21.224]                           }
[16:11:21.224]                         }
[16:11:21.224]                       }
[16:11:21.224]                       invisible(muffled)
[16:11:21.224]                     }
[16:11:21.224]                     muffleCondition(cond, pattern = "^muffle")
[16:11:21.224]                   }
[16:11:21.224]                 }
[16:11:21.224]             }
[16:11:21.224]         }))
[16:11:21.224]     }, error = function(ex) {
[16:11:21.224]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:21.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:21.224]                 ...future.rng), started = ...future.startTime, 
[16:11:21.224]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:21.224]             version = "1.8"), class = "FutureResult")
[16:11:21.224]     }, finally = {
[16:11:21.224]         if (!identical(...future.workdir, getwd())) 
[16:11:21.224]             setwd(...future.workdir)
[16:11:21.224]         {
[16:11:21.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:21.224]                 ...future.oldOptions$nwarnings <- NULL
[16:11:21.224]             }
[16:11:21.224]             base::options(...future.oldOptions)
[16:11:21.224]             if (.Platform$OS.type == "windows") {
[16:11:21.224]                 old_names <- names(...future.oldEnvVars)
[16:11:21.224]                 envs <- base::Sys.getenv()
[16:11:21.224]                 names <- names(envs)
[16:11:21.224]                 common <- intersect(names, old_names)
[16:11:21.224]                 added <- setdiff(names, old_names)
[16:11:21.224]                 removed <- setdiff(old_names, names)
[16:11:21.224]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:21.224]                   envs[common]]
[16:11:21.224]                 NAMES <- toupper(changed)
[16:11:21.224]                 args <- list()
[16:11:21.224]                 for (kk in seq_along(NAMES)) {
[16:11:21.224]                   name <- changed[[kk]]
[16:11:21.224]                   NAME <- NAMES[[kk]]
[16:11:21.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.224]                     next
[16:11:21.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:21.224]                 }
[16:11:21.224]                 NAMES <- toupper(added)
[16:11:21.224]                 for (kk in seq_along(NAMES)) {
[16:11:21.224]                   name <- added[[kk]]
[16:11:21.224]                   NAME <- NAMES[[kk]]
[16:11:21.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.224]                     next
[16:11:21.224]                   args[[name]] <- ""
[16:11:21.224]                 }
[16:11:21.224]                 NAMES <- toupper(removed)
[16:11:21.224]                 for (kk in seq_along(NAMES)) {
[16:11:21.224]                   name <- removed[[kk]]
[16:11:21.224]                   NAME <- NAMES[[kk]]
[16:11:21.224]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.224]                     next
[16:11:21.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:21.224]                 }
[16:11:21.224]                 if (length(args) > 0) 
[16:11:21.224]                   base::do.call(base::Sys.setenv, args = args)
[16:11:21.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:21.224]             }
[16:11:21.224]             else {
[16:11:21.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:21.224]             }
[16:11:21.224]             {
[16:11:21.224]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:21.224]                   0L) {
[16:11:21.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:21.224]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:21.224]                   base::options(opts)
[16:11:21.224]                 }
[16:11:21.224]                 {
[16:11:21.224]                   {
[16:11:21.224]                     NULL
[16:11:21.224]                     RNGkind("Mersenne-Twister")
[16:11:21.224]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:21.224]                       inherits = FALSE)
[16:11:21.224]                   }
[16:11:21.224]                   options(future.plan = NULL)
[16:11:21.224]                   if (is.na(NA_character_)) 
[16:11:21.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:21.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:21.224]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:21.224]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:21.224]                     envir = parent.frame()) 
[16:11:21.224]                   {
[16:11:21.224]                     if (is.function(workers)) 
[16:11:21.224]                       workers <- workers()
[16:11:21.224]                     workers <- structure(as.integer(workers), 
[16:11:21.224]                       class = class(workers))
[16:11:21.224]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:21.224]                       workers >= 1)
[16:11:21.224]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:21.224]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:21.224]                     }
[16:11:21.224]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:21.224]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:21.224]                       envir = envir)
[16:11:21.224]                     if (!future$lazy) 
[16:11:21.224]                       future <- run(future)
[16:11:21.224]                     invisible(future)
[16:11:21.224]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:21.224]                 }
[16:11:21.224]             }
[16:11:21.224]         }
[16:11:21.224]     })
[16:11:21.224]     if (FALSE) {
[16:11:21.224]         base::sink(type = "output", split = FALSE)
[16:11:21.224]         if (NA) {
[16:11:21.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:21.224]         }
[16:11:21.224]         else {
[16:11:21.224]             ...future.result["stdout"] <- base::list(NULL)
[16:11:21.224]         }
[16:11:21.224]         base::close(...future.stdout)
[16:11:21.224]         ...future.stdout <- NULL
[16:11:21.224]     }
[16:11:21.224]     ...future.result$conditions <- ...future.conditions
[16:11:21.224]     ...future.result$finished <- base::Sys.time()
[16:11:21.224]     ...future.result
[16:11:21.224] }
[16:11:21.225] assign_globals() ...
[16:11:21.226] List of 5
[16:11:21.226]  $ ...future.FUN            :function (x, y)  
[16:11:21.226]  $ MoreArgs                 : NULL
[16:11:21.226]  $ ...future.elements_ii    :List of 2
[16:11:21.226]   ..$ :List of 2
[16:11:21.226]   .. ..$ : int 1
[16:11:21.226]   .. ..$ : int 0
[16:11:21.226]   ..$ :List of 2
[16:11:21.226]   .. ..$ : int 0
[16:11:21.226]   .. ..$ : int 1
[16:11:21.226]  $ ...future.seeds_ii       : NULL
[16:11:21.226]  $ ...future.globals.maxSize: NULL
[16:11:21.226]  - attr(*, "resolved")= logi FALSE
[16:11:21.226]  - attr(*, "total_size")= num 6480
[16:11:21.226]  - attr(*, "where")=List of 5
[16:11:21.226]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:21.226]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:21.226]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:21.226]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:21.226]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:21.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:21.226]  - attr(*, "already-done")= logi TRUE
[16:11:21.231] - reassign environment for ‘...future.FUN’
[16:11:21.231] - copied ‘...future.FUN’ to environment
[16:11:21.231] - copied ‘MoreArgs’ to environment
[16:11:21.231] - copied ‘...future.elements_ii’ to environment
[16:11:21.231] - copied ‘...future.seeds_ii’ to environment
[16:11:21.232] - copied ‘...future.globals.maxSize’ to environment
[16:11:21.232] assign_globals() ... done
[16:11:21.232] plan(): Setting new future strategy stack:
[16:11:21.232] List of future strategies:
[16:11:21.232] 1. sequential:
[16:11:21.232]    - args: function (..., envir = parent.frame())
[16:11:21.232]    - tweaked: FALSE
[16:11:21.232]    - call: NULL
[16:11:21.232] plan(): nbrOfWorkers() = 1
[16:11:21.734] plan(): Setting new future strategy stack:
[16:11:21.734] List of future strategies:
[16:11:21.734] 1. multisession:
[16:11:21.734]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:21.734]    - tweaked: FALSE
[16:11:21.734]    - call: plan(strategy)
[16:11:21.738] plan(): nbrOfWorkers() = 1
[16:11:21.738] SequentialFuture started (and completed)
[16:11:21.738] - Launch lazy future ... done
[16:11:21.738] run() for ‘SequentialFuture’ ... done
[16:11:21.738] Created future:
[16:11:21.739] SequentialFuture:
[16:11:21.739] Label: ‘future_mapply-1’
[16:11:21.739] Expression:
[16:11:21.739] {
[16:11:21.739]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.739]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:21.739]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.739]         on.exit(options(oopts), add = TRUE)
[16:11:21.739]     }
[16:11:21.739]     {
[16:11:21.739]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:21.739]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:21.739]         do.call(mapply, args = args)
[16:11:21.739]     }
[16:11:21.739] }
[16:11:21.739] Lazy evaluation: FALSE
[16:11:21.739] Asynchronous evaluation: FALSE
[16:11:21.739] Local evaluation: TRUE
[16:11:21.739] Environment: R_GlobalEnv
[16:11:21.739] Capture standard output: NA
[16:11:21.739] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:21.739] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:21.739] Packages: <none>
[16:11:21.739] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:21.739] Resolved: TRUE
[16:11:21.739] Value: 224 bytes of class ‘list’
[16:11:21.739] Early signaling: FALSE
[16:11:21.739] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:21.739] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:21.740] Chunk #1 of 1 ... DONE
[16:11:21.740] Launching 1 futures (chunks) ... DONE
[16:11:21.740] Resolving 1 futures (chunks) ...
[16:11:21.740] resolve() on list ...
[16:11:21.740]  recursive: 0
[16:11:21.740]  length: 1
[16:11:21.740] 
[16:11:21.740] resolved() for ‘SequentialFuture’ ...
[16:11:21.740] - state: ‘finished’
[16:11:21.740] - run: TRUE
[16:11:21.741] - result: ‘FutureResult’
[16:11:21.741] resolved() for ‘SequentialFuture’ ... done
[16:11:21.741] Future #1
[16:11:21.741] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:21.741] - nx: 1
[16:11:21.741] - relay: TRUE
[16:11:21.741] - stdout: TRUE
[16:11:21.741] - signal: TRUE
[16:11:21.741] - resignal: FALSE
[16:11:21.741] - force: TRUE
[16:11:21.741] - relayed: [n=1] FALSE
[16:11:21.742] - queued futures: [n=1] FALSE
[16:11:21.742]  - until=1
[16:11:21.742]  - relaying element #1
[16:11:21.742] - relayed: [n=1] TRUE
[16:11:21.742] - queued futures: [n=1] TRUE
[16:11:21.742] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:21.742]  length: 0 (resolved future 1)
[16:11:21.742] Relaying remaining futures
[16:11:21.742] signalConditionsASAP(NULL, pos=0) ...
[16:11:21.742] - nx: 1
[16:11:21.743] - relay: TRUE
[16:11:21.743] - stdout: TRUE
[16:11:21.743] - signal: TRUE
[16:11:21.743] - resignal: FALSE
[16:11:21.743] - force: TRUE
[16:11:21.743] - relayed: [n=1] TRUE
[16:11:21.743] - queued futures: [n=1] TRUE
 - flush all
[16:11:21.743] - relayed: [n=1] TRUE
[16:11:21.743] - queued futures: [n=1] TRUE
[16:11:21.743] signalConditionsASAP(NULL, pos=0) ... done
[16:11:21.743] resolve() on list ... DONE
[16:11:21.744]  - Number of value chunks collected: 1
[16:11:21.744] Resolving 1 futures (chunks) ... DONE
[16:11:21.744] Reducing values from 1 chunks ...
[16:11:21.744]  - Number of values collected after concatenation: 2
[16:11:21.744]  - Number of values expected: 2
[16:11:21.744] Reducing values from 1 chunks ... DONE
[16:11:21.744] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[16:11:21.750] plan(): Setting new future strategy stack:
[16:11:21.750] List of future strategies:
[16:11:21.750] 1. multicore:
[16:11:21.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:21.750]    - tweaked: FALSE
[16:11:21.750]    - call: plan(strategy)
[16:11:21.754] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:11:21.754] future_lapply() ...
[16:11:21.760] Number of chunks: 2
[16:11:21.760] getGlobalsAndPackagesXApply() ...
[16:11:21.760]  - future.globals: TRUE
[16:11:21.760] getGlobalsAndPackages() ...
[16:11:21.760] Searching for globals...
[16:11:21.761] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:21.761] Searching for globals ... DONE
[16:11:21.762] Resolving globals: FALSE
[16:11:21.762] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:21.762] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:21.762] - globals: [1] ‘FUN’
[16:11:21.763] 
[16:11:21.763] getGlobalsAndPackages() ... DONE
[16:11:21.763]  - globals found/used: [n=1] ‘FUN’
[16:11:21.763]  - needed namespaces: [n=0] 
[16:11:21.763] Finding globals ... DONE
[16:11:21.763]  - use_args: TRUE
[16:11:21.763]  - Getting '...' globals ...
[16:11:21.763] resolve() on list ...
[16:11:21.763]  recursive: 0
[16:11:21.764]  length: 1
[16:11:21.764]  elements: ‘...’
[16:11:21.764]  length: 0 (resolved future 1)
[16:11:21.764] resolve() on list ... DONE
[16:11:21.764]    - '...' content: [n=0] 
[16:11:21.764] List of 1
[16:11:21.764]  $ ...: list()
[16:11:21.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:21.764]  - attr(*, "where")=List of 1
[16:11:21.764]   ..$ ...:<environment: 0x557e1f497638> 
[16:11:21.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:21.764]  - attr(*, "resolved")= logi TRUE
[16:11:21.764]  - attr(*, "total_size")= num NA
[16:11:21.767]  - Getting '...' globals ... DONE
[16:11:21.767] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:21.767] List of 2
[16:11:21.767]  $ ...future.FUN:function (x)  
[16:11:21.767]  $ ...          : list()
[16:11:21.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:21.767]  - attr(*, "where")=List of 2
[16:11:21.767]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:21.767]   ..$ ...          :<environment: 0x557e1f497638> 
[16:11:21.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:21.767]  - attr(*, "resolved")= logi FALSE
[16:11:21.767]  - attr(*, "total_size")= num 4720
[16:11:21.770] Packages to be attached in all futures: [n=0] 
[16:11:21.770] getGlobalsAndPackagesXApply() ... DONE
[16:11:21.770] Number of futures (= number of chunks): 2
[16:11:21.770] Launching 2 futures (chunks) ...
[16:11:21.770] Chunk #1 of 2 ...
[16:11:21.770]  - Finding globals in 'X' for chunk #1 ...
[16:11:21.770] getGlobalsAndPackages() ...
[16:11:21.770] Searching for globals...
[16:11:21.771] 
[16:11:21.771] Searching for globals ... DONE
[16:11:21.771] - globals: [0] <none>
[16:11:21.771] getGlobalsAndPackages() ... DONE
[16:11:21.771]    + additional globals found: [n=0] 
[16:11:21.771]    + additional namespaces needed: [n=0] 
[16:11:21.771]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:21.771]  - seeds: <none>
[16:11:21.771] getGlobalsAndPackages() ...
[16:11:21.771] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:21.772] Resolving globals: FALSE
[16:11:21.772] Tweak future expression to call with '...' arguments ...
[16:11:21.772] {
[16:11:21.772]     do.call(function(...) {
[16:11:21.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:21.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.772]             on.exit(options(oopts), add = TRUE)
[16:11:21.772]         }
[16:11:21.772]         {
[16:11:21.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:21.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:21.772]                 ...future.FUN(...future.X_jj, ...)
[16:11:21.772]             })
[16:11:21.772]         }
[16:11:21.772]     }, args = future.call.arguments)
[16:11:21.772] }
[16:11:21.772] Tweak future expression to call with '...' arguments ... DONE
[16:11:21.772] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:21.772] 
[16:11:21.773] getGlobalsAndPackages() ... DONE
[16:11:21.773] run() for ‘Future’ ...
[16:11:21.773] - state: ‘created’
[16:11:21.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:21.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:21.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:21.777]   - Field: ‘label’
[16:11:21.777]   - Field: ‘local’
[16:11:21.777]   - Field: ‘owner’
[16:11:21.777]   - Field: ‘envir’
[16:11:21.777]   - Field: ‘workers’
[16:11:21.777]   - Field: ‘packages’
[16:11:21.778]   - Field: ‘gc’
[16:11:21.779]   - Field: ‘job’
[16:11:21.779]   - Field: ‘conditions’
[16:11:21.780]   - Field: ‘expr’
[16:11:21.780]   - Field: ‘uuid’
[16:11:21.780]   - Field: ‘seed’
[16:11:21.780]   - Field: ‘version’
[16:11:21.780]   - Field: ‘result’
[16:11:21.780]   - Field: ‘asynchronous’
[16:11:21.780]   - Field: ‘calls’
[16:11:21.780]   - Field: ‘globals’
[16:11:21.780]   - Field: ‘stdout’
[16:11:21.781]   - Field: ‘earlySignal’
[16:11:21.781]   - Field: ‘lazy’
[16:11:21.781]   - Field: ‘state’
[16:11:21.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:21.781] - Launch lazy future ...
[16:11:21.782] Packages needed by the future expression (n = 0): <none>
[16:11:21.782] Packages needed by future strategies (n = 0): <none>
[16:11:21.783] {
[16:11:21.783]     {
[16:11:21.783]         {
[16:11:21.783]             ...future.startTime <- base::Sys.time()
[16:11:21.783]             {
[16:11:21.783]                 {
[16:11:21.783]                   {
[16:11:21.783]                     {
[16:11:21.783]                       base::local({
[16:11:21.783]                         has_future <- base::requireNamespace("future", 
[16:11:21.783]                           quietly = TRUE)
[16:11:21.783]                         if (has_future) {
[16:11:21.783]                           ns <- base::getNamespace("future")
[16:11:21.783]                           version <- ns[[".package"]][["version"]]
[16:11:21.783]                           if (is.null(version)) 
[16:11:21.783]                             version <- utils::packageVersion("future")
[16:11:21.783]                         }
[16:11:21.783]                         else {
[16:11:21.783]                           version <- NULL
[16:11:21.783]                         }
[16:11:21.783]                         if (!has_future || version < "1.8.0") {
[16:11:21.783]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:21.783]                             "", base::R.version$version.string), 
[16:11:21.783]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:21.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:21.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:21.783]                               "release", "version")], collapse = " "), 
[16:11:21.783]                             hostname = base::Sys.info()[["nodename"]])
[16:11:21.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:21.783]                             info)
[16:11:21.783]                           info <- base::paste(info, collapse = "; ")
[16:11:21.783]                           if (!has_future) {
[16:11:21.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:21.783]                               info)
[16:11:21.783]                           }
[16:11:21.783]                           else {
[16:11:21.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:21.783]                               info, version)
[16:11:21.783]                           }
[16:11:21.783]                           base::stop(msg)
[16:11:21.783]                         }
[16:11:21.783]                       })
[16:11:21.783]                     }
[16:11:21.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:21.783]                     base::options(mc.cores = 1L)
[16:11:21.783]                   }
[16:11:21.783]                   options(future.plan = NULL)
[16:11:21.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:21.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:21.783]                 }
[16:11:21.783]                 ...future.workdir <- getwd()
[16:11:21.783]             }
[16:11:21.783]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:21.783]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:21.783]         }
[16:11:21.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:21.783]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:21.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:21.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:21.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:21.783]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:21.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:21.783]             base::names(...future.oldOptions))
[16:11:21.783]     }
[16:11:21.783]     if (FALSE) {
[16:11:21.783]     }
[16:11:21.783]     else {
[16:11:21.783]         if (FALSE) {
[16:11:21.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:21.783]                 open = "w")
[16:11:21.783]         }
[16:11:21.783]         else {
[16:11:21.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:21.783]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:21.783]         }
[16:11:21.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:21.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:21.783]             base::sink(type = "output", split = FALSE)
[16:11:21.783]             base::close(...future.stdout)
[16:11:21.783]         }, add = TRUE)
[16:11:21.783]     }
[16:11:21.783]     ...future.frame <- base::sys.nframe()
[16:11:21.783]     ...future.conditions <- base::list()
[16:11:21.783]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:21.783]     if (FALSE) {
[16:11:21.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:21.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:21.783]     }
[16:11:21.783]     ...future.result <- base::tryCatch({
[16:11:21.783]         base::withCallingHandlers({
[16:11:21.783]             ...future.value <- base::withVisible(base::local({
[16:11:21.783]                 withCallingHandlers({
[16:11:21.783]                   {
[16:11:21.783]                     do.call(function(...) {
[16:11:21.783]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.783]                       if (!identical(...future.globals.maxSize.org, 
[16:11:21.783]                         ...future.globals.maxSize)) {
[16:11:21.783]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.783]                         on.exit(options(oopts), add = TRUE)
[16:11:21.783]                       }
[16:11:21.783]                       {
[16:11:21.783]                         lapply(seq_along(...future.elements_ii), 
[16:11:21.783]                           FUN = function(jj) {
[16:11:21.783]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:21.783]                             ...future.FUN(...future.X_jj, ...)
[16:11:21.783]                           })
[16:11:21.783]                       }
[16:11:21.783]                     }, args = future.call.arguments)
[16:11:21.783]                   }
[16:11:21.783]                 }, immediateCondition = function(cond) {
[16:11:21.783]                   save_rds <- function (object, pathname, ...) 
[16:11:21.783]                   {
[16:11:21.783]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:21.783]                     if (file_test("-f", pathname_tmp)) {
[16:11:21.783]                       fi_tmp <- file.info(pathname_tmp)
[16:11:21.783]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:21.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:21.783]                         fi_tmp[["mtime"]])
[16:11:21.783]                     }
[16:11:21.783]                     tryCatch({
[16:11:21.783]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:21.783]                     }, error = function(ex) {
[16:11:21.783]                       msg <- conditionMessage(ex)
[16:11:21.783]                       fi_tmp <- file.info(pathname_tmp)
[16:11:21.783]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:21.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:21.783]                         fi_tmp[["mtime"]], msg)
[16:11:21.783]                       ex$message <- msg
[16:11:21.783]                       stop(ex)
[16:11:21.783]                     })
[16:11:21.783]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:21.783]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:21.783]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:21.783]                       fi_tmp <- file.info(pathname_tmp)
[16:11:21.783]                       fi <- file.info(pathname)
[16:11:21.783]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:21.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:21.783]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:21.783]                         fi[["size"]], fi[["mtime"]])
[16:11:21.783]                       stop(msg)
[16:11:21.783]                     }
[16:11:21.783]                     invisible(pathname)
[16:11:21.783]                   }
[16:11:21.783]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:21.783]                     rootPath = tempdir()) 
[16:11:21.783]                   {
[16:11:21.783]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:21.783]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:21.783]                       tmpdir = path, fileext = ".rds")
[16:11:21.783]                     save_rds(obj, file)
[16:11:21.783]                   }
[16:11:21.783]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:21.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:21.783]                   {
[16:11:21.783]                     inherits <- base::inherits
[16:11:21.783]                     invokeRestart <- base::invokeRestart
[16:11:21.783]                     is.null <- base::is.null
[16:11:21.783]                     muffled <- FALSE
[16:11:21.783]                     if (inherits(cond, "message")) {
[16:11:21.783]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:21.783]                       if (muffled) 
[16:11:21.783]                         invokeRestart("muffleMessage")
[16:11:21.783]                     }
[16:11:21.783]                     else if (inherits(cond, "warning")) {
[16:11:21.783]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:21.783]                       if (muffled) 
[16:11:21.783]                         invokeRestart("muffleWarning")
[16:11:21.783]                     }
[16:11:21.783]                     else if (inherits(cond, "condition")) {
[16:11:21.783]                       if (!is.null(pattern)) {
[16:11:21.783]                         computeRestarts <- base::computeRestarts
[16:11:21.783]                         grepl <- base::grepl
[16:11:21.783]                         restarts <- computeRestarts(cond)
[16:11:21.783]                         for (restart in restarts) {
[16:11:21.783]                           name <- restart$name
[16:11:21.783]                           if (is.null(name)) 
[16:11:21.783]                             next
[16:11:21.783]                           if (!grepl(pattern, name)) 
[16:11:21.783]                             next
[16:11:21.783]                           invokeRestart(restart)
[16:11:21.783]                           muffled <- TRUE
[16:11:21.783]                           break
[16:11:21.783]                         }
[16:11:21.783]                       }
[16:11:21.783]                     }
[16:11:21.783]                     invisible(muffled)
[16:11:21.783]                   }
[16:11:21.783]                   muffleCondition(cond)
[16:11:21.783]                 })
[16:11:21.783]             }))
[16:11:21.783]             future::FutureResult(value = ...future.value$value, 
[16:11:21.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:21.783]                   ...future.rng), globalenv = if (FALSE) 
[16:11:21.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:21.783]                     ...future.globalenv.names))
[16:11:21.783]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:21.783]         }, condition = base::local({
[16:11:21.783]             c <- base::c
[16:11:21.783]             inherits <- base::inherits
[16:11:21.783]             invokeRestart <- base::invokeRestart
[16:11:21.783]             length <- base::length
[16:11:21.783]             list <- base::list
[16:11:21.783]             seq.int <- base::seq.int
[16:11:21.783]             signalCondition <- base::signalCondition
[16:11:21.783]             sys.calls <- base::sys.calls
[16:11:21.783]             `[[` <- base::`[[`
[16:11:21.783]             `+` <- base::`+`
[16:11:21.783]             `<<-` <- base::`<<-`
[16:11:21.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:21.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:21.783]                   3L)]
[16:11:21.783]             }
[16:11:21.783]             function(cond) {
[16:11:21.783]                 is_error <- inherits(cond, "error")
[16:11:21.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:21.783]                   NULL)
[16:11:21.783]                 if (is_error) {
[16:11:21.783]                   sessionInformation <- function() {
[16:11:21.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:21.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:21.783]                       search = base::search(), system = base::Sys.info())
[16:11:21.783]                   }
[16:11:21.783]                   ...future.conditions[[length(...future.conditions) + 
[16:11:21.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:21.783]                     cond$call), session = sessionInformation(), 
[16:11:21.783]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:21.783]                   signalCondition(cond)
[16:11:21.783]                 }
[16:11:21.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:21.783]                 "immediateCondition"))) {
[16:11:21.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:21.783]                   ...future.conditions[[length(...future.conditions) + 
[16:11:21.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:21.783]                   if (TRUE && !signal) {
[16:11:21.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:21.783]                     {
[16:11:21.783]                       inherits <- base::inherits
[16:11:21.783]                       invokeRestart <- base::invokeRestart
[16:11:21.783]                       is.null <- base::is.null
[16:11:21.783]                       muffled <- FALSE
[16:11:21.783]                       if (inherits(cond, "message")) {
[16:11:21.783]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:21.783]                         if (muffled) 
[16:11:21.783]                           invokeRestart("muffleMessage")
[16:11:21.783]                       }
[16:11:21.783]                       else if (inherits(cond, "warning")) {
[16:11:21.783]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:21.783]                         if (muffled) 
[16:11:21.783]                           invokeRestart("muffleWarning")
[16:11:21.783]                       }
[16:11:21.783]                       else if (inherits(cond, "condition")) {
[16:11:21.783]                         if (!is.null(pattern)) {
[16:11:21.783]                           computeRestarts <- base::computeRestarts
[16:11:21.783]                           grepl <- base::grepl
[16:11:21.783]                           restarts <- computeRestarts(cond)
[16:11:21.783]                           for (restart in restarts) {
[16:11:21.783]                             name <- restart$name
[16:11:21.783]                             if (is.null(name)) 
[16:11:21.783]                               next
[16:11:21.783]                             if (!grepl(pattern, name)) 
[16:11:21.783]                               next
[16:11:21.783]                             invokeRestart(restart)
[16:11:21.783]                             muffled <- TRUE
[16:11:21.783]                             break
[16:11:21.783]                           }
[16:11:21.783]                         }
[16:11:21.783]                       }
[16:11:21.783]                       invisible(muffled)
[16:11:21.783]                     }
[16:11:21.783]                     muffleCondition(cond, pattern = "^muffle")
[16:11:21.783]                   }
[16:11:21.783]                 }
[16:11:21.783]                 else {
[16:11:21.783]                   if (TRUE) {
[16:11:21.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:21.783]                     {
[16:11:21.783]                       inherits <- base::inherits
[16:11:21.783]                       invokeRestart <- base::invokeRestart
[16:11:21.783]                       is.null <- base::is.null
[16:11:21.783]                       muffled <- FALSE
[16:11:21.783]                       if (inherits(cond, "message")) {
[16:11:21.783]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:21.783]                         if (muffled) 
[16:11:21.783]                           invokeRestart("muffleMessage")
[16:11:21.783]                       }
[16:11:21.783]                       else if (inherits(cond, "warning")) {
[16:11:21.783]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:21.783]                         if (muffled) 
[16:11:21.783]                           invokeRestart("muffleWarning")
[16:11:21.783]                       }
[16:11:21.783]                       else if (inherits(cond, "condition")) {
[16:11:21.783]                         if (!is.null(pattern)) {
[16:11:21.783]                           computeRestarts <- base::computeRestarts
[16:11:21.783]                           grepl <- base::grepl
[16:11:21.783]                           restarts <- computeRestarts(cond)
[16:11:21.783]                           for (restart in restarts) {
[16:11:21.783]                             name <- restart$name
[16:11:21.783]                             if (is.null(name)) 
[16:11:21.783]                               next
[16:11:21.783]                             if (!grepl(pattern, name)) 
[16:11:21.783]                               next
[16:11:21.783]                             invokeRestart(restart)
[16:11:21.783]                             muffled <- TRUE
[16:11:21.783]                             break
[16:11:21.783]                           }
[16:11:21.783]                         }
[16:11:21.783]                       }
[16:11:21.783]                       invisible(muffled)
[16:11:21.783]                     }
[16:11:21.783]                     muffleCondition(cond, pattern = "^muffle")
[16:11:21.783]                   }
[16:11:21.783]                 }
[16:11:21.783]             }
[16:11:21.783]         }))
[16:11:21.783]     }, error = function(ex) {
[16:11:21.783]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:21.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:21.783]                 ...future.rng), started = ...future.startTime, 
[16:11:21.783]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:21.783]             version = "1.8"), class = "FutureResult")
[16:11:21.783]     }, finally = {
[16:11:21.783]         if (!identical(...future.workdir, getwd())) 
[16:11:21.783]             setwd(...future.workdir)
[16:11:21.783]         {
[16:11:21.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:21.783]                 ...future.oldOptions$nwarnings <- NULL
[16:11:21.783]             }
[16:11:21.783]             base::options(...future.oldOptions)
[16:11:21.783]             if (.Platform$OS.type == "windows") {
[16:11:21.783]                 old_names <- names(...future.oldEnvVars)
[16:11:21.783]                 envs <- base::Sys.getenv()
[16:11:21.783]                 names <- names(envs)
[16:11:21.783]                 common <- intersect(names, old_names)
[16:11:21.783]                 added <- setdiff(names, old_names)
[16:11:21.783]                 removed <- setdiff(old_names, names)
[16:11:21.783]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:21.783]                   envs[common]]
[16:11:21.783]                 NAMES <- toupper(changed)
[16:11:21.783]                 args <- list()
[16:11:21.783]                 for (kk in seq_along(NAMES)) {
[16:11:21.783]                   name <- changed[[kk]]
[16:11:21.783]                   NAME <- NAMES[[kk]]
[16:11:21.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.783]                     next
[16:11:21.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:21.783]                 }
[16:11:21.783]                 NAMES <- toupper(added)
[16:11:21.783]                 for (kk in seq_along(NAMES)) {
[16:11:21.783]                   name <- added[[kk]]
[16:11:21.783]                   NAME <- NAMES[[kk]]
[16:11:21.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.783]                     next
[16:11:21.783]                   args[[name]] <- ""
[16:11:21.783]                 }
[16:11:21.783]                 NAMES <- toupper(removed)
[16:11:21.783]                 for (kk in seq_along(NAMES)) {
[16:11:21.783]                   name <- removed[[kk]]
[16:11:21.783]                   NAME <- NAMES[[kk]]
[16:11:21.783]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.783]                     next
[16:11:21.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:21.783]                 }
[16:11:21.783]                 if (length(args) > 0) 
[16:11:21.783]                   base::do.call(base::Sys.setenv, args = args)
[16:11:21.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:21.783]             }
[16:11:21.783]             else {
[16:11:21.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:21.783]             }
[16:11:21.783]             {
[16:11:21.783]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:21.783]                   0L) {
[16:11:21.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:21.783]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:21.783]                   base::options(opts)
[16:11:21.783]                 }
[16:11:21.783]                 {
[16:11:21.783]                   {
[16:11:21.783]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:21.783]                     NULL
[16:11:21.783]                   }
[16:11:21.783]                   options(future.plan = NULL)
[16:11:21.783]                   if (is.na(NA_character_)) 
[16:11:21.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:21.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:21.783]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:21.783]                     envir = parent.frame()) 
[16:11:21.783]                   {
[16:11:21.783]                     default_workers <- missing(workers)
[16:11:21.783]                     if (is.function(workers)) 
[16:11:21.783]                       workers <- workers()
[16:11:21.783]                     workers <- structure(as.integer(workers), 
[16:11:21.783]                       class = class(workers))
[16:11:21.783]                     stop_if_not(is.finite(workers), workers >= 
[16:11:21.783]                       1L)
[16:11:21.783]                     if ((workers == 1L && !inherits(workers, 
[16:11:21.783]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:21.783]                       if (default_workers) 
[16:11:21.783]                         supportsMulticore(warn = TRUE)
[16:11:21.783]                       return(sequential(..., envir = envir))
[16:11:21.783]                     }
[16:11:21.783]                     oopts <- options(mc.cores = workers)
[16:11:21.783]                     on.exit(options(oopts))
[16:11:21.783]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:21.783]                       envir = envir)
[16:11:21.783]                     if (!future$lazy) 
[16:11:21.783]                       future <- run(future)
[16:11:21.783]                     invisible(future)
[16:11:21.783]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:21.783]                 }
[16:11:21.783]             }
[16:11:21.783]         }
[16:11:21.783]     })
[16:11:21.783]     if (TRUE) {
[16:11:21.783]         base::sink(type = "output", split = FALSE)
[16:11:21.783]         if (FALSE) {
[16:11:21.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:21.783]         }
[16:11:21.783]         else {
[16:11:21.783]             ...future.result["stdout"] <- base::list(NULL)
[16:11:21.783]         }
[16:11:21.783]         base::close(...future.stdout)
[16:11:21.783]         ...future.stdout <- NULL
[16:11:21.783]     }
[16:11:21.783]     ...future.result$conditions <- ...future.conditions
[16:11:21.783]     ...future.result$finished <- base::Sys.time()
[16:11:21.783]     ...future.result
[16:11:21.783] }
[16:11:21.785] assign_globals() ...
[16:11:21.785] List of 5
[16:11:21.785]  $ ...future.FUN            :function (x)  
[16:11:21.785]  $ future.call.arguments    : list()
[16:11:21.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:21.785]  $ ...future.elements_ii    :List of 1
[16:11:21.785]   ..$ : int 1
[16:11:21.785]  $ ...future.seeds_ii       : NULL
[16:11:21.785]  $ ...future.globals.maxSize: NULL
[16:11:21.785]  - attr(*, "where")=List of 5
[16:11:21.785]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:21.785]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:21.785]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:21.785]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:21.785]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:21.785]  - attr(*, "resolved")= logi FALSE
[16:11:21.785]  - attr(*, "total_size")= num 4720
[16:11:21.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:21.785]  - attr(*, "already-done")= logi TRUE
[16:11:21.790] - reassign environment for ‘...future.FUN’
[16:11:21.790] - copied ‘...future.FUN’ to environment
[16:11:21.790] - copied ‘future.call.arguments’ to environment
[16:11:21.790] - copied ‘...future.elements_ii’ to environment
[16:11:21.790] - copied ‘...future.seeds_ii’ to environment
[16:11:21.791] - copied ‘...future.globals.maxSize’ to environment
[16:11:21.791] assign_globals() ... done
[16:11:21.791] requestCore(): workers = 2
[16:11:21.794] MulticoreFuture started
[16:11:21.794] - Launch lazy future ... done
[16:11:21.795] plan(): Setting new future strategy stack:
[16:11:21.795] run() for ‘MulticoreFuture’ ... done
[16:11:21.795] Created future:
[16:11:21.795] List of future strategies:
[16:11:21.795] 1. sequential:
[16:11:21.795]    - args: function (..., envir = parent.frame())
[16:11:21.795]    - tweaked: FALSE
[16:11:21.795]    - call: NULL
[16:11:21.796] plan(): nbrOfWorkers() = 1
[16:11:21.795] MulticoreFuture:
[16:11:21.795] Label: ‘future_lapply-1’
[16:11:21.795] Expression:
[16:11:21.795] {
[16:11:21.795]     do.call(function(...) {
[16:11:21.795]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.795]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:21.795]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.795]             on.exit(options(oopts), add = TRUE)
[16:11:21.795]         }
[16:11:21.795]         {
[16:11:21.795]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:21.795]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:21.795]                 ...future.FUN(...future.X_jj, ...)
[16:11:21.795]             })
[16:11:21.795]         }
[16:11:21.795]     }, args = future.call.arguments)
[16:11:21.795] }
[16:11:21.795] Lazy evaluation: FALSE
[16:11:21.795] Asynchronous evaluation: TRUE
[16:11:21.795] Local evaluation: TRUE
[16:11:21.795] Environment: R_GlobalEnv
[16:11:21.795] Capture standard output: FALSE
[16:11:21.795] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:21.795] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:21.795] Packages: <none>
[16:11:21.795] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:21.795] Resolved: FALSE
[16:11:21.795] Value: <not collected>
[16:11:21.795] Conditions captured: <none>
[16:11:21.795] Early signaling: FALSE
[16:11:21.795] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:21.795] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:21.811] Chunk #1 of 2 ... DONE
[16:11:21.811] Chunk #2 of 2 ...
[16:11:21.811]  - Finding globals in 'X' for chunk #2 ...
[16:11:21.811] getGlobalsAndPackages() ...
[16:11:21.812] Searching for globals...
[16:11:21.812] 
[16:11:21.812] Searching for globals ... DONE
[16:11:21.813] - globals: [0] <none>
[16:11:21.813] getGlobalsAndPackages() ... DONE
[16:11:21.813]    + additional globals found: [n=0] 
[16:11:21.813]    + additional namespaces needed: [n=0] 
[16:11:21.813]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:21.813]  - seeds: <none>
[16:11:21.814] getGlobalsAndPackages() ...
[16:11:21.814] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:21.814] Resolving globals: FALSE
[16:11:21.814] Tweak future expression to call with '...' arguments ...
[16:11:21.814] {
[16:11:21.814]     do.call(function(...) {
[16:11:21.814]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.814]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:21.814]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.814]             on.exit(options(oopts), add = TRUE)
[16:11:21.814]         }
[16:11:21.814]         {
[16:11:21.814]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:21.814]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:21.814]                 ...future.FUN(...future.X_jj, ...)
[16:11:21.814]             })
[16:11:21.814]         }
[16:11:21.814]     }, args = future.call.arguments)
[16:11:21.814] }
[16:11:21.815] Tweak future expression to call with '...' arguments ... DONE
[16:11:21.816] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:21.816] 
[16:11:21.816] getGlobalsAndPackages() ... DONE
[16:11:21.817] run() for ‘Future’ ...
[16:11:21.817] - state: ‘created’
[16:11:21.817] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:21.822] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:21.822] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:21.823]   - Field: ‘label’
[16:11:21.823]   - Field: ‘local’
[16:11:21.823]   - Field: ‘owner’
[16:11:21.823]   - Field: ‘envir’
[16:11:21.823]   - Field: ‘workers’
[16:11:21.824]   - Field: ‘packages’
[16:11:21.824]   - Field: ‘gc’
[16:11:21.824]   - Field: ‘job’
[16:11:21.824]   - Field: ‘conditions’
[16:11:21.824]   - Field: ‘expr’
[16:11:21.825]   - Field: ‘uuid’
[16:11:21.825]   - Field: ‘seed’
[16:11:21.825]   - Field: ‘version’
[16:11:21.825]   - Field: ‘result’
[16:11:21.825]   - Field: ‘asynchronous’
[16:11:21.825]   - Field: ‘calls’
[16:11:21.826]   - Field: ‘globals’
[16:11:21.826]   - Field: ‘stdout’
[16:11:21.826]   - Field: ‘earlySignal’
[16:11:21.826]   - Field: ‘lazy’
[16:11:21.826]   - Field: ‘state’
[16:11:21.826] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:21.827] - Launch lazy future ...
[16:11:21.827] Packages needed by the future expression (n = 0): <none>
[16:11:21.827] Packages needed by future strategies (n = 0): <none>
[16:11:21.828] {
[16:11:21.828]     {
[16:11:21.828]         {
[16:11:21.828]             ...future.startTime <- base::Sys.time()
[16:11:21.828]             {
[16:11:21.828]                 {
[16:11:21.828]                   {
[16:11:21.828]                     {
[16:11:21.828]                       base::local({
[16:11:21.828]                         has_future <- base::requireNamespace("future", 
[16:11:21.828]                           quietly = TRUE)
[16:11:21.828]                         if (has_future) {
[16:11:21.828]                           ns <- base::getNamespace("future")
[16:11:21.828]                           version <- ns[[".package"]][["version"]]
[16:11:21.828]                           if (is.null(version)) 
[16:11:21.828]                             version <- utils::packageVersion("future")
[16:11:21.828]                         }
[16:11:21.828]                         else {
[16:11:21.828]                           version <- NULL
[16:11:21.828]                         }
[16:11:21.828]                         if (!has_future || version < "1.8.0") {
[16:11:21.828]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:21.828]                             "", base::R.version$version.string), 
[16:11:21.828]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:21.828]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:21.828]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:21.828]                               "release", "version")], collapse = " "), 
[16:11:21.828]                             hostname = base::Sys.info()[["nodename"]])
[16:11:21.828]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:21.828]                             info)
[16:11:21.828]                           info <- base::paste(info, collapse = "; ")
[16:11:21.828]                           if (!has_future) {
[16:11:21.828]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:21.828]                               info)
[16:11:21.828]                           }
[16:11:21.828]                           else {
[16:11:21.828]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:21.828]                               info, version)
[16:11:21.828]                           }
[16:11:21.828]                           base::stop(msg)
[16:11:21.828]                         }
[16:11:21.828]                       })
[16:11:21.828]                     }
[16:11:21.828]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:21.828]                     base::options(mc.cores = 1L)
[16:11:21.828]                   }
[16:11:21.828]                   options(future.plan = NULL)
[16:11:21.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:21.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:21.828]                 }
[16:11:21.828]                 ...future.workdir <- getwd()
[16:11:21.828]             }
[16:11:21.828]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:21.828]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:21.828]         }
[16:11:21.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:21.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:21.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:21.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:21.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:21.828]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:21.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:21.828]             base::names(...future.oldOptions))
[16:11:21.828]     }
[16:11:21.828]     if (FALSE) {
[16:11:21.828]     }
[16:11:21.828]     else {
[16:11:21.828]         if (FALSE) {
[16:11:21.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:21.828]                 open = "w")
[16:11:21.828]         }
[16:11:21.828]         else {
[16:11:21.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:21.828]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:21.828]         }
[16:11:21.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:21.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:21.828]             base::sink(type = "output", split = FALSE)
[16:11:21.828]             base::close(...future.stdout)
[16:11:21.828]         }, add = TRUE)
[16:11:21.828]     }
[16:11:21.828]     ...future.frame <- base::sys.nframe()
[16:11:21.828]     ...future.conditions <- base::list()
[16:11:21.828]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:21.828]     if (FALSE) {
[16:11:21.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:21.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:21.828]     }
[16:11:21.828]     ...future.result <- base::tryCatch({
[16:11:21.828]         base::withCallingHandlers({
[16:11:21.828]             ...future.value <- base::withVisible(base::local({
[16:11:21.828]                 withCallingHandlers({
[16:11:21.828]                   {
[16:11:21.828]                     do.call(function(...) {
[16:11:21.828]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.828]                       if (!identical(...future.globals.maxSize.org, 
[16:11:21.828]                         ...future.globals.maxSize)) {
[16:11:21.828]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.828]                         on.exit(options(oopts), add = TRUE)
[16:11:21.828]                       }
[16:11:21.828]                       {
[16:11:21.828]                         lapply(seq_along(...future.elements_ii), 
[16:11:21.828]                           FUN = function(jj) {
[16:11:21.828]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:21.828]                             ...future.FUN(...future.X_jj, ...)
[16:11:21.828]                           })
[16:11:21.828]                       }
[16:11:21.828]                     }, args = future.call.arguments)
[16:11:21.828]                   }
[16:11:21.828]                 }, immediateCondition = function(cond) {
[16:11:21.828]                   save_rds <- function (object, pathname, ...) 
[16:11:21.828]                   {
[16:11:21.828]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:21.828]                     if (file_test("-f", pathname_tmp)) {
[16:11:21.828]                       fi_tmp <- file.info(pathname_tmp)
[16:11:21.828]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:21.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:21.828]                         fi_tmp[["mtime"]])
[16:11:21.828]                     }
[16:11:21.828]                     tryCatch({
[16:11:21.828]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:21.828]                     }, error = function(ex) {
[16:11:21.828]                       msg <- conditionMessage(ex)
[16:11:21.828]                       fi_tmp <- file.info(pathname_tmp)
[16:11:21.828]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:21.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:21.828]                         fi_tmp[["mtime"]], msg)
[16:11:21.828]                       ex$message <- msg
[16:11:21.828]                       stop(ex)
[16:11:21.828]                     })
[16:11:21.828]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:21.828]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:21.828]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:21.828]                       fi_tmp <- file.info(pathname_tmp)
[16:11:21.828]                       fi <- file.info(pathname)
[16:11:21.828]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:21.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:21.828]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:21.828]                         fi[["size"]], fi[["mtime"]])
[16:11:21.828]                       stop(msg)
[16:11:21.828]                     }
[16:11:21.828]                     invisible(pathname)
[16:11:21.828]                   }
[16:11:21.828]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:21.828]                     rootPath = tempdir()) 
[16:11:21.828]                   {
[16:11:21.828]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:21.828]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:21.828]                       tmpdir = path, fileext = ".rds")
[16:11:21.828]                     save_rds(obj, file)
[16:11:21.828]                   }
[16:11:21.828]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:21.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:21.828]                   {
[16:11:21.828]                     inherits <- base::inherits
[16:11:21.828]                     invokeRestart <- base::invokeRestart
[16:11:21.828]                     is.null <- base::is.null
[16:11:21.828]                     muffled <- FALSE
[16:11:21.828]                     if (inherits(cond, "message")) {
[16:11:21.828]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:21.828]                       if (muffled) 
[16:11:21.828]                         invokeRestart("muffleMessage")
[16:11:21.828]                     }
[16:11:21.828]                     else if (inherits(cond, "warning")) {
[16:11:21.828]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:21.828]                       if (muffled) 
[16:11:21.828]                         invokeRestart("muffleWarning")
[16:11:21.828]                     }
[16:11:21.828]                     else if (inherits(cond, "condition")) {
[16:11:21.828]                       if (!is.null(pattern)) {
[16:11:21.828]                         computeRestarts <- base::computeRestarts
[16:11:21.828]                         grepl <- base::grepl
[16:11:21.828]                         restarts <- computeRestarts(cond)
[16:11:21.828]                         for (restart in restarts) {
[16:11:21.828]                           name <- restart$name
[16:11:21.828]                           if (is.null(name)) 
[16:11:21.828]                             next
[16:11:21.828]                           if (!grepl(pattern, name)) 
[16:11:21.828]                             next
[16:11:21.828]                           invokeRestart(restart)
[16:11:21.828]                           muffled <- TRUE
[16:11:21.828]                           break
[16:11:21.828]                         }
[16:11:21.828]                       }
[16:11:21.828]                     }
[16:11:21.828]                     invisible(muffled)
[16:11:21.828]                   }
[16:11:21.828]                   muffleCondition(cond)
[16:11:21.828]                 })
[16:11:21.828]             }))
[16:11:21.828]             future::FutureResult(value = ...future.value$value, 
[16:11:21.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:21.828]                   ...future.rng), globalenv = if (FALSE) 
[16:11:21.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:21.828]                     ...future.globalenv.names))
[16:11:21.828]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:21.828]         }, condition = base::local({
[16:11:21.828]             c <- base::c
[16:11:21.828]             inherits <- base::inherits
[16:11:21.828]             invokeRestart <- base::invokeRestart
[16:11:21.828]             length <- base::length
[16:11:21.828]             list <- base::list
[16:11:21.828]             seq.int <- base::seq.int
[16:11:21.828]             signalCondition <- base::signalCondition
[16:11:21.828]             sys.calls <- base::sys.calls
[16:11:21.828]             `[[` <- base::`[[`
[16:11:21.828]             `+` <- base::`+`
[16:11:21.828]             `<<-` <- base::`<<-`
[16:11:21.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:21.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:21.828]                   3L)]
[16:11:21.828]             }
[16:11:21.828]             function(cond) {
[16:11:21.828]                 is_error <- inherits(cond, "error")
[16:11:21.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:21.828]                   NULL)
[16:11:21.828]                 if (is_error) {
[16:11:21.828]                   sessionInformation <- function() {
[16:11:21.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:21.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:21.828]                       search = base::search(), system = base::Sys.info())
[16:11:21.828]                   }
[16:11:21.828]                   ...future.conditions[[length(...future.conditions) + 
[16:11:21.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:21.828]                     cond$call), session = sessionInformation(), 
[16:11:21.828]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:21.828]                   signalCondition(cond)
[16:11:21.828]                 }
[16:11:21.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:21.828]                 "immediateCondition"))) {
[16:11:21.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:21.828]                   ...future.conditions[[length(...future.conditions) + 
[16:11:21.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:21.828]                   if (TRUE && !signal) {
[16:11:21.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:21.828]                     {
[16:11:21.828]                       inherits <- base::inherits
[16:11:21.828]                       invokeRestart <- base::invokeRestart
[16:11:21.828]                       is.null <- base::is.null
[16:11:21.828]                       muffled <- FALSE
[16:11:21.828]                       if (inherits(cond, "message")) {
[16:11:21.828]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:21.828]                         if (muffled) 
[16:11:21.828]                           invokeRestart("muffleMessage")
[16:11:21.828]                       }
[16:11:21.828]                       else if (inherits(cond, "warning")) {
[16:11:21.828]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:21.828]                         if (muffled) 
[16:11:21.828]                           invokeRestart("muffleWarning")
[16:11:21.828]                       }
[16:11:21.828]                       else if (inherits(cond, "condition")) {
[16:11:21.828]                         if (!is.null(pattern)) {
[16:11:21.828]                           computeRestarts <- base::computeRestarts
[16:11:21.828]                           grepl <- base::grepl
[16:11:21.828]                           restarts <- computeRestarts(cond)
[16:11:21.828]                           for (restart in restarts) {
[16:11:21.828]                             name <- restart$name
[16:11:21.828]                             if (is.null(name)) 
[16:11:21.828]                               next
[16:11:21.828]                             if (!grepl(pattern, name)) 
[16:11:21.828]                               next
[16:11:21.828]                             invokeRestart(restart)
[16:11:21.828]                             muffled <- TRUE
[16:11:21.828]                             break
[16:11:21.828]                           }
[16:11:21.828]                         }
[16:11:21.828]                       }
[16:11:21.828]                       invisible(muffled)
[16:11:21.828]                     }
[16:11:21.828]                     muffleCondition(cond, pattern = "^muffle")
[16:11:21.828]                   }
[16:11:21.828]                 }
[16:11:21.828]                 else {
[16:11:21.828]                   if (TRUE) {
[16:11:21.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:21.828]                     {
[16:11:21.828]                       inherits <- base::inherits
[16:11:21.828]                       invokeRestart <- base::invokeRestart
[16:11:21.828]                       is.null <- base::is.null
[16:11:21.828]                       muffled <- FALSE
[16:11:21.828]                       if (inherits(cond, "message")) {
[16:11:21.828]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:21.828]                         if (muffled) 
[16:11:21.828]                           invokeRestart("muffleMessage")
[16:11:21.828]                       }
[16:11:21.828]                       else if (inherits(cond, "warning")) {
[16:11:21.828]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:21.828]                         if (muffled) 
[16:11:21.828]                           invokeRestart("muffleWarning")
[16:11:21.828]                       }
[16:11:21.828]                       else if (inherits(cond, "condition")) {
[16:11:21.828]                         if (!is.null(pattern)) {
[16:11:21.828]                           computeRestarts <- base::computeRestarts
[16:11:21.828]                           grepl <- base::grepl
[16:11:21.828]                           restarts <- computeRestarts(cond)
[16:11:21.828]                           for (restart in restarts) {
[16:11:21.828]                             name <- restart$name
[16:11:21.828]                             if (is.null(name)) 
[16:11:21.828]                               next
[16:11:21.828]                             if (!grepl(pattern, name)) 
[16:11:21.828]                               next
[16:11:21.828]                             invokeRestart(restart)
[16:11:21.828]                             muffled <- TRUE
[16:11:21.828]                             break
[16:11:21.828]                           }
[16:11:21.828]                         }
[16:11:21.828]                       }
[16:11:21.828]                       invisible(muffled)
[16:11:21.828]                     }
[16:11:21.828]                     muffleCondition(cond, pattern = "^muffle")
[16:11:21.828]                   }
[16:11:21.828]                 }
[16:11:21.828]             }
[16:11:21.828]         }))
[16:11:21.828]     }, error = function(ex) {
[16:11:21.828]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:21.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:21.828]                 ...future.rng), started = ...future.startTime, 
[16:11:21.828]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:21.828]             version = "1.8"), class = "FutureResult")
[16:11:21.828]     }, finally = {
[16:11:21.828]         if (!identical(...future.workdir, getwd())) 
[16:11:21.828]             setwd(...future.workdir)
[16:11:21.828]         {
[16:11:21.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:21.828]                 ...future.oldOptions$nwarnings <- NULL
[16:11:21.828]             }
[16:11:21.828]             base::options(...future.oldOptions)
[16:11:21.828]             if (.Platform$OS.type == "windows") {
[16:11:21.828]                 old_names <- names(...future.oldEnvVars)
[16:11:21.828]                 envs <- base::Sys.getenv()
[16:11:21.828]                 names <- names(envs)
[16:11:21.828]                 common <- intersect(names, old_names)
[16:11:21.828]                 added <- setdiff(names, old_names)
[16:11:21.828]                 removed <- setdiff(old_names, names)
[16:11:21.828]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:21.828]                   envs[common]]
[16:11:21.828]                 NAMES <- toupper(changed)
[16:11:21.828]                 args <- list()
[16:11:21.828]                 for (kk in seq_along(NAMES)) {
[16:11:21.828]                   name <- changed[[kk]]
[16:11:21.828]                   NAME <- NAMES[[kk]]
[16:11:21.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.828]                     next
[16:11:21.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:21.828]                 }
[16:11:21.828]                 NAMES <- toupper(added)
[16:11:21.828]                 for (kk in seq_along(NAMES)) {
[16:11:21.828]                   name <- added[[kk]]
[16:11:21.828]                   NAME <- NAMES[[kk]]
[16:11:21.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.828]                     next
[16:11:21.828]                   args[[name]] <- ""
[16:11:21.828]                 }
[16:11:21.828]                 NAMES <- toupper(removed)
[16:11:21.828]                 for (kk in seq_along(NAMES)) {
[16:11:21.828]                   name <- removed[[kk]]
[16:11:21.828]                   NAME <- NAMES[[kk]]
[16:11:21.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:21.828]                     next
[16:11:21.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:21.828]                 }
[16:11:21.828]                 if (length(args) > 0) 
[16:11:21.828]                   base::do.call(base::Sys.setenv, args = args)
[16:11:21.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:21.828]             }
[16:11:21.828]             else {
[16:11:21.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:21.828]             }
[16:11:21.828]             {
[16:11:21.828]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:21.828]                   0L) {
[16:11:21.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:21.828]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:21.828]                   base::options(opts)
[16:11:21.828]                 }
[16:11:21.828]                 {
[16:11:21.828]                   {
[16:11:21.828]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:21.828]                     NULL
[16:11:21.828]                   }
[16:11:21.828]                   options(future.plan = NULL)
[16:11:21.828]                   if (is.na(NA_character_)) 
[16:11:21.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:21.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:21.828]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:21.828]                     envir = parent.frame()) 
[16:11:21.828]                   {
[16:11:21.828]                     default_workers <- missing(workers)
[16:11:21.828]                     if (is.function(workers)) 
[16:11:21.828]                       workers <- workers()
[16:11:21.828]                     workers <- structure(as.integer(workers), 
[16:11:21.828]                       class = class(workers))
[16:11:21.828]                     stop_if_not(is.finite(workers), workers >= 
[16:11:21.828]                       1L)
[16:11:21.828]                     if ((workers == 1L && !inherits(workers, 
[16:11:21.828]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:21.828]                       if (default_workers) 
[16:11:21.828]                         supportsMulticore(warn = TRUE)
[16:11:21.828]                       return(sequential(..., envir = envir))
[16:11:21.828]                     }
[16:11:21.828]                     oopts <- options(mc.cores = workers)
[16:11:21.828]                     on.exit(options(oopts))
[16:11:21.828]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:21.828]                       envir = envir)
[16:11:21.828]                     if (!future$lazy) 
[16:11:21.828]                       future <- run(future)
[16:11:21.828]                     invisible(future)
[16:11:21.828]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:21.828]                 }
[16:11:21.828]             }
[16:11:21.828]         }
[16:11:21.828]     })
[16:11:21.828]     if (TRUE) {
[16:11:21.828]         base::sink(type = "output", split = FALSE)
[16:11:21.828]         if (FALSE) {
[16:11:21.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:21.828]         }
[16:11:21.828]         else {
[16:11:21.828]             ...future.result["stdout"] <- base::list(NULL)
[16:11:21.828]         }
[16:11:21.828]         base::close(...future.stdout)
[16:11:21.828]         ...future.stdout <- NULL
[16:11:21.828]     }
[16:11:21.828]     ...future.result$conditions <- ...future.conditions
[16:11:21.828]     ...future.result$finished <- base::Sys.time()
[16:11:21.828]     ...future.result
[16:11:21.828] }
[16:11:21.832] assign_globals() ...
[16:11:21.832] List of 5
[16:11:21.832]  $ ...future.FUN            :function (x)  
[16:11:21.832]  $ future.call.arguments    : list()
[16:11:21.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:21.832]  $ ...future.elements_ii    :List of 1
[16:11:21.832]   ..$ : int 0
[16:11:21.832]  $ ...future.seeds_ii       : NULL
[16:11:21.832]  $ ...future.globals.maxSize: NULL
[16:11:21.832]  - attr(*, "where")=List of 5
[16:11:21.832]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:21.832]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:21.832]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:21.832]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:21.832]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:21.832]  - attr(*, "resolved")= logi FALSE
[16:11:21.832]  - attr(*, "total_size")= num 4720
[16:11:21.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:21.832]  - attr(*, "already-done")= logi TRUE
[16:11:21.847] - reassign environment for ‘...future.FUN’
[16:11:21.847] - copied ‘...future.FUN’ to environment
[16:11:21.847] - copied ‘future.call.arguments’ to environment
[16:11:21.848] - copied ‘...future.elements_ii’ to environment
[16:11:21.848] - copied ‘...future.seeds_ii’ to environment
[16:11:21.848] - copied ‘...future.globals.maxSize’ to environment
[16:11:21.848] assign_globals() ... done
[16:11:21.849] requestCore(): workers = 2
[16:11:21.855] MulticoreFuture started
[16:11:21.855] - Launch lazy future ... done
[16:11:21.856] run() for ‘MulticoreFuture’ ... done
[16:11:21.856] Created future:
[16:11:21.856] plan(): Setting new future strategy stack:
[16:11:21.856] List of future strategies:
[16:11:21.856] 1. sequential:
[16:11:21.856]    - args: function (..., envir = parent.frame())
[16:11:21.856]    - tweaked: FALSE
[16:11:21.856]    - call: NULL
[16:11:21.857] plan(): nbrOfWorkers() = 1
[16:11:21.859] plan(): Setting new future strategy stack:
[16:11:21.860] List of future strategies:
[16:11:21.860] 1. multicore:
[16:11:21.860]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:21.860]    - tweaked: FALSE
[16:11:21.860]    - call: plan(strategy)
[16:11:21.865] plan(): nbrOfWorkers() = 2
[16:11:21.856] MulticoreFuture:
[16:11:21.856] Label: ‘future_lapply-2’
[16:11:21.856] Expression:
[16:11:21.856] {
[16:11:21.856]     do.call(function(...) {
[16:11:21.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:21.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:21.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:21.856]             on.exit(options(oopts), add = TRUE)
[16:11:21.856]         }
[16:11:21.856]         {
[16:11:21.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:21.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:21.856]                 ...future.FUN(...future.X_jj, ...)
[16:11:21.856]             })
[16:11:21.856]         }
[16:11:21.856]     }, args = future.call.arguments)
[16:11:21.856] }
[16:11:21.856] Lazy evaluation: FALSE
[16:11:21.856] Asynchronous evaluation: TRUE
[16:11:21.856] Local evaluation: TRUE
[16:11:21.856] Environment: R_GlobalEnv
[16:11:21.856] Capture standard output: FALSE
[16:11:21.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:21.856] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:21.856] Packages: <none>
[16:11:21.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:21.856] Resolved: TRUE
[16:11:21.856] Value: <not collected>
[16:11:21.856] Conditions captured: <none>
[16:11:21.856] Early signaling: FALSE
[16:11:21.856] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:21.856] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:21.866] Chunk #2 of 2 ... DONE
[16:11:21.866] Launching 2 futures (chunks) ... DONE
[16:11:21.866] Resolving 2 futures (chunks) ...
[16:11:21.866] resolve() on list ...
[16:11:21.867]  recursive: 0
[16:11:21.867]  length: 2
[16:11:21.867] 
[16:11:21.877] Future #2
[16:11:21.880] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:21.880] - nx: 2
[16:11:21.880] - relay: TRUE
[16:11:21.881] - stdout: TRUE
[16:11:21.881] - signal: TRUE
[16:11:21.881] - resignal: FALSE
[16:11:21.881] - force: TRUE
[16:11:21.881] - relayed: [n=2] FALSE, FALSE
[16:11:21.881] - queued futures: [n=2] FALSE, FALSE
[16:11:21.881]  - until=1
[16:11:21.881]  - relaying element #1
[16:11:21.882] - relayed: [n=2] FALSE, FALSE
[16:11:21.882] - queued futures: [n=2] FALSE, TRUE
[16:11:21.882] signalConditionsASAP(NULL, pos=2) ... done
[16:11:21.882]  length: 1 (resolved future 2)
[16:11:22.298] plan(): Setting new future strategy stack:
[16:11:22.299] List of future strategies:
[16:11:22.299] 1. multicore:
[16:11:22.299]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:22.299]    - tweaked: FALSE
[16:11:22.299]    - call: plan(strategy)
[16:11:22.303] plan(): nbrOfWorkers() = 2
[16:11:22.304] Future #1
[16:11:22.305] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:22.305] - nx: 2
[16:11:22.305] - relay: TRUE
[16:11:22.305] - stdout: TRUE
[16:11:22.305] - signal: TRUE
[16:11:22.305] - resignal: FALSE
[16:11:22.305] - force: TRUE
[16:11:22.305] - relayed: [n=2] FALSE, FALSE
[16:11:22.306] - queued futures: [n=2] FALSE, TRUE
[16:11:22.306]  - until=1
[16:11:22.306]  - relaying element #1
[16:11:22.306] - relayed: [n=2] TRUE, FALSE
[16:11:22.306] - queued futures: [n=2] TRUE, TRUE
[16:11:22.306] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:22.306]  length: 0 (resolved future 1)
[16:11:22.307] Relaying remaining futures
[16:11:22.307] signalConditionsASAP(NULL, pos=0) ...
[16:11:22.307] - nx: 2
[16:11:22.307] - relay: TRUE
[16:11:22.307] - stdout: TRUE
[16:11:22.307] - signal: TRUE
[16:11:22.307] - resignal: FALSE
[16:11:22.307] - force: TRUE
[16:11:22.307] - relayed: [n=2] TRUE, FALSE
[16:11:22.307] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:22.308]  - relaying element #2
[16:11:22.308] - relayed: [n=2] TRUE, TRUE
[16:11:22.308] - queued futures: [n=2] TRUE, TRUE
[16:11:22.308] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:11:22.308] resolve() on list ... DONE
[16:11:22.309]  - Number of value chunks collected: 2
[16:11:22.309] Resolving 2 futures (chunks) ... DONE
[16:11:22.309] Reducing values from 2 chunks ...
[16:11:22.309]  - Number of values collected after concatenation: 2
[16:11:22.309]  - Number of values expected: 2
[16:11:22.309] Reducing values from 2 chunks ... DONE
[16:11:22.309] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:11:22.310] future_lapply() ...
[16:11:22.314] Number of chunks: 2
[16:11:22.315] getGlobalsAndPackagesXApply() ...
[16:11:22.315]  - future.globals: TRUE
[16:11:22.315] getGlobalsAndPackages() ...
[16:11:22.315] Searching for globals...
[16:11:22.317] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:22.317] Searching for globals ... DONE
[16:11:22.317] Resolving globals: FALSE
[16:11:22.317] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:22.318] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:22.318] - globals: [1] ‘FUN’
[16:11:22.318] 
[16:11:22.318] getGlobalsAndPackages() ... DONE
[16:11:22.318]  - globals found/used: [n=1] ‘FUN’
[16:11:22.318]  - needed namespaces: [n=0] 
[16:11:22.318] Finding globals ... DONE
[16:11:22.319]  - use_args: TRUE
[16:11:22.320]  - Getting '...' globals ...
[16:11:22.321] resolve() on list ...
[16:11:22.321]  recursive: 0
[16:11:22.321]  length: 1
[16:11:22.321]  elements: ‘...’
[16:11:22.322]  length: 0 (resolved future 1)
[16:11:22.322] resolve() on list ... DONE
[16:11:22.322]    - '...' content: [n=0] 
[16:11:22.322] List of 1
[16:11:22.322]  $ ...: list()
[16:11:22.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:22.322]  - attr(*, "where")=List of 1
[16:11:22.322]   ..$ ...:<environment: 0x557e20ddf618> 
[16:11:22.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:22.322]  - attr(*, "resolved")= logi TRUE
[16:11:22.322]  - attr(*, "total_size")= num NA
[16:11:22.325]  - Getting '...' globals ... DONE
[16:11:22.326] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:22.326] List of 2
[16:11:22.326]  $ ...future.FUN:function (x)  
[16:11:22.326]  $ ...          : list()
[16:11:22.326]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:22.326]  - attr(*, "where")=List of 2
[16:11:22.326]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:22.326]   ..$ ...          :<environment: 0x557e20ddf618> 
[16:11:22.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:22.326]  - attr(*, "resolved")= logi FALSE
[16:11:22.326]  - attr(*, "total_size")= num 4720
[16:11:22.329] Packages to be attached in all futures: [n=0] 
[16:11:22.329] getGlobalsAndPackagesXApply() ... DONE
[16:11:22.329] Number of futures (= number of chunks): 2
[16:11:22.329] Launching 2 futures (chunks) ...
[16:11:22.329] Chunk #1 of 2 ...
[16:11:22.330]  - Finding globals in 'X' for chunk #1 ...
[16:11:22.330] getGlobalsAndPackages() ...
[16:11:22.330] Searching for globals...
[16:11:22.330] 
[16:11:22.330] Searching for globals ... DONE
[16:11:22.330] - globals: [0] <none>
[16:11:22.330] getGlobalsAndPackages() ... DONE
[16:11:22.330]    + additional globals found: [n=0] 
[16:11:22.330]    + additional namespaces needed: [n=0] 
[16:11:22.331]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:22.331]  - seeds: <none>
[16:11:22.331] getGlobalsAndPackages() ...
[16:11:22.331] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:22.331] Resolving globals: FALSE
[16:11:22.331] Tweak future expression to call with '...' arguments ...
[16:11:22.331] {
[16:11:22.331]     do.call(function(...) {
[16:11:22.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:22.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.331]             on.exit(options(oopts), add = TRUE)
[16:11:22.331]         }
[16:11:22.331]         {
[16:11:22.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:22.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.331]                 ...future.FUN(...future.X_jj, ...)
[16:11:22.331]             })
[16:11:22.331]         }
[16:11:22.331]     }, args = future.call.arguments)
[16:11:22.331] }
[16:11:22.331] Tweak future expression to call with '...' arguments ... DONE
[16:11:22.332] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:22.332] 
[16:11:22.332] getGlobalsAndPackages() ... DONE
[16:11:22.332] run() for ‘Future’ ...
[16:11:22.332] - state: ‘created’
[16:11:22.333] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:22.336] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:22.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:22.336]   - Field: ‘label’
[16:11:22.336]   - Field: ‘local’
[16:11:22.336]   - Field: ‘owner’
[16:11:22.336]   - Field: ‘envir’
[16:11:22.337]   - Field: ‘workers’
[16:11:22.337]   - Field: ‘packages’
[16:11:22.337]   - Field: ‘gc’
[16:11:22.337]   - Field: ‘job’
[16:11:22.337]   - Field: ‘conditions’
[16:11:22.337]   - Field: ‘expr’
[16:11:22.337]   - Field: ‘uuid’
[16:11:22.337]   - Field: ‘seed’
[16:11:22.337]   - Field: ‘version’
[16:11:22.337]   - Field: ‘result’
[16:11:22.337]   - Field: ‘asynchronous’
[16:11:22.338]   - Field: ‘calls’
[16:11:22.338]   - Field: ‘globals’
[16:11:22.338]   - Field: ‘stdout’
[16:11:22.338]   - Field: ‘earlySignal’
[16:11:22.338]   - Field: ‘lazy’
[16:11:22.338]   - Field: ‘state’
[16:11:22.338] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:22.338] - Launch lazy future ...
[16:11:22.338] Packages needed by the future expression (n = 0): <none>
[16:11:22.339] Packages needed by future strategies (n = 0): <none>
[16:11:22.339] {
[16:11:22.339]     {
[16:11:22.339]         {
[16:11:22.339]             ...future.startTime <- base::Sys.time()
[16:11:22.339]             {
[16:11:22.339]                 {
[16:11:22.339]                   {
[16:11:22.339]                     {
[16:11:22.339]                       base::local({
[16:11:22.339]                         has_future <- base::requireNamespace("future", 
[16:11:22.339]                           quietly = TRUE)
[16:11:22.339]                         if (has_future) {
[16:11:22.339]                           ns <- base::getNamespace("future")
[16:11:22.339]                           version <- ns[[".package"]][["version"]]
[16:11:22.339]                           if (is.null(version)) 
[16:11:22.339]                             version <- utils::packageVersion("future")
[16:11:22.339]                         }
[16:11:22.339]                         else {
[16:11:22.339]                           version <- NULL
[16:11:22.339]                         }
[16:11:22.339]                         if (!has_future || version < "1.8.0") {
[16:11:22.339]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:22.339]                             "", base::R.version$version.string), 
[16:11:22.339]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:22.339]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:22.339]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:22.339]                               "release", "version")], collapse = " "), 
[16:11:22.339]                             hostname = base::Sys.info()[["nodename"]])
[16:11:22.339]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:22.339]                             info)
[16:11:22.339]                           info <- base::paste(info, collapse = "; ")
[16:11:22.339]                           if (!has_future) {
[16:11:22.339]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:22.339]                               info)
[16:11:22.339]                           }
[16:11:22.339]                           else {
[16:11:22.339]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:22.339]                               info, version)
[16:11:22.339]                           }
[16:11:22.339]                           base::stop(msg)
[16:11:22.339]                         }
[16:11:22.339]                       })
[16:11:22.339]                     }
[16:11:22.339]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:22.339]                     base::options(mc.cores = 1L)
[16:11:22.339]                   }
[16:11:22.339]                   options(future.plan = NULL)
[16:11:22.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:22.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:22.339]                 }
[16:11:22.339]                 ...future.workdir <- getwd()
[16:11:22.339]             }
[16:11:22.339]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:22.339]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:22.339]         }
[16:11:22.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:22.339]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:22.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:22.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:22.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:22.339]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:22.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:22.339]             base::names(...future.oldOptions))
[16:11:22.339]     }
[16:11:22.339]     if (FALSE) {
[16:11:22.339]     }
[16:11:22.339]     else {
[16:11:22.339]         if (TRUE) {
[16:11:22.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:22.339]                 open = "w")
[16:11:22.339]         }
[16:11:22.339]         else {
[16:11:22.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:22.339]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:22.339]         }
[16:11:22.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:22.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:22.339]             base::sink(type = "output", split = FALSE)
[16:11:22.339]             base::close(...future.stdout)
[16:11:22.339]         }, add = TRUE)
[16:11:22.339]     }
[16:11:22.339]     ...future.frame <- base::sys.nframe()
[16:11:22.339]     ...future.conditions <- base::list()
[16:11:22.339]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:22.339]     if (FALSE) {
[16:11:22.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:22.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:22.339]     }
[16:11:22.339]     ...future.result <- base::tryCatch({
[16:11:22.339]         base::withCallingHandlers({
[16:11:22.339]             ...future.value <- base::withVisible(base::local({
[16:11:22.339]                 withCallingHandlers({
[16:11:22.339]                   {
[16:11:22.339]                     do.call(function(...) {
[16:11:22.339]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.339]                       if (!identical(...future.globals.maxSize.org, 
[16:11:22.339]                         ...future.globals.maxSize)) {
[16:11:22.339]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.339]                         on.exit(options(oopts), add = TRUE)
[16:11:22.339]                       }
[16:11:22.339]                       {
[16:11:22.339]                         lapply(seq_along(...future.elements_ii), 
[16:11:22.339]                           FUN = function(jj) {
[16:11:22.339]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.339]                             ...future.FUN(...future.X_jj, ...)
[16:11:22.339]                           })
[16:11:22.339]                       }
[16:11:22.339]                     }, args = future.call.arguments)
[16:11:22.339]                   }
[16:11:22.339]                 }, immediateCondition = function(cond) {
[16:11:22.339]                   save_rds <- function (object, pathname, ...) 
[16:11:22.339]                   {
[16:11:22.339]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:22.339]                     if (file_test("-f", pathname_tmp)) {
[16:11:22.339]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.339]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:22.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.339]                         fi_tmp[["mtime"]])
[16:11:22.339]                     }
[16:11:22.339]                     tryCatch({
[16:11:22.339]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:22.339]                     }, error = function(ex) {
[16:11:22.339]                       msg <- conditionMessage(ex)
[16:11:22.339]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.339]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:22.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.339]                         fi_tmp[["mtime"]], msg)
[16:11:22.339]                       ex$message <- msg
[16:11:22.339]                       stop(ex)
[16:11:22.339]                     })
[16:11:22.339]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:22.339]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:22.339]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:22.339]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.339]                       fi <- file.info(pathname)
[16:11:22.339]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:22.339]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.339]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:22.339]                         fi[["size"]], fi[["mtime"]])
[16:11:22.339]                       stop(msg)
[16:11:22.339]                     }
[16:11:22.339]                     invisible(pathname)
[16:11:22.339]                   }
[16:11:22.339]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:22.339]                     rootPath = tempdir()) 
[16:11:22.339]                   {
[16:11:22.339]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:22.339]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:22.339]                       tmpdir = path, fileext = ".rds")
[16:11:22.339]                     save_rds(obj, file)
[16:11:22.339]                   }
[16:11:22.339]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:22.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.339]                   {
[16:11:22.339]                     inherits <- base::inherits
[16:11:22.339]                     invokeRestart <- base::invokeRestart
[16:11:22.339]                     is.null <- base::is.null
[16:11:22.339]                     muffled <- FALSE
[16:11:22.339]                     if (inherits(cond, "message")) {
[16:11:22.339]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:22.339]                       if (muffled) 
[16:11:22.339]                         invokeRestart("muffleMessage")
[16:11:22.339]                     }
[16:11:22.339]                     else if (inherits(cond, "warning")) {
[16:11:22.339]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:22.339]                       if (muffled) 
[16:11:22.339]                         invokeRestart("muffleWarning")
[16:11:22.339]                     }
[16:11:22.339]                     else if (inherits(cond, "condition")) {
[16:11:22.339]                       if (!is.null(pattern)) {
[16:11:22.339]                         computeRestarts <- base::computeRestarts
[16:11:22.339]                         grepl <- base::grepl
[16:11:22.339]                         restarts <- computeRestarts(cond)
[16:11:22.339]                         for (restart in restarts) {
[16:11:22.339]                           name <- restart$name
[16:11:22.339]                           if (is.null(name)) 
[16:11:22.339]                             next
[16:11:22.339]                           if (!grepl(pattern, name)) 
[16:11:22.339]                             next
[16:11:22.339]                           invokeRestart(restart)
[16:11:22.339]                           muffled <- TRUE
[16:11:22.339]                           break
[16:11:22.339]                         }
[16:11:22.339]                       }
[16:11:22.339]                     }
[16:11:22.339]                     invisible(muffled)
[16:11:22.339]                   }
[16:11:22.339]                   muffleCondition(cond)
[16:11:22.339]                 })
[16:11:22.339]             }))
[16:11:22.339]             future::FutureResult(value = ...future.value$value, 
[16:11:22.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:22.339]                   ...future.rng), globalenv = if (FALSE) 
[16:11:22.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:22.339]                     ...future.globalenv.names))
[16:11:22.339]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:22.339]         }, condition = base::local({
[16:11:22.339]             c <- base::c
[16:11:22.339]             inherits <- base::inherits
[16:11:22.339]             invokeRestart <- base::invokeRestart
[16:11:22.339]             length <- base::length
[16:11:22.339]             list <- base::list
[16:11:22.339]             seq.int <- base::seq.int
[16:11:22.339]             signalCondition <- base::signalCondition
[16:11:22.339]             sys.calls <- base::sys.calls
[16:11:22.339]             `[[` <- base::`[[`
[16:11:22.339]             `+` <- base::`+`
[16:11:22.339]             `<<-` <- base::`<<-`
[16:11:22.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:22.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:22.339]                   3L)]
[16:11:22.339]             }
[16:11:22.339]             function(cond) {
[16:11:22.339]                 is_error <- inherits(cond, "error")
[16:11:22.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:22.339]                   NULL)
[16:11:22.339]                 if (is_error) {
[16:11:22.339]                   sessionInformation <- function() {
[16:11:22.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:22.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:22.339]                       search = base::search(), system = base::Sys.info())
[16:11:22.339]                   }
[16:11:22.339]                   ...future.conditions[[length(...future.conditions) + 
[16:11:22.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:22.339]                     cond$call), session = sessionInformation(), 
[16:11:22.339]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:22.339]                   signalCondition(cond)
[16:11:22.339]                 }
[16:11:22.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:22.339]                 "immediateCondition"))) {
[16:11:22.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:22.339]                   ...future.conditions[[length(...future.conditions) + 
[16:11:22.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:22.339]                   if (TRUE && !signal) {
[16:11:22.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.339]                     {
[16:11:22.339]                       inherits <- base::inherits
[16:11:22.339]                       invokeRestart <- base::invokeRestart
[16:11:22.339]                       is.null <- base::is.null
[16:11:22.339]                       muffled <- FALSE
[16:11:22.339]                       if (inherits(cond, "message")) {
[16:11:22.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:22.339]                         if (muffled) 
[16:11:22.339]                           invokeRestart("muffleMessage")
[16:11:22.339]                       }
[16:11:22.339]                       else if (inherits(cond, "warning")) {
[16:11:22.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:22.339]                         if (muffled) 
[16:11:22.339]                           invokeRestart("muffleWarning")
[16:11:22.339]                       }
[16:11:22.339]                       else if (inherits(cond, "condition")) {
[16:11:22.339]                         if (!is.null(pattern)) {
[16:11:22.339]                           computeRestarts <- base::computeRestarts
[16:11:22.339]                           grepl <- base::grepl
[16:11:22.339]                           restarts <- computeRestarts(cond)
[16:11:22.339]                           for (restart in restarts) {
[16:11:22.339]                             name <- restart$name
[16:11:22.339]                             if (is.null(name)) 
[16:11:22.339]                               next
[16:11:22.339]                             if (!grepl(pattern, name)) 
[16:11:22.339]                               next
[16:11:22.339]                             invokeRestart(restart)
[16:11:22.339]                             muffled <- TRUE
[16:11:22.339]                             break
[16:11:22.339]                           }
[16:11:22.339]                         }
[16:11:22.339]                       }
[16:11:22.339]                       invisible(muffled)
[16:11:22.339]                     }
[16:11:22.339]                     muffleCondition(cond, pattern = "^muffle")
[16:11:22.339]                   }
[16:11:22.339]                 }
[16:11:22.339]                 else {
[16:11:22.339]                   if (TRUE) {
[16:11:22.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.339]                     {
[16:11:22.339]                       inherits <- base::inherits
[16:11:22.339]                       invokeRestart <- base::invokeRestart
[16:11:22.339]                       is.null <- base::is.null
[16:11:22.339]                       muffled <- FALSE
[16:11:22.339]                       if (inherits(cond, "message")) {
[16:11:22.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:22.339]                         if (muffled) 
[16:11:22.339]                           invokeRestart("muffleMessage")
[16:11:22.339]                       }
[16:11:22.339]                       else if (inherits(cond, "warning")) {
[16:11:22.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:22.339]                         if (muffled) 
[16:11:22.339]                           invokeRestart("muffleWarning")
[16:11:22.339]                       }
[16:11:22.339]                       else if (inherits(cond, "condition")) {
[16:11:22.339]                         if (!is.null(pattern)) {
[16:11:22.339]                           computeRestarts <- base::computeRestarts
[16:11:22.339]                           grepl <- base::grepl
[16:11:22.339]                           restarts <- computeRestarts(cond)
[16:11:22.339]                           for (restart in restarts) {
[16:11:22.339]                             name <- restart$name
[16:11:22.339]                             if (is.null(name)) 
[16:11:22.339]                               next
[16:11:22.339]                             if (!grepl(pattern, name)) 
[16:11:22.339]                               next
[16:11:22.339]                             invokeRestart(restart)
[16:11:22.339]                             muffled <- TRUE
[16:11:22.339]                             break
[16:11:22.339]                           }
[16:11:22.339]                         }
[16:11:22.339]                       }
[16:11:22.339]                       invisible(muffled)
[16:11:22.339]                     }
[16:11:22.339]                     muffleCondition(cond, pattern = "^muffle")
[16:11:22.339]                   }
[16:11:22.339]                 }
[16:11:22.339]             }
[16:11:22.339]         }))
[16:11:22.339]     }, error = function(ex) {
[16:11:22.339]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:22.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:22.339]                 ...future.rng), started = ...future.startTime, 
[16:11:22.339]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:22.339]             version = "1.8"), class = "FutureResult")
[16:11:22.339]     }, finally = {
[16:11:22.339]         if (!identical(...future.workdir, getwd())) 
[16:11:22.339]             setwd(...future.workdir)
[16:11:22.339]         {
[16:11:22.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:22.339]                 ...future.oldOptions$nwarnings <- NULL
[16:11:22.339]             }
[16:11:22.339]             base::options(...future.oldOptions)
[16:11:22.339]             if (.Platform$OS.type == "windows") {
[16:11:22.339]                 old_names <- names(...future.oldEnvVars)
[16:11:22.339]                 envs <- base::Sys.getenv()
[16:11:22.339]                 names <- names(envs)
[16:11:22.339]                 common <- intersect(names, old_names)
[16:11:22.339]                 added <- setdiff(names, old_names)
[16:11:22.339]                 removed <- setdiff(old_names, names)
[16:11:22.339]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:22.339]                   envs[common]]
[16:11:22.339]                 NAMES <- toupper(changed)
[16:11:22.339]                 args <- list()
[16:11:22.339]                 for (kk in seq_along(NAMES)) {
[16:11:22.339]                   name <- changed[[kk]]
[16:11:22.339]                   NAME <- NAMES[[kk]]
[16:11:22.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.339]                     next
[16:11:22.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:22.339]                 }
[16:11:22.339]                 NAMES <- toupper(added)
[16:11:22.339]                 for (kk in seq_along(NAMES)) {
[16:11:22.339]                   name <- added[[kk]]
[16:11:22.339]                   NAME <- NAMES[[kk]]
[16:11:22.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.339]                     next
[16:11:22.339]                   args[[name]] <- ""
[16:11:22.339]                 }
[16:11:22.339]                 NAMES <- toupper(removed)
[16:11:22.339]                 for (kk in seq_along(NAMES)) {
[16:11:22.339]                   name <- removed[[kk]]
[16:11:22.339]                   NAME <- NAMES[[kk]]
[16:11:22.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.339]                     next
[16:11:22.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:22.339]                 }
[16:11:22.339]                 if (length(args) > 0) 
[16:11:22.339]                   base::do.call(base::Sys.setenv, args = args)
[16:11:22.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:22.339]             }
[16:11:22.339]             else {
[16:11:22.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:22.339]             }
[16:11:22.339]             {
[16:11:22.339]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:22.339]                   0L) {
[16:11:22.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:22.339]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:22.339]                   base::options(opts)
[16:11:22.339]                 }
[16:11:22.339]                 {
[16:11:22.339]                   {
[16:11:22.339]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:22.339]                     NULL
[16:11:22.339]                   }
[16:11:22.339]                   options(future.plan = NULL)
[16:11:22.339]                   if (is.na(NA_character_)) 
[16:11:22.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:22.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:22.339]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:22.339]                     envir = parent.frame()) 
[16:11:22.339]                   {
[16:11:22.339]                     default_workers <- missing(workers)
[16:11:22.339]                     if (is.function(workers)) 
[16:11:22.339]                       workers <- workers()
[16:11:22.339]                     workers <- structure(as.integer(workers), 
[16:11:22.339]                       class = class(workers))
[16:11:22.339]                     stop_if_not(is.finite(workers), workers >= 
[16:11:22.339]                       1L)
[16:11:22.339]                     if ((workers == 1L && !inherits(workers, 
[16:11:22.339]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:22.339]                       if (default_workers) 
[16:11:22.339]                         supportsMulticore(warn = TRUE)
[16:11:22.339]                       return(sequential(..., envir = envir))
[16:11:22.339]                     }
[16:11:22.339]                     oopts <- options(mc.cores = workers)
[16:11:22.339]                     on.exit(options(oopts))
[16:11:22.339]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:22.339]                       envir = envir)
[16:11:22.339]                     if (!future$lazy) 
[16:11:22.339]                       future <- run(future)
[16:11:22.339]                     invisible(future)
[16:11:22.339]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:22.339]                 }
[16:11:22.339]             }
[16:11:22.339]         }
[16:11:22.339]     })
[16:11:22.339]     if (TRUE) {
[16:11:22.339]         base::sink(type = "output", split = FALSE)
[16:11:22.339]         if (TRUE) {
[16:11:22.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:22.339]         }
[16:11:22.339]         else {
[16:11:22.339]             ...future.result["stdout"] <- base::list(NULL)
[16:11:22.339]         }
[16:11:22.339]         base::close(...future.stdout)
[16:11:22.339]         ...future.stdout <- NULL
[16:11:22.339]     }
[16:11:22.339]     ...future.result$conditions <- ...future.conditions
[16:11:22.339]     ...future.result$finished <- base::Sys.time()
[16:11:22.339]     ...future.result
[16:11:22.339] }
[16:11:22.342] assign_globals() ...
[16:11:22.342] List of 5
[16:11:22.342]  $ ...future.FUN            :function (x)  
[16:11:22.342]  $ future.call.arguments    : list()
[16:11:22.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:22.342]  $ ...future.elements_ii    :List of 1
[16:11:22.342]   ..$ : int 1
[16:11:22.342]  $ ...future.seeds_ii       : NULL
[16:11:22.342]  $ ...future.globals.maxSize: NULL
[16:11:22.342]  - attr(*, "where")=List of 5
[16:11:22.342]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:22.342]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:22.342]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:22.342]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:22.342]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:22.342]  - attr(*, "resolved")= logi FALSE
[16:11:22.342]  - attr(*, "total_size")= num 4720
[16:11:22.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:22.342]  - attr(*, "already-done")= logi TRUE
[16:11:22.346] - reassign environment for ‘...future.FUN’
[16:11:22.346] - copied ‘...future.FUN’ to environment
[16:11:22.346] - copied ‘future.call.arguments’ to environment
[16:11:22.347] - copied ‘...future.elements_ii’ to environment
[16:11:22.347] - copied ‘...future.seeds_ii’ to environment
[16:11:22.348] - copied ‘...future.globals.maxSize’ to environment
[16:11:22.348] assign_globals() ... done
[16:11:22.348] requestCore(): workers = 2
[16:11:22.351] MulticoreFuture started
[16:11:22.351] - Launch lazy future ... done
[16:11:22.352] plan(): Setting new future strategy stack:
[16:11:22.352] run() for ‘MulticoreFuture’ ... done
[16:11:22.353] Created future:
[16:11:22.352] List of future strategies:
[16:11:22.352] 1. sequential:
[16:11:22.352]    - args: function (..., envir = parent.frame())
[16:11:22.352]    - tweaked: FALSE
[16:11:22.352]    - call: NULL
[16:11:22.354] plan(): nbrOfWorkers() = 1
[16:11:22.353] MulticoreFuture:
[16:11:22.353] Label: ‘future_lapply-1’
[16:11:22.353] Expression:
[16:11:22.353] {
[16:11:22.353]     do.call(function(...) {
[16:11:22.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:22.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.353]             on.exit(options(oopts), add = TRUE)
[16:11:22.353]         }
[16:11:22.353]         {
[16:11:22.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:22.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.353]                 ...future.FUN(...future.X_jj, ...)
[16:11:22.353]             })
[16:11:22.353]         }
[16:11:22.353]     }, args = future.call.arguments)
[16:11:22.353] }
[16:11:22.353] Lazy evaluation: FALSE
[16:11:22.353] Asynchronous evaluation: TRUE
[16:11:22.353] Local evaluation: TRUE
[16:11:22.353] Environment: R_GlobalEnv
[16:11:22.353] Capture standard output: TRUE
[16:11:22.353] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:22.353] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:22.353] Packages: <none>
[16:11:22.353] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:22.353] Resolved: FALSE
[16:11:22.353] Value: <not collected>
[16:11:22.353] Conditions captured: <none>
[16:11:22.353] Early signaling: FALSE
[16:11:22.353] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:22.353] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:22.367] Chunk #1 of 2 ... DONE
[16:11:22.368] Chunk #2 of 2 ...
[16:11:22.368]  - Finding globals in 'X' for chunk #2 ...
[16:11:22.368] getGlobalsAndPackages() ...
[16:11:22.368] Searching for globals...
[16:11:22.369] 
[16:11:22.369] Searching for globals ... DONE
[16:11:22.369] - globals: [0] <none>
[16:11:22.370] getGlobalsAndPackages() ... DONE
[16:11:22.370]    + additional globals found: [n=0] 
[16:11:22.370]    + additional namespaces needed: [n=0] 
[16:11:22.370]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:22.371]  - seeds: <none>
[16:11:22.371] getGlobalsAndPackages() ...
[16:11:22.371] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:22.371] Resolving globals: FALSE
[16:11:22.371] Tweak future expression to call with '...' arguments ...
[16:11:22.372] {
[16:11:22.372]     do.call(function(...) {
[16:11:22.372]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.372]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:22.372]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.372]             on.exit(options(oopts), add = TRUE)
[16:11:22.372]         }
[16:11:22.372]         {
[16:11:22.372]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:22.372]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.372]                 ...future.FUN(...future.X_jj, ...)
[16:11:22.372]             })
[16:11:22.372]         }
[16:11:22.372]     }, args = future.call.arguments)
[16:11:22.372] }
[16:11:22.372] Tweak future expression to call with '...' arguments ... DONE
[16:11:22.373] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:22.373] 
[16:11:22.373] getGlobalsAndPackages() ... DONE
[16:11:22.374] run() for ‘Future’ ...
[16:11:22.374] - state: ‘created’
[16:11:22.374] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:22.379] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:22.379] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:22.379]   - Field: ‘label’
[16:11:22.380]   - Field: ‘local’
[16:11:22.380]   - Field: ‘owner’
[16:11:22.380]   - Field: ‘envir’
[16:11:22.380]   - Field: ‘workers’
[16:11:22.380]   - Field: ‘packages’
[16:11:22.380]   - Field: ‘gc’
[16:11:22.380]   - Field: ‘job’
[16:11:22.381]   - Field: ‘conditions’
[16:11:22.381]   - Field: ‘expr’
[16:11:22.381]   - Field: ‘uuid’
[16:11:22.381]   - Field: ‘seed’
[16:11:22.381]   - Field: ‘version’
[16:11:22.381]   - Field: ‘result’
[16:11:22.381]   - Field: ‘asynchronous’
[16:11:22.382]   - Field: ‘calls’
[16:11:22.382]   - Field: ‘globals’
[16:11:22.382]   - Field: ‘stdout’
[16:11:22.382]   - Field: ‘earlySignal’
[16:11:22.382]   - Field: ‘lazy’
[16:11:22.382]   - Field: ‘state’
[16:11:22.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:22.382] - Launch lazy future ...
[16:11:22.383] Packages needed by the future expression (n = 0): <none>
[16:11:22.383] Packages needed by future strategies (n = 0): <none>
[16:11:22.384] {
[16:11:22.384]     {
[16:11:22.384]         {
[16:11:22.384]             ...future.startTime <- base::Sys.time()
[16:11:22.384]             {
[16:11:22.384]                 {
[16:11:22.384]                   {
[16:11:22.384]                     {
[16:11:22.384]                       base::local({
[16:11:22.384]                         has_future <- base::requireNamespace("future", 
[16:11:22.384]                           quietly = TRUE)
[16:11:22.384]                         if (has_future) {
[16:11:22.384]                           ns <- base::getNamespace("future")
[16:11:22.384]                           version <- ns[[".package"]][["version"]]
[16:11:22.384]                           if (is.null(version)) 
[16:11:22.384]                             version <- utils::packageVersion("future")
[16:11:22.384]                         }
[16:11:22.384]                         else {
[16:11:22.384]                           version <- NULL
[16:11:22.384]                         }
[16:11:22.384]                         if (!has_future || version < "1.8.0") {
[16:11:22.384]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:22.384]                             "", base::R.version$version.string), 
[16:11:22.384]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:22.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:22.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:22.384]                               "release", "version")], collapse = " "), 
[16:11:22.384]                             hostname = base::Sys.info()[["nodename"]])
[16:11:22.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:22.384]                             info)
[16:11:22.384]                           info <- base::paste(info, collapse = "; ")
[16:11:22.384]                           if (!has_future) {
[16:11:22.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:22.384]                               info)
[16:11:22.384]                           }
[16:11:22.384]                           else {
[16:11:22.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:22.384]                               info, version)
[16:11:22.384]                           }
[16:11:22.384]                           base::stop(msg)
[16:11:22.384]                         }
[16:11:22.384]                       })
[16:11:22.384]                     }
[16:11:22.384]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:22.384]                     base::options(mc.cores = 1L)
[16:11:22.384]                   }
[16:11:22.384]                   options(future.plan = NULL)
[16:11:22.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:22.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:22.384]                 }
[16:11:22.384]                 ...future.workdir <- getwd()
[16:11:22.384]             }
[16:11:22.384]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:22.384]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:22.384]         }
[16:11:22.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:22.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:22.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:22.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:22.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:22.384]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:22.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:22.384]             base::names(...future.oldOptions))
[16:11:22.384]     }
[16:11:22.384]     if (FALSE) {
[16:11:22.384]     }
[16:11:22.384]     else {
[16:11:22.384]         if (TRUE) {
[16:11:22.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:22.384]                 open = "w")
[16:11:22.384]         }
[16:11:22.384]         else {
[16:11:22.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:22.384]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:22.384]         }
[16:11:22.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:22.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:22.384]             base::sink(type = "output", split = FALSE)
[16:11:22.384]             base::close(...future.stdout)
[16:11:22.384]         }, add = TRUE)
[16:11:22.384]     }
[16:11:22.384]     ...future.frame <- base::sys.nframe()
[16:11:22.384]     ...future.conditions <- base::list()
[16:11:22.384]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:22.384]     if (FALSE) {
[16:11:22.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:22.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:22.384]     }
[16:11:22.384]     ...future.result <- base::tryCatch({
[16:11:22.384]         base::withCallingHandlers({
[16:11:22.384]             ...future.value <- base::withVisible(base::local({
[16:11:22.384]                 withCallingHandlers({
[16:11:22.384]                   {
[16:11:22.384]                     do.call(function(...) {
[16:11:22.384]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.384]                       if (!identical(...future.globals.maxSize.org, 
[16:11:22.384]                         ...future.globals.maxSize)) {
[16:11:22.384]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.384]                         on.exit(options(oopts), add = TRUE)
[16:11:22.384]                       }
[16:11:22.384]                       {
[16:11:22.384]                         lapply(seq_along(...future.elements_ii), 
[16:11:22.384]                           FUN = function(jj) {
[16:11:22.384]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.384]                             ...future.FUN(...future.X_jj, ...)
[16:11:22.384]                           })
[16:11:22.384]                       }
[16:11:22.384]                     }, args = future.call.arguments)
[16:11:22.384]                   }
[16:11:22.384]                 }, immediateCondition = function(cond) {
[16:11:22.384]                   save_rds <- function (object, pathname, ...) 
[16:11:22.384]                   {
[16:11:22.384]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:22.384]                     if (file_test("-f", pathname_tmp)) {
[16:11:22.384]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.384]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:22.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.384]                         fi_tmp[["mtime"]])
[16:11:22.384]                     }
[16:11:22.384]                     tryCatch({
[16:11:22.384]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:22.384]                     }, error = function(ex) {
[16:11:22.384]                       msg <- conditionMessage(ex)
[16:11:22.384]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.384]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:22.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.384]                         fi_tmp[["mtime"]], msg)
[16:11:22.384]                       ex$message <- msg
[16:11:22.384]                       stop(ex)
[16:11:22.384]                     })
[16:11:22.384]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:22.384]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:22.384]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:22.384]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.384]                       fi <- file.info(pathname)
[16:11:22.384]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:22.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.384]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:22.384]                         fi[["size"]], fi[["mtime"]])
[16:11:22.384]                       stop(msg)
[16:11:22.384]                     }
[16:11:22.384]                     invisible(pathname)
[16:11:22.384]                   }
[16:11:22.384]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:22.384]                     rootPath = tempdir()) 
[16:11:22.384]                   {
[16:11:22.384]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:22.384]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:22.384]                       tmpdir = path, fileext = ".rds")
[16:11:22.384]                     save_rds(obj, file)
[16:11:22.384]                   }
[16:11:22.384]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:22.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.384]                   {
[16:11:22.384]                     inherits <- base::inherits
[16:11:22.384]                     invokeRestart <- base::invokeRestart
[16:11:22.384]                     is.null <- base::is.null
[16:11:22.384]                     muffled <- FALSE
[16:11:22.384]                     if (inherits(cond, "message")) {
[16:11:22.384]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:22.384]                       if (muffled) 
[16:11:22.384]                         invokeRestart("muffleMessage")
[16:11:22.384]                     }
[16:11:22.384]                     else if (inherits(cond, "warning")) {
[16:11:22.384]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:22.384]                       if (muffled) 
[16:11:22.384]                         invokeRestart("muffleWarning")
[16:11:22.384]                     }
[16:11:22.384]                     else if (inherits(cond, "condition")) {
[16:11:22.384]                       if (!is.null(pattern)) {
[16:11:22.384]                         computeRestarts <- base::computeRestarts
[16:11:22.384]                         grepl <- base::grepl
[16:11:22.384]                         restarts <- computeRestarts(cond)
[16:11:22.384]                         for (restart in restarts) {
[16:11:22.384]                           name <- restart$name
[16:11:22.384]                           if (is.null(name)) 
[16:11:22.384]                             next
[16:11:22.384]                           if (!grepl(pattern, name)) 
[16:11:22.384]                             next
[16:11:22.384]                           invokeRestart(restart)
[16:11:22.384]                           muffled <- TRUE
[16:11:22.384]                           break
[16:11:22.384]                         }
[16:11:22.384]                       }
[16:11:22.384]                     }
[16:11:22.384]                     invisible(muffled)
[16:11:22.384]                   }
[16:11:22.384]                   muffleCondition(cond)
[16:11:22.384]                 })
[16:11:22.384]             }))
[16:11:22.384]             future::FutureResult(value = ...future.value$value, 
[16:11:22.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:22.384]                   ...future.rng), globalenv = if (FALSE) 
[16:11:22.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:22.384]                     ...future.globalenv.names))
[16:11:22.384]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:22.384]         }, condition = base::local({
[16:11:22.384]             c <- base::c
[16:11:22.384]             inherits <- base::inherits
[16:11:22.384]             invokeRestart <- base::invokeRestart
[16:11:22.384]             length <- base::length
[16:11:22.384]             list <- base::list
[16:11:22.384]             seq.int <- base::seq.int
[16:11:22.384]             signalCondition <- base::signalCondition
[16:11:22.384]             sys.calls <- base::sys.calls
[16:11:22.384]             `[[` <- base::`[[`
[16:11:22.384]             `+` <- base::`+`
[16:11:22.384]             `<<-` <- base::`<<-`
[16:11:22.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:22.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:22.384]                   3L)]
[16:11:22.384]             }
[16:11:22.384]             function(cond) {
[16:11:22.384]                 is_error <- inherits(cond, "error")
[16:11:22.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:22.384]                   NULL)
[16:11:22.384]                 if (is_error) {
[16:11:22.384]                   sessionInformation <- function() {
[16:11:22.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:22.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:22.384]                       search = base::search(), system = base::Sys.info())
[16:11:22.384]                   }
[16:11:22.384]                   ...future.conditions[[length(...future.conditions) + 
[16:11:22.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:22.384]                     cond$call), session = sessionInformation(), 
[16:11:22.384]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:22.384]                   signalCondition(cond)
[16:11:22.384]                 }
[16:11:22.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:22.384]                 "immediateCondition"))) {
[16:11:22.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:22.384]                   ...future.conditions[[length(...future.conditions) + 
[16:11:22.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:22.384]                   if (TRUE && !signal) {
[16:11:22.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.384]                     {
[16:11:22.384]                       inherits <- base::inherits
[16:11:22.384]                       invokeRestart <- base::invokeRestart
[16:11:22.384]                       is.null <- base::is.null
[16:11:22.384]                       muffled <- FALSE
[16:11:22.384]                       if (inherits(cond, "message")) {
[16:11:22.384]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:22.384]                         if (muffled) 
[16:11:22.384]                           invokeRestart("muffleMessage")
[16:11:22.384]                       }
[16:11:22.384]                       else if (inherits(cond, "warning")) {
[16:11:22.384]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:22.384]                         if (muffled) 
[16:11:22.384]                           invokeRestart("muffleWarning")
[16:11:22.384]                       }
[16:11:22.384]                       else if (inherits(cond, "condition")) {
[16:11:22.384]                         if (!is.null(pattern)) {
[16:11:22.384]                           computeRestarts <- base::computeRestarts
[16:11:22.384]                           grepl <- base::grepl
[16:11:22.384]                           restarts <- computeRestarts(cond)
[16:11:22.384]                           for (restart in restarts) {
[16:11:22.384]                             name <- restart$name
[16:11:22.384]                             if (is.null(name)) 
[16:11:22.384]                               next
[16:11:22.384]                             if (!grepl(pattern, name)) 
[16:11:22.384]                               next
[16:11:22.384]                             invokeRestart(restart)
[16:11:22.384]                             muffled <- TRUE
[16:11:22.384]                             break
[16:11:22.384]                           }
[16:11:22.384]                         }
[16:11:22.384]                       }
[16:11:22.384]                       invisible(muffled)
[16:11:22.384]                     }
[16:11:22.384]                     muffleCondition(cond, pattern = "^muffle")
[16:11:22.384]                   }
[16:11:22.384]                 }
[16:11:22.384]                 else {
[16:11:22.384]                   if (TRUE) {
[16:11:22.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.384]                     {
[16:11:22.384]                       inherits <- base::inherits
[16:11:22.384]                       invokeRestart <- base::invokeRestart
[16:11:22.384]                       is.null <- base::is.null
[16:11:22.384]                       muffled <- FALSE
[16:11:22.384]                       if (inherits(cond, "message")) {
[16:11:22.384]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:22.384]                         if (muffled) 
[16:11:22.384]                           invokeRestart("muffleMessage")
[16:11:22.384]                       }
[16:11:22.384]                       else if (inherits(cond, "warning")) {
[16:11:22.384]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:22.384]                         if (muffled) 
[16:11:22.384]                           invokeRestart("muffleWarning")
[16:11:22.384]                       }
[16:11:22.384]                       else if (inherits(cond, "condition")) {
[16:11:22.384]                         if (!is.null(pattern)) {
[16:11:22.384]                           computeRestarts <- base::computeRestarts
[16:11:22.384]                           grepl <- base::grepl
[16:11:22.384]                           restarts <- computeRestarts(cond)
[16:11:22.384]                           for (restart in restarts) {
[16:11:22.384]                             name <- restart$name
[16:11:22.384]                             if (is.null(name)) 
[16:11:22.384]                               next
[16:11:22.384]                             if (!grepl(pattern, name)) 
[16:11:22.384]                               next
[16:11:22.384]                             invokeRestart(restart)
[16:11:22.384]                             muffled <- TRUE
[16:11:22.384]                             break
[16:11:22.384]                           }
[16:11:22.384]                         }
[16:11:22.384]                       }
[16:11:22.384]                       invisible(muffled)
[16:11:22.384]                     }
[16:11:22.384]                     muffleCondition(cond, pattern = "^muffle")
[16:11:22.384]                   }
[16:11:22.384]                 }
[16:11:22.384]             }
[16:11:22.384]         }))
[16:11:22.384]     }, error = function(ex) {
[16:11:22.384]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:22.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:22.384]                 ...future.rng), started = ...future.startTime, 
[16:11:22.384]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:22.384]             version = "1.8"), class = "FutureResult")
[16:11:22.384]     }, finally = {
[16:11:22.384]         if (!identical(...future.workdir, getwd())) 
[16:11:22.384]             setwd(...future.workdir)
[16:11:22.384]         {
[16:11:22.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:22.384]                 ...future.oldOptions$nwarnings <- NULL
[16:11:22.384]             }
[16:11:22.384]             base::options(...future.oldOptions)
[16:11:22.384]             if (.Platform$OS.type == "windows") {
[16:11:22.384]                 old_names <- names(...future.oldEnvVars)
[16:11:22.384]                 envs <- base::Sys.getenv()
[16:11:22.384]                 names <- names(envs)
[16:11:22.384]                 common <- intersect(names, old_names)
[16:11:22.384]                 added <- setdiff(names, old_names)
[16:11:22.384]                 removed <- setdiff(old_names, names)
[16:11:22.384]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:22.384]                   envs[common]]
[16:11:22.384]                 NAMES <- toupper(changed)
[16:11:22.384]                 args <- list()
[16:11:22.384]                 for (kk in seq_along(NAMES)) {
[16:11:22.384]                   name <- changed[[kk]]
[16:11:22.384]                   NAME <- NAMES[[kk]]
[16:11:22.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.384]                     next
[16:11:22.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:22.384]                 }
[16:11:22.384]                 NAMES <- toupper(added)
[16:11:22.384]                 for (kk in seq_along(NAMES)) {
[16:11:22.384]                   name <- added[[kk]]
[16:11:22.384]                   NAME <- NAMES[[kk]]
[16:11:22.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.384]                     next
[16:11:22.384]                   args[[name]] <- ""
[16:11:22.384]                 }
[16:11:22.384]                 NAMES <- toupper(removed)
[16:11:22.384]                 for (kk in seq_along(NAMES)) {
[16:11:22.384]                   name <- removed[[kk]]
[16:11:22.384]                   NAME <- NAMES[[kk]]
[16:11:22.384]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.384]                     next
[16:11:22.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:22.384]                 }
[16:11:22.384]                 if (length(args) > 0) 
[16:11:22.384]                   base::do.call(base::Sys.setenv, args = args)
[16:11:22.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:22.384]             }
[16:11:22.384]             else {
[16:11:22.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:22.384]             }
[16:11:22.384]             {
[16:11:22.384]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:22.384]                   0L) {
[16:11:22.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:22.384]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:22.384]                   base::options(opts)
[16:11:22.384]                 }
[16:11:22.384]                 {
[16:11:22.384]                   {
[16:11:22.384]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:22.384]                     NULL
[16:11:22.384]                   }
[16:11:22.384]                   options(future.plan = NULL)
[16:11:22.384]                   if (is.na(NA_character_)) 
[16:11:22.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:22.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:22.384]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:22.384]                     envir = parent.frame()) 
[16:11:22.384]                   {
[16:11:22.384]                     default_workers <- missing(workers)
[16:11:22.384]                     if (is.function(workers)) 
[16:11:22.384]                       workers <- workers()
[16:11:22.384]                     workers <- structure(as.integer(workers), 
[16:11:22.384]                       class = class(workers))
[16:11:22.384]                     stop_if_not(is.finite(workers), workers >= 
[16:11:22.384]                       1L)
[16:11:22.384]                     if ((workers == 1L && !inherits(workers, 
[16:11:22.384]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:22.384]                       if (default_workers) 
[16:11:22.384]                         supportsMulticore(warn = TRUE)
[16:11:22.384]                       return(sequential(..., envir = envir))
[16:11:22.384]                     }
[16:11:22.384]                     oopts <- options(mc.cores = workers)
[16:11:22.384]                     on.exit(options(oopts))
[16:11:22.384]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:22.384]                       envir = envir)
[16:11:22.384]                     if (!future$lazy) 
[16:11:22.384]                       future <- run(future)
[16:11:22.384]                     invisible(future)
[16:11:22.384]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:22.384]                 }
[16:11:22.384]             }
[16:11:22.384]         }
[16:11:22.384]     })
[16:11:22.384]     if (TRUE) {
[16:11:22.384]         base::sink(type = "output", split = FALSE)
[16:11:22.384]         if (TRUE) {
[16:11:22.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:22.384]         }
[16:11:22.384]         else {
[16:11:22.384]             ...future.result["stdout"] <- base::list(NULL)
[16:11:22.384]         }
[16:11:22.384]         base::close(...future.stdout)
[16:11:22.384]         ...future.stdout <- NULL
[16:11:22.384]     }
[16:11:22.384]     ...future.result$conditions <- ...future.conditions
[16:11:22.384]     ...future.result$finished <- base::Sys.time()
[16:11:22.384]     ...future.result
[16:11:22.384] }
[16:11:22.387] assign_globals() ...
[16:11:22.387] List of 5
[16:11:22.387]  $ ...future.FUN            :function (x)  
[16:11:22.387]  $ future.call.arguments    : list()
[16:11:22.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:22.387]  $ ...future.elements_ii    :List of 1
[16:11:22.387]   ..$ : int 0
[16:11:22.387]  $ ...future.seeds_ii       : NULL
[16:11:22.387]  $ ...future.globals.maxSize: NULL
[16:11:22.387]  - attr(*, "where")=List of 5
[16:11:22.387]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:22.387]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:22.387]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:22.387]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:22.387]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:22.387]  - attr(*, "resolved")= logi FALSE
[16:11:22.387]  - attr(*, "total_size")= num 4720
[16:11:22.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:22.387]  - attr(*, "already-done")= logi TRUE
[16:11:22.394] - reassign environment for ‘...future.FUN’
[16:11:22.394] - copied ‘...future.FUN’ to environment
[16:11:22.394] - copied ‘future.call.arguments’ to environment
[16:11:22.394] - copied ‘...future.elements_ii’ to environment
[16:11:22.394] - copied ‘...future.seeds_ii’ to environment
[16:11:22.394] - copied ‘...future.globals.maxSize’ to environment
[16:11:22.394] assign_globals() ... done
[16:11:22.394] requestCore(): workers = 2
[16:11:22.397] MulticoreFuture started
[16:11:22.397] - Launch lazy future ... done
[16:11:22.397] run() for ‘MulticoreFuture’ ... done
[16:11:22.397] Created future:
[16:11:22.398] plan(): Setting new future strategy stack:
[16:11:22.398] List of future strategies:
[16:11:22.398] 1. sequential:
[16:11:22.398]    - args: function (..., envir = parent.frame())
[16:11:22.398]    - tweaked: FALSE
[16:11:22.398]    - call: NULL
[16:11:22.399] plan(): nbrOfWorkers() = 1
[16:11:22.401] plan(): Setting new future strategy stack:
[16:11:22.401] List of future strategies:
[16:11:22.401] 1. multicore:
[16:11:22.401]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:22.401]    - tweaked: FALSE
[16:11:22.401]    - call: plan(strategy)
[16:11:22.406] plan(): nbrOfWorkers() = 2
[16:11:22.398] MulticoreFuture:
[16:11:22.398] Label: ‘future_lapply-2’
[16:11:22.398] Expression:
[16:11:22.398] {
[16:11:22.398]     do.call(function(...) {
[16:11:22.398]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.398]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:22.398]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.398]             on.exit(options(oopts), add = TRUE)
[16:11:22.398]         }
[16:11:22.398]         {
[16:11:22.398]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:22.398]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.398]                 ...future.FUN(...future.X_jj, ...)
[16:11:22.398]             })
[16:11:22.398]         }
[16:11:22.398]     }, args = future.call.arguments)
[16:11:22.398] }
[16:11:22.398] Lazy evaluation: FALSE
[16:11:22.398] Asynchronous evaluation: TRUE
[16:11:22.398] Local evaluation: TRUE
[16:11:22.398] Environment: R_GlobalEnv
[16:11:22.398] Capture standard output: TRUE
[16:11:22.398] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:22.398] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:22.398] Packages: <none>
[16:11:22.398] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:22.398] Resolved: TRUE
[16:11:22.398] Value: <not collected>
[16:11:22.398] Conditions captured: <none>
[16:11:22.398] Early signaling: FALSE
[16:11:22.398] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:22.398] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:22.407] Chunk #2 of 2 ... DONE
[16:11:22.407] Launching 2 futures (chunks) ... DONE
[16:11:22.407] Resolving 2 futures (chunks) ...
[16:11:22.407] resolve() on list ...
[16:11:22.407]  recursive: 0
[16:11:22.408]  length: 2
[16:11:22.408] 
[16:11:22.418] Future #2
[16:11:22.420] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:22.420] - nx: 2
[16:11:22.420] - relay: TRUE
[16:11:22.420] - stdout: TRUE
[16:11:22.420] - signal: TRUE
[16:11:22.420] - resignal: FALSE
[16:11:22.420] - force: TRUE
[16:11:22.420] - relayed: [n=2] FALSE, FALSE
[16:11:22.421] - queued futures: [n=2] FALSE, FALSE
[16:11:22.421]  - until=1
[16:11:22.421]  - relaying element #1
[16:11:22.421] - relayed: [n=2] FALSE, FALSE
[16:11:22.421] - queued futures: [n=2] FALSE, TRUE
[16:11:22.421] signalConditionsASAP(NULL, pos=2) ... done
[16:11:22.421]  length: 1 (resolved future 2)
[16:11:22.857] plan(): Setting new future strategy stack:
[16:11:22.857] List of future strategies:
[16:11:22.857] 1. multicore:
[16:11:22.857]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:22.857]    - tweaked: FALSE
[16:11:22.857]    - call: plan(strategy)
[16:11:22.862] plan(): nbrOfWorkers() = 2
[16:11:22.863] Future #1
[16:11:22.864] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:22.864] - nx: 2
[16:11:22.865] - relay: TRUE
[16:11:22.865] - stdout: TRUE
[16:11:22.865] - signal: TRUE
[16:11:22.865] - resignal: FALSE
[16:11:22.866] - force: TRUE
[16:11:22.866] - relayed: [n=2] FALSE, FALSE
[16:11:22.866] - queued futures: [n=2] FALSE, TRUE
[16:11:22.866]  - until=1
[16:11:22.866]  - relaying element #1
[16:11:22.867] - relayed: [n=2] TRUE, FALSE
[16:11:22.867] - queued futures: [n=2] TRUE, TRUE
[16:11:22.867] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:22.867]  length: 0 (resolved future 1)
[16:11:22.868] Relaying remaining futures
[16:11:22.868] signalConditionsASAP(NULL, pos=0) ...
[16:11:22.868] - nx: 2
[16:11:22.868] - relay: TRUE
[16:11:22.868] - stdout: TRUE
[16:11:22.868] - signal: TRUE
[16:11:22.869] - resignal: FALSE
[16:11:22.869] - force: TRUE
[16:11:22.869] - relayed: [n=2] TRUE, FALSE
[16:11:22.869] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:22.869]  - relaying element #2
[16:11:22.869] - relayed: [n=2] TRUE, TRUE
[16:11:22.870] - queued futures: [n=2] TRUE, TRUE
[16:11:22.870] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:11:22.870] resolve() on list ... DONE
[16:11:22.870]  - Number of value chunks collected: 2
[16:11:22.870] Resolving 2 futures (chunks) ... DONE
[16:11:22.870] Reducing values from 2 chunks ...
[16:11:22.870]  - Number of values collected after concatenation: 2
[16:11:22.871]  - Number of values expected: 2
[16:11:22.871] Reducing values from 2 chunks ... DONE
[16:11:22.871] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:11:22.871] future_lapply() ...
[16:11:22.876] Number of chunks: 2
[16:11:22.876] getGlobalsAndPackagesXApply() ...
[16:11:22.876]  - future.globals: TRUE
[16:11:22.876] getGlobalsAndPackages() ...
[16:11:22.876] Searching for globals...
[16:11:22.878] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:22.878] Searching for globals ... DONE
[16:11:22.878] Resolving globals: FALSE
[16:11:22.879] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:22.879] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:22.879] - globals: [1] ‘FUN’
[16:11:22.879] 
[16:11:22.879] getGlobalsAndPackages() ... DONE
[16:11:22.880]  - globals found/used: [n=1] ‘FUN’
[16:11:22.880]  - needed namespaces: [n=0] 
[16:11:22.880] Finding globals ... DONE
[16:11:22.880]  - use_args: TRUE
[16:11:22.880]  - Getting '...' globals ...
[16:11:22.880] resolve() on list ...
[16:11:22.881]  recursive: 0
[16:11:22.881]  length: 1
[16:11:22.881]  elements: ‘...’
[16:11:22.881]  length: 0 (resolved future 1)
[16:11:22.881] resolve() on list ... DONE
[16:11:22.881]    - '...' content: [n=0] 
[16:11:22.881] List of 1
[16:11:22.881]  $ ...: list()
[16:11:22.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:22.881]  - attr(*, "where")=List of 1
[16:11:22.881]   ..$ ...:<environment: 0x557e1f053d20> 
[16:11:22.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:22.881]  - attr(*, "resolved")= logi TRUE
[16:11:22.881]  - attr(*, "total_size")= num NA
[16:11:22.884]  - Getting '...' globals ... DONE
[16:11:22.884] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:22.884] List of 2
[16:11:22.884]  $ ...future.FUN:function (x)  
[16:11:22.884]  $ ...          : list()
[16:11:22.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:22.884]  - attr(*, "where")=List of 2
[16:11:22.884]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:22.884]   ..$ ...          :<environment: 0x557e1f053d20> 
[16:11:22.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:22.884]  - attr(*, "resolved")= logi FALSE
[16:11:22.884]  - attr(*, "total_size")= num 4720
[16:11:22.887] Packages to be attached in all futures: [n=0] 
[16:11:22.887] getGlobalsAndPackagesXApply() ... DONE
[16:11:22.887] Number of futures (= number of chunks): 2
[16:11:22.888] Launching 2 futures (chunks) ...
[16:11:22.888] Chunk #1 of 2 ...
[16:11:22.888]  - Finding globals in 'X' for chunk #1 ...
[16:11:22.888] getGlobalsAndPackages() ...
[16:11:22.888] Searching for globals...
[16:11:22.888] 
[16:11:22.888] Searching for globals ... DONE
[16:11:22.889] - globals: [0] <none>
[16:11:22.889] getGlobalsAndPackages() ... DONE
[16:11:22.889]    + additional globals found: [n=0] 
[16:11:22.889]    + additional namespaces needed: [n=0] 
[16:11:22.889]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:22.889]  - seeds: <none>
[16:11:22.889] getGlobalsAndPackages() ...
[16:11:22.889] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:22.889] Resolving globals: FALSE
[16:11:22.889] Tweak future expression to call with '...' arguments ...
[16:11:22.890] {
[16:11:22.890]     do.call(function(...) {
[16:11:22.890]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.890]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:22.890]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.890]             on.exit(options(oopts), add = TRUE)
[16:11:22.890]         }
[16:11:22.890]         {
[16:11:22.890]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:22.890]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.890]                 ...future.FUN(...future.X_jj, ...)
[16:11:22.890]             })
[16:11:22.890]         }
[16:11:22.890]     }, args = future.call.arguments)
[16:11:22.890] }
[16:11:22.890] Tweak future expression to call with '...' arguments ... DONE
[16:11:22.890] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:22.890] 
[16:11:22.890] getGlobalsAndPackages() ... DONE
[16:11:22.891] run() for ‘Future’ ...
[16:11:22.891] - state: ‘created’
[16:11:22.893] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:22.897] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:22.897] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:22.897]   - Field: ‘label’
[16:11:22.897]   - Field: ‘local’
[16:11:22.897]   - Field: ‘owner’
[16:11:22.897]   - Field: ‘envir’
[16:11:22.898]   - Field: ‘workers’
[16:11:22.898]   - Field: ‘packages’
[16:11:22.898]   - Field: ‘gc’
[16:11:22.898]   - Field: ‘job’
[16:11:22.898]   - Field: ‘conditions’
[16:11:22.898]   - Field: ‘expr’
[16:11:22.898]   - Field: ‘uuid’
[16:11:22.898]   - Field: ‘seed’
[16:11:22.898]   - Field: ‘version’
[16:11:22.898]   - Field: ‘result’
[16:11:22.899]   - Field: ‘asynchronous’
[16:11:22.899]   - Field: ‘calls’
[16:11:22.899]   - Field: ‘globals’
[16:11:22.899]   - Field: ‘stdout’
[16:11:22.899]   - Field: ‘earlySignal’
[16:11:22.899]   - Field: ‘lazy’
[16:11:22.899]   - Field: ‘state’
[16:11:22.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:22.899] - Launch lazy future ...
[16:11:22.900] Packages needed by the future expression (n = 0): <none>
[16:11:22.900] Packages needed by future strategies (n = 0): <none>
[16:11:22.900] {
[16:11:22.900]     {
[16:11:22.900]         {
[16:11:22.900]             ...future.startTime <- base::Sys.time()
[16:11:22.900]             {
[16:11:22.900]                 {
[16:11:22.900]                   {
[16:11:22.900]                     {
[16:11:22.900]                       base::local({
[16:11:22.900]                         has_future <- base::requireNamespace("future", 
[16:11:22.900]                           quietly = TRUE)
[16:11:22.900]                         if (has_future) {
[16:11:22.900]                           ns <- base::getNamespace("future")
[16:11:22.900]                           version <- ns[[".package"]][["version"]]
[16:11:22.900]                           if (is.null(version)) 
[16:11:22.900]                             version <- utils::packageVersion("future")
[16:11:22.900]                         }
[16:11:22.900]                         else {
[16:11:22.900]                           version <- NULL
[16:11:22.900]                         }
[16:11:22.900]                         if (!has_future || version < "1.8.0") {
[16:11:22.900]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:22.900]                             "", base::R.version$version.string), 
[16:11:22.900]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:22.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:22.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:22.900]                               "release", "version")], collapse = " "), 
[16:11:22.900]                             hostname = base::Sys.info()[["nodename"]])
[16:11:22.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:22.900]                             info)
[16:11:22.900]                           info <- base::paste(info, collapse = "; ")
[16:11:22.900]                           if (!has_future) {
[16:11:22.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:22.900]                               info)
[16:11:22.900]                           }
[16:11:22.900]                           else {
[16:11:22.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:22.900]                               info, version)
[16:11:22.900]                           }
[16:11:22.900]                           base::stop(msg)
[16:11:22.900]                         }
[16:11:22.900]                       })
[16:11:22.900]                     }
[16:11:22.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:22.900]                     base::options(mc.cores = 1L)
[16:11:22.900]                   }
[16:11:22.900]                   options(future.plan = NULL)
[16:11:22.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:22.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:22.900]                 }
[16:11:22.900]                 ...future.workdir <- getwd()
[16:11:22.900]             }
[16:11:22.900]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:22.900]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:22.900]         }
[16:11:22.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:22.900]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:22.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:22.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:22.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:22.900]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:22.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:22.900]             base::names(...future.oldOptions))
[16:11:22.900]     }
[16:11:22.900]     if (TRUE) {
[16:11:22.900]     }
[16:11:22.900]     else {
[16:11:22.900]         if (NA) {
[16:11:22.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:22.900]                 open = "w")
[16:11:22.900]         }
[16:11:22.900]         else {
[16:11:22.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:22.900]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:22.900]         }
[16:11:22.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:22.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:22.900]             base::sink(type = "output", split = FALSE)
[16:11:22.900]             base::close(...future.stdout)
[16:11:22.900]         }, add = TRUE)
[16:11:22.900]     }
[16:11:22.900]     ...future.frame <- base::sys.nframe()
[16:11:22.900]     ...future.conditions <- base::list()
[16:11:22.900]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:22.900]     if (FALSE) {
[16:11:22.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:22.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:22.900]     }
[16:11:22.900]     ...future.result <- base::tryCatch({
[16:11:22.900]         base::withCallingHandlers({
[16:11:22.900]             ...future.value <- base::withVisible(base::local({
[16:11:22.900]                 withCallingHandlers({
[16:11:22.900]                   {
[16:11:22.900]                     do.call(function(...) {
[16:11:22.900]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.900]                       if (!identical(...future.globals.maxSize.org, 
[16:11:22.900]                         ...future.globals.maxSize)) {
[16:11:22.900]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.900]                         on.exit(options(oopts), add = TRUE)
[16:11:22.900]                       }
[16:11:22.900]                       {
[16:11:22.900]                         lapply(seq_along(...future.elements_ii), 
[16:11:22.900]                           FUN = function(jj) {
[16:11:22.900]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.900]                             ...future.FUN(...future.X_jj, ...)
[16:11:22.900]                           })
[16:11:22.900]                       }
[16:11:22.900]                     }, args = future.call.arguments)
[16:11:22.900]                   }
[16:11:22.900]                 }, immediateCondition = function(cond) {
[16:11:22.900]                   save_rds <- function (object, pathname, ...) 
[16:11:22.900]                   {
[16:11:22.900]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:22.900]                     if (file_test("-f", pathname_tmp)) {
[16:11:22.900]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.900]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:22.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.900]                         fi_tmp[["mtime"]])
[16:11:22.900]                     }
[16:11:22.900]                     tryCatch({
[16:11:22.900]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:22.900]                     }, error = function(ex) {
[16:11:22.900]                       msg <- conditionMessage(ex)
[16:11:22.900]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.900]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:22.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.900]                         fi_tmp[["mtime"]], msg)
[16:11:22.900]                       ex$message <- msg
[16:11:22.900]                       stop(ex)
[16:11:22.900]                     })
[16:11:22.900]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:22.900]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:22.900]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:22.900]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.900]                       fi <- file.info(pathname)
[16:11:22.900]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:22.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.900]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:22.900]                         fi[["size"]], fi[["mtime"]])
[16:11:22.900]                       stop(msg)
[16:11:22.900]                     }
[16:11:22.900]                     invisible(pathname)
[16:11:22.900]                   }
[16:11:22.900]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:22.900]                     rootPath = tempdir()) 
[16:11:22.900]                   {
[16:11:22.900]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:22.900]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:22.900]                       tmpdir = path, fileext = ".rds")
[16:11:22.900]                     save_rds(obj, file)
[16:11:22.900]                   }
[16:11:22.900]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:22.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.900]                   {
[16:11:22.900]                     inherits <- base::inherits
[16:11:22.900]                     invokeRestart <- base::invokeRestart
[16:11:22.900]                     is.null <- base::is.null
[16:11:22.900]                     muffled <- FALSE
[16:11:22.900]                     if (inherits(cond, "message")) {
[16:11:22.900]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:22.900]                       if (muffled) 
[16:11:22.900]                         invokeRestart("muffleMessage")
[16:11:22.900]                     }
[16:11:22.900]                     else if (inherits(cond, "warning")) {
[16:11:22.900]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:22.900]                       if (muffled) 
[16:11:22.900]                         invokeRestart("muffleWarning")
[16:11:22.900]                     }
[16:11:22.900]                     else if (inherits(cond, "condition")) {
[16:11:22.900]                       if (!is.null(pattern)) {
[16:11:22.900]                         computeRestarts <- base::computeRestarts
[16:11:22.900]                         grepl <- base::grepl
[16:11:22.900]                         restarts <- computeRestarts(cond)
[16:11:22.900]                         for (restart in restarts) {
[16:11:22.900]                           name <- restart$name
[16:11:22.900]                           if (is.null(name)) 
[16:11:22.900]                             next
[16:11:22.900]                           if (!grepl(pattern, name)) 
[16:11:22.900]                             next
[16:11:22.900]                           invokeRestart(restart)
[16:11:22.900]                           muffled <- TRUE
[16:11:22.900]                           break
[16:11:22.900]                         }
[16:11:22.900]                       }
[16:11:22.900]                     }
[16:11:22.900]                     invisible(muffled)
[16:11:22.900]                   }
[16:11:22.900]                   muffleCondition(cond)
[16:11:22.900]                 })
[16:11:22.900]             }))
[16:11:22.900]             future::FutureResult(value = ...future.value$value, 
[16:11:22.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:22.900]                   ...future.rng), globalenv = if (FALSE) 
[16:11:22.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:22.900]                     ...future.globalenv.names))
[16:11:22.900]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:22.900]         }, condition = base::local({
[16:11:22.900]             c <- base::c
[16:11:22.900]             inherits <- base::inherits
[16:11:22.900]             invokeRestart <- base::invokeRestart
[16:11:22.900]             length <- base::length
[16:11:22.900]             list <- base::list
[16:11:22.900]             seq.int <- base::seq.int
[16:11:22.900]             signalCondition <- base::signalCondition
[16:11:22.900]             sys.calls <- base::sys.calls
[16:11:22.900]             `[[` <- base::`[[`
[16:11:22.900]             `+` <- base::`+`
[16:11:22.900]             `<<-` <- base::`<<-`
[16:11:22.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:22.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:22.900]                   3L)]
[16:11:22.900]             }
[16:11:22.900]             function(cond) {
[16:11:22.900]                 is_error <- inherits(cond, "error")
[16:11:22.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:22.900]                   NULL)
[16:11:22.900]                 if (is_error) {
[16:11:22.900]                   sessionInformation <- function() {
[16:11:22.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:22.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:22.900]                       search = base::search(), system = base::Sys.info())
[16:11:22.900]                   }
[16:11:22.900]                   ...future.conditions[[length(...future.conditions) + 
[16:11:22.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:22.900]                     cond$call), session = sessionInformation(), 
[16:11:22.900]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:22.900]                   signalCondition(cond)
[16:11:22.900]                 }
[16:11:22.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:22.900]                 "immediateCondition"))) {
[16:11:22.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:22.900]                   ...future.conditions[[length(...future.conditions) + 
[16:11:22.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:22.900]                   if (TRUE && !signal) {
[16:11:22.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.900]                     {
[16:11:22.900]                       inherits <- base::inherits
[16:11:22.900]                       invokeRestart <- base::invokeRestart
[16:11:22.900]                       is.null <- base::is.null
[16:11:22.900]                       muffled <- FALSE
[16:11:22.900]                       if (inherits(cond, "message")) {
[16:11:22.900]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:22.900]                         if (muffled) 
[16:11:22.900]                           invokeRestart("muffleMessage")
[16:11:22.900]                       }
[16:11:22.900]                       else if (inherits(cond, "warning")) {
[16:11:22.900]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:22.900]                         if (muffled) 
[16:11:22.900]                           invokeRestart("muffleWarning")
[16:11:22.900]                       }
[16:11:22.900]                       else if (inherits(cond, "condition")) {
[16:11:22.900]                         if (!is.null(pattern)) {
[16:11:22.900]                           computeRestarts <- base::computeRestarts
[16:11:22.900]                           grepl <- base::grepl
[16:11:22.900]                           restarts <- computeRestarts(cond)
[16:11:22.900]                           for (restart in restarts) {
[16:11:22.900]                             name <- restart$name
[16:11:22.900]                             if (is.null(name)) 
[16:11:22.900]                               next
[16:11:22.900]                             if (!grepl(pattern, name)) 
[16:11:22.900]                               next
[16:11:22.900]                             invokeRestart(restart)
[16:11:22.900]                             muffled <- TRUE
[16:11:22.900]                             break
[16:11:22.900]                           }
[16:11:22.900]                         }
[16:11:22.900]                       }
[16:11:22.900]                       invisible(muffled)
[16:11:22.900]                     }
[16:11:22.900]                     muffleCondition(cond, pattern = "^muffle")
[16:11:22.900]                   }
[16:11:22.900]                 }
[16:11:22.900]                 else {
[16:11:22.900]                   if (TRUE) {
[16:11:22.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.900]                     {
[16:11:22.900]                       inherits <- base::inherits
[16:11:22.900]                       invokeRestart <- base::invokeRestart
[16:11:22.900]                       is.null <- base::is.null
[16:11:22.900]                       muffled <- FALSE
[16:11:22.900]                       if (inherits(cond, "message")) {
[16:11:22.900]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:22.900]                         if (muffled) 
[16:11:22.900]                           invokeRestart("muffleMessage")
[16:11:22.900]                       }
[16:11:22.900]                       else if (inherits(cond, "warning")) {
[16:11:22.900]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:22.900]                         if (muffled) 
[16:11:22.900]                           invokeRestart("muffleWarning")
[16:11:22.900]                       }
[16:11:22.900]                       else if (inherits(cond, "condition")) {
[16:11:22.900]                         if (!is.null(pattern)) {
[16:11:22.900]                           computeRestarts <- base::computeRestarts
[16:11:22.900]                           grepl <- base::grepl
[16:11:22.900]                           restarts <- computeRestarts(cond)
[16:11:22.900]                           for (restart in restarts) {
[16:11:22.900]                             name <- restart$name
[16:11:22.900]                             if (is.null(name)) 
[16:11:22.900]                               next
[16:11:22.900]                             if (!grepl(pattern, name)) 
[16:11:22.900]                               next
[16:11:22.900]                             invokeRestart(restart)
[16:11:22.900]                             muffled <- TRUE
[16:11:22.900]                             break
[16:11:22.900]                           }
[16:11:22.900]                         }
[16:11:22.900]                       }
[16:11:22.900]                       invisible(muffled)
[16:11:22.900]                     }
[16:11:22.900]                     muffleCondition(cond, pattern = "^muffle")
[16:11:22.900]                   }
[16:11:22.900]                 }
[16:11:22.900]             }
[16:11:22.900]         }))
[16:11:22.900]     }, error = function(ex) {
[16:11:22.900]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:22.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:22.900]                 ...future.rng), started = ...future.startTime, 
[16:11:22.900]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:22.900]             version = "1.8"), class = "FutureResult")
[16:11:22.900]     }, finally = {
[16:11:22.900]         if (!identical(...future.workdir, getwd())) 
[16:11:22.900]             setwd(...future.workdir)
[16:11:22.900]         {
[16:11:22.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:22.900]                 ...future.oldOptions$nwarnings <- NULL
[16:11:22.900]             }
[16:11:22.900]             base::options(...future.oldOptions)
[16:11:22.900]             if (.Platform$OS.type == "windows") {
[16:11:22.900]                 old_names <- names(...future.oldEnvVars)
[16:11:22.900]                 envs <- base::Sys.getenv()
[16:11:22.900]                 names <- names(envs)
[16:11:22.900]                 common <- intersect(names, old_names)
[16:11:22.900]                 added <- setdiff(names, old_names)
[16:11:22.900]                 removed <- setdiff(old_names, names)
[16:11:22.900]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:22.900]                   envs[common]]
[16:11:22.900]                 NAMES <- toupper(changed)
[16:11:22.900]                 args <- list()
[16:11:22.900]                 for (kk in seq_along(NAMES)) {
[16:11:22.900]                   name <- changed[[kk]]
[16:11:22.900]                   NAME <- NAMES[[kk]]
[16:11:22.900]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.900]                     next
[16:11:22.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:22.900]                 }
[16:11:22.900]                 NAMES <- toupper(added)
[16:11:22.900]                 for (kk in seq_along(NAMES)) {
[16:11:22.900]                   name <- added[[kk]]
[16:11:22.900]                   NAME <- NAMES[[kk]]
[16:11:22.900]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.900]                     next
[16:11:22.900]                   args[[name]] <- ""
[16:11:22.900]                 }
[16:11:22.900]                 NAMES <- toupper(removed)
[16:11:22.900]                 for (kk in seq_along(NAMES)) {
[16:11:22.900]                   name <- removed[[kk]]
[16:11:22.900]                   NAME <- NAMES[[kk]]
[16:11:22.900]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.900]                     next
[16:11:22.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:22.900]                 }
[16:11:22.900]                 if (length(args) > 0) 
[16:11:22.900]                   base::do.call(base::Sys.setenv, args = args)
[16:11:22.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:22.900]             }
[16:11:22.900]             else {
[16:11:22.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:22.900]             }
[16:11:22.900]             {
[16:11:22.900]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:22.900]                   0L) {
[16:11:22.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:22.900]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:22.900]                   base::options(opts)
[16:11:22.900]                 }
[16:11:22.900]                 {
[16:11:22.900]                   {
[16:11:22.900]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:22.900]                     NULL
[16:11:22.900]                   }
[16:11:22.900]                   options(future.plan = NULL)
[16:11:22.900]                   if (is.na(NA_character_)) 
[16:11:22.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:22.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:22.900]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:22.900]                     envir = parent.frame()) 
[16:11:22.900]                   {
[16:11:22.900]                     default_workers <- missing(workers)
[16:11:22.900]                     if (is.function(workers)) 
[16:11:22.900]                       workers <- workers()
[16:11:22.900]                     workers <- structure(as.integer(workers), 
[16:11:22.900]                       class = class(workers))
[16:11:22.900]                     stop_if_not(is.finite(workers), workers >= 
[16:11:22.900]                       1L)
[16:11:22.900]                     if ((workers == 1L && !inherits(workers, 
[16:11:22.900]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:22.900]                       if (default_workers) 
[16:11:22.900]                         supportsMulticore(warn = TRUE)
[16:11:22.900]                       return(sequential(..., envir = envir))
[16:11:22.900]                     }
[16:11:22.900]                     oopts <- options(mc.cores = workers)
[16:11:22.900]                     on.exit(options(oopts))
[16:11:22.900]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:22.900]                       envir = envir)
[16:11:22.900]                     if (!future$lazy) 
[16:11:22.900]                       future <- run(future)
[16:11:22.900]                     invisible(future)
[16:11:22.900]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:22.900]                 }
[16:11:22.900]             }
[16:11:22.900]         }
[16:11:22.900]     })
[16:11:22.900]     if (FALSE) {
[16:11:22.900]         base::sink(type = "output", split = FALSE)
[16:11:22.900]         if (NA) {
[16:11:22.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:22.900]         }
[16:11:22.900]         else {
[16:11:22.900]             ...future.result["stdout"] <- base::list(NULL)
[16:11:22.900]         }
[16:11:22.900]         base::close(...future.stdout)
[16:11:22.900]         ...future.stdout <- NULL
[16:11:22.900]     }
[16:11:22.900]     ...future.result$conditions <- ...future.conditions
[16:11:22.900]     ...future.result$finished <- base::Sys.time()
[16:11:22.900]     ...future.result
[16:11:22.900] }
[16:11:22.903] assign_globals() ...
[16:11:22.903] List of 5
[16:11:22.903]  $ ...future.FUN            :function (x)  
[16:11:22.903]  $ future.call.arguments    : list()
[16:11:22.903]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:22.903]  $ ...future.elements_ii    :List of 1
[16:11:22.903]   ..$ : int 1
[16:11:22.903]  $ ...future.seeds_ii       : NULL
[16:11:22.903]  $ ...future.globals.maxSize: NULL
[16:11:22.903]  - attr(*, "where")=List of 5
[16:11:22.903]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:22.903]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:22.903]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:22.903]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:22.903]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:22.903]  - attr(*, "resolved")= logi FALSE
[16:11:22.903]  - attr(*, "total_size")= num 4720
[16:11:22.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:22.903]  - attr(*, "already-done")= logi TRUE
[16:11:22.907] - reassign environment for ‘...future.FUN’
[16:11:22.907] - copied ‘...future.FUN’ to environment
[16:11:22.908] - copied ‘future.call.arguments’ to environment
[16:11:22.908] - copied ‘...future.elements_ii’ to environment
[16:11:22.908] - copied ‘...future.seeds_ii’ to environment
[16:11:22.908] - copied ‘...future.globals.maxSize’ to environment
[16:11:22.908] assign_globals() ... done
[16:11:22.908] requestCore(): workers = 2
[16:11:22.910] MulticoreFuture started
[16:11:22.911] - Launch lazy future ... done
[16:11:22.911] run() for ‘MulticoreFuture’ ... done
[16:11:22.911] Created future:
[16:11:22.911] plan(): Setting new future strategy stack:
[16:11:22.912] List of future strategies:
[16:11:22.912] 1. sequential:
[16:11:22.912]    - args: function (..., envir = parent.frame())
[16:11:22.912]    - tweaked: FALSE
[16:11:22.912]    - call: NULL
[16:11:22.913] plan(): nbrOfWorkers() = 1
[16:11:22.911] MulticoreFuture:
[16:11:22.911] Label: ‘future_lapply-1’
[16:11:22.911] Expression:
[16:11:22.911] {
[16:11:22.911]     do.call(function(...) {
[16:11:22.911]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.911]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:22.911]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.911]             on.exit(options(oopts), add = TRUE)
[16:11:22.911]         }
[16:11:22.911]         {
[16:11:22.911]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:22.911]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.911]                 ...future.FUN(...future.X_jj, ...)
[16:11:22.911]             })
[16:11:22.911]         }
[16:11:22.911]     }, args = future.call.arguments)
[16:11:22.911] }
[16:11:22.911] Lazy evaluation: FALSE
[16:11:22.911] Asynchronous evaluation: TRUE
[16:11:22.911] Local evaluation: TRUE
[16:11:22.911] Environment: R_GlobalEnv
[16:11:22.911] Capture standard output: NA
[16:11:22.911] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:22.911] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:22.911] Packages: <none>
[16:11:22.911] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:22.911] Resolved: FALSE
[16:11:22.911] Value: <not collected>
[16:11:22.911] Conditions captured: <none>
[16:11:22.911] Early signaling: FALSE
[16:11:22.911] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:22.911] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:22.924] Chunk #1 of 2 ... DONE
[16:11:22.924] Chunk #2 of 2 ...
[16:11:22.925]  - Finding globals in 'X' for chunk #2 ...
[16:11:22.925] getGlobalsAndPackages() ...
[16:11:22.925] Searching for globals...
[16:11:22.925] 
[16:11:22.926] Searching for globals ... DONE
[16:11:22.926] - globals: [0] <none>
[16:11:22.926] getGlobalsAndPackages() ... DONE
[16:11:22.926]    + additional globals found: [n=0] 
[16:11:22.926]    + additional namespaces needed: [n=0] 
[16:11:22.926]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:22.926]  - seeds: <none>
[16:11:22.927] getGlobalsAndPackages() ...
[16:11:22.927] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:22.927] Resolving globals: FALSE
[16:11:22.927] Tweak future expression to call with '...' arguments ...
[16:11:22.927] {
[16:11:22.927]     do.call(function(...) {
[16:11:22.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:22.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.927]             on.exit(options(oopts), add = TRUE)
[16:11:22.927]         }
[16:11:22.927]         {
[16:11:22.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:22.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.927]                 ...future.FUN(...future.X_jj, ...)
[16:11:22.927]             })
[16:11:22.927]         }
[16:11:22.927]     }, args = future.call.arguments)
[16:11:22.927] }
[16:11:22.928] Tweak future expression to call with '...' arguments ... DONE
[16:11:22.928] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:22.929] 
[16:11:22.929] getGlobalsAndPackages() ... DONE
[16:11:22.929] run() for ‘Future’ ...
[16:11:22.930] - state: ‘created’
[16:11:22.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:22.935] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:22.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:22.935]   - Field: ‘label’
[16:11:22.936]   - Field: ‘local’
[16:11:22.936]   - Field: ‘owner’
[16:11:22.936]   - Field: ‘envir’
[16:11:22.936]   - Field: ‘workers’
[16:11:22.936]   - Field: ‘packages’
[16:11:22.936]   - Field: ‘gc’
[16:11:22.937]   - Field: ‘job’
[16:11:22.937]   - Field: ‘conditions’
[16:11:22.937]   - Field: ‘expr’
[16:11:22.937]   - Field: ‘uuid’
[16:11:22.937]   - Field: ‘seed’
[16:11:22.937]   - Field: ‘version’
[16:11:22.937]   - Field: ‘result’
[16:11:22.938]   - Field: ‘asynchronous’
[16:11:22.938]   - Field: ‘calls’
[16:11:22.938]   - Field: ‘globals’
[16:11:22.938]   - Field: ‘stdout’
[16:11:22.938]   - Field: ‘earlySignal’
[16:11:22.938]   - Field: ‘lazy’
[16:11:22.938]   - Field: ‘state’
[16:11:22.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:22.939] - Launch lazy future ...
[16:11:22.939] Packages needed by the future expression (n = 0): <none>
[16:11:22.939] Packages needed by future strategies (n = 0): <none>
[16:11:22.940] {
[16:11:22.940]     {
[16:11:22.940]         {
[16:11:22.940]             ...future.startTime <- base::Sys.time()
[16:11:22.940]             {
[16:11:22.940]                 {
[16:11:22.940]                   {
[16:11:22.940]                     {
[16:11:22.940]                       base::local({
[16:11:22.940]                         has_future <- base::requireNamespace("future", 
[16:11:22.940]                           quietly = TRUE)
[16:11:22.940]                         if (has_future) {
[16:11:22.940]                           ns <- base::getNamespace("future")
[16:11:22.940]                           version <- ns[[".package"]][["version"]]
[16:11:22.940]                           if (is.null(version)) 
[16:11:22.940]                             version <- utils::packageVersion("future")
[16:11:22.940]                         }
[16:11:22.940]                         else {
[16:11:22.940]                           version <- NULL
[16:11:22.940]                         }
[16:11:22.940]                         if (!has_future || version < "1.8.0") {
[16:11:22.940]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:22.940]                             "", base::R.version$version.string), 
[16:11:22.940]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:22.940]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:22.940]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:22.940]                               "release", "version")], collapse = " "), 
[16:11:22.940]                             hostname = base::Sys.info()[["nodename"]])
[16:11:22.940]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:22.940]                             info)
[16:11:22.940]                           info <- base::paste(info, collapse = "; ")
[16:11:22.940]                           if (!has_future) {
[16:11:22.940]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:22.940]                               info)
[16:11:22.940]                           }
[16:11:22.940]                           else {
[16:11:22.940]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:22.940]                               info, version)
[16:11:22.940]                           }
[16:11:22.940]                           base::stop(msg)
[16:11:22.940]                         }
[16:11:22.940]                       })
[16:11:22.940]                     }
[16:11:22.940]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:22.940]                     base::options(mc.cores = 1L)
[16:11:22.940]                   }
[16:11:22.940]                   options(future.plan = NULL)
[16:11:22.940]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:22.940]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:22.940]                 }
[16:11:22.940]                 ...future.workdir <- getwd()
[16:11:22.940]             }
[16:11:22.940]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:22.940]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:22.940]         }
[16:11:22.940]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:22.940]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:22.940]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:22.940]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:22.940]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:22.940]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:22.940]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:22.940]             base::names(...future.oldOptions))
[16:11:22.940]     }
[16:11:22.940]     if (TRUE) {
[16:11:22.940]     }
[16:11:22.940]     else {
[16:11:22.940]         if (NA) {
[16:11:22.940]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:22.940]                 open = "w")
[16:11:22.940]         }
[16:11:22.940]         else {
[16:11:22.940]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:22.940]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:22.940]         }
[16:11:22.940]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:22.940]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:22.940]             base::sink(type = "output", split = FALSE)
[16:11:22.940]             base::close(...future.stdout)
[16:11:22.940]         }, add = TRUE)
[16:11:22.940]     }
[16:11:22.940]     ...future.frame <- base::sys.nframe()
[16:11:22.940]     ...future.conditions <- base::list()
[16:11:22.940]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:22.940]     if (FALSE) {
[16:11:22.940]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:22.940]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:22.940]     }
[16:11:22.940]     ...future.result <- base::tryCatch({
[16:11:22.940]         base::withCallingHandlers({
[16:11:22.940]             ...future.value <- base::withVisible(base::local({
[16:11:22.940]                 withCallingHandlers({
[16:11:22.940]                   {
[16:11:22.940]                     do.call(function(...) {
[16:11:22.940]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.940]                       if (!identical(...future.globals.maxSize.org, 
[16:11:22.940]                         ...future.globals.maxSize)) {
[16:11:22.940]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.940]                         on.exit(options(oopts), add = TRUE)
[16:11:22.940]                       }
[16:11:22.940]                       {
[16:11:22.940]                         lapply(seq_along(...future.elements_ii), 
[16:11:22.940]                           FUN = function(jj) {
[16:11:22.940]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.940]                             ...future.FUN(...future.X_jj, ...)
[16:11:22.940]                           })
[16:11:22.940]                       }
[16:11:22.940]                     }, args = future.call.arguments)
[16:11:22.940]                   }
[16:11:22.940]                 }, immediateCondition = function(cond) {
[16:11:22.940]                   save_rds <- function (object, pathname, ...) 
[16:11:22.940]                   {
[16:11:22.940]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:22.940]                     if (file_test("-f", pathname_tmp)) {
[16:11:22.940]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.940]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:22.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.940]                         fi_tmp[["mtime"]])
[16:11:22.940]                     }
[16:11:22.940]                     tryCatch({
[16:11:22.940]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:22.940]                     }, error = function(ex) {
[16:11:22.940]                       msg <- conditionMessage(ex)
[16:11:22.940]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.940]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:22.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.940]                         fi_tmp[["mtime"]], msg)
[16:11:22.940]                       ex$message <- msg
[16:11:22.940]                       stop(ex)
[16:11:22.940]                     })
[16:11:22.940]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:22.940]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:22.940]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:22.940]                       fi_tmp <- file.info(pathname_tmp)
[16:11:22.940]                       fi <- file.info(pathname)
[16:11:22.940]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:22.940]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:22.940]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:22.940]                         fi[["size"]], fi[["mtime"]])
[16:11:22.940]                       stop(msg)
[16:11:22.940]                     }
[16:11:22.940]                     invisible(pathname)
[16:11:22.940]                   }
[16:11:22.940]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:22.940]                     rootPath = tempdir()) 
[16:11:22.940]                   {
[16:11:22.940]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:22.940]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:22.940]                       tmpdir = path, fileext = ".rds")
[16:11:22.940]                     save_rds(obj, file)
[16:11:22.940]                   }
[16:11:22.940]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:22.940]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.940]                   {
[16:11:22.940]                     inherits <- base::inherits
[16:11:22.940]                     invokeRestart <- base::invokeRestart
[16:11:22.940]                     is.null <- base::is.null
[16:11:22.940]                     muffled <- FALSE
[16:11:22.940]                     if (inherits(cond, "message")) {
[16:11:22.940]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:22.940]                       if (muffled) 
[16:11:22.940]                         invokeRestart("muffleMessage")
[16:11:22.940]                     }
[16:11:22.940]                     else if (inherits(cond, "warning")) {
[16:11:22.940]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:22.940]                       if (muffled) 
[16:11:22.940]                         invokeRestart("muffleWarning")
[16:11:22.940]                     }
[16:11:22.940]                     else if (inherits(cond, "condition")) {
[16:11:22.940]                       if (!is.null(pattern)) {
[16:11:22.940]                         computeRestarts <- base::computeRestarts
[16:11:22.940]                         grepl <- base::grepl
[16:11:22.940]                         restarts <- computeRestarts(cond)
[16:11:22.940]                         for (restart in restarts) {
[16:11:22.940]                           name <- restart$name
[16:11:22.940]                           if (is.null(name)) 
[16:11:22.940]                             next
[16:11:22.940]                           if (!grepl(pattern, name)) 
[16:11:22.940]                             next
[16:11:22.940]                           invokeRestart(restart)
[16:11:22.940]                           muffled <- TRUE
[16:11:22.940]                           break
[16:11:22.940]                         }
[16:11:22.940]                       }
[16:11:22.940]                     }
[16:11:22.940]                     invisible(muffled)
[16:11:22.940]                   }
[16:11:22.940]                   muffleCondition(cond)
[16:11:22.940]                 })
[16:11:22.940]             }))
[16:11:22.940]             future::FutureResult(value = ...future.value$value, 
[16:11:22.940]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:22.940]                   ...future.rng), globalenv = if (FALSE) 
[16:11:22.940]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:22.940]                     ...future.globalenv.names))
[16:11:22.940]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:22.940]         }, condition = base::local({
[16:11:22.940]             c <- base::c
[16:11:22.940]             inherits <- base::inherits
[16:11:22.940]             invokeRestart <- base::invokeRestart
[16:11:22.940]             length <- base::length
[16:11:22.940]             list <- base::list
[16:11:22.940]             seq.int <- base::seq.int
[16:11:22.940]             signalCondition <- base::signalCondition
[16:11:22.940]             sys.calls <- base::sys.calls
[16:11:22.940]             `[[` <- base::`[[`
[16:11:22.940]             `+` <- base::`+`
[16:11:22.940]             `<<-` <- base::`<<-`
[16:11:22.940]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:22.940]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:22.940]                   3L)]
[16:11:22.940]             }
[16:11:22.940]             function(cond) {
[16:11:22.940]                 is_error <- inherits(cond, "error")
[16:11:22.940]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:22.940]                   NULL)
[16:11:22.940]                 if (is_error) {
[16:11:22.940]                   sessionInformation <- function() {
[16:11:22.940]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:22.940]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:22.940]                       search = base::search(), system = base::Sys.info())
[16:11:22.940]                   }
[16:11:22.940]                   ...future.conditions[[length(...future.conditions) + 
[16:11:22.940]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:22.940]                     cond$call), session = sessionInformation(), 
[16:11:22.940]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:22.940]                   signalCondition(cond)
[16:11:22.940]                 }
[16:11:22.940]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:22.940]                 "immediateCondition"))) {
[16:11:22.940]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:22.940]                   ...future.conditions[[length(...future.conditions) + 
[16:11:22.940]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:22.940]                   if (TRUE && !signal) {
[16:11:22.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.940]                     {
[16:11:22.940]                       inherits <- base::inherits
[16:11:22.940]                       invokeRestart <- base::invokeRestart
[16:11:22.940]                       is.null <- base::is.null
[16:11:22.940]                       muffled <- FALSE
[16:11:22.940]                       if (inherits(cond, "message")) {
[16:11:22.940]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:22.940]                         if (muffled) 
[16:11:22.940]                           invokeRestart("muffleMessage")
[16:11:22.940]                       }
[16:11:22.940]                       else if (inherits(cond, "warning")) {
[16:11:22.940]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:22.940]                         if (muffled) 
[16:11:22.940]                           invokeRestart("muffleWarning")
[16:11:22.940]                       }
[16:11:22.940]                       else if (inherits(cond, "condition")) {
[16:11:22.940]                         if (!is.null(pattern)) {
[16:11:22.940]                           computeRestarts <- base::computeRestarts
[16:11:22.940]                           grepl <- base::grepl
[16:11:22.940]                           restarts <- computeRestarts(cond)
[16:11:22.940]                           for (restart in restarts) {
[16:11:22.940]                             name <- restart$name
[16:11:22.940]                             if (is.null(name)) 
[16:11:22.940]                               next
[16:11:22.940]                             if (!grepl(pattern, name)) 
[16:11:22.940]                               next
[16:11:22.940]                             invokeRestart(restart)
[16:11:22.940]                             muffled <- TRUE
[16:11:22.940]                             break
[16:11:22.940]                           }
[16:11:22.940]                         }
[16:11:22.940]                       }
[16:11:22.940]                       invisible(muffled)
[16:11:22.940]                     }
[16:11:22.940]                     muffleCondition(cond, pattern = "^muffle")
[16:11:22.940]                   }
[16:11:22.940]                 }
[16:11:22.940]                 else {
[16:11:22.940]                   if (TRUE) {
[16:11:22.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:22.940]                     {
[16:11:22.940]                       inherits <- base::inherits
[16:11:22.940]                       invokeRestart <- base::invokeRestart
[16:11:22.940]                       is.null <- base::is.null
[16:11:22.940]                       muffled <- FALSE
[16:11:22.940]                       if (inherits(cond, "message")) {
[16:11:22.940]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:22.940]                         if (muffled) 
[16:11:22.940]                           invokeRestart("muffleMessage")
[16:11:22.940]                       }
[16:11:22.940]                       else if (inherits(cond, "warning")) {
[16:11:22.940]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:22.940]                         if (muffled) 
[16:11:22.940]                           invokeRestart("muffleWarning")
[16:11:22.940]                       }
[16:11:22.940]                       else if (inherits(cond, "condition")) {
[16:11:22.940]                         if (!is.null(pattern)) {
[16:11:22.940]                           computeRestarts <- base::computeRestarts
[16:11:22.940]                           grepl <- base::grepl
[16:11:22.940]                           restarts <- computeRestarts(cond)
[16:11:22.940]                           for (restart in restarts) {
[16:11:22.940]                             name <- restart$name
[16:11:22.940]                             if (is.null(name)) 
[16:11:22.940]                               next
[16:11:22.940]                             if (!grepl(pattern, name)) 
[16:11:22.940]                               next
[16:11:22.940]                             invokeRestart(restart)
[16:11:22.940]                             muffled <- TRUE
[16:11:22.940]                             break
[16:11:22.940]                           }
[16:11:22.940]                         }
[16:11:22.940]                       }
[16:11:22.940]                       invisible(muffled)
[16:11:22.940]                     }
[16:11:22.940]                     muffleCondition(cond, pattern = "^muffle")
[16:11:22.940]                   }
[16:11:22.940]                 }
[16:11:22.940]             }
[16:11:22.940]         }))
[16:11:22.940]     }, error = function(ex) {
[16:11:22.940]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:22.940]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:22.940]                 ...future.rng), started = ...future.startTime, 
[16:11:22.940]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:22.940]             version = "1.8"), class = "FutureResult")
[16:11:22.940]     }, finally = {
[16:11:22.940]         if (!identical(...future.workdir, getwd())) 
[16:11:22.940]             setwd(...future.workdir)
[16:11:22.940]         {
[16:11:22.940]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:22.940]                 ...future.oldOptions$nwarnings <- NULL
[16:11:22.940]             }
[16:11:22.940]             base::options(...future.oldOptions)
[16:11:22.940]             if (.Platform$OS.type == "windows") {
[16:11:22.940]                 old_names <- names(...future.oldEnvVars)
[16:11:22.940]                 envs <- base::Sys.getenv()
[16:11:22.940]                 names <- names(envs)
[16:11:22.940]                 common <- intersect(names, old_names)
[16:11:22.940]                 added <- setdiff(names, old_names)
[16:11:22.940]                 removed <- setdiff(old_names, names)
[16:11:22.940]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:22.940]                   envs[common]]
[16:11:22.940]                 NAMES <- toupper(changed)
[16:11:22.940]                 args <- list()
[16:11:22.940]                 for (kk in seq_along(NAMES)) {
[16:11:22.940]                   name <- changed[[kk]]
[16:11:22.940]                   NAME <- NAMES[[kk]]
[16:11:22.940]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.940]                     next
[16:11:22.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:22.940]                 }
[16:11:22.940]                 NAMES <- toupper(added)
[16:11:22.940]                 for (kk in seq_along(NAMES)) {
[16:11:22.940]                   name <- added[[kk]]
[16:11:22.940]                   NAME <- NAMES[[kk]]
[16:11:22.940]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.940]                     next
[16:11:22.940]                   args[[name]] <- ""
[16:11:22.940]                 }
[16:11:22.940]                 NAMES <- toupper(removed)
[16:11:22.940]                 for (kk in seq_along(NAMES)) {
[16:11:22.940]                   name <- removed[[kk]]
[16:11:22.940]                   NAME <- NAMES[[kk]]
[16:11:22.940]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:22.940]                     next
[16:11:22.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:22.940]                 }
[16:11:22.940]                 if (length(args) > 0) 
[16:11:22.940]                   base::do.call(base::Sys.setenv, args = args)
[16:11:22.940]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:22.940]             }
[16:11:22.940]             else {
[16:11:22.940]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:22.940]             }
[16:11:22.940]             {
[16:11:22.940]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:22.940]                   0L) {
[16:11:22.940]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:22.940]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:22.940]                   base::options(opts)
[16:11:22.940]                 }
[16:11:22.940]                 {
[16:11:22.940]                   {
[16:11:22.940]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:22.940]                     NULL
[16:11:22.940]                   }
[16:11:22.940]                   options(future.plan = NULL)
[16:11:22.940]                   if (is.na(NA_character_)) 
[16:11:22.940]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:22.940]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:22.940]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:22.940]                     envir = parent.frame()) 
[16:11:22.940]                   {
[16:11:22.940]                     default_workers <- missing(workers)
[16:11:22.940]                     if (is.function(workers)) 
[16:11:22.940]                       workers <- workers()
[16:11:22.940]                     workers <- structure(as.integer(workers), 
[16:11:22.940]                       class = class(workers))
[16:11:22.940]                     stop_if_not(is.finite(workers), workers >= 
[16:11:22.940]                       1L)
[16:11:22.940]                     if ((workers == 1L && !inherits(workers, 
[16:11:22.940]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:22.940]                       if (default_workers) 
[16:11:22.940]                         supportsMulticore(warn = TRUE)
[16:11:22.940]                       return(sequential(..., envir = envir))
[16:11:22.940]                     }
[16:11:22.940]                     oopts <- options(mc.cores = workers)
[16:11:22.940]                     on.exit(options(oopts))
[16:11:22.940]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:22.940]                       envir = envir)
[16:11:22.940]                     if (!future$lazy) 
[16:11:22.940]                       future <- run(future)
[16:11:22.940]                     invisible(future)
[16:11:22.940]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:22.940]                 }
[16:11:22.940]             }
[16:11:22.940]         }
[16:11:22.940]     })
[16:11:22.940]     if (FALSE) {
[16:11:22.940]         base::sink(type = "output", split = FALSE)
[16:11:22.940]         if (NA) {
[16:11:22.940]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:22.940]         }
[16:11:22.940]         else {
[16:11:22.940]             ...future.result["stdout"] <- base::list(NULL)
[16:11:22.940]         }
[16:11:22.940]         base::close(...future.stdout)
[16:11:22.940]         ...future.stdout <- NULL
[16:11:22.940]     }
[16:11:22.940]     ...future.result$conditions <- ...future.conditions
[16:11:22.940]     ...future.result$finished <- base::Sys.time()
[16:11:22.940]     ...future.result
[16:11:22.940] }
[16:11:22.943] assign_globals() ...
[16:11:22.943] List of 5
[16:11:22.943]  $ ...future.FUN            :function (x)  
[16:11:22.943]  $ future.call.arguments    : list()
[16:11:22.943]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:22.943]  $ ...future.elements_ii    :List of 1
[16:11:22.943]   ..$ : int 0
[16:11:22.943]  $ ...future.seeds_ii       : NULL
[16:11:22.943]  $ ...future.globals.maxSize: NULL
[16:11:22.943]  - attr(*, "where")=List of 5
[16:11:22.943]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:22.943]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:22.943]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:22.943]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:22.943]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:22.943]  - attr(*, "resolved")= logi FALSE
[16:11:22.943]  - attr(*, "total_size")= num 4720
[16:11:22.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:22.943]  - attr(*, "already-done")= logi TRUE
[16:11:22.956] - reassign environment for ‘...future.FUN’
[16:11:22.956] - copied ‘...future.FUN’ to environment
[16:11:22.956] - copied ‘future.call.arguments’ to environment
[16:11:22.957] - copied ‘...future.elements_ii’ to environment
[16:11:22.957] - copied ‘...future.seeds_ii’ to environment
[16:11:22.957] - copied ‘...future.globals.maxSize’ to environment
[16:11:22.957] assign_globals() ... done
[16:11:22.957] requestCore(): workers = 2
[16:11:22.959] MulticoreFuture started
[16:11:22.960] - Launch lazy future ... done
[16:11:22.960] run() for ‘MulticoreFuture’ ... done
[16:11:22.960] Created future:
[16:11:22.961] plan(): Setting new future strategy stack:
[16:11:22.961] List of future strategies:
[16:11:22.961] 1. sequential:
[16:11:22.961]    - args: function (..., envir = parent.frame())
[16:11:22.961]    - tweaked: FALSE
[16:11:22.961]    - call: NULL
[16:11:22.962] plan(): nbrOfWorkers() = 1
[16:11:22.964] plan(): Setting new future strategy stack:
[16:11:22.964] List of future strategies:
[16:11:22.964] 1. multicore:
[16:11:22.964]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:22.964]    - tweaked: FALSE
[16:11:22.964]    - call: plan(strategy)
[16:11:22.969] plan(): nbrOfWorkers() = 2
[16:11:22.961] MulticoreFuture:
[16:11:22.961] Label: ‘future_lapply-2’
[16:11:22.961] Expression:
[16:11:22.961] {
[16:11:22.961]     do.call(function(...) {
[16:11:22.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:22.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:22.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:22.961]             on.exit(options(oopts), add = TRUE)
[16:11:22.961]         }
[16:11:22.961]         {
[16:11:22.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:22.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:22.961]                 ...future.FUN(...future.X_jj, ...)
[16:11:22.961]             })
[16:11:22.961]         }
[16:11:22.961]     }, args = future.call.arguments)
[16:11:22.961] }
[16:11:22.961] Lazy evaluation: FALSE
[16:11:22.961] Asynchronous evaluation: TRUE
[16:11:22.961] Local evaluation: TRUE
[16:11:22.961] Environment: R_GlobalEnv
[16:11:22.961] Capture standard output: NA
[16:11:22.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:22.961] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:22.961] Packages: <none>
[16:11:22.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:22.961] Resolved: TRUE
[16:11:22.961] Value: <not collected>
[16:11:22.961] Conditions captured: <none>
[16:11:22.961] Early signaling: FALSE
[16:11:22.961] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:22.961] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:22.970] Chunk #2 of 2 ... DONE
[16:11:22.970] Launching 2 futures (chunks) ... DONE
[16:11:22.971] Resolving 2 futures (chunks) ...
[16:11:22.971] resolve() on list ...
[16:11:22.971]  recursive: 0
[16:11:22.971]  length: 2
[16:11:22.971] 
[16:11:22.982] Future #2
[16:11:22.983] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:22.983] - nx: 2
[16:11:22.983] - relay: TRUE
[16:11:22.983] - stdout: TRUE
[16:11:22.984] - signal: TRUE
[16:11:22.984] - resignal: FALSE
[16:11:22.984] - force: TRUE
[16:11:22.984] - relayed: [n=2] FALSE, FALSE
[16:11:22.984] - queued futures: [n=2] FALSE, FALSE
[16:11:22.984]  - until=1
[16:11:22.984]  - relaying element #1
[16:11:22.985] - relayed: [n=2] FALSE, FALSE
[16:11:22.985] - queued futures: [n=2] FALSE, TRUE
[16:11:22.985] signalConditionsASAP(NULL, pos=2) ... done
[16:11:22.985]  length: 1 (resolved future 2)
[16:11:23.415] plan(): Setting new future strategy stack:
[16:11:23.415] List of future strategies:
[16:11:23.415] 1. multicore:
[16:11:23.415]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:23.415]    - tweaked: FALSE
[16:11:23.415]    - call: plan(strategy)
[16:11:23.420] plan(): nbrOfWorkers() = 2
[16:11:23.423] Future #1
[16:11:23.424] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:23.424] - nx: 2
[16:11:23.424] - relay: TRUE
[16:11:23.425] - stdout: TRUE
[16:11:23.425] - signal: TRUE
[16:11:23.425] - resignal: FALSE
[16:11:23.425] - force: TRUE
[16:11:23.425] - relayed: [n=2] FALSE, FALSE
[16:11:23.425] - queued futures: [n=2] FALSE, TRUE
[16:11:23.425]  - until=1
[16:11:23.425]  - relaying element #1
[16:11:23.426] - relayed: [n=2] TRUE, FALSE
[16:11:23.426] - queued futures: [n=2] TRUE, TRUE
[16:11:23.426] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:23.426]  length: 0 (resolved future 1)
[16:11:23.426] Relaying remaining futures
[16:11:23.426] signalConditionsASAP(NULL, pos=0) ...
[16:11:23.426] - nx: 2
[16:11:23.426] - relay: TRUE
[16:11:23.426] - stdout: TRUE
[16:11:23.427] - signal: TRUE
[16:11:23.427] - resignal: FALSE
[16:11:23.427] - force: TRUE
[16:11:23.427] - relayed: [n=2] TRUE, FALSE
[16:11:23.427] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:23.427]  - relaying element #2
[16:11:23.427] - relayed: [n=2] TRUE, TRUE
[16:11:23.428] - queued futures: [n=2] TRUE, TRUE
[16:11:23.428] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:11:23.428] resolve() on list ... DONE
[16:11:23.428]  - Number of value chunks collected: 2
[16:11:23.428] Resolving 2 futures (chunks) ... DONE
[16:11:23.428] Reducing values from 2 chunks ...
[16:11:23.428]  - Number of values collected after concatenation: 2
[16:11:23.428]  - Number of values expected: 2
[16:11:23.429] Reducing values from 2 chunks ... DONE
[16:11:23.429] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:11:23.429] future_mapply() ...
[16:11:23.434] Number of chunks: 2
[16:11:23.434] getGlobalsAndPackagesXApply() ...
[16:11:23.434]  - future.globals: TRUE
[16:11:23.434] getGlobalsAndPackages() ...
[16:11:23.434] Searching for globals...
[16:11:23.436] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:23.436] Searching for globals ... DONE
[16:11:23.436] Resolving globals: FALSE
[16:11:23.437] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:23.437] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:23.437] - globals: [1] ‘FUN’
[16:11:23.438] 
[16:11:23.438] getGlobalsAndPackages() ... DONE
[16:11:23.440]  - globals found/used: [n=1] ‘FUN’
[16:11:23.440]  - needed namespaces: [n=0] 
[16:11:23.440] Finding globals ... DONE
[16:11:23.440] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:23.440] List of 2
[16:11:23.440]  $ ...future.FUN:function (x, y)  
[16:11:23.440]  $ MoreArgs     : NULL
[16:11:23.440]  - attr(*, "where")=List of 2
[16:11:23.440]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:23.440]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:23.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:23.440]  - attr(*, "resolved")= logi FALSE
[16:11:23.440]  - attr(*, "total_size")= num NA
[16:11:23.444] Packages to be attached in all futures: [n=0] 
[16:11:23.444] getGlobalsAndPackagesXApply() ... DONE
[16:11:23.444] Number of futures (= number of chunks): 2
[16:11:23.445] Launching 2 futures (chunks) ...
[16:11:23.445] Chunk #1 of 2 ...
[16:11:23.445]  - Finding globals in '...' for chunk #1 ...
[16:11:23.445] getGlobalsAndPackages() ...
[16:11:23.445] Searching for globals...
[16:11:23.446] 
[16:11:23.446] Searching for globals ... DONE
[16:11:23.446] - globals: [0] <none>
[16:11:23.446] getGlobalsAndPackages() ... DONE
[16:11:23.446]    + additional globals found: [n=0] 
[16:11:23.446]    + additional namespaces needed: [n=0] 
[16:11:23.446]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:23.446]  - seeds: <none>
[16:11:23.447] getGlobalsAndPackages() ...
[16:11:23.447] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:23.447] Resolving globals: FALSE
[16:11:23.447] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:23.448] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:23.448] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:23.448] 
[16:11:23.448] getGlobalsAndPackages() ... DONE
[16:11:23.448] run() for ‘Future’ ...
[16:11:23.449] - state: ‘created’
[16:11:23.449] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:23.452] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:23.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:23.452]   - Field: ‘label’
[16:11:23.453]   - Field: ‘local’
[16:11:23.453]   - Field: ‘owner’
[16:11:23.453]   - Field: ‘envir’
[16:11:23.453]   - Field: ‘workers’
[16:11:23.453]   - Field: ‘packages’
[16:11:23.453]   - Field: ‘gc’
[16:11:23.453]   - Field: ‘job’
[16:11:23.453]   - Field: ‘conditions’
[16:11:23.453]   - Field: ‘expr’
[16:11:23.453]   - Field: ‘uuid’
[16:11:23.453]   - Field: ‘seed’
[16:11:23.454]   - Field: ‘version’
[16:11:23.454]   - Field: ‘result’
[16:11:23.454]   - Field: ‘asynchronous’
[16:11:23.454]   - Field: ‘calls’
[16:11:23.454]   - Field: ‘globals’
[16:11:23.454]   - Field: ‘stdout’
[16:11:23.454]   - Field: ‘earlySignal’
[16:11:23.454]   - Field: ‘lazy’
[16:11:23.454]   - Field: ‘state’
[16:11:23.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:23.455] - Launch lazy future ...
[16:11:23.455] Packages needed by the future expression (n = 0): <none>
[16:11:23.455] Packages needed by future strategies (n = 0): <none>
[16:11:23.455] {
[16:11:23.455]     {
[16:11:23.455]         {
[16:11:23.455]             ...future.startTime <- base::Sys.time()
[16:11:23.455]             {
[16:11:23.455]                 {
[16:11:23.455]                   {
[16:11:23.455]                     {
[16:11:23.455]                       base::local({
[16:11:23.455]                         has_future <- base::requireNamespace("future", 
[16:11:23.455]                           quietly = TRUE)
[16:11:23.455]                         if (has_future) {
[16:11:23.455]                           ns <- base::getNamespace("future")
[16:11:23.455]                           version <- ns[[".package"]][["version"]]
[16:11:23.455]                           if (is.null(version)) 
[16:11:23.455]                             version <- utils::packageVersion("future")
[16:11:23.455]                         }
[16:11:23.455]                         else {
[16:11:23.455]                           version <- NULL
[16:11:23.455]                         }
[16:11:23.455]                         if (!has_future || version < "1.8.0") {
[16:11:23.455]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:23.455]                             "", base::R.version$version.string), 
[16:11:23.455]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:23.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:23.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:23.455]                               "release", "version")], collapse = " "), 
[16:11:23.455]                             hostname = base::Sys.info()[["nodename"]])
[16:11:23.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:23.455]                             info)
[16:11:23.455]                           info <- base::paste(info, collapse = "; ")
[16:11:23.455]                           if (!has_future) {
[16:11:23.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:23.455]                               info)
[16:11:23.455]                           }
[16:11:23.455]                           else {
[16:11:23.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:23.455]                               info, version)
[16:11:23.455]                           }
[16:11:23.455]                           base::stop(msg)
[16:11:23.455]                         }
[16:11:23.455]                       })
[16:11:23.455]                     }
[16:11:23.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:23.455]                     base::options(mc.cores = 1L)
[16:11:23.455]                   }
[16:11:23.455]                   options(future.plan = NULL)
[16:11:23.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:23.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:23.455]                 }
[16:11:23.455]                 ...future.workdir <- getwd()
[16:11:23.455]             }
[16:11:23.455]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:23.455]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:23.455]         }
[16:11:23.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:23.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:23.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:23.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:23.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:23.455]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:23.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:23.455]             base::names(...future.oldOptions))
[16:11:23.455]     }
[16:11:23.455]     if (FALSE) {
[16:11:23.455]     }
[16:11:23.455]     else {
[16:11:23.455]         if (FALSE) {
[16:11:23.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:23.455]                 open = "w")
[16:11:23.455]         }
[16:11:23.455]         else {
[16:11:23.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:23.455]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:23.455]         }
[16:11:23.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:23.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:23.455]             base::sink(type = "output", split = FALSE)
[16:11:23.455]             base::close(...future.stdout)
[16:11:23.455]         }, add = TRUE)
[16:11:23.455]     }
[16:11:23.455]     ...future.frame <- base::sys.nframe()
[16:11:23.455]     ...future.conditions <- base::list()
[16:11:23.455]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:23.455]     if (FALSE) {
[16:11:23.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:23.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:23.455]     }
[16:11:23.455]     ...future.result <- base::tryCatch({
[16:11:23.455]         base::withCallingHandlers({
[16:11:23.455]             ...future.value <- base::withVisible(base::local({
[16:11:23.455]                 withCallingHandlers({
[16:11:23.455]                   {
[16:11:23.455]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:23.455]                     if (!identical(...future.globals.maxSize.org, 
[16:11:23.455]                       ...future.globals.maxSize)) {
[16:11:23.455]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:23.455]                       on.exit(options(oopts), add = TRUE)
[16:11:23.455]                     }
[16:11:23.455]                     {
[16:11:23.455]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:23.455]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:23.455]                         USE.NAMES = FALSE)
[16:11:23.455]                       do.call(mapply, args = args)
[16:11:23.455]                     }
[16:11:23.455]                   }
[16:11:23.455]                 }, immediateCondition = function(cond) {
[16:11:23.455]                   save_rds <- function (object, pathname, ...) 
[16:11:23.455]                   {
[16:11:23.455]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:23.455]                     if (file_test("-f", pathname_tmp)) {
[16:11:23.455]                       fi_tmp <- file.info(pathname_tmp)
[16:11:23.455]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:23.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:23.455]                         fi_tmp[["mtime"]])
[16:11:23.455]                     }
[16:11:23.455]                     tryCatch({
[16:11:23.455]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:23.455]                     }, error = function(ex) {
[16:11:23.455]                       msg <- conditionMessage(ex)
[16:11:23.455]                       fi_tmp <- file.info(pathname_tmp)
[16:11:23.455]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:23.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:23.455]                         fi_tmp[["mtime"]], msg)
[16:11:23.455]                       ex$message <- msg
[16:11:23.455]                       stop(ex)
[16:11:23.455]                     })
[16:11:23.455]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:23.455]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:23.455]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:23.455]                       fi_tmp <- file.info(pathname_tmp)
[16:11:23.455]                       fi <- file.info(pathname)
[16:11:23.455]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:23.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:23.455]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:23.455]                         fi[["size"]], fi[["mtime"]])
[16:11:23.455]                       stop(msg)
[16:11:23.455]                     }
[16:11:23.455]                     invisible(pathname)
[16:11:23.455]                   }
[16:11:23.455]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:23.455]                     rootPath = tempdir()) 
[16:11:23.455]                   {
[16:11:23.455]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:23.455]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:23.455]                       tmpdir = path, fileext = ".rds")
[16:11:23.455]                     save_rds(obj, file)
[16:11:23.455]                   }
[16:11:23.455]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:23.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:23.455]                   {
[16:11:23.455]                     inherits <- base::inherits
[16:11:23.455]                     invokeRestart <- base::invokeRestart
[16:11:23.455]                     is.null <- base::is.null
[16:11:23.455]                     muffled <- FALSE
[16:11:23.455]                     if (inherits(cond, "message")) {
[16:11:23.455]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:23.455]                       if (muffled) 
[16:11:23.455]                         invokeRestart("muffleMessage")
[16:11:23.455]                     }
[16:11:23.455]                     else if (inherits(cond, "warning")) {
[16:11:23.455]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:23.455]                       if (muffled) 
[16:11:23.455]                         invokeRestart("muffleWarning")
[16:11:23.455]                     }
[16:11:23.455]                     else if (inherits(cond, "condition")) {
[16:11:23.455]                       if (!is.null(pattern)) {
[16:11:23.455]                         computeRestarts <- base::computeRestarts
[16:11:23.455]                         grepl <- base::grepl
[16:11:23.455]                         restarts <- computeRestarts(cond)
[16:11:23.455]                         for (restart in restarts) {
[16:11:23.455]                           name <- restart$name
[16:11:23.455]                           if (is.null(name)) 
[16:11:23.455]                             next
[16:11:23.455]                           if (!grepl(pattern, name)) 
[16:11:23.455]                             next
[16:11:23.455]                           invokeRestart(restart)
[16:11:23.455]                           muffled <- TRUE
[16:11:23.455]                           break
[16:11:23.455]                         }
[16:11:23.455]                       }
[16:11:23.455]                     }
[16:11:23.455]                     invisible(muffled)
[16:11:23.455]                   }
[16:11:23.455]                   muffleCondition(cond)
[16:11:23.455]                 })
[16:11:23.455]             }))
[16:11:23.455]             future::FutureResult(value = ...future.value$value, 
[16:11:23.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:23.455]                   ...future.rng), globalenv = if (FALSE) 
[16:11:23.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:23.455]                     ...future.globalenv.names))
[16:11:23.455]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:23.455]         }, condition = base::local({
[16:11:23.455]             c <- base::c
[16:11:23.455]             inherits <- base::inherits
[16:11:23.455]             invokeRestart <- base::invokeRestart
[16:11:23.455]             length <- base::length
[16:11:23.455]             list <- base::list
[16:11:23.455]             seq.int <- base::seq.int
[16:11:23.455]             signalCondition <- base::signalCondition
[16:11:23.455]             sys.calls <- base::sys.calls
[16:11:23.455]             `[[` <- base::`[[`
[16:11:23.455]             `+` <- base::`+`
[16:11:23.455]             `<<-` <- base::`<<-`
[16:11:23.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:23.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:23.455]                   3L)]
[16:11:23.455]             }
[16:11:23.455]             function(cond) {
[16:11:23.455]                 is_error <- inherits(cond, "error")
[16:11:23.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:23.455]                   NULL)
[16:11:23.455]                 if (is_error) {
[16:11:23.455]                   sessionInformation <- function() {
[16:11:23.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:23.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:23.455]                       search = base::search(), system = base::Sys.info())
[16:11:23.455]                   }
[16:11:23.455]                   ...future.conditions[[length(...future.conditions) + 
[16:11:23.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:23.455]                     cond$call), session = sessionInformation(), 
[16:11:23.455]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:23.455]                   signalCondition(cond)
[16:11:23.455]                 }
[16:11:23.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:23.455]                 "immediateCondition"))) {
[16:11:23.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:23.455]                   ...future.conditions[[length(...future.conditions) + 
[16:11:23.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:23.455]                   if (TRUE && !signal) {
[16:11:23.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:23.455]                     {
[16:11:23.455]                       inherits <- base::inherits
[16:11:23.455]                       invokeRestart <- base::invokeRestart
[16:11:23.455]                       is.null <- base::is.null
[16:11:23.455]                       muffled <- FALSE
[16:11:23.455]                       if (inherits(cond, "message")) {
[16:11:23.455]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:23.455]                         if (muffled) 
[16:11:23.455]                           invokeRestart("muffleMessage")
[16:11:23.455]                       }
[16:11:23.455]                       else if (inherits(cond, "warning")) {
[16:11:23.455]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:23.455]                         if (muffled) 
[16:11:23.455]                           invokeRestart("muffleWarning")
[16:11:23.455]                       }
[16:11:23.455]                       else if (inherits(cond, "condition")) {
[16:11:23.455]                         if (!is.null(pattern)) {
[16:11:23.455]                           computeRestarts <- base::computeRestarts
[16:11:23.455]                           grepl <- base::grepl
[16:11:23.455]                           restarts <- computeRestarts(cond)
[16:11:23.455]                           for (restart in restarts) {
[16:11:23.455]                             name <- restart$name
[16:11:23.455]                             if (is.null(name)) 
[16:11:23.455]                               next
[16:11:23.455]                             if (!grepl(pattern, name)) 
[16:11:23.455]                               next
[16:11:23.455]                             invokeRestart(restart)
[16:11:23.455]                             muffled <- TRUE
[16:11:23.455]                             break
[16:11:23.455]                           }
[16:11:23.455]                         }
[16:11:23.455]                       }
[16:11:23.455]                       invisible(muffled)
[16:11:23.455]                     }
[16:11:23.455]                     muffleCondition(cond, pattern = "^muffle")
[16:11:23.455]                   }
[16:11:23.455]                 }
[16:11:23.455]                 else {
[16:11:23.455]                   if (TRUE) {
[16:11:23.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:23.455]                     {
[16:11:23.455]                       inherits <- base::inherits
[16:11:23.455]                       invokeRestart <- base::invokeRestart
[16:11:23.455]                       is.null <- base::is.null
[16:11:23.455]                       muffled <- FALSE
[16:11:23.455]                       if (inherits(cond, "message")) {
[16:11:23.455]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:23.455]                         if (muffled) 
[16:11:23.455]                           invokeRestart("muffleMessage")
[16:11:23.455]                       }
[16:11:23.455]                       else if (inherits(cond, "warning")) {
[16:11:23.455]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:23.455]                         if (muffled) 
[16:11:23.455]                           invokeRestart("muffleWarning")
[16:11:23.455]                       }
[16:11:23.455]                       else if (inherits(cond, "condition")) {
[16:11:23.455]                         if (!is.null(pattern)) {
[16:11:23.455]                           computeRestarts <- base::computeRestarts
[16:11:23.455]                           grepl <- base::grepl
[16:11:23.455]                           restarts <- computeRestarts(cond)
[16:11:23.455]                           for (restart in restarts) {
[16:11:23.455]                             name <- restart$name
[16:11:23.455]                             if (is.null(name)) 
[16:11:23.455]                               next
[16:11:23.455]                             if (!grepl(pattern, name)) 
[16:11:23.455]                               next
[16:11:23.455]                             invokeRestart(restart)
[16:11:23.455]                             muffled <- TRUE
[16:11:23.455]                             break
[16:11:23.455]                           }
[16:11:23.455]                         }
[16:11:23.455]                       }
[16:11:23.455]                       invisible(muffled)
[16:11:23.455]                     }
[16:11:23.455]                     muffleCondition(cond, pattern = "^muffle")
[16:11:23.455]                   }
[16:11:23.455]                 }
[16:11:23.455]             }
[16:11:23.455]         }))
[16:11:23.455]     }, error = function(ex) {
[16:11:23.455]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:23.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:23.455]                 ...future.rng), started = ...future.startTime, 
[16:11:23.455]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:23.455]             version = "1.8"), class = "FutureResult")
[16:11:23.455]     }, finally = {
[16:11:23.455]         if (!identical(...future.workdir, getwd())) 
[16:11:23.455]             setwd(...future.workdir)
[16:11:23.455]         {
[16:11:23.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:23.455]                 ...future.oldOptions$nwarnings <- NULL
[16:11:23.455]             }
[16:11:23.455]             base::options(...future.oldOptions)
[16:11:23.455]             if (.Platform$OS.type == "windows") {
[16:11:23.455]                 old_names <- names(...future.oldEnvVars)
[16:11:23.455]                 envs <- base::Sys.getenv()
[16:11:23.455]                 names <- names(envs)
[16:11:23.455]                 common <- intersect(names, old_names)
[16:11:23.455]                 added <- setdiff(names, old_names)
[16:11:23.455]                 removed <- setdiff(old_names, names)
[16:11:23.455]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:23.455]                   envs[common]]
[16:11:23.455]                 NAMES <- toupper(changed)
[16:11:23.455]                 args <- list()
[16:11:23.455]                 for (kk in seq_along(NAMES)) {
[16:11:23.455]                   name <- changed[[kk]]
[16:11:23.455]                   NAME <- NAMES[[kk]]
[16:11:23.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:23.455]                     next
[16:11:23.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:23.455]                 }
[16:11:23.455]                 NAMES <- toupper(added)
[16:11:23.455]                 for (kk in seq_along(NAMES)) {
[16:11:23.455]                   name <- added[[kk]]
[16:11:23.455]                   NAME <- NAMES[[kk]]
[16:11:23.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:23.455]                     next
[16:11:23.455]                   args[[name]] <- ""
[16:11:23.455]                 }
[16:11:23.455]                 NAMES <- toupper(removed)
[16:11:23.455]                 for (kk in seq_along(NAMES)) {
[16:11:23.455]                   name <- removed[[kk]]
[16:11:23.455]                   NAME <- NAMES[[kk]]
[16:11:23.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:23.455]                     next
[16:11:23.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:23.455]                 }
[16:11:23.455]                 if (length(args) > 0) 
[16:11:23.455]                   base::do.call(base::Sys.setenv, args = args)
[16:11:23.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:23.455]             }
[16:11:23.455]             else {
[16:11:23.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:23.455]             }
[16:11:23.455]             {
[16:11:23.455]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:23.455]                   0L) {
[16:11:23.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:23.455]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:23.455]                   base::options(opts)
[16:11:23.455]                 }
[16:11:23.455]                 {
[16:11:23.455]                   {
[16:11:23.455]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:23.455]                     NULL
[16:11:23.455]                   }
[16:11:23.455]                   options(future.plan = NULL)
[16:11:23.455]                   if (is.na(NA_character_)) 
[16:11:23.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:23.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:23.455]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:23.455]                     envir = parent.frame()) 
[16:11:23.455]                   {
[16:11:23.455]                     default_workers <- missing(workers)
[16:11:23.455]                     if (is.function(workers)) 
[16:11:23.455]                       workers <- workers()
[16:11:23.455]                     workers <- structure(as.integer(workers), 
[16:11:23.455]                       class = class(workers))
[16:11:23.455]                     stop_if_not(is.finite(workers), workers >= 
[16:11:23.455]                       1L)
[16:11:23.455]                     if ((workers == 1L && !inherits(workers, 
[16:11:23.455]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:23.455]                       if (default_workers) 
[16:11:23.455]                         supportsMulticore(warn = TRUE)
[16:11:23.455]                       return(sequential(..., envir = envir))
[16:11:23.455]                     }
[16:11:23.455]                     oopts <- options(mc.cores = workers)
[16:11:23.455]                     on.exit(options(oopts))
[16:11:23.455]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:23.455]                       envir = envir)
[16:11:23.455]                     if (!future$lazy) 
[16:11:23.455]                       future <- run(future)
[16:11:23.455]                     invisible(future)
[16:11:23.455]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:23.455]                 }
[16:11:23.455]             }
[16:11:23.455]         }
[16:11:23.455]     })
[16:11:23.455]     if (TRUE) {
[16:11:23.455]         base::sink(type = "output", split = FALSE)
[16:11:23.455]         if (FALSE) {
[16:11:23.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:23.455]         }
[16:11:23.455]         else {
[16:11:23.455]             ...future.result["stdout"] <- base::list(NULL)
[16:11:23.455]         }
[16:11:23.455]         base::close(...future.stdout)
[16:11:23.455]         ...future.stdout <- NULL
[16:11:23.455]     }
[16:11:23.455]     ...future.result$conditions <- ...future.conditions
[16:11:23.455]     ...future.result$finished <- base::Sys.time()
[16:11:23.455]     ...future.result
[16:11:23.455] }
[16:11:23.458] assign_globals() ...
[16:11:23.458] List of 5
[16:11:23.458]  $ ...future.FUN            :function (x, y)  
[16:11:23.458]  $ MoreArgs                 : NULL
[16:11:23.458]  $ ...future.elements_ii    :List of 2
[16:11:23.458]   ..$ :List of 1
[16:11:23.458]   .. ..$ : int 1
[16:11:23.458]   ..$ :List of 1
[16:11:23.458]   .. ..$ : int 0
[16:11:23.458]  $ ...future.seeds_ii       : NULL
[16:11:23.458]  $ ...future.globals.maxSize: NULL
[16:11:23.458]  - attr(*, "where")=List of 5
[16:11:23.458]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:23.458]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:23.458]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:23.458]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:23.458]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:23.458]  - attr(*, "resolved")= logi FALSE
[16:11:23.458]  - attr(*, "total_size")= num 6368
[16:11:23.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:23.458]  - attr(*, "already-done")= logi TRUE
[16:11:23.463] - reassign environment for ‘...future.FUN’
[16:11:23.463] - copied ‘...future.FUN’ to environment
[16:11:23.463] - copied ‘MoreArgs’ to environment
[16:11:23.463] - copied ‘...future.elements_ii’ to environment
[16:11:23.463] - copied ‘...future.seeds_ii’ to environment
[16:11:23.463] - copied ‘...future.globals.maxSize’ to environment
[16:11:23.464] assign_globals() ... done
[16:11:23.464] requestCore(): workers = 2
[16:11:23.466] MulticoreFuture started
[16:11:23.466] - Launch lazy future ... done
[16:11:23.466] run() for ‘MulticoreFuture’ ... done
[16:11:23.466] Created future:
[16:11:23.467] plan(): Setting new future strategy stack:
[16:11:23.467] List of future strategies:
[16:11:23.467] 1. sequential:
[16:11:23.467]    - args: function (..., envir = parent.frame())
[16:11:23.467]    - tweaked: FALSE
[16:11:23.467]    - call: NULL
[16:11:23.468] plan(): nbrOfWorkers() = 1
[16:11:23.467] MulticoreFuture:
[16:11:23.467] Label: ‘future_mapply-1’
[16:11:23.467] Expression:
[16:11:23.467] {
[16:11:23.467]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:23.467]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:23.467]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:23.467]         on.exit(options(oopts), add = TRUE)
[16:11:23.467]     }
[16:11:23.467]     {
[16:11:23.467]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:23.467]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:23.467]         do.call(mapply, args = args)
[16:11:23.467]     }
[16:11:23.467] }
[16:11:23.467] Lazy evaluation: FALSE
[16:11:23.467] Asynchronous evaluation: TRUE
[16:11:23.467] Local evaluation: TRUE
[16:11:23.467] Environment: R_GlobalEnv
[16:11:23.467] Capture standard output: FALSE
[16:11:23.467] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:23.467] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:23.467] Packages: <none>
[16:11:23.467] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:23.467] Resolved: FALSE
[16:11:23.467] Value: <not collected>
[16:11:23.467] Conditions captured: <none>
[16:11:23.467] Early signaling: FALSE
[16:11:23.467] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:23.467] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:23.479] Chunk #1 of 2 ... DONE
[16:11:23.479] Chunk #2 of 2 ...
[16:11:23.480]  - Finding globals in '...' for chunk #2 ...
[16:11:23.480] getGlobalsAndPackages() ...
[16:11:23.480] Searching for globals...
[16:11:23.484] 
[16:11:23.484] Searching for globals ... DONE
[16:11:23.485] - globals: [0] <none>
[16:11:23.485] getGlobalsAndPackages() ... DONE
[16:11:23.485]    + additional globals found: [n=0] 
[16:11:23.486]    + additional namespaces needed: [n=0] 
[16:11:23.486]  - Finding globals in '...' for chunk #2 ... DONE
[16:11:23.486]  - seeds: <none>
[16:11:23.487] getGlobalsAndPackages() ...
[16:11:23.487] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:23.488] Resolving globals: FALSE
[16:11:23.489] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:23.490] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:23.490] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:23.490] 
[16:11:23.491] getGlobalsAndPackages() ... DONE
[16:11:23.491] run() for ‘Future’ ...
[16:11:23.491] - state: ‘created’
[16:11:23.492] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:23.497] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:23.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:23.497]   - Field: ‘label’
[16:11:23.498]   - Field: ‘local’
[16:11:23.498]   - Field: ‘owner’
[16:11:23.498]   - Field: ‘envir’
[16:11:23.498]   - Field: ‘workers’
[16:11:23.498]   - Field: ‘packages’
[16:11:23.498]   - Field: ‘gc’
[16:11:23.499]   - Field: ‘job’
[16:11:23.499]   - Field: ‘conditions’
[16:11:23.499]   - Field: ‘expr’
[16:11:23.499]   - Field: ‘uuid’
[16:11:23.499]   - Field: ‘seed’
[16:11:23.499]   - Field: ‘version’
[16:11:23.499]   - Field: ‘result’
[16:11:23.500]   - Field: ‘asynchronous’
[16:11:23.500]   - Field: ‘calls’
[16:11:23.500]   - Field: ‘globals’
[16:11:23.500]   - Field: ‘stdout’
[16:11:23.500]   - Field: ‘earlySignal’
[16:11:23.500]   - Field: ‘lazy’
[16:11:23.501]   - Field: ‘state’
[16:11:23.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:23.501] - Launch lazy future ...
[16:11:23.501] Packages needed by the future expression (n = 0): <none>
[16:11:23.501] Packages needed by future strategies (n = 0): <none>
[16:11:23.502] {
[16:11:23.502]     {
[16:11:23.502]         {
[16:11:23.502]             ...future.startTime <- base::Sys.time()
[16:11:23.502]             {
[16:11:23.502]                 {
[16:11:23.502]                   {
[16:11:23.502]                     {
[16:11:23.502]                       base::local({
[16:11:23.502]                         has_future <- base::requireNamespace("future", 
[16:11:23.502]                           quietly = TRUE)
[16:11:23.502]                         if (has_future) {
[16:11:23.502]                           ns <- base::getNamespace("future")
[16:11:23.502]                           version <- ns[[".package"]][["version"]]
[16:11:23.502]                           if (is.null(version)) 
[16:11:23.502]                             version <- utils::packageVersion("future")
[16:11:23.502]                         }
[16:11:23.502]                         else {
[16:11:23.502]                           version <- NULL
[16:11:23.502]                         }
[16:11:23.502]                         if (!has_future || version < "1.8.0") {
[16:11:23.502]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:23.502]                             "", base::R.version$version.string), 
[16:11:23.502]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:23.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:23.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:23.502]                               "release", "version")], collapse = " "), 
[16:11:23.502]                             hostname = base::Sys.info()[["nodename"]])
[16:11:23.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:23.502]                             info)
[16:11:23.502]                           info <- base::paste(info, collapse = "; ")
[16:11:23.502]                           if (!has_future) {
[16:11:23.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:23.502]                               info)
[16:11:23.502]                           }
[16:11:23.502]                           else {
[16:11:23.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:23.502]                               info, version)
[16:11:23.502]                           }
[16:11:23.502]                           base::stop(msg)
[16:11:23.502]                         }
[16:11:23.502]                       })
[16:11:23.502]                     }
[16:11:23.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:23.502]                     base::options(mc.cores = 1L)
[16:11:23.502]                   }
[16:11:23.502]                   options(future.plan = NULL)
[16:11:23.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:23.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:23.502]                 }
[16:11:23.502]                 ...future.workdir <- getwd()
[16:11:23.502]             }
[16:11:23.502]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:23.502]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:23.502]         }
[16:11:23.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:23.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:23.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:23.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:23.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:23.502]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:23.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:23.502]             base::names(...future.oldOptions))
[16:11:23.502]     }
[16:11:23.502]     if (FALSE) {
[16:11:23.502]     }
[16:11:23.502]     else {
[16:11:23.502]         if (FALSE) {
[16:11:23.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:23.502]                 open = "w")
[16:11:23.502]         }
[16:11:23.502]         else {
[16:11:23.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:23.502]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:23.502]         }
[16:11:23.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:23.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:23.502]             base::sink(type = "output", split = FALSE)
[16:11:23.502]             base::close(...future.stdout)
[16:11:23.502]         }, add = TRUE)
[16:11:23.502]     }
[16:11:23.502]     ...future.frame <- base::sys.nframe()
[16:11:23.502]     ...future.conditions <- base::list()
[16:11:23.502]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:23.502]     if (FALSE) {
[16:11:23.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:23.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:23.502]     }
[16:11:23.502]     ...future.result <- base::tryCatch({
[16:11:23.502]         base::withCallingHandlers({
[16:11:23.502]             ...future.value <- base::withVisible(base::local({
[16:11:23.502]                 withCallingHandlers({
[16:11:23.502]                   {
[16:11:23.502]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:23.502]                     if (!identical(...future.globals.maxSize.org, 
[16:11:23.502]                       ...future.globals.maxSize)) {
[16:11:23.502]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:23.502]                       on.exit(options(oopts), add = TRUE)
[16:11:23.502]                     }
[16:11:23.502]                     {
[16:11:23.502]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:23.502]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:23.502]                         USE.NAMES = FALSE)
[16:11:23.502]                       do.call(mapply, args = args)
[16:11:23.502]                     }
[16:11:23.502]                   }
[16:11:23.502]                 }, immediateCondition = function(cond) {
[16:11:23.502]                   save_rds <- function (object, pathname, ...) 
[16:11:23.502]                   {
[16:11:23.502]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:23.502]                     if (file_test("-f", pathname_tmp)) {
[16:11:23.502]                       fi_tmp <- file.info(pathname_tmp)
[16:11:23.502]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:23.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:23.502]                         fi_tmp[["mtime"]])
[16:11:23.502]                     }
[16:11:23.502]                     tryCatch({
[16:11:23.502]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:23.502]                     }, error = function(ex) {
[16:11:23.502]                       msg <- conditionMessage(ex)
[16:11:23.502]                       fi_tmp <- file.info(pathname_tmp)
[16:11:23.502]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:23.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:23.502]                         fi_tmp[["mtime"]], msg)
[16:11:23.502]                       ex$message <- msg
[16:11:23.502]                       stop(ex)
[16:11:23.502]                     })
[16:11:23.502]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:23.502]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:23.502]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:23.502]                       fi_tmp <- file.info(pathname_tmp)
[16:11:23.502]                       fi <- file.info(pathname)
[16:11:23.502]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:23.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:23.502]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:23.502]                         fi[["size"]], fi[["mtime"]])
[16:11:23.502]                       stop(msg)
[16:11:23.502]                     }
[16:11:23.502]                     invisible(pathname)
[16:11:23.502]                   }
[16:11:23.502]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:23.502]                     rootPath = tempdir()) 
[16:11:23.502]                   {
[16:11:23.502]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:23.502]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:23.502]                       tmpdir = path, fileext = ".rds")
[16:11:23.502]                     save_rds(obj, file)
[16:11:23.502]                   }
[16:11:23.502]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:23.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:23.502]                   {
[16:11:23.502]                     inherits <- base::inherits
[16:11:23.502]                     invokeRestart <- base::invokeRestart
[16:11:23.502]                     is.null <- base::is.null
[16:11:23.502]                     muffled <- FALSE
[16:11:23.502]                     if (inherits(cond, "message")) {
[16:11:23.502]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:23.502]                       if (muffled) 
[16:11:23.502]                         invokeRestart("muffleMessage")
[16:11:23.502]                     }
[16:11:23.502]                     else if (inherits(cond, "warning")) {
[16:11:23.502]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:23.502]                       if (muffled) 
[16:11:23.502]                         invokeRestart("muffleWarning")
[16:11:23.502]                     }
[16:11:23.502]                     else if (inherits(cond, "condition")) {
[16:11:23.502]                       if (!is.null(pattern)) {
[16:11:23.502]                         computeRestarts <- base::computeRestarts
[16:11:23.502]                         grepl <- base::grepl
[16:11:23.502]                         restarts <- computeRestarts(cond)
[16:11:23.502]                         for (restart in restarts) {
[16:11:23.502]                           name <- restart$name
[16:11:23.502]                           if (is.null(name)) 
[16:11:23.502]                             next
[16:11:23.502]                           if (!grepl(pattern, name)) 
[16:11:23.502]                             next
[16:11:23.502]                           invokeRestart(restart)
[16:11:23.502]                           muffled <- TRUE
[16:11:23.502]                           break
[16:11:23.502]                         }
[16:11:23.502]                       }
[16:11:23.502]                     }
[16:11:23.502]                     invisible(muffled)
[16:11:23.502]                   }
[16:11:23.502]                   muffleCondition(cond)
[16:11:23.502]                 })
[16:11:23.502]             }))
[16:11:23.502]             future::FutureResult(value = ...future.value$value, 
[16:11:23.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:23.502]                   ...future.rng), globalenv = if (FALSE) 
[16:11:23.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:23.502]                     ...future.globalenv.names))
[16:11:23.502]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:23.502]         }, condition = base::local({
[16:11:23.502]             c <- base::c
[16:11:23.502]             inherits <- base::inherits
[16:11:23.502]             invokeRestart <- base::invokeRestart
[16:11:23.502]             length <- base::length
[16:11:23.502]             list <- base::list
[16:11:23.502]             seq.int <- base::seq.int
[16:11:23.502]             signalCondition <- base::signalCondition
[16:11:23.502]             sys.calls <- base::sys.calls
[16:11:23.502]             `[[` <- base::`[[`
[16:11:23.502]             `+` <- base::`+`
[16:11:23.502]             `<<-` <- base::`<<-`
[16:11:23.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:23.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:23.502]                   3L)]
[16:11:23.502]             }
[16:11:23.502]             function(cond) {
[16:11:23.502]                 is_error <- inherits(cond, "error")
[16:11:23.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:23.502]                   NULL)
[16:11:23.502]                 if (is_error) {
[16:11:23.502]                   sessionInformation <- function() {
[16:11:23.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:23.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:23.502]                       search = base::search(), system = base::Sys.info())
[16:11:23.502]                   }
[16:11:23.502]                   ...future.conditions[[length(...future.conditions) + 
[16:11:23.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:23.502]                     cond$call), session = sessionInformation(), 
[16:11:23.502]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:23.502]                   signalCondition(cond)
[16:11:23.502]                 }
[16:11:23.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:23.502]                 "immediateCondition"))) {
[16:11:23.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:23.502]                   ...future.conditions[[length(...future.conditions) + 
[16:11:23.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:23.502]                   if (TRUE && !signal) {
[16:11:23.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:23.502]                     {
[16:11:23.502]                       inherits <- base::inherits
[16:11:23.502]                       invokeRestart <- base::invokeRestart
[16:11:23.502]                       is.null <- base::is.null
[16:11:23.502]                       muffled <- FALSE
[16:11:23.502]                       if (inherits(cond, "message")) {
[16:11:23.502]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:23.502]                         if (muffled) 
[16:11:23.502]                           invokeRestart("muffleMessage")
[16:11:23.502]                       }
[16:11:23.502]                       else if (inherits(cond, "warning")) {
[16:11:23.502]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:23.502]                         if (muffled) 
[16:11:23.502]                           invokeRestart("muffleWarning")
[16:11:23.502]                       }
[16:11:23.502]                       else if (inherits(cond, "condition")) {
[16:11:23.502]                         if (!is.null(pattern)) {
[16:11:23.502]                           computeRestarts <- base::computeRestarts
[16:11:23.502]                           grepl <- base::grepl
[16:11:23.502]                           restarts <- computeRestarts(cond)
[16:11:23.502]                           for (restart in restarts) {
[16:11:23.502]                             name <- restart$name
[16:11:23.502]                             if (is.null(name)) 
[16:11:23.502]                               next
[16:11:23.502]                             if (!grepl(pattern, name)) 
[16:11:23.502]                               next
[16:11:23.502]                             invokeRestart(restart)
[16:11:23.502]                             muffled <- TRUE
[16:11:23.502]                             break
[16:11:23.502]                           }
[16:11:23.502]                         }
[16:11:23.502]                       }
[16:11:23.502]                       invisible(muffled)
[16:11:23.502]                     }
[16:11:23.502]                     muffleCondition(cond, pattern = "^muffle")
[16:11:23.502]                   }
[16:11:23.502]                 }
[16:11:23.502]                 else {
[16:11:23.502]                   if (TRUE) {
[16:11:23.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:23.502]                     {
[16:11:23.502]                       inherits <- base::inherits
[16:11:23.502]                       invokeRestart <- base::invokeRestart
[16:11:23.502]                       is.null <- base::is.null
[16:11:23.502]                       muffled <- FALSE
[16:11:23.502]                       if (inherits(cond, "message")) {
[16:11:23.502]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:23.502]                         if (muffled) 
[16:11:23.502]                           invokeRestart("muffleMessage")
[16:11:23.502]                       }
[16:11:23.502]                       else if (inherits(cond, "warning")) {
[16:11:23.502]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:23.502]                         if (muffled) 
[16:11:23.502]                           invokeRestart("muffleWarning")
[16:11:23.502]                       }
[16:11:23.502]                       else if (inherits(cond, "condition")) {
[16:11:23.502]                         if (!is.null(pattern)) {
[16:11:23.502]                           computeRestarts <- base::computeRestarts
[16:11:23.502]                           grepl <- base::grepl
[16:11:23.502]                           restarts <- computeRestarts(cond)
[16:11:23.502]                           for (restart in restarts) {
[16:11:23.502]                             name <- restart$name
[16:11:23.502]                             if (is.null(name)) 
[16:11:23.502]                               next
[16:11:23.502]                             if (!grepl(pattern, name)) 
[16:11:23.502]                               next
[16:11:23.502]                             invokeRestart(restart)
[16:11:23.502]                             muffled <- TRUE
[16:11:23.502]                             break
[16:11:23.502]                           }
[16:11:23.502]                         }
[16:11:23.502]                       }
[16:11:23.502]                       invisible(muffled)
[16:11:23.502]                     }
[16:11:23.502]                     muffleCondition(cond, pattern = "^muffle")
[16:11:23.502]                   }
[16:11:23.502]                 }
[16:11:23.502]             }
[16:11:23.502]         }))
[16:11:23.502]     }, error = function(ex) {
[16:11:23.502]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:23.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:23.502]                 ...future.rng), started = ...future.startTime, 
[16:11:23.502]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:23.502]             version = "1.8"), class = "FutureResult")
[16:11:23.502]     }, finally = {
[16:11:23.502]         if (!identical(...future.workdir, getwd())) 
[16:11:23.502]             setwd(...future.workdir)
[16:11:23.502]         {
[16:11:23.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:23.502]                 ...future.oldOptions$nwarnings <- NULL
[16:11:23.502]             }
[16:11:23.502]             base::options(...future.oldOptions)
[16:11:23.502]             if (.Platform$OS.type == "windows") {
[16:11:23.502]                 old_names <- names(...future.oldEnvVars)
[16:11:23.502]                 envs <- base::Sys.getenv()
[16:11:23.502]                 names <- names(envs)
[16:11:23.502]                 common <- intersect(names, old_names)
[16:11:23.502]                 added <- setdiff(names, old_names)
[16:11:23.502]                 removed <- setdiff(old_names, names)
[16:11:23.502]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:23.502]                   envs[common]]
[16:11:23.502]                 NAMES <- toupper(changed)
[16:11:23.502]                 args <- list()
[16:11:23.502]                 for (kk in seq_along(NAMES)) {
[16:11:23.502]                   name <- changed[[kk]]
[16:11:23.502]                   NAME <- NAMES[[kk]]
[16:11:23.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:23.502]                     next
[16:11:23.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:23.502]                 }
[16:11:23.502]                 NAMES <- toupper(added)
[16:11:23.502]                 for (kk in seq_along(NAMES)) {
[16:11:23.502]                   name <- added[[kk]]
[16:11:23.502]                   NAME <- NAMES[[kk]]
[16:11:23.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:23.502]                     next
[16:11:23.502]                   args[[name]] <- ""
[16:11:23.502]                 }
[16:11:23.502]                 NAMES <- toupper(removed)
[16:11:23.502]                 for (kk in seq_along(NAMES)) {
[16:11:23.502]                   name <- removed[[kk]]
[16:11:23.502]                   NAME <- NAMES[[kk]]
[16:11:23.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:23.502]                     next
[16:11:23.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:23.502]                 }
[16:11:23.502]                 if (length(args) > 0) 
[16:11:23.502]                   base::do.call(base::Sys.setenv, args = args)
[16:11:23.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:23.502]             }
[16:11:23.502]             else {
[16:11:23.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:23.502]             }
[16:11:23.502]             {
[16:11:23.502]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:23.502]                   0L) {
[16:11:23.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:23.502]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:23.502]                   base::options(opts)
[16:11:23.502]                 }
[16:11:23.502]                 {
[16:11:23.502]                   {
[16:11:23.502]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:23.502]                     NULL
[16:11:23.502]                   }
[16:11:23.502]                   options(future.plan = NULL)
[16:11:23.502]                   if (is.na(NA_character_)) 
[16:11:23.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:23.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:23.502]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:23.502]                     envir = parent.frame()) 
[16:11:23.502]                   {
[16:11:23.502]                     default_workers <- missing(workers)
[16:11:23.502]                     if (is.function(workers)) 
[16:11:23.502]                       workers <- workers()
[16:11:23.502]                     workers <- structure(as.integer(workers), 
[16:11:23.502]                       class = class(workers))
[16:11:23.502]                     stop_if_not(is.finite(workers), workers >= 
[16:11:23.502]                       1L)
[16:11:23.502]                     if ((workers == 1L && !inherits(workers, 
[16:11:23.502]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:23.502]                       if (default_workers) 
[16:11:23.502]                         supportsMulticore(warn = TRUE)
[16:11:23.502]                       return(sequential(..., envir = envir))
[16:11:23.502]                     }
[16:11:23.502]                     oopts <- options(mc.cores = workers)
[16:11:23.502]                     on.exit(options(oopts))
[16:11:23.502]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:23.502]                       envir = envir)
[16:11:23.502]                     if (!future$lazy) 
[16:11:23.502]                       future <- run(future)
[16:11:23.502]                     invisible(future)
[16:11:23.502]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:23.502]                 }
[16:11:23.502]             }
[16:11:23.502]         }
[16:11:23.502]     })
[16:11:23.502]     if (TRUE) {
[16:11:23.502]         base::sink(type = "output", split = FALSE)
[16:11:23.502]         if (FALSE) {
[16:11:23.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:23.502]         }
[16:11:23.502]         else {
[16:11:23.502]             ...future.result["stdout"] <- base::list(NULL)
[16:11:23.502]         }
[16:11:23.502]         base::close(...future.stdout)
[16:11:23.502]         ...future.stdout <- NULL
[16:11:23.502]     }
[16:11:23.502]     ...future.result$conditions <- ...future.conditions
[16:11:23.502]     ...future.result$finished <- base::Sys.time()
[16:11:23.502]     ...future.result
[16:11:23.502] }
[16:11:23.505] assign_globals() ...
[16:11:23.505] List of 5
[16:11:23.505]  $ ...future.FUN            :function (x, y)  
[16:11:23.505]  $ MoreArgs                 : NULL
[16:11:23.505]  $ ...future.elements_ii    :List of 2
[16:11:23.505]   ..$ :List of 1
[16:11:23.505]   .. ..$ : int 0
[16:11:23.505]   ..$ :List of 1
[16:11:23.505]   .. ..$ : int 1
[16:11:23.505]  $ ...future.seeds_ii       : NULL
[16:11:23.505]  $ ...future.globals.maxSize: NULL
[16:11:23.505]  - attr(*, "where")=List of 5
[16:11:23.505]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:23.505]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:23.505]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:23.505]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:23.505]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:23.505]  - attr(*, "resolved")= logi FALSE
[16:11:23.505]  - attr(*, "total_size")= num 6368
[16:11:23.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:23.505]  - attr(*, "already-done")= logi TRUE
[16:11:23.512] - reassign environment for ‘...future.FUN’
[16:11:23.513] - copied ‘...future.FUN’ to environment
[16:11:23.513] - copied ‘MoreArgs’ to environment
[16:11:23.513] - copied ‘...future.elements_ii’ to environment
[16:11:23.513] - copied ‘...future.seeds_ii’ to environment
[16:11:23.513] - copied ‘...future.globals.maxSize’ to environment
[16:11:23.513] assign_globals() ... done
[16:11:23.513] requestCore(): workers = 2
[16:11:23.516] MulticoreFuture started
[16:11:23.516] - Launch lazy future ... done
[16:11:23.516] run() for ‘MulticoreFuture’ ... done
[16:11:23.517] Created future:
[16:11:23.517] plan(): Setting new future strategy stack:
[16:11:23.517] List of future strategies:
[16:11:23.517] 1. sequential:
[16:11:23.517]    - args: function (..., envir = parent.frame())
[16:11:23.517]    - tweaked: FALSE
[16:11:23.517]    - call: NULL
[16:11:23.518] plan(): nbrOfWorkers() = 1
[16:11:23.520] plan(): Setting new future strategy stack:
[16:11:23.520] List of future strategies:
[16:11:23.520] 1. multicore:
[16:11:23.520]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:23.520]    - tweaked: FALSE
[16:11:23.520]    - call: plan(strategy)
[16:11:23.526] plan(): nbrOfWorkers() = 2
[16:11:23.517] MulticoreFuture:
[16:11:23.517] Label: ‘future_mapply-2’
[16:11:23.517] Expression:
[16:11:23.517] {
[16:11:23.517]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:23.517]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:23.517]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:23.517]         on.exit(options(oopts), add = TRUE)
[16:11:23.517]     }
[16:11:23.517]     {
[16:11:23.517]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:23.517]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:23.517]         do.call(mapply, args = args)
[16:11:23.517]     }
[16:11:23.517] }
[16:11:23.517] Lazy evaluation: FALSE
[16:11:23.517] Asynchronous evaluation: TRUE
[16:11:23.517] Local evaluation: TRUE
[16:11:23.517] Environment: R_GlobalEnv
[16:11:23.517] Capture standard output: FALSE
[16:11:23.517] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:23.517] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:23.517] Packages: <none>
[16:11:23.517] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:23.517] Resolved: TRUE
[16:11:23.517] Value: <not collected>
[16:11:23.517] Conditions captured: <none>
[16:11:23.517] Early signaling: FALSE
[16:11:23.517] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:23.517] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:23.527] Chunk #2 of 2 ... DONE
[16:11:23.527] Launching 2 futures (chunks) ... DONE
[16:11:23.527] Resolving 2 futures (chunks) ...
[16:11:23.527] resolve() on list ...
[16:11:23.527]  recursive: 0
[16:11:23.527]  length: 2
[16:11:23.528] 
[16:11:23.538] Future #2
[16:11:23.539] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:23.540] - nx: 2
[16:11:23.540] - relay: TRUE
[16:11:23.540] - stdout: TRUE
[16:11:23.540] - signal: TRUE
[16:11:23.540] - resignal: FALSE
[16:11:23.540] - force: TRUE
[16:11:23.540] - relayed: [n=2] FALSE, FALSE
[16:11:23.541] - queued futures: [n=2] FALSE, FALSE
[16:11:23.541]  - until=1
[16:11:23.541]  - relaying element #1
[16:11:23.541] - relayed: [n=2] FALSE, FALSE
[16:11:23.541] - queued futures: [n=2] FALSE, TRUE
[16:11:23.541] signalConditionsASAP(NULL, pos=2) ... done
[16:11:23.541]  length: 1 (resolved future 2)
[16:11:23.970] plan(): Setting new future strategy stack:
[16:11:23.971] List of future strategies:
[16:11:23.971] 1. multicore:
[16:11:23.971]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:23.971]    - tweaked: FALSE
[16:11:23.971]    - call: plan(strategy)
[16:11:23.979] plan(): nbrOfWorkers() = 2
[16:11:23.979] Future #1
[16:11:23.980] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:23.980] - nx: 2
[16:11:23.980] - relay: TRUE
[16:11:23.983] - stdout: TRUE
[16:11:23.983] - signal: TRUE
[16:11:23.983] - resignal: FALSE
[16:11:23.983] - force: TRUE
[16:11:23.984] - relayed: [n=2] FALSE, FALSE
[16:11:23.984] - queued futures: [n=2] FALSE, TRUE
[16:11:23.984]  - until=1
[16:11:23.984]  - relaying element #1
[16:11:23.985] - relayed: [n=2] TRUE, FALSE
[16:11:23.985] - queued futures: [n=2] TRUE, TRUE
[16:11:23.985] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:23.985]  length: 0 (resolved future 1)
[16:11:23.985] Relaying remaining futures
[16:11:23.985] signalConditionsASAP(NULL, pos=0) ...
[16:11:23.986] - nx: 2
[16:11:23.986] - relay: TRUE
[16:11:23.986] - stdout: TRUE
[16:11:23.986] - signal: TRUE
[16:11:23.986] - resignal: FALSE
[16:11:23.986] - force: TRUE
[16:11:23.986] - relayed: [n=2] TRUE, FALSE
[16:11:23.986] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:23.987]  - relaying element #2
[16:11:23.987] - relayed: [n=2] TRUE, TRUE
[16:11:23.987] - queued futures: [n=2] TRUE, TRUE
[16:11:23.987] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:11:23.987] resolve() on list ... DONE
[16:11:23.988]  - Number of value chunks collected: 2
[16:11:23.988] Resolving 2 futures (chunks) ... DONE
[16:11:23.988] Reducing values from 2 chunks ...
[16:11:23.988]  - Number of values collected after concatenation: 2
[16:11:23.988]  - Number of values expected: 2
[16:11:23.988] Reducing values from 2 chunks ... DONE
[16:11:23.989] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:11:23.989] future_mapply() ...
[16:11:23.993] Number of chunks: 2
[16:11:23.993] getGlobalsAndPackagesXApply() ...
[16:11:23.994]  - future.globals: TRUE
[16:11:23.994] getGlobalsAndPackages() ...
[16:11:23.994] Searching for globals...
[16:11:23.996] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:23.996] Searching for globals ... DONE
[16:11:23.996] Resolving globals: FALSE
[16:11:23.996] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:23.997] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:23.997] - globals: [1] ‘FUN’
[16:11:23.997] 
[16:11:23.997] getGlobalsAndPackages() ... DONE
[16:11:23.997]  - globals found/used: [n=1] ‘FUN’
[16:11:23.997]  - needed namespaces: [n=0] 
[16:11:23.997] Finding globals ... DONE
[16:11:23.998] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:23.998] List of 2
[16:11:23.998]  $ ...future.FUN:function (x, y)  
[16:11:23.998]  $ MoreArgs     : NULL
[16:11:23.998]  - attr(*, "where")=List of 2
[16:11:23.998]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:23.998]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:23.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:23.998]  - attr(*, "resolved")= logi FALSE
[16:11:23.998]  - attr(*, "total_size")= num NA
[16:11:24.001] Packages to be attached in all futures: [n=0] 
[16:11:24.001] getGlobalsAndPackagesXApply() ... DONE
[16:11:24.001] Number of futures (= number of chunks): 2
[16:11:24.001] Launching 2 futures (chunks) ...
[16:11:24.001] Chunk #1 of 2 ...
[16:11:24.001]  - Finding globals in '...' for chunk #1 ...
[16:11:24.002] getGlobalsAndPackages() ...
[16:11:24.002] Searching for globals...
[16:11:24.002] 
[16:11:24.002] Searching for globals ... DONE
[16:11:24.002] - globals: [0] <none>
[16:11:24.002] getGlobalsAndPackages() ... DONE
[16:11:24.002]    + additional globals found: [n=0] 
[16:11:24.002]    + additional namespaces needed: [n=0] 
[16:11:24.003]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:24.003]  - seeds: <none>
[16:11:24.003] getGlobalsAndPackages() ...
[16:11:24.003] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:24.003] Resolving globals: FALSE
[16:11:24.003] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:24.004] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:24.004] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:24.004] 
[16:11:24.004] getGlobalsAndPackages() ... DONE
[16:11:24.005] run() for ‘Future’ ...
[16:11:24.005] - state: ‘created’
[16:11:24.005] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:24.008] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:24.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:24.009]   - Field: ‘label’
[16:11:24.009]   - Field: ‘local’
[16:11:24.009]   - Field: ‘owner’
[16:11:24.009]   - Field: ‘envir’
[16:11:24.009]   - Field: ‘workers’
[16:11:24.009]   - Field: ‘packages’
[16:11:24.009]   - Field: ‘gc’
[16:11:24.009]   - Field: ‘job’
[16:11:24.009]   - Field: ‘conditions’
[16:11:24.010]   - Field: ‘expr’
[16:11:24.010]   - Field: ‘uuid’
[16:11:24.010]   - Field: ‘seed’
[16:11:24.010]   - Field: ‘version’
[16:11:24.010]   - Field: ‘result’
[16:11:24.010]   - Field: ‘asynchronous’
[16:11:24.010]   - Field: ‘calls’
[16:11:24.010]   - Field: ‘globals’
[16:11:24.010]   - Field: ‘stdout’
[16:11:24.010]   - Field: ‘earlySignal’
[16:11:24.010]   - Field: ‘lazy’
[16:11:24.011]   - Field: ‘state’
[16:11:24.011] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:24.011] - Launch lazy future ...
[16:11:24.011] Packages needed by the future expression (n = 0): <none>
[16:11:24.011] Packages needed by future strategies (n = 0): <none>
[16:11:24.012] {
[16:11:24.012]     {
[16:11:24.012]         {
[16:11:24.012]             ...future.startTime <- base::Sys.time()
[16:11:24.012]             {
[16:11:24.012]                 {
[16:11:24.012]                   {
[16:11:24.012]                     {
[16:11:24.012]                       base::local({
[16:11:24.012]                         has_future <- base::requireNamespace("future", 
[16:11:24.012]                           quietly = TRUE)
[16:11:24.012]                         if (has_future) {
[16:11:24.012]                           ns <- base::getNamespace("future")
[16:11:24.012]                           version <- ns[[".package"]][["version"]]
[16:11:24.012]                           if (is.null(version)) 
[16:11:24.012]                             version <- utils::packageVersion("future")
[16:11:24.012]                         }
[16:11:24.012]                         else {
[16:11:24.012]                           version <- NULL
[16:11:24.012]                         }
[16:11:24.012]                         if (!has_future || version < "1.8.0") {
[16:11:24.012]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:24.012]                             "", base::R.version$version.string), 
[16:11:24.012]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:24.012]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:24.012]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:24.012]                               "release", "version")], collapse = " "), 
[16:11:24.012]                             hostname = base::Sys.info()[["nodename"]])
[16:11:24.012]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:24.012]                             info)
[16:11:24.012]                           info <- base::paste(info, collapse = "; ")
[16:11:24.012]                           if (!has_future) {
[16:11:24.012]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:24.012]                               info)
[16:11:24.012]                           }
[16:11:24.012]                           else {
[16:11:24.012]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:24.012]                               info, version)
[16:11:24.012]                           }
[16:11:24.012]                           base::stop(msg)
[16:11:24.012]                         }
[16:11:24.012]                       })
[16:11:24.012]                     }
[16:11:24.012]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:24.012]                     base::options(mc.cores = 1L)
[16:11:24.012]                   }
[16:11:24.012]                   options(future.plan = NULL)
[16:11:24.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:24.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:24.012]                 }
[16:11:24.012]                 ...future.workdir <- getwd()
[16:11:24.012]             }
[16:11:24.012]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:24.012]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:24.012]         }
[16:11:24.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:24.012]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:24.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:24.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:24.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:24.012]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:24.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:24.012]             base::names(...future.oldOptions))
[16:11:24.012]     }
[16:11:24.012]     if (FALSE) {
[16:11:24.012]     }
[16:11:24.012]     else {
[16:11:24.012]         if (TRUE) {
[16:11:24.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:24.012]                 open = "w")
[16:11:24.012]         }
[16:11:24.012]         else {
[16:11:24.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:24.012]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:24.012]         }
[16:11:24.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:24.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:24.012]             base::sink(type = "output", split = FALSE)
[16:11:24.012]             base::close(...future.stdout)
[16:11:24.012]         }, add = TRUE)
[16:11:24.012]     }
[16:11:24.012]     ...future.frame <- base::sys.nframe()
[16:11:24.012]     ...future.conditions <- base::list()
[16:11:24.012]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:24.012]     if (FALSE) {
[16:11:24.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:24.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:24.012]     }
[16:11:24.012]     ...future.result <- base::tryCatch({
[16:11:24.012]         base::withCallingHandlers({
[16:11:24.012]             ...future.value <- base::withVisible(base::local({
[16:11:24.012]                 withCallingHandlers({
[16:11:24.012]                   {
[16:11:24.012]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:24.012]                     if (!identical(...future.globals.maxSize.org, 
[16:11:24.012]                       ...future.globals.maxSize)) {
[16:11:24.012]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:24.012]                       on.exit(options(oopts), add = TRUE)
[16:11:24.012]                     }
[16:11:24.012]                     {
[16:11:24.012]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:24.012]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:24.012]                         USE.NAMES = FALSE)
[16:11:24.012]                       do.call(mapply, args = args)
[16:11:24.012]                     }
[16:11:24.012]                   }
[16:11:24.012]                 }, immediateCondition = function(cond) {
[16:11:24.012]                   save_rds <- function (object, pathname, ...) 
[16:11:24.012]                   {
[16:11:24.012]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:24.012]                     if (file_test("-f", pathname_tmp)) {
[16:11:24.012]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.012]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:24.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.012]                         fi_tmp[["mtime"]])
[16:11:24.012]                     }
[16:11:24.012]                     tryCatch({
[16:11:24.012]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:24.012]                     }, error = function(ex) {
[16:11:24.012]                       msg <- conditionMessage(ex)
[16:11:24.012]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.012]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:24.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.012]                         fi_tmp[["mtime"]], msg)
[16:11:24.012]                       ex$message <- msg
[16:11:24.012]                       stop(ex)
[16:11:24.012]                     })
[16:11:24.012]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:24.012]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:24.012]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:24.012]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.012]                       fi <- file.info(pathname)
[16:11:24.012]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:24.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.012]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:24.012]                         fi[["size"]], fi[["mtime"]])
[16:11:24.012]                       stop(msg)
[16:11:24.012]                     }
[16:11:24.012]                     invisible(pathname)
[16:11:24.012]                   }
[16:11:24.012]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:24.012]                     rootPath = tempdir()) 
[16:11:24.012]                   {
[16:11:24.012]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:24.012]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:24.012]                       tmpdir = path, fileext = ".rds")
[16:11:24.012]                     save_rds(obj, file)
[16:11:24.012]                   }
[16:11:24.012]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:24.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.012]                   {
[16:11:24.012]                     inherits <- base::inherits
[16:11:24.012]                     invokeRestart <- base::invokeRestart
[16:11:24.012]                     is.null <- base::is.null
[16:11:24.012]                     muffled <- FALSE
[16:11:24.012]                     if (inherits(cond, "message")) {
[16:11:24.012]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:24.012]                       if (muffled) 
[16:11:24.012]                         invokeRestart("muffleMessage")
[16:11:24.012]                     }
[16:11:24.012]                     else if (inherits(cond, "warning")) {
[16:11:24.012]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:24.012]                       if (muffled) 
[16:11:24.012]                         invokeRestart("muffleWarning")
[16:11:24.012]                     }
[16:11:24.012]                     else if (inherits(cond, "condition")) {
[16:11:24.012]                       if (!is.null(pattern)) {
[16:11:24.012]                         computeRestarts <- base::computeRestarts
[16:11:24.012]                         grepl <- base::grepl
[16:11:24.012]                         restarts <- computeRestarts(cond)
[16:11:24.012]                         for (restart in restarts) {
[16:11:24.012]                           name <- restart$name
[16:11:24.012]                           if (is.null(name)) 
[16:11:24.012]                             next
[16:11:24.012]                           if (!grepl(pattern, name)) 
[16:11:24.012]                             next
[16:11:24.012]                           invokeRestart(restart)
[16:11:24.012]                           muffled <- TRUE
[16:11:24.012]                           break
[16:11:24.012]                         }
[16:11:24.012]                       }
[16:11:24.012]                     }
[16:11:24.012]                     invisible(muffled)
[16:11:24.012]                   }
[16:11:24.012]                   muffleCondition(cond)
[16:11:24.012]                 })
[16:11:24.012]             }))
[16:11:24.012]             future::FutureResult(value = ...future.value$value, 
[16:11:24.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:24.012]                   ...future.rng), globalenv = if (FALSE) 
[16:11:24.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:24.012]                     ...future.globalenv.names))
[16:11:24.012]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:24.012]         }, condition = base::local({
[16:11:24.012]             c <- base::c
[16:11:24.012]             inherits <- base::inherits
[16:11:24.012]             invokeRestart <- base::invokeRestart
[16:11:24.012]             length <- base::length
[16:11:24.012]             list <- base::list
[16:11:24.012]             seq.int <- base::seq.int
[16:11:24.012]             signalCondition <- base::signalCondition
[16:11:24.012]             sys.calls <- base::sys.calls
[16:11:24.012]             `[[` <- base::`[[`
[16:11:24.012]             `+` <- base::`+`
[16:11:24.012]             `<<-` <- base::`<<-`
[16:11:24.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:24.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:24.012]                   3L)]
[16:11:24.012]             }
[16:11:24.012]             function(cond) {
[16:11:24.012]                 is_error <- inherits(cond, "error")
[16:11:24.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:24.012]                   NULL)
[16:11:24.012]                 if (is_error) {
[16:11:24.012]                   sessionInformation <- function() {
[16:11:24.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:24.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:24.012]                       search = base::search(), system = base::Sys.info())
[16:11:24.012]                   }
[16:11:24.012]                   ...future.conditions[[length(...future.conditions) + 
[16:11:24.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:24.012]                     cond$call), session = sessionInformation(), 
[16:11:24.012]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:24.012]                   signalCondition(cond)
[16:11:24.012]                 }
[16:11:24.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:24.012]                 "immediateCondition"))) {
[16:11:24.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:24.012]                   ...future.conditions[[length(...future.conditions) + 
[16:11:24.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:24.012]                   if (TRUE && !signal) {
[16:11:24.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.012]                     {
[16:11:24.012]                       inherits <- base::inherits
[16:11:24.012]                       invokeRestart <- base::invokeRestart
[16:11:24.012]                       is.null <- base::is.null
[16:11:24.012]                       muffled <- FALSE
[16:11:24.012]                       if (inherits(cond, "message")) {
[16:11:24.012]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:24.012]                         if (muffled) 
[16:11:24.012]                           invokeRestart("muffleMessage")
[16:11:24.012]                       }
[16:11:24.012]                       else if (inherits(cond, "warning")) {
[16:11:24.012]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:24.012]                         if (muffled) 
[16:11:24.012]                           invokeRestart("muffleWarning")
[16:11:24.012]                       }
[16:11:24.012]                       else if (inherits(cond, "condition")) {
[16:11:24.012]                         if (!is.null(pattern)) {
[16:11:24.012]                           computeRestarts <- base::computeRestarts
[16:11:24.012]                           grepl <- base::grepl
[16:11:24.012]                           restarts <- computeRestarts(cond)
[16:11:24.012]                           for (restart in restarts) {
[16:11:24.012]                             name <- restart$name
[16:11:24.012]                             if (is.null(name)) 
[16:11:24.012]                               next
[16:11:24.012]                             if (!grepl(pattern, name)) 
[16:11:24.012]                               next
[16:11:24.012]                             invokeRestart(restart)
[16:11:24.012]                             muffled <- TRUE
[16:11:24.012]                             break
[16:11:24.012]                           }
[16:11:24.012]                         }
[16:11:24.012]                       }
[16:11:24.012]                       invisible(muffled)
[16:11:24.012]                     }
[16:11:24.012]                     muffleCondition(cond, pattern = "^muffle")
[16:11:24.012]                   }
[16:11:24.012]                 }
[16:11:24.012]                 else {
[16:11:24.012]                   if (TRUE) {
[16:11:24.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.012]                     {
[16:11:24.012]                       inherits <- base::inherits
[16:11:24.012]                       invokeRestart <- base::invokeRestart
[16:11:24.012]                       is.null <- base::is.null
[16:11:24.012]                       muffled <- FALSE
[16:11:24.012]                       if (inherits(cond, "message")) {
[16:11:24.012]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:24.012]                         if (muffled) 
[16:11:24.012]                           invokeRestart("muffleMessage")
[16:11:24.012]                       }
[16:11:24.012]                       else if (inherits(cond, "warning")) {
[16:11:24.012]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:24.012]                         if (muffled) 
[16:11:24.012]                           invokeRestart("muffleWarning")
[16:11:24.012]                       }
[16:11:24.012]                       else if (inherits(cond, "condition")) {
[16:11:24.012]                         if (!is.null(pattern)) {
[16:11:24.012]                           computeRestarts <- base::computeRestarts
[16:11:24.012]                           grepl <- base::grepl
[16:11:24.012]                           restarts <- computeRestarts(cond)
[16:11:24.012]                           for (restart in restarts) {
[16:11:24.012]                             name <- restart$name
[16:11:24.012]                             if (is.null(name)) 
[16:11:24.012]                               next
[16:11:24.012]                             if (!grepl(pattern, name)) 
[16:11:24.012]                               next
[16:11:24.012]                             invokeRestart(restart)
[16:11:24.012]                             muffled <- TRUE
[16:11:24.012]                             break
[16:11:24.012]                           }
[16:11:24.012]                         }
[16:11:24.012]                       }
[16:11:24.012]                       invisible(muffled)
[16:11:24.012]                     }
[16:11:24.012]                     muffleCondition(cond, pattern = "^muffle")
[16:11:24.012]                   }
[16:11:24.012]                 }
[16:11:24.012]             }
[16:11:24.012]         }))
[16:11:24.012]     }, error = function(ex) {
[16:11:24.012]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:24.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:24.012]                 ...future.rng), started = ...future.startTime, 
[16:11:24.012]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:24.012]             version = "1.8"), class = "FutureResult")
[16:11:24.012]     }, finally = {
[16:11:24.012]         if (!identical(...future.workdir, getwd())) 
[16:11:24.012]             setwd(...future.workdir)
[16:11:24.012]         {
[16:11:24.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:24.012]                 ...future.oldOptions$nwarnings <- NULL
[16:11:24.012]             }
[16:11:24.012]             base::options(...future.oldOptions)
[16:11:24.012]             if (.Platform$OS.type == "windows") {
[16:11:24.012]                 old_names <- names(...future.oldEnvVars)
[16:11:24.012]                 envs <- base::Sys.getenv()
[16:11:24.012]                 names <- names(envs)
[16:11:24.012]                 common <- intersect(names, old_names)
[16:11:24.012]                 added <- setdiff(names, old_names)
[16:11:24.012]                 removed <- setdiff(old_names, names)
[16:11:24.012]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:24.012]                   envs[common]]
[16:11:24.012]                 NAMES <- toupper(changed)
[16:11:24.012]                 args <- list()
[16:11:24.012]                 for (kk in seq_along(NAMES)) {
[16:11:24.012]                   name <- changed[[kk]]
[16:11:24.012]                   NAME <- NAMES[[kk]]
[16:11:24.012]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.012]                     next
[16:11:24.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:24.012]                 }
[16:11:24.012]                 NAMES <- toupper(added)
[16:11:24.012]                 for (kk in seq_along(NAMES)) {
[16:11:24.012]                   name <- added[[kk]]
[16:11:24.012]                   NAME <- NAMES[[kk]]
[16:11:24.012]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.012]                     next
[16:11:24.012]                   args[[name]] <- ""
[16:11:24.012]                 }
[16:11:24.012]                 NAMES <- toupper(removed)
[16:11:24.012]                 for (kk in seq_along(NAMES)) {
[16:11:24.012]                   name <- removed[[kk]]
[16:11:24.012]                   NAME <- NAMES[[kk]]
[16:11:24.012]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.012]                     next
[16:11:24.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:24.012]                 }
[16:11:24.012]                 if (length(args) > 0) 
[16:11:24.012]                   base::do.call(base::Sys.setenv, args = args)
[16:11:24.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:24.012]             }
[16:11:24.012]             else {
[16:11:24.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:24.012]             }
[16:11:24.012]             {
[16:11:24.012]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:24.012]                   0L) {
[16:11:24.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:24.012]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:24.012]                   base::options(opts)
[16:11:24.012]                 }
[16:11:24.012]                 {
[16:11:24.012]                   {
[16:11:24.012]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:24.012]                     NULL
[16:11:24.012]                   }
[16:11:24.012]                   options(future.plan = NULL)
[16:11:24.012]                   if (is.na(NA_character_)) 
[16:11:24.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:24.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:24.012]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:24.012]                     envir = parent.frame()) 
[16:11:24.012]                   {
[16:11:24.012]                     default_workers <- missing(workers)
[16:11:24.012]                     if (is.function(workers)) 
[16:11:24.012]                       workers <- workers()
[16:11:24.012]                     workers <- structure(as.integer(workers), 
[16:11:24.012]                       class = class(workers))
[16:11:24.012]                     stop_if_not(is.finite(workers), workers >= 
[16:11:24.012]                       1L)
[16:11:24.012]                     if ((workers == 1L && !inherits(workers, 
[16:11:24.012]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:24.012]                       if (default_workers) 
[16:11:24.012]                         supportsMulticore(warn = TRUE)
[16:11:24.012]                       return(sequential(..., envir = envir))
[16:11:24.012]                     }
[16:11:24.012]                     oopts <- options(mc.cores = workers)
[16:11:24.012]                     on.exit(options(oopts))
[16:11:24.012]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:24.012]                       envir = envir)
[16:11:24.012]                     if (!future$lazy) 
[16:11:24.012]                       future <- run(future)
[16:11:24.012]                     invisible(future)
[16:11:24.012]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:24.012]                 }
[16:11:24.012]             }
[16:11:24.012]         }
[16:11:24.012]     })
[16:11:24.012]     if (TRUE) {
[16:11:24.012]         base::sink(type = "output", split = FALSE)
[16:11:24.012]         if (TRUE) {
[16:11:24.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:24.012]         }
[16:11:24.012]         else {
[16:11:24.012]             ...future.result["stdout"] <- base::list(NULL)
[16:11:24.012]         }
[16:11:24.012]         base::close(...future.stdout)
[16:11:24.012]         ...future.stdout <- NULL
[16:11:24.012]     }
[16:11:24.012]     ...future.result$conditions <- ...future.conditions
[16:11:24.012]     ...future.result$finished <- base::Sys.time()
[16:11:24.012]     ...future.result
[16:11:24.012] }
[16:11:24.015] assign_globals() ...
[16:11:24.015] List of 5
[16:11:24.015]  $ ...future.FUN            :function (x, y)  
[16:11:24.015]  $ MoreArgs                 : NULL
[16:11:24.015]  $ ...future.elements_ii    :List of 2
[16:11:24.015]   ..$ :List of 1
[16:11:24.015]   .. ..$ : int 1
[16:11:24.015]   ..$ :List of 1
[16:11:24.015]   .. ..$ : int 0
[16:11:24.015]  $ ...future.seeds_ii       : NULL
[16:11:24.015]  $ ...future.globals.maxSize: NULL
[16:11:24.015]  - attr(*, "where")=List of 5
[16:11:24.015]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:24.015]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:24.015]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:24.015]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:24.015]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:24.015]  - attr(*, "resolved")= logi FALSE
[16:11:24.015]  - attr(*, "total_size")= num 6368
[16:11:24.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:24.015]  - attr(*, "already-done")= logi TRUE
[16:11:24.021] - reassign environment for ‘...future.FUN’
[16:11:24.021] - copied ‘...future.FUN’ to environment
[16:11:24.021] - copied ‘MoreArgs’ to environment
[16:11:24.021] - copied ‘...future.elements_ii’ to environment
[16:11:24.021] - copied ‘...future.seeds_ii’ to environment
[16:11:24.021] - copied ‘...future.globals.maxSize’ to environment
[16:11:24.021] assign_globals() ... done
[16:11:24.021] requestCore(): workers = 2
[16:11:24.023] MulticoreFuture started
[16:11:24.024] - Launch lazy future ... done
[16:11:24.024] run() for ‘MulticoreFuture’ ... done
[16:11:24.024] Created future:
[16:11:24.024] plan(): Setting new future strategy stack:
[16:11:24.025] List of future strategies:
[16:11:24.025] 1. sequential:
[16:11:24.025]    - args: function (..., envir = parent.frame())
[16:11:24.025]    - tweaked: FALSE
[16:11:24.025]    - call: NULL
[16:11:24.025] plan(): nbrOfWorkers() = 1
[16:11:24.024] MulticoreFuture:
[16:11:24.024] Label: ‘future_mapply-1’
[16:11:24.024] Expression:
[16:11:24.024] {
[16:11:24.024]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:24.024]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:24.024]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:24.024]         on.exit(options(oopts), add = TRUE)
[16:11:24.024]     }
[16:11:24.024]     {
[16:11:24.024]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:24.024]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:24.024]         do.call(mapply, args = args)
[16:11:24.024]     }
[16:11:24.024] }
[16:11:24.024] Lazy evaluation: FALSE
[16:11:24.024] Asynchronous evaluation: TRUE
[16:11:24.024] Local evaluation: TRUE
[16:11:24.024] Environment: R_GlobalEnv
[16:11:24.024] Capture standard output: TRUE
[16:11:24.024] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:24.024] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:24.024] Packages: <none>
[16:11:24.024] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:24.024] Resolved: FALSE
[16:11:24.024] Value: <not collected>
[16:11:24.024] Conditions captured: <none>
[16:11:24.024] Early signaling: FALSE
[16:11:24.024] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:24.024] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:24.037] Chunk #1 of 2 ... DONE
[16:11:24.037] Chunk #2 of 2 ...
[16:11:24.037]  - Finding globals in '...' for chunk #2 ...
[16:11:24.037] getGlobalsAndPackages() ...
[16:11:24.037] Searching for globals...
[16:11:24.038] 
[16:11:24.038] Searching for globals ... DONE
[16:11:24.038] - globals: [0] <none>
[16:11:24.038] getGlobalsAndPackages() ... DONE
[16:11:24.039]    + additional globals found: [n=0] 
[16:11:24.039]    + additional namespaces needed: [n=0] 
[16:11:24.039]  - Finding globals in '...' for chunk #2 ... DONE
[16:11:24.039]  - seeds: <none>
[16:11:24.039] getGlobalsAndPackages() ...
[16:11:24.039] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:24.040] Resolving globals: FALSE
[16:11:24.041] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:24.042] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:24.042] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:24.042] 
[16:11:24.042] getGlobalsAndPackages() ... DONE
[16:11:24.043] run() for ‘Future’ ...
[16:11:24.043] - state: ‘created’
[16:11:24.043] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:24.048] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:24.048] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:24.048]   - Field: ‘label’
[16:11:24.049]   - Field: ‘local’
[16:11:24.049]   - Field: ‘owner’
[16:11:24.049]   - Field: ‘envir’
[16:11:24.049]   - Field: ‘workers’
[16:11:24.049]   - Field: ‘packages’
[16:11:24.049]   - Field: ‘gc’
[16:11:24.049]   - Field: ‘job’
[16:11:24.050]   - Field: ‘conditions’
[16:11:24.050]   - Field: ‘expr’
[16:11:24.050]   - Field: ‘uuid’
[16:11:24.050]   - Field: ‘seed’
[16:11:24.050]   - Field: ‘version’
[16:11:24.050]   - Field: ‘result’
[16:11:24.050]   - Field: ‘asynchronous’
[16:11:24.051]   - Field: ‘calls’
[16:11:24.051]   - Field: ‘globals’
[16:11:24.051]   - Field: ‘stdout’
[16:11:24.051]   - Field: ‘earlySignal’
[16:11:24.051]   - Field: ‘lazy’
[16:11:24.051]   - Field: ‘state’
[16:11:24.052] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:24.052] - Launch lazy future ...
[16:11:24.052] Packages needed by the future expression (n = 0): <none>
[16:11:24.052] Packages needed by future strategies (n = 0): <none>
[16:11:24.053] {
[16:11:24.053]     {
[16:11:24.053]         {
[16:11:24.053]             ...future.startTime <- base::Sys.time()
[16:11:24.053]             {
[16:11:24.053]                 {
[16:11:24.053]                   {
[16:11:24.053]                     {
[16:11:24.053]                       base::local({
[16:11:24.053]                         has_future <- base::requireNamespace("future", 
[16:11:24.053]                           quietly = TRUE)
[16:11:24.053]                         if (has_future) {
[16:11:24.053]                           ns <- base::getNamespace("future")
[16:11:24.053]                           version <- ns[[".package"]][["version"]]
[16:11:24.053]                           if (is.null(version)) 
[16:11:24.053]                             version <- utils::packageVersion("future")
[16:11:24.053]                         }
[16:11:24.053]                         else {
[16:11:24.053]                           version <- NULL
[16:11:24.053]                         }
[16:11:24.053]                         if (!has_future || version < "1.8.0") {
[16:11:24.053]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:24.053]                             "", base::R.version$version.string), 
[16:11:24.053]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:24.053]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:24.053]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:24.053]                               "release", "version")], collapse = " "), 
[16:11:24.053]                             hostname = base::Sys.info()[["nodename"]])
[16:11:24.053]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:24.053]                             info)
[16:11:24.053]                           info <- base::paste(info, collapse = "; ")
[16:11:24.053]                           if (!has_future) {
[16:11:24.053]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:24.053]                               info)
[16:11:24.053]                           }
[16:11:24.053]                           else {
[16:11:24.053]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:24.053]                               info, version)
[16:11:24.053]                           }
[16:11:24.053]                           base::stop(msg)
[16:11:24.053]                         }
[16:11:24.053]                       })
[16:11:24.053]                     }
[16:11:24.053]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:24.053]                     base::options(mc.cores = 1L)
[16:11:24.053]                   }
[16:11:24.053]                   options(future.plan = NULL)
[16:11:24.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:24.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:24.053]                 }
[16:11:24.053]                 ...future.workdir <- getwd()
[16:11:24.053]             }
[16:11:24.053]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:24.053]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:24.053]         }
[16:11:24.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:24.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:24.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:24.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:24.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:24.053]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:24.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:24.053]             base::names(...future.oldOptions))
[16:11:24.053]     }
[16:11:24.053]     if (FALSE) {
[16:11:24.053]     }
[16:11:24.053]     else {
[16:11:24.053]         if (TRUE) {
[16:11:24.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:24.053]                 open = "w")
[16:11:24.053]         }
[16:11:24.053]         else {
[16:11:24.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:24.053]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:24.053]         }
[16:11:24.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:24.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:24.053]             base::sink(type = "output", split = FALSE)
[16:11:24.053]             base::close(...future.stdout)
[16:11:24.053]         }, add = TRUE)
[16:11:24.053]     }
[16:11:24.053]     ...future.frame <- base::sys.nframe()
[16:11:24.053]     ...future.conditions <- base::list()
[16:11:24.053]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:24.053]     if (FALSE) {
[16:11:24.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:24.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:24.053]     }
[16:11:24.053]     ...future.result <- base::tryCatch({
[16:11:24.053]         base::withCallingHandlers({
[16:11:24.053]             ...future.value <- base::withVisible(base::local({
[16:11:24.053]                 withCallingHandlers({
[16:11:24.053]                   {
[16:11:24.053]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:24.053]                     if (!identical(...future.globals.maxSize.org, 
[16:11:24.053]                       ...future.globals.maxSize)) {
[16:11:24.053]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:24.053]                       on.exit(options(oopts), add = TRUE)
[16:11:24.053]                     }
[16:11:24.053]                     {
[16:11:24.053]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:24.053]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:24.053]                         USE.NAMES = FALSE)
[16:11:24.053]                       do.call(mapply, args = args)
[16:11:24.053]                     }
[16:11:24.053]                   }
[16:11:24.053]                 }, immediateCondition = function(cond) {
[16:11:24.053]                   save_rds <- function (object, pathname, ...) 
[16:11:24.053]                   {
[16:11:24.053]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:24.053]                     if (file_test("-f", pathname_tmp)) {
[16:11:24.053]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.053]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:24.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.053]                         fi_tmp[["mtime"]])
[16:11:24.053]                     }
[16:11:24.053]                     tryCatch({
[16:11:24.053]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:24.053]                     }, error = function(ex) {
[16:11:24.053]                       msg <- conditionMessage(ex)
[16:11:24.053]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.053]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:24.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.053]                         fi_tmp[["mtime"]], msg)
[16:11:24.053]                       ex$message <- msg
[16:11:24.053]                       stop(ex)
[16:11:24.053]                     })
[16:11:24.053]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:24.053]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:24.053]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:24.053]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.053]                       fi <- file.info(pathname)
[16:11:24.053]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:24.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.053]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:24.053]                         fi[["size"]], fi[["mtime"]])
[16:11:24.053]                       stop(msg)
[16:11:24.053]                     }
[16:11:24.053]                     invisible(pathname)
[16:11:24.053]                   }
[16:11:24.053]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:24.053]                     rootPath = tempdir()) 
[16:11:24.053]                   {
[16:11:24.053]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:24.053]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:24.053]                       tmpdir = path, fileext = ".rds")
[16:11:24.053]                     save_rds(obj, file)
[16:11:24.053]                   }
[16:11:24.053]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:24.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.053]                   {
[16:11:24.053]                     inherits <- base::inherits
[16:11:24.053]                     invokeRestart <- base::invokeRestart
[16:11:24.053]                     is.null <- base::is.null
[16:11:24.053]                     muffled <- FALSE
[16:11:24.053]                     if (inherits(cond, "message")) {
[16:11:24.053]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:24.053]                       if (muffled) 
[16:11:24.053]                         invokeRestart("muffleMessage")
[16:11:24.053]                     }
[16:11:24.053]                     else if (inherits(cond, "warning")) {
[16:11:24.053]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:24.053]                       if (muffled) 
[16:11:24.053]                         invokeRestart("muffleWarning")
[16:11:24.053]                     }
[16:11:24.053]                     else if (inherits(cond, "condition")) {
[16:11:24.053]                       if (!is.null(pattern)) {
[16:11:24.053]                         computeRestarts <- base::computeRestarts
[16:11:24.053]                         grepl <- base::grepl
[16:11:24.053]                         restarts <- computeRestarts(cond)
[16:11:24.053]                         for (restart in restarts) {
[16:11:24.053]                           name <- restart$name
[16:11:24.053]                           if (is.null(name)) 
[16:11:24.053]                             next
[16:11:24.053]                           if (!grepl(pattern, name)) 
[16:11:24.053]                             next
[16:11:24.053]                           invokeRestart(restart)
[16:11:24.053]                           muffled <- TRUE
[16:11:24.053]                           break
[16:11:24.053]                         }
[16:11:24.053]                       }
[16:11:24.053]                     }
[16:11:24.053]                     invisible(muffled)
[16:11:24.053]                   }
[16:11:24.053]                   muffleCondition(cond)
[16:11:24.053]                 })
[16:11:24.053]             }))
[16:11:24.053]             future::FutureResult(value = ...future.value$value, 
[16:11:24.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:24.053]                   ...future.rng), globalenv = if (FALSE) 
[16:11:24.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:24.053]                     ...future.globalenv.names))
[16:11:24.053]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:24.053]         }, condition = base::local({
[16:11:24.053]             c <- base::c
[16:11:24.053]             inherits <- base::inherits
[16:11:24.053]             invokeRestart <- base::invokeRestart
[16:11:24.053]             length <- base::length
[16:11:24.053]             list <- base::list
[16:11:24.053]             seq.int <- base::seq.int
[16:11:24.053]             signalCondition <- base::signalCondition
[16:11:24.053]             sys.calls <- base::sys.calls
[16:11:24.053]             `[[` <- base::`[[`
[16:11:24.053]             `+` <- base::`+`
[16:11:24.053]             `<<-` <- base::`<<-`
[16:11:24.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:24.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:24.053]                   3L)]
[16:11:24.053]             }
[16:11:24.053]             function(cond) {
[16:11:24.053]                 is_error <- inherits(cond, "error")
[16:11:24.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:24.053]                   NULL)
[16:11:24.053]                 if (is_error) {
[16:11:24.053]                   sessionInformation <- function() {
[16:11:24.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:24.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:24.053]                       search = base::search(), system = base::Sys.info())
[16:11:24.053]                   }
[16:11:24.053]                   ...future.conditions[[length(...future.conditions) + 
[16:11:24.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:24.053]                     cond$call), session = sessionInformation(), 
[16:11:24.053]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:24.053]                   signalCondition(cond)
[16:11:24.053]                 }
[16:11:24.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:24.053]                 "immediateCondition"))) {
[16:11:24.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:24.053]                   ...future.conditions[[length(...future.conditions) + 
[16:11:24.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:24.053]                   if (TRUE && !signal) {
[16:11:24.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.053]                     {
[16:11:24.053]                       inherits <- base::inherits
[16:11:24.053]                       invokeRestart <- base::invokeRestart
[16:11:24.053]                       is.null <- base::is.null
[16:11:24.053]                       muffled <- FALSE
[16:11:24.053]                       if (inherits(cond, "message")) {
[16:11:24.053]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:24.053]                         if (muffled) 
[16:11:24.053]                           invokeRestart("muffleMessage")
[16:11:24.053]                       }
[16:11:24.053]                       else if (inherits(cond, "warning")) {
[16:11:24.053]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:24.053]                         if (muffled) 
[16:11:24.053]                           invokeRestart("muffleWarning")
[16:11:24.053]                       }
[16:11:24.053]                       else if (inherits(cond, "condition")) {
[16:11:24.053]                         if (!is.null(pattern)) {
[16:11:24.053]                           computeRestarts <- base::computeRestarts
[16:11:24.053]                           grepl <- base::grepl
[16:11:24.053]                           restarts <- computeRestarts(cond)
[16:11:24.053]                           for (restart in restarts) {
[16:11:24.053]                             name <- restart$name
[16:11:24.053]                             if (is.null(name)) 
[16:11:24.053]                               next
[16:11:24.053]                             if (!grepl(pattern, name)) 
[16:11:24.053]                               next
[16:11:24.053]                             invokeRestart(restart)
[16:11:24.053]                             muffled <- TRUE
[16:11:24.053]                             break
[16:11:24.053]                           }
[16:11:24.053]                         }
[16:11:24.053]                       }
[16:11:24.053]                       invisible(muffled)
[16:11:24.053]                     }
[16:11:24.053]                     muffleCondition(cond, pattern = "^muffle")
[16:11:24.053]                   }
[16:11:24.053]                 }
[16:11:24.053]                 else {
[16:11:24.053]                   if (TRUE) {
[16:11:24.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.053]                     {
[16:11:24.053]                       inherits <- base::inherits
[16:11:24.053]                       invokeRestart <- base::invokeRestart
[16:11:24.053]                       is.null <- base::is.null
[16:11:24.053]                       muffled <- FALSE
[16:11:24.053]                       if (inherits(cond, "message")) {
[16:11:24.053]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:24.053]                         if (muffled) 
[16:11:24.053]                           invokeRestart("muffleMessage")
[16:11:24.053]                       }
[16:11:24.053]                       else if (inherits(cond, "warning")) {
[16:11:24.053]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:24.053]                         if (muffled) 
[16:11:24.053]                           invokeRestart("muffleWarning")
[16:11:24.053]                       }
[16:11:24.053]                       else if (inherits(cond, "condition")) {
[16:11:24.053]                         if (!is.null(pattern)) {
[16:11:24.053]                           computeRestarts <- base::computeRestarts
[16:11:24.053]                           grepl <- base::grepl
[16:11:24.053]                           restarts <- computeRestarts(cond)
[16:11:24.053]                           for (restart in restarts) {
[16:11:24.053]                             name <- restart$name
[16:11:24.053]                             if (is.null(name)) 
[16:11:24.053]                               next
[16:11:24.053]                             if (!grepl(pattern, name)) 
[16:11:24.053]                               next
[16:11:24.053]                             invokeRestart(restart)
[16:11:24.053]                             muffled <- TRUE
[16:11:24.053]                             break
[16:11:24.053]                           }
[16:11:24.053]                         }
[16:11:24.053]                       }
[16:11:24.053]                       invisible(muffled)
[16:11:24.053]                     }
[16:11:24.053]                     muffleCondition(cond, pattern = "^muffle")
[16:11:24.053]                   }
[16:11:24.053]                 }
[16:11:24.053]             }
[16:11:24.053]         }))
[16:11:24.053]     }, error = function(ex) {
[16:11:24.053]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:24.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:24.053]                 ...future.rng), started = ...future.startTime, 
[16:11:24.053]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:24.053]             version = "1.8"), class = "FutureResult")
[16:11:24.053]     }, finally = {
[16:11:24.053]         if (!identical(...future.workdir, getwd())) 
[16:11:24.053]             setwd(...future.workdir)
[16:11:24.053]         {
[16:11:24.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:24.053]                 ...future.oldOptions$nwarnings <- NULL
[16:11:24.053]             }
[16:11:24.053]             base::options(...future.oldOptions)
[16:11:24.053]             if (.Platform$OS.type == "windows") {
[16:11:24.053]                 old_names <- names(...future.oldEnvVars)
[16:11:24.053]                 envs <- base::Sys.getenv()
[16:11:24.053]                 names <- names(envs)
[16:11:24.053]                 common <- intersect(names, old_names)
[16:11:24.053]                 added <- setdiff(names, old_names)
[16:11:24.053]                 removed <- setdiff(old_names, names)
[16:11:24.053]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:24.053]                   envs[common]]
[16:11:24.053]                 NAMES <- toupper(changed)
[16:11:24.053]                 args <- list()
[16:11:24.053]                 for (kk in seq_along(NAMES)) {
[16:11:24.053]                   name <- changed[[kk]]
[16:11:24.053]                   NAME <- NAMES[[kk]]
[16:11:24.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.053]                     next
[16:11:24.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:24.053]                 }
[16:11:24.053]                 NAMES <- toupper(added)
[16:11:24.053]                 for (kk in seq_along(NAMES)) {
[16:11:24.053]                   name <- added[[kk]]
[16:11:24.053]                   NAME <- NAMES[[kk]]
[16:11:24.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.053]                     next
[16:11:24.053]                   args[[name]] <- ""
[16:11:24.053]                 }
[16:11:24.053]                 NAMES <- toupper(removed)
[16:11:24.053]                 for (kk in seq_along(NAMES)) {
[16:11:24.053]                   name <- removed[[kk]]
[16:11:24.053]                   NAME <- NAMES[[kk]]
[16:11:24.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.053]                     next
[16:11:24.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:24.053]                 }
[16:11:24.053]                 if (length(args) > 0) 
[16:11:24.053]                   base::do.call(base::Sys.setenv, args = args)
[16:11:24.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:24.053]             }
[16:11:24.053]             else {
[16:11:24.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:24.053]             }
[16:11:24.053]             {
[16:11:24.053]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:24.053]                   0L) {
[16:11:24.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:24.053]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:24.053]                   base::options(opts)
[16:11:24.053]                 }
[16:11:24.053]                 {
[16:11:24.053]                   {
[16:11:24.053]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:24.053]                     NULL
[16:11:24.053]                   }
[16:11:24.053]                   options(future.plan = NULL)
[16:11:24.053]                   if (is.na(NA_character_)) 
[16:11:24.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:24.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:24.053]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:24.053]                     envir = parent.frame()) 
[16:11:24.053]                   {
[16:11:24.053]                     default_workers <- missing(workers)
[16:11:24.053]                     if (is.function(workers)) 
[16:11:24.053]                       workers <- workers()
[16:11:24.053]                     workers <- structure(as.integer(workers), 
[16:11:24.053]                       class = class(workers))
[16:11:24.053]                     stop_if_not(is.finite(workers), workers >= 
[16:11:24.053]                       1L)
[16:11:24.053]                     if ((workers == 1L && !inherits(workers, 
[16:11:24.053]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:24.053]                       if (default_workers) 
[16:11:24.053]                         supportsMulticore(warn = TRUE)
[16:11:24.053]                       return(sequential(..., envir = envir))
[16:11:24.053]                     }
[16:11:24.053]                     oopts <- options(mc.cores = workers)
[16:11:24.053]                     on.exit(options(oopts))
[16:11:24.053]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:24.053]                       envir = envir)
[16:11:24.053]                     if (!future$lazy) 
[16:11:24.053]                       future <- run(future)
[16:11:24.053]                     invisible(future)
[16:11:24.053]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:24.053]                 }
[16:11:24.053]             }
[16:11:24.053]         }
[16:11:24.053]     })
[16:11:24.053]     if (TRUE) {
[16:11:24.053]         base::sink(type = "output", split = FALSE)
[16:11:24.053]         if (TRUE) {
[16:11:24.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:24.053]         }
[16:11:24.053]         else {
[16:11:24.053]             ...future.result["stdout"] <- base::list(NULL)
[16:11:24.053]         }
[16:11:24.053]         base::close(...future.stdout)
[16:11:24.053]         ...future.stdout <- NULL
[16:11:24.053]     }
[16:11:24.053]     ...future.result$conditions <- ...future.conditions
[16:11:24.053]     ...future.result$finished <- base::Sys.time()
[16:11:24.053]     ...future.result
[16:11:24.053] }
[16:11:24.056] assign_globals() ...
[16:11:24.057] List of 5
[16:11:24.057]  $ ...future.FUN            :function (x, y)  
[16:11:24.057]  $ MoreArgs                 : NULL
[16:11:24.057]  $ ...future.elements_ii    :List of 2
[16:11:24.057]   ..$ :List of 1
[16:11:24.057]   .. ..$ : int 0
[16:11:24.057]   ..$ :List of 1
[16:11:24.057]   .. ..$ : int 1
[16:11:24.057]  $ ...future.seeds_ii       : NULL
[16:11:24.057]  $ ...future.globals.maxSize: NULL
[16:11:24.057]  - attr(*, "where")=List of 5
[16:11:24.057]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:24.057]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:24.057]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:24.057]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:24.057]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:24.057]  - attr(*, "resolved")= logi FALSE
[16:11:24.057]  - attr(*, "total_size")= num 6368
[16:11:24.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:24.057]  - attr(*, "already-done")= logi TRUE
[16:11:24.071] - reassign environment for ‘...future.FUN’
[16:11:24.072] - copied ‘...future.FUN’ to environment
[16:11:24.072] - copied ‘MoreArgs’ to environment
[16:11:24.072] - copied ‘...future.elements_ii’ to environment
[16:11:24.072] - copied ‘...future.seeds_ii’ to environment
[16:11:24.072] - copied ‘...future.globals.maxSize’ to environment
[16:11:24.072] assign_globals() ... done
[16:11:24.073] requestCore(): workers = 2
[16:11:24.075] MulticoreFuture started
[16:11:24.075] - Launch lazy future ... done
[16:11:24.076] run() for ‘MulticoreFuture’ ... done
[16:11:24.076] Created future:
[16:11:24.076] plan(): Setting new future strategy stack:
[16:11:24.076] List of future strategies:
[16:11:24.076] 1. sequential:
[16:11:24.076]    - args: function (..., envir = parent.frame())
[16:11:24.076]    - tweaked: FALSE
[16:11:24.076]    - call: NULL
[16:11:24.078] plan(): nbrOfWorkers() = 1
[16:11:24.080] plan(): Setting new future strategy stack:
[16:11:24.080] List of future strategies:
[16:11:24.080] 1. multicore:
[16:11:24.080]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:24.080]    - tweaked: FALSE
[16:11:24.080]    - call: plan(strategy)
[16:11:24.086] plan(): nbrOfWorkers() = 2
[16:11:24.076] MulticoreFuture:
[16:11:24.076] Label: ‘future_mapply-2’
[16:11:24.076] Expression:
[16:11:24.076] {
[16:11:24.076]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:24.076]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:24.076]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:24.076]         on.exit(options(oopts), add = TRUE)
[16:11:24.076]     }
[16:11:24.076]     {
[16:11:24.076]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:24.076]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:24.076]         do.call(mapply, args = args)
[16:11:24.076]     }
[16:11:24.076] }
[16:11:24.076] Lazy evaluation: FALSE
[16:11:24.076] Asynchronous evaluation: TRUE
[16:11:24.076] Local evaluation: TRUE
[16:11:24.076] Environment: R_GlobalEnv
[16:11:24.076] Capture standard output: TRUE
[16:11:24.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:24.076] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:24.076] Packages: <none>
[16:11:24.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:24.076] Resolved: TRUE
[16:11:24.076] Value: <not collected>
[16:11:24.076] Conditions captured: <none>
[16:11:24.076] Early signaling: FALSE
[16:11:24.076] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:24.076] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:24.087] Chunk #2 of 2 ... DONE
[16:11:24.087] Launching 2 futures (chunks) ... DONE
[16:11:24.088] Resolving 2 futures (chunks) ...
[16:11:24.088] resolve() on list ...
[16:11:24.088]  recursive: 0
[16:11:24.088]  length: 2
[16:11:24.089] 
[16:11:24.099] Future #2
[16:11:24.101] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:24.101] - nx: 2
[16:11:24.101] - relay: TRUE
[16:11:24.101] - stdout: TRUE
[16:11:24.101] - signal: TRUE
[16:11:24.102] - resignal: FALSE
[16:11:24.102] - force: TRUE
[16:11:24.102] - relayed: [n=2] FALSE, FALSE
[16:11:24.102] - queued futures: [n=2] FALSE, FALSE
[16:11:24.102]  - until=1
[16:11:24.102]  - relaying element #1
[16:11:24.103] - relayed: [n=2] FALSE, FALSE
[16:11:24.103] - queued futures: [n=2] FALSE, TRUE
[16:11:24.103] signalConditionsASAP(NULL, pos=2) ... done
[16:11:24.103]  length: 1 (resolved future 2)
[16:11:24.528] plan(): Setting new future strategy stack:
[16:11:24.528] List of future strategies:
[16:11:24.528] 1. multicore:
[16:11:24.528]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:24.528]    - tweaked: FALSE
[16:11:24.528]    - call: plan(strategy)
[16:11:24.533] plan(): nbrOfWorkers() = 2
[16:11:24.541] Future #1
[16:11:24.542] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:24.542] - nx: 2
[16:11:24.542] - relay: TRUE
[16:11:24.542] - stdout: TRUE
[16:11:24.542] - signal: TRUE
[16:11:24.543] - resignal: FALSE
[16:11:24.543] - force: TRUE
[16:11:24.543] - relayed: [n=2] FALSE, FALSE
[16:11:24.543] - queued futures: [n=2] FALSE, TRUE
[16:11:24.543]  - until=1
[16:11:24.543]  - relaying element #1
[16:11:24.543] - relayed: [n=2] TRUE, FALSE
[16:11:24.543] - queued futures: [n=2] TRUE, TRUE
[16:11:24.544] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:24.544]  length: 0 (resolved future 1)
[16:11:24.544] Relaying remaining futures
[16:11:24.544] signalConditionsASAP(NULL, pos=0) ...
[16:11:24.544] - nx: 2
[16:11:24.544] - relay: TRUE
[16:11:24.544] - stdout: TRUE
[16:11:24.544] - signal: TRUE
[16:11:24.545] - resignal: FALSE
[16:11:24.545] - force: TRUE
[16:11:24.545] - relayed: [n=2] TRUE, FALSE
[16:11:24.545] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:24.545]  - relaying element #2
[16:11:24.545] - relayed: [n=2] TRUE, TRUE
[16:11:24.545] - queued futures: [n=2] TRUE, TRUE
[16:11:24.546] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:11:24.546] resolve() on list ... DONE
[16:11:24.546]  - Number of value chunks collected: 2
[16:11:24.546] Resolving 2 futures (chunks) ... DONE
[16:11:24.546] Reducing values from 2 chunks ...
[16:11:24.546]  - Number of values collected after concatenation: 2
[16:11:24.546]  - Number of values expected: 2
[16:11:24.547] Reducing values from 2 chunks ... DONE
[16:11:24.547] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:11:24.547] future_mapply() ...
[16:11:24.551] Number of chunks: 2
[16:11:24.551] getGlobalsAndPackagesXApply() ...
[16:11:24.552]  - future.globals: TRUE
[16:11:24.552] getGlobalsAndPackages() ...
[16:11:24.552] Searching for globals...
[16:11:24.554] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:24.554] Searching for globals ... DONE
[16:11:24.554] Resolving globals: FALSE
[16:11:24.555] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:24.555] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:24.555] - globals: [1] ‘FUN’
[16:11:24.555] 
[16:11:24.555] getGlobalsAndPackages() ... DONE
[16:11:24.555]  - globals found/used: [n=1] ‘FUN’
[16:11:24.556]  - needed namespaces: [n=0] 
[16:11:24.556] Finding globals ... DONE
[16:11:24.556] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:24.556] List of 2
[16:11:24.556]  $ ...future.FUN:function (x, y)  
[16:11:24.556]  $ MoreArgs     : NULL
[16:11:24.556]  - attr(*, "where")=List of 2
[16:11:24.556]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:24.556]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:24.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:24.556]  - attr(*, "resolved")= logi FALSE
[16:11:24.556]  - attr(*, "total_size")= num NA
[16:11:24.559] Packages to be attached in all futures: [n=0] 
[16:11:24.559] getGlobalsAndPackagesXApply() ... DONE
[16:11:24.559] Number of futures (= number of chunks): 2
[16:11:24.560] Launching 2 futures (chunks) ...
[16:11:24.561] Chunk #1 of 2 ...
[16:11:24.562]  - Finding globals in '...' for chunk #1 ...
[16:11:24.562] getGlobalsAndPackages() ...
[16:11:24.562] Searching for globals...
[16:11:24.562] 
[16:11:24.562] Searching for globals ... DONE
[16:11:24.563] - globals: [0] <none>
[16:11:24.563] getGlobalsAndPackages() ... DONE
[16:11:24.563]    + additional globals found: [n=0] 
[16:11:24.563]    + additional namespaces needed: [n=0] 
[16:11:24.563]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:24.563]  - seeds: <none>
[16:11:24.563] getGlobalsAndPackages() ...
[16:11:24.563] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:24.564] Resolving globals: FALSE
[16:11:24.564] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:24.565] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:24.565] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:24.565] 
[16:11:24.565] getGlobalsAndPackages() ... DONE
[16:11:24.566] run() for ‘Future’ ...
[16:11:24.566] - state: ‘created’
[16:11:24.566] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:24.569] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:24.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:24.570]   - Field: ‘label’
[16:11:24.570]   - Field: ‘local’
[16:11:24.570]   - Field: ‘owner’
[16:11:24.570]   - Field: ‘envir’
[16:11:24.570]   - Field: ‘workers’
[16:11:24.570]   - Field: ‘packages’
[16:11:24.570]   - Field: ‘gc’
[16:11:24.570]   - Field: ‘job’
[16:11:24.570]   - Field: ‘conditions’
[16:11:24.571]   - Field: ‘expr’
[16:11:24.571]   - Field: ‘uuid’
[16:11:24.571]   - Field: ‘seed’
[16:11:24.571]   - Field: ‘version’
[16:11:24.571]   - Field: ‘result’
[16:11:24.571]   - Field: ‘asynchronous’
[16:11:24.571]   - Field: ‘calls’
[16:11:24.571]   - Field: ‘globals’
[16:11:24.571]   - Field: ‘stdout’
[16:11:24.571]   - Field: ‘earlySignal’
[16:11:24.571]   - Field: ‘lazy’
[16:11:24.572]   - Field: ‘state’
[16:11:24.572] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:24.572] - Launch lazy future ...
[16:11:24.572] Packages needed by the future expression (n = 0): <none>
[16:11:24.572] Packages needed by future strategies (n = 0): <none>
[16:11:24.573] {
[16:11:24.573]     {
[16:11:24.573]         {
[16:11:24.573]             ...future.startTime <- base::Sys.time()
[16:11:24.573]             {
[16:11:24.573]                 {
[16:11:24.573]                   {
[16:11:24.573]                     {
[16:11:24.573]                       base::local({
[16:11:24.573]                         has_future <- base::requireNamespace("future", 
[16:11:24.573]                           quietly = TRUE)
[16:11:24.573]                         if (has_future) {
[16:11:24.573]                           ns <- base::getNamespace("future")
[16:11:24.573]                           version <- ns[[".package"]][["version"]]
[16:11:24.573]                           if (is.null(version)) 
[16:11:24.573]                             version <- utils::packageVersion("future")
[16:11:24.573]                         }
[16:11:24.573]                         else {
[16:11:24.573]                           version <- NULL
[16:11:24.573]                         }
[16:11:24.573]                         if (!has_future || version < "1.8.0") {
[16:11:24.573]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:24.573]                             "", base::R.version$version.string), 
[16:11:24.573]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:24.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:24.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:24.573]                               "release", "version")], collapse = " "), 
[16:11:24.573]                             hostname = base::Sys.info()[["nodename"]])
[16:11:24.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:24.573]                             info)
[16:11:24.573]                           info <- base::paste(info, collapse = "; ")
[16:11:24.573]                           if (!has_future) {
[16:11:24.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:24.573]                               info)
[16:11:24.573]                           }
[16:11:24.573]                           else {
[16:11:24.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:24.573]                               info, version)
[16:11:24.573]                           }
[16:11:24.573]                           base::stop(msg)
[16:11:24.573]                         }
[16:11:24.573]                       })
[16:11:24.573]                     }
[16:11:24.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:24.573]                     base::options(mc.cores = 1L)
[16:11:24.573]                   }
[16:11:24.573]                   options(future.plan = NULL)
[16:11:24.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:24.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:24.573]                 }
[16:11:24.573]                 ...future.workdir <- getwd()
[16:11:24.573]             }
[16:11:24.573]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:24.573]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:24.573]         }
[16:11:24.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:24.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:24.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:24.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:24.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:24.573]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:24.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:24.573]             base::names(...future.oldOptions))
[16:11:24.573]     }
[16:11:24.573]     if (TRUE) {
[16:11:24.573]     }
[16:11:24.573]     else {
[16:11:24.573]         if (NA) {
[16:11:24.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:24.573]                 open = "w")
[16:11:24.573]         }
[16:11:24.573]         else {
[16:11:24.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:24.573]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:24.573]         }
[16:11:24.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:24.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:24.573]             base::sink(type = "output", split = FALSE)
[16:11:24.573]             base::close(...future.stdout)
[16:11:24.573]         }, add = TRUE)
[16:11:24.573]     }
[16:11:24.573]     ...future.frame <- base::sys.nframe()
[16:11:24.573]     ...future.conditions <- base::list()
[16:11:24.573]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:24.573]     if (FALSE) {
[16:11:24.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:24.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:24.573]     }
[16:11:24.573]     ...future.result <- base::tryCatch({
[16:11:24.573]         base::withCallingHandlers({
[16:11:24.573]             ...future.value <- base::withVisible(base::local({
[16:11:24.573]                 withCallingHandlers({
[16:11:24.573]                   {
[16:11:24.573]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:24.573]                     if (!identical(...future.globals.maxSize.org, 
[16:11:24.573]                       ...future.globals.maxSize)) {
[16:11:24.573]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:24.573]                       on.exit(options(oopts), add = TRUE)
[16:11:24.573]                     }
[16:11:24.573]                     {
[16:11:24.573]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:24.573]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:24.573]                         USE.NAMES = FALSE)
[16:11:24.573]                       do.call(mapply, args = args)
[16:11:24.573]                     }
[16:11:24.573]                   }
[16:11:24.573]                 }, immediateCondition = function(cond) {
[16:11:24.573]                   save_rds <- function (object, pathname, ...) 
[16:11:24.573]                   {
[16:11:24.573]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:24.573]                     if (file_test("-f", pathname_tmp)) {
[16:11:24.573]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.573]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:24.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.573]                         fi_tmp[["mtime"]])
[16:11:24.573]                     }
[16:11:24.573]                     tryCatch({
[16:11:24.573]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:24.573]                     }, error = function(ex) {
[16:11:24.573]                       msg <- conditionMessage(ex)
[16:11:24.573]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.573]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:24.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.573]                         fi_tmp[["mtime"]], msg)
[16:11:24.573]                       ex$message <- msg
[16:11:24.573]                       stop(ex)
[16:11:24.573]                     })
[16:11:24.573]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:24.573]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:24.573]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:24.573]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.573]                       fi <- file.info(pathname)
[16:11:24.573]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:24.573]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.573]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:24.573]                         fi[["size"]], fi[["mtime"]])
[16:11:24.573]                       stop(msg)
[16:11:24.573]                     }
[16:11:24.573]                     invisible(pathname)
[16:11:24.573]                   }
[16:11:24.573]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:24.573]                     rootPath = tempdir()) 
[16:11:24.573]                   {
[16:11:24.573]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:24.573]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:24.573]                       tmpdir = path, fileext = ".rds")
[16:11:24.573]                     save_rds(obj, file)
[16:11:24.573]                   }
[16:11:24.573]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:24.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.573]                   {
[16:11:24.573]                     inherits <- base::inherits
[16:11:24.573]                     invokeRestart <- base::invokeRestart
[16:11:24.573]                     is.null <- base::is.null
[16:11:24.573]                     muffled <- FALSE
[16:11:24.573]                     if (inherits(cond, "message")) {
[16:11:24.573]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:24.573]                       if (muffled) 
[16:11:24.573]                         invokeRestart("muffleMessage")
[16:11:24.573]                     }
[16:11:24.573]                     else if (inherits(cond, "warning")) {
[16:11:24.573]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:24.573]                       if (muffled) 
[16:11:24.573]                         invokeRestart("muffleWarning")
[16:11:24.573]                     }
[16:11:24.573]                     else if (inherits(cond, "condition")) {
[16:11:24.573]                       if (!is.null(pattern)) {
[16:11:24.573]                         computeRestarts <- base::computeRestarts
[16:11:24.573]                         grepl <- base::grepl
[16:11:24.573]                         restarts <- computeRestarts(cond)
[16:11:24.573]                         for (restart in restarts) {
[16:11:24.573]                           name <- restart$name
[16:11:24.573]                           if (is.null(name)) 
[16:11:24.573]                             next
[16:11:24.573]                           if (!grepl(pattern, name)) 
[16:11:24.573]                             next
[16:11:24.573]                           invokeRestart(restart)
[16:11:24.573]                           muffled <- TRUE
[16:11:24.573]                           break
[16:11:24.573]                         }
[16:11:24.573]                       }
[16:11:24.573]                     }
[16:11:24.573]                     invisible(muffled)
[16:11:24.573]                   }
[16:11:24.573]                   muffleCondition(cond)
[16:11:24.573]                 })
[16:11:24.573]             }))
[16:11:24.573]             future::FutureResult(value = ...future.value$value, 
[16:11:24.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:24.573]                   ...future.rng), globalenv = if (FALSE) 
[16:11:24.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:24.573]                     ...future.globalenv.names))
[16:11:24.573]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:24.573]         }, condition = base::local({
[16:11:24.573]             c <- base::c
[16:11:24.573]             inherits <- base::inherits
[16:11:24.573]             invokeRestart <- base::invokeRestart
[16:11:24.573]             length <- base::length
[16:11:24.573]             list <- base::list
[16:11:24.573]             seq.int <- base::seq.int
[16:11:24.573]             signalCondition <- base::signalCondition
[16:11:24.573]             sys.calls <- base::sys.calls
[16:11:24.573]             `[[` <- base::`[[`
[16:11:24.573]             `+` <- base::`+`
[16:11:24.573]             `<<-` <- base::`<<-`
[16:11:24.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:24.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:24.573]                   3L)]
[16:11:24.573]             }
[16:11:24.573]             function(cond) {
[16:11:24.573]                 is_error <- inherits(cond, "error")
[16:11:24.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:24.573]                   NULL)
[16:11:24.573]                 if (is_error) {
[16:11:24.573]                   sessionInformation <- function() {
[16:11:24.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:24.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:24.573]                       search = base::search(), system = base::Sys.info())
[16:11:24.573]                   }
[16:11:24.573]                   ...future.conditions[[length(...future.conditions) + 
[16:11:24.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:24.573]                     cond$call), session = sessionInformation(), 
[16:11:24.573]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:24.573]                   signalCondition(cond)
[16:11:24.573]                 }
[16:11:24.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:24.573]                 "immediateCondition"))) {
[16:11:24.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:24.573]                   ...future.conditions[[length(...future.conditions) + 
[16:11:24.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:24.573]                   if (TRUE && !signal) {
[16:11:24.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.573]                     {
[16:11:24.573]                       inherits <- base::inherits
[16:11:24.573]                       invokeRestart <- base::invokeRestart
[16:11:24.573]                       is.null <- base::is.null
[16:11:24.573]                       muffled <- FALSE
[16:11:24.573]                       if (inherits(cond, "message")) {
[16:11:24.573]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:24.573]                         if (muffled) 
[16:11:24.573]                           invokeRestart("muffleMessage")
[16:11:24.573]                       }
[16:11:24.573]                       else if (inherits(cond, "warning")) {
[16:11:24.573]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:24.573]                         if (muffled) 
[16:11:24.573]                           invokeRestart("muffleWarning")
[16:11:24.573]                       }
[16:11:24.573]                       else if (inherits(cond, "condition")) {
[16:11:24.573]                         if (!is.null(pattern)) {
[16:11:24.573]                           computeRestarts <- base::computeRestarts
[16:11:24.573]                           grepl <- base::grepl
[16:11:24.573]                           restarts <- computeRestarts(cond)
[16:11:24.573]                           for (restart in restarts) {
[16:11:24.573]                             name <- restart$name
[16:11:24.573]                             if (is.null(name)) 
[16:11:24.573]                               next
[16:11:24.573]                             if (!grepl(pattern, name)) 
[16:11:24.573]                               next
[16:11:24.573]                             invokeRestart(restart)
[16:11:24.573]                             muffled <- TRUE
[16:11:24.573]                             break
[16:11:24.573]                           }
[16:11:24.573]                         }
[16:11:24.573]                       }
[16:11:24.573]                       invisible(muffled)
[16:11:24.573]                     }
[16:11:24.573]                     muffleCondition(cond, pattern = "^muffle")
[16:11:24.573]                   }
[16:11:24.573]                 }
[16:11:24.573]                 else {
[16:11:24.573]                   if (TRUE) {
[16:11:24.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.573]                     {
[16:11:24.573]                       inherits <- base::inherits
[16:11:24.573]                       invokeRestart <- base::invokeRestart
[16:11:24.573]                       is.null <- base::is.null
[16:11:24.573]                       muffled <- FALSE
[16:11:24.573]                       if (inherits(cond, "message")) {
[16:11:24.573]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:24.573]                         if (muffled) 
[16:11:24.573]                           invokeRestart("muffleMessage")
[16:11:24.573]                       }
[16:11:24.573]                       else if (inherits(cond, "warning")) {
[16:11:24.573]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:24.573]                         if (muffled) 
[16:11:24.573]                           invokeRestart("muffleWarning")
[16:11:24.573]                       }
[16:11:24.573]                       else if (inherits(cond, "condition")) {
[16:11:24.573]                         if (!is.null(pattern)) {
[16:11:24.573]                           computeRestarts <- base::computeRestarts
[16:11:24.573]                           grepl <- base::grepl
[16:11:24.573]                           restarts <- computeRestarts(cond)
[16:11:24.573]                           for (restart in restarts) {
[16:11:24.573]                             name <- restart$name
[16:11:24.573]                             if (is.null(name)) 
[16:11:24.573]                               next
[16:11:24.573]                             if (!grepl(pattern, name)) 
[16:11:24.573]                               next
[16:11:24.573]                             invokeRestart(restart)
[16:11:24.573]                             muffled <- TRUE
[16:11:24.573]                             break
[16:11:24.573]                           }
[16:11:24.573]                         }
[16:11:24.573]                       }
[16:11:24.573]                       invisible(muffled)
[16:11:24.573]                     }
[16:11:24.573]                     muffleCondition(cond, pattern = "^muffle")
[16:11:24.573]                   }
[16:11:24.573]                 }
[16:11:24.573]             }
[16:11:24.573]         }))
[16:11:24.573]     }, error = function(ex) {
[16:11:24.573]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:24.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:24.573]                 ...future.rng), started = ...future.startTime, 
[16:11:24.573]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:24.573]             version = "1.8"), class = "FutureResult")
[16:11:24.573]     }, finally = {
[16:11:24.573]         if (!identical(...future.workdir, getwd())) 
[16:11:24.573]             setwd(...future.workdir)
[16:11:24.573]         {
[16:11:24.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:24.573]                 ...future.oldOptions$nwarnings <- NULL
[16:11:24.573]             }
[16:11:24.573]             base::options(...future.oldOptions)
[16:11:24.573]             if (.Platform$OS.type == "windows") {
[16:11:24.573]                 old_names <- names(...future.oldEnvVars)
[16:11:24.573]                 envs <- base::Sys.getenv()
[16:11:24.573]                 names <- names(envs)
[16:11:24.573]                 common <- intersect(names, old_names)
[16:11:24.573]                 added <- setdiff(names, old_names)
[16:11:24.573]                 removed <- setdiff(old_names, names)
[16:11:24.573]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:24.573]                   envs[common]]
[16:11:24.573]                 NAMES <- toupper(changed)
[16:11:24.573]                 args <- list()
[16:11:24.573]                 for (kk in seq_along(NAMES)) {
[16:11:24.573]                   name <- changed[[kk]]
[16:11:24.573]                   NAME <- NAMES[[kk]]
[16:11:24.573]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.573]                     next
[16:11:24.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:24.573]                 }
[16:11:24.573]                 NAMES <- toupper(added)
[16:11:24.573]                 for (kk in seq_along(NAMES)) {
[16:11:24.573]                   name <- added[[kk]]
[16:11:24.573]                   NAME <- NAMES[[kk]]
[16:11:24.573]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.573]                     next
[16:11:24.573]                   args[[name]] <- ""
[16:11:24.573]                 }
[16:11:24.573]                 NAMES <- toupper(removed)
[16:11:24.573]                 for (kk in seq_along(NAMES)) {
[16:11:24.573]                   name <- removed[[kk]]
[16:11:24.573]                   NAME <- NAMES[[kk]]
[16:11:24.573]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.573]                     next
[16:11:24.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:24.573]                 }
[16:11:24.573]                 if (length(args) > 0) 
[16:11:24.573]                   base::do.call(base::Sys.setenv, args = args)
[16:11:24.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:24.573]             }
[16:11:24.573]             else {
[16:11:24.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:24.573]             }
[16:11:24.573]             {
[16:11:24.573]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:24.573]                   0L) {
[16:11:24.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:24.573]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:24.573]                   base::options(opts)
[16:11:24.573]                 }
[16:11:24.573]                 {
[16:11:24.573]                   {
[16:11:24.573]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:24.573]                     NULL
[16:11:24.573]                   }
[16:11:24.573]                   options(future.plan = NULL)
[16:11:24.573]                   if (is.na(NA_character_)) 
[16:11:24.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:24.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:24.573]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:24.573]                     envir = parent.frame()) 
[16:11:24.573]                   {
[16:11:24.573]                     default_workers <- missing(workers)
[16:11:24.573]                     if (is.function(workers)) 
[16:11:24.573]                       workers <- workers()
[16:11:24.573]                     workers <- structure(as.integer(workers), 
[16:11:24.573]                       class = class(workers))
[16:11:24.573]                     stop_if_not(is.finite(workers), workers >= 
[16:11:24.573]                       1L)
[16:11:24.573]                     if ((workers == 1L && !inherits(workers, 
[16:11:24.573]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:24.573]                       if (default_workers) 
[16:11:24.573]                         supportsMulticore(warn = TRUE)
[16:11:24.573]                       return(sequential(..., envir = envir))
[16:11:24.573]                     }
[16:11:24.573]                     oopts <- options(mc.cores = workers)
[16:11:24.573]                     on.exit(options(oopts))
[16:11:24.573]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:24.573]                       envir = envir)
[16:11:24.573]                     if (!future$lazy) 
[16:11:24.573]                       future <- run(future)
[16:11:24.573]                     invisible(future)
[16:11:24.573]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:24.573]                 }
[16:11:24.573]             }
[16:11:24.573]         }
[16:11:24.573]     })
[16:11:24.573]     if (FALSE) {
[16:11:24.573]         base::sink(type = "output", split = FALSE)
[16:11:24.573]         if (NA) {
[16:11:24.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:24.573]         }
[16:11:24.573]         else {
[16:11:24.573]             ...future.result["stdout"] <- base::list(NULL)
[16:11:24.573]         }
[16:11:24.573]         base::close(...future.stdout)
[16:11:24.573]         ...future.stdout <- NULL
[16:11:24.573]     }
[16:11:24.573]     ...future.result$conditions <- ...future.conditions
[16:11:24.573]     ...future.result$finished <- base::Sys.time()
[16:11:24.573]     ...future.result
[16:11:24.573] }
[16:11:24.575] assign_globals() ...
[16:11:24.575] List of 5
[16:11:24.575]  $ ...future.FUN            :function (x, y)  
[16:11:24.575]  $ MoreArgs                 : NULL
[16:11:24.575]  $ ...future.elements_ii    :List of 2
[16:11:24.575]   ..$ :List of 1
[16:11:24.575]   .. ..$ : int 1
[16:11:24.575]   ..$ :List of 1
[16:11:24.575]   .. ..$ : int 0
[16:11:24.575]  $ ...future.seeds_ii       : NULL
[16:11:24.575]  $ ...future.globals.maxSize: NULL
[16:11:24.575]  - attr(*, "where")=List of 5
[16:11:24.575]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:24.575]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:24.575]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:24.575]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:24.575]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:24.575]  - attr(*, "resolved")= logi FALSE
[16:11:24.575]  - attr(*, "total_size")= num 6368
[16:11:24.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:24.575]  - attr(*, "already-done")= logi TRUE
[16:11:24.580] - reassign environment for ‘...future.FUN’
[16:11:24.580] - copied ‘...future.FUN’ to environment
[16:11:24.580] - copied ‘MoreArgs’ to environment
[16:11:24.581] - copied ‘...future.elements_ii’ to environment
[16:11:24.581] - copied ‘...future.seeds_ii’ to environment
[16:11:24.581] - copied ‘...future.globals.maxSize’ to environment
[16:11:24.581] assign_globals() ... done
[16:11:24.581] requestCore(): workers = 2
[16:11:24.583] MulticoreFuture started
[16:11:24.583] - Launch lazy future ... done
[16:11:24.583] run() for ‘MulticoreFuture’ ... done
[16:11:24.584] Created future:
[16:11:24.584] plan(): Setting new future strategy stack:
[16:11:24.584] List of future strategies:
[16:11:24.584] 1. sequential:
[16:11:24.584]    - args: function (..., envir = parent.frame())
[16:11:24.584]    - tweaked: FALSE
[16:11:24.584]    - call: NULL
[16:11:24.585] plan(): nbrOfWorkers() = 1
[16:11:24.584] MulticoreFuture:
[16:11:24.584] Label: ‘future_mapply-1’
[16:11:24.584] Expression:
[16:11:24.584] {
[16:11:24.584]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:24.584]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:24.584]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:24.584]         on.exit(options(oopts), add = TRUE)
[16:11:24.584]     }
[16:11:24.584]     {
[16:11:24.584]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:24.584]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:24.584]         do.call(mapply, args = args)
[16:11:24.584]     }
[16:11:24.584] }
[16:11:24.584] Lazy evaluation: FALSE
[16:11:24.584] Asynchronous evaluation: TRUE
[16:11:24.584] Local evaluation: TRUE
[16:11:24.584] Environment: R_GlobalEnv
[16:11:24.584] Capture standard output: NA
[16:11:24.584] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:24.584] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:24.584] Packages: <none>
[16:11:24.584] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:24.584] Resolved: FALSE
[16:11:24.584] Value: <not collected>
[16:11:24.584] Conditions captured: <none>
[16:11:24.584] Early signaling: FALSE
[16:11:24.584] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:24.584] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:24.596] Chunk #1 of 2 ... DONE
[16:11:24.597] Chunk #2 of 2 ...
[16:11:24.597]  - Finding globals in '...' for chunk #2 ...
[16:11:24.597] getGlobalsAndPackages() ...
[16:11:24.597] Searching for globals...
[16:11:24.598] 
[16:11:24.598] Searching for globals ... DONE
[16:11:24.598] - globals: [0] <none>
[16:11:24.598] getGlobalsAndPackages() ... DONE
[16:11:24.598]    + additional globals found: [n=0] 
[16:11:24.599]    + additional namespaces needed: [n=0] 
[16:11:24.599]  - Finding globals in '...' for chunk #2 ... DONE
[16:11:24.599]  - seeds: <none>
[16:11:24.599] getGlobalsAndPackages() ...
[16:11:24.599] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:24.599] Resolving globals: FALSE
[16:11:24.600] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:24.601] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:24.601] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:24.601] 
[16:11:24.602] getGlobalsAndPackages() ... DONE
[16:11:24.602] run() for ‘Future’ ...
[16:11:24.602] - state: ‘created’
[16:11:24.603] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:24.607] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:24.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:24.608]   - Field: ‘label’
[16:11:24.608]   - Field: ‘local’
[16:11:24.608]   - Field: ‘owner’
[16:11:24.608]   - Field: ‘envir’
[16:11:24.608]   - Field: ‘workers’
[16:11:24.609]   - Field: ‘packages’
[16:11:24.612]   - Field: ‘gc’
[16:11:24.612]   - Field: ‘job’
[16:11:24.612]   - Field: ‘conditions’
[16:11:24.613]   - Field: ‘expr’
[16:11:24.613]   - Field: ‘uuid’
[16:11:24.613]   - Field: ‘seed’
[16:11:24.614]   - Field: ‘version’
[16:11:24.614]   - Field: ‘result’
[16:11:24.614]   - Field: ‘asynchronous’
[16:11:24.614]   - Field: ‘calls’
[16:11:24.614]   - Field: ‘globals’
[16:11:24.615]   - Field: ‘stdout’
[16:11:24.615]   - Field: ‘earlySignal’
[16:11:24.615]   - Field: ‘lazy’
[16:11:24.615]   - Field: ‘state’
[16:11:24.616] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:24.616] - Launch lazy future ...
[16:11:24.617] Packages needed by the future expression (n = 0): <none>
[16:11:24.617] Packages needed by future strategies (n = 0): <none>
[16:11:24.618] {
[16:11:24.618]     {
[16:11:24.618]         {
[16:11:24.618]             ...future.startTime <- base::Sys.time()
[16:11:24.618]             {
[16:11:24.618]                 {
[16:11:24.618]                   {
[16:11:24.618]                     {
[16:11:24.618]                       base::local({
[16:11:24.618]                         has_future <- base::requireNamespace("future", 
[16:11:24.618]                           quietly = TRUE)
[16:11:24.618]                         if (has_future) {
[16:11:24.618]                           ns <- base::getNamespace("future")
[16:11:24.618]                           version <- ns[[".package"]][["version"]]
[16:11:24.618]                           if (is.null(version)) 
[16:11:24.618]                             version <- utils::packageVersion("future")
[16:11:24.618]                         }
[16:11:24.618]                         else {
[16:11:24.618]                           version <- NULL
[16:11:24.618]                         }
[16:11:24.618]                         if (!has_future || version < "1.8.0") {
[16:11:24.618]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:24.618]                             "", base::R.version$version.string), 
[16:11:24.618]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:24.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:24.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:24.618]                               "release", "version")], collapse = " "), 
[16:11:24.618]                             hostname = base::Sys.info()[["nodename"]])
[16:11:24.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:24.618]                             info)
[16:11:24.618]                           info <- base::paste(info, collapse = "; ")
[16:11:24.618]                           if (!has_future) {
[16:11:24.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:24.618]                               info)
[16:11:24.618]                           }
[16:11:24.618]                           else {
[16:11:24.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:24.618]                               info, version)
[16:11:24.618]                           }
[16:11:24.618]                           base::stop(msg)
[16:11:24.618]                         }
[16:11:24.618]                       })
[16:11:24.618]                     }
[16:11:24.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:24.618]                     base::options(mc.cores = 1L)
[16:11:24.618]                   }
[16:11:24.618]                   options(future.plan = NULL)
[16:11:24.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:24.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:24.618]                 }
[16:11:24.618]                 ...future.workdir <- getwd()
[16:11:24.618]             }
[16:11:24.618]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:24.618]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:24.618]         }
[16:11:24.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:24.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:24.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:24.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:24.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:24.618]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:24.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:24.618]             base::names(...future.oldOptions))
[16:11:24.618]     }
[16:11:24.618]     if (TRUE) {
[16:11:24.618]     }
[16:11:24.618]     else {
[16:11:24.618]         if (NA) {
[16:11:24.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:24.618]                 open = "w")
[16:11:24.618]         }
[16:11:24.618]         else {
[16:11:24.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:24.618]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:24.618]         }
[16:11:24.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:24.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:24.618]             base::sink(type = "output", split = FALSE)
[16:11:24.618]             base::close(...future.stdout)
[16:11:24.618]         }, add = TRUE)
[16:11:24.618]     }
[16:11:24.618]     ...future.frame <- base::sys.nframe()
[16:11:24.618]     ...future.conditions <- base::list()
[16:11:24.618]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:24.618]     if (FALSE) {
[16:11:24.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:24.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:24.618]     }
[16:11:24.618]     ...future.result <- base::tryCatch({
[16:11:24.618]         base::withCallingHandlers({
[16:11:24.618]             ...future.value <- base::withVisible(base::local({
[16:11:24.618]                 withCallingHandlers({
[16:11:24.618]                   {
[16:11:24.618]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:24.618]                     if (!identical(...future.globals.maxSize.org, 
[16:11:24.618]                       ...future.globals.maxSize)) {
[16:11:24.618]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:24.618]                       on.exit(options(oopts), add = TRUE)
[16:11:24.618]                     }
[16:11:24.618]                     {
[16:11:24.618]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:24.618]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:24.618]                         USE.NAMES = FALSE)
[16:11:24.618]                       do.call(mapply, args = args)
[16:11:24.618]                     }
[16:11:24.618]                   }
[16:11:24.618]                 }, immediateCondition = function(cond) {
[16:11:24.618]                   save_rds <- function (object, pathname, ...) 
[16:11:24.618]                   {
[16:11:24.618]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:24.618]                     if (file_test("-f", pathname_tmp)) {
[16:11:24.618]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.618]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:24.618]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.618]                         fi_tmp[["mtime"]])
[16:11:24.618]                     }
[16:11:24.618]                     tryCatch({
[16:11:24.618]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:24.618]                     }, error = function(ex) {
[16:11:24.618]                       msg <- conditionMessage(ex)
[16:11:24.618]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.618]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:24.618]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.618]                         fi_tmp[["mtime"]], msg)
[16:11:24.618]                       ex$message <- msg
[16:11:24.618]                       stop(ex)
[16:11:24.618]                     })
[16:11:24.618]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:24.618]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:24.618]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:24.618]                       fi_tmp <- file.info(pathname_tmp)
[16:11:24.618]                       fi <- file.info(pathname)
[16:11:24.618]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:24.618]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:24.618]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:24.618]                         fi[["size"]], fi[["mtime"]])
[16:11:24.618]                       stop(msg)
[16:11:24.618]                     }
[16:11:24.618]                     invisible(pathname)
[16:11:24.618]                   }
[16:11:24.618]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:24.618]                     rootPath = tempdir()) 
[16:11:24.618]                   {
[16:11:24.618]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:24.618]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:24.618]                       tmpdir = path, fileext = ".rds")
[16:11:24.618]                     save_rds(obj, file)
[16:11:24.618]                   }
[16:11:24.618]                   saveImmediateCondition(cond, path = "/tmp/RtmpXRj9O2/.future/immediateConditions")
[16:11:24.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.618]                   {
[16:11:24.618]                     inherits <- base::inherits
[16:11:24.618]                     invokeRestart <- base::invokeRestart
[16:11:24.618]                     is.null <- base::is.null
[16:11:24.618]                     muffled <- FALSE
[16:11:24.618]                     if (inherits(cond, "message")) {
[16:11:24.618]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:24.618]                       if (muffled) 
[16:11:24.618]                         invokeRestart("muffleMessage")
[16:11:24.618]                     }
[16:11:24.618]                     else if (inherits(cond, "warning")) {
[16:11:24.618]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:24.618]                       if (muffled) 
[16:11:24.618]                         invokeRestart("muffleWarning")
[16:11:24.618]                     }
[16:11:24.618]                     else if (inherits(cond, "condition")) {
[16:11:24.618]                       if (!is.null(pattern)) {
[16:11:24.618]                         computeRestarts <- base::computeRestarts
[16:11:24.618]                         grepl <- base::grepl
[16:11:24.618]                         restarts <- computeRestarts(cond)
[16:11:24.618]                         for (restart in restarts) {
[16:11:24.618]                           name <- restart$name
[16:11:24.618]                           if (is.null(name)) 
[16:11:24.618]                             next
[16:11:24.618]                           if (!grepl(pattern, name)) 
[16:11:24.618]                             next
[16:11:24.618]                           invokeRestart(restart)
[16:11:24.618]                           muffled <- TRUE
[16:11:24.618]                           break
[16:11:24.618]                         }
[16:11:24.618]                       }
[16:11:24.618]                     }
[16:11:24.618]                     invisible(muffled)
[16:11:24.618]                   }
[16:11:24.618]                   muffleCondition(cond)
[16:11:24.618]                 })
[16:11:24.618]             }))
[16:11:24.618]             future::FutureResult(value = ...future.value$value, 
[16:11:24.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:24.618]                   ...future.rng), globalenv = if (FALSE) 
[16:11:24.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:24.618]                     ...future.globalenv.names))
[16:11:24.618]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:24.618]         }, condition = base::local({
[16:11:24.618]             c <- base::c
[16:11:24.618]             inherits <- base::inherits
[16:11:24.618]             invokeRestart <- base::invokeRestart
[16:11:24.618]             length <- base::length
[16:11:24.618]             list <- base::list
[16:11:24.618]             seq.int <- base::seq.int
[16:11:24.618]             signalCondition <- base::signalCondition
[16:11:24.618]             sys.calls <- base::sys.calls
[16:11:24.618]             `[[` <- base::`[[`
[16:11:24.618]             `+` <- base::`+`
[16:11:24.618]             `<<-` <- base::`<<-`
[16:11:24.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:24.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:24.618]                   3L)]
[16:11:24.618]             }
[16:11:24.618]             function(cond) {
[16:11:24.618]                 is_error <- inherits(cond, "error")
[16:11:24.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:24.618]                   NULL)
[16:11:24.618]                 if (is_error) {
[16:11:24.618]                   sessionInformation <- function() {
[16:11:24.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:24.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:24.618]                       search = base::search(), system = base::Sys.info())
[16:11:24.618]                   }
[16:11:24.618]                   ...future.conditions[[length(...future.conditions) + 
[16:11:24.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:24.618]                     cond$call), session = sessionInformation(), 
[16:11:24.618]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:24.618]                   signalCondition(cond)
[16:11:24.618]                 }
[16:11:24.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:24.618]                 "immediateCondition"))) {
[16:11:24.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:24.618]                   ...future.conditions[[length(...future.conditions) + 
[16:11:24.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:24.618]                   if (TRUE && !signal) {
[16:11:24.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.618]                     {
[16:11:24.618]                       inherits <- base::inherits
[16:11:24.618]                       invokeRestart <- base::invokeRestart
[16:11:24.618]                       is.null <- base::is.null
[16:11:24.618]                       muffled <- FALSE
[16:11:24.618]                       if (inherits(cond, "message")) {
[16:11:24.618]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:24.618]                         if (muffled) 
[16:11:24.618]                           invokeRestart("muffleMessage")
[16:11:24.618]                       }
[16:11:24.618]                       else if (inherits(cond, "warning")) {
[16:11:24.618]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:24.618]                         if (muffled) 
[16:11:24.618]                           invokeRestart("muffleWarning")
[16:11:24.618]                       }
[16:11:24.618]                       else if (inherits(cond, "condition")) {
[16:11:24.618]                         if (!is.null(pattern)) {
[16:11:24.618]                           computeRestarts <- base::computeRestarts
[16:11:24.618]                           grepl <- base::grepl
[16:11:24.618]                           restarts <- computeRestarts(cond)
[16:11:24.618]                           for (restart in restarts) {
[16:11:24.618]                             name <- restart$name
[16:11:24.618]                             if (is.null(name)) 
[16:11:24.618]                               next
[16:11:24.618]                             if (!grepl(pattern, name)) 
[16:11:24.618]                               next
[16:11:24.618]                             invokeRestart(restart)
[16:11:24.618]                             muffled <- TRUE
[16:11:24.618]                             break
[16:11:24.618]                           }
[16:11:24.618]                         }
[16:11:24.618]                       }
[16:11:24.618]                       invisible(muffled)
[16:11:24.618]                     }
[16:11:24.618]                     muffleCondition(cond, pattern = "^muffle")
[16:11:24.618]                   }
[16:11:24.618]                 }
[16:11:24.618]                 else {
[16:11:24.618]                   if (TRUE) {
[16:11:24.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:24.618]                     {
[16:11:24.618]                       inherits <- base::inherits
[16:11:24.618]                       invokeRestart <- base::invokeRestart
[16:11:24.618]                       is.null <- base::is.null
[16:11:24.618]                       muffled <- FALSE
[16:11:24.618]                       if (inherits(cond, "message")) {
[16:11:24.618]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:24.618]                         if (muffled) 
[16:11:24.618]                           invokeRestart("muffleMessage")
[16:11:24.618]                       }
[16:11:24.618]                       else if (inherits(cond, "warning")) {
[16:11:24.618]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:24.618]                         if (muffled) 
[16:11:24.618]                           invokeRestart("muffleWarning")
[16:11:24.618]                       }
[16:11:24.618]                       else if (inherits(cond, "condition")) {
[16:11:24.618]                         if (!is.null(pattern)) {
[16:11:24.618]                           computeRestarts <- base::computeRestarts
[16:11:24.618]                           grepl <- base::grepl
[16:11:24.618]                           restarts <- computeRestarts(cond)
[16:11:24.618]                           for (restart in restarts) {
[16:11:24.618]                             name <- restart$name
[16:11:24.618]                             if (is.null(name)) 
[16:11:24.618]                               next
[16:11:24.618]                             if (!grepl(pattern, name)) 
[16:11:24.618]                               next
[16:11:24.618]                             invokeRestart(restart)
[16:11:24.618]                             muffled <- TRUE
[16:11:24.618]                             break
[16:11:24.618]                           }
[16:11:24.618]                         }
[16:11:24.618]                       }
[16:11:24.618]                       invisible(muffled)
[16:11:24.618]                     }
[16:11:24.618]                     muffleCondition(cond, pattern = "^muffle")
[16:11:24.618]                   }
[16:11:24.618]                 }
[16:11:24.618]             }
[16:11:24.618]         }))
[16:11:24.618]     }, error = function(ex) {
[16:11:24.618]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:24.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:24.618]                 ...future.rng), started = ...future.startTime, 
[16:11:24.618]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:24.618]             version = "1.8"), class = "FutureResult")
[16:11:24.618]     }, finally = {
[16:11:24.618]         if (!identical(...future.workdir, getwd())) 
[16:11:24.618]             setwd(...future.workdir)
[16:11:24.618]         {
[16:11:24.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:24.618]                 ...future.oldOptions$nwarnings <- NULL
[16:11:24.618]             }
[16:11:24.618]             base::options(...future.oldOptions)
[16:11:24.618]             if (.Platform$OS.type == "windows") {
[16:11:24.618]                 old_names <- names(...future.oldEnvVars)
[16:11:24.618]                 envs <- base::Sys.getenv()
[16:11:24.618]                 names <- names(envs)
[16:11:24.618]                 common <- intersect(names, old_names)
[16:11:24.618]                 added <- setdiff(names, old_names)
[16:11:24.618]                 removed <- setdiff(old_names, names)
[16:11:24.618]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:24.618]                   envs[common]]
[16:11:24.618]                 NAMES <- toupper(changed)
[16:11:24.618]                 args <- list()
[16:11:24.618]                 for (kk in seq_along(NAMES)) {
[16:11:24.618]                   name <- changed[[kk]]
[16:11:24.618]                   NAME <- NAMES[[kk]]
[16:11:24.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.618]                     next
[16:11:24.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:24.618]                 }
[16:11:24.618]                 NAMES <- toupper(added)
[16:11:24.618]                 for (kk in seq_along(NAMES)) {
[16:11:24.618]                   name <- added[[kk]]
[16:11:24.618]                   NAME <- NAMES[[kk]]
[16:11:24.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.618]                     next
[16:11:24.618]                   args[[name]] <- ""
[16:11:24.618]                 }
[16:11:24.618]                 NAMES <- toupper(removed)
[16:11:24.618]                 for (kk in seq_along(NAMES)) {
[16:11:24.618]                   name <- removed[[kk]]
[16:11:24.618]                   NAME <- NAMES[[kk]]
[16:11:24.618]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:24.618]                     next
[16:11:24.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:24.618]                 }
[16:11:24.618]                 if (length(args) > 0) 
[16:11:24.618]                   base::do.call(base::Sys.setenv, args = args)
[16:11:24.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:24.618]             }
[16:11:24.618]             else {
[16:11:24.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:24.618]             }
[16:11:24.618]             {
[16:11:24.618]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:24.618]                   0L) {
[16:11:24.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:24.618]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:24.618]                   base::options(opts)
[16:11:24.618]                 }
[16:11:24.618]                 {
[16:11:24.618]                   {
[16:11:24.618]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:24.618]                     NULL
[16:11:24.618]                   }
[16:11:24.618]                   options(future.plan = NULL)
[16:11:24.618]                   if (is.na(NA_character_)) 
[16:11:24.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:24.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:24.618]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:24.618]                     envir = parent.frame()) 
[16:11:24.618]                   {
[16:11:24.618]                     default_workers <- missing(workers)
[16:11:24.618]                     if (is.function(workers)) 
[16:11:24.618]                       workers <- workers()
[16:11:24.618]                     workers <- structure(as.integer(workers), 
[16:11:24.618]                       class = class(workers))
[16:11:24.618]                     stop_if_not(is.finite(workers), workers >= 
[16:11:24.618]                       1L)
[16:11:24.618]                     if ((workers == 1L && !inherits(workers, 
[16:11:24.618]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:24.618]                       if (default_workers) 
[16:11:24.618]                         supportsMulticore(warn = TRUE)
[16:11:24.618]                       return(sequential(..., envir = envir))
[16:11:24.618]                     }
[16:11:24.618]                     oopts <- options(mc.cores = workers)
[16:11:24.618]                     on.exit(options(oopts))
[16:11:24.618]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:24.618]                       envir = envir)
[16:11:24.618]                     if (!future$lazy) 
[16:11:24.618]                       future <- run(future)
[16:11:24.618]                     invisible(future)
[16:11:24.618]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:24.618]                 }
[16:11:24.618]             }
[16:11:24.618]         }
[16:11:24.618]     })
[16:11:24.618]     if (FALSE) {
[16:11:24.618]         base::sink(type = "output", split = FALSE)
[16:11:24.618]         if (NA) {
[16:11:24.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:24.618]         }
[16:11:24.618]         else {
[16:11:24.618]             ...future.result["stdout"] <- base::list(NULL)
[16:11:24.618]         }
[16:11:24.618]         base::close(...future.stdout)
[16:11:24.618]         ...future.stdout <- NULL
[16:11:24.618]     }
[16:11:24.618]     ...future.result$conditions <- ...future.conditions
[16:11:24.618]     ...future.result$finished <- base::Sys.time()
[16:11:24.618]     ...future.result
[16:11:24.618] }
[16:11:24.621] assign_globals() ...
[16:11:24.621] List of 5
[16:11:24.621]  $ ...future.FUN            :function (x, y)  
[16:11:24.621]  $ MoreArgs                 : NULL
[16:11:24.621]  $ ...future.elements_ii    :List of 2
[16:11:24.621]   ..$ :List of 1
[16:11:24.621]   .. ..$ : int 0
[16:11:24.621]   ..$ :List of 1
[16:11:24.621]   .. ..$ : int 1
[16:11:24.621]  $ ...future.seeds_ii       : NULL
[16:11:24.621]  $ ...future.globals.maxSize: NULL
[16:11:24.621]  - attr(*, "where")=List of 5
[16:11:24.621]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:24.621]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:11:24.621]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:24.621]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:24.621]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:24.621]  - attr(*, "resolved")= logi FALSE
[16:11:24.621]  - attr(*, "total_size")= num 6368
[16:11:24.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:24.621]  - attr(*, "already-done")= logi TRUE
[16:11:24.629] - reassign environment for ‘...future.FUN’
[16:11:24.629] - copied ‘...future.FUN’ to environment
[16:11:24.630] - copied ‘MoreArgs’ to environment
[16:11:24.630] - copied ‘...future.elements_ii’ to environment
[16:11:24.630] - copied ‘...future.seeds_ii’ to environment
[16:11:24.630] - copied ‘...future.globals.maxSize’ to environment
[16:11:24.630] assign_globals() ... done
[16:11:24.630] requestCore(): workers = 2
[16:11:24.632] MulticoreFuture started
[16:11:24.633] - Launch lazy future ... done
[16:11:24.633] run() for ‘MulticoreFuture’ ... done
[16:11:24.633] Created future:
[16:11:24.633] plan(): Setting new future strategy stack:
[16:11:24.634] List of future strategies:
[16:11:24.634] 1. sequential:
[16:11:24.634]    - args: function (..., envir = parent.frame())
[16:11:24.634]    - tweaked: FALSE
[16:11:24.634]    - call: NULL
[16:11:24.635] plan(): nbrOfWorkers() = 1
[16:11:24.637] plan(): Setting new future strategy stack:
[16:11:24.637] List of future strategies:
[16:11:24.637] 1. multicore:
[16:11:24.637]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:24.637]    - tweaked: FALSE
[16:11:24.637]    - call: plan(strategy)
[16:11:24.642] plan(): nbrOfWorkers() = 2
[16:11:24.633] MulticoreFuture:
[16:11:24.633] Label: ‘future_mapply-2’
[16:11:24.633] Expression:
[16:11:24.633] {
[16:11:24.633]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:24.633]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:24.633]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:24.633]         on.exit(options(oopts), add = TRUE)
[16:11:24.633]     }
[16:11:24.633]     {
[16:11:24.633]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:24.633]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:24.633]         do.call(mapply, args = args)
[16:11:24.633]     }
[16:11:24.633] }
[16:11:24.633] Lazy evaluation: FALSE
[16:11:24.633] Asynchronous evaluation: TRUE
[16:11:24.633] Local evaluation: TRUE
[16:11:24.633] Environment: R_GlobalEnv
[16:11:24.633] Capture standard output: NA
[16:11:24.633] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:24.633] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:24.633] Packages: <none>
[16:11:24.633] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:24.633] Resolved: TRUE
[16:11:24.633] Value: <not collected>
[16:11:24.633] Conditions captured: <none>
[16:11:24.633] Early signaling: FALSE
[16:11:24.633] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:24.633] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:24.643] Chunk #2 of 2 ... DONE
[16:11:24.643] Launching 2 futures (chunks) ... DONE
[16:11:24.643] Resolving 2 futures (chunks) ...
[16:11:24.643] resolve() on list ...
[16:11:24.643]  recursive: 0
[16:11:24.644]  length: 2
[16:11:24.644] 
[16:11:24.654] Future #2
[16:11:24.656] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:24.656] - nx: 2
[16:11:24.656] - relay: TRUE
[16:11:24.656] - stdout: TRUE
[16:11:24.656] - signal: TRUE
[16:11:24.656] - resignal: FALSE
[16:11:24.656] - force: TRUE
[16:11:24.657] - relayed: [n=2] FALSE, FALSE
[16:11:24.657] - queued futures: [n=2] FALSE, FALSE
[16:11:24.657]  - until=1
[16:11:24.657]  - relaying element #1
[16:11:24.657] - relayed: [n=2] FALSE, FALSE
[16:11:24.657] - queued futures: [n=2] FALSE, TRUE
[16:11:24.657] signalConditionsASAP(NULL, pos=2) ... done
[16:11:24.657]  length: 1 (resolved future 2)
[16:11:25.088] plan(): Setting new future strategy stack:
[16:11:25.088] List of future strategies:
[16:11:25.088] 1. multicore:
[16:11:25.088]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:25.088]    - tweaked: FALSE
[16:11:25.088]    - call: plan(strategy)
[16:11:25.093] plan(): nbrOfWorkers() = 2
[16:11:25.095] Future #1
[16:11:25.096] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:25.096] - nx: 2
[16:11:25.097] - relay: TRUE
[16:11:25.097] - stdout: TRUE
[16:11:25.097] - signal: TRUE
[16:11:25.097] - resignal: FALSE
[16:11:25.097] - force: TRUE
[16:11:25.097] - relayed: [n=2] FALSE, FALSE
[16:11:25.097] - queued futures: [n=2] FALSE, TRUE
[16:11:25.097]  - until=1
[16:11:25.097]  - relaying element #1
[16:11:25.098] - relayed: [n=2] TRUE, FALSE
[16:11:25.098] - queued futures: [n=2] TRUE, TRUE
[16:11:25.098] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:25.098]  length: 0 (resolved future 1)
[16:11:25.098] Relaying remaining futures
[16:11:25.098] signalConditionsASAP(NULL, pos=0) ...
[16:11:25.098] - nx: 2
[16:11:25.098] - relay: TRUE
[16:11:25.099] - stdout: TRUE
[16:11:25.099] - signal: TRUE
[16:11:25.099] - resignal: FALSE
[16:11:25.099] - force: TRUE
[16:11:25.099] - relayed: [n=2] TRUE, FALSE
[16:11:25.099] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:25.099]  - relaying element #2
[16:11:25.100] - relayed: [n=2] TRUE, TRUE
[16:11:25.100] - queued futures: [n=2] TRUE, TRUE
[16:11:25.100] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:11:25.100] resolve() on list ... DONE
[16:11:25.100]  - Number of value chunks collected: 2
[16:11:25.100] Resolving 2 futures (chunks) ... DONE
[16:11:25.100] Reducing values from 2 chunks ...
[16:11:25.101]  - Number of values collected after concatenation: 2
[16:11:25.101]  - Number of values expected: 2
[16:11:25.101] Reducing values from 2 chunks ... DONE
[16:11:25.101] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[16:11:25.101] plan(): Setting new future strategy stack:
[16:11:25.102] List of future strategies:
[16:11:25.102] 1. multisession:
[16:11:25.102]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:25.102]    - tweaked: FALSE
[16:11:25.102]    - call: plan(strategy)
[16:11:25.102] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:11:25.102] multisession:
[16:11:25.102] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:25.102] - tweaked: FALSE
[16:11:25.102] - call: plan(strategy)
[16:11:25.111] getGlobalsAndPackages() ...
[16:11:25.112] Not searching for globals
[16:11:25.112] - globals: [0] <none>
[16:11:25.112] getGlobalsAndPackages() ... DONE
[16:11:25.113] [local output] makeClusterPSOCK() ...
[16:11:25.150] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:11:25.156] [local output] Base port: 11383
[16:11:25.156] [local output] Getting setup options for 2 cluster nodes ...
[16:11:25.156] [local output]  - Node 1 of 2 ...
[16:11:25.156] [local output] localMachine=TRUE => revtunnel=FALSE

[16:11:25.157] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXRj9O2/worker.rank=1.parallelly.parent=78942.1345e5f74536f.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpXRj9O2/worker.rank=1.parallelly.parent=78942.1345e5f74536f.pid")'’
[16:11:25.344] - Possible to infer worker's PID: TRUE
[16:11:25.344] [local output] Rscript port: 11383

[16:11:25.344] [local output]  - Node 2 of 2 ...
[16:11:25.345] [local output] localMachine=TRUE => revtunnel=FALSE

[16:11:25.346] [local output] Rscript port: 11383

[16:11:25.346] [local output] Getting setup options for 2 cluster nodes ... done
[16:11:25.346] [local output]  - Parallel setup requested for some PSOCK nodes
[16:11:25.346] [local output] Setting up PSOCK nodes in parallel
[16:11:25.347] List of 36
[16:11:25.347]  $ worker          : chr "localhost"
[16:11:25.347]   ..- attr(*, "localhost")= logi TRUE
[16:11:25.347]  $ master          : chr "localhost"
[16:11:25.347]  $ port            : int 11383
[16:11:25.347]  $ connectTimeout  : num 120
[16:11:25.347]  $ timeout         : num 2592000
[16:11:25.347]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:11:25.347]  $ homogeneous     : logi TRUE
[16:11:25.347]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:11:25.347]  $ rscript_envs    : NULL
[16:11:25.347]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:11:25.347]  $ rscript_startup : NULL
[16:11:25.347]  $ rscript_sh      : chr "sh"
[16:11:25.347]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:11:25.347]  $ methods         : logi TRUE
[16:11:25.347]  $ socketOptions   : chr "no-delay"
[16:11:25.347]  $ useXDR          : logi FALSE
[16:11:25.347]  $ outfile         : chr "/dev/null"
[16:11:25.347]  $ renice          : int NA
[16:11:25.347]  $ rshcmd          : NULL
[16:11:25.347]  $ user            : chr(0) 
[16:11:25.347]  $ revtunnel       : logi FALSE
[16:11:25.347]  $ rshlogfile      : NULL
[16:11:25.347]  $ rshopts         : chr(0) 
[16:11:25.347]  $ rank            : int 1
[16:11:25.347]  $ manual          : logi FALSE
[16:11:25.347]  $ dryrun          : logi FALSE
[16:11:25.347]  $ quiet           : logi FALSE
[16:11:25.347]  $ setup_strategy  : chr "parallel"
[16:11:25.347]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:11:25.347]  $ pidfile         : chr "/tmp/RtmpXRj9O2/worker.rank=1.parallelly.parent=78942.1345e5f74536f.pid"
[16:11:25.347]  $ rshcmd_label    : NULL
[16:11:25.347]  $ rsh_call        : NULL
[16:11:25.347]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:11:25.347]  $ localMachine    : logi TRUE
[16:11:25.347]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:11:25.347]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:11:25.347]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:11:25.347]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:11:25.347]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:11:25.347]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:11:25.347]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:11:25.347]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:11:25.347]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:11:25.347]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:11:25.347]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:11:25.347]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:11:25.347]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:11:25.347]  $ arguments       :List of 28
[16:11:25.347]   ..$ worker          : chr "localhost"
[16:11:25.347]   ..$ master          : NULL
[16:11:25.347]   ..$ port            : int 11383
[16:11:25.347]   ..$ connectTimeout  : num 120
[16:11:25.347]   ..$ timeout         : num 2592000
[16:11:25.347]   ..$ rscript         : NULL
[16:11:25.347]   ..$ homogeneous     : NULL
[16:11:25.347]   ..$ rscript_args    : NULL
[16:11:25.347]   ..$ rscript_envs    : NULL
[16:11:25.347]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:11:25.347]   ..$ rscript_startup : NULL
[16:11:25.347]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:11:25.347]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:11:25.347]   ..$ methods         : logi TRUE
[16:11:25.347]   ..$ socketOptions   : chr "no-delay"
[16:11:25.347]   ..$ useXDR          : logi FALSE
[16:11:25.347]   ..$ outfile         : chr "/dev/null"
[16:11:25.347]   ..$ renice          : int NA
[16:11:25.347]   ..$ rshcmd          : NULL
[16:11:25.347]   ..$ user            : NULL
[16:11:25.347]   ..$ revtunnel       : logi NA
[16:11:25.347]   ..$ rshlogfile      : NULL
[16:11:25.347]   ..$ rshopts         : NULL
[16:11:25.347]   ..$ rank            : int 1
[16:11:25.347]   ..$ manual          : logi FALSE
[16:11:25.347]   ..$ dryrun          : logi FALSE
[16:11:25.347]   ..$ quiet           : logi FALSE
[16:11:25.347]   ..$ setup_strategy  : chr "parallel"
[16:11:25.347]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:11:25.364] [local output] System call to launch all workers:
[16:11:25.364] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpXRj9O2/worker.rank=1.parallelly.parent=78942.1345e5f74536f.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11383 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:11:25.364] [local output] Starting PSOCK main server
[16:11:25.366] [local output] Workers launched
[16:11:25.366] [local output] Waiting for workers to connect back
[16:11:25.366]  - [local output] 0 workers out of 2 ready
[16:11:25.650]  - [local output] 0 workers out of 2 ready
[16:11:25.650]  - [local output] 1 workers out of 2 ready
[16:11:25.654]  - [local output] 1 workers out of 2 ready
[16:11:25.655]  - [local output] 2 workers out of 2 ready
[16:11:25.655] [local output] Launching of workers completed
[16:11:25.655] [local output] Collecting session information from workers
[16:11:25.656] [local output]  - Worker #1 of 2
[16:11:25.656] [local output]  - Worker #2 of 2
[16:11:25.656] [local output] makeClusterPSOCK() ... done
[16:11:25.669] Packages needed by the future expression (n = 0): <none>
[16:11:25.669] Packages needed by future strategies (n = 0): <none>
[16:11:25.669] {
[16:11:25.669]     {
[16:11:25.669]         {
[16:11:25.669]             ...future.startTime <- base::Sys.time()
[16:11:25.669]             {
[16:11:25.669]                 {
[16:11:25.669]                   {
[16:11:25.669]                     {
[16:11:25.669]                       base::local({
[16:11:25.669]                         has_future <- base::requireNamespace("future", 
[16:11:25.669]                           quietly = TRUE)
[16:11:25.669]                         if (has_future) {
[16:11:25.669]                           ns <- base::getNamespace("future")
[16:11:25.669]                           version <- ns[[".package"]][["version"]]
[16:11:25.669]                           if (is.null(version)) 
[16:11:25.669]                             version <- utils::packageVersion("future")
[16:11:25.669]                         }
[16:11:25.669]                         else {
[16:11:25.669]                           version <- NULL
[16:11:25.669]                         }
[16:11:25.669]                         if (!has_future || version < "1.8.0") {
[16:11:25.669]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:25.669]                             "", base::R.version$version.string), 
[16:11:25.669]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:25.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:25.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:25.669]                               "release", "version")], collapse = " "), 
[16:11:25.669]                             hostname = base::Sys.info()[["nodename"]])
[16:11:25.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:25.669]                             info)
[16:11:25.669]                           info <- base::paste(info, collapse = "; ")
[16:11:25.669]                           if (!has_future) {
[16:11:25.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:25.669]                               info)
[16:11:25.669]                           }
[16:11:25.669]                           else {
[16:11:25.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:25.669]                               info, version)
[16:11:25.669]                           }
[16:11:25.669]                           base::stop(msg)
[16:11:25.669]                         }
[16:11:25.669]                       })
[16:11:25.669]                     }
[16:11:25.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:25.669]                     base::options(mc.cores = 1L)
[16:11:25.669]                   }
[16:11:25.669]                   options(future.plan = NULL)
[16:11:25.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:25.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:25.669]                 }
[16:11:25.669]                 ...future.workdir <- getwd()
[16:11:25.669]             }
[16:11:25.669]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:25.669]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:25.669]         }
[16:11:25.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:25.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:25.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:25.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:25.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:25.669]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:25.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:25.669]             base::names(...future.oldOptions))
[16:11:25.669]     }
[16:11:25.669]     if (FALSE) {
[16:11:25.669]     }
[16:11:25.669]     else {
[16:11:25.669]         if (TRUE) {
[16:11:25.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:25.669]                 open = "w")
[16:11:25.669]         }
[16:11:25.669]         else {
[16:11:25.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:25.669]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:25.669]         }
[16:11:25.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:25.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:25.669]             base::sink(type = "output", split = FALSE)
[16:11:25.669]             base::close(...future.stdout)
[16:11:25.669]         }, add = TRUE)
[16:11:25.669]     }
[16:11:25.669]     ...future.frame <- base::sys.nframe()
[16:11:25.669]     ...future.conditions <- base::list()
[16:11:25.669]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:25.669]     if (FALSE) {
[16:11:25.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:25.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:25.669]     }
[16:11:25.669]     ...future.result <- base::tryCatch({
[16:11:25.669]         base::withCallingHandlers({
[16:11:25.669]             ...future.value <- base::withVisible(base::local({
[16:11:25.669]                 ...future.makeSendCondition <- local({
[16:11:25.669]                   sendCondition <- NULL
[16:11:25.669]                   function(frame = 1L) {
[16:11:25.669]                     if (is.function(sendCondition)) 
[16:11:25.669]                       return(sendCondition)
[16:11:25.669]                     ns <- getNamespace("parallel")
[16:11:25.669]                     if (exists("sendData", mode = "function", 
[16:11:25.669]                       envir = ns)) {
[16:11:25.669]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:25.669]                         envir = ns)
[16:11:25.669]                       envir <- sys.frame(frame)
[16:11:25.669]                       master <- NULL
[16:11:25.669]                       while (!identical(envir, .GlobalEnv) && 
[16:11:25.669]                         !identical(envir, emptyenv())) {
[16:11:25.669]                         if (exists("master", mode = "list", envir = envir, 
[16:11:25.669]                           inherits = FALSE)) {
[16:11:25.669]                           master <- get("master", mode = "list", 
[16:11:25.669]                             envir = envir, inherits = FALSE)
[16:11:25.669]                           if (inherits(master, c("SOCKnode", 
[16:11:25.669]                             "SOCK0node"))) {
[16:11:25.669]                             sendCondition <<- function(cond) {
[16:11:25.669]                               data <- list(type = "VALUE", value = cond, 
[16:11:25.669]                                 success = TRUE)
[16:11:25.669]                               parallel_sendData(master, data)
[16:11:25.669]                             }
[16:11:25.669]                             return(sendCondition)
[16:11:25.669]                           }
[16:11:25.669]                         }
[16:11:25.669]                         frame <- frame + 1L
[16:11:25.669]                         envir <- sys.frame(frame)
[16:11:25.669]                       }
[16:11:25.669]                     }
[16:11:25.669]                     sendCondition <<- function(cond) NULL
[16:11:25.669]                   }
[16:11:25.669]                 })
[16:11:25.669]                 withCallingHandlers({
[16:11:25.669]                   NA
[16:11:25.669]                 }, immediateCondition = function(cond) {
[16:11:25.669]                   sendCondition <- ...future.makeSendCondition()
[16:11:25.669]                   sendCondition(cond)
[16:11:25.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.669]                   {
[16:11:25.669]                     inherits <- base::inherits
[16:11:25.669]                     invokeRestart <- base::invokeRestart
[16:11:25.669]                     is.null <- base::is.null
[16:11:25.669]                     muffled <- FALSE
[16:11:25.669]                     if (inherits(cond, "message")) {
[16:11:25.669]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:25.669]                       if (muffled) 
[16:11:25.669]                         invokeRestart("muffleMessage")
[16:11:25.669]                     }
[16:11:25.669]                     else if (inherits(cond, "warning")) {
[16:11:25.669]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:25.669]                       if (muffled) 
[16:11:25.669]                         invokeRestart("muffleWarning")
[16:11:25.669]                     }
[16:11:25.669]                     else if (inherits(cond, "condition")) {
[16:11:25.669]                       if (!is.null(pattern)) {
[16:11:25.669]                         computeRestarts <- base::computeRestarts
[16:11:25.669]                         grepl <- base::grepl
[16:11:25.669]                         restarts <- computeRestarts(cond)
[16:11:25.669]                         for (restart in restarts) {
[16:11:25.669]                           name <- restart$name
[16:11:25.669]                           if (is.null(name)) 
[16:11:25.669]                             next
[16:11:25.669]                           if (!grepl(pattern, name)) 
[16:11:25.669]                             next
[16:11:25.669]                           invokeRestart(restart)
[16:11:25.669]                           muffled <- TRUE
[16:11:25.669]                           break
[16:11:25.669]                         }
[16:11:25.669]                       }
[16:11:25.669]                     }
[16:11:25.669]                     invisible(muffled)
[16:11:25.669]                   }
[16:11:25.669]                   muffleCondition(cond)
[16:11:25.669]                 })
[16:11:25.669]             }))
[16:11:25.669]             future::FutureResult(value = ...future.value$value, 
[16:11:25.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:25.669]                   ...future.rng), globalenv = if (FALSE) 
[16:11:25.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:25.669]                     ...future.globalenv.names))
[16:11:25.669]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:25.669]         }, condition = base::local({
[16:11:25.669]             c <- base::c
[16:11:25.669]             inherits <- base::inherits
[16:11:25.669]             invokeRestart <- base::invokeRestart
[16:11:25.669]             length <- base::length
[16:11:25.669]             list <- base::list
[16:11:25.669]             seq.int <- base::seq.int
[16:11:25.669]             signalCondition <- base::signalCondition
[16:11:25.669]             sys.calls <- base::sys.calls
[16:11:25.669]             `[[` <- base::`[[`
[16:11:25.669]             `+` <- base::`+`
[16:11:25.669]             `<<-` <- base::`<<-`
[16:11:25.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:25.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:25.669]                   3L)]
[16:11:25.669]             }
[16:11:25.669]             function(cond) {
[16:11:25.669]                 is_error <- inherits(cond, "error")
[16:11:25.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:25.669]                   NULL)
[16:11:25.669]                 if (is_error) {
[16:11:25.669]                   sessionInformation <- function() {
[16:11:25.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:25.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:25.669]                       search = base::search(), system = base::Sys.info())
[16:11:25.669]                   }
[16:11:25.669]                   ...future.conditions[[length(...future.conditions) + 
[16:11:25.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:25.669]                     cond$call), session = sessionInformation(), 
[16:11:25.669]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:25.669]                   signalCondition(cond)
[16:11:25.669]                 }
[16:11:25.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:25.669]                 "immediateCondition"))) {
[16:11:25.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:25.669]                   ...future.conditions[[length(...future.conditions) + 
[16:11:25.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:25.669]                   if (TRUE && !signal) {
[16:11:25.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.669]                     {
[16:11:25.669]                       inherits <- base::inherits
[16:11:25.669]                       invokeRestart <- base::invokeRestart
[16:11:25.669]                       is.null <- base::is.null
[16:11:25.669]                       muffled <- FALSE
[16:11:25.669]                       if (inherits(cond, "message")) {
[16:11:25.669]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:25.669]                         if (muffled) 
[16:11:25.669]                           invokeRestart("muffleMessage")
[16:11:25.669]                       }
[16:11:25.669]                       else if (inherits(cond, "warning")) {
[16:11:25.669]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:25.669]                         if (muffled) 
[16:11:25.669]                           invokeRestart("muffleWarning")
[16:11:25.669]                       }
[16:11:25.669]                       else if (inherits(cond, "condition")) {
[16:11:25.669]                         if (!is.null(pattern)) {
[16:11:25.669]                           computeRestarts <- base::computeRestarts
[16:11:25.669]                           grepl <- base::grepl
[16:11:25.669]                           restarts <- computeRestarts(cond)
[16:11:25.669]                           for (restart in restarts) {
[16:11:25.669]                             name <- restart$name
[16:11:25.669]                             if (is.null(name)) 
[16:11:25.669]                               next
[16:11:25.669]                             if (!grepl(pattern, name)) 
[16:11:25.669]                               next
[16:11:25.669]                             invokeRestart(restart)
[16:11:25.669]                             muffled <- TRUE
[16:11:25.669]                             break
[16:11:25.669]                           }
[16:11:25.669]                         }
[16:11:25.669]                       }
[16:11:25.669]                       invisible(muffled)
[16:11:25.669]                     }
[16:11:25.669]                     muffleCondition(cond, pattern = "^muffle")
[16:11:25.669]                   }
[16:11:25.669]                 }
[16:11:25.669]                 else {
[16:11:25.669]                   if (TRUE) {
[16:11:25.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.669]                     {
[16:11:25.669]                       inherits <- base::inherits
[16:11:25.669]                       invokeRestart <- base::invokeRestart
[16:11:25.669]                       is.null <- base::is.null
[16:11:25.669]                       muffled <- FALSE
[16:11:25.669]                       if (inherits(cond, "message")) {
[16:11:25.669]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:25.669]                         if (muffled) 
[16:11:25.669]                           invokeRestart("muffleMessage")
[16:11:25.669]                       }
[16:11:25.669]                       else if (inherits(cond, "warning")) {
[16:11:25.669]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:25.669]                         if (muffled) 
[16:11:25.669]                           invokeRestart("muffleWarning")
[16:11:25.669]                       }
[16:11:25.669]                       else if (inherits(cond, "condition")) {
[16:11:25.669]                         if (!is.null(pattern)) {
[16:11:25.669]                           computeRestarts <- base::computeRestarts
[16:11:25.669]                           grepl <- base::grepl
[16:11:25.669]                           restarts <- computeRestarts(cond)
[16:11:25.669]                           for (restart in restarts) {
[16:11:25.669]                             name <- restart$name
[16:11:25.669]                             if (is.null(name)) 
[16:11:25.669]                               next
[16:11:25.669]                             if (!grepl(pattern, name)) 
[16:11:25.669]                               next
[16:11:25.669]                             invokeRestart(restart)
[16:11:25.669]                             muffled <- TRUE
[16:11:25.669]                             break
[16:11:25.669]                           }
[16:11:25.669]                         }
[16:11:25.669]                       }
[16:11:25.669]                       invisible(muffled)
[16:11:25.669]                     }
[16:11:25.669]                     muffleCondition(cond, pattern = "^muffle")
[16:11:25.669]                   }
[16:11:25.669]                 }
[16:11:25.669]             }
[16:11:25.669]         }))
[16:11:25.669]     }, error = function(ex) {
[16:11:25.669]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:25.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:25.669]                 ...future.rng), started = ...future.startTime, 
[16:11:25.669]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:25.669]             version = "1.8"), class = "FutureResult")
[16:11:25.669]     }, finally = {
[16:11:25.669]         if (!identical(...future.workdir, getwd())) 
[16:11:25.669]             setwd(...future.workdir)
[16:11:25.669]         {
[16:11:25.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:25.669]                 ...future.oldOptions$nwarnings <- NULL
[16:11:25.669]             }
[16:11:25.669]             base::options(...future.oldOptions)
[16:11:25.669]             if (.Platform$OS.type == "windows") {
[16:11:25.669]                 old_names <- names(...future.oldEnvVars)
[16:11:25.669]                 envs <- base::Sys.getenv()
[16:11:25.669]                 names <- names(envs)
[16:11:25.669]                 common <- intersect(names, old_names)
[16:11:25.669]                 added <- setdiff(names, old_names)
[16:11:25.669]                 removed <- setdiff(old_names, names)
[16:11:25.669]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:25.669]                   envs[common]]
[16:11:25.669]                 NAMES <- toupper(changed)
[16:11:25.669]                 args <- list()
[16:11:25.669]                 for (kk in seq_along(NAMES)) {
[16:11:25.669]                   name <- changed[[kk]]
[16:11:25.669]                   NAME <- NAMES[[kk]]
[16:11:25.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.669]                     next
[16:11:25.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:25.669]                 }
[16:11:25.669]                 NAMES <- toupper(added)
[16:11:25.669]                 for (kk in seq_along(NAMES)) {
[16:11:25.669]                   name <- added[[kk]]
[16:11:25.669]                   NAME <- NAMES[[kk]]
[16:11:25.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.669]                     next
[16:11:25.669]                   args[[name]] <- ""
[16:11:25.669]                 }
[16:11:25.669]                 NAMES <- toupper(removed)
[16:11:25.669]                 for (kk in seq_along(NAMES)) {
[16:11:25.669]                   name <- removed[[kk]]
[16:11:25.669]                   NAME <- NAMES[[kk]]
[16:11:25.669]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.669]                     next
[16:11:25.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:25.669]                 }
[16:11:25.669]                 if (length(args) > 0) 
[16:11:25.669]                   base::do.call(base::Sys.setenv, args = args)
[16:11:25.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:25.669]             }
[16:11:25.669]             else {
[16:11:25.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:25.669]             }
[16:11:25.669]             {
[16:11:25.669]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:25.669]                   0L) {
[16:11:25.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:25.669]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:25.669]                   base::options(opts)
[16:11:25.669]                 }
[16:11:25.669]                 {
[16:11:25.669]                   {
[16:11:25.669]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:25.669]                     NULL
[16:11:25.669]                   }
[16:11:25.669]                   options(future.plan = NULL)
[16:11:25.669]                   if (is.na(NA_character_)) 
[16:11:25.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:25.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:25.669]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:25.669]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:25.669]                     envir = parent.frame()) 
[16:11:25.669]                   {
[16:11:25.669]                     if (is.function(workers)) 
[16:11:25.669]                       workers <- workers()
[16:11:25.669]                     workers <- structure(as.integer(workers), 
[16:11:25.669]                       class = class(workers))
[16:11:25.669]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:25.669]                       workers >= 1)
[16:11:25.669]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:25.669]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:25.669]                     }
[16:11:25.669]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:25.669]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:25.669]                       envir = envir)
[16:11:25.669]                     if (!future$lazy) 
[16:11:25.669]                       future <- run(future)
[16:11:25.669]                     invisible(future)
[16:11:25.669]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:25.669]                 }
[16:11:25.669]             }
[16:11:25.669]         }
[16:11:25.669]     })
[16:11:25.669]     if (TRUE) {
[16:11:25.669]         base::sink(type = "output", split = FALSE)
[16:11:25.669]         if (TRUE) {
[16:11:25.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:25.669]         }
[16:11:25.669]         else {
[16:11:25.669]             ...future.result["stdout"] <- base::list(NULL)
[16:11:25.669]         }
[16:11:25.669]         base::close(...future.stdout)
[16:11:25.669]         ...future.stdout <- NULL
[16:11:25.669]     }
[16:11:25.669]     ...future.result$conditions <- ...future.conditions
[16:11:25.669]     ...future.result$finished <- base::Sys.time()
[16:11:25.669]     ...future.result
[16:11:25.669] }
[16:11:25.742] MultisessionFuture started
[16:11:25.742] result() for ClusterFuture ...
[16:11:25.742] receiveMessageFromWorker() for ClusterFuture ...
[16:11:25.743] - Validating connection of MultisessionFuture
[16:11:25.775] - received message: FutureResult
[16:11:25.775] - Received FutureResult
[16:11:25.775] - Erased future from FutureRegistry
[16:11:25.775] result() for ClusterFuture ...
[16:11:25.775] - result already collected: FutureResult
[16:11:25.775] result() for ClusterFuture ... done
[16:11:25.776] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:25.776] result() for ClusterFuture ... done
[16:11:25.776] result() for ClusterFuture ...
[16:11:25.776] - result already collected: FutureResult
[16:11:25.776] result() for ClusterFuture ... done
[16:11:25.776] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:11:25.780] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:11:25.780] future_lapply() ...
[16:11:25.785] Number of chunks: 2
[16:11:25.785] getGlobalsAndPackagesXApply() ...
[16:11:25.785]  - future.globals: TRUE
[16:11:25.785] getGlobalsAndPackages() ...
[16:11:25.785] Searching for globals...
[16:11:25.787] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:25.787] Searching for globals ... DONE
[16:11:25.787] Resolving globals: FALSE
[16:11:25.788] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:25.788] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:25.788] - globals: [1] ‘FUN’
[16:11:25.788] 
[16:11:25.789] getGlobalsAndPackages() ... DONE
[16:11:25.789]  - globals found/used: [n=1] ‘FUN’
[16:11:25.789]  - needed namespaces: [n=0] 
[16:11:25.789] Finding globals ... DONE
[16:11:25.789]  - use_args: TRUE
[16:11:25.789]  - Getting '...' globals ...
[16:11:25.790] resolve() on list ...
[16:11:25.790]  recursive: 0
[16:11:25.790]  length: 1
[16:11:25.790]  elements: ‘...’
[16:11:25.790]  length: 0 (resolved future 1)
[16:11:25.790] resolve() on list ... DONE
[16:11:25.790]    - '...' content: [n=0] 
[16:11:25.790] List of 1
[16:11:25.790]  $ ...: list()
[16:11:25.790]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:25.790]  - attr(*, "where")=List of 1
[16:11:25.790]   ..$ ...:<environment: 0x557e21ee86c0> 
[16:11:25.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:25.790]  - attr(*, "resolved")= logi TRUE
[16:11:25.790]  - attr(*, "total_size")= num NA
[16:11:25.794]  - Getting '...' globals ... DONE
[16:11:25.794] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:25.794] List of 2
[16:11:25.794]  $ ...future.FUN:function (x)  
[16:11:25.794]  $ ...          : list()
[16:11:25.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:25.794]  - attr(*, "where")=List of 2
[16:11:25.794]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:25.794]   ..$ ...          :<environment: 0x557e21ee86c0> 
[16:11:25.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:25.794]  - attr(*, "resolved")= logi FALSE
[16:11:25.794]  - attr(*, "total_size")= num 4720
[16:11:25.797] Packages to be attached in all futures: [n=0] 
[16:11:25.797] getGlobalsAndPackagesXApply() ... DONE
[16:11:25.798] Number of futures (= number of chunks): 2
[16:11:25.798] Launching 2 futures (chunks) ...
[16:11:25.798] Chunk #1 of 2 ...
[16:11:25.798]  - Finding globals in 'X' for chunk #1 ...
[16:11:25.798] getGlobalsAndPackages() ...
[16:11:25.798] Searching for globals...
[16:11:25.798] 
[16:11:25.799] Searching for globals ... DONE
[16:11:25.799] - globals: [0] <none>
[16:11:25.799] getGlobalsAndPackages() ... DONE
[16:11:25.799]    + additional globals found: [n=0] 
[16:11:25.799]    + additional namespaces needed: [n=0] 
[16:11:25.799]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:25.799]  - seeds: <none>
[16:11:25.799] getGlobalsAndPackages() ...
[16:11:25.800] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:25.800] Resolving globals: FALSE
[16:11:25.800] Tweak future expression to call with '...' arguments ...
[16:11:25.800] {
[16:11:25.800]     do.call(function(...) {
[16:11:25.800]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:25.800]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:25.800]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:25.800]             on.exit(options(oopts), add = TRUE)
[16:11:25.800]         }
[16:11:25.800]         {
[16:11:25.800]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:25.800]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:25.800]                 ...future.FUN(...future.X_jj, ...)
[16:11:25.800]             })
[16:11:25.800]         }
[16:11:25.800]     }, args = future.call.arguments)
[16:11:25.800] }
[16:11:25.800] Tweak future expression to call with '...' arguments ... DONE
[16:11:25.801] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:25.801] 
[16:11:25.801] getGlobalsAndPackages() ... DONE
[16:11:25.801] run() for ‘Future’ ...
[16:11:25.801] - state: ‘created’
[16:11:25.802] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:25.818] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:25.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:25.818]   - Field: ‘node’
[16:11:25.818]   - Field: ‘label’
[16:11:25.818]   - Field: ‘local’
[16:11:25.818]   - Field: ‘owner’
[16:11:25.818]   - Field: ‘envir’
[16:11:25.818]   - Field: ‘workers’
[16:11:25.818]   - Field: ‘packages’
[16:11:25.818]   - Field: ‘gc’
[16:11:25.819]   - Field: ‘conditions’
[16:11:25.819]   - Field: ‘persistent’
[16:11:25.819]   - Field: ‘expr’
[16:11:25.819]   - Field: ‘uuid’
[16:11:25.819]   - Field: ‘seed’
[16:11:25.819]   - Field: ‘version’
[16:11:25.819]   - Field: ‘result’
[16:11:25.819]   - Field: ‘asynchronous’
[16:11:25.820]   - Field: ‘calls’
[16:11:25.820]   - Field: ‘globals’
[16:11:25.820]   - Field: ‘stdout’
[16:11:25.820]   - Field: ‘earlySignal’
[16:11:25.820]   - Field: ‘lazy’
[16:11:25.820]   - Field: ‘state’
[16:11:25.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:25.820] - Launch lazy future ...
[16:11:25.821] Packages needed by the future expression (n = 0): <none>
[16:11:25.821] Packages needed by future strategies (n = 0): <none>
[16:11:25.821] {
[16:11:25.821]     {
[16:11:25.821]         {
[16:11:25.821]             ...future.startTime <- base::Sys.time()
[16:11:25.821]             {
[16:11:25.821]                 {
[16:11:25.821]                   {
[16:11:25.821]                     {
[16:11:25.821]                       base::local({
[16:11:25.821]                         has_future <- base::requireNamespace("future", 
[16:11:25.821]                           quietly = TRUE)
[16:11:25.821]                         if (has_future) {
[16:11:25.821]                           ns <- base::getNamespace("future")
[16:11:25.821]                           version <- ns[[".package"]][["version"]]
[16:11:25.821]                           if (is.null(version)) 
[16:11:25.821]                             version <- utils::packageVersion("future")
[16:11:25.821]                         }
[16:11:25.821]                         else {
[16:11:25.821]                           version <- NULL
[16:11:25.821]                         }
[16:11:25.821]                         if (!has_future || version < "1.8.0") {
[16:11:25.821]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:25.821]                             "", base::R.version$version.string), 
[16:11:25.821]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:25.821]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:25.821]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:25.821]                               "release", "version")], collapse = " "), 
[16:11:25.821]                             hostname = base::Sys.info()[["nodename"]])
[16:11:25.821]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:25.821]                             info)
[16:11:25.821]                           info <- base::paste(info, collapse = "; ")
[16:11:25.821]                           if (!has_future) {
[16:11:25.821]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:25.821]                               info)
[16:11:25.821]                           }
[16:11:25.821]                           else {
[16:11:25.821]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:25.821]                               info, version)
[16:11:25.821]                           }
[16:11:25.821]                           base::stop(msg)
[16:11:25.821]                         }
[16:11:25.821]                       })
[16:11:25.821]                     }
[16:11:25.821]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:25.821]                     base::options(mc.cores = 1L)
[16:11:25.821]                   }
[16:11:25.821]                   options(future.plan = NULL)
[16:11:25.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:25.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:25.821]                 }
[16:11:25.821]                 ...future.workdir <- getwd()
[16:11:25.821]             }
[16:11:25.821]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:25.821]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:25.821]         }
[16:11:25.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:25.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:25.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:25.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:25.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:25.821]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:25.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:25.821]             base::names(...future.oldOptions))
[16:11:25.821]     }
[16:11:25.821]     if (FALSE) {
[16:11:25.821]     }
[16:11:25.821]     else {
[16:11:25.821]         if (FALSE) {
[16:11:25.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:25.821]                 open = "w")
[16:11:25.821]         }
[16:11:25.821]         else {
[16:11:25.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:25.821]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:25.821]         }
[16:11:25.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:25.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:25.821]             base::sink(type = "output", split = FALSE)
[16:11:25.821]             base::close(...future.stdout)
[16:11:25.821]         }, add = TRUE)
[16:11:25.821]     }
[16:11:25.821]     ...future.frame <- base::sys.nframe()
[16:11:25.821]     ...future.conditions <- base::list()
[16:11:25.821]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:25.821]     if (FALSE) {
[16:11:25.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:25.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:25.821]     }
[16:11:25.821]     ...future.result <- base::tryCatch({
[16:11:25.821]         base::withCallingHandlers({
[16:11:25.821]             ...future.value <- base::withVisible(base::local({
[16:11:25.821]                 ...future.makeSendCondition <- local({
[16:11:25.821]                   sendCondition <- NULL
[16:11:25.821]                   function(frame = 1L) {
[16:11:25.821]                     if (is.function(sendCondition)) 
[16:11:25.821]                       return(sendCondition)
[16:11:25.821]                     ns <- getNamespace("parallel")
[16:11:25.821]                     if (exists("sendData", mode = "function", 
[16:11:25.821]                       envir = ns)) {
[16:11:25.821]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:25.821]                         envir = ns)
[16:11:25.821]                       envir <- sys.frame(frame)
[16:11:25.821]                       master <- NULL
[16:11:25.821]                       while (!identical(envir, .GlobalEnv) && 
[16:11:25.821]                         !identical(envir, emptyenv())) {
[16:11:25.821]                         if (exists("master", mode = "list", envir = envir, 
[16:11:25.821]                           inherits = FALSE)) {
[16:11:25.821]                           master <- get("master", mode = "list", 
[16:11:25.821]                             envir = envir, inherits = FALSE)
[16:11:25.821]                           if (inherits(master, c("SOCKnode", 
[16:11:25.821]                             "SOCK0node"))) {
[16:11:25.821]                             sendCondition <<- function(cond) {
[16:11:25.821]                               data <- list(type = "VALUE", value = cond, 
[16:11:25.821]                                 success = TRUE)
[16:11:25.821]                               parallel_sendData(master, data)
[16:11:25.821]                             }
[16:11:25.821]                             return(sendCondition)
[16:11:25.821]                           }
[16:11:25.821]                         }
[16:11:25.821]                         frame <- frame + 1L
[16:11:25.821]                         envir <- sys.frame(frame)
[16:11:25.821]                       }
[16:11:25.821]                     }
[16:11:25.821]                     sendCondition <<- function(cond) NULL
[16:11:25.821]                   }
[16:11:25.821]                 })
[16:11:25.821]                 withCallingHandlers({
[16:11:25.821]                   {
[16:11:25.821]                     do.call(function(...) {
[16:11:25.821]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:25.821]                       if (!identical(...future.globals.maxSize.org, 
[16:11:25.821]                         ...future.globals.maxSize)) {
[16:11:25.821]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:25.821]                         on.exit(options(oopts), add = TRUE)
[16:11:25.821]                       }
[16:11:25.821]                       {
[16:11:25.821]                         lapply(seq_along(...future.elements_ii), 
[16:11:25.821]                           FUN = function(jj) {
[16:11:25.821]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:25.821]                             ...future.FUN(...future.X_jj, ...)
[16:11:25.821]                           })
[16:11:25.821]                       }
[16:11:25.821]                     }, args = future.call.arguments)
[16:11:25.821]                   }
[16:11:25.821]                 }, immediateCondition = function(cond) {
[16:11:25.821]                   sendCondition <- ...future.makeSendCondition()
[16:11:25.821]                   sendCondition(cond)
[16:11:25.821]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.821]                   {
[16:11:25.821]                     inherits <- base::inherits
[16:11:25.821]                     invokeRestart <- base::invokeRestart
[16:11:25.821]                     is.null <- base::is.null
[16:11:25.821]                     muffled <- FALSE
[16:11:25.821]                     if (inherits(cond, "message")) {
[16:11:25.821]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:25.821]                       if (muffled) 
[16:11:25.821]                         invokeRestart("muffleMessage")
[16:11:25.821]                     }
[16:11:25.821]                     else if (inherits(cond, "warning")) {
[16:11:25.821]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:25.821]                       if (muffled) 
[16:11:25.821]                         invokeRestart("muffleWarning")
[16:11:25.821]                     }
[16:11:25.821]                     else if (inherits(cond, "condition")) {
[16:11:25.821]                       if (!is.null(pattern)) {
[16:11:25.821]                         computeRestarts <- base::computeRestarts
[16:11:25.821]                         grepl <- base::grepl
[16:11:25.821]                         restarts <- computeRestarts(cond)
[16:11:25.821]                         for (restart in restarts) {
[16:11:25.821]                           name <- restart$name
[16:11:25.821]                           if (is.null(name)) 
[16:11:25.821]                             next
[16:11:25.821]                           if (!grepl(pattern, name)) 
[16:11:25.821]                             next
[16:11:25.821]                           invokeRestart(restart)
[16:11:25.821]                           muffled <- TRUE
[16:11:25.821]                           break
[16:11:25.821]                         }
[16:11:25.821]                       }
[16:11:25.821]                     }
[16:11:25.821]                     invisible(muffled)
[16:11:25.821]                   }
[16:11:25.821]                   muffleCondition(cond)
[16:11:25.821]                 })
[16:11:25.821]             }))
[16:11:25.821]             future::FutureResult(value = ...future.value$value, 
[16:11:25.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:25.821]                   ...future.rng), globalenv = if (FALSE) 
[16:11:25.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:25.821]                     ...future.globalenv.names))
[16:11:25.821]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:25.821]         }, condition = base::local({
[16:11:25.821]             c <- base::c
[16:11:25.821]             inherits <- base::inherits
[16:11:25.821]             invokeRestart <- base::invokeRestart
[16:11:25.821]             length <- base::length
[16:11:25.821]             list <- base::list
[16:11:25.821]             seq.int <- base::seq.int
[16:11:25.821]             signalCondition <- base::signalCondition
[16:11:25.821]             sys.calls <- base::sys.calls
[16:11:25.821]             `[[` <- base::`[[`
[16:11:25.821]             `+` <- base::`+`
[16:11:25.821]             `<<-` <- base::`<<-`
[16:11:25.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:25.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:25.821]                   3L)]
[16:11:25.821]             }
[16:11:25.821]             function(cond) {
[16:11:25.821]                 is_error <- inherits(cond, "error")
[16:11:25.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:25.821]                   NULL)
[16:11:25.821]                 if (is_error) {
[16:11:25.821]                   sessionInformation <- function() {
[16:11:25.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:25.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:25.821]                       search = base::search(), system = base::Sys.info())
[16:11:25.821]                   }
[16:11:25.821]                   ...future.conditions[[length(...future.conditions) + 
[16:11:25.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:25.821]                     cond$call), session = sessionInformation(), 
[16:11:25.821]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:25.821]                   signalCondition(cond)
[16:11:25.821]                 }
[16:11:25.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:25.821]                 "immediateCondition"))) {
[16:11:25.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:25.821]                   ...future.conditions[[length(...future.conditions) + 
[16:11:25.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:25.821]                   if (TRUE && !signal) {
[16:11:25.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.821]                     {
[16:11:25.821]                       inherits <- base::inherits
[16:11:25.821]                       invokeRestart <- base::invokeRestart
[16:11:25.821]                       is.null <- base::is.null
[16:11:25.821]                       muffled <- FALSE
[16:11:25.821]                       if (inherits(cond, "message")) {
[16:11:25.821]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:25.821]                         if (muffled) 
[16:11:25.821]                           invokeRestart("muffleMessage")
[16:11:25.821]                       }
[16:11:25.821]                       else if (inherits(cond, "warning")) {
[16:11:25.821]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:25.821]                         if (muffled) 
[16:11:25.821]                           invokeRestart("muffleWarning")
[16:11:25.821]                       }
[16:11:25.821]                       else if (inherits(cond, "condition")) {
[16:11:25.821]                         if (!is.null(pattern)) {
[16:11:25.821]                           computeRestarts <- base::computeRestarts
[16:11:25.821]                           grepl <- base::grepl
[16:11:25.821]                           restarts <- computeRestarts(cond)
[16:11:25.821]                           for (restart in restarts) {
[16:11:25.821]                             name <- restart$name
[16:11:25.821]                             if (is.null(name)) 
[16:11:25.821]                               next
[16:11:25.821]                             if (!grepl(pattern, name)) 
[16:11:25.821]                               next
[16:11:25.821]                             invokeRestart(restart)
[16:11:25.821]                             muffled <- TRUE
[16:11:25.821]                             break
[16:11:25.821]                           }
[16:11:25.821]                         }
[16:11:25.821]                       }
[16:11:25.821]                       invisible(muffled)
[16:11:25.821]                     }
[16:11:25.821]                     muffleCondition(cond, pattern = "^muffle")
[16:11:25.821]                   }
[16:11:25.821]                 }
[16:11:25.821]                 else {
[16:11:25.821]                   if (TRUE) {
[16:11:25.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.821]                     {
[16:11:25.821]                       inherits <- base::inherits
[16:11:25.821]                       invokeRestart <- base::invokeRestart
[16:11:25.821]                       is.null <- base::is.null
[16:11:25.821]                       muffled <- FALSE
[16:11:25.821]                       if (inherits(cond, "message")) {
[16:11:25.821]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:25.821]                         if (muffled) 
[16:11:25.821]                           invokeRestart("muffleMessage")
[16:11:25.821]                       }
[16:11:25.821]                       else if (inherits(cond, "warning")) {
[16:11:25.821]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:25.821]                         if (muffled) 
[16:11:25.821]                           invokeRestart("muffleWarning")
[16:11:25.821]                       }
[16:11:25.821]                       else if (inherits(cond, "condition")) {
[16:11:25.821]                         if (!is.null(pattern)) {
[16:11:25.821]                           computeRestarts <- base::computeRestarts
[16:11:25.821]                           grepl <- base::grepl
[16:11:25.821]                           restarts <- computeRestarts(cond)
[16:11:25.821]                           for (restart in restarts) {
[16:11:25.821]                             name <- restart$name
[16:11:25.821]                             if (is.null(name)) 
[16:11:25.821]                               next
[16:11:25.821]                             if (!grepl(pattern, name)) 
[16:11:25.821]                               next
[16:11:25.821]                             invokeRestart(restart)
[16:11:25.821]                             muffled <- TRUE
[16:11:25.821]                             break
[16:11:25.821]                           }
[16:11:25.821]                         }
[16:11:25.821]                       }
[16:11:25.821]                       invisible(muffled)
[16:11:25.821]                     }
[16:11:25.821]                     muffleCondition(cond, pattern = "^muffle")
[16:11:25.821]                   }
[16:11:25.821]                 }
[16:11:25.821]             }
[16:11:25.821]         }))
[16:11:25.821]     }, error = function(ex) {
[16:11:25.821]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:25.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:25.821]                 ...future.rng), started = ...future.startTime, 
[16:11:25.821]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:25.821]             version = "1.8"), class = "FutureResult")
[16:11:25.821]     }, finally = {
[16:11:25.821]         if (!identical(...future.workdir, getwd())) 
[16:11:25.821]             setwd(...future.workdir)
[16:11:25.821]         {
[16:11:25.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:25.821]                 ...future.oldOptions$nwarnings <- NULL
[16:11:25.821]             }
[16:11:25.821]             base::options(...future.oldOptions)
[16:11:25.821]             if (.Platform$OS.type == "windows") {
[16:11:25.821]                 old_names <- names(...future.oldEnvVars)
[16:11:25.821]                 envs <- base::Sys.getenv()
[16:11:25.821]                 names <- names(envs)
[16:11:25.821]                 common <- intersect(names, old_names)
[16:11:25.821]                 added <- setdiff(names, old_names)
[16:11:25.821]                 removed <- setdiff(old_names, names)
[16:11:25.821]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:25.821]                   envs[common]]
[16:11:25.821]                 NAMES <- toupper(changed)
[16:11:25.821]                 args <- list()
[16:11:25.821]                 for (kk in seq_along(NAMES)) {
[16:11:25.821]                   name <- changed[[kk]]
[16:11:25.821]                   NAME <- NAMES[[kk]]
[16:11:25.821]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.821]                     next
[16:11:25.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:25.821]                 }
[16:11:25.821]                 NAMES <- toupper(added)
[16:11:25.821]                 for (kk in seq_along(NAMES)) {
[16:11:25.821]                   name <- added[[kk]]
[16:11:25.821]                   NAME <- NAMES[[kk]]
[16:11:25.821]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.821]                     next
[16:11:25.821]                   args[[name]] <- ""
[16:11:25.821]                 }
[16:11:25.821]                 NAMES <- toupper(removed)
[16:11:25.821]                 for (kk in seq_along(NAMES)) {
[16:11:25.821]                   name <- removed[[kk]]
[16:11:25.821]                   NAME <- NAMES[[kk]]
[16:11:25.821]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.821]                     next
[16:11:25.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:25.821]                 }
[16:11:25.821]                 if (length(args) > 0) 
[16:11:25.821]                   base::do.call(base::Sys.setenv, args = args)
[16:11:25.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:25.821]             }
[16:11:25.821]             else {
[16:11:25.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:25.821]             }
[16:11:25.821]             {
[16:11:25.821]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:25.821]                   0L) {
[16:11:25.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:25.821]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:25.821]                   base::options(opts)
[16:11:25.821]                 }
[16:11:25.821]                 {
[16:11:25.821]                   {
[16:11:25.821]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:25.821]                     NULL
[16:11:25.821]                   }
[16:11:25.821]                   options(future.plan = NULL)
[16:11:25.821]                   if (is.na(NA_character_)) 
[16:11:25.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:25.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:25.821]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:25.821]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:25.821]                     envir = parent.frame()) 
[16:11:25.821]                   {
[16:11:25.821]                     if (is.function(workers)) 
[16:11:25.821]                       workers <- workers()
[16:11:25.821]                     workers <- structure(as.integer(workers), 
[16:11:25.821]                       class = class(workers))
[16:11:25.821]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:25.821]                       workers >= 1)
[16:11:25.821]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:25.821]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:25.821]                     }
[16:11:25.821]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:25.821]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:25.821]                       envir = envir)
[16:11:25.821]                     if (!future$lazy) 
[16:11:25.821]                       future <- run(future)
[16:11:25.821]                     invisible(future)
[16:11:25.821]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:25.821]                 }
[16:11:25.821]             }
[16:11:25.821]         }
[16:11:25.821]     })
[16:11:25.821]     if (TRUE) {
[16:11:25.821]         base::sink(type = "output", split = FALSE)
[16:11:25.821]         if (FALSE) {
[16:11:25.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:25.821]         }
[16:11:25.821]         else {
[16:11:25.821]             ...future.result["stdout"] <- base::list(NULL)
[16:11:25.821]         }
[16:11:25.821]         base::close(...future.stdout)
[16:11:25.821]         ...future.stdout <- NULL
[16:11:25.821]     }
[16:11:25.821]     ...future.result$conditions <- ...future.conditions
[16:11:25.821]     ...future.result$finished <- base::Sys.time()
[16:11:25.821]     ...future.result
[16:11:25.821] }
[16:11:25.825] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:11:25.825] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:11:25.825] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:11:25.826] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:25.826] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:25.826] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:11:25.827] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:11:25.827] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:25.827] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:25.827] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:25.828] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:25.828] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:11:25.828] MultisessionFuture started
[16:11:25.828] - Launch lazy future ... done
[16:11:25.829] run() for ‘MultisessionFuture’ ... done
[16:11:25.829] Created future:
[16:11:25.829] MultisessionFuture:
[16:11:25.829] Label: ‘future_lapply-1’
[16:11:25.829] Expression:
[16:11:25.829] {
[16:11:25.829]     do.call(function(...) {
[16:11:25.829]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:25.829]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:25.829]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:25.829]             on.exit(options(oopts), add = TRUE)
[16:11:25.829]         }
[16:11:25.829]         {
[16:11:25.829]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:25.829]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:25.829]                 ...future.FUN(...future.X_jj, ...)
[16:11:25.829]             })
[16:11:25.829]         }
[16:11:25.829]     }, args = future.call.arguments)
[16:11:25.829] }
[16:11:25.829] Lazy evaluation: FALSE
[16:11:25.829] Asynchronous evaluation: TRUE
[16:11:25.829] Local evaluation: TRUE
[16:11:25.829] Environment: R_GlobalEnv
[16:11:25.829] Capture standard output: FALSE
[16:11:25.829] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:25.829] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:25.829] Packages: <none>
[16:11:25.829] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:25.829] Resolved: FALSE
[16:11:25.829] Value: <not collected>
[16:11:25.829] Conditions captured: <none>
[16:11:25.829] Early signaling: FALSE
[16:11:25.829] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:25.829] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:25.841] Chunk #1 of 2 ... DONE
[16:11:25.841] Chunk #2 of 2 ...
[16:11:25.841]  - Finding globals in 'X' for chunk #2 ...
[16:11:25.841] getGlobalsAndPackages() ...
[16:11:25.841] Searching for globals...
[16:11:25.842] 
[16:11:25.842] Searching for globals ... DONE
[16:11:25.842] - globals: [0] <none>
[16:11:25.842] getGlobalsAndPackages() ... DONE
[16:11:25.842]    + additional globals found: [n=0] 
[16:11:25.842]    + additional namespaces needed: [n=0] 
[16:11:25.842]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:25.843]  - seeds: <none>
[16:11:25.843] getGlobalsAndPackages() ...
[16:11:25.843] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:25.843] Resolving globals: FALSE
[16:11:25.843] Tweak future expression to call with '...' arguments ...
[16:11:25.843] {
[16:11:25.843]     do.call(function(...) {
[16:11:25.843]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:25.843]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:25.843]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:25.843]             on.exit(options(oopts), add = TRUE)
[16:11:25.843]         }
[16:11:25.843]         {
[16:11:25.843]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:25.843]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:25.843]                 ...future.FUN(...future.X_jj, ...)
[16:11:25.843]             })
[16:11:25.843]         }
[16:11:25.843]     }, args = future.call.arguments)
[16:11:25.843] }
[16:11:25.843] Tweak future expression to call with '...' arguments ... DONE
[16:11:25.844] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:25.844] 
[16:11:25.844] getGlobalsAndPackages() ... DONE
[16:11:25.845] run() for ‘Future’ ...
[16:11:25.845] - state: ‘created’
[16:11:25.845] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:25.861] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:25.861] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:25.861]   - Field: ‘node’
[16:11:25.861]   - Field: ‘label’
[16:11:25.862]   - Field: ‘local’
[16:11:25.862]   - Field: ‘owner’
[16:11:25.862]   - Field: ‘envir’
[16:11:25.862]   - Field: ‘workers’
[16:11:25.862]   - Field: ‘packages’
[16:11:25.862]   - Field: ‘gc’
[16:11:25.862]   - Field: ‘conditions’
[16:11:25.862]   - Field: ‘persistent’
[16:11:25.862]   - Field: ‘expr’
[16:11:25.863]   - Field: ‘uuid’
[16:11:25.863]   - Field: ‘seed’
[16:11:25.863]   - Field: ‘version’
[16:11:25.863]   - Field: ‘result’
[16:11:25.863]   - Field: ‘asynchronous’
[16:11:25.863]   - Field: ‘calls’
[16:11:25.863]   - Field: ‘globals’
[16:11:25.863]   - Field: ‘stdout’
[16:11:25.863]   - Field: ‘earlySignal’
[16:11:25.864]   - Field: ‘lazy’
[16:11:25.864]   - Field: ‘state’
[16:11:25.864] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:25.864] - Launch lazy future ...
[16:11:25.864] Packages needed by the future expression (n = 0): <none>
[16:11:25.864] Packages needed by future strategies (n = 0): <none>
[16:11:25.865] {
[16:11:25.865]     {
[16:11:25.865]         {
[16:11:25.865]             ...future.startTime <- base::Sys.time()
[16:11:25.865]             {
[16:11:25.865]                 {
[16:11:25.865]                   {
[16:11:25.865]                     {
[16:11:25.865]                       base::local({
[16:11:25.865]                         has_future <- base::requireNamespace("future", 
[16:11:25.865]                           quietly = TRUE)
[16:11:25.865]                         if (has_future) {
[16:11:25.865]                           ns <- base::getNamespace("future")
[16:11:25.865]                           version <- ns[[".package"]][["version"]]
[16:11:25.865]                           if (is.null(version)) 
[16:11:25.865]                             version <- utils::packageVersion("future")
[16:11:25.865]                         }
[16:11:25.865]                         else {
[16:11:25.865]                           version <- NULL
[16:11:25.865]                         }
[16:11:25.865]                         if (!has_future || version < "1.8.0") {
[16:11:25.865]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:25.865]                             "", base::R.version$version.string), 
[16:11:25.865]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:25.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:25.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:25.865]                               "release", "version")], collapse = " "), 
[16:11:25.865]                             hostname = base::Sys.info()[["nodename"]])
[16:11:25.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:25.865]                             info)
[16:11:25.865]                           info <- base::paste(info, collapse = "; ")
[16:11:25.865]                           if (!has_future) {
[16:11:25.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:25.865]                               info)
[16:11:25.865]                           }
[16:11:25.865]                           else {
[16:11:25.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:25.865]                               info, version)
[16:11:25.865]                           }
[16:11:25.865]                           base::stop(msg)
[16:11:25.865]                         }
[16:11:25.865]                       })
[16:11:25.865]                     }
[16:11:25.865]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:25.865]                     base::options(mc.cores = 1L)
[16:11:25.865]                   }
[16:11:25.865]                   options(future.plan = NULL)
[16:11:25.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:25.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:25.865]                 }
[16:11:25.865]                 ...future.workdir <- getwd()
[16:11:25.865]             }
[16:11:25.865]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:25.865]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:25.865]         }
[16:11:25.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:25.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:25.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:25.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:25.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:25.865]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:25.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:25.865]             base::names(...future.oldOptions))
[16:11:25.865]     }
[16:11:25.865]     if (FALSE) {
[16:11:25.865]     }
[16:11:25.865]     else {
[16:11:25.865]         if (FALSE) {
[16:11:25.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:25.865]                 open = "w")
[16:11:25.865]         }
[16:11:25.865]         else {
[16:11:25.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:25.865]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:25.865]         }
[16:11:25.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:25.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:25.865]             base::sink(type = "output", split = FALSE)
[16:11:25.865]             base::close(...future.stdout)
[16:11:25.865]         }, add = TRUE)
[16:11:25.865]     }
[16:11:25.865]     ...future.frame <- base::sys.nframe()
[16:11:25.865]     ...future.conditions <- base::list()
[16:11:25.865]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:25.865]     if (FALSE) {
[16:11:25.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:25.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:25.865]     }
[16:11:25.865]     ...future.result <- base::tryCatch({
[16:11:25.865]         base::withCallingHandlers({
[16:11:25.865]             ...future.value <- base::withVisible(base::local({
[16:11:25.865]                 ...future.makeSendCondition <- local({
[16:11:25.865]                   sendCondition <- NULL
[16:11:25.865]                   function(frame = 1L) {
[16:11:25.865]                     if (is.function(sendCondition)) 
[16:11:25.865]                       return(sendCondition)
[16:11:25.865]                     ns <- getNamespace("parallel")
[16:11:25.865]                     if (exists("sendData", mode = "function", 
[16:11:25.865]                       envir = ns)) {
[16:11:25.865]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:25.865]                         envir = ns)
[16:11:25.865]                       envir <- sys.frame(frame)
[16:11:25.865]                       master <- NULL
[16:11:25.865]                       while (!identical(envir, .GlobalEnv) && 
[16:11:25.865]                         !identical(envir, emptyenv())) {
[16:11:25.865]                         if (exists("master", mode = "list", envir = envir, 
[16:11:25.865]                           inherits = FALSE)) {
[16:11:25.865]                           master <- get("master", mode = "list", 
[16:11:25.865]                             envir = envir, inherits = FALSE)
[16:11:25.865]                           if (inherits(master, c("SOCKnode", 
[16:11:25.865]                             "SOCK0node"))) {
[16:11:25.865]                             sendCondition <<- function(cond) {
[16:11:25.865]                               data <- list(type = "VALUE", value = cond, 
[16:11:25.865]                                 success = TRUE)
[16:11:25.865]                               parallel_sendData(master, data)
[16:11:25.865]                             }
[16:11:25.865]                             return(sendCondition)
[16:11:25.865]                           }
[16:11:25.865]                         }
[16:11:25.865]                         frame <- frame + 1L
[16:11:25.865]                         envir <- sys.frame(frame)
[16:11:25.865]                       }
[16:11:25.865]                     }
[16:11:25.865]                     sendCondition <<- function(cond) NULL
[16:11:25.865]                   }
[16:11:25.865]                 })
[16:11:25.865]                 withCallingHandlers({
[16:11:25.865]                   {
[16:11:25.865]                     do.call(function(...) {
[16:11:25.865]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:25.865]                       if (!identical(...future.globals.maxSize.org, 
[16:11:25.865]                         ...future.globals.maxSize)) {
[16:11:25.865]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:25.865]                         on.exit(options(oopts), add = TRUE)
[16:11:25.865]                       }
[16:11:25.865]                       {
[16:11:25.865]                         lapply(seq_along(...future.elements_ii), 
[16:11:25.865]                           FUN = function(jj) {
[16:11:25.865]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:25.865]                             ...future.FUN(...future.X_jj, ...)
[16:11:25.865]                           })
[16:11:25.865]                       }
[16:11:25.865]                     }, args = future.call.arguments)
[16:11:25.865]                   }
[16:11:25.865]                 }, immediateCondition = function(cond) {
[16:11:25.865]                   sendCondition <- ...future.makeSendCondition()
[16:11:25.865]                   sendCondition(cond)
[16:11:25.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.865]                   {
[16:11:25.865]                     inherits <- base::inherits
[16:11:25.865]                     invokeRestart <- base::invokeRestart
[16:11:25.865]                     is.null <- base::is.null
[16:11:25.865]                     muffled <- FALSE
[16:11:25.865]                     if (inherits(cond, "message")) {
[16:11:25.865]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:25.865]                       if (muffled) 
[16:11:25.865]                         invokeRestart("muffleMessage")
[16:11:25.865]                     }
[16:11:25.865]                     else if (inherits(cond, "warning")) {
[16:11:25.865]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:25.865]                       if (muffled) 
[16:11:25.865]                         invokeRestart("muffleWarning")
[16:11:25.865]                     }
[16:11:25.865]                     else if (inherits(cond, "condition")) {
[16:11:25.865]                       if (!is.null(pattern)) {
[16:11:25.865]                         computeRestarts <- base::computeRestarts
[16:11:25.865]                         grepl <- base::grepl
[16:11:25.865]                         restarts <- computeRestarts(cond)
[16:11:25.865]                         for (restart in restarts) {
[16:11:25.865]                           name <- restart$name
[16:11:25.865]                           if (is.null(name)) 
[16:11:25.865]                             next
[16:11:25.865]                           if (!grepl(pattern, name)) 
[16:11:25.865]                             next
[16:11:25.865]                           invokeRestart(restart)
[16:11:25.865]                           muffled <- TRUE
[16:11:25.865]                           break
[16:11:25.865]                         }
[16:11:25.865]                       }
[16:11:25.865]                     }
[16:11:25.865]                     invisible(muffled)
[16:11:25.865]                   }
[16:11:25.865]                   muffleCondition(cond)
[16:11:25.865]                 })
[16:11:25.865]             }))
[16:11:25.865]             future::FutureResult(value = ...future.value$value, 
[16:11:25.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:25.865]                   ...future.rng), globalenv = if (FALSE) 
[16:11:25.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:25.865]                     ...future.globalenv.names))
[16:11:25.865]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:25.865]         }, condition = base::local({
[16:11:25.865]             c <- base::c
[16:11:25.865]             inherits <- base::inherits
[16:11:25.865]             invokeRestart <- base::invokeRestart
[16:11:25.865]             length <- base::length
[16:11:25.865]             list <- base::list
[16:11:25.865]             seq.int <- base::seq.int
[16:11:25.865]             signalCondition <- base::signalCondition
[16:11:25.865]             sys.calls <- base::sys.calls
[16:11:25.865]             `[[` <- base::`[[`
[16:11:25.865]             `+` <- base::`+`
[16:11:25.865]             `<<-` <- base::`<<-`
[16:11:25.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:25.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:25.865]                   3L)]
[16:11:25.865]             }
[16:11:25.865]             function(cond) {
[16:11:25.865]                 is_error <- inherits(cond, "error")
[16:11:25.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:25.865]                   NULL)
[16:11:25.865]                 if (is_error) {
[16:11:25.865]                   sessionInformation <- function() {
[16:11:25.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:25.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:25.865]                       search = base::search(), system = base::Sys.info())
[16:11:25.865]                   }
[16:11:25.865]                   ...future.conditions[[length(...future.conditions) + 
[16:11:25.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:25.865]                     cond$call), session = sessionInformation(), 
[16:11:25.865]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:25.865]                   signalCondition(cond)
[16:11:25.865]                 }
[16:11:25.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:25.865]                 "immediateCondition"))) {
[16:11:25.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:25.865]                   ...future.conditions[[length(...future.conditions) + 
[16:11:25.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:25.865]                   if (TRUE && !signal) {
[16:11:25.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.865]                     {
[16:11:25.865]                       inherits <- base::inherits
[16:11:25.865]                       invokeRestart <- base::invokeRestart
[16:11:25.865]                       is.null <- base::is.null
[16:11:25.865]                       muffled <- FALSE
[16:11:25.865]                       if (inherits(cond, "message")) {
[16:11:25.865]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:25.865]                         if (muffled) 
[16:11:25.865]                           invokeRestart("muffleMessage")
[16:11:25.865]                       }
[16:11:25.865]                       else if (inherits(cond, "warning")) {
[16:11:25.865]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:25.865]                         if (muffled) 
[16:11:25.865]                           invokeRestart("muffleWarning")
[16:11:25.865]                       }
[16:11:25.865]                       else if (inherits(cond, "condition")) {
[16:11:25.865]                         if (!is.null(pattern)) {
[16:11:25.865]                           computeRestarts <- base::computeRestarts
[16:11:25.865]                           grepl <- base::grepl
[16:11:25.865]                           restarts <- computeRestarts(cond)
[16:11:25.865]                           for (restart in restarts) {
[16:11:25.865]                             name <- restart$name
[16:11:25.865]                             if (is.null(name)) 
[16:11:25.865]                               next
[16:11:25.865]                             if (!grepl(pattern, name)) 
[16:11:25.865]                               next
[16:11:25.865]                             invokeRestart(restart)
[16:11:25.865]                             muffled <- TRUE
[16:11:25.865]                             break
[16:11:25.865]                           }
[16:11:25.865]                         }
[16:11:25.865]                       }
[16:11:25.865]                       invisible(muffled)
[16:11:25.865]                     }
[16:11:25.865]                     muffleCondition(cond, pattern = "^muffle")
[16:11:25.865]                   }
[16:11:25.865]                 }
[16:11:25.865]                 else {
[16:11:25.865]                   if (TRUE) {
[16:11:25.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:25.865]                     {
[16:11:25.865]                       inherits <- base::inherits
[16:11:25.865]                       invokeRestart <- base::invokeRestart
[16:11:25.865]                       is.null <- base::is.null
[16:11:25.865]                       muffled <- FALSE
[16:11:25.865]                       if (inherits(cond, "message")) {
[16:11:25.865]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:25.865]                         if (muffled) 
[16:11:25.865]                           invokeRestart("muffleMessage")
[16:11:25.865]                       }
[16:11:25.865]                       else if (inherits(cond, "warning")) {
[16:11:25.865]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:25.865]                         if (muffled) 
[16:11:25.865]                           invokeRestart("muffleWarning")
[16:11:25.865]                       }
[16:11:25.865]                       else if (inherits(cond, "condition")) {
[16:11:25.865]                         if (!is.null(pattern)) {
[16:11:25.865]                           computeRestarts <- base::computeRestarts
[16:11:25.865]                           grepl <- base::grepl
[16:11:25.865]                           restarts <- computeRestarts(cond)
[16:11:25.865]                           for (restart in restarts) {
[16:11:25.865]                             name <- restart$name
[16:11:25.865]                             if (is.null(name)) 
[16:11:25.865]                               next
[16:11:25.865]                             if (!grepl(pattern, name)) 
[16:11:25.865]                               next
[16:11:25.865]                             invokeRestart(restart)
[16:11:25.865]                             muffled <- TRUE
[16:11:25.865]                             break
[16:11:25.865]                           }
[16:11:25.865]                         }
[16:11:25.865]                       }
[16:11:25.865]                       invisible(muffled)
[16:11:25.865]                     }
[16:11:25.865]                     muffleCondition(cond, pattern = "^muffle")
[16:11:25.865]                   }
[16:11:25.865]                 }
[16:11:25.865]             }
[16:11:25.865]         }))
[16:11:25.865]     }, error = function(ex) {
[16:11:25.865]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:25.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:25.865]                 ...future.rng), started = ...future.startTime, 
[16:11:25.865]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:25.865]             version = "1.8"), class = "FutureResult")
[16:11:25.865]     }, finally = {
[16:11:25.865]         if (!identical(...future.workdir, getwd())) 
[16:11:25.865]             setwd(...future.workdir)
[16:11:25.865]         {
[16:11:25.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:25.865]                 ...future.oldOptions$nwarnings <- NULL
[16:11:25.865]             }
[16:11:25.865]             base::options(...future.oldOptions)
[16:11:25.865]             if (.Platform$OS.type == "windows") {
[16:11:25.865]                 old_names <- names(...future.oldEnvVars)
[16:11:25.865]                 envs <- base::Sys.getenv()
[16:11:25.865]                 names <- names(envs)
[16:11:25.865]                 common <- intersect(names, old_names)
[16:11:25.865]                 added <- setdiff(names, old_names)
[16:11:25.865]                 removed <- setdiff(old_names, names)
[16:11:25.865]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:25.865]                   envs[common]]
[16:11:25.865]                 NAMES <- toupper(changed)
[16:11:25.865]                 args <- list()
[16:11:25.865]                 for (kk in seq_along(NAMES)) {
[16:11:25.865]                   name <- changed[[kk]]
[16:11:25.865]                   NAME <- NAMES[[kk]]
[16:11:25.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.865]                     next
[16:11:25.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:25.865]                 }
[16:11:25.865]                 NAMES <- toupper(added)
[16:11:25.865]                 for (kk in seq_along(NAMES)) {
[16:11:25.865]                   name <- added[[kk]]
[16:11:25.865]                   NAME <- NAMES[[kk]]
[16:11:25.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.865]                     next
[16:11:25.865]                   args[[name]] <- ""
[16:11:25.865]                 }
[16:11:25.865]                 NAMES <- toupper(removed)
[16:11:25.865]                 for (kk in seq_along(NAMES)) {
[16:11:25.865]                   name <- removed[[kk]]
[16:11:25.865]                   NAME <- NAMES[[kk]]
[16:11:25.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:25.865]                     next
[16:11:25.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:25.865]                 }
[16:11:25.865]                 if (length(args) > 0) 
[16:11:25.865]                   base::do.call(base::Sys.setenv, args = args)
[16:11:25.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:25.865]             }
[16:11:25.865]             else {
[16:11:25.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:25.865]             }
[16:11:25.865]             {
[16:11:25.865]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:25.865]                   0L) {
[16:11:25.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:25.865]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:25.865]                   base::options(opts)
[16:11:25.865]                 }
[16:11:25.865]                 {
[16:11:25.865]                   {
[16:11:25.865]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:25.865]                     NULL
[16:11:25.865]                   }
[16:11:25.865]                   options(future.plan = NULL)
[16:11:25.865]                   if (is.na(NA_character_)) 
[16:11:25.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:25.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:25.865]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:25.865]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:25.865]                     envir = parent.frame()) 
[16:11:25.865]                   {
[16:11:25.865]                     if (is.function(workers)) 
[16:11:25.865]                       workers <- workers()
[16:11:25.865]                     workers <- structure(as.integer(workers), 
[16:11:25.865]                       class = class(workers))
[16:11:25.865]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:25.865]                       workers >= 1)
[16:11:25.865]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:25.865]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:25.865]                     }
[16:11:25.865]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:25.865]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:25.865]                       envir = envir)
[16:11:25.865]                     if (!future$lazy) 
[16:11:25.865]                       future <- run(future)
[16:11:25.865]                     invisible(future)
[16:11:25.865]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:25.865]                 }
[16:11:25.865]             }
[16:11:25.865]         }
[16:11:25.865]     })
[16:11:25.865]     if (TRUE) {
[16:11:25.865]         base::sink(type = "output", split = FALSE)
[16:11:25.865]         if (FALSE) {
[16:11:25.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:25.865]         }
[16:11:25.865]         else {
[16:11:25.865]             ...future.result["stdout"] <- base::list(NULL)
[16:11:25.865]         }
[16:11:25.865]         base::close(...future.stdout)
[16:11:25.865]         ...future.stdout <- NULL
[16:11:25.865]     }
[16:11:25.865]     ...future.result$conditions <- ...future.conditions
[16:11:25.865]     ...future.result$finished <- base::Sys.time()
[16:11:25.865]     ...future.result
[16:11:25.865] }
[16:11:25.936] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:11:25.936] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:11:25.937] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:11:25.937] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:25.938] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:25.938] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:11:25.938] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:11:25.938] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:25.939] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:25.939] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:25.939] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:25.939] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:11:25.940] MultisessionFuture started
[16:11:25.940] - Launch lazy future ... done
[16:11:25.940] run() for ‘MultisessionFuture’ ... done
[16:11:25.940] Created future:
[16:11:25.940] MultisessionFuture:
[16:11:25.940] Label: ‘future_lapply-2’
[16:11:25.940] Expression:
[16:11:25.940] {
[16:11:25.940]     do.call(function(...) {
[16:11:25.940]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:25.940]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:25.940]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:25.940]             on.exit(options(oopts), add = TRUE)
[16:11:25.940]         }
[16:11:25.940]         {
[16:11:25.940]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:25.940]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:25.940]                 ...future.FUN(...future.X_jj, ...)
[16:11:25.940]             })
[16:11:25.940]         }
[16:11:25.940]     }, args = future.call.arguments)
[16:11:25.940] }
[16:11:25.940] Lazy evaluation: FALSE
[16:11:25.940] Asynchronous evaluation: TRUE
[16:11:25.940] Local evaluation: TRUE
[16:11:25.940] Environment: R_GlobalEnv
[16:11:25.940] Capture standard output: FALSE
[16:11:25.940] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:25.940] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:25.940] Packages: <none>
[16:11:25.940] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:25.940] Resolved: FALSE
[16:11:25.940] Value: <not collected>
[16:11:25.940] Conditions captured: <none>
[16:11:25.940] Early signaling: FALSE
[16:11:25.940] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:25.940] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:25.952] Chunk #2 of 2 ... DONE
[16:11:25.952] Launching 2 futures (chunks) ... DONE
[16:11:25.953] Resolving 2 futures (chunks) ...
[16:11:25.953] resolve() on list ...
[16:11:25.953]  recursive: 0
[16:11:25.953]  length: 2
[16:11:25.953] 
[16:11:26.029] receiveMessageFromWorker() for ClusterFuture ...
[16:11:26.029] - Validating connection of MultisessionFuture
[16:11:26.030] - received message: FutureResult
[16:11:26.030] - Received FutureResult
[16:11:26.030] - Erased future from FutureRegistry
[16:11:26.030] result() for ClusterFuture ...
[16:11:26.030] - result already collected: FutureResult
[16:11:26.030] result() for ClusterFuture ... done
[16:11:26.030] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:26.030] Future #2
[16:11:26.031] result() for ClusterFuture ...
[16:11:26.031] - result already collected: FutureResult
[16:11:26.031] result() for ClusterFuture ... done
[16:11:26.031] result() for ClusterFuture ...
[16:11:26.031] - result already collected: FutureResult
[16:11:26.031] result() for ClusterFuture ... done
[16:11:26.031] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:26.031] - nx: 2
[16:11:26.031] - relay: TRUE
[16:11:26.031] - stdout: TRUE
[16:11:26.032] - signal: TRUE
[16:11:26.032] - resignal: FALSE
[16:11:26.032] - force: TRUE
[16:11:26.032] - relayed: [n=2] FALSE, FALSE
[16:11:26.032] - queued futures: [n=2] FALSE, FALSE
[16:11:26.032]  - until=1
[16:11:26.032]  - relaying element #1
[16:11:26.032] - relayed: [n=2] FALSE, FALSE
[16:11:26.032] - queued futures: [n=2] FALSE, TRUE
[16:11:26.032] signalConditionsASAP(NULL, pos=2) ... done
[16:11:26.033]  length: 1 (resolved future 2)
[16:11:26.378] receiveMessageFromWorker() for ClusterFuture ...
[16:11:26.378] - Validating connection of MultisessionFuture
[16:11:26.378] - received message: FutureResult
[16:11:26.379] - Received FutureResult
[16:11:26.379] - Erased future from FutureRegistry
[16:11:26.379] result() for ClusterFuture ...
[16:11:26.379] - result already collected: FutureResult
[16:11:26.379] result() for ClusterFuture ... done
[16:11:26.379] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:26.379] Future #1
[16:11:26.379] result() for ClusterFuture ...
[16:11:26.379] - result already collected: FutureResult
[16:11:26.379] result() for ClusterFuture ... done
[16:11:26.380] result() for ClusterFuture ...
[16:11:26.380] - result already collected: FutureResult
[16:11:26.380] result() for ClusterFuture ... done
[16:11:26.380] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:26.380] - nx: 2
[16:11:26.380] - relay: TRUE
[16:11:26.380] - stdout: TRUE
[16:11:26.380] - signal: TRUE
[16:11:26.380] - resignal: FALSE
[16:11:26.380] - force: TRUE
[16:11:26.380] - relayed: [n=2] FALSE, FALSE
[16:11:26.380] - queued futures: [n=2] FALSE, TRUE
[16:11:26.381]  - until=1
[16:11:26.381]  - relaying element #1
[16:11:26.381] result() for ClusterFuture ...
[16:11:26.381] - result already collected: FutureResult
[16:11:26.381] result() for ClusterFuture ... done
[16:11:26.381] result() for ClusterFuture ...
[16:11:26.381] - result already collected: FutureResult
[16:11:26.381] result() for ClusterFuture ... done
[16:11:26.381] result() for ClusterFuture ...
[16:11:26.381] - result already collected: FutureResult
[16:11:26.381] result() for ClusterFuture ... done
[16:11:26.382] result() for ClusterFuture ...
[16:11:26.382] - result already collected: FutureResult
[16:11:26.382] result() for ClusterFuture ... done
[16:11:26.382] - relayed: [n=2] TRUE, FALSE
[16:11:26.382] - queued futures: [n=2] TRUE, TRUE
[16:11:26.382] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:26.382]  length: 0 (resolved future 1)
[16:11:26.382] Relaying remaining futures
[16:11:26.382] signalConditionsASAP(NULL, pos=0) ...
[16:11:26.382] - nx: 2
[16:11:26.382] - relay: TRUE
[16:11:26.382] - stdout: TRUE
[16:11:26.383] - signal: TRUE
[16:11:26.383] - resignal: FALSE
[16:11:26.383] - force: TRUE
[16:11:26.383] - relayed: [n=2] TRUE, FALSE
[16:11:26.383] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:26.383]  - relaying element #2
[16:11:26.383] result() for ClusterFuture ...
[16:11:26.383] - result already collected: FutureResult
[16:11:26.383] result() for ClusterFuture ... done
[16:11:26.383] result() for ClusterFuture ...
[16:11:26.383] - result already collected: FutureResult
[16:11:26.384] result() for ClusterFuture ... done
[16:11:26.384] result() for ClusterFuture ...
[16:11:26.384] - result already collected: FutureResult
[16:11:26.384] result() for ClusterFuture ... done
[16:11:26.384] result() for ClusterFuture ...
[16:11:26.384] - result already collected: FutureResult
[16:11:26.384] result() for ClusterFuture ... done
[16:11:26.384] - relayed: [n=2] TRUE, TRUE
[16:11:26.384] - queued futures: [n=2] TRUE, TRUE
[16:11:26.384] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:11:26.384] resolve() on list ... DONE
[16:11:26.385] result() for ClusterFuture ...
[16:11:26.385] - result already collected: FutureResult
[16:11:26.385] result() for ClusterFuture ... done
[16:11:26.385] result() for ClusterFuture ...
[16:11:26.385] - result already collected: FutureResult
[16:11:26.385] result() for ClusterFuture ... done
[16:11:26.385] result() for ClusterFuture ...
[16:11:26.385] - result already collected: FutureResult
[16:11:26.385] result() for ClusterFuture ... done
[16:11:26.385] result() for ClusterFuture ...
[16:11:26.385] - result already collected: FutureResult
[16:11:26.385] result() for ClusterFuture ... done
[16:11:26.386]  - Number of value chunks collected: 2
[16:11:26.386] Resolving 2 futures (chunks) ... DONE
[16:11:26.386] Reducing values from 2 chunks ...
[16:11:26.386]  - Number of values collected after concatenation: 2
[16:11:26.386]  - Number of values expected: 2
[16:11:26.386] Reducing values from 2 chunks ... DONE
[16:11:26.386] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:11:26.386] future_lapply() ...
[16:11:26.391] Number of chunks: 2
[16:11:26.391] getGlobalsAndPackagesXApply() ...
[16:11:26.391]  - future.globals: TRUE
[16:11:26.391] getGlobalsAndPackages() ...
[16:11:26.391] Searching for globals...
[16:11:26.392] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:26.393] Searching for globals ... DONE
[16:11:26.393] Resolving globals: FALSE
[16:11:26.393] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:26.393] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:26.394] - globals: [1] ‘FUN’
[16:11:26.394] 
[16:11:26.394] getGlobalsAndPackages() ... DONE
[16:11:26.394]  - globals found/used: [n=1] ‘FUN’
[16:11:26.394]  - needed namespaces: [n=0] 
[16:11:26.394] Finding globals ... DONE
[16:11:26.394]  - use_args: TRUE
[16:11:26.394]  - Getting '...' globals ...
[16:11:26.395] resolve() on list ...
[16:11:26.395]  recursive: 0
[16:11:26.395]  length: 1
[16:11:26.395]  elements: ‘...’
[16:11:26.395]  length: 0 (resolved future 1)
[16:11:26.395] resolve() on list ... DONE
[16:11:26.395]    - '...' content: [n=0] 
[16:11:26.395] List of 1
[16:11:26.395]  $ ...: list()
[16:11:26.395]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:26.395]  - attr(*, "where")=List of 1
[16:11:26.395]   ..$ ...:<environment: 0x557e206c0f48> 
[16:11:26.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:26.395]  - attr(*, "resolved")= logi TRUE
[16:11:26.395]  - attr(*, "total_size")= num NA
[16:11:26.398]  - Getting '...' globals ... DONE
[16:11:26.398] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:26.398] List of 2
[16:11:26.398]  $ ...future.FUN:function (x)  
[16:11:26.398]  $ ...          : list()
[16:11:26.398]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:26.398]  - attr(*, "where")=List of 2
[16:11:26.398]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:26.398]   ..$ ...          :<environment: 0x557e206c0f48> 
[16:11:26.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:26.398]  - attr(*, "resolved")= logi FALSE
[16:11:26.398]  - attr(*, "total_size")= num 4720
[16:11:26.401] Packages to be attached in all futures: [n=0] 
[16:11:26.401] getGlobalsAndPackagesXApply() ... DONE
[16:11:26.401] Number of futures (= number of chunks): 2
[16:11:26.401] Launching 2 futures (chunks) ...
[16:11:26.401] Chunk #1 of 2 ...
[16:11:26.401]  - Finding globals in 'X' for chunk #1 ...
[16:11:26.401] getGlobalsAndPackages() ...
[16:11:26.402] Searching for globals...
[16:11:26.402] 
[16:11:26.402] Searching for globals ... DONE
[16:11:26.402] - globals: [0] <none>
[16:11:26.402] getGlobalsAndPackages() ... DONE
[16:11:26.402]    + additional globals found: [n=0] 
[16:11:26.402]    + additional namespaces needed: [n=0] 
[16:11:26.402]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:26.402]  - seeds: <none>
[16:11:26.403] getGlobalsAndPackages() ...
[16:11:26.403] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:26.403] Resolving globals: FALSE
[16:11:26.403] Tweak future expression to call with '...' arguments ...
[16:11:26.403] {
[16:11:26.403]     do.call(function(...) {
[16:11:26.403]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:26.403]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:26.403]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:26.403]             on.exit(options(oopts), add = TRUE)
[16:11:26.403]         }
[16:11:26.403]         {
[16:11:26.403]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:26.403]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:26.403]                 ...future.FUN(...future.X_jj, ...)
[16:11:26.403]             })
[16:11:26.403]         }
[16:11:26.403]     }, args = future.call.arguments)
[16:11:26.403] }
[16:11:26.403] Tweak future expression to call with '...' arguments ... DONE
[16:11:26.403] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:26.404] 
[16:11:26.404] getGlobalsAndPackages() ... DONE
[16:11:26.404] run() for ‘Future’ ...
[16:11:26.404] - state: ‘created’
[16:11:26.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:26.419] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:26.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:26.419]   - Field: ‘node’
[16:11:26.419]   - Field: ‘label’
[16:11:26.419]   - Field: ‘local’
[16:11:26.419]   - Field: ‘owner’
[16:11:26.419]   - Field: ‘envir’
[16:11:26.420]   - Field: ‘workers’
[16:11:26.420]   - Field: ‘packages’
[16:11:26.420]   - Field: ‘gc’
[16:11:26.420]   - Field: ‘conditions’
[16:11:26.420]   - Field: ‘persistent’
[16:11:26.420]   - Field: ‘expr’
[16:11:26.420]   - Field: ‘uuid’
[16:11:26.420]   - Field: ‘seed’
[16:11:26.420]   - Field: ‘version’
[16:11:26.420]   - Field: ‘result’
[16:11:26.421]   - Field: ‘asynchronous’
[16:11:26.421]   - Field: ‘calls’
[16:11:26.421]   - Field: ‘globals’
[16:11:26.421]   - Field: ‘stdout’
[16:11:26.421]   - Field: ‘earlySignal’
[16:11:26.421]   - Field: ‘lazy’
[16:11:26.421]   - Field: ‘state’
[16:11:26.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:26.421] - Launch lazy future ...
[16:11:26.422] Packages needed by the future expression (n = 0): <none>
[16:11:26.422] Packages needed by future strategies (n = 0): <none>
[16:11:26.422] {
[16:11:26.422]     {
[16:11:26.422]         {
[16:11:26.422]             ...future.startTime <- base::Sys.time()
[16:11:26.422]             {
[16:11:26.422]                 {
[16:11:26.422]                   {
[16:11:26.422]                     {
[16:11:26.422]                       base::local({
[16:11:26.422]                         has_future <- base::requireNamespace("future", 
[16:11:26.422]                           quietly = TRUE)
[16:11:26.422]                         if (has_future) {
[16:11:26.422]                           ns <- base::getNamespace("future")
[16:11:26.422]                           version <- ns[[".package"]][["version"]]
[16:11:26.422]                           if (is.null(version)) 
[16:11:26.422]                             version <- utils::packageVersion("future")
[16:11:26.422]                         }
[16:11:26.422]                         else {
[16:11:26.422]                           version <- NULL
[16:11:26.422]                         }
[16:11:26.422]                         if (!has_future || version < "1.8.0") {
[16:11:26.422]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:26.422]                             "", base::R.version$version.string), 
[16:11:26.422]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:26.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:26.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:26.422]                               "release", "version")], collapse = " "), 
[16:11:26.422]                             hostname = base::Sys.info()[["nodename"]])
[16:11:26.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:26.422]                             info)
[16:11:26.422]                           info <- base::paste(info, collapse = "; ")
[16:11:26.422]                           if (!has_future) {
[16:11:26.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:26.422]                               info)
[16:11:26.422]                           }
[16:11:26.422]                           else {
[16:11:26.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:26.422]                               info, version)
[16:11:26.422]                           }
[16:11:26.422]                           base::stop(msg)
[16:11:26.422]                         }
[16:11:26.422]                       })
[16:11:26.422]                     }
[16:11:26.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:26.422]                     base::options(mc.cores = 1L)
[16:11:26.422]                   }
[16:11:26.422]                   options(future.plan = NULL)
[16:11:26.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:26.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:26.422]                 }
[16:11:26.422]                 ...future.workdir <- getwd()
[16:11:26.422]             }
[16:11:26.422]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:26.422]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:26.422]         }
[16:11:26.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:26.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:26.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:26.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:26.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:26.422]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:26.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:26.422]             base::names(...future.oldOptions))
[16:11:26.422]     }
[16:11:26.422]     if (FALSE) {
[16:11:26.422]     }
[16:11:26.422]     else {
[16:11:26.422]         if (TRUE) {
[16:11:26.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:26.422]                 open = "w")
[16:11:26.422]         }
[16:11:26.422]         else {
[16:11:26.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:26.422]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:26.422]         }
[16:11:26.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:26.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:26.422]             base::sink(type = "output", split = FALSE)
[16:11:26.422]             base::close(...future.stdout)
[16:11:26.422]         }, add = TRUE)
[16:11:26.422]     }
[16:11:26.422]     ...future.frame <- base::sys.nframe()
[16:11:26.422]     ...future.conditions <- base::list()
[16:11:26.422]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:26.422]     if (FALSE) {
[16:11:26.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:26.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:26.422]     }
[16:11:26.422]     ...future.result <- base::tryCatch({
[16:11:26.422]         base::withCallingHandlers({
[16:11:26.422]             ...future.value <- base::withVisible(base::local({
[16:11:26.422]                 ...future.makeSendCondition <- local({
[16:11:26.422]                   sendCondition <- NULL
[16:11:26.422]                   function(frame = 1L) {
[16:11:26.422]                     if (is.function(sendCondition)) 
[16:11:26.422]                       return(sendCondition)
[16:11:26.422]                     ns <- getNamespace("parallel")
[16:11:26.422]                     if (exists("sendData", mode = "function", 
[16:11:26.422]                       envir = ns)) {
[16:11:26.422]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:26.422]                         envir = ns)
[16:11:26.422]                       envir <- sys.frame(frame)
[16:11:26.422]                       master <- NULL
[16:11:26.422]                       while (!identical(envir, .GlobalEnv) && 
[16:11:26.422]                         !identical(envir, emptyenv())) {
[16:11:26.422]                         if (exists("master", mode = "list", envir = envir, 
[16:11:26.422]                           inherits = FALSE)) {
[16:11:26.422]                           master <- get("master", mode = "list", 
[16:11:26.422]                             envir = envir, inherits = FALSE)
[16:11:26.422]                           if (inherits(master, c("SOCKnode", 
[16:11:26.422]                             "SOCK0node"))) {
[16:11:26.422]                             sendCondition <<- function(cond) {
[16:11:26.422]                               data <- list(type = "VALUE", value = cond, 
[16:11:26.422]                                 success = TRUE)
[16:11:26.422]                               parallel_sendData(master, data)
[16:11:26.422]                             }
[16:11:26.422]                             return(sendCondition)
[16:11:26.422]                           }
[16:11:26.422]                         }
[16:11:26.422]                         frame <- frame + 1L
[16:11:26.422]                         envir <- sys.frame(frame)
[16:11:26.422]                       }
[16:11:26.422]                     }
[16:11:26.422]                     sendCondition <<- function(cond) NULL
[16:11:26.422]                   }
[16:11:26.422]                 })
[16:11:26.422]                 withCallingHandlers({
[16:11:26.422]                   {
[16:11:26.422]                     do.call(function(...) {
[16:11:26.422]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:26.422]                       if (!identical(...future.globals.maxSize.org, 
[16:11:26.422]                         ...future.globals.maxSize)) {
[16:11:26.422]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:26.422]                         on.exit(options(oopts), add = TRUE)
[16:11:26.422]                       }
[16:11:26.422]                       {
[16:11:26.422]                         lapply(seq_along(...future.elements_ii), 
[16:11:26.422]                           FUN = function(jj) {
[16:11:26.422]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:26.422]                             ...future.FUN(...future.X_jj, ...)
[16:11:26.422]                           })
[16:11:26.422]                       }
[16:11:26.422]                     }, args = future.call.arguments)
[16:11:26.422]                   }
[16:11:26.422]                 }, immediateCondition = function(cond) {
[16:11:26.422]                   sendCondition <- ...future.makeSendCondition()
[16:11:26.422]                   sendCondition(cond)
[16:11:26.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:26.422]                   {
[16:11:26.422]                     inherits <- base::inherits
[16:11:26.422]                     invokeRestart <- base::invokeRestart
[16:11:26.422]                     is.null <- base::is.null
[16:11:26.422]                     muffled <- FALSE
[16:11:26.422]                     if (inherits(cond, "message")) {
[16:11:26.422]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:26.422]                       if (muffled) 
[16:11:26.422]                         invokeRestart("muffleMessage")
[16:11:26.422]                     }
[16:11:26.422]                     else if (inherits(cond, "warning")) {
[16:11:26.422]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:26.422]                       if (muffled) 
[16:11:26.422]                         invokeRestart("muffleWarning")
[16:11:26.422]                     }
[16:11:26.422]                     else if (inherits(cond, "condition")) {
[16:11:26.422]                       if (!is.null(pattern)) {
[16:11:26.422]                         computeRestarts <- base::computeRestarts
[16:11:26.422]                         grepl <- base::grepl
[16:11:26.422]                         restarts <- computeRestarts(cond)
[16:11:26.422]                         for (restart in restarts) {
[16:11:26.422]                           name <- restart$name
[16:11:26.422]                           if (is.null(name)) 
[16:11:26.422]                             next
[16:11:26.422]                           if (!grepl(pattern, name)) 
[16:11:26.422]                             next
[16:11:26.422]                           invokeRestart(restart)
[16:11:26.422]                           muffled <- TRUE
[16:11:26.422]                           break
[16:11:26.422]                         }
[16:11:26.422]                       }
[16:11:26.422]                     }
[16:11:26.422]                     invisible(muffled)
[16:11:26.422]                   }
[16:11:26.422]                   muffleCondition(cond)
[16:11:26.422]                 })
[16:11:26.422]             }))
[16:11:26.422]             future::FutureResult(value = ...future.value$value, 
[16:11:26.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:26.422]                   ...future.rng), globalenv = if (FALSE) 
[16:11:26.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:26.422]                     ...future.globalenv.names))
[16:11:26.422]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:26.422]         }, condition = base::local({
[16:11:26.422]             c <- base::c
[16:11:26.422]             inherits <- base::inherits
[16:11:26.422]             invokeRestart <- base::invokeRestart
[16:11:26.422]             length <- base::length
[16:11:26.422]             list <- base::list
[16:11:26.422]             seq.int <- base::seq.int
[16:11:26.422]             signalCondition <- base::signalCondition
[16:11:26.422]             sys.calls <- base::sys.calls
[16:11:26.422]             `[[` <- base::`[[`
[16:11:26.422]             `+` <- base::`+`
[16:11:26.422]             `<<-` <- base::`<<-`
[16:11:26.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:26.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:26.422]                   3L)]
[16:11:26.422]             }
[16:11:26.422]             function(cond) {
[16:11:26.422]                 is_error <- inherits(cond, "error")
[16:11:26.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:26.422]                   NULL)
[16:11:26.422]                 if (is_error) {
[16:11:26.422]                   sessionInformation <- function() {
[16:11:26.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:26.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:26.422]                       search = base::search(), system = base::Sys.info())
[16:11:26.422]                   }
[16:11:26.422]                   ...future.conditions[[length(...future.conditions) + 
[16:11:26.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:26.422]                     cond$call), session = sessionInformation(), 
[16:11:26.422]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:26.422]                   signalCondition(cond)
[16:11:26.422]                 }
[16:11:26.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:26.422]                 "immediateCondition"))) {
[16:11:26.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:26.422]                   ...future.conditions[[length(...future.conditions) + 
[16:11:26.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:26.422]                   if (TRUE && !signal) {
[16:11:26.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:26.422]                     {
[16:11:26.422]                       inherits <- base::inherits
[16:11:26.422]                       invokeRestart <- base::invokeRestart
[16:11:26.422]                       is.null <- base::is.null
[16:11:26.422]                       muffled <- FALSE
[16:11:26.422]                       if (inherits(cond, "message")) {
[16:11:26.422]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:26.422]                         if (muffled) 
[16:11:26.422]                           invokeRestart("muffleMessage")
[16:11:26.422]                       }
[16:11:26.422]                       else if (inherits(cond, "warning")) {
[16:11:26.422]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:26.422]                         if (muffled) 
[16:11:26.422]                           invokeRestart("muffleWarning")
[16:11:26.422]                       }
[16:11:26.422]                       else if (inherits(cond, "condition")) {
[16:11:26.422]                         if (!is.null(pattern)) {
[16:11:26.422]                           computeRestarts <- base::computeRestarts
[16:11:26.422]                           grepl <- base::grepl
[16:11:26.422]                           restarts <- computeRestarts(cond)
[16:11:26.422]                           for (restart in restarts) {
[16:11:26.422]                             name <- restart$name
[16:11:26.422]                             if (is.null(name)) 
[16:11:26.422]                               next
[16:11:26.422]                             if (!grepl(pattern, name)) 
[16:11:26.422]                               next
[16:11:26.422]                             invokeRestart(restart)
[16:11:26.422]                             muffled <- TRUE
[16:11:26.422]                             break
[16:11:26.422]                           }
[16:11:26.422]                         }
[16:11:26.422]                       }
[16:11:26.422]                       invisible(muffled)
[16:11:26.422]                     }
[16:11:26.422]                     muffleCondition(cond, pattern = "^muffle")
[16:11:26.422]                   }
[16:11:26.422]                 }
[16:11:26.422]                 else {
[16:11:26.422]                   if (TRUE) {
[16:11:26.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:26.422]                     {
[16:11:26.422]                       inherits <- base::inherits
[16:11:26.422]                       invokeRestart <- base::invokeRestart
[16:11:26.422]                       is.null <- base::is.null
[16:11:26.422]                       muffled <- FALSE
[16:11:26.422]                       if (inherits(cond, "message")) {
[16:11:26.422]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:26.422]                         if (muffled) 
[16:11:26.422]                           invokeRestart("muffleMessage")
[16:11:26.422]                       }
[16:11:26.422]                       else if (inherits(cond, "warning")) {
[16:11:26.422]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:26.422]                         if (muffled) 
[16:11:26.422]                           invokeRestart("muffleWarning")
[16:11:26.422]                       }
[16:11:26.422]                       else if (inherits(cond, "condition")) {
[16:11:26.422]                         if (!is.null(pattern)) {
[16:11:26.422]                           computeRestarts <- base::computeRestarts
[16:11:26.422]                           grepl <- base::grepl
[16:11:26.422]                           restarts <- computeRestarts(cond)
[16:11:26.422]                           for (restart in restarts) {
[16:11:26.422]                             name <- restart$name
[16:11:26.422]                             if (is.null(name)) 
[16:11:26.422]                               next
[16:11:26.422]                             if (!grepl(pattern, name)) 
[16:11:26.422]                               next
[16:11:26.422]                             invokeRestart(restart)
[16:11:26.422]                             muffled <- TRUE
[16:11:26.422]                             break
[16:11:26.422]                           }
[16:11:26.422]                         }
[16:11:26.422]                       }
[16:11:26.422]                       invisible(muffled)
[16:11:26.422]                     }
[16:11:26.422]                     muffleCondition(cond, pattern = "^muffle")
[16:11:26.422]                   }
[16:11:26.422]                 }
[16:11:26.422]             }
[16:11:26.422]         }))
[16:11:26.422]     }, error = function(ex) {
[16:11:26.422]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:26.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:26.422]                 ...future.rng), started = ...future.startTime, 
[16:11:26.422]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:26.422]             version = "1.8"), class = "FutureResult")
[16:11:26.422]     }, finally = {
[16:11:26.422]         if (!identical(...future.workdir, getwd())) 
[16:11:26.422]             setwd(...future.workdir)
[16:11:26.422]         {
[16:11:26.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:26.422]                 ...future.oldOptions$nwarnings <- NULL
[16:11:26.422]             }
[16:11:26.422]             base::options(...future.oldOptions)
[16:11:26.422]             if (.Platform$OS.type == "windows") {
[16:11:26.422]                 old_names <- names(...future.oldEnvVars)
[16:11:26.422]                 envs <- base::Sys.getenv()
[16:11:26.422]                 names <- names(envs)
[16:11:26.422]                 common <- intersect(names, old_names)
[16:11:26.422]                 added <- setdiff(names, old_names)
[16:11:26.422]                 removed <- setdiff(old_names, names)
[16:11:26.422]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:26.422]                   envs[common]]
[16:11:26.422]                 NAMES <- toupper(changed)
[16:11:26.422]                 args <- list()
[16:11:26.422]                 for (kk in seq_along(NAMES)) {
[16:11:26.422]                   name <- changed[[kk]]
[16:11:26.422]                   NAME <- NAMES[[kk]]
[16:11:26.422]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:26.422]                     next
[16:11:26.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:26.422]                 }
[16:11:26.422]                 NAMES <- toupper(added)
[16:11:26.422]                 for (kk in seq_along(NAMES)) {
[16:11:26.422]                   name <- added[[kk]]
[16:11:26.422]                   NAME <- NAMES[[kk]]
[16:11:26.422]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:26.422]                     next
[16:11:26.422]                   args[[name]] <- ""
[16:11:26.422]                 }
[16:11:26.422]                 NAMES <- toupper(removed)
[16:11:26.422]                 for (kk in seq_along(NAMES)) {
[16:11:26.422]                   name <- removed[[kk]]
[16:11:26.422]                   NAME <- NAMES[[kk]]
[16:11:26.422]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:26.422]                     next
[16:11:26.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:26.422]                 }
[16:11:26.422]                 if (length(args) > 0) 
[16:11:26.422]                   base::do.call(base::Sys.setenv, args = args)
[16:11:26.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:26.422]             }
[16:11:26.422]             else {
[16:11:26.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:26.422]             }
[16:11:26.422]             {
[16:11:26.422]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:26.422]                   0L) {
[16:11:26.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:26.422]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:26.422]                   base::options(opts)
[16:11:26.422]                 }
[16:11:26.422]                 {
[16:11:26.422]                   {
[16:11:26.422]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:26.422]                     NULL
[16:11:26.422]                   }
[16:11:26.422]                   options(future.plan = NULL)
[16:11:26.422]                   if (is.na(NA_character_)) 
[16:11:26.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:26.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:26.422]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:26.422]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:26.422]                     envir = parent.frame()) 
[16:11:26.422]                   {
[16:11:26.422]                     if (is.function(workers)) 
[16:11:26.422]                       workers <- workers()
[16:11:26.422]                     workers <- structure(as.integer(workers), 
[16:11:26.422]                       class = class(workers))
[16:11:26.422]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:26.422]                       workers >= 1)
[16:11:26.422]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:26.422]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:26.422]                     }
[16:11:26.422]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:26.422]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:26.422]                       envir = envir)
[16:11:26.422]                     if (!future$lazy) 
[16:11:26.422]                       future <- run(future)
[16:11:26.422]                     invisible(future)
[16:11:26.422]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:26.422]                 }
[16:11:26.422]             }
[16:11:26.422]         }
[16:11:26.422]     })
[16:11:26.422]     if (TRUE) {
[16:11:26.422]         base::sink(type = "output", split = FALSE)
[16:11:26.422]         if (TRUE) {
[16:11:26.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:26.422]         }
[16:11:26.422]         else {
[16:11:26.422]             ...future.result["stdout"] <- base::list(NULL)
[16:11:26.422]         }
[16:11:26.422]         base::close(...future.stdout)
[16:11:26.422]         ...future.stdout <- NULL
[16:11:26.422]     }
[16:11:26.422]     ...future.result$conditions <- ...future.conditions
[16:11:26.422]     ...future.result$finished <- base::Sys.time()
[16:11:26.422]     ...future.result
[16:11:26.422] }
[16:11:26.425] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:11:26.425] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:11:26.425] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:11:26.426] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:26.426] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:26.426] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:11:26.427] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:11:26.427] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:26.427] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:26.427] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:26.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:26.428] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:11:26.428] MultisessionFuture started
[16:11:26.428] - Launch lazy future ... done
[16:11:26.429] run() for ‘MultisessionFuture’ ... done
[16:11:26.429] Created future:
[16:11:26.429] MultisessionFuture:
[16:11:26.429] Label: ‘future_lapply-1’
[16:11:26.429] Expression:
[16:11:26.429] {
[16:11:26.429]     do.call(function(...) {
[16:11:26.429]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:26.429]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:26.429]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:26.429]             on.exit(options(oopts), add = TRUE)
[16:11:26.429]         }
[16:11:26.429]         {
[16:11:26.429]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:26.429]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:26.429]                 ...future.FUN(...future.X_jj, ...)
[16:11:26.429]             })
[16:11:26.429]         }
[16:11:26.429]     }, args = future.call.arguments)
[16:11:26.429] }
[16:11:26.429] Lazy evaluation: FALSE
[16:11:26.429] Asynchronous evaluation: TRUE
[16:11:26.429] Local evaluation: TRUE
[16:11:26.429] Environment: R_GlobalEnv
[16:11:26.429] Capture standard output: TRUE
[16:11:26.429] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:26.429] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:26.429] Packages: <none>
[16:11:26.429] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:26.429] Resolved: FALSE
[16:11:26.429] Value: <not collected>
[16:11:26.429] Conditions captured: <none>
[16:11:26.429] Early signaling: FALSE
[16:11:26.429] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:26.429] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:26.440] Chunk #1 of 2 ... DONE
[16:11:26.440] Chunk #2 of 2 ...
[16:11:26.441]  - Finding globals in 'X' for chunk #2 ...
[16:11:26.441] getGlobalsAndPackages() ...
[16:11:26.441] Searching for globals...
[16:11:26.441] 
[16:11:26.441] Searching for globals ... DONE
[16:11:26.441] - globals: [0] <none>
[16:11:26.441] getGlobalsAndPackages() ... DONE
[16:11:26.441]    + additional globals found: [n=0] 
[16:11:26.441]    + additional namespaces needed: [n=0] 
[16:11:26.442]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:26.442]  - seeds: <none>
[16:11:26.442] getGlobalsAndPackages() ...
[16:11:26.442] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:26.442] Resolving globals: FALSE
[16:11:26.442] Tweak future expression to call with '...' arguments ...
[16:11:26.442] {
[16:11:26.442]     do.call(function(...) {
[16:11:26.442]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:26.442]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:26.442]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:26.442]             on.exit(options(oopts), add = TRUE)
[16:11:26.442]         }
[16:11:26.442]         {
[16:11:26.442]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:26.442]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:26.442]                 ...future.FUN(...future.X_jj, ...)
[16:11:26.442]             })
[16:11:26.442]         }
[16:11:26.442]     }, args = future.call.arguments)
[16:11:26.442] }
[16:11:26.442] Tweak future expression to call with '...' arguments ... DONE
[16:11:26.443] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:26.443] 
[16:11:26.443] getGlobalsAndPackages() ... DONE
[16:11:26.443] run() for ‘Future’ ...
[16:11:26.443] - state: ‘created’
[16:11:26.443] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:26.458] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:26.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:26.458]   - Field: ‘node’
[16:11:26.458]   - Field: ‘label’
[16:11:26.458]   - Field: ‘local’
[16:11:26.458]   - Field: ‘owner’
[16:11:26.459]   - Field: ‘envir’
[16:11:26.459]   - Field: ‘workers’
[16:11:26.459]   - Field: ‘packages’
[16:11:26.459]   - Field: ‘gc’
[16:11:26.459]   - Field: ‘conditions’
[16:11:26.459]   - Field: ‘persistent’
[16:11:26.459]   - Field: ‘expr’
[16:11:26.459]   - Field: ‘uuid’
[16:11:26.459]   - Field: ‘seed’
[16:11:26.459]   - Field: ‘version’
[16:11:26.459]   - Field: ‘result’
[16:11:26.460]   - Field: ‘asynchronous’
[16:11:26.460]   - Field: ‘calls’
[16:11:26.460]   - Field: ‘globals’
[16:11:26.460]   - Field: ‘stdout’
[16:11:26.460]   - Field: ‘earlySignal’
[16:11:26.460]   - Field: ‘lazy’
[16:11:26.460]   - Field: ‘state’
[16:11:26.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:26.460] - Launch lazy future ...
[16:11:26.461] Packages needed by the future expression (n = 0): <none>
[16:11:26.461] Packages needed by future strategies (n = 0): <none>
[16:11:26.461] {
[16:11:26.461]     {
[16:11:26.461]         {
[16:11:26.461]             ...future.startTime <- base::Sys.time()
[16:11:26.461]             {
[16:11:26.461]                 {
[16:11:26.461]                   {
[16:11:26.461]                     {
[16:11:26.461]                       base::local({
[16:11:26.461]                         has_future <- base::requireNamespace("future", 
[16:11:26.461]                           quietly = TRUE)
[16:11:26.461]                         if (has_future) {
[16:11:26.461]                           ns <- base::getNamespace("future")
[16:11:26.461]                           version <- ns[[".package"]][["version"]]
[16:11:26.461]                           if (is.null(version)) 
[16:11:26.461]                             version <- utils::packageVersion("future")
[16:11:26.461]                         }
[16:11:26.461]                         else {
[16:11:26.461]                           version <- NULL
[16:11:26.461]                         }
[16:11:26.461]                         if (!has_future || version < "1.8.0") {
[16:11:26.461]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:26.461]                             "", base::R.version$version.string), 
[16:11:26.461]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:26.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:26.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:26.461]                               "release", "version")], collapse = " "), 
[16:11:26.461]                             hostname = base::Sys.info()[["nodename"]])
[16:11:26.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:26.461]                             info)
[16:11:26.461]                           info <- base::paste(info, collapse = "; ")
[16:11:26.461]                           if (!has_future) {
[16:11:26.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:26.461]                               info)
[16:11:26.461]                           }
[16:11:26.461]                           else {
[16:11:26.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:26.461]                               info, version)
[16:11:26.461]                           }
[16:11:26.461]                           base::stop(msg)
[16:11:26.461]                         }
[16:11:26.461]                       })
[16:11:26.461]                     }
[16:11:26.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:26.461]                     base::options(mc.cores = 1L)
[16:11:26.461]                   }
[16:11:26.461]                   options(future.plan = NULL)
[16:11:26.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:26.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:26.461]                 }
[16:11:26.461]                 ...future.workdir <- getwd()
[16:11:26.461]             }
[16:11:26.461]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:26.461]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:26.461]         }
[16:11:26.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:26.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:26.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:26.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:26.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:26.461]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:26.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:26.461]             base::names(...future.oldOptions))
[16:11:26.461]     }
[16:11:26.461]     if (FALSE) {
[16:11:26.461]     }
[16:11:26.461]     else {
[16:11:26.461]         if (TRUE) {
[16:11:26.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:26.461]                 open = "w")
[16:11:26.461]         }
[16:11:26.461]         else {
[16:11:26.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:26.461]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:26.461]         }
[16:11:26.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:26.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:26.461]             base::sink(type = "output", split = FALSE)
[16:11:26.461]             base::close(...future.stdout)
[16:11:26.461]         }, add = TRUE)
[16:11:26.461]     }
[16:11:26.461]     ...future.frame <- base::sys.nframe()
[16:11:26.461]     ...future.conditions <- base::list()
[16:11:26.461]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:26.461]     if (FALSE) {
[16:11:26.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:26.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:26.461]     }
[16:11:26.461]     ...future.result <- base::tryCatch({
[16:11:26.461]         base::withCallingHandlers({
[16:11:26.461]             ...future.value <- base::withVisible(base::local({
[16:11:26.461]                 ...future.makeSendCondition <- local({
[16:11:26.461]                   sendCondition <- NULL
[16:11:26.461]                   function(frame = 1L) {
[16:11:26.461]                     if (is.function(sendCondition)) 
[16:11:26.461]                       return(sendCondition)
[16:11:26.461]                     ns <- getNamespace("parallel")
[16:11:26.461]                     if (exists("sendData", mode = "function", 
[16:11:26.461]                       envir = ns)) {
[16:11:26.461]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:26.461]                         envir = ns)
[16:11:26.461]                       envir <- sys.frame(frame)
[16:11:26.461]                       master <- NULL
[16:11:26.461]                       while (!identical(envir, .GlobalEnv) && 
[16:11:26.461]                         !identical(envir, emptyenv())) {
[16:11:26.461]                         if (exists("master", mode = "list", envir = envir, 
[16:11:26.461]                           inherits = FALSE)) {
[16:11:26.461]                           master <- get("master", mode = "list", 
[16:11:26.461]                             envir = envir, inherits = FALSE)
[16:11:26.461]                           if (inherits(master, c("SOCKnode", 
[16:11:26.461]                             "SOCK0node"))) {
[16:11:26.461]                             sendCondition <<- function(cond) {
[16:11:26.461]                               data <- list(type = "VALUE", value = cond, 
[16:11:26.461]                                 success = TRUE)
[16:11:26.461]                               parallel_sendData(master, data)
[16:11:26.461]                             }
[16:11:26.461]                             return(sendCondition)
[16:11:26.461]                           }
[16:11:26.461]                         }
[16:11:26.461]                         frame <- frame + 1L
[16:11:26.461]                         envir <- sys.frame(frame)
[16:11:26.461]                       }
[16:11:26.461]                     }
[16:11:26.461]                     sendCondition <<- function(cond) NULL
[16:11:26.461]                   }
[16:11:26.461]                 })
[16:11:26.461]                 withCallingHandlers({
[16:11:26.461]                   {
[16:11:26.461]                     do.call(function(...) {
[16:11:26.461]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:26.461]                       if (!identical(...future.globals.maxSize.org, 
[16:11:26.461]                         ...future.globals.maxSize)) {
[16:11:26.461]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:26.461]                         on.exit(options(oopts), add = TRUE)
[16:11:26.461]                       }
[16:11:26.461]                       {
[16:11:26.461]                         lapply(seq_along(...future.elements_ii), 
[16:11:26.461]                           FUN = function(jj) {
[16:11:26.461]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:26.461]                             ...future.FUN(...future.X_jj, ...)
[16:11:26.461]                           })
[16:11:26.461]                       }
[16:11:26.461]                     }, args = future.call.arguments)
[16:11:26.461]                   }
[16:11:26.461]                 }, immediateCondition = function(cond) {
[16:11:26.461]                   sendCondition <- ...future.makeSendCondition()
[16:11:26.461]                   sendCondition(cond)
[16:11:26.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:26.461]                   {
[16:11:26.461]                     inherits <- base::inherits
[16:11:26.461]                     invokeRestart <- base::invokeRestart
[16:11:26.461]                     is.null <- base::is.null
[16:11:26.461]                     muffled <- FALSE
[16:11:26.461]                     if (inherits(cond, "message")) {
[16:11:26.461]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:26.461]                       if (muffled) 
[16:11:26.461]                         invokeRestart("muffleMessage")
[16:11:26.461]                     }
[16:11:26.461]                     else if (inherits(cond, "warning")) {
[16:11:26.461]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:26.461]                       if (muffled) 
[16:11:26.461]                         invokeRestart("muffleWarning")
[16:11:26.461]                     }
[16:11:26.461]                     else if (inherits(cond, "condition")) {
[16:11:26.461]                       if (!is.null(pattern)) {
[16:11:26.461]                         computeRestarts <- base::computeRestarts
[16:11:26.461]                         grepl <- base::grepl
[16:11:26.461]                         restarts <- computeRestarts(cond)
[16:11:26.461]                         for (restart in restarts) {
[16:11:26.461]                           name <- restart$name
[16:11:26.461]                           if (is.null(name)) 
[16:11:26.461]                             next
[16:11:26.461]                           if (!grepl(pattern, name)) 
[16:11:26.461]                             next
[16:11:26.461]                           invokeRestart(restart)
[16:11:26.461]                           muffled <- TRUE
[16:11:26.461]                           break
[16:11:26.461]                         }
[16:11:26.461]                       }
[16:11:26.461]                     }
[16:11:26.461]                     invisible(muffled)
[16:11:26.461]                   }
[16:11:26.461]                   muffleCondition(cond)
[16:11:26.461]                 })
[16:11:26.461]             }))
[16:11:26.461]             future::FutureResult(value = ...future.value$value, 
[16:11:26.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:26.461]                   ...future.rng), globalenv = if (FALSE) 
[16:11:26.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:26.461]                     ...future.globalenv.names))
[16:11:26.461]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:26.461]         }, condition = base::local({
[16:11:26.461]             c <- base::c
[16:11:26.461]             inherits <- base::inherits
[16:11:26.461]             invokeRestart <- base::invokeRestart
[16:11:26.461]             length <- base::length
[16:11:26.461]             list <- base::list
[16:11:26.461]             seq.int <- base::seq.int
[16:11:26.461]             signalCondition <- base::signalCondition
[16:11:26.461]             sys.calls <- base::sys.calls
[16:11:26.461]             `[[` <- base::`[[`
[16:11:26.461]             `+` <- base::`+`
[16:11:26.461]             `<<-` <- base::`<<-`
[16:11:26.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:26.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:26.461]                   3L)]
[16:11:26.461]             }
[16:11:26.461]             function(cond) {
[16:11:26.461]                 is_error <- inherits(cond, "error")
[16:11:26.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:26.461]                   NULL)
[16:11:26.461]                 if (is_error) {
[16:11:26.461]                   sessionInformation <- function() {
[16:11:26.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:26.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:26.461]                       search = base::search(), system = base::Sys.info())
[16:11:26.461]                   }
[16:11:26.461]                   ...future.conditions[[length(...future.conditions) + 
[16:11:26.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:26.461]                     cond$call), session = sessionInformation(), 
[16:11:26.461]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:26.461]                   signalCondition(cond)
[16:11:26.461]                 }
[16:11:26.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:26.461]                 "immediateCondition"))) {
[16:11:26.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:26.461]                   ...future.conditions[[length(...future.conditions) + 
[16:11:26.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:26.461]                   if (TRUE && !signal) {
[16:11:26.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:26.461]                     {
[16:11:26.461]                       inherits <- base::inherits
[16:11:26.461]                       invokeRestart <- base::invokeRestart
[16:11:26.461]                       is.null <- base::is.null
[16:11:26.461]                       muffled <- FALSE
[16:11:26.461]                       if (inherits(cond, "message")) {
[16:11:26.461]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:26.461]                         if (muffled) 
[16:11:26.461]                           invokeRestart("muffleMessage")
[16:11:26.461]                       }
[16:11:26.461]                       else if (inherits(cond, "warning")) {
[16:11:26.461]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:26.461]                         if (muffled) 
[16:11:26.461]                           invokeRestart("muffleWarning")
[16:11:26.461]                       }
[16:11:26.461]                       else if (inherits(cond, "condition")) {
[16:11:26.461]                         if (!is.null(pattern)) {
[16:11:26.461]                           computeRestarts <- base::computeRestarts
[16:11:26.461]                           grepl <- base::grepl
[16:11:26.461]                           restarts <- computeRestarts(cond)
[16:11:26.461]                           for (restart in restarts) {
[16:11:26.461]                             name <- restart$name
[16:11:26.461]                             if (is.null(name)) 
[16:11:26.461]                               next
[16:11:26.461]                             if (!grepl(pattern, name)) 
[16:11:26.461]                               next
[16:11:26.461]                             invokeRestart(restart)
[16:11:26.461]                             muffled <- TRUE
[16:11:26.461]                             break
[16:11:26.461]                           }
[16:11:26.461]                         }
[16:11:26.461]                       }
[16:11:26.461]                       invisible(muffled)
[16:11:26.461]                     }
[16:11:26.461]                     muffleCondition(cond, pattern = "^muffle")
[16:11:26.461]                   }
[16:11:26.461]                 }
[16:11:26.461]                 else {
[16:11:26.461]                   if (TRUE) {
[16:11:26.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:26.461]                     {
[16:11:26.461]                       inherits <- base::inherits
[16:11:26.461]                       invokeRestart <- base::invokeRestart
[16:11:26.461]                       is.null <- base::is.null
[16:11:26.461]                       muffled <- FALSE
[16:11:26.461]                       if (inherits(cond, "message")) {
[16:11:26.461]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:26.461]                         if (muffled) 
[16:11:26.461]                           invokeRestart("muffleMessage")
[16:11:26.461]                       }
[16:11:26.461]                       else if (inherits(cond, "warning")) {
[16:11:26.461]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:26.461]                         if (muffled) 
[16:11:26.461]                           invokeRestart("muffleWarning")
[16:11:26.461]                       }
[16:11:26.461]                       else if (inherits(cond, "condition")) {
[16:11:26.461]                         if (!is.null(pattern)) {
[16:11:26.461]                           computeRestarts <- base::computeRestarts
[16:11:26.461]                           grepl <- base::grepl
[16:11:26.461]                           restarts <- computeRestarts(cond)
[16:11:26.461]                           for (restart in restarts) {
[16:11:26.461]                             name <- restart$name
[16:11:26.461]                             if (is.null(name)) 
[16:11:26.461]                               next
[16:11:26.461]                             if (!grepl(pattern, name)) 
[16:11:26.461]                               next
[16:11:26.461]                             invokeRestart(restart)
[16:11:26.461]                             muffled <- TRUE
[16:11:26.461]                             break
[16:11:26.461]                           }
[16:11:26.461]                         }
[16:11:26.461]                       }
[16:11:26.461]                       invisible(muffled)
[16:11:26.461]                     }
[16:11:26.461]                     muffleCondition(cond, pattern = "^muffle")
[16:11:26.461]                   }
[16:11:26.461]                 }
[16:11:26.461]             }
[16:11:26.461]         }))
[16:11:26.461]     }, error = function(ex) {
[16:11:26.461]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:26.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:26.461]                 ...future.rng), started = ...future.startTime, 
[16:11:26.461]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:26.461]             version = "1.8"), class = "FutureResult")
[16:11:26.461]     }, finally = {
[16:11:26.461]         if (!identical(...future.workdir, getwd())) 
[16:11:26.461]             setwd(...future.workdir)
[16:11:26.461]         {
[16:11:26.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:26.461]                 ...future.oldOptions$nwarnings <- NULL
[16:11:26.461]             }
[16:11:26.461]             base::options(...future.oldOptions)
[16:11:26.461]             if (.Platform$OS.type == "windows") {
[16:11:26.461]                 old_names <- names(...future.oldEnvVars)
[16:11:26.461]                 envs <- base::Sys.getenv()
[16:11:26.461]                 names <- names(envs)
[16:11:26.461]                 common <- intersect(names, old_names)
[16:11:26.461]                 added <- setdiff(names, old_names)
[16:11:26.461]                 removed <- setdiff(old_names, names)
[16:11:26.461]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:26.461]                   envs[common]]
[16:11:26.461]                 NAMES <- toupper(changed)
[16:11:26.461]                 args <- list()
[16:11:26.461]                 for (kk in seq_along(NAMES)) {
[16:11:26.461]                   name <- changed[[kk]]
[16:11:26.461]                   NAME <- NAMES[[kk]]
[16:11:26.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:26.461]                     next
[16:11:26.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:26.461]                 }
[16:11:26.461]                 NAMES <- toupper(added)
[16:11:26.461]                 for (kk in seq_along(NAMES)) {
[16:11:26.461]                   name <- added[[kk]]
[16:11:26.461]                   NAME <- NAMES[[kk]]
[16:11:26.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:26.461]                     next
[16:11:26.461]                   args[[name]] <- ""
[16:11:26.461]                 }
[16:11:26.461]                 NAMES <- toupper(removed)
[16:11:26.461]                 for (kk in seq_along(NAMES)) {
[16:11:26.461]                   name <- removed[[kk]]
[16:11:26.461]                   NAME <- NAMES[[kk]]
[16:11:26.461]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:26.461]                     next
[16:11:26.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:26.461]                 }
[16:11:26.461]                 if (length(args) > 0) 
[16:11:26.461]                   base::do.call(base::Sys.setenv, args = args)
[16:11:26.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:26.461]             }
[16:11:26.461]             else {
[16:11:26.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:26.461]             }
[16:11:26.461]             {
[16:11:26.461]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:26.461]                   0L) {
[16:11:26.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:26.461]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:26.461]                   base::options(opts)
[16:11:26.461]                 }
[16:11:26.461]                 {
[16:11:26.461]                   {
[16:11:26.461]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:26.461]                     NULL
[16:11:26.461]                   }
[16:11:26.461]                   options(future.plan = NULL)
[16:11:26.461]                   if (is.na(NA_character_)) 
[16:11:26.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:26.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:26.461]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:26.461]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:26.461]                     envir = parent.frame()) 
[16:11:26.461]                   {
[16:11:26.461]                     if (is.function(workers)) 
[16:11:26.461]                       workers <- workers()
[16:11:26.461]                     workers <- structure(as.integer(workers), 
[16:11:26.461]                       class = class(workers))
[16:11:26.461]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:26.461]                       workers >= 1)
[16:11:26.461]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:26.461]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:26.461]                     }
[16:11:26.461]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:26.461]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:26.461]                       envir = envir)
[16:11:26.461]                     if (!future$lazy) 
[16:11:26.461]                       future <- run(future)
[16:11:26.461]                     invisible(future)
[16:11:26.461]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:26.461]                 }
[16:11:26.461]             }
[16:11:26.461]         }
[16:11:26.461]     })
[16:11:26.461]     if (TRUE) {
[16:11:26.461]         base::sink(type = "output", split = FALSE)
[16:11:26.461]         if (TRUE) {
[16:11:26.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:26.461]         }
[16:11:26.461]         else {
[16:11:26.461]             ...future.result["stdout"] <- base::list(NULL)
[16:11:26.461]         }
[16:11:26.461]         base::close(...future.stdout)
[16:11:26.461]         ...future.stdout <- NULL
[16:11:26.461]     }
[16:11:26.461]     ...future.result$conditions <- ...future.conditions
[16:11:26.461]     ...future.result$finished <- base::Sys.time()
[16:11:26.461]     ...future.result
[16:11:26.461] }
[16:11:26.464] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:11:26.464] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:11:26.465] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:11:26.465] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:26.465] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:26.465] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:11:26.466] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:11:26.466] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:26.466] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:26.466] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:26.466] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:26.466] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:11:26.467] MultisessionFuture started
[16:11:26.467] - Launch lazy future ... done
[16:11:26.467] run() for ‘MultisessionFuture’ ... done
[16:11:26.467] Created future:
[16:11:26.467] MultisessionFuture:
[16:11:26.467] Label: ‘future_lapply-2’
[16:11:26.467] Expression:
[16:11:26.467] {
[16:11:26.467]     do.call(function(...) {
[16:11:26.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:26.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:26.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:26.467]             on.exit(options(oopts), add = TRUE)
[16:11:26.467]         }
[16:11:26.467]         {
[16:11:26.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:26.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:26.467]                 ...future.FUN(...future.X_jj, ...)
[16:11:26.467]             })
[16:11:26.467]         }
[16:11:26.467]     }, args = future.call.arguments)
[16:11:26.467] }
[16:11:26.467] Lazy evaluation: FALSE
[16:11:26.467] Asynchronous evaluation: TRUE
[16:11:26.467] Local evaluation: TRUE
[16:11:26.467] Environment: R_GlobalEnv
[16:11:26.467] Capture standard output: TRUE
[16:11:26.467] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:26.467] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:26.467] Packages: <none>
[16:11:26.467] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:26.467] Resolved: FALSE
[16:11:26.467] Value: <not collected>
[16:11:26.467] Conditions captured: <none>
[16:11:26.467] Early signaling: FALSE
[16:11:26.467] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:26.467] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:26.479] Chunk #2 of 2 ... DONE
[16:11:26.479] Launching 2 futures (chunks) ... DONE
[16:11:26.479] Resolving 2 futures (chunks) ...
[16:11:26.479] resolve() on list ...
[16:11:26.479]  recursive: 0
[16:11:26.480]  length: 2
[16:11:26.480] 
[16:11:26.522] receiveMessageFromWorker() for ClusterFuture ...
[16:11:26.522] - Validating connection of MultisessionFuture
[16:11:26.522] - received message: FutureResult
[16:11:26.522] - Received FutureResult
[16:11:26.522] - Erased future from FutureRegistry
[16:11:26.522] result() for ClusterFuture ...
[16:11:26.523] - result already collected: FutureResult
[16:11:26.523] result() for ClusterFuture ... done
[16:11:26.523] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:26.523] Future #2
[16:11:26.523] result() for ClusterFuture ...
[16:11:26.523] - result already collected: FutureResult
[16:11:26.523] result() for ClusterFuture ... done
[16:11:26.523] result() for ClusterFuture ...
[16:11:26.523] - result already collected: FutureResult
[16:11:26.523] result() for ClusterFuture ... done
[16:11:26.524] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:26.524] - nx: 2
[16:11:26.524] - relay: TRUE
[16:11:26.524] - stdout: TRUE
[16:11:26.524] - signal: TRUE
[16:11:26.524] - resignal: FALSE
[16:11:26.524] - force: TRUE
[16:11:26.524] - relayed: [n=2] FALSE, FALSE
[16:11:26.524] - queued futures: [n=2] FALSE, FALSE
[16:11:26.524]  - until=1
[16:11:26.524]  - relaying element #1
[16:11:26.525] - relayed: [n=2] FALSE, FALSE
[16:11:26.525] - queued futures: [n=2] FALSE, TRUE
[16:11:26.525] signalConditionsASAP(NULL, pos=2) ... done
[16:11:26.525]  length: 1 (resolved future 2)
[16:11:26.978] receiveMessageFromWorker() for ClusterFuture ...
[16:11:26.978] - Validating connection of MultisessionFuture
[16:11:26.978] - received message: FutureResult
[16:11:26.979] - Received FutureResult
[16:11:26.979] - Erased future from FutureRegistry
[16:11:26.979] result() for ClusterFuture ...
[16:11:26.979] - result already collected: FutureResult
[16:11:26.979] result() for ClusterFuture ... done
[16:11:26.979] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:26.979] Future #1
[16:11:26.979] result() for ClusterFuture ...
[16:11:26.979] - result already collected: FutureResult
[16:11:26.980] result() for ClusterFuture ... done
[16:11:26.980] result() for ClusterFuture ...
[16:11:26.980] - result already collected: FutureResult
[16:11:26.980] result() for ClusterFuture ... done
[16:11:26.980] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:26.980] - nx: 2
[16:11:26.980] - relay: TRUE
[16:11:26.980] - stdout: TRUE
[16:11:26.980] - signal: TRUE
[16:11:26.980] - resignal: FALSE
[16:11:26.980] - force: TRUE
[16:11:26.981] - relayed: [n=2] FALSE, FALSE
[16:11:26.981] - queued futures: [n=2] FALSE, TRUE
[16:11:26.981]  - until=1
[16:11:26.981]  - relaying element #1
[16:11:26.981] result() for ClusterFuture ...
[16:11:26.981] - result already collected: FutureResult
[16:11:26.981] result() for ClusterFuture ... done
[16:11:26.981] result() for ClusterFuture ...
[16:11:26.981] - result already collected: FutureResult
[16:11:26.981] result() for ClusterFuture ... done
[16:11:26.981] result() for ClusterFuture ...
[16:11:26.982] - result already collected: FutureResult
[16:11:26.982] result() for ClusterFuture ... done
[16:11:26.982] result() for ClusterFuture ...
[16:11:26.982] - result already collected: FutureResult
[16:11:26.982] result() for ClusterFuture ... done
[16:11:26.982] - relayed: [n=2] TRUE, FALSE
[16:11:26.982] - queued futures: [n=2] TRUE, TRUE
[16:11:26.982] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:26.982]  length: 0 (resolved future 1)
[16:11:26.982] Relaying remaining futures
[16:11:26.982] signalConditionsASAP(NULL, pos=0) ...
[16:11:26.983] - nx: 2
[16:11:26.983] - relay: TRUE
[16:11:26.983] - stdout: TRUE
[16:11:26.983] - signal: TRUE
[16:11:26.983] - resignal: FALSE
[16:11:26.983] - force: TRUE
[16:11:26.983] - relayed: [n=2] TRUE, FALSE
[16:11:26.983] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:26.983]  - relaying element #2
[16:11:26.983] result() for ClusterFuture ...
[16:11:26.983] - result already collected: FutureResult
[16:11:26.985] result() for ClusterFuture ... done
[16:11:26.986] result() for ClusterFuture ...
[16:11:26.986] - result already collected: FutureResult
[16:11:26.986] result() for ClusterFuture ... done
[16:11:26.986] result() for ClusterFuture ...
[16:11:26.986] - result already collected: FutureResult
[16:11:26.986] result() for ClusterFuture ... done
[16:11:26.986] result() for ClusterFuture ...
[16:11:26.986] - result already collected: FutureResult
[16:11:26.986] result() for ClusterFuture ... done
[16:11:26.986] - relayed: [n=2] TRUE, TRUE
[16:11:26.986] - queued futures: [n=2] TRUE, TRUE
[16:11:26.986] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:11:26.987] resolve() on list ... DONE
[16:11:26.987] result() for ClusterFuture ...
[16:11:26.987] - result already collected: FutureResult
[16:11:26.987] result() for ClusterFuture ... done
[16:11:26.987] result() for ClusterFuture ...
[16:11:26.987] - result already collected: FutureResult
[16:11:26.987] result() for ClusterFuture ... done
[16:11:26.987] result() for ClusterFuture ...
[16:11:26.987] - result already collected: FutureResult
[16:11:26.987] result() for ClusterFuture ... done
[16:11:26.987] result() for ClusterFuture ...
[16:11:26.988] - result already collected: FutureResult
[16:11:26.988] result() for ClusterFuture ... done
[16:11:26.988]  - Number of value chunks collected: 2
[16:11:26.988] Resolving 2 futures (chunks) ... DONE
[16:11:26.988] Reducing values from 2 chunks ...
[16:11:26.988]  - Number of values collected after concatenation: 2
[16:11:26.988]  - Number of values expected: 2
[16:11:26.988] Reducing values from 2 chunks ... DONE
[16:11:26.988] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:11:26.989] future_lapply() ...
[16:11:26.993] Number of chunks: 2
[16:11:26.993] getGlobalsAndPackagesXApply() ...
[16:11:26.993]  - future.globals: TRUE
[16:11:26.993] getGlobalsAndPackages() ...
[16:11:26.993] Searching for globals...
[16:11:26.994] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:11:26.995] Searching for globals ... DONE
[16:11:26.995] Resolving globals: FALSE
[16:11:26.995] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:11:26.995] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:11:26.996] - globals: [1] ‘FUN’
[16:11:26.996] 
[16:11:26.996] getGlobalsAndPackages() ... DONE
[16:11:26.996]  - globals found/used: [n=1] ‘FUN’
[16:11:26.996]  - needed namespaces: [n=0] 
[16:11:26.996] Finding globals ... DONE
[16:11:26.996]  - use_args: TRUE
[16:11:26.996]  - Getting '...' globals ...
[16:11:26.997] resolve() on list ...
[16:11:26.997]  recursive: 0
[16:11:26.997]  length: 1
[16:11:26.997]  elements: ‘...’
[16:11:26.997]  length: 0 (resolved future 1)
[16:11:26.997] resolve() on list ... DONE
[16:11:26.997]    - '...' content: [n=0] 
[16:11:26.997] List of 1
[16:11:26.997]  $ ...: list()
[16:11:26.997]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:26.997]  - attr(*, "where")=List of 1
[16:11:26.997]   ..$ ...:<environment: 0x557e21293458> 
[16:11:26.997]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:26.997]  - attr(*, "resolved")= logi TRUE
[16:11:26.997]  - attr(*, "total_size")= num NA
[16:11:27.000]  - Getting '...' globals ... DONE
[16:11:27.000] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:27.000] List of 2
[16:11:27.000]  $ ...future.FUN:function (x)  
[16:11:27.000]  $ ...          : list()
[16:11:27.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:27.000]  - attr(*, "where")=List of 2
[16:11:27.000]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:27.000]   ..$ ...          :<environment: 0x557e21293458> 
[16:11:27.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:27.000]  - attr(*, "resolved")= logi FALSE
[16:11:27.000]  - attr(*, "total_size")= num 4720
[16:11:27.002] Packages to be attached in all futures: [n=0] 
[16:11:27.003] getGlobalsAndPackagesXApply() ... DONE
[16:11:27.003] Number of futures (= number of chunks): 2
[16:11:27.003] Launching 2 futures (chunks) ...
[16:11:27.003] Chunk #1 of 2 ...
[16:11:27.003]  - Finding globals in 'X' for chunk #1 ...
[16:11:27.003] getGlobalsAndPackages() ...
[16:11:27.003] Searching for globals...
[16:11:27.003] 
[16:11:27.004] Searching for globals ... DONE
[16:11:27.004] - globals: [0] <none>
[16:11:27.004] getGlobalsAndPackages() ... DONE
[16:11:27.004]    + additional globals found: [n=0] 
[16:11:27.004]    + additional namespaces needed: [n=0] 
[16:11:27.004]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:27.004]  - seeds: <none>
[16:11:27.004] getGlobalsAndPackages() ...
[16:11:27.004] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:27.004] Resolving globals: FALSE
[16:11:27.005] Tweak future expression to call with '...' arguments ...
[16:11:27.005] {
[16:11:27.005]     do.call(function(...) {
[16:11:27.005]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.005]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:27.005]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.005]             on.exit(options(oopts), add = TRUE)
[16:11:27.005]         }
[16:11:27.005]         {
[16:11:27.005]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:27.005]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:27.005]                 ...future.FUN(...future.X_jj, ...)
[16:11:27.005]             })
[16:11:27.005]         }
[16:11:27.005]     }, args = future.call.arguments)
[16:11:27.005] }
[16:11:27.005] Tweak future expression to call with '...' arguments ... DONE
[16:11:27.005] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:27.005] 
[16:11:27.005] getGlobalsAndPackages() ... DONE
[16:11:27.006] run() for ‘Future’ ...
[16:11:27.006] - state: ‘created’
[16:11:27.006] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:27.023] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:27.023] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:27.023]   - Field: ‘node’
[16:11:27.023]   - Field: ‘label’
[16:11:27.023]   - Field: ‘local’
[16:11:27.024]   - Field: ‘owner’
[16:11:27.024]   - Field: ‘envir’
[16:11:27.024]   - Field: ‘workers’
[16:11:27.024]   - Field: ‘packages’
[16:11:27.024]   - Field: ‘gc’
[16:11:27.024]   - Field: ‘conditions’
[16:11:27.024]   - Field: ‘persistent’
[16:11:27.024]   - Field: ‘expr’
[16:11:27.024]   - Field: ‘uuid’
[16:11:27.024]   - Field: ‘seed’
[16:11:27.025]   - Field: ‘version’
[16:11:27.025]   - Field: ‘result’
[16:11:27.025]   - Field: ‘asynchronous’
[16:11:27.025]   - Field: ‘calls’
[16:11:27.025]   - Field: ‘globals’
[16:11:27.025]   - Field: ‘stdout’
[16:11:27.025]   - Field: ‘earlySignal’
[16:11:27.025]   - Field: ‘lazy’
[16:11:27.025]   - Field: ‘state’
[16:11:27.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:27.026] - Launch lazy future ...
[16:11:27.026] Packages needed by the future expression (n = 0): <none>
[16:11:27.026] Packages needed by future strategies (n = 0): <none>
[16:11:27.026] {
[16:11:27.026]     {
[16:11:27.026]         {
[16:11:27.026]             ...future.startTime <- base::Sys.time()
[16:11:27.026]             {
[16:11:27.026]                 {
[16:11:27.026]                   {
[16:11:27.026]                     {
[16:11:27.026]                       base::local({
[16:11:27.026]                         has_future <- base::requireNamespace("future", 
[16:11:27.026]                           quietly = TRUE)
[16:11:27.026]                         if (has_future) {
[16:11:27.026]                           ns <- base::getNamespace("future")
[16:11:27.026]                           version <- ns[[".package"]][["version"]]
[16:11:27.026]                           if (is.null(version)) 
[16:11:27.026]                             version <- utils::packageVersion("future")
[16:11:27.026]                         }
[16:11:27.026]                         else {
[16:11:27.026]                           version <- NULL
[16:11:27.026]                         }
[16:11:27.026]                         if (!has_future || version < "1.8.0") {
[16:11:27.026]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:27.026]                             "", base::R.version$version.string), 
[16:11:27.026]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:27.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:27.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:27.026]                               "release", "version")], collapse = " "), 
[16:11:27.026]                             hostname = base::Sys.info()[["nodename"]])
[16:11:27.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:27.026]                             info)
[16:11:27.026]                           info <- base::paste(info, collapse = "; ")
[16:11:27.026]                           if (!has_future) {
[16:11:27.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:27.026]                               info)
[16:11:27.026]                           }
[16:11:27.026]                           else {
[16:11:27.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:27.026]                               info, version)
[16:11:27.026]                           }
[16:11:27.026]                           base::stop(msg)
[16:11:27.026]                         }
[16:11:27.026]                       })
[16:11:27.026]                     }
[16:11:27.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:27.026]                     base::options(mc.cores = 1L)
[16:11:27.026]                   }
[16:11:27.026]                   options(future.plan = NULL)
[16:11:27.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:27.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:27.026]                 }
[16:11:27.026]                 ...future.workdir <- getwd()
[16:11:27.026]             }
[16:11:27.026]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:27.026]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:27.026]         }
[16:11:27.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:27.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:27.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:27.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:27.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:27.026]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:27.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:27.026]             base::names(...future.oldOptions))
[16:11:27.026]     }
[16:11:27.026]     if (TRUE) {
[16:11:27.026]     }
[16:11:27.026]     else {
[16:11:27.026]         if (NA) {
[16:11:27.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:27.026]                 open = "w")
[16:11:27.026]         }
[16:11:27.026]         else {
[16:11:27.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:27.026]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:27.026]         }
[16:11:27.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:27.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:27.026]             base::sink(type = "output", split = FALSE)
[16:11:27.026]             base::close(...future.stdout)
[16:11:27.026]         }, add = TRUE)
[16:11:27.026]     }
[16:11:27.026]     ...future.frame <- base::sys.nframe()
[16:11:27.026]     ...future.conditions <- base::list()
[16:11:27.026]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:27.026]     if (FALSE) {
[16:11:27.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:27.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:27.026]     }
[16:11:27.026]     ...future.result <- base::tryCatch({
[16:11:27.026]         base::withCallingHandlers({
[16:11:27.026]             ...future.value <- base::withVisible(base::local({
[16:11:27.026]                 ...future.makeSendCondition <- local({
[16:11:27.026]                   sendCondition <- NULL
[16:11:27.026]                   function(frame = 1L) {
[16:11:27.026]                     if (is.function(sendCondition)) 
[16:11:27.026]                       return(sendCondition)
[16:11:27.026]                     ns <- getNamespace("parallel")
[16:11:27.026]                     if (exists("sendData", mode = "function", 
[16:11:27.026]                       envir = ns)) {
[16:11:27.026]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:27.026]                         envir = ns)
[16:11:27.026]                       envir <- sys.frame(frame)
[16:11:27.026]                       master <- NULL
[16:11:27.026]                       while (!identical(envir, .GlobalEnv) && 
[16:11:27.026]                         !identical(envir, emptyenv())) {
[16:11:27.026]                         if (exists("master", mode = "list", envir = envir, 
[16:11:27.026]                           inherits = FALSE)) {
[16:11:27.026]                           master <- get("master", mode = "list", 
[16:11:27.026]                             envir = envir, inherits = FALSE)
[16:11:27.026]                           if (inherits(master, c("SOCKnode", 
[16:11:27.026]                             "SOCK0node"))) {
[16:11:27.026]                             sendCondition <<- function(cond) {
[16:11:27.026]                               data <- list(type = "VALUE", value = cond, 
[16:11:27.026]                                 success = TRUE)
[16:11:27.026]                               parallel_sendData(master, data)
[16:11:27.026]                             }
[16:11:27.026]                             return(sendCondition)
[16:11:27.026]                           }
[16:11:27.026]                         }
[16:11:27.026]                         frame <- frame + 1L
[16:11:27.026]                         envir <- sys.frame(frame)
[16:11:27.026]                       }
[16:11:27.026]                     }
[16:11:27.026]                     sendCondition <<- function(cond) NULL
[16:11:27.026]                   }
[16:11:27.026]                 })
[16:11:27.026]                 withCallingHandlers({
[16:11:27.026]                   {
[16:11:27.026]                     do.call(function(...) {
[16:11:27.026]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.026]                       if (!identical(...future.globals.maxSize.org, 
[16:11:27.026]                         ...future.globals.maxSize)) {
[16:11:27.026]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.026]                         on.exit(options(oopts), add = TRUE)
[16:11:27.026]                       }
[16:11:27.026]                       {
[16:11:27.026]                         lapply(seq_along(...future.elements_ii), 
[16:11:27.026]                           FUN = function(jj) {
[16:11:27.026]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:27.026]                             ...future.FUN(...future.X_jj, ...)
[16:11:27.026]                           })
[16:11:27.026]                       }
[16:11:27.026]                     }, args = future.call.arguments)
[16:11:27.026]                   }
[16:11:27.026]                 }, immediateCondition = function(cond) {
[16:11:27.026]                   sendCondition <- ...future.makeSendCondition()
[16:11:27.026]                   sendCondition(cond)
[16:11:27.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.026]                   {
[16:11:27.026]                     inherits <- base::inherits
[16:11:27.026]                     invokeRestart <- base::invokeRestart
[16:11:27.026]                     is.null <- base::is.null
[16:11:27.026]                     muffled <- FALSE
[16:11:27.026]                     if (inherits(cond, "message")) {
[16:11:27.026]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:27.026]                       if (muffled) 
[16:11:27.026]                         invokeRestart("muffleMessage")
[16:11:27.026]                     }
[16:11:27.026]                     else if (inherits(cond, "warning")) {
[16:11:27.026]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:27.026]                       if (muffled) 
[16:11:27.026]                         invokeRestart("muffleWarning")
[16:11:27.026]                     }
[16:11:27.026]                     else if (inherits(cond, "condition")) {
[16:11:27.026]                       if (!is.null(pattern)) {
[16:11:27.026]                         computeRestarts <- base::computeRestarts
[16:11:27.026]                         grepl <- base::grepl
[16:11:27.026]                         restarts <- computeRestarts(cond)
[16:11:27.026]                         for (restart in restarts) {
[16:11:27.026]                           name <- restart$name
[16:11:27.026]                           if (is.null(name)) 
[16:11:27.026]                             next
[16:11:27.026]                           if (!grepl(pattern, name)) 
[16:11:27.026]                             next
[16:11:27.026]                           invokeRestart(restart)
[16:11:27.026]                           muffled <- TRUE
[16:11:27.026]                           break
[16:11:27.026]                         }
[16:11:27.026]                       }
[16:11:27.026]                     }
[16:11:27.026]                     invisible(muffled)
[16:11:27.026]                   }
[16:11:27.026]                   muffleCondition(cond)
[16:11:27.026]                 })
[16:11:27.026]             }))
[16:11:27.026]             future::FutureResult(value = ...future.value$value, 
[16:11:27.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:27.026]                   ...future.rng), globalenv = if (FALSE) 
[16:11:27.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:27.026]                     ...future.globalenv.names))
[16:11:27.026]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:27.026]         }, condition = base::local({
[16:11:27.026]             c <- base::c
[16:11:27.026]             inherits <- base::inherits
[16:11:27.026]             invokeRestart <- base::invokeRestart
[16:11:27.026]             length <- base::length
[16:11:27.026]             list <- base::list
[16:11:27.026]             seq.int <- base::seq.int
[16:11:27.026]             signalCondition <- base::signalCondition
[16:11:27.026]             sys.calls <- base::sys.calls
[16:11:27.026]             `[[` <- base::`[[`
[16:11:27.026]             `+` <- base::`+`
[16:11:27.026]             `<<-` <- base::`<<-`
[16:11:27.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:27.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:27.026]                   3L)]
[16:11:27.026]             }
[16:11:27.026]             function(cond) {
[16:11:27.026]                 is_error <- inherits(cond, "error")
[16:11:27.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:27.026]                   NULL)
[16:11:27.026]                 if (is_error) {
[16:11:27.026]                   sessionInformation <- function() {
[16:11:27.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:27.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:27.026]                       search = base::search(), system = base::Sys.info())
[16:11:27.026]                   }
[16:11:27.026]                   ...future.conditions[[length(...future.conditions) + 
[16:11:27.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:27.026]                     cond$call), session = sessionInformation(), 
[16:11:27.026]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:27.026]                   signalCondition(cond)
[16:11:27.026]                 }
[16:11:27.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:27.026]                 "immediateCondition"))) {
[16:11:27.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:27.026]                   ...future.conditions[[length(...future.conditions) + 
[16:11:27.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:27.026]                   if (TRUE && !signal) {
[16:11:27.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.026]                     {
[16:11:27.026]                       inherits <- base::inherits
[16:11:27.026]                       invokeRestart <- base::invokeRestart
[16:11:27.026]                       is.null <- base::is.null
[16:11:27.026]                       muffled <- FALSE
[16:11:27.026]                       if (inherits(cond, "message")) {
[16:11:27.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:27.026]                         if (muffled) 
[16:11:27.026]                           invokeRestart("muffleMessage")
[16:11:27.026]                       }
[16:11:27.026]                       else if (inherits(cond, "warning")) {
[16:11:27.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:27.026]                         if (muffled) 
[16:11:27.026]                           invokeRestart("muffleWarning")
[16:11:27.026]                       }
[16:11:27.026]                       else if (inherits(cond, "condition")) {
[16:11:27.026]                         if (!is.null(pattern)) {
[16:11:27.026]                           computeRestarts <- base::computeRestarts
[16:11:27.026]                           grepl <- base::grepl
[16:11:27.026]                           restarts <- computeRestarts(cond)
[16:11:27.026]                           for (restart in restarts) {
[16:11:27.026]                             name <- restart$name
[16:11:27.026]                             if (is.null(name)) 
[16:11:27.026]                               next
[16:11:27.026]                             if (!grepl(pattern, name)) 
[16:11:27.026]                               next
[16:11:27.026]                             invokeRestart(restart)
[16:11:27.026]                             muffled <- TRUE
[16:11:27.026]                             break
[16:11:27.026]                           }
[16:11:27.026]                         }
[16:11:27.026]                       }
[16:11:27.026]                       invisible(muffled)
[16:11:27.026]                     }
[16:11:27.026]                     muffleCondition(cond, pattern = "^muffle")
[16:11:27.026]                   }
[16:11:27.026]                 }
[16:11:27.026]                 else {
[16:11:27.026]                   if (TRUE) {
[16:11:27.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.026]                     {
[16:11:27.026]                       inherits <- base::inherits
[16:11:27.026]                       invokeRestart <- base::invokeRestart
[16:11:27.026]                       is.null <- base::is.null
[16:11:27.026]                       muffled <- FALSE
[16:11:27.026]                       if (inherits(cond, "message")) {
[16:11:27.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:27.026]                         if (muffled) 
[16:11:27.026]                           invokeRestart("muffleMessage")
[16:11:27.026]                       }
[16:11:27.026]                       else if (inherits(cond, "warning")) {
[16:11:27.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:27.026]                         if (muffled) 
[16:11:27.026]                           invokeRestart("muffleWarning")
[16:11:27.026]                       }
[16:11:27.026]                       else if (inherits(cond, "condition")) {
[16:11:27.026]                         if (!is.null(pattern)) {
[16:11:27.026]                           computeRestarts <- base::computeRestarts
[16:11:27.026]                           grepl <- base::grepl
[16:11:27.026]                           restarts <- computeRestarts(cond)
[16:11:27.026]                           for (restart in restarts) {
[16:11:27.026]                             name <- restart$name
[16:11:27.026]                             if (is.null(name)) 
[16:11:27.026]                               next
[16:11:27.026]                             if (!grepl(pattern, name)) 
[16:11:27.026]                               next
[16:11:27.026]                             invokeRestart(restart)
[16:11:27.026]                             muffled <- TRUE
[16:11:27.026]                             break
[16:11:27.026]                           }
[16:11:27.026]                         }
[16:11:27.026]                       }
[16:11:27.026]                       invisible(muffled)
[16:11:27.026]                     }
[16:11:27.026]                     muffleCondition(cond, pattern = "^muffle")
[16:11:27.026]                   }
[16:11:27.026]                 }
[16:11:27.026]             }
[16:11:27.026]         }))
[16:11:27.026]     }, error = function(ex) {
[16:11:27.026]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:27.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:27.026]                 ...future.rng), started = ...future.startTime, 
[16:11:27.026]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:27.026]             version = "1.8"), class = "FutureResult")
[16:11:27.026]     }, finally = {
[16:11:27.026]         if (!identical(...future.workdir, getwd())) 
[16:11:27.026]             setwd(...future.workdir)
[16:11:27.026]         {
[16:11:27.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:27.026]                 ...future.oldOptions$nwarnings <- NULL
[16:11:27.026]             }
[16:11:27.026]             base::options(...future.oldOptions)
[16:11:27.026]             if (.Platform$OS.type == "windows") {
[16:11:27.026]                 old_names <- names(...future.oldEnvVars)
[16:11:27.026]                 envs <- base::Sys.getenv()
[16:11:27.026]                 names <- names(envs)
[16:11:27.026]                 common <- intersect(names, old_names)
[16:11:27.026]                 added <- setdiff(names, old_names)
[16:11:27.026]                 removed <- setdiff(old_names, names)
[16:11:27.026]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:27.026]                   envs[common]]
[16:11:27.026]                 NAMES <- toupper(changed)
[16:11:27.026]                 args <- list()
[16:11:27.026]                 for (kk in seq_along(NAMES)) {
[16:11:27.026]                   name <- changed[[kk]]
[16:11:27.026]                   NAME <- NAMES[[kk]]
[16:11:27.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.026]                     next
[16:11:27.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:27.026]                 }
[16:11:27.026]                 NAMES <- toupper(added)
[16:11:27.026]                 for (kk in seq_along(NAMES)) {
[16:11:27.026]                   name <- added[[kk]]
[16:11:27.026]                   NAME <- NAMES[[kk]]
[16:11:27.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.026]                     next
[16:11:27.026]                   args[[name]] <- ""
[16:11:27.026]                 }
[16:11:27.026]                 NAMES <- toupper(removed)
[16:11:27.026]                 for (kk in seq_along(NAMES)) {
[16:11:27.026]                   name <- removed[[kk]]
[16:11:27.026]                   NAME <- NAMES[[kk]]
[16:11:27.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.026]                     next
[16:11:27.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:27.026]                 }
[16:11:27.026]                 if (length(args) > 0) 
[16:11:27.026]                   base::do.call(base::Sys.setenv, args = args)
[16:11:27.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:27.026]             }
[16:11:27.026]             else {
[16:11:27.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:27.026]             }
[16:11:27.026]             {
[16:11:27.026]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:27.026]                   0L) {
[16:11:27.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:27.026]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:27.026]                   base::options(opts)
[16:11:27.026]                 }
[16:11:27.026]                 {
[16:11:27.026]                   {
[16:11:27.026]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:27.026]                     NULL
[16:11:27.026]                   }
[16:11:27.026]                   options(future.plan = NULL)
[16:11:27.026]                   if (is.na(NA_character_)) 
[16:11:27.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:27.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:27.026]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:27.026]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:27.026]                     envir = parent.frame()) 
[16:11:27.026]                   {
[16:11:27.026]                     if (is.function(workers)) 
[16:11:27.026]                       workers <- workers()
[16:11:27.026]                     workers <- structure(as.integer(workers), 
[16:11:27.026]                       class = class(workers))
[16:11:27.026]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:27.026]                       workers >= 1)
[16:11:27.026]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:27.026]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:27.026]                     }
[16:11:27.026]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:27.026]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:27.026]                       envir = envir)
[16:11:27.026]                     if (!future$lazy) 
[16:11:27.026]                       future <- run(future)
[16:11:27.026]                     invisible(future)
[16:11:27.026]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:27.026]                 }
[16:11:27.026]             }
[16:11:27.026]         }
[16:11:27.026]     })
[16:11:27.026]     if (FALSE) {
[16:11:27.026]         base::sink(type = "output", split = FALSE)
[16:11:27.026]         if (NA) {
[16:11:27.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:27.026]         }
[16:11:27.026]         else {
[16:11:27.026]             ...future.result["stdout"] <- base::list(NULL)
[16:11:27.026]         }
[16:11:27.026]         base::close(...future.stdout)
[16:11:27.026]         ...future.stdout <- NULL
[16:11:27.026]     }
[16:11:27.026]     ...future.result$conditions <- ...future.conditions
[16:11:27.026]     ...future.result$finished <- base::Sys.time()
[16:11:27.026]     ...future.result
[16:11:27.026] }
[16:11:27.030] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:11:27.030] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:11:27.030] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:11:27.030] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:27.031] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:27.031] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:11:27.031] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:11:27.032] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:27.032] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:27.032] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:27.032] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:27.033] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:11:27.033] MultisessionFuture started
[16:11:27.033] - Launch lazy future ... done
[16:11:27.034] run() for ‘MultisessionFuture’ ... done
[16:11:27.034] Created future:
[16:11:27.034] MultisessionFuture:
[16:11:27.034] Label: ‘future_lapply-1’
[16:11:27.034] Expression:
[16:11:27.034] {
[16:11:27.034]     do.call(function(...) {
[16:11:27.034]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.034]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:27.034]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.034]             on.exit(options(oopts), add = TRUE)
[16:11:27.034]         }
[16:11:27.034]         {
[16:11:27.034]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:27.034]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:27.034]                 ...future.FUN(...future.X_jj, ...)
[16:11:27.034]             })
[16:11:27.034]         }
[16:11:27.034]     }, args = future.call.arguments)
[16:11:27.034] }
[16:11:27.034] Lazy evaluation: FALSE
[16:11:27.034] Asynchronous evaluation: TRUE
[16:11:27.034] Local evaluation: TRUE
[16:11:27.034] Environment: R_GlobalEnv
[16:11:27.034] Capture standard output: NA
[16:11:27.034] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:27.034] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:27.034] Packages: <none>
[16:11:27.034] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:27.034] Resolved: FALSE
[16:11:27.034] Value: <not collected>
[16:11:27.034] Conditions captured: <none>
[16:11:27.034] Early signaling: FALSE
[16:11:27.034] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:27.034] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:27.045] Chunk #1 of 2 ... DONE
[16:11:27.046] Chunk #2 of 2 ...
[16:11:27.046]  - Finding globals in 'X' for chunk #2 ...
[16:11:27.046] getGlobalsAndPackages() ...
[16:11:27.046] Searching for globals...
[16:11:27.046] 
[16:11:27.046] Searching for globals ... DONE
[16:11:27.046] - globals: [0] <none>
[16:11:27.046] getGlobalsAndPackages() ... DONE
[16:11:27.046]    + additional globals found: [n=0] 
[16:11:27.047]    + additional namespaces needed: [n=0] 
[16:11:27.047]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:27.047]  - seeds: <none>
[16:11:27.047] getGlobalsAndPackages() ...
[16:11:27.047] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:27.047] Resolving globals: FALSE
[16:11:27.047] Tweak future expression to call with '...' arguments ...
[16:11:27.047] {
[16:11:27.047]     do.call(function(...) {
[16:11:27.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:27.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.047]             on.exit(options(oopts), add = TRUE)
[16:11:27.047]         }
[16:11:27.047]         {
[16:11:27.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:27.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:27.047]                 ...future.FUN(...future.X_jj, ...)
[16:11:27.047]             })
[16:11:27.047]         }
[16:11:27.047]     }, args = future.call.arguments)
[16:11:27.047] }
[16:11:27.048] Tweak future expression to call with '...' arguments ... DONE
[16:11:27.048] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:27.048] 
[16:11:27.048] getGlobalsAndPackages() ... DONE
[16:11:27.048] run() for ‘Future’ ...
[16:11:27.049] - state: ‘created’
[16:11:27.049] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:27.064] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:27.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:27.064]   - Field: ‘node’
[16:11:27.064]   - Field: ‘label’
[16:11:27.064]   - Field: ‘local’
[16:11:27.064]   - Field: ‘owner’
[16:11:27.064]   - Field: ‘envir’
[16:11:27.065]   - Field: ‘workers’
[16:11:27.065]   - Field: ‘packages’
[16:11:27.065]   - Field: ‘gc’
[16:11:27.065]   - Field: ‘conditions’
[16:11:27.065]   - Field: ‘persistent’
[16:11:27.065]   - Field: ‘expr’
[16:11:27.065]   - Field: ‘uuid’
[16:11:27.065]   - Field: ‘seed’
[16:11:27.065]   - Field: ‘version’
[16:11:27.065]   - Field: ‘result’
[16:11:27.065]   - Field: ‘asynchronous’
[16:11:27.066]   - Field: ‘calls’
[16:11:27.066]   - Field: ‘globals’
[16:11:27.066]   - Field: ‘stdout’
[16:11:27.066]   - Field: ‘earlySignal’
[16:11:27.066]   - Field: ‘lazy’
[16:11:27.066]   - Field: ‘state’
[16:11:27.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:27.066] - Launch lazy future ...
[16:11:27.066] Packages needed by the future expression (n = 0): <none>
[16:11:27.067] Packages needed by future strategies (n = 0): <none>
[16:11:27.067] {
[16:11:27.067]     {
[16:11:27.067]         {
[16:11:27.067]             ...future.startTime <- base::Sys.time()
[16:11:27.067]             {
[16:11:27.067]                 {
[16:11:27.067]                   {
[16:11:27.067]                     {
[16:11:27.067]                       base::local({
[16:11:27.067]                         has_future <- base::requireNamespace("future", 
[16:11:27.067]                           quietly = TRUE)
[16:11:27.067]                         if (has_future) {
[16:11:27.067]                           ns <- base::getNamespace("future")
[16:11:27.067]                           version <- ns[[".package"]][["version"]]
[16:11:27.067]                           if (is.null(version)) 
[16:11:27.067]                             version <- utils::packageVersion("future")
[16:11:27.067]                         }
[16:11:27.067]                         else {
[16:11:27.067]                           version <- NULL
[16:11:27.067]                         }
[16:11:27.067]                         if (!has_future || version < "1.8.0") {
[16:11:27.067]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:27.067]                             "", base::R.version$version.string), 
[16:11:27.067]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:27.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:27.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:27.067]                               "release", "version")], collapse = " "), 
[16:11:27.067]                             hostname = base::Sys.info()[["nodename"]])
[16:11:27.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:27.067]                             info)
[16:11:27.067]                           info <- base::paste(info, collapse = "; ")
[16:11:27.067]                           if (!has_future) {
[16:11:27.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:27.067]                               info)
[16:11:27.067]                           }
[16:11:27.067]                           else {
[16:11:27.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:27.067]                               info, version)
[16:11:27.067]                           }
[16:11:27.067]                           base::stop(msg)
[16:11:27.067]                         }
[16:11:27.067]                       })
[16:11:27.067]                     }
[16:11:27.067]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:27.067]                     base::options(mc.cores = 1L)
[16:11:27.067]                   }
[16:11:27.067]                   options(future.plan = NULL)
[16:11:27.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:27.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:27.067]                 }
[16:11:27.067]                 ...future.workdir <- getwd()
[16:11:27.067]             }
[16:11:27.067]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:27.067]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:27.067]         }
[16:11:27.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:27.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:27.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:27.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:27.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:27.067]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:27.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:27.067]             base::names(...future.oldOptions))
[16:11:27.067]     }
[16:11:27.067]     if (TRUE) {
[16:11:27.067]     }
[16:11:27.067]     else {
[16:11:27.067]         if (NA) {
[16:11:27.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:27.067]                 open = "w")
[16:11:27.067]         }
[16:11:27.067]         else {
[16:11:27.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:27.067]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:27.067]         }
[16:11:27.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:27.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:27.067]             base::sink(type = "output", split = FALSE)
[16:11:27.067]             base::close(...future.stdout)
[16:11:27.067]         }, add = TRUE)
[16:11:27.067]     }
[16:11:27.067]     ...future.frame <- base::sys.nframe()
[16:11:27.067]     ...future.conditions <- base::list()
[16:11:27.067]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:27.067]     if (FALSE) {
[16:11:27.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:27.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:27.067]     }
[16:11:27.067]     ...future.result <- base::tryCatch({
[16:11:27.067]         base::withCallingHandlers({
[16:11:27.067]             ...future.value <- base::withVisible(base::local({
[16:11:27.067]                 ...future.makeSendCondition <- local({
[16:11:27.067]                   sendCondition <- NULL
[16:11:27.067]                   function(frame = 1L) {
[16:11:27.067]                     if (is.function(sendCondition)) 
[16:11:27.067]                       return(sendCondition)
[16:11:27.067]                     ns <- getNamespace("parallel")
[16:11:27.067]                     if (exists("sendData", mode = "function", 
[16:11:27.067]                       envir = ns)) {
[16:11:27.067]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:27.067]                         envir = ns)
[16:11:27.067]                       envir <- sys.frame(frame)
[16:11:27.067]                       master <- NULL
[16:11:27.067]                       while (!identical(envir, .GlobalEnv) && 
[16:11:27.067]                         !identical(envir, emptyenv())) {
[16:11:27.067]                         if (exists("master", mode = "list", envir = envir, 
[16:11:27.067]                           inherits = FALSE)) {
[16:11:27.067]                           master <- get("master", mode = "list", 
[16:11:27.067]                             envir = envir, inherits = FALSE)
[16:11:27.067]                           if (inherits(master, c("SOCKnode", 
[16:11:27.067]                             "SOCK0node"))) {
[16:11:27.067]                             sendCondition <<- function(cond) {
[16:11:27.067]                               data <- list(type = "VALUE", value = cond, 
[16:11:27.067]                                 success = TRUE)
[16:11:27.067]                               parallel_sendData(master, data)
[16:11:27.067]                             }
[16:11:27.067]                             return(sendCondition)
[16:11:27.067]                           }
[16:11:27.067]                         }
[16:11:27.067]                         frame <- frame + 1L
[16:11:27.067]                         envir <- sys.frame(frame)
[16:11:27.067]                       }
[16:11:27.067]                     }
[16:11:27.067]                     sendCondition <<- function(cond) NULL
[16:11:27.067]                   }
[16:11:27.067]                 })
[16:11:27.067]                 withCallingHandlers({
[16:11:27.067]                   {
[16:11:27.067]                     do.call(function(...) {
[16:11:27.067]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.067]                       if (!identical(...future.globals.maxSize.org, 
[16:11:27.067]                         ...future.globals.maxSize)) {
[16:11:27.067]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.067]                         on.exit(options(oopts), add = TRUE)
[16:11:27.067]                       }
[16:11:27.067]                       {
[16:11:27.067]                         lapply(seq_along(...future.elements_ii), 
[16:11:27.067]                           FUN = function(jj) {
[16:11:27.067]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:27.067]                             ...future.FUN(...future.X_jj, ...)
[16:11:27.067]                           })
[16:11:27.067]                       }
[16:11:27.067]                     }, args = future.call.arguments)
[16:11:27.067]                   }
[16:11:27.067]                 }, immediateCondition = function(cond) {
[16:11:27.067]                   sendCondition <- ...future.makeSendCondition()
[16:11:27.067]                   sendCondition(cond)
[16:11:27.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.067]                   {
[16:11:27.067]                     inherits <- base::inherits
[16:11:27.067]                     invokeRestart <- base::invokeRestart
[16:11:27.067]                     is.null <- base::is.null
[16:11:27.067]                     muffled <- FALSE
[16:11:27.067]                     if (inherits(cond, "message")) {
[16:11:27.067]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:27.067]                       if (muffled) 
[16:11:27.067]                         invokeRestart("muffleMessage")
[16:11:27.067]                     }
[16:11:27.067]                     else if (inherits(cond, "warning")) {
[16:11:27.067]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:27.067]                       if (muffled) 
[16:11:27.067]                         invokeRestart("muffleWarning")
[16:11:27.067]                     }
[16:11:27.067]                     else if (inherits(cond, "condition")) {
[16:11:27.067]                       if (!is.null(pattern)) {
[16:11:27.067]                         computeRestarts <- base::computeRestarts
[16:11:27.067]                         grepl <- base::grepl
[16:11:27.067]                         restarts <- computeRestarts(cond)
[16:11:27.067]                         for (restart in restarts) {
[16:11:27.067]                           name <- restart$name
[16:11:27.067]                           if (is.null(name)) 
[16:11:27.067]                             next
[16:11:27.067]                           if (!grepl(pattern, name)) 
[16:11:27.067]                             next
[16:11:27.067]                           invokeRestart(restart)
[16:11:27.067]                           muffled <- TRUE
[16:11:27.067]                           break
[16:11:27.067]                         }
[16:11:27.067]                       }
[16:11:27.067]                     }
[16:11:27.067]                     invisible(muffled)
[16:11:27.067]                   }
[16:11:27.067]                   muffleCondition(cond)
[16:11:27.067]                 })
[16:11:27.067]             }))
[16:11:27.067]             future::FutureResult(value = ...future.value$value, 
[16:11:27.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:27.067]                   ...future.rng), globalenv = if (FALSE) 
[16:11:27.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:27.067]                     ...future.globalenv.names))
[16:11:27.067]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:27.067]         }, condition = base::local({
[16:11:27.067]             c <- base::c
[16:11:27.067]             inherits <- base::inherits
[16:11:27.067]             invokeRestart <- base::invokeRestart
[16:11:27.067]             length <- base::length
[16:11:27.067]             list <- base::list
[16:11:27.067]             seq.int <- base::seq.int
[16:11:27.067]             signalCondition <- base::signalCondition
[16:11:27.067]             sys.calls <- base::sys.calls
[16:11:27.067]             `[[` <- base::`[[`
[16:11:27.067]             `+` <- base::`+`
[16:11:27.067]             `<<-` <- base::`<<-`
[16:11:27.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:27.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:27.067]                   3L)]
[16:11:27.067]             }
[16:11:27.067]             function(cond) {
[16:11:27.067]                 is_error <- inherits(cond, "error")
[16:11:27.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:27.067]                   NULL)
[16:11:27.067]                 if (is_error) {
[16:11:27.067]                   sessionInformation <- function() {
[16:11:27.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:27.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:27.067]                       search = base::search(), system = base::Sys.info())
[16:11:27.067]                   }
[16:11:27.067]                   ...future.conditions[[length(...future.conditions) + 
[16:11:27.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:27.067]                     cond$call), session = sessionInformation(), 
[16:11:27.067]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:27.067]                   signalCondition(cond)
[16:11:27.067]                 }
[16:11:27.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:27.067]                 "immediateCondition"))) {
[16:11:27.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:27.067]                   ...future.conditions[[length(...future.conditions) + 
[16:11:27.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:27.067]                   if (TRUE && !signal) {
[16:11:27.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.067]                     {
[16:11:27.067]                       inherits <- base::inherits
[16:11:27.067]                       invokeRestart <- base::invokeRestart
[16:11:27.067]                       is.null <- base::is.null
[16:11:27.067]                       muffled <- FALSE
[16:11:27.067]                       if (inherits(cond, "message")) {
[16:11:27.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:27.067]                         if (muffled) 
[16:11:27.067]                           invokeRestart("muffleMessage")
[16:11:27.067]                       }
[16:11:27.067]                       else if (inherits(cond, "warning")) {
[16:11:27.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:27.067]                         if (muffled) 
[16:11:27.067]                           invokeRestart("muffleWarning")
[16:11:27.067]                       }
[16:11:27.067]                       else if (inherits(cond, "condition")) {
[16:11:27.067]                         if (!is.null(pattern)) {
[16:11:27.067]                           computeRestarts <- base::computeRestarts
[16:11:27.067]                           grepl <- base::grepl
[16:11:27.067]                           restarts <- computeRestarts(cond)
[16:11:27.067]                           for (restart in restarts) {
[16:11:27.067]                             name <- restart$name
[16:11:27.067]                             if (is.null(name)) 
[16:11:27.067]                               next
[16:11:27.067]                             if (!grepl(pattern, name)) 
[16:11:27.067]                               next
[16:11:27.067]                             invokeRestart(restart)
[16:11:27.067]                             muffled <- TRUE
[16:11:27.067]                             break
[16:11:27.067]                           }
[16:11:27.067]                         }
[16:11:27.067]                       }
[16:11:27.067]                       invisible(muffled)
[16:11:27.067]                     }
[16:11:27.067]                     muffleCondition(cond, pattern = "^muffle")
[16:11:27.067]                   }
[16:11:27.067]                 }
[16:11:27.067]                 else {
[16:11:27.067]                   if (TRUE) {
[16:11:27.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.067]                     {
[16:11:27.067]                       inherits <- base::inherits
[16:11:27.067]                       invokeRestart <- base::invokeRestart
[16:11:27.067]                       is.null <- base::is.null
[16:11:27.067]                       muffled <- FALSE
[16:11:27.067]                       if (inherits(cond, "message")) {
[16:11:27.067]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:27.067]                         if (muffled) 
[16:11:27.067]                           invokeRestart("muffleMessage")
[16:11:27.067]                       }
[16:11:27.067]                       else if (inherits(cond, "warning")) {
[16:11:27.067]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:27.067]                         if (muffled) 
[16:11:27.067]                           invokeRestart("muffleWarning")
[16:11:27.067]                       }
[16:11:27.067]                       else if (inherits(cond, "condition")) {
[16:11:27.067]                         if (!is.null(pattern)) {
[16:11:27.067]                           computeRestarts <- base::computeRestarts
[16:11:27.067]                           grepl <- base::grepl
[16:11:27.067]                           restarts <- computeRestarts(cond)
[16:11:27.067]                           for (restart in restarts) {
[16:11:27.067]                             name <- restart$name
[16:11:27.067]                             if (is.null(name)) 
[16:11:27.067]                               next
[16:11:27.067]                             if (!grepl(pattern, name)) 
[16:11:27.067]                               next
[16:11:27.067]                             invokeRestart(restart)
[16:11:27.067]                             muffled <- TRUE
[16:11:27.067]                             break
[16:11:27.067]                           }
[16:11:27.067]                         }
[16:11:27.067]                       }
[16:11:27.067]                       invisible(muffled)
[16:11:27.067]                     }
[16:11:27.067]                     muffleCondition(cond, pattern = "^muffle")
[16:11:27.067]                   }
[16:11:27.067]                 }
[16:11:27.067]             }
[16:11:27.067]         }))
[16:11:27.067]     }, error = function(ex) {
[16:11:27.067]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:27.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:27.067]                 ...future.rng), started = ...future.startTime, 
[16:11:27.067]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:27.067]             version = "1.8"), class = "FutureResult")
[16:11:27.067]     }, finally = {
[16:11:27.067]         if (!identical(...future.workdir, getwd())) 
[16:11:27.067]             setwd(...future.workdir)
[16:11:27.067]         {
[16:11:27.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:27.067]                 ...future.oldOptions$nwarnings <- NULL
[16:11:27.067]             }
[16:11:27.067]             base::options(...future.oldOptions)
[16:11:27.067]             if (.Platform$OS.type == "windows") {
[16:11:27.067]                 old_names <- names(...future.oldEnvVars)
[16:11:27.067]                 envs <- base::Sys.getenv()
[16:11:27.067]                 names <- names(envs)
[16:11:27.067]                 common <- intersect(names, old_names)
[16:11:27.067]                 added <- setdiff(names, old_names)
[16:11:27.067]                 removed <- setdiff(old_names, names)
[16:11:27.067]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:27.067]                   envs[common]]
[16:11:27.067]                 NAMES <- toupper(changed)
[16:11:27.067]                 args <- list()
[16:11:27.067]                 for (kk in seq_along(NAMES)) {
[16:11:27.067]                   name <- changed[[kk]]
[16:11:27.067]                   NAME <- NAMES[[kk]]
[16:11:27.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.067]                     next
[16:11:27.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:27.067]                 }
[16:11:27.067]                 NAMES <- toupper(added)
[16:11:27.067]                 for (kk in seq_along(NAMES)) {
[16:11:27.067]                   name <- added[[kk]]
[16:11:27.067]                   NAME <- NAMES[[kk]]
[16:11:27.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.067]                     next
[16:11:27.067]                   args[[name]] <- ""
[16:11:27.067]                 }
[16:11:27.067]                 NAMES <- toupper(removed)
[16:11:27.067]                 for (kk in seq_along(NAMES)) {
[16:11:27.067]                   name <- removed[[kk]]
[16:11:27.067]                   NAME <- NAMES[[kk]]
[16:11:27.067]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.067]                     next
[16:11:27.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:27.067]                 }
[16:11:27.067]                 if (length(args) > 0) 
[16:11:27.067]                   base::do.call(base::Sys.setenv, args = args)
[16:11:27.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:27.067]             }
[16:11:27.067]             else {
[16:11:27.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:27.067]             }
[16:11:27.067]             {
[16:11:27.067]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:27.067]                   0L) {
[16:11:27.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:27.067]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:27.067]                   base::options(opts)
[16:11:27.067]                 }
[16:11:27.067]                 {
[16:11:27.067]                   {
[16:11:27.067]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:27.067]                     NULL
[16:11:27.067]                   }
[16:11:27.067]                   options(future.plan = NULL)
[16:11:27.067]                   if (is.na(NA_character_)) 
[16:11:27.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:27.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:27.067]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:27.067]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:27.067]                     envir = parent.frame()) 
[16:11:27.067]                   {
[16:11:27.067]                     if (is.function(workers)) 
[16:11:27.067]                       workers <- workers()
[16:11:27.067]                     workers <- structure(as.integer(workers), 
[16:11:27.067]                       class = class(workers))
[16:11:27.067]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:27.067]                       workers >= 1)
[16:11:27.067]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:27.067]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:27.067]                     }
[16:11:27.067]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:27.067]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:27.067]                       envir = envir)
[16:11:27.067]                     if (!future$lazy) 
[16:11:27.067]                       future <- run(future)
[16:11:27.067]                     invisible(future)
[16:11:27.067]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:27.067]                 }
[16:11:27.067]             }
[16:11:27.067]         }
[16:11:27.067]     })
[16:11:27.067]     if (FALSE) {
[16:11:27.067]         base::sink(type = "output", split = FALSE)
[16:11:27.067]         if (NA) {
[16:11:27.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:27.067]         }
[16:11:27.067]         else {
[16:11:27.067]             ...future.result["stdout"] <- base::list(NULL)
[16:11:27.067]         }
[16:11:27.067]         base::close(...future.stdout)
[16:11:27.067]         ...future.stdout <- NULL
[16:11:27.067]     }
[16:11:27.067]     ...future.result$conditions <- ...future.conditions
[16:11:27.067]     ...future.result$finished <- base::Sys.time()
[16:11:27.067]     ...future.result
[16:11:27.067] }
[16:11:27.070] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:11:27.070] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:11:27.070] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:11:27.071] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:27.071] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:27.071] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:11:27.072] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:11:27.072] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:27.072] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:27.072] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:27.073] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:27.073] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:11:27.073] MultisessionFuture started
[16:11:27.074] - Launch lazy future ... done
[16:11:27.074] run() for ‘MultisessionFuture’ ... done
[16:11:27.074] Created future:
[16:11:27.074] MultisessionFuture:
[16:11:27.074] Label: ‘future_lapply-2’
[16:11:27.074] Expression:
[16:11:27.074] {
[16:11:27.074]     do.call(function(...) {
[16:11:27.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:27.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.074]             on.exit(options(oopts), add = TRUE)
[16:11:27.074]         }
[16:11:27.074]         {
[16:11:27.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:27.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:27.074]                 ...future.FUN(...future.X_jj, ...)
[16:11:27.074]             })
[16:11:27.074]         }
[16:11:27.074]     }, args = future.call.arguments)
[16:11:27.074] }
[16:11:27.074] Lazy evaluation: FALSE
[16:11:27.074] Asynchronous evaluation: TRUE
[16:11:27.074] Local evaluation: TRUE
[16:11:27.074] Environment: R_GlobalEnv
[16:11:27.074] Capture standard output: NA
[16:11:27.074] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:27.074] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:27.074] Packages: <none>
[16:11:27.074] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:27.074] Resolved: FALSE
[16:11:27.074] Value: <not collected>
[16:11:27.074] Conditions captured: <none>
[16:11:27.074] Early signaling: FALSE
[16:11:27.074] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:27.074] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:27.085] Chunk #2 of 2 ... DONE
[16:11:27.085] Launching 2 futures (chunks) ... DONE
[16:11:27.086] Resolving 2 futures (chunks) ...
[16:11:27.086] resolve() on list ...
[16:11:27.086]  recursive: 0
[16:11:27.086]  length: 2
[16:11:27.086] 
[16:11:27.128] receiveMessageFromWorker() for ClusterFuture ...
[16:11:27.128] - Validating connection of MultisessionFuture
[16:11:27.129] - received message: FutureResult
[16:11:27.129] - Received FutureResult
[16:11:27.129] - Erased future from FutureRegistry
[16:11:27.129] result() for ClusterFuture ...
[16:11:27.129] - result already collected: FutureResult
[16:11:27.129] result() for ClusterFuture ... done
[16:11:27.129] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:27.129] Future #2
[16:11:27.129] result() for ClusterFuture ...
[16:11:27.130] - result already collected: FutureResult
[16:11:27.130] result() for ClusterFuture ... done
[16:11:27.130] result() for ClusterFuture ...
[16:11:27.130] - result already collected: FutureResult
[16:11:27.130] result() for ClusterFuture ... done
[16:11:27.130] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:27.130] - nx: 2
[16:11:27.130] - relay: TRUE
[16:11:27.130] - stdout: TRUE
[16:11:27.130] - signal: TRUE
[16:11:27.130] - resignal: FALSE
[16:11:27.131] - force: TRUE
[16:11:27.131] - relayed: [n=2] FALSE, FALSE
[16:11:27.131] - queued futures: [n=2] FALSE, FALSE
[16:11:27.131]  - until=1
[16:11:27.131]  - relaying element #1
[16:11:27.131] - relayed: [n=2] FALSE, FALSE
[16:11:27.131] - queued futures: [n=2] FALSE, TRUE
[16:11:27.131] signalConditionsASAP(NULL, pos=2) ... done
[16:11:27.131]  length: 1 (resolved future 2)
[16:11:27.582] receiveMessageFromWorker() for ClusterFuture ...
[16:11:27.582] - Validating connection of MultisessionFuture
[16:11:27.582] - received message: FutureResult
[16:11:27.582] - Received FutureResult
[16:11:27.582] - Erased future from FutureRegistry
[16:11:27.582] result() for ClusterFuture ...
[16:11:27.583] - result already collected: FutureResult
[16:11:27.583] result() for ClusterFuture ... done
[16:11:27.583] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:27.583] Future #1
[16:11:27.583] result() for ClusterFuture ...
[16:11:27.583] - result already collected: FutureResult
[16:11:27.583] result() for ClusterFuture ... done
[16:11:27.583] result() for ClusterFuture ...
[16:11:27.583] - result already collected: FutureResult
[16:11:27.583] result() for ClusterFuture ... done
[16:11:27.583] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:27.584] - nx: 2
[16:11:27.584] - relay: TRUE
[16:11:27.584] - stdout: TRUE
[16:11:27.584] - signal: TRUE
[16:11:27.584] - resignal: FALSE
[16:11:27.584] - force: TRUE
[16:11:27.584] - relayed: [n=2] FALSE, FALSE
[16:11:27.584] - queued futures: [n=2] FALSE, TRUE
[16:11:27.584]  - until=1
[16:11:27.584]  - relaying element #1
[16:11:27.584] result() for ClusterFuture ...
[16:11:27.585] - result already collected: FutureResult
[16:11:27.585] result() for ClusterFuture ... done
[16:11:27.585] result() for ClusterFuture ...
[16:11:27.585] - result already collected: FutureResult
[16:11:27.585] result() for ClusterFuture ... done
[16:11:27.585] result() for ClusterFuture ...
[16:11:27.585] - result already collected: FutureResult
[16:11:27.585] result() for ClusterFuture ... done
[16:11:27.585] result() for ClusterFuture ...
[16:11:27.585] - result already collected: FutureResult
[16:11:27.585] result() for ClusterFuture ... done
[16:11:27.585] - relayed: [n=2] TRUE, FALSE
[16:11:27.586] - queued futures: [n=2] TRUE, TRUE
[16:11:27.586] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:27.586]  length: 0 (resolved future 1)
[16:11:27.586] Relaying remaining futures
[16:11:27.586] signalConditionsASAP(NULL, pos=0) ...
[16:11:27.586] - nx: 2
[16:11:27.586] - relay: TRUE
[16:11:27.586] - stdout: TRUE
[16:11:27.586] - signal: TRUE
[16:11:27.586] - resignal: FALSE
[16:11:27.586] - force: TRUE
[16:11:27.587] - relayed: [n=2] TRUE, FALSE
[16:11:27.587] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:27.587]  - relaying element #2
[16:11:27.587] result() for ClusterFuture ...
[16:11:27.587] - result already collected: FutureResult
[16:11:27.587] result() for ClusterFuture ... done
[16:11:27.587] result() for ClusterFuture ...
[16:11:27.587] - result already collected: FutureResult
[16:11:27.587] result() for ClusterFuture ... done
[16:11:27.587] result() for ClusterFuture ...
[16:11:27.587] - result already collected: FutureResult
[16:11:27.588] result() for ClusterFuture ... done
[16:11:27.588] result() for ClusterFuture ...
[16:11:27.588] - result already collected: FutureResult
[16:11:27.588] result() for ClusterFuture ... done
[16:11:27.588] - relayed: [n=2] TRUE, TRUE
[16:11:27.588] - queued futures: [n=2] TRUE, TRUE
[16:11:27.588] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:11:27.588] resolve() on list ... DONE
[16:11:27.588] result() for ClusterFuture ...
[16:11:27.588] - result already collected: FutureResult
[16:11:27.588] result() for ClusterFuture ... done
[16:11:27.589] result() for ClusterFuture ...
[16:11:27.589] - result already collected: FutureResult
[16:11:27.589] result() for ClusterFuture ... done
[16:11:27.589] result() for ClusterFuture ...
[16:11:27.589] - result already collected: FutureResult
[16:11:27.589] result() for ClusterFuture ... done
[16:11:27.589] result() for ClusterFuture ...
[16:11:27.589] - result already collected: FutureResult
[16:11:27.589] result() for ClusterFuture ... done
[16:11:27.589]  - Number of value chunks collected: 2
[16:11:27.589] Resolving 2 futures (chunks) ... DONE
[16:11:27.590] Reducing values from 2 chunks ...
[16:11:27.590]  - Number of values collected after concatenation: 2
[16:11:27.590]  - Number of values expected: 2
[16:11:27.590] Reducing values from 2 chunks ... DONE
[16:11:27.590] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:11:27.590] future_mapply() ...
[16:11:27.594] Number of chunks: 2
[16:11:27.594] getGlobalsAndPackagesXApply() ...
[16:11:27.594]  - future.globals: TRUE
[16:11:27.594] getGlobalsAndPackages() ...
[16:11:27.594] Searching for globals...
[16:11:27.596] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:27.596] Searching for globals ... DONE
[16:11:27.596] Resolving globals: FALSE
[16:11:27.597] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:27.597] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:27.597] - globals: [1] ‘FUN’
[16:11:27.597] 
[16:11:27.597] getGlobalsAndPackages() ... DONE
[16:11:27.597]  - globals found/used: [n=1] ‘FUN’
[16:11:27.598]  - needed namespaces: [n=0] 
[16:11:27.598] Finding globals ... DONE
[16:11:27.598] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:27.598] List of 2
[16:11:27.598]  $ ...future.FUN:function (x, y)  
[16:11:27.598]  $ MoreArgs     : NULL
[16:11:27.598]  - attr(*, "where")=List of 2
[16:11:27.598]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:27.598]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:27.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:27.598]  - attr(*, "resolved")= logi FALSE
[16:11:27.598]  - attr(*, "total_size")= num NA
[16:11:27.601] Packages to be attached in all futures: [n=0] 
[16:11:27.601] getGlobalsAndPackagesXApply() ... DONE
[16:11:27.601] Number of futures (= number of chunks): 2
[16:11:27.601] Launching 2 futures (chunks) ...
[16:11:27.601] Chunk #1 of 2 ...
[16:11:27.601]  - Finding globals in '...' for chunk #1 ...
[16:11:27.601] getGlobalsAndPackages() ...
[16:11:27.602] Searching for globals...
[16:11:27.602] 
[16:11:27.602] Searching for globals ... DONE
[16:11:27.602] - globals: [0] <none>
[16:11:27.602] getGlobalsAndPackages() ... DONE
[16:11:27.602]    + additional globals found: [n=0] 
[16:11:27.602]    + additional namespaces needed: [n=0] 
[16:11:27.602]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:27.603]  - seeds: <none>
[16:11:27.603] getGlobalsAndPackages() ...
[16:11:27.603] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:27.603] Resolving globals: FALSE
[16:11:27.603] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:27.606] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:27.606] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:27.606] 
[16:11:27.607] getGlobalsAndPackages() ... DONE
[16:11:27.607] run() for ‘Future’ ...
[16:11:27.607] - state: ‘created’
[16:11:27.607] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:27.623] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:27.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:27.623]   - Field: ‘node’
[16:11:27.623]   - Field: ‘label’
[16:11:27.623]   - Field: ‘local’
[16:11:27.623]   - Field: ‘owner’
[16:11:27.623]   - Field: ‘envir’
[16:11:27.623]   - Field: ‘workers’
[16:11:27.623]   - Field: ‘packages’
[16:11:27.623]   - Field: ‘gc’
[16:11:27.624]   - Field: ‘conditions’
[16:11:27.624]   - Field: ‘persistent’
[16:11:27.624]   - Field: ‘expr’
[16:11:27.624]   - Field: ‘uuid’
[16:11:27.624]   - Field: ‘seed’
[16:11:27.624]   - Field: ‘version’
[16:11:27.624]   - Field: ‘result’
[16:11:27.624]   - Field: ‘asynchronous’
[16:11:27.624]   - Field: ‘calls’
[16:11:27.624]   - Field: ‘globals’
[16:11:27.625]   - Field: ‘stdout’
[16:11:27.625]   - Field: ‘earlySignal’
[16:11:27.625]   - Field: ‘lazy’
[16:11:27.625]   - Field: ‘state’
[16:11:27.625] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:27.625] - Launch lazy future ...
[16:11:27.625] Packages needed by the future expression (n = 0): <none>
[16:11:27.625] Packages needed by future strategies (n = 0): <none>
[16:11:27.626] {
[16:11:27.626]     {
[16:11:27.626]         {
[16:11:27.626]             ...future.startTime <- base::Sys.time()
[16:11:27.626]             {
[16:11:27.626]                 {
[16:11:27.626]                   {
[16:11:27.626]                     {
[16:11:27.626]                       base::local({
[16:11:27.626]                         has_future <- base::requireNamespace("future", 
[16:11:27.626]                           quietly = TRUE)
[16:11:27.626]                         if (has_future) {
[16:11:27.626]                           ns <- base::getNamespace("future")
[16:11:27.626]                           version <- ns[[".package"]][["version"]]
[16:11:27.626]                           if (is.null(version)) 
[16:11:27.626]                             version <- utils::packageVersion("future")
[16:11:27.626]                         }
[16:11:27.626]                         else {
[16:11:27.626]                           version <- NULL
[16:11:27.626]                         }
[16:11:27.626]                         if (!has_future || version < "1.8.0") {
[16:11:27.626]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:27.626]                             "", base::R.version$version.string), 
[16:11:27.626]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:27.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:27.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:27.626]                               "release", "version")], collapse = " "), 
[16:11:27.626]                             hostname = base::Sys.info()[["nodename"]])
[16:11:27.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:27.626]                             info)
[16:11:27.626]                           info <- base::paste(info, collapse = "; ")
[16:11:27.626]                           if (!has_future) {
[16:11:27.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:27.626]                               info)
[16:11:27.626]                           }
[16:11:27.626]                           else {
[16:11:27.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:27.626]                               info, version)
[16:11:27.626]                           }
[16:11:27.626]                           base::stop(msg)
[16:11:27.626]                         }
[16:11:27.626]                       })
[16:11:27.626]                     }
[16:11:27.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:27.626]                     base::options(mc.cores = 1L)
[16:11:27.626]                   }
[16:11:27.626]                   options(future.plan = NULL)
[16:11:27.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:27.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:27.626]                 }
[16:11:27.626]                 ...future.workdir <- getwd()
[16:11:27.626]             }
[16:11:27.626]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:27.626]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:27.626]         }
[16:11:27.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:27.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:27.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:27.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:27.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:27.626]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:27.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:27.626]             base::names(...future.oldOptions))
[16:11:27.626]     }
[16:11:27.626]     if (FALSE) {
[16:11:27.626]     }
[16:11:27.626]     else {
[16:11:27.626]         if (FALSE) {
[16:11:27.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:27.626]                 open = "w")
[16:11:27.626]         }
[16:11:27.626]         else {
[16:11:27.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:27.626]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:27.626]         }
[16:11:27.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:27.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:27.626]             base::sink(type = "output", split = FALSE)
[16:11:27.626]             base::close(...future.stdout)
[16:11:27.626]         }, add = TRUE)
[16:11:27.626]     }
[16:11:27.626]     ...future.frame <- base::sys.nframe()
[16:11:27.626]     ...future.conditions <- base::list()
[16:11:27.626]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:27.626]     if (FALSE) {
[16:11:27.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:27.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:27.626]     }
[16:11:27.626]     ...future.result <- base::tryCatch({
[16:11:27.626]         base::withCallingHandlers({
[16:11:27.626]             ...future.value <- base::withVisible(base::local({
[16:11:27.626]                 ...future.makeSendCondition <- local({
[16:11:27.626]                   sendCondition <- NULL
[16:11:27.626]                   function(frame = 1L) {
[16:11:27.626]                     if (is.function(sendCondition)) 
[16:11:27.626]                       return(sendCondition)
[16:11:27.626]                     ns <- getNamespace("parallel")
[16:11:27.626]                     if (exists("sendData", mode = "function", 
[16:11:27.626]                       envir = ns)) {
[16:11:27.626]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:27.626]                         envir = ns)
[16:11:27.626]                       envir <- sys.frame(frame)
[16:11:27.626]                       master <- NULL
[16:11:27.626]                       while (!identical(envir, .GlobalEnv) && 
[16:11:27.626]                         !identical(envir, emptyenv())) {
[16:11:27.626]                         if (exists("master", mode = "list", envir = envir, 
[16:11:27.626]                           inherits = FALSE)) {
[16:11:27.626]                           master <- get("master", mode = "list", 
[16:11:27.626]                             envir = envir, inherits = FALSE)
[16:11:27.626]                           if (inherits(master, c("SOCKnode", 
[16:11:27.626]                             "SOCK0node"))) {
[16:11:27.626]                             sendCondition <<- function(cond) {
[16:11:27.626]                               data <- list(type = "VALUE", value = cond, 
[16:11:27.626]                                 success = TRUE)
[16:11:27.626]                               parallel_sendData(master, data)
[16:11:27.626]                             }
[16:11:27.626]                             return(sendCondition)
[16:11:27.626]                           }
[16:11:27.626]                         }
[16:11:27.626]                         frame <- frame + 1L
[16:11:27.626]                         envir <- sys.frame(frame)
[16:11:27.626]                       }
[16:11:27.626]                     }
[16:11:27.626]                     sendCondition <<- function(cond) NULL
[16:11:27.626]                   }
[16:11:27.626]                 })
[16:11:27.626]                 withCallingHandlers({
[16:11:27.626]                   {
[16:11:27.626]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.626]                     if (!identical(...future.globals.maxSize.org, 
[16:11:27.626]                       ...future.globals.maxSize)) {
[16:11:27.626]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.626]                       on.exit(options(oopts), add = TRUE)
[16:11:27.626]                     }
[16:11:27.626]                     {
[16:11:27.626]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:27.626]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:27.626]                         USE.NAMES = FALSE)
[16:11:27.626]                       do.call(mapply, args = args)
[16:11:27.626]                     }
[16:11:27.626]                   }
[16:11:27.626]                 }, immediateCondition = function(cond) {
[16:11:27.626]                   sendCondition <- ...future.makeSendCondition()
[16:11:27.626]                   sendCondition(cond)
[16:11:27.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.626]                   {
[16:11:27.626]                     inherits <- base::inherits
[16:11:27.626]                     invokeRestart <- base::invokeRestart
[16:11:27.626]                     is.null <- base::is.null
[16:11:27.626]                     muffled <- FALSE
[16:11:27.626]                     if (inherits(cond, "message")) {
[16:11:27.626]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:27.626]                       if (muffled) 
[16:11:27.626]                         invokeRestart("muffleMessage")
[16:11:27.626]                     }
[16:11:27.626]                     else if (inherits(cond, "warning")) {
[16:11:27.626]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:27.626]                       if (muffled) 
[16:11:27.626]                         invokeRestart("muffleWarning")
[16:11:27.626]                     }
[16:11:27.626]                     else if (inherits(cond, "condition")) {
[16:11:27.626]                       if (!is.null(pattern)) {
[16:11:27.626]                         computeRestarts <- base::computeRestarts
[16:11:27.626]                         grepl <- base::grepl
[16:11:27.626]                         restarts <- computeRestarts(cond)
[16:11:27.626]                         for (restart in restarts) {
[16:11:27.626]                           name <- restart$name
[16:11:27.626]                           if (is.null(name)) 
[16:11:27.626]                             next
[16:11:27.626]                           if (!grepl(pattern, name)) 
[16:11:27.626]                             next
[16:11:27.626]                           invokeRestart(restart)
[16:11:27.626]                           muffled <- TRUE
[16:11:27.626]                           break
[16:11:27.626]                         }
[16:11:27.626]                       }
[16:11:27.626]                     }
[16:11:27.626]                     invisible(muffled)
[16:11:27.626]                   }
[16:11:27.626]                   muffleCondition(cond)
[16:11:27.626]                 })
[16:11:27.626]             }))
[16:11:27.626]             future::FutureResult(value = ...future.value$value, 
[16:11:27.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:27.626]                   ...future.rng), globalenv = if (FALSE) 
[16:11:27.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:27.626]                     ...future.globalenv.names))
[16:11:27.626]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:27.626]         }, condition = base::local({
[16:11:27.626]             c <- base::c
[16:11:27.626]             inherits <- base::inherits
[16:11:27.626]             invokeRestart <- base::invokeRestart
[16:11:27.626]             length <- base::length
[16:11:27.626]             list <- base::list
[16:11:27.626]             seq.int <- base::seq.int
[16:11:27.626]             signalCondition <- base::signalCondition
[16:11:27.626]             sys.calls <- base::sys.calls
[16:11:27.626]             `[[` <- base::`[[`
[16:11:27.626]             `+` <- base::`+`
[16:11:27.626]             `<<-` <- base::`<<-`
[16:11:27.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:27.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:27.626]                   3L)]
[16:11:27.626]             }
[16:11:27.626]             function(cond) {
[16:11:27.626]                 is_error <- inherits(cond, "error")
[16:11:27.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:27.626]                   NULL)
[16:11:27.626]                 if (is_error) {
[16:11:27.626]                   sessionInformation <- function() {
[16:11:27.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:27.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:27.626]                       search = base::search(), system = base::Sys.info())
[16:11:27.626]                   }
[16:11:27.626]                   ...future.conditions[[length(...future.conditions) + 
[16:11:27.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:27.626]                     cond$call), session = sessionInformation(), 
[16:11:27.626]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:27.626]                   signalCondition(cond)
[16:11:27.626]                 }
[16:11:27.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:27.626]                 "immediateCondition"))) {
[16:11:27.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:27.626]                   ...future.conditions[[length(...future.conditions) + 
[16:11:27.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:27.626]                   if (TRUE && !signal) {
[16:11:27.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.626]                     {
[16:11:27.626]                       inherits <- base::inherits
[16:11:27.626]                       invokeRestart <- base::invokeRestart
[16:11:27.626]                       is.null <- base::is.null
[16:11:27.626]                       muffled <- FALSE
[16:11:27.626]                       if (inherits(cond, "message")) {
[16:11:27.626]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:27.626]                         if (muffled) 
[16:11:27.626]                           invokeRestart("muffleMessage")
[16:11:27.626]                       }
[16:11:27.626]                       else if (inherits(cond, "warning")) {
[16:11:27.626]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:27.626]                         if (muffled) 
[16:11:27.626]                           invokeRestart("muffleWarning")
[16:11:27.626]                       }
[16:11:27.626]                       else if (inherits(cond, "condition")) {
[16:11:27.626]                         if (!is.null(pattern)) {
[16:11:27.626]                           computeRestarts <- base::computeRestarts
[16:11:27.626]                           grepl <- base::grepl
[16:11:27.626]                           restarts <- computeRestarts(cond)
[16:11:27.626]                           for (restart in restarts) {
[16:11:27.626]                             name <- restart$name
[16:11:27.626]                             if (is.null(name)) 
[16:11:27.626]                               next
[16:11:27.626]                             if (!grepl(pattern, name)) 
[16:11:27.626]                               next
[16:11:27.626]                             invokeRestart(restart)
[16:11:27.626]                             muffled <- TRUE
[16:11:27.626]                             break
[16:11:27.626]                           }
[16:11:27.626]                         }
[16:11:27.626]                       }
[16:11:27.626]                       invisible(muffled)
[16:11:27.626]                     }
[16:11:27.626]                     muffleCondition(cond, pattern = "^muffle")
[16:11:27.626]                   }
[16:11:27.626]                 }
[16:11:27.626]                 else {
[16:11:27.626]                   if (TRUE) {
[16:11:27.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.626]                     {
[16:11:27.626]                       inherits <- base::inherits
[16:11:27.626]                       invokeRestart <- base::invokeRestart
[16:11:27.626]                       is.null <- base::is.null
[16:11:27.626]                       muffled <- FALSE
[16:11:27.626]                       if (inherits(cond, "message")) {
[16:11:27.626]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:27.626]                         if (muffled) 
[16:11:27.626]                           invokeRestart("muffleMessage")
[16:11:27.626]                       }
[16:11:27.626]                       else if (inherits(cond, "warning")) {
[16:11:27.626]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:27.626]                         if (muffled) 
[16:11:27.626]                           invokeRestart("muffleWarning")
[16:11:27.626]                       }
[16:11:27.626]                       else if (inherits(cond, "condition")) {
[16:11:27.626]                         if (!is.null(pattern)) {
[16:11:27.626]                           computeRestarts <- base::computeRestarts
[16:11:27.626]                           grepl <- base::grepl
[16:11:27.626]                           restarts <- computeRestarts(cond)
[16:11:27.626]                           for (restart in restarts) {
[16:11:27.626]                             name <- restart$name
[16:11:27.626]                             if (is.null(name)) 
[16:11:27.626]                               next
[16:11:27.626]                             if (!grepl(pattern, name)) 
[16:11:27.626]                               next
[16:11:27.626]                             invokeRestart(restart)
[16:11:27.626]                             muffled <- TRUE
[16:11:27.626]                             break
[16:11:27.626]                           }
[16:11:27.626]                         }
[16:11:27.626]                       }
[16:11:27.626]                       invisible(muffled)
[16:11:27.626]                     }
[16:11:27.626]                     muffleCondition(cond, pattern = "^muffle")
[16:11:27.626]                   }
[16:11:27.626]                 }
[16:11:27.626]             }
[16:11:27.626]         }))
[16:11:27.626]     }, error = function(ex) {
[16:11:27.626]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:27.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:27.626]                 ...future.rng), started = ...future.startTime, 
[16:11:27.626]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:27.626]             version = "1.8"), class = "FutureResult")
[16:11:27.626]     }, finally = {
[16:11:27.626]         if (!identical(...future.workdir, getwd())) 
[16:11:27.626]             setwd(...future.workdir)
[16:11:27.626]         {
[16:11:27.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:27.626]                 ...future.oldOptions$nwarnings <- NULL
[16:11:27.626]             }
[16:11:27.626]             base::options(...future.oldOptions)
[16:11:27.626]             if (.Platform$OS.type == "windows") {
[16:11:27.626]                 old_names <- names(...future.oldEnvVars)
[16:11:27.626]                 envs <- base::Sys.getenv()
[16:11:27.626]                 names <- names(envs)
[16:11:27.626]                 common <- intersect(names, old_names)
[16:11:27.626]                 added <- setdiff(names, old_names)
[16:11:27.626]                 removed <- setdiff(old_names, names)
[16:11:27.626]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:27.626]                   envs[common]]
[16:11:27.626]                 NAMES <- toupper(changed)
[16:11:27.626]                 args <- list()
[16:11:27.626]                 for (kk in seq_along(NAMES)) {
[16:11:27.626]                   name <- changed[[kk]]
[16:11:27.626]                   NAME <- NAMES[[kk]]
[16:11:27.626]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.626]                     next
[16:11:27.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:27.626]                 }
[16:11:27.626]                 NAMES <- toupper(added)
[16:11:27.626]                 for (kk in seq_along(NAMES)) {
[16:11:27.626]                   name <- added[[kk]]
[16:11:27.626]                   NAME <- NAMES[[kk]]
[16:11:27.626]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.626]                     next
[16:11:27.626]                   args[[name]] <- ""
[16:11:27.626]                 }
[16:11:27.626]                 NAMES <- toupper(removed)
[16:11:27.626]                 for (kk in seq_along(NAMES)) {
[16:11:27.626]                   name <- removed[[kk]]
[16:11:27.626]                   NAME <- NAMES[[kk]]
[16:11:27.626]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.626]                     next
[16:11:27.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:27.626]                 }
[16:11:27.626]                 if (length(args) > 0) 
[16:11:27.626]                   base::do.call(base::Sys.setenv, args = args)
[16:11:27.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:27.626]             }
[16:11:27.626]             else {
[16:11:27.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:27.626]             }
[16:11:27.626]             {
[16:11:27.626]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:27.626]                   0L) {
[16:11:27.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:27.626]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:27.626]                   base::options(opts)
[16:11:27.626]                 }
[16:11:27.626]                 {
[16:11:27.626]                   {
[16:11:27.626]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:27.626]                     NULL
[16:11:27.626]                   }
[16:11:27.626]                   options(future.plan = NULL)
[16:11:27.626]                   if (is.na(NA_character_)) 
[16:11:27.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:27.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:27.626]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:27.626]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:27.626]                     envir = parent.frame()) 
[16:11:27.626]                   {
[16:11:27.626]                     if (is.function(workers)) 
[16:11:27.626]                       workers <- workers()
[16:11:27.626]                     workers <- structure(as.integer(workers), 
[16:11:27.626]                       class = class(workers))
[16:11:27.626]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:27.626]                       workers >= 1)
[16:11:27.626]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:27.626]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:27.626]                     }
[16:11:27.626]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:27.626]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:27.626]                       envir = envir)
[16:11:27.626]                     if (!future$lazy) 
[16:11:27.626]                       future <- run(future)
[16:11:27.626]                     invisible(future)
[16:11:27.626]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:27.626]                 }
[16:11:27.626]             }
[16:11:27.626]         }
[16:11:27.626]     })
[16:11:27.626]     if (TRUE) {
[16:11:27.626]         base::sink(type = "output", split = FALSE)
[16:11:27.626]         if (FALSE) {
[16:11:27.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:27.626]         }
[16:11:27.626]         else {
[16:11:27.626]             ...future.result["stdout"] <- base::list(NULL)
[16:11:27.626]         }
[16:11:27.626]         base::close(...future.stdout)
[16:11:27.626]         ...future.stdout <- NULL
[16:11:27.626]     }
[16:11:27.626]     ...future.result$conditions <- ...future.conditions
[16:11:27.626]     ...future.result$finished <- base::Sys.time()
[16:11:27.626]     ...future.result
[16:11:27.626] }
[16:11:27.629] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:11:27.629] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:11:27.629] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:11:27.629] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:11:27.630] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:11:27.630] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:11:27.630] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:11:27.630] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:27.631] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:27.631] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:27.631] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:27.631] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:11:27.632] MultisessionFuture started
[16:11:27.632] - Launch lazy future ... done
[16:11:27.632] run() for ‘MultisessionFuture’ ... done
[16:11:27.632] Created future:
[16:11:27.633] MultisessionFuture:
[16:11:27.633] Label: ‘future_mapply-1’
[16:11:27.633] Expression:
[16:11:27.633] {
[16:11:27.633]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.633]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:27.633]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.633]         on.exit(options(oopts), add = TRUE)
[16:11:27.633]     }
[16:11:27.633]     {
[16:11:27.633]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:27.633]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:27.633]         do.call(mapply, args = args)
[16:11:27.633]     }
[16:11:27.633] }
[16:11:27.633] Lazy evaluation: FALSE
[16:11:27.633] Asynchronous evaluation: TRUE
[16:11:27.633] Local evaluation: TRUE
[16:11:27.633] Environment: R_GlobalEnv
[16:11:27.633] Capture standard output: FALSE
[16:11:27.633] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:27.633] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:27.633] Packages: <none>
[16:11:27.633] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:27.633] Resolved: FALSE
[16:11:27.633] Value: <not collected>
[16:11:27.633] Conditions captured: <none>
[16:11:27.633] Early signaling: FALSE
[16:11:27.633] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:27.633] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:27.644] Chunk #1 of 2 ... DONE
[16:11:27.644] Chunk #2 of 2 ...
[16:11:27.645]  - Finding globals in '...' for chunk #2 ...
[16:11:27.645] getGlobalsAndPackages() ...
[16:11:27.645] Searching for globals...
[16:11:27.645] 
[16:11:27.645] Searching for globals ... DONE
[16:11:27.645] - globals: [0] <none>
[16:11:27.645] getGlobalsAndPackages() ... DONE
[16:11:27.646]    + additional globals found: [n=0] 
[16:11:27.646]    + additional namespaces needed: [n=0] 
[16:11:27.646]  - Finding globals in '...' for chunk #2 ... DONE
[16:11:27.646]  - seeds: <none>
[16:11:27.646] getGlobalsAndPackages() ...
[16:11:27.646] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:27.646] Resolving globals: FALSE
[16:11:27.647] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:27.647] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:27.647] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:27.647] 
[16:11:27.647] getGlobalsAndPackages() ... DONE
[16:11:27.648] run() for ‘Future’ ...
[16:11:27.648] - state: ‘created’
[16:11:27.648] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:27.663] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:27.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:27.664]   - Field: ‘node’
[16:11:27.664]   - Field: ‘label’
[16:11:27.664]   - Field: ‘local’
[16:11:27.664]   - Field: ‘owner’
[16:11:27.664]   - Field: ‘envir’
[16:11:27.664]   - Field: ‘workers’
[16:11:27.664]   - Field: ‘packages’
[16:11:27.664]   - Field: ‘gc’
[16:11:27.665]   - Field: ‘conditions’
[16:11:27.665]   - Field: ‘persistent’
[16:11:27.665]   - Field: ‘expr’
[16:11:27.665]   - Field: ‘uuid’
[16:11:27.665]   - Field: ‘seed’
[16:11:27.665]   - Field: ‘version’
[16:11:27.665]   - Field: ‘result’
[16:11:27.665]   - Field: ‘asynchronous’
[16:11:27.665]   - Field: ‘calls’
[16:11:27.665]   - Field: ‘globals’
[16:11:27.665]   - Field: ‘stdout’
[16:11:27.666]   - Field: ‘earlySignal’
[16:11:27.666]   - Field: ‘lazy’
[16:11:27.666]   - Field: ‘state’
[16:11:27.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:27.666] - Launch lazy future ...
[16:11:27.666] Packages needed by the future expression (n = 0): <none>
[16:11:27.666] Packages needed by future strategies (n = 0): <none>
[16:11:27.667] {
[16:11:27.667]     {
[16:11:27.667]         {
[16:11:27.667]             ...future.startTime <- base::Sys.time()
[16:11:27.667]             {
[16:11:27.667]                 {
[16:11:27.667]                   {
[16:11:27.667]                     {
[16:11:27.667]                       base::local({
[16:11:27.667]                         has_future <- base::requireNamespace("future", 
[16:11:27.667]                           quietly = TRUE)
[16:11:27.667]                         if (has_future) {
[16:11:27.667]                           ns <- base::getNamespace("future")
[16:11:27.667]                           version <- ns[[".package"]][["version"]]
[16:11:27.667]                           if (is.null(version)) 
[16:11:27.667]                             version <- utils::packageVersion("future")
[16:11:27.667]                         }
[16:11:27.667]                         else {
[16:11:27.667]                           version <- NULL
[16:11:27.667]                         }
[16:11:27.667]                         if (!has_future || version < "1.8.0") {
[16:11:27.667]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:27.667]                             "", base::R.version$version.string), 
[16:11:27.667]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:27.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:27.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:27.667]                               "release", "version")], collapse = " "), 
[16:11:27.667]                             hostname = base::Sys.info()[["nodename"]])
[16:11:27.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:27.667]                             info)
[16:11:27.667]                           info <- base::paste(info, collapse = "; ")
[16:11:27.667]                           if (!has_future) {
[16:11:27.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:27.667]                               info)
[16:11:27.667]                           }
[16:11:27.667]                           else {
[16:11:27.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:27.667]                               info, version)
[16:11:27.667]                           }
[16:11:27.667]                           base::stop(msg)
[16:11:27.667]                         }
[16:11:27.667]                       })
[16:11:27.667]                     }
[16:11:27.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:27.667]                     base::options(mc.cores = 1L)
[16:11:27.667]                   }
[16:11:27.667]                   options(future.plan = NULL)
[16:11:27.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:27.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:27.667]                 }
[16:11:27.667]                 ...future.workdir <- getwd()
[16:11:27.667]             }
[16:11:27.667]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:27.667]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:27.667]         }
[16:11:27.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:27.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:27.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:27.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:27.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:27.667]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:27.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:27.667]             base::names(...future.oldOptions))
[16:11:27.667]     }
[16:11:27.667]     if (FALSE) {
[16:11:27.667]     }
[16:11:27.667]     else {
[16:11:27.667]         if (FALSE) {
[16:11:27.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:27.667]                 open = "w")
[16:11:27.667]         }
[16:11:27.667]         else {
[16:11:27.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:27.667]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:27.667]         }
[16:11:27.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:27.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:27.667]             base::sink(type = "output", split = FALSE)
[16:11:27.667]             base::close(...future.stdout)
[16:11:27.667]         }, add = TRUE)
[16:11:27.667]     }
[16:11:27.667]     ...future.frame <- base::sys.nframe()
[16:11:27.667]     ...future.conditions <- base::list()
[16:11:27.667]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:27.667]     if (FALSE) {
[16:11:27.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:27.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:27.667]     }
[16:11:27.667]     ...future.result <- base::tryCatch({
[16:11:27.667]         base::withCallingHandlers({
[16:11:27.667]             ...future.value <- base::withVisible(base::local({
[16:11:27.667]                 ...future.makeSendCondition <- local({
[16:11:27.667]                   sendCondition <- NULL
[16:11:27.667]                   function(frame = 1L) {
[16:11:27.667]                     if (is.function(sendCondition)) 
[16:11:27.667]                       return(sendCondition)
[16:11:27.667]                     ns <- getNamespace("parallel")
[16:11:27.667]                     if (exists("sendData", mode = "function", 
[16:11:27.667]                       envir = ns)) {
[16:11:27.667]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:27.667]                         envir = ns)
[16:11:27.667]                       envir <- sys.frame(frame)
[16:11:27.667]                       master <- NULL
[16:11:27.667]                       while (!identical(envir, .GlobalEnv) && 
[16:11:27.667]                         !identical(envir, emptyenv())) {
[16:11:27.667]                         if (exists("master", mode = "list", envir = envir, 
[16:11:27.667]                           inherits = FALSE)) {
[16:11:27.667]                           master <- get("master", mode = "list", 
[16:11:27.667]                             envir = envir, inherits = FALSE)
[16:11:27.667]                           if (inherits(master, c("SOCKnode", 
[16:11:27.667]                             "SOCK0node"))) {
[16:11:27.667]                             sendCondition <<- function(cond) {
[16:11:27.667]                               data <- list(type = "VALUE", value = cond, 
[16:11:27.667]                                 success = TRUE)
[16:11:27.667]                               parallel_sendData(master, data)
[16:11:27.667]                             }
[16:11:27.667]                             return(sendCondition)
[16:11:27.667]                           }
[16:11:27.667]                         }
[16:11:27.667]                         frame <- frame + 1L
[16:11:27.667]                         envir <- sys.frame(frame)
[16:11:27.667]                       }
[16:11:27.667]                     }
[16:11:27.667]                     sendCondition <<- function(cond) NULL
[16:11:27.667]                   }
[16:11:27.667]                 })
[16:11:27.667]                 withCallingHandlers({
[16:11:27.667]                   {
[16:11:27.667]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.667]                     if (!identical(...future.globals.maxSize.org, 
[16:11:27.667]                       ...future.globals.maxSize)) {
[16:11:27.667]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.667]                       on.exit(options(oopts), add = TRUE)
[16:11:27.667]                     }
[16:11:27.667]                     {
[16:11:27.667]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:27.667]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:27.667]                         USE.NAMES = FALSE)
[16:11:27.667]                       do.call(mapply, args = args)
[16:11:27.667]                     }
[16:11:27.667]                   }
[16:11:27.667]                 }, immediateCondition = function(cond) {
[16:11:27.667]                   sendCondition <- ...future.makeSendCondition()
[16:11:27.667]                   sendCondition(cond)
[16:11:27.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.667]                   {
[16:11:27.667]                     inherits <- base::inherits
[16:11:27.667]                     invokeRestart <- base::invokeRestart
[16:11:27.667]                     is.null <- base::is.null
[16:11:27.667]                     muffled <- FALSE
[16:11:27.667]                     if (inherits(cond, "message")) {
[16:11:27.667]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:27.667]                       if (muffled) 
[16:11:27.667]                         invokeRestart("muffleMessage")
[16:11:27.667]                     }
[16:11:27.667]                     else if (inherits(cond, "warning")) {
[16:11:27.667]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:27.667]                       if (muffled) 
[16:11:27.667]                         invokeRestart("muffleWarning")
[16:11:27.667]                     }
[16:11:27.667]                     else if (inherits(cond, "condition")) {
[16:11:27.667]                       if (!is.null(pattern)) {
[16:11:27.667]                         computeRestarts <- base::computeRestarts
[16:11:27.667]                         grepl <- base::grepl
[16:11:27.667]                         restarts <- computeRestarts(cond)
[16:11:27.667]                         for (restart in restarts) {
[16:11:27.667]                           name <- restart$name
[16:11:27.667]                           if (is.null(name)) 
[16:11:27.667]                             next
[16:11:27.667]                           if (!grepl(pattern, name)) 
[16:11:27.667]                             next
[16:11:27.667]                           invokeRestart(restart)
[16:11:27.667]                           muffled <- TRUE
[16:11:27.667]                           break
[16:11:27.667]                         }
[16:11:27.667]                       }
[16:11:27.667]                     }
[16:11:27.667]                     invisible(muffled)
[16:11:27.667]                   }
[16:11:27.667]                   muffleCondition(cond)
[16:11:27.667]                 })
[16:11:27.667]             }))
[16:11:27.667]             future::FutureResult(value = ...future.value$value, 
[16:11:27.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:27.667]                   ...future.rng), globalenv = if (FALSE) 
[16:11:27.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:27.667]                     ...future.globalenv.names))
[16:11:27.667]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:27.667]         }, condition = base::local({
[16:11:27.667]             c <- base::c
[16:11:27.667]             inherits <- base::inherits
[16:11:27.667]             invokeRestart <- base::invokeRestart
[16:11:27.667]             length <- base::length
[16:11:27.667]             list <- base::list
[16:11:27.667]             seq.int <- base::seq.int
[16:11:27.667]             signalCondition <- base::signalCondition
[16:11:27.667]             sys.calls <- base::sys.calls
[16:11:27.667]             `[[` <- base::`[[`
[16:11:27.667]             `+` <- base::`+`
[16:11:27.667]             `<<-` <- base::`<<-`
[16:11:27.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:27.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:27.667]                   3L)]
[16:11:27.667]             }
[16:11:27.667]             function(cond) {
[16:11:27.667]                 is_error <- inherits(cond, "error")
[16:11:27.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:27.667]                   NULL)
[16:11:27.667]                 if (is_error) {
[16:11:27.667]                   sessionInformation <- function() {
[16:11:27.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:27.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:27.667]                       search = base::search(), system = base::Sys.info())
[16:11:27.667]                   }
[16:11:27.667]                   ...future.conditions[[length(...future.conditions) + 
[16:11:27.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:27.667]                     cond$call), session = sessionInformation(), 
[16:11:27.667]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:27.667]                   signalCondition(cond)
[16:11:27.667]                 }
[16:11:27.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:27.667]                 "immediateCondition"))) {
[16:11:27.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:27.667]                   ...future.conditions[[length(...future.conditions) + 
[16:11:27.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:27.667]                   if (TRUE && !signal) {
[16:11:27.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.667]                     {
[16:11:27.667]                       inherits <- base::inherits
[16:11:27.667]                       invokeRestart <- base::invokeRestart
[16:11:27.667]                       is.null <- base::is.null
[16:11:27.667]                       muffled <- FALSE
[16:11:27.667]                       if (inherits(cond, "message")) {
[16:11:27.667]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:27.667]                         if (muffled) 
[16:11:27.667]                           invokeRestart("muffleMessage")
[16:11:27.667]                       }
[16:11:27.667]                       else if (inherits(cond, "warning")) {
[16:11:27.667]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:27.667]                         if (muffled) 
[16:11:27.667]                           invokeRestart("muffleWarning")
[16:11:27.667]                       }
[16:11:27.667]                       else if (inherits(cond, "condition")) {
[16:11:27.667]                         if (!is.null(pattern)) {
[16:11:27.667]                           computeRestarts <- base::computeRestarts
[16:11:27.667]                           grepl <- base::grepl
[16:11:27.667]                           restarts <- computeRestarts(cond)
[16:11:27.667]                           for (restart in restarts) {
[16:11:27.667]                             name <- restart$name
[16:11:27.667]                             if (is.null(name)) 
[16:11:27.667]                               next
[16:11:27.667]                             if (!grepl(pattern, name)) 
[16:11:27.667]                               next
[16:11:27.667]                             invokeRestart(restart)
[16:11:27.667]                             muffled <- TRUE
[16:11:27.667]                             break
[16:11:27.667]                           }
[16:11:27.667]                         }
[16:11:27.667]                       }
[16:11:27.667]                       invisible(muffled)
[16:11:27.667]                     }
[16:11:27.667]                     muffleCondition(cond, pattern = "^muffle")
[16:11:27.667]                   }
[16:11:27.667]                 }
[16:11:27.667]                 else {
[16:11:27.667]                   if (TRUE) {
[16:11:27.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:27.667]                     {
[16:11:27.667]                       inherits <- base::inherits
[16:11:27.667]                       invokeRestart <- base::invokeRestart
[16:11:27.667]                       is.null <- base::is.null
[16:11:27.667]                       muffled <- FALSE
[16:11:27.667]                       if (inherits(cond, "message")) {
[16:11:27.667]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:27.667]                         if (muffled) 
[16:11:27.667]                           invokeRestart("muffleMessage")
[16:11:27.667]                       }
[16:11:27.667]                       else if (inherits(cond, "warning")) {
[16:11:27.667]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:27.667]                         if (muffled) 
[16:11:27.667]                           invokeRestart("muffleWarning")
[16:11:27.667]                       }
[16:11:27.667]                       else if (inherits(cond, "condition")) {
[16:11:27.667]                         if (!is.null(pattern)) {
[16:11:27.667]                           computeRestarts <- base::computeRestarts
[16:11:27.667]                           grepl <- base::grepl
[16:11:27.667]                           restarts <- computeRestarts(cond)
[16:11:27.667]                           for (restart in restarts) {
[16:11:27.667]                             name <- restart$name
[16:11:27.667]                             if (is.null(name)) 
[16:11:27.667]                               next
[16:11:27.667]                             if (!grepl(pattern, name)) 
[16:11:27.667]                               next
[16:11:27.667]                             invokeRestart(restart)
[16:11:27.667]                             muffled <- TRUE
[16:11:27.667]                             break
[16:11:27.667]                           }
[16:11:27.667]                         }
[16:11:27.667]                       }
[16:11:27.667]                       invisible(muffled)
[16:11:27.667]                     }
[16:11:27.667]                     muffleCondition(cond, pattern = "^muffle")
[16:11:27.667]                   }
[16:11:27.667]                 }
[16:11:27.667]             }
[16:11:27.667]         }))
[16:11:27.667]     }, error = function(ex) {
[16:11:27.667]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:27.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:27.667]                 ...future.rng), started = ...future.startTime, 
[16:11:27.667]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:27.667]             version = "1.8"), class = "FutureResult")
[16:11:27.667]     }, finally = {
[16:11:27.667]         if (!identical(...future.workdir, getwd())) 
[16:11:27.667]             setwd(...future.workdir)
[16:11:27.667]         {
[16:11:27.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:27.667]                 ...future.oldOptions$nwarnings <- NULL
[16:11:27.667]             }
[16:11:27.667]             base::options(...future.oldOptions)
[16:11:27.667]             if (.Platform$OS.type == "windows") {
[16:11:27.667]                 old_names <- names(...future.oldEnvVars)
[16:11:27.667]                 envs <- base::Sys.getenv()
[16:11:27.667]                 names <- names(envs)
[16:11:27.667]                 common <- intersect(names, old_names)
[16:11:27.667]                 added <- setdiff(names, old_names)
[16:11:27.667]                 removed <- setdiff(old_names, names)
[16:11:27.667]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:27.667]                   envs[common]]
[16:11:27.667]                 NAMES <- toupper(changed)
[16:11:27.667]                 args <- list()
[16:11:27.667]                 for (kk in seq_along(NAMES)) {
[16:11:27.667]                   name <- changed[[kk]]
[16:11:27.667]                   NAME <- NAMES[[kk]]
[16:11:27.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.667]                     next
[16:11:27.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:27.667]                 }
[16:11:27.667]                 NAMES <- toupper(added)
[16:11:27.667]                 for (kk in seq_along(NAMES)) {
[16:11:27.667]                   name <- added[[kk]]
[16:11:27.667]                   NAME <- NAMES[[kk]]
[16:11:27.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.667]                     next
[16:11:27.667]                   args[[name]] <- ""
[16:11:27.667]                 }
[16:11:27.667]                 NAMES <- toupper(removed)
[16:11:27.667]                 for (kk in seq_along(NAMES)) {
[16:11:27.667]                   name <- removed[[kk]]
[16:11:27.667]                   NAME <- NAMES[[kk]]
[16:11:27.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:27.667]                     next
[16:11:27.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:27.667]                 }
[16:11:27.667]                 if (length(args) > 0) 
[16:11:27.667]                   base::do.call(base::Sys.setenv, args = args)
[16:11:27.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:27.667]             }
[16:11:27.667]             else {
[16:11:27.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:27.667]             }
[16:11:27.667]             {
[16:11:27.667]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:27.667]                   0L) {
[16:11:27.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:27.667]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:27.667]                   base::options(opts)
[16:11:27.667]                 }
[16:11:27.667]                 {
[16:11:27.667]                   {
[16:11:27.667]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:27.667]                     NULL
[16:11:27.667]                   }
[16:11:27.667]                   options(future.plan = NULL)
[16:11:27.667]                   if (is.na(NA_character_)) 
[16:11:27.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:27.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:27.667]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:27.667]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:27.667]                     envir = parent.frame()) 
[16:11:27.667]                   {
[16:11:27.667]                     if (is.function(workers)) 
[16:11:27.667]                       workers <- workers()
[16:11:27.667]                     workers <- structure(as.integer(workers), 
[16:11:27.667]                       class = class(workers))
[16:11:27.667]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:27.667]                       workers >= 1)
[16:11:27.667]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:27.667]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:27.667]                     }
[16:11:27.667]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:27.667]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:27.667]                       envir = envir)
[16:11:27.667]                     if (!future$lazy) 
[16:11:27.667]                       future <- run(future)
[16:11:27.667]                     invisible(future)
[16:11:27.667]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:27.667]                 }
[16:11:27.667]             }
[16:11:27.667]         }
[16:11:27.667]     })
[16:11:27.667]     if (TRUE) {
[16:11:27.667]         base::sink(type = "output", split = FALSE)
[16:11:27.667]         if (FALSE) {
[16:11:27.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:27.667]         }
[16:11:27.667]         else {
[16:11:27.667]             ...future.result["stdout"] <- base::list(NULL)
[16:11:27.667]         }
[16:11:27.667]         base::close(...future.stdout)
[16:11:27.667]         ...future.stdout <- NULL
[16:11:27.667]     }
[16:11:27.667]     ...future.result$conditions <- ...future.conditions
[16:11:27.667]     ...future.result$finished <- base::Sys.time()
[16:11:27.667]     ...future.result
[16:11:27.667] }
[16:11:27.670] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:11:27.670] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:11:27.670] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:11:27.670] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:11:27.671] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:11:27.671] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:11:27.671] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:11:27.671] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:27.672] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:27.672] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:27.672] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:27.672] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:11:27.673] MultisessionFuture started
[16:11:27.673] - Launch lazy future ... done
[16:11:27.673] run() for ‘MultisessionFuture’ ... done
[16:11:27.673] Created future:
[16:11:27.673] MultisessionFuture:
[16:11:27.673] Label: ‘future_mapply-2’
[16:11:27.673] Expression:
[16:11:27.673] {
[16:11:27.673]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:27.673]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:27.673]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:27.673]         on.exit(options(oopts), add = TRUE)
[16:11:27.673]     }
[16:11:27.673]     {
[16:11:27.673]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:27.673]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:27.673]         do.call(mapply, args = args)
[16:11:27.673]     }
[16:11:27.673] }
[16:11:27.673] Lazy evaluation: FALSE
[16:11:27.673] Asynchronous evaluation: TRUE
[16:11:27.673] Local evaluation: TRUE
[16:11:27.673] Environment: R_GlobalEnv
[16:11:27.673] Capture standard output: FALSE
[16:11:27.673] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:27.673] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:27.673] Packages: <none>
[16:11:27.673] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:27.673] Resolved: FALSE
[16:11:27.673] Value: <not collected>
[16:11:27.673] Conditions captured: <none>
[16:11:27.673] Early signaling: FALSE
[16:11:27.673] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:27.673] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:27.685] Chunk #2 of 2 ... DONE
[16:11:27.685] Launching 2 futures (chunks) ... DONE
[16:11:27.685] Resolving 2 futures (chunks) ...
[16:11:27.685] resolve() on list ...
[16:11:27.685]  recursive: 0
[16:11:27.685]  length: 2
[16:11:27.685] 
[16:11:27.728] receiveMessageFromWorker() for ClusterFuture ...
[16:11:27.728] - Validating connection of MultisessionFuture
[16:11:27.728] - received message: FutureResult
[16:11:27.728] - Received FutureResult
[16:11:27.729] - Erased future from FutureRegistry
[16:11:27.729] result() for ClusterFuture ...
[16:11:27.729] - result already collected: FutureResult
[16:11:27.729] result() for ClusterFuture ... done
[16:11:27.729] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:27.729] Future #2
[16:11:27.729] result() for ClusterFuture ...
[16:11:27.729] - result already collected: FutureResult
[16:11:27.729] result() for ClusterFuture ... done
[16:11:27.729] result() for ClusterFuture ...
[16:11:27.730] - result already collected: FutureResult
[16:11:27.730] result() for ClusterFuture ... done
[16:11:27.730] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:27.730] - nx: 2
[16:11:27.730] - relay: TRUE
[16:11:27.730] - stdout: TRUE
[16:11:27.730] - signal: TRUE
[16:11:27.730] - resignal: FALSE
[16:11:27.730] - force: TRUE
[16:11:27.730] - relayed: [n=2] FALSE, FALSE
[16:11:27.730] - queued futures: [n=2] FALSE, FALSE
[16:11:27.731]  - until=1
[16:11:27.731]  - relaying element #1
[16:11:27.731] - relayed: [n=2] FALSE, FALSE
[16:11:27.731] - queued futures: [n=2] FALSE, TRUE
[16:11:27.731] signalConditionsASAP(NULL, pos=2) ... done
[16:11:27.731]  length: 1 (resolved future 2)
[16:11:28.182] receiveMessageFromWorker() for ClusterFuture ...
[16:11:28.183] - Validating connection of MultisessionFuture
[16:11:28.183] - received message: FutureResult
[16:11:28.183] - Received FutureResult
[16:11:28.183] - Erased future from FutureRegistry
[16:11:28.183] result() for ClusterFuture ...
[16:11:28.183] - result already collected: FutureResult
[16:11:28.183] result() for ClusterFuture ... done
[16:11:28.183] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:28.184] Future #1
[16:11:28.184] result() for ClusterFuture ...
[16:11:28.184] - result already collected: FutureResult
[16:11:28.184] result() for ClusterFuture ... done
[16:11:28.184] result() for ClusterFuture ...
[16:11:28.184] - result already collected: FutureResult
[16:11:28.184] result() for ClusterFuture ... done
[16:11:28.184] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:28.184] - nx: 2
[16:11:28.184] - relay: TRUE
[16:11:28.185] - stdout: TRUE
[16:11:28.185] - signal: TRUE
[16:11:28.185] - resignal: FALSE
[16:11:28.185] - force: TRUE
[16:11:28.185] - relayed: [n=2] FALSE, FALSE
[16:11:28.185] - queued futures: [n=2] FALSE, TRUE
[16:11:28.185]  - until=1
[16:11:28.185]  - relaying element #1
[16:11:28.185] result() for ClusterFuture ...
[16:11:28.185] - result already collected: FutureResult
[16:11:28.185] result() for ClusterFuture ... done
[16:11:28.186] result() for ClusterFuture ...
[16:11:28.186] - result already collected: FutureResult
[16:11:28.186] result() for ClusterFuture ... done
[16:11:28.186] result() for ClusterFuture ...
[16:11:28.186] - result already collected: FutureResult
[16:11:28.186] result() for ClusterFuture ... done
[16:11:28.186] result() for ClusterFuture ...
[16:11:28.186] - result already collected: FutureResult
[16:11:28.186] result() for ClusterFuture ... done
[16:11:28.186] - relayed: [n=2] TRUE, FALSE
[16:11:28.186] - queued futures: [n=2] TRUE, TRUE
[16:11:28.186] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:28.187]  length: 0 (resolved future 1)
[16:11:28.187] Relaying remaining futures
[16:11:28.187] signalConditionsASAP(NULL, pos=0) ...
[16:11:28.187] - nx: 2
[16:11:28.187] - relay: TRUE
[16:11:28.187] - stdout: TRUE
[16:11:28.187] - signal: TRUE
[16:11:28.187] - resignal: FALSE
[16:11:28.187] - force: TRUE
[16:11:28.187] - relayed: [n=2] TRUE, FALSE
[16:11:28.187] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:28.188]  - relaying element #2
[16:11:28.188] result() for ClusterFuture ...
[16:11:28.188] - result already collected: FutureResult
[16:11:28.188] result() for ClusterFuture ... done
[16:11:28.188] result() for ClusterFuture ...
[16:11:28.188] - result already collected: FutureResult
[16:11:28.188] result() for ClusterFuture ... done
[16:11:28.188] result() for ClusterFuture ...
[16:11:28.188] - result already collected: FutureResult
[16:11:28.188] result() for ClusterFuture ... done
[16:11:28.189] result() for ClusterFuture ...
[16:11:28.189] - result already collected: FutureResult
[16:11:28.189] result() for ClusterFuture ... done
[16:11:28.189] - relayed: [n=2] TRUE, TRUE
[16:11:28.189] - queued futures: [n=2] TRUE, TRUE
[16:11:28.189] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:11:28.189] resolve() on list ... DONE
[16:11:28.189] result() for ClusterFuture ...
[16:11:28.189] - result already collected: FutureResult
[16:11:28.189] result() for ClusterFuture ... done
[16:11:28.189] result() for ClusterFuture ...
[16:11:28.189] - result already collected: FutureResult
[16:11:28.190] result() for ClusterFuture ... done
[16:11:28.190] result() for ClusterFuture ...
[16:11:28.190] - result already collected: FutureResult
[16:11:28.190] result() for ClusterFuture ... done
[16:11:28.190] result() for ClusterFuture ...
[16:11:28.190] - result already collected: FutureResult
[16:11:28.190] result() for ClusterFuture ... done
[16:11:28.190]  - Number of value chunks collected: 2
[16:11:28.190] Resolving 2 futures (chunks) ... DONE
[16:11:28.190] Reducing values from 2 chunks ...
[16:11:28.190]  - Number of values collected after concatenation: 2
[16:11:28.191]  - Number of values expected: 2
[16:11:28.191] Reducing values from 2 chunks ... DONE
[16:11:28.191] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:11:28.191] future_mapply() ...
[16:11:28.195] Number of chunks: 2
[16:11:28.195] getGlobalsAndPackagesXApply() ...
[16:11:28.195]  - future.globals: TRUE
[16:11:28.195] getGlobalsAndPackages() ...
[16:11:28.195] Searching for globals...
[16:11:28.197] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:28.197] Searching for globals ... DONE
[16:11:28.197] Resolving globals: FALSE
[16:11:28.198] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:28.198] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:28.198] - globals: [1] ‘FUN’
[16:11:28.198] 
[16:11:28.198] getGlobalsAndPackages() ... DONE
[16:11:28.199]  - globals found/used: [n=1] ‘FUN’
[16:11:28.199]  - needed namespaces: [n=0] 
[16:11:28.199] Finding globals ... DONE
[16:11:28.199] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:28.199] List of 2
[16:11:28.199]  $ ...future.FUN:function (x, y)  
[16:11:28.199]  $ MoreArgs     : NULL
[16:11:28.199]  - attr(*, "where")=List of 2
[16:11:28.199]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:28.199]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:28.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:28.199]  - attr(*, "resolved")= logi FALSE
[16:11:28.199]  - attr(*, "total_size")= num NA
[16:11:28.202] Packages to be attached in all futures: [n=0] 
[16:11:28.202] getGlobalsAndPackagesXApply() ... DONE
[16:11:28.202] Number of futures (= number of chunks): 2
[16:11:28.202] Launching 2 futures (chunks) ...
[16:11:28.202] Chunk #1 of 2 ...
[16:11:28.202]  - Finding globals in '...' for chunk #1 ...
[16:11:28.202] getGlobalsAndPackages() ...
[16:11:28.202] Searching for globals...
[16:11:28.203] 
[16:11:28.203] Searching for globals ... DONE
[16:11:28.203] - globals: [0] <none>
[16:11:28.203] getGlobalsAndPackages() ... DONE
[16:11:28.203]    + additional globals found: [n=0] 
[16:11:28.203]    + additional namespaces needed: [n=0] 
[16:11:28.203]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:28.203]  - seeds: <none>
[16:11:28.203] getGlobalsAndPackages() ...
[16:11:28.204] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:28.204] Resolving globals: FALSE
[16:11:28.204] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:28.205] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:28.205] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:28.205] 
[16:11:28.205] getGlobalsAndPackages() ... DONE
[16:11:28.205] run() for ‘Future’ ...
[16:11:28.205] - state: ‘created’
[16:11:28.206] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:28.220] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:28.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:28.220]   - Field: ‘node’
[16:11:28.221]   - Field: ‘label’
[16:11:28.221]   - Field: ‘local’
[16:11:28.221]   - Field: ‘owner’
[16:11:28.221]   - Field: ‘envir’
[16:11:28.221]   - Field: ‘workers’
[16:11:28.221]   - Field: ‘packages’
[16:11:28.221]   - Field: ‘gc’
[16:11:28.221]   - Field: ‘conditions’
[16:11:28.221]   - Field: ‘persistent’
[16:11:28.221]   - Field: ‘expr’
[16:11:28.221]   - Field: ‘uuid’
[16:11:28.222]   - Field: ‘seed’
[16:11:28.222]   - Field: ‘version’
[16:11:28.222]   - Field: ‘result’
[16:11:28.222]   - Field: ‘asynchronous’
[16:11:28.222]   - Field: ‘calls’
[16:11:28.222]   - Field: ‘globals’
[16:11:28.222]   - Field: ‘stdout’
[16:11:28.222]   - Field: ‘earlySignal’
[16:11:28.222]   - Field: ‘lazy’
[16:11:28.222]   - Field: ‘state’
[16:11:28.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:28.223] - Launch lazy future ...
[16:11:28.223] Packages needed by the future expression (n = 0): <none>
[16:11:28.223] Packages needed by future strategies (n = 0): <none>
[16:11:28.223] {
[16:11:28.223]     {
[16:11:28.223]         {
[16:11:28.223]             ...future.startTime <- base::Sys.time()
[16:11:28.223]             {
[16:11:28.223]                 {
[16:11:28.223]                   {
[16:11:28.223]                     {
[16:11:28.223]                       base::local({
[16:11:28.223]                         has_future <- base::requireNamespace("future", 
[16:11:28.223]                           quietly = TRUE)
[16:11:28.223]                         if (has_future) {
[16:11:28.223]                           ns <- base::getNamespace("future")
[16:11:28.223]                           version <- ns[[".package"]][["version"]]
[16:11:28.223]                           if (is.null(version)) 
[16:11:28.223]                             version <- utils::packageVersion("future")
[16:11:28.223]                         }
[16:11:28.223]                         else {
[16:11:28.223]                           version <- NULL
[16:11:28.223]                         }
[16:11:28.223]                         if (!has_future || version < "1.8.0") {
[16:11:28.223]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:28.223]                             "", base::R.version$version.string), 
[16:11:28.223]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:28.223]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:28.223]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:28.223]                               "release", "version")], collapse = " "), 
[16:11:28.223]                             hostname = base::Sys.info()[["nodename"]])
[16:11:28.223]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:28.223]                             info)
[16:11:28.223]                           info <- base::paste(info, collapse = "; ")
[16:11:28.223]                           if (!has_future) {
[16:11:28.223]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:28.223]                               info)
[16:11:28.223]                           }
[16:11:28.223]                           else {
[16:11:28.223]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:28.223]                               info, version)
[16:11:28.223]                           }
[16:11:28.223]                           base::stop(msg)
[16:11:28.223]                         }
[16:11:28.223]                       })
[16:11:28.223]                     }
[16:11:28.223]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:28.223]                     base::options(mc.cores = 1L)
[16:11:28.223]                   }
[16:11:28.223]                   options(future.plan = NULL)
[16:11:28.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:28.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:28.223]                 }
[16:11:28.223]                 ...future.workdir <- getwd()
[16:11:28.223]             }
[16:11:28.223]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:28.223]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:28.223]         }
[16:11:28.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:28.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:28.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:28.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:28.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:28.223]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:28.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:28.223]             base::names(...future.oldOptions))
[16:11:28.223]     }
[16:11:28.223]     if (FALSE) {
[16:11:28.223]     }
[16:11:28.223]     else {
[16:11:28.223]         if (TRUE) {
[16:11:28.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:28.223]                 open = "w")
[16:11:28.223]         }
[16:11:28.223]         else {
[16:11:28.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:28.223]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:28.223]         }
[16:11:28.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:28.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:28.223]             base::sink(type = "output", split = FALSE)
[16:11:28.223]             base::close(...future.stdout)
[16:11:28.223]         }, add = TRUE)
[16:11:28.223]     }
[16:11:28.223]     ...future.frame <- base::sys.nframe()
[16:11:28.223]     ...future.conditions <- base::list()
[16:11:28.223]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:28.223]     if (FALSE) {
[16:11:28.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:28.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:28.223]     }
[16:11:28.223]     ...future.result <- base::tryCatch({
[16:11:28.223]         base::withCallingHandlers({
[16:11:28.223]             ...future.value <- base::withVisible(base::local({
[16:11:28.223]                 ...future.makeSendCondition <- local({
[16:11:28.223]                   sendCondition <- NULL
[16:11:28.223]                   function(frame = 1L) {
[16:11:28.223]                     if (is.function(sendCondition)) 
[16:11:28.223]                       return(sendCondition)
[16:11:28.223]                     ns <- getNamespace("parallel")
[16:11:28.223]                     if (exists("sendData", mode = "function", 
[16:11:28.223]                       envir = ns)) {
[16:11:28.223]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:28.223]                         envir = ns)
[16:11:28.223]                       envir <- sys.frame(frame)
[16:11:28.223]                       master <- NULL
[16:11:28.223]                       while (!identical(envir, .GlobalEnv) && 
[16:11:28.223]                         !identical(envir, emptyenv())) {
[16:11:28.223]                         if (exists("master", mode = "list", envir = envir, 
[16:11:28.223]                           inherits = FALSE)) {
[16:11:28.223]                           master <- get("master", mode = "list", 
[16:11:28.223]                             envir = envir, inherits = FALSE)
[16:11:28.223]                           if (inherits(master, c("SOCKnode", 
[16:11:28.223]                             "SOCK0node"))) {
[16:11:28.223]                             sendCondition <<- function(cond) {
[16:11:28.223]                               data <- list(type = "VALUE", value = cond, 
[16:11:28.223]                                 success = TRUE)
[16:11:28.223]                               parallel_sendData(master, data)
[16:11:28.223]                             }
[16:11:28.223]                             return(sendCondition)
[16:11:28.223]                           }
[16:11:28.223]                         }
[16:11:28.223]                         frame <- frame + 1L
[16:11:28.223]                         envir <- sys.frame(frame)
[16:11:28.223]                       }
[16:11:28.223]                     }
[16:11:28.223]                     sendCondition <<- function(cond) NULL
[16:11:28.223]                   }
[16:11:28.223]                 })
[16:11:28.223]                 withCallingHandlers({
[16:11:28.223]                   {
[16:11:28.223]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:28.223]                     if (!identical(...future.globals.maxSize.org, 
[16:11:28.223]                       ...future.globals.maxSize)) {
[16:11:28.223]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:28.223]                       on.exit(options(oopts), add = TRUE)
[16:11:28.223]                     }
[16:11:28.223]                     {
[16:11:28.223]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:28.223]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:28.223]                         USE.NAMES = FALSE)
[16:11:28.223]                       do.call(mapply, args = args)
[16:11:28.223]                     }
[16:11:28.223]                   }
[16:11:28.223]                 }, immediateCondition = function(cond) {
[16:11:28.223]                   sendCondition <- ...future.makeSendCondition()
[16:11:28.223]                   sendCondition(cond)
[16:11:28.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.223]                   {
[16:11:28.223]                     inherits <- base::inherits
[16:11:28.223]                     invokeRestart <- base::invokeRestart
[16:11:28.223]                     is.null <- base::is.null
[16:11:28.223]                     muffled <- FALSE
[16:11:28.223]                     if (inherits(cond, "message")) {
[16:11:28.223]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:28.223]                       if (muffled) 
[16:11:28.223]                         invokeRestart("muffleMessage")
[16:11:28.223]                     }
[16:11:28.223]                     else if (inherits(cond, "warning")) {
[16:11:28.223]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:28.223]                       if (muffled) 
[16:11:28.223]                         invokeRestart("muffleWarning")
[16:11:28.223]                     }
[16:11:28.223]                     else if (inherits(cond, "condition")) {
[16:11:28.223]                       if (!is.null(pattern)) {
[16:11:28.223]                         computeRestarts <- base::computeRestarts
[16:11:28.223]                         grepl <- base::grepl
[16:11:28.223]                         restarts <- computeRestarts(cond)
[16:11:28.223]                         for (restart in restarts) {
[16:11:28.223]                           name <- restart$name
[16:11:28.223]                           if (is.null(name)) 
[16:11:28.223]                             next
[16:11:28.223]                           if (!grepl(pattern, name)) 
[16:11:28.223]                             next
[16:11:28.223]                           invokeRestart(restart)
[16:11:28.223]                           muffled <- TRUE
[16:11:28.223]                           break
[16:11:28.223]                         }
[16:11:28.223]                       }
[16:11:28.223]                     }
[16:11:28.223]                     invisible(muffled)
[16:11:28.223]                   }
[16:11:28.223]                   muffleCondition(cond)
[16:11:28.223]                 })
[16:11:28.223]             }))
[16:11:28.223]             future::FutureResult(value = ...future.value$value, 
[16:11:28.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:28.223]                   ...future.rng), globalenv = if (FALSE) 
[16:11:28.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:28.223]                     ...future.globalenv.names))
[16:11:28.223]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:28.223]         }, condition = base::local({
[16:11:28.223]             c <- base::c
[16:11:28.223]             inherits <- base::inherits
[16:11:28.223]             invokeRestart <- base::invokeRestart
[16:11:28.223]             length <- base::length
[16:11:28.223]             list <- base::list
[16:11:28.223]             seq.int <- base::seq.int
[16:11:28.223]             signalCondition <- base::signalCondition
[16:11:28.223]             sys.calls <- base::sys.calls
[16:11:28.223]             `[[` <- base::`[[`
[16:11:28.223]             `+` <- base::`+`
[16:11:28.223]             `<<-` <- base::`<<-`
[16:11:28.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:28.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:28.223]                   3L)]
[16:11:28.223]             }
[16:11:28.223]             function(cond) {
[16:11:28.223]                 is_error <- inherits(cond, "error")
[16:11:28.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:28.223]                   NULL)
[16:11:28.223]                 if (is_error) {
[16:11:28.223]                   sessionInformation <- function() {
[16:11:28.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:28.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:28.223]                       search = base::search(), system = base::Sys.info())
[16:11:28.223]                   }
[16:11:28.223]                   ...future.conditions[[length(...future.conditions) + 
[16:11:28.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:28.223]                     cond$call), session = sessionInformation(), 
[16:11:28.223]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:28.223]                   signalCondition(cond)
[16:11:28.223]                 }
[16:11:28.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:28.223]                 "immediateCondition"))) {
[16:11:28.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:28.223]                   ...future.conditions[[length(...future.conditions) + 
[16:11:28.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:28.223]                   if (TRUE && !signal) {
[16:11:28.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.223]                     {
[16:11:28.223]                       inherits <- base::inherits
[16:11:28.223]                       invokeRestart <- base::invokeRestart
[16:11:28.223]                       is.null <- base::is.null
[16:11:28.223]                       muffled <- FALSE
[16:11:28.223]                       if (inherits(cond, "message")) {
[16:11:28.223]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:28.223]                         if (muffled) 
[16:11:28.223]                           invokeRestart("muffleMessage")
[16:11:28.223]                       }
[16:11:28.223]                       else if (inherits(cond, "warning")) {
[16:11:28.223]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:28.223]                         if (muffled) 
[16:11:28.223]                           invokeRestart("muffleWarning")
[16:11:28.223]                       }
[16:11:28.223]                       else if (inherits(cond, "condition")) {
[16:11:28.223]                         if (!is.null(pattern)) {
[16:11:28.223]                           computeRestarts <- base::computeRestarts
[16:11:28.223]                           grepl <- base::grepl
[16:11:28.223]                           restarts <- computeRestarts(cond)
[16:11:28.223]                           for (restart in restarts) {
[16:11:28.223]                             name <- restart$name
[16:11:28.223]                             if (is.null(name)) 
[16:11:28.223]                               next
[16:11:28.223]                             if (!grepl(pattern, name)) 
[16:11:28.223]                               next
[16:11:28.223]                             invokeRestart(restart)
[16:11:28.223]                             muffled <- TRUE
[16:11:28.223]                             break
[16:11:28.223]                           }
[16:11:28.223]                         }
[16:11:28.223]                       }
[16:11:28.223]                       invisible(muffled)
[16:11:28.223]                     }
[16:11:28.223]                     muffleCondition(cond, pattern = "^muffle")
[16:11:28.223]                   }
[16:11:28.223]                 }
[16:11:28.223]                 else {
[16:11:28.223]                   if (TRUE) {
[16:11:28.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.223]                     {
[16:11:28.223]                       inherits <- base::inherits
[16:11:28.223]                       invokeRestart <- base::invokeRestart
[16:11:28.223]                       is.null <- base::is.null
[16:11:28.223]                       muffled <- FALSE
[16:11:28.223]                       if (inherits(cond, "message")) {
[16:11:28.223]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:28.223]                         if (muffled) 
[16:11:28.223]                           invokeRestart("muffleMessage")
[16:11:28.223]                       }
[16:11:28.223]                       else if (inherits(cond, "warning")) {
[16:11:28.223]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:28.223]                         if (muffled) 
[16:11:28.223]                           invokeRestart("muffleWarning")
[16:11:28.223]                       }
[16:11:28.223]                       else if (inherits(cond, "condition")) {
[16:11:28.223]                         if (!is.null(pattern)) {
[16:11:28.223]                           computeRestarts <- base::computeRestarts
[16:11:28.223]                           grepl <- base::grepl
[16:11:28.223]                           restarts <- computeRestarts(cond)
[16:11:28.223]                           for (restart in restarts) {
[16:11:28.223]                             name <- restart$name
[16:11:28.223]                             if (is.null(name)) 
[16:11:28.223]                               next
[16:11:28.223]                             if (!grepl(pattern, name)) 
[16:11:28.223]                               next
[16:11:28.223]                             invokeRestart(restart)
[16:11:28.223]                             muffled <- TRUE
[16:11:28.223]                             break
[16:11:28.223]                           }
[16:11:28.223]                         }
[16:11:28.223]                       }
[16:11:28.223]                       invisible(muffled)
[16:11:28.223]                     }
[16:11:28.223]                     muffleCondition(cond, pattern = "^muffle")
[16:11:28.223]                   }
[16:11:28.223]                 }
[16:11:28.223]             }
[16:11:28.223]         }))
[16:11:28.223]     }, error = function(ex) {
[16:11:28.223]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:28.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:28.223]                 ...future.rng), started = ...future.startTime, 
[16:11:28.223]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:28.223]             version = "1.8"), class = "FutureResult")
[16:11:28.223]     }, finally = {
[16:11:28.223]         if (!identical(...future.workdir, getwd())) 
[16:11:28.223]             setwd(...future.workdir)
[16:11:28.223]         {
[16:11:28.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:28.223]                 ...future.oldOptions$nwarnings <- NULL
[16:11:28.223]             }
[16:11:28.223]             base::options(...future.oldOptions)
[16:11:28.223]             if (.Platform$OS.type == "windows") {
[16:11:28.223]                 old_names <- names(...future.oldEnvVars)
[16:11:28.223]                 envs <- base::Sys.getenv()
[16:11:28.223]                 names <- names(envs)
[16:11:28.223]                 common <- intersect(names, old_names)
[16:11:28.223]                 added <- setdiff(names, old_names)
[16:11:28.223]                 removed <- setdiff(old_names, names)
[16:11:28.223]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:28.223]                   envs[common]]
[16:11:28.223]                 NAMES <- toupper(changed)
[16:11:28.223]                 args <- list()
[16:11:28.223]                 for (kk in seq_along(NAMES)) {
[16:11:28.223]                   name <- changed[[kk]]
[16:11:28.223]                   NAME <- NAMES[[kk]]
[16:11:28.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.223]                     next
[16:11:28.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:28.223]                 }
[16:11:28.223]                 NAMES <- toupper(added)
[16:11:28.223]                 for (kk in seq_along(NAMES)) {
[16:11:28.223]                   name <- added[[kk]]
[16:11:28.223]                   NAME <- NAMES[[kk]]
[16:11:28.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.223]                     next
[16:11:28.223]                   args[[name]] <- ""
[16:11:28.223]                 }
[16:11:28.223]                 NAMES <- toupper(removed)
[16:11:28.223]                 for (kk in seq_along(NAMES)) {
[16:11:28.223]                   name <- removed[[kk]]
[16:11:28.223]                   NAME <- NAMES[[kk]]
[16:11:28.223]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.223]                     next
[16:11:28.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:28.223]                 }
[16:11:28.223]                 if (length(args) > 0) 
[16:11:28.223]                   base::do.call(base::Sys.setenv, args = args)
[16:11:28.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:28.223]             }
[16:11:28.223]             else {
[16:11:28.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:28.223]             }
[16:11:28.223]             {
[16:11:28.223]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:28.223]                   0L) {
[16:11:28.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:28.223]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:28.223]                   base::options(opts)
[16:11:28.223]                 }
[16:11:28.223]                 {
[16:11:28.223]                   {
[16:11:28.223]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:28.223]                     NULL
[16:11:28.223]                   }
[16:11:28.223]                   options(future.plan = NULL)
[16:11:28.223]                   if (is.na(NA_character_)) 
[16:11:28.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:28.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:28.223]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:28.223]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:28.223]                     envir = parent.frame()) 
[16:11:28.223]                   {
[16:11:28.223]                     if (is.function(workers)) 
[16:11:28.223]                       workers <- workers()
[16:11:28.223]                     workers <- structure(as.integer(workers), 
[16:11:28.223]                       class = class(workers))
[16:11:28.223]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:28.223]                       workers >= 1)
[16:11:28.223]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:28.223]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:28.223]                     }
[16:11:28.223]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:28.223]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:28.223]                       envir = envir)
[16:11:28.223]                     if (!future$lazy) 
[16:11:28.223]                       future <- run(future)
[16:11:28.223]                     invisible(future)
[16:11:28.223]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:28.223]                 }
[16:11:28.223]             }
[16:11:28.223]         }
[16:11:28.223]     })
[16:11:28.223]     if (TRUE) {
[16:11:28.223]         base::sink(type = "output", split = FALSE)
[16:11:28.223]         if (TRUE) {
[16:11:28.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:28.223]         }
[16:11:28.223]         else {
[16:11:28.223]             ...future.result["stdout"] <- base::list(NULL)
[16:11:28.223]         }
[16:11:28.223]         base::close(...future.stdout)
[16:11:28.223]         ...future.stdout <- NULL
[16:11:28.223]     }
[16:11:28.223]     ...future.result$conditions <- ...future.conditions
[16:11:28.223]     ...future.result$finished <- base::Sys.time()
[16:11:28.223]     ...future.result
[16:11:28.223] }
[16:11:28.226] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:11:28.226] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:11:28.227] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:11:28.227] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:11:28.227] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:11:28.227] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:11:28.228] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:11:28.228] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:28.228] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:28.228] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:28.229] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:28.229] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:11:28.229] MultisessionFuture started
[16:11:28.229] - Launch lazy future ... done
[16:11:28.229] run() for ‘MultisessionFuture’ ... done
[16:11:28.229] Created future:
[16:11:28.230] MultisessionFuture:
[16:11:28.230] Label: ‘future_mapply-1’
[16:11:28.230] Expression:
[16:11:28.230] {
[16:11:28.230]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:28.230]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:28.230]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:28.230]         on.exit(options(oopts), add = TRUE)
[16:11:28.230]     }
[16:11:28.230]     {
[16:11:28.230]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:28.230]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:28.230]         do.call(mapply, args = args)
[16:11:28.230]     }
[16:11:28.230] }
[16:11:28.230] Lazy evaluation: FALSE
[16:11:28.230] Asynchronous evaluation: TRUE
[16:11:28.230] Local evaluation: TRUE
[16:11:28.230] Environment: R_GlobalEnv
[16:11:28.230] Capture standard output: TRUE
[16:11:28.230] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:28.230] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:28.230] Packages: <none>
[16:11:28.230] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:28.230] Resolved: FALSE
[16:11:28.230] Value: <not collected>
[16:11:28.230] Conditions captured: <none>
[16:11:28.230] Early signaling: FALSE
[16:11:28.230] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:28.230] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:28.241] Chunk #1 of 2 ... DONE
[16:11:28.241] Chunk #2 of 2 ...
[16:11:28.241]  - Finding globals in '...' for chunk #2 ...
[16:11:28.241] getGlobalsAndPackages() ...
[16:11:28.241] Searching for globals...
[16:11:28.242] 
[16:11:28.242] Searching for globals ... DONE
[16:11:28.242] - globals: [0] <none>
[16:11:28.242] getGlobalsAndPackages() ... DONE
[16:11:28.242]    + additional globals found: [n=0] 
[16:11:28.242]    + additional namespaces needed: [n=0] 
[16:11:28.242]  - Finding globals in '...' for chunk #2 ... DONE
[16:11:28.242]  - seeds: <none>
[16:11:28.242] getGlobalsAndPackages() ...
[16:11:28.243] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:28.243] Resolving globals: FALSE
[16:11:28.243] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:28.244] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:28.244] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:28.244] 
[16:11:28.244] getGlobalsAndPackages() ... DONE
[16:11:28.244] run() for ‘Future’ ...
[16:11:28.244] - state: ‘created’
[16:11:28.245] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:28.259] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:28.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:28.260]   - Field: ‘node’
[16:11:28.260]   - Field: ‘label’
[16:11:28.260]   - Field: ‘local’
[16:11:28.260]   - Field: ‘owner’
[16:11:28.260]   - Field: ‘envir’
[16:11:28.260]   - Field: ‘workers’
[16:11:28.260]   - Field: ‘packages’
[16:11:28.260]   - Field: ‘gc’
[16:11:28.261]   - Field: ‘conditions’
[16:11:28.261]   - Field: ‘persistent’
[16:11:28.261]   - Field: ‘expr’
[16:11:28.261]   - Field: ‘uuid’
[16:11:28.261]   - Field: ‘seed’
[16:11:28.263]   - Field: ‘version’
[16:11:28.263]   - Field: ‘result’
[16:11:28.263]   - Field: ‘asynchronous’
[16:11:28.264]   - Field: ‘calls’
[16:11:28.264]   - Field: ‘globals’
[16:11:28.264]   - Field: ‘stdout’
[16:11:28.264]   - Field: ‘earlySignal’
[16:11:28.264]   - Field: ‘lazy’
[16:11:28.264]   - Field: ‘state’
[16:11:28.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:28.264] - Launch lazy future ...
[16:11:28.265] Packages needed by the future expression (n = 0): <none>
[16:11:28.265] Packages needed by future strategies (n = 0): <none>
[16:11:28.265] {
[16:11:28.265]     {
[16:11:28.265]         {
[16:11:28.265]             ...future.startTime <- base::Sys.time()
[16:11:28.265]             {
[16:11:28.265]                 {
[16:11:28.265]                   {
[16:11:28.265]                     {
[16:11:28.265]                       base::local({
[16:11:28.265]                         has_future <- base::requireNamespace("future", 
[16:11:28.265]                           quietly = TRUE)
[16:11:28.265]                         if (has_future) {
[16:11:28.265]                           ns <- base::getNamespace("future")
[16:11:28.265]                           version <- ns[[".package"]][["version"]]
[16:11:28.265]                           if (is.null(version)) 
[16:11:28.265]                             version <- utils::packageVersion("future")
[16:11:28.265]                         }
[16:11:28.265]                         else {
[16:11:28.265]                           version <- NULL
[16:11:28.265]                         }
[16:11:28.265]                         if (!has_future || version < "1.8.0") {
[16:11:28.265]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:28.265]                             "", base::R.version$version.string), 
[16:11:28.265]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:28.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:28.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:28.265]                               "release", "version")], collapse = " "), 
[16:11:28.265]                             hostname = base::Sys.info()[["nodename"]])
[16:11:28.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:28.265]                             info)
[16:11:28.265]                           info <- base::paste(info, collapse = "; ")
[16:11:28.265]                           if (!has_future) {
[16:11:28.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:28.265]                               info)
[16:11:28.265]                           }
[16:11:28.265]                           else {
[16:11:28.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:28.265]                               info, version)
[16:11:28.265]                           }
[16:11:28.265]                           base::stop(msg)
[16:11:28.265]                         }
[16:11:28.265]                       })
[16:11:28.265]                     }
[16:11:28.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:28.265]                     base::options(mc.cores = 1L)
[16:11:28.265]                   }
[16:11:28.265]                   options(future.plan = NULL)
[16:11:28.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:28.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:28.265]                 }
[16:11:28.265]                 ...future.workdir <- getwd()
[16:11:28.265]             }
[16:11:28.265]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:28.265]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:28.265]         }
[16:11:28.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:28.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:28.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:28.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:28.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:28.265]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:28.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:28.265]             base::names(...future.oldOptions))
[16:11:28.265]     }
[16:11:28.265]     if (FALSE) {
[16:11:28.265]     }
[16:11:28.265]     else {
[16:11:28.265]         if (TRUE) {
[16:11:28.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:28.265]                 open = "w")
[16:11:28.265]         }
[16:11:28.265]         else {
[16:11:28.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:28.265]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:28.265]         }
[16:11:28.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:28.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:28.265]             base::sink(type = "output", split = FALSE)
[16:11:28.265]             base::close(...future.stdout)
[16:11:28.265]         }, add = TRUE)
[16:11:28.265]     }
[16:11:28.265]     ...future.frame <- base::sys.nframe()
[16:11:28.265]     ...future.conditions <- base::list()
[16:11:28.265]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:28.265]     if (FALSE) {
[16:11:28.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:28.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:28.265]     }
[16:11:28.265]     ...future.result <- base::tryCatch({
[16:11:28.265]         base::withCallingHandlers({
[16:11:28.265]             ...future.value <- base::withVisible(base::local({
[16:11:28.265]                 ...future.makeSendCondition <- local({
[16:11:28.265]                   sendCondition <- NULL
[16:11:28.265]                   function(frame = 1L) {
[16:11:28.265]                     if (is.function(sendCondition)) 
[16:11:28.265]                       return(sendCondition)
[16:11:28.265]                     ns <- getNamespace("parallel")
[16:11:28.265]                     if (exists("sendData", mode = "function", 
[16:11:28.265]                       envir = ns)) {
[16:11:28.265]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:28.265]                         envir = ns)
[16:11:28.265]                       envir <- sys.frame(frame)
[16:11:28.265]                       master <- NULL
[16:11:28.265]                       while (!identical(envir, .GlobalEnv) && 
[16:11:28.265]                         !identical(envir, emptyenv())) {
[16:11:28.265]                         if (exists("master", mode = "list", envir = envir, 
[16:11:28.265]                           inherits = FALSE)) {
[16:11:28.265]                           master <- get("master", mode = "list", 
[16:11:28.265]                             envir = envir, inherits = FALSE)
[16:11:28.265]                           if (inherits(master, c("SOCKnode", 
[16:11:28.265]                             "SOCK0node"))) {
[16:11:28.265]                             sendCondition <<- function(cond) {
[16:11:28.265]                               data <- list(type = "VALUE", value = cond, 
[16:11:28.265]                                 success = TRUE)
[16:11:28.265]                               parallel_sendData(master, data)
[16:11:28.265]                             }
[16:11:28.265]                             return(sendCondition)
[16:11:28.265]                           }
[16:11:28.265]                         }
[16:11:28.265]                         frame <- frame + 1L
[16:11:28.265]                         envir <- sys.frame(frame)
[16:11:28.265]                       }
[16:11:28.265]                     }
[16:11:28.265]                     sendCondition <<- function(cond) NULL
[16:11:28.265]                   }
[16:11:28.265]                 })
[16:11:28.265]                 withCallingHandlers({
[16:11:28.265]                   {
[16:11:28.265]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:28.265]                     if (!identical(...future.globals.maxSize.org, 
[16:11:28.265]                       ...future.globals.maxSize)) {
[16:11:28.265]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:28.265]                       on.exit(options(oopts), add = TRUE)
[16:11:28.265]                     }
[16:11:28.265]                     {
[16:11:28.265]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:28.265]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:28.265]                         USE.NAMES = FALSE)
[16:11:28.265]                       do.call(mapply, args = args)
[16:11:28.265]                     }
[16:11:28.265]                   }
[16:11:28.265]                 }, immediateCondition = function(cond) {
[16:11:28.265]                   sendCondition <- ...future.makeSendCondition()
[16:11:28.265]                   sendCondition(cond)
[16:11:28.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.265]                   {
[16:11:28.265]                     inherits <- base::inherits
[16:11:28.265]                     invokeRestart <- base::invokeRestart
[16:11:28.265]                     is.null <- base::is.null
[16:11:28.265]                     muffled <- FALSE
[16:11:28.265]                     if (inherits(cond, "message")) {
[16:11:28.265]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:28.265]                       if (muffled) 
[16:11:28.265]                         invokeRestart("muffleMessage")
[16:11:28.265]                     }
[16:11:28.265]                     else if (inherits(cond, "warning")) {
[16:11:28.265]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:28.265]                       if (muffled) 
[16:11:28.265]                         invokeRestart("muffleWarning")
[16:11:28.265]                     }
[16:11:28.265]                     else if (inherits(cond, "condition")) {
[16:11:28.265]                       if (!is.null(pattern)) {
[16:11:28.265]                         computeRestarts <- base::computeRestarts
[16:11:28.265]                         grepl <- base::grepl
[16:11:28.265]                         restarts <- computeRestarts(cond)
[16:11:28.265]                         for (restart in restarts) {
[16:11:28.265]                           name <- restart$name
[16:11:28.265]                           if (is.null(name)) 
[16:11:28.265]                             next
[16:11:28.265]                           if (!grepl(pattern, name)) 
[16:11:28.265]                             next
[16:11:28.265]                           invokeRestart(restart)
[16:11:28.265]                           muffled <- TRUE
[16:11:28.265]                           break
[16:11:28.265]                         }
[16:11:28.265]                       }
[16:11:28.265]                     }
[16:11:28.265]                     invisible(muffled)
[16:11:28.265]                   }
[16:11:28.265]                   muffleCondition(cond)
[16:11:28.265]                 })
[16:11:28.265]             }))
[16:11:28.265]             future::FutureResult(value = ...future.value$value, 
[16:11:28.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:28.265]                   ...future.rng), globalenv = if (FALSE) 
[16:11:28.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:28.265]                     ...future.globalenv.names))
[16:11:28.265]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:28.265]         }, condition = base::local({
[16:11:28.265]             c <- base::c
[16:11:28.265]             inherits <- base::inherits
[16:11:28.265]             invokeRestart <- base::invokeRestart
[16:11:28.265]             length <- base::length
[16:11:28.265]             list <- base::list
[16:11:28.265]             seq.int <- base::seq.int
[16:11:28.265]             signalCondition <- base::signalCondition
[16:11:28.265]             sys.calls <- base::sys.calls
[16:11:28.265]             `[[` <- base::`[[`
[16:11:28.265]             `+` <- base::`+`
[16:11:28.265]             `<<-` <- base::`<<-`
[16:11:28.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:28.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:28.265]                   3L)]
[16:11:28.265]             }
[16:11:28.265]             function(cond) {
[16:11:28.265]                 is_error <- inherits(cond, "error")
[16:11:28.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:28.265]                   NULL)
[16:11:28.265]                 if (is_error) {
[16:11:28.265]                   sessionInformation <- function() {
[16:11:28.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:28.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:28.265]                       search = base::search(), system = base::Sys.info())
[16:11:28.265]                   }
[16:11:28.265]                   ...future.conditions[[length(...future.conditions) + 
[16:11:28.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:28.265]                     cond$call), session = sessionInformation(), 
[16:11:28.265]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:28.265]                   signalCondition(cond)
[16:11:28.265]                 }
[16:11:28.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:28.265]                 "immediateCondition"))) {
[16:11:28.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:28.265]                   ...future.conditions[[length(...future.conditions) + 
[16:11:28.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:28.265]                   if (TRUE && !signal) {
[16:11:28.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.265]                     {
[16:11:28.265]                       inherits <- base::inherits
[16:11:28.265]                       invokeRestart <- base::invokeRestart
[16:11:28.265]                       is.null <- base::is.null
[16:11:28.265]                       muffled <- FALSE
[16:11:28.265]                       if (inherits(cond, "message")) {
[16:11:28.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:28.265]                         if (muffled) 
[16:11:28.265]                           invokeRestart("muffleMessage")
[16:11:28.265]                       }
[16:11:28.265]                       else if (inherits(cond, "warning")) {
[16:11:28.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:28.265]                         if (muffled) 
[16:11:28.265]                           invokeRestart("muffleWarning")
[16:11:28.265]                       }
[16:11:28.265]                       else if (inherits(cond, "condition")) {
[16:11:28.265]                         if (!is.null(pattern)) {
[16:11:28.265]                           computeRestarts <- base::computeRestarts
[16:11:28.265]                           grepl <- base::grepl
[16:11:28.265]                           restarts <- computeRestarts(cond)
[16:11:28.265]                           for (restart in restarts) {
[16:11:28.265]                             name <- restart$name
[16:11:28.265]                             if (is.null(name)) 
[16:11:28.265]                               next
[16:11:28.265]                             if (!grepl(pattern, name)) 
[16:11:28.265]                               next
[16:11:28.265]                             invokeRestart(restart)
[16:11:28.265]                             muffled <- TRUE
[16:11:28.265]                             break
[16:11:28.265]                           }
[16:11:28.265]                         }
[16:11:28.265]                       }
[16:11:28.265]                       invisible(muffled)
[16:11:28.265]                     }
[16:11:28.265]                     muffleCondition(cond, pattern = "^muffle")
[16:11:28.265]                   }
[16:11:28.265]                 }
[16:11:28.265]                 else {
[16:11:28.265]                   if (TRUE) {
[16:11:28.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.265]                     {
[16:11:28.265]                       inherits <- base::inherits
[16:11:28.265]                       invokeRestart <- base::invokeRestart
[16:11:28.265]                       is.null <- base::is.null
[16:11:28.265]                       muffled <- FALSE
[16:11:28.265]                       if (inherits(cond, "message")) {
[16:11:28.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:28.265]                         if (muffled) 
[16:11:28.265]                           invokeRestart("muffleMessage")
[16:11:28.265]                       }
[16:11:28.265]                       else if (inherits(cond, "warning")) {
[16:11:28.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:28.265]                         if (muffled) 
[16:11:28.265]                           invokeRestart("muffleWarning")
[16:11:28.265]                       }
[16:11:28.265]                       else if (inherits(cond, "condition")) {
[16:11:28.265]                         if (!is.null(pattern)) {
[16:11:28.265]                           computeRestarts <- base::computeRestarts
[16:11:28.265]                           grepl <- base::grepl
[16:11:28.265]                           restarts <- computeRestarts(cond)
[16:11:28.265]                           for (restart in restarts) {
[16:11:28.265]                             name <- restart$name
[16:11:28.265]                             if (is.null(name)) 
[16:11:28.265]                               next
[16:11:28.265]                             if (!grepl(pattern, name)) 
[16:11:28.265]                               next
[16:11:28.265]                             invokeRestart(restart)
[16:11:28.265]                             muffled <- TRUE
[16:11:28.265]                             break
[16:11:28.265]                           }
[16:11:28.265]                         }
[16:11:28.265]                       }
[16:11:28.265]                       invisible(muffled)
[16:11:28.265]                     }
[16:11:28.265]                     muffleCondition(cond, pattern = "^muffle")
[16:11:28.265]                   }
[16:11:28.265]                 }
[16:11:28.265]             }
[16:11:28.265]         }))
[16:11:28.265]     }, error = function(ex) {
[16:11:28.265]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:28.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:28.265]                 ...future.rng), started = ...future.startTime, 
[16:11:28.265]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:28.265]             version = "1.8"), class = "FutureResult")
[16:11:28.265]     }, finally = {
[16:11:28.265]         if (!identical(...future.workdir, getwd())) 
[16:11:28.265]             setwd(...future.workdir)
[16:11:28.265]         {
[16:11:28.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:28.265]                 ...future.oldOptions$nwarnings <- NULL
[16:11:28.265]             }
[16:11:28.265]             base::options(...future.oldOptions)
[16:11:28.265]             if (.Platform$OS.type == "windows") {
[16:11:28.265]                 old_names <- names(...future.oldEnvVars)
[16:11:28.265]                 envs <- base::Sys.getenv()
[16:11:28.265]                 names <- names(envs)
[16:11:28.265]                 common <- intersect(names, old_names)
[16:11:28.265]                 added <- setdiff(names, old_names)
[16:11:28.265]                 removed <- setdiff(old_names, names)
[16:11:28.265]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:28.265]                   envs[common]]
[16:11:28.265]                 NAMES <- toupper(changed)
[16:11:28.265]                 args <- list()
[16:11:28.265]                 for (kk in seq_along(NAMES)) {
[16:11:28.265]                   name <- changed[[kk]]
[16:11:28.265]                   NAME <- NAMES[[kk]]
[16:11:28.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.265]                     next
[16:11:28.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:28.265]                 }
[16:11:28.265]                 NAMES <- toupper(added)
[16:11:28.265]                 for (kk in seq_along(NAMES)) {
[16:11:28.265]                   name <- added[[kk]]
[16:11:28.265]                   NAME <- NAMES[[kk]]
[16:11:28.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.265]                     next
[16:11:28.265]                   args[[name]] <- ""
[16:11:28.265]                 }
[16:11:28.265]                 NAMES <- toupper(removed)
[16:11:28.265]                 for (kk in seq_along(NAMES)) {
[16:11:28.265]                   name <- removed[[kk]]
[16:11:28.265]                   NAME <- NAMES[[kk]]
[16:11:28.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.265]                     next
[16:11:28.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:28.265]                 }
[16:11:28.265]                 if (length(args) > 0) 
[16:11:28.265]                   base::do.call(base::Sys.setenv, args = args)
[16:11:28.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:28.265]             }
[16:11:28.265]             else {
[16:11:28.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:28.265]             }
[16:11:28.265]             {
[16:11:28.265]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:28.265]                   0L) {
[16:11:28.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:28.265]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:28.265]                   base::options(opts)
[16:11:28.265]                 }
[16:11:28.265]                 {
[16:11:28.265]                   {
[16:11:28.265]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:28.265]                     NULL
[16:11:28.265]                   }
[16:11:28.265]                   options(future.plan = NULL)
[16:11:28.265]                   if (is.na(NA_character_)) 
[16:11:28.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:28.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:28.265]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:28.265]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:28.265]                     envir = parent.frame()) 
[16:11:28.265]                   {
[16:11:28.265]                     if (is.function(workers)) 
[16:11:28.265]                       workers <- workers()
[16:11:28.265]                     workers <- structure(as.integer(workers), 
[16:11:28.265]                       class = class(workers))
[16:11:28.265]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:28.265]                       workers >= 1)
[16:11:28.265]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:28.265]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:28.265]                     }
[16:11:28.265]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:28.265]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:28.265]                       envir = envir)
[16:11:28.265]                     if (!future$lazy) 
[16:11:28.265]                       future <- run(future)
[16:11:28.265]                     invisible(future)
[16:11:28.265]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:28.265]                 }
[16:11:28.265]             }
[16:11:28.265]         }
[16:11:28.265]     })
[16:11:28.265]     if (TRUE) {
[16:11:28.265]         base::sink(type = "output", split = FALSE)
[16:11:28.265]         if (TRUE) {
[16:11:28.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:28.265]         }
[16:11:28.265]         else {
[16:11:28.265]             ...future.result["stdout"] <- base::list(NULL)
[16:11:28.265]         }
[16:11:28.265]         base::close(...future.stdout)
[16:11:28.265]         ...future.stdout <- NULL
[16:11:28.265]     }
[16:11:28.265]     ...future.result$conditions <- ...future.conditions
[16:11:28.265]     ...future.result$finished <- base::Sys.time()
[16:11:28.265]     ...future.result
[16:11:28.265] }
[16:11:28.268] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:11:28.268] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:11:28.268] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:11:28.269] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:11:28.269] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:11:28.269] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:11:28.269] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:11:28.269] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:28.270] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:28.270] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:28.270] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:28.270] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:11:28.271] MultisessionFuture started
[16:11:28.271] - Launch lazy future ... done
[16:11:28.271] run() for ‘MultisessionFuture’ ... done
[16:11:28.271] Created future:
[16:11:28.271] MultisessionFuture:
[16:11:28.271] Label: ‘future_mapply-2’
[16:11:28.271] Expression:
[16:11:28.271] {
[16:11:28.271]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:28.271]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:28.271]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:28.271]         on.exit(options(oopts), add = TRUE)
[16:11:28.271]     }
[16:11:28.271]     {
[16:11:28.271]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:28.271]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:28.271]         do.call(mapply, args = args)
[16:11:28.271]     }
[16:11:28.271] }
[16:11:28.271] Lazy evaluation: FALSE
[16:11:28.271] Asynchronous evaluation: TRUE
[16:11:28.271] Local evaluation: TRUE
[16:11:28.271] Environment: R_GlobalEnv
[16:11:28.271] Capture standard output: TRUE
[16:11:28.271] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:28.271] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:28.271] Packages: <none>
[16:11:28.271] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:28.271] Resolved: FALSE
[16:11:28.271] Value: <not collected>
[16:11:28.271] Conditions captured: <none>
[16:11:28.271] Early signaling: FALSE
[16:11:28.271] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:28.271] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:28.283] Chunk #2 of 2 ... DONE
[16:11:28.283] Launching 2 futures (chunks) ... DONE
[16:11:28.283] Resolving 2 futures (chunks) ...
[16:11:28.283] resolve() on list ...
[16:11:28.283]  recursive: 0
[16:11:28.283]  length: 2
[16:11:28.283] 
[16:11:28.325] receiveMessageFromWorker() for ClusterFuture ...
[16:11:28.326] - Validating connection of MultisessionFuture
[16:11:28.326] - received message: FutureResult
[16:11:28.326] - Received FutureResult
[16:11:28.326] - Erased future from FutureRegistry
[16:11:28.326] result() for ClusterFuture ...
[16:11:28.326] - result already collected: FutureResult
[16:11:28.326] result() for ClusterFuture ... done
[16:11:28.327] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:28.327] Future #2
[16:11:28.327] result() for ClusterFuture ...
[16:11:28.327] - result already collected: FutureResult
[16:11:28.327] result() for ClusterFuture ... done
[16:11:28.327] result() for ClusterFuture ...
[16:11:28.327] - result already collected: FutureResult
[16:11:28.327] result() for ClusterFuture ... done
[16:11:28.327] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:28.327] - nx: 2
[16:11:28.327] - relay: TRUE
[16:11:28.328] - stdout: TRUE
[16:11:28.328] - signal: TRUE
[16:11:28.328] - resignal: FALSE
[16:11:28.328] - force: TRUE
[16:11:28.328] - relayed: [n=2] FALSE, FALSE
[16:11:28.328] - queued futures: [n=2] FALSE, FALSE
[16:11:28.328]  - until=1
[16:11:28.328]  - relaying element #1
[16:11:28.328] - relayed: [n=2] FALSE, FALSE
[16:11:28.328] - queued futures: [n=2] FALSE, TRUE
[16:11:28.328] signalConditionsASAP(NULL, pos=2) ... done
[16:11:28.329]  length: 1 (resolved future 2)
[16:11:28.778] receiveMessageFromWorker() for ClusterFuture ...
[16:11:28.778] - Validating connection of MultisessionFuture
[16:11:28.778] - received message: FutureResult
[16:11:28.779] - Received FutureResult
[16:11:28.779] - Erased future from FutureRegistry
[16:11:28.779] result() for ClusterFuture ...
[16:11:28.779] - result already collected: FutureResult
[16:11:28.779] result() for ClusterFuture ... done
[16:11:28.779] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:28.779] Future #1
[16:11:28.779] result() for ClusterFuture ...
[16:11:28.779] - result already collected: FutureResult
[16:11:28.779] result() for ClusterFuture ... done
[16:11:28.780] result() for ClusterFuture ...
[16:11:28.780] - result already collected: FutureResult
[16:11:28.780] result() for ClusterFuture ... done
[16:11:28.780] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:28.780] - nx: 2
[16:11:28.780] - relay: TRUE
[16:11:28.780] - stdout: TRUE
[16:11:28.780] - signal: TRUE
[16:11:28.780] - resignal: FALSE
[16:11:28.780] - force: TRUE
[16:11:28.781] - relayed: [n=2] FALSE, FALSE
[16:11:28.781] - queued futures: [n=2] FALSE, TRUE
[16:11:28.781]  - until=1
[16:11:28.781]  - relaying element #1
[16:11:28.781] result() for ClusterFuture ...
[16:11:28.781] - result already collected: FutureResult
[16:11:28.781] result() for ClusterFuture ... done
[16:11:28.781] result() for ClusterFuture ...
[16:11:28.781] - result already collected: FutureResult
[16:11:28.781] result() for ClusterFuture ... done
[16:11:28.782] result() for ClusterFuture ...
[16:11:28.782] - result already collected: FutureResult
[16:11:28.782] result() for ClusterFuture ... done
[16:11:28.782] result() for ClusterFuture ...
[16:11:28.782] - result already collected: FutureResult
[16:11:28.782] result() for ClusterFuture ... done
[16:11:28.782] - relayed: [n=2] TRUE, FALSE
[16:11:28.782] - queued futures: [n=2] TRUE, TRUE
[16:11:28.782] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:28.782]  length: 0 (resolved future 1)
[16:11:28.782] Relaying remaining futures
[16:11:28.783] signalConditionsASAP(NULL, pos=0) ...
[16:11:28.783] - nx: 2
[16:11:28.783] - relay: TRUE
[16:11:28.783] - stdout: TRUE
[16:11:28.783] - signal: TRUE
[16:11:28.783] - resignal: FALSE
[16:11:28.783] - force: TRUE
[16:11:28.783] - relayed: [n=2] TRUE, FALSE
[16:11:28.783] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:28.783]  - relaying element #2
[16:11:28.783] result() for ClusterFuture ...
[16:11:28.784] - result already collected: FutureResult
[16:11:28.784] result() for ClusterFuture ... done
[16:11:28.784] result() for ClusterFuture ...
[16:11:28.784] - result already collected: FutureResult
[16:11:28.784] result() for ClusterFuture ... done
[16:11:28.784] result() for ClusterFuture ...
[16:11:28.784] - result already collected: FutureResult
[16:11:28.784] result() for ClusterFuture ... done
[16:11:28.784] result() for ClusterFuture ...
[16:11:28.784] - result already collected: FutureResult
[16:11:28.785] result() for ClusterFuture ... done
[16:11:28.785] - relayed: [n=2] TRUE, TRUE
[16:11:28.785] - queued futures: [n=2] TRUE, TRUE
[16:11:28.785] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:11:28.785] resolve() on list ... DONE
[16:11:28.785] result() for ClusterFuture ...
[16:11:28.785] - result already collected: FutureResult
[16:11:28.785] result() for ClusterFuture ... done
[16:11:28.785] result() for ClusterFuture ...
[16:11:28.785] - result already collected: FutureResult
[16:11:28.785] result() for ClusterFuture ... done
[16:11:28.786] result() for ClusterFuture ...
[16:11:28.786] - result already collected: FutureResult
[16:11:28.786] result() for ClusterFuture ... done
[16:11:28.786] result() for ClusterFuture ...
[16:11:28.786] - result already collected: FutureResult
[16:11:28.786] result() for ClusterFuture ... done
[16:11:28.786]  - Number of value chunks collected: 2
[16:11:28.786] Resolving 2 futures (chunks) ... DONE
[16:11:28.786] Reducing values from 2 chunks ...
[16:11:28.786]  - Number of values collected after concatenation: 2
[16:11:28.787]  - Number of values expected: 2
[16:11:28.787] Reducing values from 2 chunks ... DONE
[16:11:28.787] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:11:28.787] future_mapply() ...
[16:11:28.791] Number of chunks: 2
[16:11:28.791] getGlobalsAndPackagesXApply() ...
[16:11:28.791]  - future.globals: TRUE
[16:11:28.791] getGlobalsAndPackages() ...
[16:11:28.791] Searching for globals...
[16:11:28.793] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:11:28.793] Searching for globals ... DONE
[16:11:28.793] Resolving globals: FALSE
[16:11:28.794] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:11:28.794] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:11:28.794] - globals: [1] ‘FUN’
[16:11:28.794] 
[16:11:28.794] getGlobalsAndPackages() ... DONE
[16:11:28.794]  - globals found/used: [n=1] ‘FUN’
[16:11:28.795]  - needed namespaces: [n=0] 
[16:11:28.795] Finding globals ... DONE
[16:11:28.795] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:11:28.795] List of 2
[16:11:28.795]  $ ...future.FUN:function (x, y)  
[16:11:28.795]  $ MoreArgs     : NULL
[16:11:28.795]  - attr(*, "where")=List of 2
[16:11:28.795]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:28.795]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:11:28.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:28.795]  - attr(*, "resolved")= logi FALSE
[16:11:28.795]  - attr(*, "total_size")= num NA
[16:11:28.798] Packages to be attached in all futures: [n=0] 
[16:11:28.798] getGlobalsAndPackagesXApply() ... DONE
[16:11:28.798] Number of futures (= number of chunks): 2
[16:11:28.798] Launching 2 futures (chunks) ...
[16:11:28.798] Chunk #1 of 2 ...
[16:11:28.798]  - Finding globals in '...' for chunk #1 ...
[16:11:28.798] getGlobalsAndPackages() ...
[16:11:28.798] Searching for globals...
[16:11:28.799] 
[16:11:28.799] Searching for globals ... DONE
[16:11:28.799] - globals: [0] <none>
[16:11:28.799] getGlobalsAndPackages() ... DONE
[16:11:28.799]    + additional globals found: [n=0] 
[16:11:28.799]    + additional namespaces needed: [n=0] 
[16:11:28.799]  - Finding globals in '...' for chunk #1 ... DONE
[16:11:28.799]  - seeds: <none>
[16:11:28.799] getGlobalsAndPackages() ...
[16:11:28.799] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:28.800] Resolving globals: FALSE
[16:11:28.800] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:28.801] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:28.801] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:28.801] 
[16:11:28.801] getGlobalsAndPackages() ... DONE
[16:11:28.801] run() for ‘Future’ ...
[16:11:28.801] - state: ‘created’
[16:11:28.801] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:28.816] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:28.817] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:28.817]   - Field: ‘node’
[16:11:28.817]   - Field: ‘label’
[16:11:28.817]   - Field: ‘local’
[16:11:28.817]   - Field: ‘owner’
[16:11:28.817]   - Field: ‘envir’
[16:11:28.817]   - Field: ‘workers’
[16:11:28.817]   - Field: ‘packages’
[16:11:28.817]   - Field: ‘gc’
[16:11:28.817]   - Field: ‘conditions’
[16:11:28.818]   - Field: ‘persistent’
[16:11:28.818]   - Field: ‘expr’
[16:11:28.818]   - Field: ‘uuid’
[16:11:28.818]   - Field: ‘seed’
[16:11:28.818]   - Field: ‘version’
[16:11:28.818]   - Field: ‘result’
[16:11:28.818]   - Field: ‘asynchronous’
[16:11:28.818]   - Field: ‘calls’
[16:11:28.818]   - Field: ‘globals’
[16:11:28.818]   - Field: ‘stdout’
[16:11:28.818]   - Field: ‘earlySignal’
[16:11:28.819]   - Field: ‘lazy’
[16:11:28.819]   - Field: ‘state’
[16:11:28.819] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:28.819] - Launch lazy future ...
[16:11:28.819] Packages needed by the future expression (n = 0): <none>
[16:11:28.819] Packages needed by future strategies (n = 0): <none>
[16:11:28.820] {
[16:11:28.820]     {
[16:11:28.820]         {
[16:11:28.820]             ...future.startTime <- base::Sys.time()
[16:11:28.820]             {
[16:11:28.820]                 {
[16:11:28.820]                   {
[16:11:28.820]                     {
[16:11:28.820]                       base::local({
[16:11:28.820]                         has_future <- base::requireNamespace("future", 
[16:11:28.820]                           quietly = TRUE)
[16:11:28.820]                         if (has_future) {
[16:11:28.820]                           ns <- base::getNamespace("future")
[16:11:28.820]                           version <- ns[[".package"]][["version"]]
[16:11:28.820]                           if (is.null(version)) 
[16:11:28.820]                             version <- utils::packageVersion("future")
[16:11:28.820]                         }
[16:11:28.820]                         else {
[16:11:28.820]                           version <- NULL
[16:11:28.820]                         }
[16:11:28.820]                         if (!has_future || version < "1.8.0") {
[16:11:28.820]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:28.820]                             "", base::R.version$version.string), 
[16:11:28.820]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:28.820]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:28.820]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:28.820]                               "release", "version")], collapse = " "), 
[16:11:28.820]                             hostname = base::Sys.info()[["nodename"]])
[16:11:28.820]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:28.820]                             info)
[16:11:28.820]                           info <- base::paste(info, collapse = "; ")
[16:11:28.820]                           if (!has_future) {
[16:11:28.820]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:28.820]                               info)
[16:11:28.820]                           }
[16:11:28.820]                           else {
[16:11:28.820]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:28.820]                               info, version)
[16:11:28.820]                           }
[16:11:28.820]                           base::stop(msg)
[16:11:28.820]                         }
[16:11:28.820]                       })
[16:11:28.820]                     }
[16:11:28.820]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:28.820]                     base::options(mc.cores = 1L)
[16:11:28.820]                   }
[16:11:28.820]                   options(future.plan = NULL)
[16:11:28.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:28.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:28.820]                 }
[16:11:28.820]                 ...future.workdir <- getwd()
[16:11:28.820]             }
[16:11:28.820]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:28.820]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:28.820]         }
[16:11:28.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:28.820]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:28.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:28.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:28.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:28.820]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:28.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:28.820]             base::names(...future.oldOptions))
[16:11:28.820]     }
[16:11:28.820]     if (TRUE) {
[16:11:28.820]     }
[16:11:28.820]     else {
[16:11:28.820]         if (NA) {
[16:11:28.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:28.820]                 open = "w")
[16:11:28.820]         }
[16:11:28.820]         else {
[16:11:28.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:28.820]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:28.820]         }
[16:11:28.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:28.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:28.820]             base::sink(type = "output", split = FALSE)
[16:11:28.820]             base::close(...future.stdout)
[16:11:28.820]         }, add = TRUE)
[16:11:28.820]     }
[16:11:28.820]     ...future.frame <- base::sys.nframe()
[16:11:28.820]     ...future.conditions <- base::list()
[16:11:28.820]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:28.820]     if (FALSE) {
[16:11:28.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:28.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:28.820]     }
[16:11:28.820]     ...future.result <- base::tryCatch({
[16:11:28.820]         base::withCallingHandlers({
[16:11:28.820]             ...future.value <- base::withVisible(base::local({
[16:11:28.820]                 ...future.makeSendCondition <- local({
[16:11:28.820]                   sendCondition <- NULL
[16:11:28.820]                   function(frame = 1L) {
[16:11:28.820]                     if (is.function(sendCondition)) 
[16:11:28.820]                       return(sendCondition)
[16:11:28.820]                     ns <- getNamespace("parallel")
[16:11:28.820]                     if (exists("sendData", mode = "function", 
[16:11:28.820]                       envir = ns)) {
[16:11:28.820]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:28.820]                         envir = ns)
[16:11:28.820]                       envir <- sys.frame(frame)
[16:11:28.820]                       master <- NULL
[16:11:28.820]                       while (!identical(envir, .GlobalEnv) && 
[16:11:28.820]                         !identical(envir, emptyenv())) {
[16:11:28.820]                         if (exists("master", mode = "list", envir = envir, 
[16:11:28.820]                           inherits = FALSE)) {
[16:11:28.820]                           master <- get("master", mode = "list", 
[16:11:28.820]                             envir = envir, inherits = FALSE)
[16:11:28.820]                           if (inherits(master, c("SOCKnode", 
[16:11:28.820]                             "SOCK0node"))) {
[16:11:28.820]                             sendCondition <<- function(cond) {
[16:11:28.820]                               data <- list(type = "VALUE", value = cond, 
[16:11:28.820]                                 success = TRUE)
[16:11:28.820]                               parallel_sendData(master, data)
[16:11:28.820]                             }
[16:11:28.820]                             return(sendCondition)
[16:11:28.820]                           }
[16:11:28.820]                         }
[16:11:28.820]                         frame <- frame + 1L
[16:11:28.820]                         envir <- sys.frame(frame)
[16:11:28.820]                       }
[16:11:28.820]                     }
[16:11:28.820]                     sendCondition <<- function(cond) NULL
[16:11:28.820]                   }
[16:11:28.820]                 })
[16:11:28.820]                 withCallingHandlers({
[16:11:28.820]                   {
[16:11:28.820]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:28.820]                     if (!identical(...future.globals.maxSize.org, 
[16:11:28.820]                       ...future.globals.maxSize)) {
[16:11:28.820]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:28.820]                       on.exit(options(oopts), add = TRUE)
[16:11:28.820]                     }
[16:11:28.820]                     {
[16:11:28.820]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:28.820]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:28.820]                         USE.NAMES = FALSE)
[16:11:28.820]                       do.call(mapply, args = args)
[16:11:28.820]                     }
[16:11:28.820]                   }
[16:11:28.820]                 }, immediateCondition = function(cond) {
[16:11:28.820]                   sendCondition <- ...future.makeSendCondition()
[16:11:28.820]                   sendCondition(cond)
[16:11:28.820]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.820]                   {
[16:11:28.820]                     inherits <- base::inherits
[16:11:28.820]                     invokeRestart <- base::invokeRestart
[16:11:28.820]                     is.null <- base::is.null
[16:11:28.820]                     muffled <- FALSE
[16:11:28.820]                     if (inherits(cond, "message")) {
[16:11:28.820]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:28.820]                       if (muffled) 
[16:11:28.820]                         invokeRestart("muffleMessage")
[16:11:28.820]                     }
[16:11:28.820]                     else if (inherits(cond, "warning")) {
[16:11:28.820]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:28.820]                       if (muffled) 
[16:11:28.820]                         invokeRestart("muffleWarning")
[16:11:28.820]                     }
[16:11:28.820]                     else if (inherits(cond, "condition")) {
[16:11:28.820]                       if (!is.null(pattern)) {
[16:11:28.820]                         computeRestarts <- base::computeRestarts
[16:11:28.820]                         grepl <- base::grepl
[16:11:28.820]                         restarts <- computeRestarts(cond)
[16:11:28.820]                         for (restart in restarts) {
[16:11:28.820]                           name <- restart$name
[16:11:28.820]                           if (is.null(name)) 
[16:11:28.820]                             next
[16:11:28.820]                           if (!grepl(pattern, name)) 
[16:11:28.820]                             next
[16:11:28.820]                           invokeRestart(restart)
[16:11:28.820]                           muffled <- TRUE
[16:11:28.820]                           break
[16:11:28.820]                         }
[16:11:28.820]                       }
[16:11:28.820]                     }
[16:11:28.820]                     invisible(muffled)
[16:11:28.820]                   }
[16:11:28.820]                   muffleCondition(cond)
[16:11:28.820]                 })
[16:11:28.820]             }))
[16:11:28.820]             future::FutureResult(value = ...future.value$value, 
[16:11:28.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:28.820]                   ...future.rng), globalenv = if (FALSE) 
[16:11:28.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:28.820]                     ...future.globalenv.names))
[16:11:28.820]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:28.820]         }, condition = base::local({
[16:11:28.820]             c <- base::c
[16:11:28.820]             inherits <- base::inherits
[16:11:28.820]             invokeRestart <- base::invokeRestart
[16:11:28.820]             length <- base::length
[16:11:28.820]             list <- base::list
[16:11:28.820]             seq.int <- base::seq.int
[16:11:28.820]             signalCondition <- base::signalCondition
[16:11:28.820]             sys.calls <- base::sys.calls
[16:11:28.820]             `[[` <- base::`[[`
[16:11:28.820]             `+` <- base::`+`
[16:11:28.820]             `<<-` <- base::`<<-`
[16:11:28.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:28.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:28.820]                   3L)]
[16:11:28.820]             }
[16:11:28.820]             function(cond) {
[16:11:28.820]                 is_error <- inherits(cond, "error")
[16:11:28.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:28.820]                   NULL)
[16:11:28.820]                 if (is_error) {
[16:11:28.820]                   sessionInformation <- function() {
[16:11:28.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:28.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:28.820]                       search = base::search(), system = base::Sys.info())
[16:11:28.820]                   }
[16:11:28.820]                   ...future.conditions[[length(...future.conditions) + 
[16:11:28.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:28.820]                     cond$call), session = sessionInformation(), 
[16:11:28.820]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:28.820]                   signalCondition(cond)
[16:11:28.820]                 }
[16:11:28.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:28.820]                 "immediateCondition"))) {
[16:11:28.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:28.820]                   ...future.conditions[[length(...future.conditions) + 
[16:11:28.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:28.820]                   if (TRUE && !signal) {
[16:11:28.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.820]                     {
[16:11:28.820]                       inherits <- base::inherits
[16:11:28.820]                       invokeRestart <- base::invokeRestart
[16:11:28.820]                       is.null <- base::is.null
[16:11:28.820]                       muffled <- FALSE
[16:11:28.820]                       if (inherits(cond, "message")) {
[16:11:28.820]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:28.820]                         if (muffled) 
[16:11:28.820]                           invokeRestart("muffleMessage")
[16:11:28.820]                       }
[16:11:28.820]                       else if (inherits(cond, "warning")) {
[16:11:28.820]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:28.820]                         if (muffled) 
[16:11:28.820]                           invokeRestart("muffleWarning")
[16:11:28.820]                       }
[16:11:28.820]                       else if (inherits(cond, "condition")) {
[16:11:28.820]                         if (!is.null(pattern)) {
[16:11:28.820]                           computeRestarts <- base::computeRestarts
[16:11:28.820]                           grepl <- base::grepl
[16:11:28.820]                           restarts <- computeRestarts(cond)
[16:11:28.820]                           for (restart in restarts) {
[16:11:28.820]                             name <- restart$name
[16:11:28.820]                             if (is.null(name)) 
[16:11:28.820]                               next
[16:11:28.820]                             if (!grepl(pattern, name)) 
[16:11:28.820]                               next
[16:11:28.820]                             invokeRestart(restart)
[16:11:28.820]                             muffled <- TRUE
[16:11:28.820]                             break
[16:11:28.820]                           }
[16:11:28.820]                         }
[16:11:28.820]                       }
[16:11:28.820]                       invisible(muffled)
[16:11:28.820]                     }
[16:11:28.820]                     muffleCondition(cond, pattern = "^muffle")
[16:11:28.820]                   }
[16:11:28.820]                 }
[16:11:28.820]                 else {
[16:11:28.820]                   if (TRUE) {
[16:11:28.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.820]                     {
[16:11:28.820]                       inherits <- base::inherits
[16:11:28.820]                       invokeRestart <- base::invokeRestart
[16:11:28.820]                       is.null <- base::is.null
[16:11:28.820]                       muffled <- FALSE
[16:11:28.820]                       if (inherits(cond, "message")) {
[16:11:28.820]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:28.820]                         if (muffled) 
[16:11:28.820]                           invokeRestart("muffleMessage")
[16:11:28.820]                       }
[16:11:28.820]                       else if (inherits(cond, "warning")) {
[16:11:28.820]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:28.820]                         if (muffled) 
[16:11:28.820]                           invokeRestart("muffleWarning")
[16:11:28.820]                       }
[16:11:28.820]                       else if (inherits(cond, "condition")) {
[16:11:28.820]                         if (!is.null(pattern)) {
[16:11:28.820]                           computeRestarts <- base::computeRestarts
[16:11:28.820]                           grepl <- base::grepl
[16:11:28.820]                           restarts <- computeRestarts(cond)
[16:11:28.820]                           for (restart in restarts) {
[16:11:28.820]                             name <- restart$name
[16:11:28.820]                             if (is.null(name)) 
[16:11:28.820]                               next
[16:11:28.820]                             if (!grepl(pattern, name)) 
[16:11:28.820]                               next
[16:11:28.820]                             invokeRestart(restart)
[16:11:28.820]                             muffled <- TRUE
[16:11:28.820]                             break
[16:11:28.820]                           }
[16:11:28.820]                         }
[16:11:28.820]                       }
[16:11:28.820]                       invisible(muffled)
[16:11:28.820]                     }
[16:11:28.820]                     muffleCondition(cond, pattern = "^muffle")
[16:11:28.820]                   }
[16:11:28.820]                 }
[16:11:28.820]             }
[16:11:28.820]         }))
[16:11:28.820]     }, error = function(ex) {
[16:11:28.820]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:28.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:28.820]                 ...future.rng), started = ...future.startTime, 
[16:11:28.820]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:28.820]             version = "1.8"), class = "FutureResult")
[16:11:28.820]     }, finally = {
[16:11:28.820]         if (!identical(...future.workdir, getwd())) 
[16:11:28.820]             setwd(...future.workdir)
[16:11:28.820]         {
[16:11:28.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:28.820]                 ...future.oldOptions$nwarnings <- NULL
[16:11:28.820]             }
[16:11:28.820]             base::options(...future.oldOptions)
[16:11:28.820]             if (.Platform$OS.type == "windows") {
[16:11:28.820]                 old_names <- names(...future.oldEnvVars)
[16:11:28.820]                 envs <- base::Sys.getenv()
[16:11:28.820]                 names <- names(envs)
[16:11:28.820]                 common <- intersect(names, old_names)
[16:11:28.820]                 added <- setdiff(names, old_names)
[16:11:28.820]                 removed <- setdiff(old_names, names)
[16:11:28.820]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:28.820]                   envs[common]]
[16:11:28.820]                 NAMES <- toupper(changed)
[16:11:28.820]                 args <- list()
[16:11:28.820]                 for (kk in seq_along(NAMES)) {
[16:11:28.820]                   name <- changed[[kk]]
[16:11:28.820]                   NAME <- NAMES[[kk]]
[16:11:28.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.820]                     next
[16:11:28.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:28.820]                 }
[16:11:28.820]                 NAMES <- toupper(added)
[16:11:28.820]                 for (kk in seq_along(NAMES)) {
[16:11:28.820]                   name <- added[[kk]]
[16:11:28.820]                   NAME <- NAMES[[kk]]
[16:11:28.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.820]                     next
[16:11:28.820]                   args[[name]] <- ""
[16:11:28.820]                 }
[16:11:28.820]                 NAMES <- toupper(removed)
[16:11:28.820]                 for (kk in seq_along(NAMES)) {
[16:11:28.820]                   name <- removed[[kk]]
[16:11:28.820]                   NAME <- NAMES[[kk]]
[16:11:28.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.820]                     next
[16:11:28.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:28.820]                 }
[16:11:28.820]                 if (length(args) > 0) 
[16:11:28.820]                   base::do.call(base::Sys.setenv, args = args)
[16:11:28.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:28.820]             }
[16:11:28.820]             else {
[16:11:28.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:28.820]             }
[16:11:28.820]             {
[16:11:28.820]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:28.820]                   0L) {
[16:11:28.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:28.820]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:28.820]                   base::options(opts)
[16:11:28.820]                 }
[16:11:28.820]                 {
[16:11:28.820]                   {
[16:11:28.820]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:28.820]                     NULL
[16:11:28.820]                   }
[16:11:28.820]                   options(future.plan = NULL)
[16:11:28.820]                   if (is.na(NA_character_)) 
[16:11:28.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:28.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:28.820]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:28.820]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:28.820]                     envir = parent.frame()) 
[16:11:28.820]                   {
[16:11:28.820]                     if (is.function(workers)) 
[16:11:28.820]                       workers <- workers()
[16:11:28.820]                     workers <- structure(as.integer(workers), 
[16:11:28.820]                       class = class(workers))
[16:11:28.820]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:28.820]                       workers >= 1)
[16:11:28.820]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:28.820]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:28.820]                     }
[16:11:28.820]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:28.820]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:28.820]                       envir = envir)
[16:11:28.820]                     if (!future$lazy) 
[16:11:28.820]                       future <- run(future)
[16:11:28.820]                     invisible(future)
[16:11:28.820]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:28.820]                 }
[16:11:28.820]             }
[16:11:28.820]         }
[16:11:28.820]     })
[16:11:28.820]     if (FALSE) {
[16:11:28.820]         base::sink(type = "output", split = FALSE)
[16:11:28.820]         if (NA) {
[16:11:28.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:28.820]         }
[16:11:28.820]         else {
[16:11:28.820]             ...future.result["stdout"] <- base::list(NULL)
[16:11:28.820]         }
[16:11:28.820]         base::close(...future.stdout)
[16:11:28.820]         ...future.stdout <- NULL
[16:11:28.820]     }
[16:11:28.820]     ...future.result$conditions <- ...future.conditions
[16:11:28.820]     ...future.result$finished <- base::Sys.time()
[16:11:28.820]     ...future.result
[16:11:28.820] }
[16:11:28.823] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:11:28.823] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:11:28.824] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:11:28.824] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:11:28.824] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:11:28.824] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:11:28.825] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:11:28.825] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:28.825] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:28.825] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:28.825] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:28.826] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:11:28.826] MultisessionFuture started
[16:11:28.826] - Launch lazy future ... done
[16:11:28.826] run() for ‘MultisessionFuture’ ... done
[16:11:28.827] Created future:
[16:11:28.827] MultisessionFuture:
[16:11:28.827] Label: ‘future_mapply-1’
[16:11:28.827] Expression:
[16:11:28.827] {
[16:11:28.827]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:28.827]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:28.827]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:28.827]         on.exit(options(oopts), add = TRUE)
[16:11:28.827]     }
[16:11:28.827]     {
[16:11:28.827]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:28.827]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:28.827]         do.call(mapply, args = args)
[16:11:28.827]     }
[16:11:28.827] }
[16:11:28.827] Lazy evaluation: FALSE
[16:11:28.827] Asynchronous evaluation: TRUE
[16:11:28.827] Local evaluation: TRUE
[16:11:28.827] Environment: R_GlobalEnv
[16:11:28.827] Capture standard output: NA
[16:11:28.827] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:28.827] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:28.827] Packages: <none>
[16:11:28.827] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:28.827] Resolved: FALSE
[16:11:28.827] Value: <not collected>
[16:11:28.827] Conditions captured: <none>
[16:11:28.827] Early signaling: FALSE
[16:11:28.827] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:28.827] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:28.838] Chunk #1 of 2 ... DONE
[16:11:28.838] Chunk #2 of 2 ...
[16:11:28.839]  - Finding globals in '...' for chunk #2 ...
[16:11:28.839] getGlobalsAndPackages() ...
[16:11:28.839] Searching for globals...
[16:11:28.839] 
[16:11:28.839] Searching for globals ... DONE
[16:11:28.839] - globals: [0] <none>
[16:11:28.839] getGlobalsAndPackages() ... DONE
[16:11:28.840]    + additional globals found: [n=0] 
[16:11:28.840]    + additional namespaces needed: [n=0] 
[16:11:28.840]  - Finding globals in '...' for chunk #2 ... DONE
[16:11:28.840]  - seeds: <none>
[16:11:28.840] getGlobalsAndPackages() ...
[16:11:28.840] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:28.840] Resolving globals: FALSE
[16:11:28.841] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:11:28.841] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:11:28.841] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:28.842] 
[16:11:28.842] getGlobalsAndPackages() ... DONE
[16:11:28.842] run() for ‘Future’ ...
[16:11:28.842] - state: ‘created’
[16:11:28.842] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:28.857] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:28.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:28.858]   - Field: ‘node’
[16:11:28.858]   - Field: ‘label’
[16:11:28.858]   - Field: ‘local’
[16:11:28.858]   - Field: ‘owner’
[16:11:28.858]   - Field: ‘envir’
[16:11:28.858]   - Field: ‘workers’
[16:11:28.858]   - Field: ‘packages’
[16:11:28.858]   - Field: ‘gc’
[16:11:28.859]   - Field: ‘conditions’
[16:11:28.859]   - Field: ‘persistent’
[16:11:28.859]   - Field: ‘expr’
[16:11:28.859]   - Field: ‘uuid’
[16:11:28.859]   - Field: ‘seed’
[16:11:28.859]   - Field: ‘version’
[16:11:28.859]   - Field: ‘result’
[16:11:28.859]   - Field: ‘asynchronous’
[16:11:28.859]   - Field: ‘calls’
[16:11:28.859]   - Field: ‘globals’
[16:11:28.859]   - Field: ‘stdout’
[16:11:28.860]   - Field: ‘earlySignal’
[16:11:28.860]   - Field: ‘lazy’
[16:11:28.860]   - Field: ‘state’
[16:11:28.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:28.860] - Launch lazy future ...
[16:11:28.860] Packages needed by the future expression (n = 0): <none>
[16:11:28.860] Packages needed by future strategies (n = 0): <none>
[16:11:28.861] {
[16:11:28.861]     {
[16:11:28.861]         {
[16:11:28.861]             ...future.startTime <- base::Sys.time()
[16:11:28.861]             {
[16:11:28.861]                 {
[16:11:28.861]                   {
[16:11:28.861]                     {
[16:11:28.861]                       base::local({
[16:11:28.861]                         has_future <- base::requireNamespace("future", 
[16:11:28.861]                           quietly = TRUE)
[16:11:28.861]                         if (has_future) {
[16:11:28.861]                           ns <- base::getNamespace("future")
[16:11:28.861]                           version <- ns[[".package"]][["version"]]
[16:11:28.861]                           if (is.null(version)) 
[16:11:28.861]                             version <- utils::packageVersion("future")
[16:11:28.861]                         }
[16:11:28.861]                         else {
[16:11:28.861]                           version <- NULL
[16:11:28.861]                         }
[16:11:28.861]                         if (!has_future || version < "1.8.0") {
[16:11:28.861]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:28.861]                             "", base::R.version$version.string), 
[16:11:28.861]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:28.861]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:28.861]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:28.861]                               "release", "version")], collapse = " "), 
[16:11:28.861]                             hostname = base::Sys.info()[["nodename"]])
[16:11:28.861]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:28.861]                             info)
[16:11:28.861]                           info <- base::paste(info, collapse = "; ")
[16:11:28.861]                           if (!has_future) {
[16:11:28.861]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:28.861]                               info)
[16:11:28.861]                           }
[16:11:28.861]                           else {
[16:11:28.861]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:28.861]                               info, version)
[16:11:28.861]                           }
[16:11:28.861]                           base::stop(msg)
[16:11:28.861]                         }
[16:11:28.861]                       })
[16:11:28.861]                     }
[16:11:28.861]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:28.861]                     base::options(mc.cores = 1L)
[16:11:28.861]                   }
[16:11:28.861]                   options(future.plan = NULL)
[16:11:28.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:28.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:28.861]                 }
[16:11:28.861]                 ...future.workdir <- getwd()
[16:11:28.861]             }
[16:11:28.861]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:28.861]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:28.861]         }
[16:11:28.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:28.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:28.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:28.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:28.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:28.861]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:28.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:28.861]             base::names(...future.oldOptions))
[16:11:28.861]     }
[16:11:28.861]     if (TRUE) {
[16:11:28.861]     }
[16:11:28.861]     else {
[16:11:28.861]         if (NA) {
[16:11:28.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:28.861]                 open = "w")
[16:11:28.861]         }
[16:11:28.861]         else {
[16:11:28.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:28.861]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:28.861]         }
[16:11:28.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:28.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:28.861]             base::sink(type = "output", split = FALSE)
[16:11:28.861]             base::close(...future.stdout)
[16:11:28.861]         }, add = TRUE)
[16:11:28.861]     }
[16:11:28.861]     ...future.frame <- base::sys.nframe()
[16:11:28.861]     ...future.conditions <- base::list()
[16:11:28.861]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:28.861]     if (FALSE) {
[16:11:28.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:28.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:28.861]     }
[16:11:28.861]     ...future.result <- base::tryCatch({
[16:11:28.861]         base::withCallingHandlers({
[16:11:28.861]             ...future.value <- base::withVisible(base::local({
[16:11:28.861]                 ...future.makeSendCondition <- local({
[16:11:28.861]                   sendCondition <- NULL
[16:11:28.861]                   function(frame = 1L) {
[16:11:28.861]                     if (is.function(sendCondition)) 
[16:11:28.861]                       return(sendCondition)
[16:11:28.861]                     ns <- getNamespace("parallel")
[16:11:28.861]                     if (exists("sendData", mode = "function", 
[16:11:28.861]                       envir = ns)) {
[16:11:28.861]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:28.861]                         envir = ns)
[16:11:28.861]                       envir <- sys.frame(frame)
[16:11:28.861]                       master <- NULL
[16:11:28.861]                       while (!identical(envir, .GlobalEnv) && 
[16:11:28.861]                         !identical(envir, emptyenv())) {
[16:11:28.861]                         if (exists("master", mode = "list", envir = envir, 
[16:11:28.861]                           inherits = FALSE)) {
[16:11:28.861]                           master <- get("master", mode = "list", 
[16:11:28.861]                             envir = envir, inherits = FALSE)
[16:11:28.861]                           if (inherits(master, c("SOCKnode", 
[16:11:28.861]                             "SOCK0node"))) {
[16:11:28.861]                             sendCondition <<- function(cond) {
[16:11:28.861]                               data <- list(type = "VALUE", value = cond, 
[16:11:28.861]                                 success = TRUE)
[16:11:28.861]                               parallel_sendData(master, data)
[16:11:28.861]                             }
[16:11:28.861]                             return(sendCondition)
[16:11:28.861]                           }
[16:11:28.861]                         }
[16:11:28.861]                         frame <- frame + 1L
[16:11:28.861]                         envir <- sys.frame(frame)
[16:11:28.861]                       }
[16:11:28.861]                     }
[16:11:28.861]                     sendCondition <<- function(cond) NULL
[16:11:28.861]                   }
[16:11:28.861]                 })
[16:11:28.861]                 withCallingHandlers({
[16:11:28.861]                   {
[16:11:28.861]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:28.861]                     if (!identical(...future.globals.maxSize.org, 
[16:11:28.861]                       ...future.globals.maxSize)) {
[16:11:28.861]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:28.861]                       on.exit(options(oopts), add = TRUE)
[16:11:28.861]                     }
[16:11:28.861]                     {
[16:11:28.861]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:28.861]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:11:28.861]                         USE.NAMES = FALSE)
[16:11:28.861]                       do.call(mapply, args = args)
[16:11:28.861]                     }
[16:11:28.861]                   }
[16:11:28.861]                 }, immediateCondition = function(cond) {
[16:11:28.861]                   sendCondition <- ...future.makeSendCondition()
[16:11:28.861]                   sendCondition(cond)
[16:11:28.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.861]                   {
[16:11:28.861]                     inherits <- base::inherits
[16:11:28.861]                     invokeRestart <- base::invokeRestart
[16:11:28.861]                     is.null <- base::is.null
[16:11:28.861]                     muffled <- FALSE
[16:11:28.861]                     if (inherits(cond, "message")) {
[16:11:28.861]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:28.861]                       if (muffled) 
[16:11:28.861]                         invokeRestart("muffleMessage")
[16:11:28.861]                     }
[16:11:28.861]                     else if (inherits(cond, "warning")) {
[16:11:28.861]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:28.861]                       if (muffled) 
[16:11:28.861]                         invokeRestart("muffleWarning")
[16:11:28.861]                     }
[16:11:28.861]                     else if (inherits(cond, "condition")) {
[16:11:28.861]                       if (!is.null(pattern)) {
[16:11:28.861]                         computeRestarts <- base::computeRestarts
[16:11:28.861]                         grepl <- base::grepl
[16:11:28.861]                         restarts <- computeRestarts(cond)
[16:11:28.861]                         for (restart in restarts) {
[16:11:28.861]                           name <- restart$name
[16:11:28.861]                           if (is.null(name)) 
[16:11:28.861]                             next
[16:11:28.861]                           if (!grepl(pattern, name)) 
[16:11:28.861]                             next
[16:11:28.861]                           invokeRestart(restart)
[16:11:28.861]                           muffled <- TRUE
[16:11:28.861]                           break
[16:11:28.861]                         }
[16:11:28.861]                       }
[16:11:28.861]                     }
[16:11:28.861]                     invisible(muffled)
[16:11:28.861]                   }
[16:11:28.861]                   muffleCondition(cond)
[16:11:28.861]                 })
[16:11:28.861]             }))
[16:11:28.861]             future::FutureResult(value = ...future.value$value, 
[16:11:28.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:28.861]                   ...future.rng), globalenv = if (FALSE) 
[16:11:28.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:28.861]                     ...future.globalenv.names))
[16:11:28.861]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:28.861]         }, condition = base::local({
[16:11:28.861]             c <- base::c
[16:11:28.861]             inherits <- base::inherits
[16:11:28.861]             invokeRestart <- base::invokeRestart
[16:11:28.861]             length <- base::length
[16:11:28.861]             list <- base::list
[16:11:28.861]             seq.int <- base::seq.int
[16:11:28.861]             signalCondition <- base::signalCondition
[16:11:28.861]             sys.calls <- base::sys.calls
[16:11:28.861]             `[[` <- base::`[[`
[16:11:28.861]             `+` <- base::`+`
[16:11:28.861]             `<<-` <- base::`<<-`
[16:11:28.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:28.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:28.861]                   3L)]
[16:11:28.861]             }
[16:11:28.861]             function(cond) {
[16:11:28.861]                 is_error <- inherits(cond, "error")
[16:11:28.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:28.861]                   NULL)
[16:11:28.861]                 if (is_error) {
[16:11:28.861]                   sessionInformation <- function() {
[16:11:28.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:28.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:28.861]                       search = base::search(), system = base::Sys.info())
[16:11:28.861]                   }
[16:11:28.861]                   ...future.conditions[[length(...future.conditions) + 
[16:11:28.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:28.861]                     cond$call), session = sessionInformation(), 
[16:11:28.861]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:28.861]                   signalCondition(cond)
[16:11:28.861]                 }
[16:11:28.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:28.861]                 "immediateCondition"))) {
[16:11:28.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:28.861]                   ...future.conditions[[length(...future.conditions) + 
[16:11:28.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:28.861]                   if (TRUE && !signal) {
[16:11:28.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.861]                     {
[16:11:28.861]                       inherits <- base::inherits
[16:11:28.861]                       invokeRestart <- base::invokeRestart
[16:11:28.861]                       is.null <- base::is.null
[16:11:28.861]                       muffled <- FALSE
[16:11:28.861]                       if (inherits(cond, "message")) {
[16:11:28.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:28.861]                         if (muffled) 
[16:11:28.861]                           invokeRestart("muffleMessage")
[16:11:28.861]                       }
[16:11:28.861]                       else if (inherits(cond, "warning")) {
[16:11:28.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:28.861]                         if (muffled) 
[16:11:28.861]                           invokeRestart("muffleWarning")
[16:11:28.861]                       }
[16:11:28.861]                       else if (inherits(cond, "condition")) {
[16:11:28.861]                         if (!is.null(pattern)) {
[16:11:28.861]                           computeRestarts <- base::computeRestarts
[16:11:28.861]                           grepl <- base::grepl
[16:11:28.861]                           restarts <- computeRestarts(cond)
[16:11:28.861]                           for (restart in restarts) {
[16:11:28.861]                             name <- restart$name
[16:11:28.861]                             if (is.null(name)) 
[16:11:28.861]                               next
[16:11:28.861]                             if (!grepl(pattern, name)) 
[16:11:28.861]                               next
[16:11:28.861]                             invokeRestart(restart)
[16:11:28.861]                             muffled <- TRUE
[16:11:28.861]                             break
[16:11:28.861]                           }
[16:11:28.861]                         }
[16:11:28.861]                       }
[16:11:28.861]                       invisible(muffled)
[16:11:28.861]                     }
[16:11:28.861]                     muffleCondition(cond, pattern = "^muffle")
[16:11:28.861]                   }
[16:11:28.861]                 }
[16:11:28.861]                 else {
[16:11:28.861]                   if (TRUE) {
[16:11:28.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:28.861]                     {
[16:11:28.861]                       inherits <- base::inherits
[16:11:28.861]                       invokeRestart <- base::invokeRestart
[16:11:28.861]                       is.null <- base::is.null
[16:11:28.861]                       muffled <- FALSE
[16:11:28.861]                       if (inherits(cond, "message")) {
[16:11:28.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:28.861]                         if (muffled) 
[16:11:28.861]                           invokeRestart("muffleMessage")
[16:11:28.861]                       }
[16:11:28.861]                       else if (inherits(cond, "warning")) {
[16:11:28.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:28.861]                         if (muffled) 
[16:11:28.861]                           invokeRestart("muffleWarning")
[16:11:28.861]                       }
[16:11:28.861]                       else if (inherits(cond, "condition")) {
[16:11:28.861]                         if (!is.null(pattern)) {
[16:11:28.861]                           computeRestarts <- base::computeRestarts
[16:11:28.861]                           grepl <- base::grepl
[16:11:28.861]                           restarts <- computeRestarts(cond)
[16:11:28.861]                           for (restart in restarts) {
[16:11:28.861]                             name <- restart$name
[16:11:28.861]                             if (is.null(name)) 
[16:11:28.861]                               next
[16:11:28.861]                             if (!grepl(pattern, name)) 
[16:11:28.861]                               next
[16:11:28.861]                             invokeRestart(restart)
[16:11:28.861]                             muffled <- TRUE
[16:11:28.861]                             break
[16:11:28.861]                           }
[16:11:28.861]                         }
[16:11:28.861]                       }
[16:11:28.861]                       invisible(muffled)
[16:11:28.861]                     }
[16:11:28.861]                     muffleCondition(cond, pattern = "^muffle")
[16:11:28.861]                   }
[16:11:28.861]                 }
[16:11:28.861]             }
[16:11:28.861]         }))
[16:11:28.861]     }, error = function(ex) {
[16:11:28.861]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:28.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:28.861]                 ...future.rng), started = ...future.startTime, 
[16:11:28.861]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:28.861]             version = "1.8"), class = "FutureResult")
[16:11:28.861]     }, finally = {
[16:11:28.861]         if (!identical(...future.workdir, getwd())) 
[16:11:28.861]             setwd(...future.workdir)
[16:11:28.861]         {
[16:11:28.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:28.861]                 ...future.oldOptions$nwarnings <- NULL
[16:11:28.861]             }
[16:11:28.861]             base::options(...future.oldOptions)
[16:11:28.861]             if (.Platform$OS.type == "windows") {
[16:11:28.861]                 old_names <- names(...future.oldEnvVars)
[16:11:28.861]                 envs <- base::Sys.getenv()
[16:11:28.861]                 names <- names(envs)
[16:11:28.861]                 common <- intersect(names, old_names)
[16:11:28.861]                 added <- setdiff(names, old_names)
[16:11:28.861]                 removed <- setdiff(old_names, names)
[16:11:28.861]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:28.861]                   envs[common]]
[16:11:28.861]                 NAMES <- toupper(changed)
[16:11:28.861]                 args <- list()
[16:11:28.861]                 for (kk in seq_along(NAMES)) {
[16:11:28.861]                   name <- changed[[kk]]
[16:11:28.861]                   NAME <- NAMES[[kk]]
[16:11:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.861]                     next
[16:11:28.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:28.861]                 }
[16:11:28.861]                 NAMES <- toupper(added)
[16:11:28.861]                 for (kk in seq_along(NAMES)) {
[16:11:28.861]                   name <- added[[kk]]
[16:11:28.861]                   NAME <- NAMES[[kk]]
[16:11:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.861]                     next
[16:11:28.861]                   args[[name]] <- ""
[16:11:28.861]                 }
[16:11:28.861]                 NAMES <- toupper(removed)
[16:11:28.861]                 for (kk in seq_along(NAMES)) {
[16:11:28.861]                   name <- removed[[kk]]
[16:11:28.861]                   NAME <- NAMES[[kk]]
[16:11:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:28.861]                     next
[16:11:28.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:28.861]                 }
[16:11:28.861]                 if (length(args) > 0) 
[16:11:28.861]                   base::do.call(base::Sys.setenv, args = args)
[16:11:28.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:28.861]             }
[16:11:28.861]             else {
[16:11:28.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:28.861]             }
[16:11:28.861]             {
[16:11:28.861]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:28.861]                   0L) {
[16:11:28.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:28.861]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:28.861]                   base::options(opts)
[16:11:28.861]                 }
[16:11:28.861]                 {
[16:11:28.861]                   {
[16:11:28.861]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:28.861]                     NULL
[16:11:28.861]                   }
[16:11:28.861]                   options(future.plan = NULL)
[16:11:28.861]                   if (is.na(NA_character_)) 
[16:11:28.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:28.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:28.861]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:28.861]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:28.861]                     envir = parent.frame()) 
[16:11:28.861]                   {
[16:11:28.861]                     if (is.function(workers)) 
[16:11:28.861]                       workers <- workers()
[16:11:28.861]                     workers <- structure(as.integer(workers), 
[16:11:28.861]                       class = class(workers))
[16:11:28.861]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:28.861]                       workers >= 1)
[16:11:28.861]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:28.861]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:28.861]                     }
[16:11:28.861]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:28.861]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:28.861]                       envir = envir)
[16:11:28.861]                     if (!future$lazy) 
[16:11:28.861]                       future <- run(future)
[16:11:28.861]                     invisible(future)
[16:11:28.861]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:28.861]                 }
[16:11:28.861]             }
[16:11:28.861]         }
[16:11:28.861]     })
[16:11:28.861]     if (FALSE) {
[16:11:28.861]         base::sink(type = "output", split = FALSE)
[16:11:28.861]         if (NA) {
[16:11:28.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:28.861]         }
[16:11:28.861]         else {
[16:11:28.861]             ...future.result["stdout"] <- base::list(NULL)
[16:11:28.861]         }
[16:11:28.861]         base::close(...future.stdout)
[16:11:28.861]         ...future.stdout <- NULL
[16:11:28.861]     }
[16:11:28.861]     ...future.result$conditions <- ...future.conditions
[16:11:28.861]     ...future.result$finished <- base::Sys.time()
[16:11:28.861]     ...future.result
[16:11:28.861] }
[16:11:28.864] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:11:28.864] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:11:28.865] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:11:28.865] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:11:28.865] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:11:28.865] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:11:28.865] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:11:28.866] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:28.866] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:28.866] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:28.866] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:28.866] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:11:28.867] MultisessionFuture started
[16:11:28.867] - Launch lazy future ... done
[16:11:28.867] run() for ‘MultisessionFuture’ ... done
[16:11:28.867] Created future:
[16:11:28.868] MultisessionFuture:
[16:11:28.868] Label: ‘future_mapply-2’
[16:11:28.868] Expression:
[16:11:28.868] {
[16:11:28.868]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:28.868]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:28.868]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:28.868]         on.exit(options(oopts), add = TRUE)
[16:11:28.868]     }
[16:11:28.868]     {
[16:11:28.868]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:11:28.868]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:11:28.868]         do.call(mapply, args = args)
[16:11:28.868]     }
[16:11:28.868] }
[16:11:28.868] Lazy evaluation: FALSE
[16:11:28.868] Asynchronous evaluation: TRUE
[16:11:28.868] Local evaluation: TRUE
[16:11:28.868] Environment: R_GlobalEnv
[16:11:28.868] Capture standard output: NA
[16:11:28.868] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:28.868] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:28.868] Packages: <none>
[16:11:28.868] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:28.868] Resolved: FALSE
[16:11:28.868] Value: <not collected>
[16:11:28.868] Conditions captured: <none>
[16:11:28.868] Early signaling: FALSE
[16:11:28.868] Owner process: e4849dd6-a4d7-9458-8017-ba5173636007
[16:11:28.868] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:28.879] Chunk #2 of 2 ... DONE
[16:11:28.879] Launching 2 futures (chunks) ... DONE
[16:11:28.880] Resolving 2 futures (chunks) ...
[16:11:28.880] resolve() on list ...
[16:11:28.880]  recursive: 0
[16:11:28.880]  length: 2
[16:11:28.880] 
[16:11:28.923] receiveMessageFromWorker() for ClusterFuture ...
[16:11:28.923] - Validating connection of MultisessionFuture
[16:11:28.923] - received message: FutureResult
[16:11:28.923] - Received FutureResult
[16:11:28.924] - Erased future from FutureRegistry
[16:11:28.924] result() for ClusterFuture ...
[16:11:28.924] - result already collected: FutureResult
[16:11:28.924] result() for ClusterFuture ... done
[16:11:28.924] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:28.924] Future #2
[16:11:28.924] result() for ClusterFuture ...
[16:11:28.924] - result already collected: FutureResult
[16:11:28.924] result() for ClusterFuture ... done
[16:11:28.924] result() for ClusterFuture ...
[16:11:28.925] - result already collected: FutureResult
[16:11:28.925] result() for ClusterFuture ... done
[16:11:28.925] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:28.925] - nx: 2
[16:11:28.925] - relay: TRUE
[16:11:28.925] - stdout: TRUE
[16:11:28.925] - signal: TRUE
[16:11:28.925] - resignal: FALSE
[16:11:28.925] - force: TRUE
[16:11:28.925] - relayed: [n=2] FALSE, FALSE
[16:11:28.926] - queued futures: [n=2] FALSE, FALSE
[16:11:28.926]  - until=1
[16:11:28.926]  - relaying element #1
[16:11:28.926] - relayed: [n=2] FALSE, FALSE
[16:11:28.926] - queued futures: [n=2] FALSE, TRUE
[16:11:28.926] signalConditionsASAP(NULL, pos=2) ... done
[16:11:28.926]  length: 1 (resolved future 2)
[16:11:29.378] receiveMessageFromWorker() for ClusterFuture ...
[16:11:29.378] - Validating connection of MultisessionFuture
[16:11:29.378] - received message: FutureResult
[16:11:29.378] - Received FutureResult
[16:11:29.378] - Erased future from FutureRegistry
[16:11:29.378] result() for ClusterFuture ...
[16:11:29.378] - result already collected: FutureResult
[16:11:29.379] result() for ClusterFuture ... done
[16:11:29.379] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:29.379] Future #1
[16:11:29.379] result() for ClusterFuture ...
[16:11:29.379] - result already collected: FutureResult
[16:11:29.379] result() for ClusterFuture ... done
[16:11:29.379] result() for ClusterFuture ...
[16:11:29.379] - result already collected: FutureResult
[16:11:29.379] result() for ClusterFuture ... done
[16:11:29.382] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:29.382] - nx: 2
[16:11:29.382] - relay: TRUE
[16:11:29.382] - stdout: TRUE
[16:11:29.382] - signal: TRUE
[16:11:29.382] - resignal: FALSE
[16:11:29.382] - force: TRUE
[16:11:29.382] - relayed: [n=2] FALSE, FALSE
[16:11:29.382] - queued futures: [n=2] FALSE, TRUE
[16:11:29.382]  - until=1
[16:11:29.382]  - relaying element #1
[16:11:29.382] result() for ClusterFuture ...
[16:11:29.383] - result already collected: FutureResult
[16:11:29.383] result() for ClusterFuture ... done
[16:11:29.383] result() for ClusterFuture ...
[16:11:29.383] - result already collected: FutureResult
[16:11:29.383] result() for ClusterFuture ... done
[16:11:29.383] result() for ClusterFuture ...
[16:11:29.383] - result already collected: FutureResult
[16:11:29.383] result() for ClusterFuture ... done
[16:11:29.383] result() for ClusterFuture ...
[16:11:29.383] - result already collected: FutureResult
[16:11:29.383] result() for ClusterFuture ... done
[16:11:29.383] - relayed: [n=2] TRUE, FALSE
[16:11:29.384] - queued futures: [n=2] TRUE, TRUE
[16:11:29.384] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:29.384]  length: 0 (resolved future 1)
[16:11:29.384] Relaying remaining futures
[16:11:29.384] signalConditionsASAP(NULL, pos=0) ...
[16:11:29.384] - nx: 2
[16:11:29.384] - relay: TRUE
[16:11:29.384] - stdout: TRUE
[16:11:29.384] - signal: TRUE
[16:11:29.384] - resignal: FALSE
[16:11:29.384] - force: TRUE
[16:11:29.385] - relayed: [n=2] TRUE, FALSE
[16:11:29.385] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:29.385]  - relaying element #2
[16:11:29.385] result() for ClusterFuture ...
[16:11:29.385] - result already collected: FutureResult
[16:11:29.385] result() for ClusterFuture ... done
[16:11:29.385] result() for ClusterFuture ...
[16:11:29.385] - result already collected: FutureResult
[16:11:29.385] result() for ClusterFuture ... done
[16:11:29.385] result() for ClusterFuture ...
[16:11:29.386] - result already collected: FutureResult
[16:11:29.386] result() for ClusterFuture ... done
[16:11:29.386] result() for ClusterFuture ...
[16:11:29.386] - result already collected: FutureResult
[16:11:29.386] result() for ClusterFuture ... done
[16:11:29.386] - relayed: [n=2] TRUE, TRUE
[16:11:29.386] - queued futures: [n=2] TRUE, TRUE
[16:11:29.386] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:11:29.386] resolve() on list ... DONE
[16:11:29.386] result() for ClusterFuture ...
[16:11:29.386] - result already collected: FutureResult
[16:11:29.386] result() for ClusterFuture ... done
[16:11:29.386] result() for ClusterFuture ...
[16:11:29.387] - result already collected: FutureResult
[16:11:29.387] result() for ClusterFuture ... done
[16:11:29.387] result() for ClusterFuture ...
[16:11:29.387] - result already collected: FutureResult
[16:11:29.387] result() for ClusterFuture ... done
[16:11:29.387] result() for ClusterFuture ...
[16:11:29.387] - result already collected: FutureResult
[16:11:29.387] result() for ClusterFuture ... done
[16:11:29.387]  - Number of value chunks collected: 2
[16:11:29.387] Resolving 2 futures (chunks) ... DONE
[16:11:29.387] Reducing values from 2 chunks ...
[16:11:29.388]  - Number of values collected after concatenation: 2
[16:11:29.388]  - Number of values expected: 2
[16:11:29.388] Reducing values from 2 chunks ... DONE
[16:11:29.388] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[16:11:29.389] plan(): Setting new future strategy stack:
[16:11:29.389] List of future strategies:
[16:11:29.389] 1. FutureStrategy:
[16:11:29.389]    - args: function (..., envir = parent.frame())
[16:11:29.389]    - tweaked: FALSE
[16:11:29.389]    - call: future::plan(oplan)
[16:11:29.390] plan(): nbrOfWorkers() = 1
> 
