
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:41:05.840] plan(): Setting new future strategy stack:
[17:41:05.840] List of future strategies:
[17:41:05.840] 1. sequential:
[17:41:05.840]    - args: function (..., envir = parent.frame())
[17:41:05.840]    - tweaked: FALSE
[17:41:05.840]    - call: future::plan("sequential")
[17:41:05.850] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[17:41:05.883] plan(): Setting new future strategy stack:
[17:41:05.883] List of future strategies:
[17:41:05.883] 1. sequential:
[17:41:05.883]    - args: function (..., envir = parent.frame())
[17:41:05.883]    - tweaked: FALSE
[17:41:05.883]    - call: plan(strategy)
[17:41:05.893] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:41:05.894] future_lapply() ...
[17:41:05.898] Number of chunks: 1
[17:41:05.898] getGlobalsAndPackagesXApply() ...
[17:41:05.899]  - future.globals: TRUE
[17:41:05.899] getGlobalsAndPackages() ...
[17:41:05.901] Searching for globals...
[17:41:05.904] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:05.904] Searching for globals ... DONE
[17:41:05.904] Resolving globals: FALSE
[17:41:05.905] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:05.906] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:05.906] - globals: [1] ‘FUN’
[17:41:05.906] 
[17:41:05.906] getGlobalsAndPackages() ... DONE
[17:41:05.906]  - globals found/used: [n=1] ‘FUN’
[17:41:05.906]  - needed namespaces: [n=0] 
[17:41:05.906] Finding globals ... DONE
[17:41:05.906]  - use_args: TRUE
[17:41:05.906]  - Getting '...' globals ...
[17:41:05.907] resolve() on list ...
[17:41:05.907]  recursive: 0
[17:41:05.908]  length: 1
[17:41:05.908]  elements: ‘...’
[17:41:05.908]  length: 0 (resolved future 1)
[17:41:05.908] resolve() on list ... DONE
[17:41:05.908]    - '...' content: [n=0] 
[17:41:05.908] List of 1
[17:41:05.908]  $ ...: list()
[17:41:05.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:05.908]  - attr(*, "where")=List of 1
[17:41:05.908]   ..$ ...:<environment: 0x55c988fdab48> 
[17:41:05.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:05.908]  - attr(*, "resolved")= logi TRUE
[17:41:05.908]  - attr(*, "total_size")= num NA
[17:41:05.913]  - Getting '...' globals ... DONE
[17:41:05.914] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:05.914] List of 2
[17:41:05.914]  $ ...future.FUN:function (x)  
[17:41:05.914]  $ ...          : list()
[17:41:05.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:05.914]  - attr(*, "where")=List of 2
[17:41:05.914]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:05.914]   ..$ ...          :<environment: 0x55c988fdab48> 
[17:41:05.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:05.914]  - attr(*, "resolved")= logi FALSE
[17:41:05.914]  - attr(*, "total_size")= num 4720
[17:41:05.916] Packages to be attached in all futures: [n=0] 
[17:41:05.916] getGlobalsAndPackagesXApply() ... DONE
[17:41:05.917] Number of futures (= number of chunks): 1
[17:41:05.917] Launching 1 futures (chunks) ...
[17:41:05.917] Chunk #1 of 1 ...
[17:41:05.917]  - Finding globals in 'X' for chunk #1 ...
[17:41:05.917] getGlobalsAndPackages() ...
[17:41:05.917] Searching for globals...
[17:41:05.918] 
[17:41:05.918] Searching for globals ... DONE
[17:41:05.918] - globals: [0] <none>
[17:41:05.918] getGlobalsAndPackages() ... DONE
[17:41:05.918]    + additional globals found: [n=0] 
[17:41:05.918]    + additional namespaces needed: [n=0] 
[17:41:05.918]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:05.919]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:05.919]  - seeds: <none>
[17:41:05.919] getGlobalsAndPackages() ...
[17:41:05.919] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:05.919] Resolving globals: FALSE
[17:41:05.919] Tweak future expression to call with '...' arguments ...
[17:41:05.919] {
[17:41:05.919]     do.call(function(...) {
[17:41:05.919]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:05.919]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:05.919]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:05.919]             on.exit(options(oopts), add = TRUE)
[17:41:05.919]         }
[17:41:05.919]         {
[17:41:05.919]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:05.919]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:05.919]                 ...future.FUN(...future.X_jj, ...)
[17:41:05.919]             })
[17:41:05.919]         }
[17:41:05.919]     }, args = future.call.arguments)
[17:41:05.919] }
[17:41:05.920] Tweak future expression to call with '...' arguments ... DONE
[17:41:05.920] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:05.920] 
[17:41:05.920] getGlobalsAndPackages() ... DONE
[17:41:05.921] run() for ‘Future’ ...
[17:41:05.921] - state: ‘created’
[17:41:05.921] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:05.922] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:05.922] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:05.922]   - Field: ‘label’
[17:41:05.922]   - Field: ‘local’
[17:41:05.922]   - Field: ‘owner’
[17:41:05.922]   - Field: ‘envir’
[17:41:05.922]   - Field: ‘packages’
[17:41:05.922]   - Field: ‘gc’
[17:41:05.922]   - Field: ‘conditions’
[17:41:05.922]   - Field: ‘expr’
[17:41:05.923]   - Field: ‘uuid’
[17:41:05.923]   - Field: ‘seed’
[17:41:05.923]   - Field: ‘version’
[17:41:05.923]   - Field: ‘result’
[17:41:05.923]   - Field: ‘asynchronous’
[17:41:05.923]   - Field: ‘calls’
[17:41:05.923]   - Field: ‘globals’
[17:41:05.923]   - Field: ‘stdout’
[17:41:05.923]   - Field: ‘earlySignal’
[17:41:05.923]   - Field: ‘lazy’
[17:41:05.924]   - Field: ‘state’
[17:41:05.924] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:05.924] - Launch lazy future ...
[17:41:05.925] Packages needed by the future expression (n = 0): <none>
[17:41:05.925] Packages needed by future strategies (n = 0): <none>
[17:41:05.925] {
[17:41:05.925]     {
[17:41:05.925]         {
[17:41:05.925]             ...future.startTime <- base::Sys.time()
[17:41:05.925]             {
[17:41:05.925]                 {
[17:41:05.925]                   {
[17:41:05.925]                     base::local({
[17:41:05.925]                       has_future <- base::requireNamespace("future", 
[17:41:05.925]                         quietly = TRUE)
[17:41:05.925]                       if (has_future) {
[17:41:05.925]                         ns <- base::getNamespace("future")
[17:41:05.925]                         version <- ns[[".package"]][["version"]]
[17:41:05.925]                         if (is.null(version)) 
[17:41:05.925]                           version <- utils::packageVersion("future")
[17:41:05.925]                       }
[17:41:05.925]                       else {
[17:41:05.925]                         version <- NULL
[17:41:05.925]                       }
[17:41:05.925]                       if (!has_future || version < "1.8.0") {
[17:41:05.925]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:05.925]                           "", base::R.version$version.string), 
[17:41:05.925]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:05.925]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:05.925]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:05.925]                             "release", "version")], collapse = " "), 
[17:41:05.925]                           hostname = base::Sys.info()[["nodename"]])
[17:41:05.925]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:05.925]                           info)
[17:41:05.925]                         info <- base::paste(info, collapse = "; ")
[17:41:05.925]                         if (!has_future) {
[17:41:05.925]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:05.925]                             info)
[17:41:05.925]                         }
[17:41:05.925]                         else {
[17:41:05.925]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:05.925]                             info, version)
[17:41:05.925]                         }
[17:41:05.925]                         base::stop(msg)
[17:41:05.925]                       }
[17:41:05.925]                     })
[17:41:05.925]                   }
[17:41:05.925]                   options(future.plan = NULL)
[17:41:05.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:05.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:05.925]                 }
[17:41:05.925]                 ...future.workdir <- getwd()
[17:41:05.925]             }
[17:41:05.925]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:05.925]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:05.925]         }
[17:41:05.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:05.925]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:05.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:05.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:05.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:05.925]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:05.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:05.925]             base::names(...future.oldOptions))
[17:41:05.925]     }
[17:41:05.925]     if (FALSE) {
[17:41:05.925]     }
[17:41:05.925]     else {
[17:41:05.925]         if (FALSE) {
[17:41:05.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:05.925]                 open = "w")
[17:41:05.925]         }
[17:41:05.925]         else {
[17:41:05.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:05.925]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:05.925]         }
[17:41:05.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:05.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:05.925]             base::sink(type = "output", split = FALSE)
[17:41:05.925]             base::close(...future.stdout)
[17:41:05.925]         }, add = TRUE)
[17:41:05.925]     }
[17:41:05.925]     ...future.frame <- base::sys.nframe()
[17:41:05.925]     ...future.conditions <- base::list()
[17:41:05.925]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:05.925]     if (FALSE) {
[17:41:05.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:05.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:05.925]     }
[17:41:05.925]     ...future.result <- base::tryCatch({
[17:41:05.925]         base::withCallingHandlers({
[17:41:05.925]             ...future.value <- base::withVisible(base::local({
[17:41:05.925]                 do.call(function(...) {
[17:41:05.925]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:05.925]                   if (!identical(...future.globals.maxSize.org, 
[17:41:05.925]                     ...future.globals.maxSize)) {
[17:41:05.925]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:05.925]                     on.exit(options(oopts), add = TRUE)
[17:41:05.925]                   }
[17:41:05.925]                   {
[17:41:05.925]                     lapply(seq_along(...future.elements_ii), 
[17:41:05.925]                       FUN = function(jj) {
[17:41:05.925]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:05.925]                         ...future.FUN(...future.X_jj, ...)
[17:41:05.925]                       })
[17:41:05.925]                   }
[17:41:05.925]                 }, args = future.call.arguments)
[17:41:05.925]             }))
[17:41:05.925]             future::FutureResult(value = ...future.value$value, 
[17:41:05.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:05.925]                   ...future.rng), globalenv = if (FALSE) 
[17:41:05.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:05.925]                     ...future.globalenv.names))
[17:41:05.925]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:05.925]         }, condition = base::local({
[17:41:05.925]             c <- base::c
[17:41:05.925]             inherits <- base::inherits
[17:41:05.925]             invokeRestart <- base::invokeRestart
[17:41:05.925]             length <- base::length
[17:41:05.925]             list <- base::list
[17:41:05.925]             seq.int <- base::seq.int
[17:41:05.925]             signalCondition <- base::signalCondition
[17:41:05.925]             sys.calls <- base::sys.calls
[17:41:05.925]             `[[` <- base::`[[`
[17:41:05.925]             `+` <- base::`+`
[17:41:05.925]             `<<-` <- base::`<<-`
[17:41:05.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:05.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:05.925]                   3L)]
[17:41:05.925]             }
[17:41:05.925]             function(cond) {
[17:41:05.925]                 is_error <- inherits(cond, "error")
[17:41:05.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:05.925]                   NULL)
[17:41:05.925]                 if (is_error) {
[17:41:05.925]                   sessionInformation <- function() {
[17:41:05.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:05.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:05.925]                       search = base::search(), system = base::Sys.info())
[17:41:05.925]                   }
[17:41:05.925]                   ...future.conditions[[length(...future.conditions) + 
[17:41:05.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:05.925]                     cond$call), session = sessionInformation(), 
[17:41:05.925]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:05.925]                   signalCondition(cond)
[17:41:05.925]                 }
[17:41:05.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:05.925]                 "immediateCondition"))) {
[17:41:05.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:05.925]                   ...future.conditions[[length(...future.conditions) + 
[17:41:05.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:05.925]                   if (TRUE && !signal) {
[17:41:05.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:05.925]                     {
[17:41:05.925]                       inherits <- base::inherits
[17:41:05.925]                       invokeRestart <- base::invokeRestart
[17:41:05.925]                       is.null <- base::is.null
[17:41:05.925]                       muffled <- FALSE
[17:41:05.925]                       if (inherits(cond, "message")) {
[17:41:05.925]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:05.925]                         if (muffled) 
[17:41:05.925]                           invokeRestart("muffleMessage")
[17:41:05.925]                       }
[17:41:05.925]                       else if (inherits(cond, "warning")) {
[17:41:05.925]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:05.925]                         if (muffled) 
[17:41:05.925]                           invokeRestart("muffleWarning")
[17:41:05.925]                       }
[17:41:05.925]                       else if (inherits(cond, "condition")) {
[17:41:05.925]                         if (!is.null(pattern)) {
[17:41:05.925]                           computeRestarts <- base::computeRestarts
[17:41:05.925]                           grepl <- base::grepl
[17:41:05.925]                           restarts <- computeRestarts(cond)
[17:41:05.925]                           for (restart in restarts) {
[17:41:05.925]                             name <- restart$name
[17:41:05.925]                             if (is.null(name)) 
[17:41:05.925]                               next
[17:41:05.925]                             if (!grepl(pattern, name)) 
[17:41:05.925]                               next
[17:41:05.925]                             invokeRestart(restart)
[17:41:05.925]                             muffled <- TRUE
[17:41:05.925]                             break
[17:41:05.925]                           }
[17:41:05.925]                         }
[17:41:05.925]                       }
[17:41:05.925]                       invisible(muffled)
[17:41:05.925]                     }
[17:41:05.925]                     muffleCondition(cond, pattern = "^muffle")
[17:41:05.925]                   }
[17:41:05.925]                 }
[17:41:05.925]                 else {
[17:41:05.925]                   if (TRUE) {
[17:41:05.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:05.925]                     {
[17:41:05.925]                       inherits <- base::inherits
[17:41:05.925]                       invokeRestart <- base::invokeRestart
[17:41:05.925]                       is.null <- base::is.null
[17:41:05.925]                       muffled <- FALSE
[17:41:05.925]                       if (inherits(cond, "message")) {
[17:41:05.925]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:05.925]                         if (muffled) 
[17:41:05.925]                           invokeRestart("muffleMessage")
[17:41:05.925]                       }
[17:41:05.925]                       else if (inherits(cond, "warning")) {
[17:41:05.925]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:05.925]                         if (muffled) 
[17:41:05.925]                           invokeRestart("muffleWarning")
[17:41:05.925]                       }
[17:41:05.925]                       else if (inherits(cond, "condition")) {
[17:41:05.925]                         if (!is.null(pattern)) {
[17:41:05.925]                           computeRestarts <- base::computeRestarts
[17:41:05.925]                           grepl <- base::grepl
[17:41:05.925]                           restarts <- computeRestarts(cond)
[17:41:05.925]                           for (restart in restarts) {
[17:41:05.925]                             name <- restart$name
[17:41:05.925]                             if (is.null(name)) 
[17:41:05.925]                               next
[17:41:05.925]                             if (!grepl(pattern, name)) 
[17:41:05.925]                               next
[17:41:05.925]                             invokeRestart(restart)
[17:41:05.925]                             muffled <- TRUE
[17:41:05.925]                             break
[17:41:05.925]                           }
[17:41:05.925]                         }
[17:41:05.925]                       }
[17:41:05.925]                       invisible(muffled)
[17:41:05.925]                     }
[17:41:05.925]                     muffleCondition(cond, pattern = "^muffle")
[17:41:05.925]                   }
[17:41:05.925]                 }
[17:41:05.925]             }
[17:41:05.925]         }))
[17:41:05.925]     }, error = function(ex) {
[17:41:05.925]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:05.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:05.925]                 ...future.rng), started = ...future.startTime, 
[17:41:05.925]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:05.925]             version = "1.8"), class = "FutureResult")
[17:41:05.925]     }, finally = {
[17:41:05.925]         if (!identical(...future.workdir, getwd())) 
[17:41:05.925]             setwd(...future.workdir)
[17:41:05.925]         {
[17:41:05.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:05.925]                 ...future.oldOptions$nwarnings <- NULL
[17:41:05.925]             }
[17:41:05.925]             base::options(...future.oldOptions)
[17:41:05.925]             if (.Platform$OS.type == "windows") {
[17:41:05.925]                 old_names <- names(...future.oldEnvVars)
[17:41:05.925]                 envs <- base::Sys.getenv()
[17:41:05.925]                 names <- names(envs)
[17:41:05.925]                 common <- intersect(names, old_names)
[17:41:05.925]                 added <- setdiff(names, old_names)
[17:41:05.925]                 removed <- setdiff(old_names, names)
[17:41:05.925]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:05.925]                   envs[common]]
[17:41:05.925]                 NAMES <- toupper(changed)
[17:41:05.925]                 args <- list()
[17:41:05.925]                 for (kk in seq_along(NAMES)) {
[17:41:05.925]                   name <- changed[[kk]]
[17:41:05.925]                   NAME <- NAMES[[kk]]
[17:41:05.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:05.925]                     next
[17:41:05.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:05.925]                 }
[17:41:05.925]                 NAMES <- toupper(added)
[17:41:05.925]                 for (kk in seq_along(NAMES)) {
[17:41:05.925]                   name <- added[[kk]]
[17:41:05.925]                   NAME <- NAMES[[kk]]
[17:41:05.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:05.925]                     next
[17:41:05.925]                   args[[name]] <- ""
[17:41:05.925]                 }
[17:41:05.925]                 NAMES <- toupper(removed)
[17:41:05.925]                 for (kk in seq_along(NAMES)) {
[17:41:05.925]                   name <- removed[[kk]]
[17:41:05.925]                   NAME <- NAMES[[kk]]
[17:41:05.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:05.925]                     next
[17:41:05.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:05.925]                 }
[17:41:05.925]                 if (length(args) > 0) 
[17:41:05.925]                   base::do.call(base::Sys.setenv, args = args)
[17:41:05.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:05.925]             }
[17:41:05.925]             else {
[17:41:05.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:05.925]             }
[17:41:05.925]             {
[17:41:05.925]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:05.925]                   0L) {
[17:41:05.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:05.925]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:05.925]                   base::options(opts)
[17:41:05.925]                 }
[17:41:05.925]                 {
[17:41:05.925]                   {
[17:41:05.925]                     NULL
[17:41:05.925]                     RNGkind("Mersenne-Twister")
[17:41:05.925]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:05.925]                       inherits = FALSE)
[17:41:05.925]                   }
[17:41:05.925]                   options(future.plan = NULL)
[17:41:05.925]                   if (is.na(NA_character_)) 
[17:41:05.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:05.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:05.925]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:05.925]                   {
[17:41:05.925]                     future <- SequentialFuture(..., envir = envir)
[17:41:05.925]                     if (!future$lazy) 
[17:41:05.925]                       future <- run(future)
[17:41:05.925]                     invisible(future)
[17:41:05.925]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:05.925]                 }
[17:41:05.925]             }
[17:41:05.925]         }
[17:41:05.925]     })
[17:41:05.925]     if (TRUE) {
[17:41:05.925]         base::sink(type = "output", split = FALSE)
[17:41:05.925]         if (FALSE) {
[17:41:05.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:05.925]         }
[17:41:05.925]         else {
[17:41:05.925]             ...future.result["stdout"] <- base::list(NULL)
[17:41:05.925]         }
[17:41:05.925]         base::close(...future.stdout)
[17:41:05.925]         ...future.stdout <- NULL
[17:41:05.925]     }
[17:41:05.925]     ...future.result$conditions <- ...future.conditions
[17:41:05.925]     ...future.result$finished <- base::Sys.time()
[17:41:05.925]     ...future.result
[17:41:05.925] }
[17:41:05.927] assign_globals() ...
[17:41:05.928] List of 5
[17:41:05.928]  $ ...future.FUN            :function (x)  
[17:41:05.928]  $ future.call.arguments    : list()
[17:41:05.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:05.928]  $ ...future.elements_ii    :List of 2
[17:41:05.928]   ..$ : int 1
[17:41:05.928]   ..$ : int 0
[17:41:05.928]  $ ...future.seeds_ii       : NULL
[17:41:05.928]  $ ...future.globals.maxSize: NULL
[17:41:05.928]  - attr(*, "resolved")= logi FALSE
[17:41:05.928]  - attr(*, "total_size")= num 4720
[17:41:05.928]  - attr(*, "where")=List of 5
[17:41:05.928]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:05.928]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:05.928]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:05.928]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:05.928]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:05.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:05.928]  - attr(*, "already-done")= logi TRUE
[17:41:05.932] - reassign environment for ‘...future.FUN’
[17:41:05.932] - copied ‘...future.FUN’ to environment
[17:41:05.932] - copied ‘future.call.arguments’ to environment
[17:41:05.933] - copied ‘...future.elements_ii’ to environment
[17:41:05.933] - copied ‘...future.seeds_ii’ to environment
[17:41:05.933] - copied ‘...future.globals.maxSize’ to environment
[17:41:05.933] assign_globals() ... done
[17:41:05.933] plan(): Setting new future strategy stack:
[17:41:05.933] List of future strategies:
[17:41:05.933] 1. sequential:
[17:41:05.933]    - args: function (..., envir = parent.frame())
[17:41:05.933]    - tweaked: FALSE
[17:41:05.933]    - call: NULL
[17:41:05.934] plan(): nbrOfWorkers() = 1
[17:41:06.438] plan(): Setting new future strategy stack:
[17:41:06.438] List of future strategies:
[17:41:06.438] 1. sequential:
[17:41:06.438]    - args: function (..., envir = parent.frame())
[17:41:06.438]    - tweaked: FALSE
[17:41:06.438]    - call: plan(strategy)
[17:41:06.439] plan(): nbrOfWorkers() = 1
[17:41:06.439] SequentialFuture started (and completed)
[17:41:06.439] - Launch lazy future ... done
[17:41:06.440] run() for ‘SequentialFuture’ ... done
[17:41:06.440] Created future:
[17:41:06.440] SequentialFuture:
[17:41:06.440] Label: ‘future_lapply-1’
[17:41:06.440] Expression:
[17:41:06.440] {
[17:41:06.440]     do.call(function(...) {
[17:41:06.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:06.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:06.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:06.440]             on.exit(options(oopts), add = TRUE)
[17:41:06.440]         }
[17:41:06.440]         {
[17:41:06.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:06.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:06.440]                 ...future.FUN(...future.X_jj, ...)
[17:41:06.440]             })
[17:41:06.440]         }
[17:41:06.440]     }, args = future.call.arguments)
[17:41:06.440] }
[17:41:06.440] Lazy evaluation: FALSE
[17:41:06.440] Asynchronous evaluation: FALSE
[17:41:06.440] Local evaluation: TRUE
[17:41:06.440] Environment: R_GlobalEnv
[17:41:06.440] Capture standard output: FALSE
[17:41:06.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:06.440] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:06.440] Packages: <none>
[17:41:06.440] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:06.440] Resolved: TRUE
[17:41:06.440] Value: 112 bytes of class ‘list’
[17:41:06.440] Early signaling: FALSE
[17:41:06.440] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:06.440] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:06.441] Chunk #1 of 1 ... DONE
[17:41:06.442] Launching 1 futures (chunks) ... DONE
[17:41:06.442] Resolving 1 futures (chunks) ...
[17:41:06.442] resolve() on list ...
[17:41:06.442]  recursive: 0
[17:41:06.442]  length: 1
[17:41:06.442] 
[17:41:06.442] resolved() for ‘SequentialFuture’ ...
[17:41:06.442] - state: ‘finished’
[17:41:06.442] - run: TRUE
[17:41:06.443] - result: ‘FutureResult’
[17:41:06.443] resolved() for ‘SequentialFuture’ ... done
[17:41:06.443] Future #1
[17:41:06.443] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:06.443] - nx: 1
[17:41:06.443] - relay: TRUE
[17:41:06.444] - stdout: TRUE
[17:41:06.444] - signal: TRUE
[17:41:06.444] - resignal: FALSE
[17:41:06.444] - force: TRUE
[17:41:06.444] - relayed: [n=1] FALSE
[17:41:06.444] - queued futures: [n=1] FALSE
[17:41:06.444]  - until=1
[17:41:06.444]  - relaying element #1
[17:41:06.444] - relayed: [n=1] TRUE
[17:41:06.444] - queued futures: [n=1] TRUE
[17:41:06.444] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:06.445]  length: 0 (resolved future 1)
[17:41:06.445] Relaying remaining futures
[17:41:06.445] signalConditionsASAP(NULL, pos=0) ...
[17:41:06.445] - nx: 1
[17:41:06.445] - relay: TRUE
[17:41:06.445] - stdout: TRUE
[17:41:06.445] - signal: TRUE
[17:41:06.445] - resignal: FALSE
[17:41:06.445] - force: TRUE
[17:41:06.445] - relayed: [n=1] TRUE
[17:41:06.446] - queued futures: [n=1] TRUE
 - flush all
[17:41:06.446] - relayed: [n=1] TRUE
[17:41:06.446] - queued futures: [n=1] TRUE
[17:41:06.446] signalConditionsASAP(NULL, pos=0) ... done
[17:41:06.446] resolve() on list ... DONE
[17:41:06.446]  - Number of value chunks collected: 1
[17:41:06.446] Resolving 1 futures (chunks) ... DONE
[17:41:06.446] Reducing values from 1 chunks ...
[17:41:06.446]  - Number of values collected after concatenation: 2
[17:41:06.446]  - Number of values expected: 2
[17:41:06.447] Reducing values from 1 chunks ... DONE
[17:41:06.447] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:41:06.447] future_lapply() ...
[17:41:06.448] Number of chunks: 1
[17:41:06.448] getGlobalsAndPackagesXApply() ...
[17:41:06.448]  - future.globals: TRUE
[17:41:06.448] getGlobalsAndPackages() ...
[17:41:06.448] Searching for globals...
[17:41:06.449] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:06.450] Searching for globals ... DONE
[17:41:06.450] Resolving globals: FALSE
[17:41:06.450] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:06.450] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:06.451] - globals: [1] ‘FUN’
[17:41:06.451] 
[17:41:06.451] getGlobalsAndPackages() ... DONE
[17:41:06.451]  - globals found/used: [n=1] ‘FUN’
[17:41:06.451]  - needed namespaces: [n=0] 
[17:41:06.451] Finding globals ... DONE
[17:41:06.451]  - use_args: TRUE
[17:41:06.451]  - Getting '...' globals ...
[17:41:06.452] resolve() on list ...
[17:41:06.452]  recursive: 0
[17:41:06.452]  length: 1
[17:41:06.452]  elements: ‘...’
[17:41:06.452]  length: 0 (resolved future 1)
[17:41:06.452] resolve() on list ... DONE
[17:41:06.452]    - '...' content: [n=0] 
[17:41:06.452] List of 1
[17:41:06.452]  $ ...: list()
[17:41:06.452]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:06.452]  - attr(*, "where")=List of 1
[17:41:06.452]   ..$ ...:<environment: 0x55c9883a7370> 
[17:41:06.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:06.452]  - attr(*, "resolved")= logi TRUE
[17:41:06.452]  - attr(*, "total_size")= num NA
[17:41:06.455]  - Getting '...' globals ... DONE
[17:41:06.455] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:06.455] List of 2
[17:41:06.455]  $ ...future.FUN:function (x)  
[17:41:06.455]  $ ...          : list()
[17:41:06.455]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:06.455]  - attr(*, "where")=List of 2
[17:41:06.455]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:06.455]   ..$ ...          :<environment: 0x55c9883a7370> 
[17:41:06.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:06.455]  - attr(*, "resolved")= logi FALSE
[17:41:06.455]  - attr(*, "total_size")= num 4720
[17:41:06.458] Packages to be attached in all futures: [n=0] 
[17:41:06.458] getGlobalsAndPackagesXApply() ... DONE
[17:41:06.458] Number of futures (= number of chunks): 1
[17:41:06.458] Launching 1 futures (chunks) ...
[17:41:06.458] Chunk #1 of 1 ...
[17:41:06.458]  - Finding globals in 'X' for chunk #1 ...
[17:41:06.458] getGlobalsAndPackages() ...
[17:41:06.458] Searching for globals...
[17:41:06.459] 
[17:41:06.459] Searching for globals ... DONE
[17:41:06.459] - globals: [0] <none>
[17:41:06.459] getGlobalsAndPackages() ... DONE
[17:41:06.459]    + additional globals found: [n=0] 
[17:41:06.459]    + additional namespaces needed: [n=0] 
[17:41:06.459]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:06.459]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:06.459]  - seeds: <none>
[17:41:06.460] getGlobalsAndPackages() ...
[17:41:06.460] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:06.460] Resolving globals: FALSE
[17:41:06.460] Tweak future expression to call with '...' arguments ...
[17:41:06.460] {
[17:41:06.460]     do.call(function(...) {
[17:41:06.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:06.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:06.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:06.460]             on.exit(options(oopts), add = TRUE)
[17:41:06.460]         }
[17:41:06.460]         {
[17:41:06.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:06.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:06.460]                 ...future.FUN(...future.X_jj, ...)
[17:41:06.460]             })
[17:41:06.460]         }
[17:41:06.460]     }, args = future.call.arguments)
[17:41:06.460] }
[17:41:06.460] Tweak future expression to call with '...' arguments ... DONE
[17:41:06.461] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:06.461] 
[17:41:06.461] getGlobalsAndPackages() ... DONE
[17:41:06.461] run() for ‘Future’ ...
[17:41:06.461] - state: ‘created’
[17:41:06.461] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:06.462] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:06.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:06.462]   - Field: ‘label’
[17:41:06.462]   - Field: ‘local’
[17:41:06.462]   - Field: ‘owner’
[17:41:06.462]   - Field: ‘envir’
[17:41:06.462]   - Field: ‘packages’
[17:41:06.462]   - Field: ‘gc’
[17:41:06.462]   - Field: ‘conditions’
[17:41:06.462]   - Field: ‘expr’
[17:41:06.462]   - Field: ‘uuid’
[17:41:06.464]   - Field: ‘seed’
[17:41:06.464]   - Field: ‘version’
[17:41:06.464]   - Field: ‘result’
[17:41:06.464]   - Field: ‘asynchronous’
[17:41:06.465]   - Field: ‘calls’
[17:41:06.465]   - Field: ‘globals’
[17:41:06.465]   - Field: ‘stdout’
[17:41:06.465]   - Field: ‘earlySignal’
[17:41:06.465]   - Field: ‘lazy’
[17:41:06.465]   - Field: ‘state’
[17:41:06.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:06.465] - Launch lazy future ...
[17:41:06.465] Packages needed by the future expression (n = 0): <none>
[17:41:06.466] Packages needed by future strategies (n = 0): <none>
[17:41:06.466] {
[17:41:06.466]     {
[17:41:06.466]         {
[17:41:06.466]             ...future.startTime <- base::Sys.time()
[17:41:06.466]             {
[17:41:06.466]                 {
[17:41:06.466]                   {
[17:41:06.466]                     base::local({
[17:41:06.466]                       has_future <- base::requireNamespace("future", 
[17:41:06.466]                         quietly = TRUE)
[17:41:06.466]                       if (has_future) {
[17:41:06.466]                         ns <- base::getNamespace("future")
[17:41:06.466]                         version <- ns[[".package"]][["version"]]
[17:41:06.466]                         if (is.null(version)) 
[17:41:06.466]                           version <- utils::packageVersion("future")
[17:41:06.466]                       }
[17:41:06.466]                       else {
[17:41:06.466]                         version <- NULL
[17:41:06.466]                       }
[17:41:06.466]                       if (!has_future || version < "1.8.0") {
[17:41:06.466]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:06.466]                           "", base::R.version$version.string), 
[17:41:06.466]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:06.466]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:06.466]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:06.466]                             "release", "version")], collapse = " "), 
[17:41:06.466]                           hostname = base::Sys.info()[["nodename"]])
[17:41:06.466]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:06.466]                           info)
[17:41:06.466]                         info <- base::paste(info, collapse = "; ")
[17:41:06.466]                         if (!has_future) {
[17:41:06.466]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:06.466]                             info)
[17:41:06.466]                         }
[17:41:06.466]                         else {
[17:41:06.466]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:06.466]                             info, version)
[17:41:06.466]                         }
[17:41:06.466]                         base::stop(msg)
[17:41:06.466]                       }
[17:41:06.466]                     })
[17:41:06.466]                   }
[17:41:06.466]                   options(future.plan = NULL)
[17:41:06.466]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:06.466]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:06.466]                 }
[17:41:06.466]                 ...future.workdir <- getwd()
[17:41:06.466]             }
[17:41:06.466]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:06.466]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:06.466]         }
[17:41:06.466]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:06.466]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:06.466]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:06.466]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:06.466]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:06.466]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:06.466]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:06.466]             base::names(...future.oldOptions))
[17:41:06.466]     }
[17:41:06.466]     if (FALSE) {
[17:41:06.466]     }
[17:41:06.466]     else {
[17:41:06.466]         if (TRUE) {
[17:41:06.466]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:06.466]                 open = "w")
[17:41:06.466]         }
[17:41:06.466]         else {
[17:41:06.466]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:06.466]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:06.466]         }
[17:41:06.466]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:06.466]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:06.466]             base::sink(type = "output", split = FALSE)
[17:41:06.466]             base::close(...future.stdout)
[17:41:06.466]         }, add = TRUE)
[17:41:06.466]     }
[17:41:06.466]     ...future.frame <- base::sys.nframe()
[17:41:06.466]     ...future.conditions <- base::list()
[17:41:06.466]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:06.466]     if (FALSE) {
[17:41:06.466]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:06.466]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:06.466]     }
[17:41:06.466]     ...future.result <- base::tryCatch({
[17:41:06.466]         base::withCallingHandlers({
[17:41:06.466]             ...future.value <- base::withVisible(base::local({
[17:41:06.466]                 do.call(function(...) {
[17:41:06.466]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:06.466]                   if (!identical(...future.globals.maxSize.org, 
[17:41:06.466]                     ...future.globals.maxSize)) {
[17:41:06.466]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:06.466]                     on.exit(options(oopts), add = TRUE)
[17:41:06.466]                   }
[17:41:06.466]                   {
[17:41:06.466]                     lapply(seq_along(...future.elements_ii), 
[17:41:06.466]                       FUN = function(jj) {
[17:41:06.466]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:06.466]                         ...future.FUN(...future.X_jj, ...)
[17:41:06.466]                       })
[17:41:06.466]                   }
[17:41:06.466]                 }, args = future.call.arguments)
[17:41:06.466]             }))
[17:41:06.466]             future::FutureResult(value = ...future.value$value, 
[17:41:06.466]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:06.466]                   ...future.rng), globalenv = if (FALSE) 
[17:41:06.466]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:06.466]                     ...future.globalenv.names))
[17:41:06.466]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:06.466]         }, condition = base::local({
[17:41:06.466]             c <- base::c
[17:41:06.466]             inherits <- base::inherits
[17:41:06.466]             invokeRestart <- base::invokeRestart
[17:41:06.466]             length <- base::length
[17:41:06.466]             list <- base::list
[17:41:06.466]             seq.int <- base::seq.int
[17:41:06.466]             signalCondition <- base::signalCondition
[17:41:06.466]             sys.calls <- base::sys.calls
[17:41:06.466]             `[[` <- base::`[[`
[17:41:06.466]             `+` <- base::`+`
[17:41:06.466]             `<<-` <- base::`<<-`
[17:41:06.466]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:06.466]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:06.466]                   3L)]
[17:41:06.466]             }
[17:41:06.466]             function(cond) {
[17:41:06.466]                 is_error <- inherits(cond, "error")
[17:41:06.466]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:06.466]                   NULL)
[17:41:06.466]                 if (is_error) {
[17:41:06.466]                   sessionInformation <- function() {
[17:41:06.466]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:06.466]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:06.466]                       search = base::search(), system = base::Sys.info())
[17:41:06.466]                   }
[17:41:06.466]                   ...future.conditions[[length(...future.conditions) + 
[17:41:06.466]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:06.466]                     cond$call), session = sessionInformation(), 
[17:41:06.466]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:06.466]                   signalCondition(cond)
[17:41:06.466]                 }
[17:41:06.466]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:06.466]                 "immediateCondition"))) {
[17:41:06.466]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:06.466]                   ...future.conditions[[length(...future.conditions) + 
[17:41:06.466]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:06.466]                   if (TRUE && !signal) {
[17:41:06.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:06.466]                     {
[17:41:06.466]                       inherits <- base::inherits
[17:41:06.466]                       invokeRestart <- base::invokeRestart
[17:41:06.466]                       is.null <- base::is.null
[17:41:06.466]                       muffled <- FALSE
[17:41:06.466]                       if (inherits(cond, "message")) {
[17:41:06.466]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:06.466]                         if (muffled) 
[17:41:06.466]                           invokeRestart("muffleMessage")
[17:41:06.466]                       }
[17:41:06.466]                       else if (inherits(cond, "warning")) {
[17:41:06.466]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:06.466]                         if (muffled) 
[17:41:06.466]                           invokeRestart("muffleWarning")
[17:41:06.466]                       }
[17:41:06.466]                       else if (inherits(cond, "condition")) {
[17:41:06.466]                         if (!is.null(pattern)) {
[17:41:06.466]                           computeRestarts <- base::computeRestarts
[17:41:06.466]                           grepl <- base::grepl
[17:41:06.466]                           restarts <- computeRestarts(cond)
[17:41:06.466]                           for (restart in restarts) {
[17:41:06.466]                             name <- restart$name
[17:41:06.466]                             if (is.null(name)) 
[17:41:06.466]                               next
[17:41:06.466]                             if (!grepl(pattern, name)) 
[17:41:06.466]                               next
[17:41:06.466]                             invokeRestart(restart)
[17:41:06.466]                             muffled <- TRUE
[17:41:06.466]                             break
[17:41:06.466]                           }
[17:41:06.466]                         }
[17:41:06.466]                       }
[17:41:06.466]                       invisible(muffled)
[17:41:06.466]                     }
[17:41:06.466]                     muffleCondition(cond, pattern = "^muffle")
[17:41:06.466]                   }
[17:41:06.466]                 }
[17:41:06.466]                 else {
[17:41:06.466]                   if (TRUE) {
[17:41:06.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:06.466]                     {
[17:41:06.466]                       inherits <- base::inherits
[17:41:06.466]                       invokeRestart <- base::invokeRestart
[17:41:06.466]                       is.null <- base::is.null
[17:41:06.466]                       muffled <- FALSE
[17:41:06.466]                       if (inherits(cond, "message")) {
[17:41:06.466]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:06.466]                         if (muffled) 
[17:41:06.466]                           invokeRestart("muffleMessage")
[17:41:06.466]                       }
[17:41:06.466]                       else if (inherits(cond, "warning")) {
[17:41:06.466]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:06.466]                         if (muffled) 
[17:41:06.466]                           invokeRestart("muffleWarning")
[17:41:06.466]                       }
[17:41:06.466]                       else if (inherits(cond, "condition")) {
[17:41:06.466]                         if (!is.null(pattern)) {
[17:41:06.466]                           computeRestarts <- base::computeRestarts
[17:41:06.466]                           grepl <- base::grepl
[17:41:06.466]                           restarts <- computeRestarts(cond)
[17:41:06.466]                           for (restart in restarts) {
[17:41:06.466]                             name <- restart$name
[17:41:06.466]                             if (is.null(name)) 
[17:41:06.466]                               next
[17:41:06.466]                             if (!grepl(pattern, name)) 
[17:41:06.466]                               next
[17:41:06.466]                             invokeRestart(restart)
[17:41:06.466]                             muffled <- TRUE
[17:41:06.466]                             break
[17:41:06.466]                           }
[17:41:06.466]                         }
[17:41:06.466]                       }
[17:41:06.466]                       invisible(muffled)
[17:41:06.466]                     }
[17:41:06.466]                     muffleCondition(cond, pattern = "^muffle")
[17:41:06.466]                   }
[17:41:06.466]                 }
[17:41:06.466]             }
[17:41:06.466]         }))
[17:41:06.466]     }, error = function(ex) {
[17:41:06.466]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:06.466]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:06.466]                 ...future.rng), started = ...future.startTime, 
[17:41:06.466]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:06.466]             version = "1.8"), class = "FutureResult")
[17:41:06.466]     }, finally = {
[17:41:06.466]         if (!identical(...future.workdir, getwd())) 
[17:41:06.466]             setwd(...future.workdir)
[17:41:06.466]         {
[17:41:06.466]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:06.466]                 ...future.oldOptions$nwarnings <- NULL
[17:41:06.466]             }
[17:41:06.466]             base::options(...future.oldOptions)
[17:41:06.466]             if (.Platform$OS.type == "windows") {
[17:41:06.466]                 old_names <- names(...future.oldEnvVars)
[17:41:06.466]                 envs <- base::Sys.getenv()
[17:41:06.466]                 names <- names(envs)
[17:41:06.466]                 common <- intersect(names, old_names)
[17:41:06.466]                 added <- setdiff(names, old_names)
[17:41:06.466]                 removed <- setdiff(old_names, names)
[17:41:06.466]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:06.466]                   envs[common]]
[17:41:06.466]                 NAMES <- toupper(changed)
[17:41:06.466]                 args <- list()
[17:41:06.466]                 for (kk in seq_along(NAMES)) {
[17:41:06.466]                   name <- changed[[kk]]
[17:41:06.466]                   NAME <- NAMES[[kk]]
[17:41:06.466]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:06.466]                     next
[17:41:06.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:06.466]                 }
[17:41:06.466]                 NAMES <- toupper(added)
[17:41:06.466]                 for (kk in seq_along(NAMES)) {
[17:41:06.466]                   name <- added[[kk]]
[17:41:06.466]                   NAME <- NAMES[[kk]]
[17:41:06.466]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:06.466]                     next
[17:41:06.466]                   args[[name]] <- ""
[17:41:06.466]                 }
[17:41:06.466]                 NAMES <- toupper(removed)
[17:41:06.466]                 for (kk in seq_along(NAMES)) {
[17:41:06.466]                   name <- removed[[kk]]
[17:41:06.466]                   NAME <- NAMES[[kk]]
[17:41:06.466]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:06.466]                     next
[17:41:06.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:06.466]                 }
[17:41:06.466]                 if (length(args) > 0) 
[17:41:06.466]                   base::do.call(base::Sys.setenv, args = args)
[17:41:06.466]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:06.466]             }
[17:41:06.466]             else {
[17:41:06.466]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:06.466]             }
[17:41:06.466]             {
[17:41:06.466]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:06.466]                   0L) {
[17:41:06.466]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:06.466]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:06.466]                   base::options(opts)
[17:41:06.466]                 }
[17:41:06.466]                 {
[17:41:06.466]                   {
[17:41:06.466]                     NULL
[17:41:06.466]                     RNGkind("Mersenne-Twister")
[17:41:06.466]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:06.466]                       inherits = FALSE)
[17:41:06.466]                   }
[17:41:06.466]                   options(future.plan = NULL)
[17:41:06.466]                   if (is.na(NA_character_)) 
[17:41:06.466]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:06.466]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:06.466]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:06.466]                   {
[17:41:06.466]                     future <- SequentialFuture(..., envir = envir)
[17:41:06.466]                     if (!future$lazy) 
[17:41:06.466]                       future <- run(future)
[17:41:06.466]                     invisible(future)
[17:41:06.466]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:06.466]                 }
[17:41:06.466]             }
[17:41:06.466]         }
[17:41:06.466]     })
[17:41:06.466]     if (TRUE) {
[17:41:06.466]         base::sink(type = "output", split = FALSE)
[17:41:06.466]         if (TRUE) {
[17:41:06.466]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:06.466]         }
[17:41:06.466]         else {
[17:41:06.466]             ...future.result["stdout"] <- base::list(NULL)
[17:41:06.466]         }
[17:41:06.466]         base::close(...future.stdout)
[17:41:06.466]         ...future.stdout <- NULL
[17:41:06.466]     }
[17:41:06.466]     ...future.result$conditions <- ...future.conditions
[17:41:06.466]     ...future.result$finished <- base::Sys.time()
[17:41:06.466]     ...future.result
[17:41:06.466] }
[17:41:06.468] assign_globals() ...
[17:41:06.468] List of 5
[17:41:06.468]  $ ...future.FUN            :function (x)  
[17:41:06.468]  $ future.call.arguments    : list()
[17:41:06.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:06.468]  $ ...future.elements_ii    :List of 2
[17:41:06.468]   ..$ : int 1
[17:41:06.468]   ..$ : int 0
[17:41:06.468]  $ ...future.seeds_ii       : NULL
[17:41:06.468]  $ ...future.globals.maxSize: NULL
[17:41:06.468]  - attr(*, "resolved")= logi FALSE
[17:41:06.468]  - attr(*, "total_size")= num 4720
[17:41:06.468]  - attr(*, "where")=List of 5
[17:41:06.468]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:06.468]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:06.468]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:06.468]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:06.468]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:06.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:06.468]  - attr(*, "already-done")= logi TRUE
[17:41:06.472] - reassign environment for ‘...future.FUN’
[17:41:06.473] - copied ‘...future.FUN’ to environment
[17:41:06.473] - copied ‘future.call.arguments’ to environment
[17:41:06.473] - copied ‘...future.elements_ii’ to environment
[17:41:06.473] - copied ‘...future.seeds_ii’ to environment
[17:41:06.473] - copied ‘...future.globals.maxSize’ to environment
[17:41:06.473] assign_globals() ... done
[17:41:06.473] plan(): Setting new future strategy stack:
[17:41:06.473] List of future strategies:
[17:41:06.473] 1. sequential:
[17:41:06.473]    - args: function (..., envir = parent.frame())
[17:41:06.473]    - tweaked: FALSE
[17:41:06.473]    - call: NULL
[17:41:06.474] plan(): nbrOfWorkers() = 1
[17:41:06.975] plan(): Setting new future strategy stack:
[17:41:06.976] List of future strategies:
[17:41:06.976] 1. sequential:
[17:41:06.976]    - args: function (..., envir = parent.frame())
[17:41:06.976]    - tweaked: FALSE
[17:41:06.976]    - call: plan(strategy)
[17:41:06.976] plan(): nbrOfWorkers() = 1
[17:41:06.976] SequentialFuture started (and completed)
[17:41:06.977] - Launch lazy future ... done
[17:41:06.977] run() for ‘SequentialFuture’ ... done
[17:41:06.977] Created future:
[17:41:06.977] SequentialFuture:
[17:41:06.977] Label: ‘future_lapply-1’
[17:41:06.977] Expression:
[17:41:06.977] {
[17:41:06.977]     do.call(function(...) {
[17:41:06.977]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:06.977]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:06.977]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:06.977]             on.exit(options(oopts), add = TRUE)
[17:41:06.977]         }
[17:41:06.977]         {
[17:41:06.977]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:06.977]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:06.977]                 ...future.FUN(...future.X_jj, ...)
[17:41:06.977]             })
[17:41:06.977]         }
[17:41:06.977]     }, args = future.call.arguments)
[17:41:06.977] }
[17:41:06.977] Lazy evaluation: FALSE
[17:41:06.977] Asynchronous evaluation: FALSE
[17:41:06.977] Local evaluation: TRUE
[17:41:06.977] Environment: R_GlobalEnv
[17:41:06.977] Capture standard output: TRUE
[17:41:06.977] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:06.977] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:06.977] Packages: <none>
[17:41:06.977] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:06.977] Resolved: TRUE
[17:41:06.977] Value: 112 bytes of class ‘list’
[17:41:06.977] Early signaling: FALSE
[17:41:06.977] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:06.977] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:06.978] Chunk #1 of 1 ... DONE
[17:41:06.978] Launching 1 futures (chunks) ... DONE
[17:41:06.978] Resolving 1 futures (chunks) ...
[17:41:06.979] resolve() on list ...
[17:41:06.979]  recursive: 0
[17:41:06.979]  length: 1
[17:41:06.979] 
[17:41:06.979] resolved() for ‘SequentialFuture’ ...
[17:41:06.979] - state: ‘finished’
[17:41:06.979] - run: TRUE
[17:41:06.979] - result: ‘FutureResult’
[17:41:06.979] resolved() for ‘SequentialFuture’ ... done
[17:41:06.979] Future #1
[17:41:06.980] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:06.980] - nx: 1
[17:41:06.980] - relay: TRUE
[17:41:06.980] - stdout: TRUE
[17:41:06.980] - signal: TRUE
[17:41:06.980] - resignal: FALSE
[17:41:06.980] - force: TRUE
[17:41:06.980] - relayed: [n=1] FALSE
[17:41:06.980] - queued futures: [n=1] FALSE
[17:41:06.980]  - until=1
[17:41:06.980]  - relaying element #1
[17:41:06.981] - relayed: [n=1] TRUE
[17:41:06.981] - queued futures: [n=1] TRUE
[17:41:06.981] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:06.981]  length: 0 (resolved future 1)
[17:41:06.981] Relaying remaining futures
[17:41:06.981] signalConditionsASAP(NULL, pos=0) ...
[17:41:06.981] - nx: 1
[17:41:06.981] - relay: TRUE
[17:41:06.981] - stdout: TRUE
[17:41:06.981] - signal: TRUE
[17:41:06.981] - resignal: FALSE
[17:41:06.982] - force: TRUE
[17:41:06.982] - relayed: [n=1] TRUE
[17:41:06.982] - queued futures: [n=1] TRUE
 - flush all
[17:41:06.982] - relayed: [n=1] TRUE
[17:41:06.982] - queued futures: [n=1] TRUE
[17:41:06.982] signalConditionsASAP(NULL, pos=0) ... done
[17:41:06.982] resolve() on list ... DONE
[17:41:06.982]  - Number of value chunks collected: 1
[17:41:06.982] Resolving 1 futures (chunks) ... DONE
[17:41:06.982] Reducing values from 1 chunks ...
[17:41:06.983]  - Number of values collected after concatenation: 2
[17:41:06.983]  - Number of values expected: 2
[17:41:06.983] Reducing values from 1 chunks ... DONE
[17:41:06.983] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:41:06.983] future_lapply() ...
[17:41:06.984] Number of chunks: 1
[17:41:06.984] getGlobalsAndPackagesXApply() ...
[17:41:06.984]  - future.globals: TRUE
[17:41:06.984] getGlobalsAndPackages() ...
[17:41:06.984] Searching for globals...
[17:41:06.986] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:06.986] Searching for globals ... DONE
[17:41:06.986] Resolving globals: FALSE
[17:41:06.986] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:06.987] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:06.987] - globals: [1] ‘FUN’
[17:41:06.987] 
[17:41:06.987] getGlobalsAndPackages() ... DONE
[17:41:06.987]  - globals found/used: [n=1] ‘FUN’
[17:41:06.987]  - needed namespaces: [n=0] 
[17:41:06.987] Finding globals ... DONE
[17:41:06.987]  - use_args: TRUE
[17:41:06.987]  - Getting '...' globals ...
[17:41:06.988] resolve() on list ...
[17:41:06.988]  recursive: 0
[17:41:06.988]  length: 1
[17:41:06.988]  elements: ‘...’
[17:41:06.988]  length: 0 (resolved future 1)
[17:41:06.988] resolve() on list ... DONE
[17:41:06.988]    - '...' content: [n=0] 
[17:41:06.988] List of 1
[17:41:06.988]  $ ...: list()
[17:41:06.988]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:06.988]  - attr(*, "where")=List of 1
[17:41:06.988]   ..$ ...:<environment: 0x55c988b8cff0> 
[17:41:06.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:06.988]  - attr(*, "resolved")= logi TRUE
[17:41:06.988]  - attr(*, "total_size")= num NA
[17:41:06.993]  - Getting '...' globals ... DONE
[17:41:06.993] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:06.993] List of 2
[17:41:06.993]  $ ...future.FUN:function (x)  
[17:41:06.993]  $ ...          : list()
[17:41:06.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:06.993]  - attr(*, "where")=List of 2
[17:41:06.993]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:06.993]   ..$ ...          :<environment: 0x55c988b8cff0> 
[17:41:06.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:06.993]  - attr(*, "resolved")= logi FALSE
[17:41:06.993]  - attr(*, "total_size")= num 4720
[17:41:06.996] Packages to be attached in all futures: [n=0] 
[17:41:06.996] getGlobalsAndPackagesXApply() ... DONE
[17:41:06.996] Number of futures (= number of chunks): 1
[17:41:06.996] Launching 1 futures (chunks) ...
[17:41:06.996] Chunk #1 of 1 ...
[17:41:06.996]  - Finding globals in 'X' for chunk #1 ...
[17:41:06.996] getGlobalsAndPackages() ...
[17:41:06.996] Searching for globals...
[17:41:06.997] 
[17:41:06.997] Searching for globals ... DONE
[17:41:06.997] - globals: [0] <none>
[17:41:06.997] getGlobalsAndPackages() ... DONE
[17:41:06.997]    + additional globals found: [n=0] 
[17:41:06.997]    + additional namespaces needed: [n=0] 
[17:41:06.997]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:06.997]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:06.997]  - seeds: <none>
[17:41:06.997] getGlobalsAndPackages() ...
[17:41:06.997] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:06.998] Resolving globals: FALSE
[17:41:06.998] Tweak future expression to call with '...' arguments ...
[17:41:06.998] {
[17:41:06.998]     do.call(function(...) {
[17:41:06.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:06.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:06.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:06.998]             on.exit(options(oopts), add = TRUE)
[17:41:06.998]         }
[17:41:06.998]         {
[17:41:06.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:06.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:06.998]                 ...future.FUN(...future.X_jj, ...)
[17:41:06.998]             })
[17:41:06.998]         }
[17:41:06.998]     }, args = future.call.arguments)
[17:41:06.998] }
[17:41:06.998] Tweak future expression to call with '...' arguments ... DONE
[17:41:06.998] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:06.999] 
[17:41:06.999] getGlobalsAndPackages() ... DONE
[17:41:06.999] run() for ‘Future’ ...
[17:41:06.999] - state: ‘created’
[17:41:06.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:06.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:07.000] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:07.000]   - Field: ‘label’
[17:41:07.000]   - Field: ‘local’
[17:41:07.000]   - Field: ‘owner’
[17:41:07.000]   - Field: ‘envir’
[17:41:07.000]   - Field: ‘packages’
[17:41:07.000]   - Field: ‘gc’
[17:41:07.000]   - Field: ‘conditions’
[17:41:07.000]   - Field: ‘expr’
[17:41:07.000]   - Field: ‘uuid’
[17:41:07.000]   - Field: ‘seed’
[17:41:07.001]   - Field: ‘version’
[17:41:07.001]   - Field: ‘result’
[17:41:07.001]   - Field: ‘asynchronous’
[17:41:07.001]   - Field: ‘calls’
[17:41:07.001]   - Field: ‘globals’
[17:41:07.001]   - Field: ‘stdout’
[17:41:07.001]   - Field: ‘earlySignal’
[17:41:07.001]   - Field: ‘lazy’
[17:41:07.001]   - Field: ‘state’
[17:41:07.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:07.001] - Launch lazy future ...
[17:41:07.002] Packages needed by the future expression (n = 0): <none>
[17:41:07.002] Packages needed by future strategies (n = 0): <none>
[17:41:07.002] {
[17:41:07.002]     {
[17:41:07.002]         {
[17:41:07.002]             ...future.startTime <- base::Sys.time()
[17:41:07.002]             {
[17:41:07.002]                 {
[17:41:07.002]                   {
[17:41:07.002]                     base::local({
[17:41:07.002]                       has_future <- base::requireNamespace("future", 
[17:41:07.002]                         quietly = TRUE)
[17:41:07.002]                       if (has_future) {
[17:41:07.002]                         ns <- base::getNamespace("future")
[17:41:07.002]                         version <- ns[[".package"]][["version"]]
[17:41:07.002]                         if (is.null(version)) 
[17:41:07.002]                           version <- utils::packageVersion("future")
[17:41:07.002]                       }
[17:41:07.002]                       else {
[17:41:07.002]                         version <- NULL
[17:41:07.002]                       }
[17:41:07.002]                       if (!has_future || version < "1.8.0") {
[17:41:07.002]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:07.002]                           "", base::R.version$version.string), 
[17:41:07.002]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:07.002]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:07.002]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:07.002]                             "release", "version")], collapse = " "), 
[17:41:07.002]                           hostname = base::Sys.info()[["nodename"]])
[17:41:07.002]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:07.002]                           info)
[17:41:07.002]                         info <- base::paste(info, collapse = "; ")
[17:41:07.002]                         if (!has_future) {
[17:41:07.002]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:07.002]                             info)
[17:41:07.002]                         }
[17:41:07.002]                         else {
[17:41:07.002]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:07.002]                             info, version)
[17:41:07.002]                         }
[17:41:07.002]                         base::stop(msg)
[17:41:07.002]                       }
[17:41:07.002]                     })
[17:41:07.002]                   }
[17:41:07.002]                   options(future.plan = NULL)
[17:41:07.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:07.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:07.002]                 }
[17:41:07.002]                 ...future.workdir <- getwd()
[17:41:07.002]             }
[17:41:07.002]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:07.002]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:07.002]         }
[17:41:07.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:07.002]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:07.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:07.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:07.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:07.002]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:07.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:07.002]             base::names(...future.oldOptions))
[17:41:07.002]     }
[17:41:07.002]     if (TRUE) {
[17:41:07.002]     }
[17:41:07.002]     else {
[17:41:07.002]         if (NA) {
[17:41:07.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:07.002]                 open = "w")
[17:41:07.002]         }
[17:41:07.002]         else {
[17:41:07.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:07.002]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:07.002]         }
[17:41:07.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:07.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:07.002]             base::sink(type = "output", split = FALSE)
[17:41:07.002]             base::close(...future.stdout)
[17:41:07.002]         }, add = TRUE)
[17:41:07.002]     }
[17:41:07.002]     ...future.frame <- base::sys.nframe()
[17:41:07.002]     ...future.conditions <- base::list()
[17:41:07.002]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:07.002]     if (FALSE) {
[17:41:07.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:07.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:07.002]     }
[17:41:07.002]     ...future.result <- base::tryCatch({
[17:41:07.002]         base::withCallingHandlers({
[17:41:07.002]             ...future.value <- base::withVisible(base::local({
[17:41:07.002]                 do.call(function(...) {
[17:41:07.002]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:07.002]                   if (!identical(...future.globals.maxSize.org, 
[17:41:07.002]                     ...future.globals.maxSize)) {
[17:41:07.002]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:07.002]                     on.exit(options(oopts), add = TRUE)
[17:41:07.002]                   }
[17:41:07.002]                   {
[17:41:07.002]                     lapply(seq_along(...future.elements_ii), 
[17:41:07.002]                       FUN = function(jj) {
[17:41:07.002]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:07.002]                         ...future.FUN(...future.X_jj, ...)
[17:41:07.002]                       })
[17:41:07.002]                   }
[17:41:07.002]                 }, args = future.call.arguments)
[17:41:07.002]             }))
[17:41:07.002]             future::FutureResult(value = ...future.value$value, 
[17:41:07.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:07.002]                   ...future.rng), globalenv = if (FALSE) 
[17:41:07.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:07.002]                     ...future.globalenv.names))
[17:41:07.002]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:07.002]         }, condition = base::local({
[17:41:07.002]             c <- base::c
[17:41:07.002]             inherits <- base::inherits
[17:41:07.002]             invokeRestart <- base::invokeRestart
[17:41:07.002]             length <- base::length
[17:41:07.002]             list <- base::list
[17:41:07.002]             seq.int <- base::seq.int
[17:41:07.002]             signalCondition <- base::signalCondition
[17:41:07.002]             sys.calls <- base::sys.calls
[17:41:07.002]             `[[` <- base::`[[`
[17:41:07.002]             `+` <- base::`+`
[17:41:07.002]             `<<-` <- base::`<<-`
[17:41:07.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:07.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:07.002]                   3L)]
[17:41:07.002]             }
[17:41:07.002]             function(cond) {
[17:41:07.002]                 is_error <- inherits(cond, "error")
[17:41:07.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:07.002]                   NULL)
[17:41:07.002]                 if (is_error) {
[17:41:07.002]                   sessionInformation <- function() {
[17:41:07.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:07.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:07.002]                       search = base::search(), system = base::Sys.info())
[17:41:07.002]                   }
[17:41:07.002]                   ...future.conditions[[length(...future.conditions) + 
[17:41:07.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:07.002]                     cond$call), session = sessionInformation(), 
[17:41:07.002]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:07.002]                   signalCondition(cond)
[17:41:07.002]                 }
[17:41:07.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:07.002]                 "immediateCondition"))) {
[17:41:07.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:07.002]                   ...future.conditions[[length(...future.conditions) + 
[17:41:07.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:07.002]                   if (TRUE && !signal) {
[17:41:07.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:07.002]                     {
[17:41:07.002]                       inherits <- base::inherits
[17:41:07.002]                       invokeRestart <- base::invokeRestart
[17:41:07.002]                       is.null <- base::is.null
[17:41:07.002]                       muffled <- FALSE
[17:41:07.002]                       if (inherits(cond, "message")) {
[17:41:07.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:07.002]                         if (muffled) 
[17:41:07.002]                           invokeRestart("muffleMessage")
[17:41:07.002]                       }
[17:41:07.002]                       else if (inherits(cond, "warning")) {
[17:41:07.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:07.002]                         if (muffled) 
[17:41:07.002]                           invokeRestart("muffleWarning")
[17:41:07.002]                       }
[17:41:07.002]                       else if (inherits(cond, "condition")) {
[17:41:07.002]                         if (!is.null(pattern)) {
[17:41:07.002]                           computeRestarts <- base::computeRestarts
[17:41:07.002]                           grepl <- base::grepl
[17:41:07.002]                           restarts <- computeRestarts(cond)
[17:41:07.002]                           for (restart in restarts) {
[17:41:07.002]                             name <- restart$name
[17:41:07.002]                             if (is.null(name)) 
[17:41:07.002]                               next
[17:41:07.002]                             if (!grepl(pattern, name)) 
[17:41:07.002]                               next
[17:41:07.002]                             invokeRestart(restart)
[17:41:07.002]                             muffled <- TRUE
[17:41:07.002]                             break
[17:41:07.002]                           }
[17:41:07.002]                         }
[17:41:07.002]                       }
[17:41:07.002]                       invisible(muffled)
[17:41:07.002]                     }
[17:41:07.002]                     muffleCondition(cond, pattern = "^muffle")
[17:41:07.002]                   }
[17:41:07.002]                 }
[17:41:07.002]                 else {
[17:41:07.002]                   if (TRUE) {
[17:41:07.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:07.002]                     {
[17:41:07.002]                       inherits <- base::inherits
[17:41:07.002]                       invokeRestart <- base::invokeRestart
[17:41:07.002]                       is.null <- base::is.null
[17:41:07.002]                       muffled <- FALSE
[17:41:07.002]                       if (inherits(cond, "message")) {
[17:41:07.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:07.002]                         if (muffled) 
[17:41:07.002]                           invokeRestart("muffleMessage")
[17:41:07.002]                       }
[17:41:07.002]                       else if (inherits(cond, "warning")) {
[17:41:07.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:07.002]                         if (muffled) 
[17:41:07.002]                           invokeRestart("muffleWarning")
[17:41:07.002]                       }
[17:41:07.002]                       else if (inherits(cond, "condition")) {
[17:41:07.002]                         if (!is.null(pattern)) {
[17:41:07.002]                           computeRestarts <- base::computeRestarts
[17:41:07.002]                           grepl <- base::grepl
[17:41:07.002]                           restarts <- computeRestarts(cond)
[17:41:07.002]                           for (restart in restarts) {
[17:41:07.002]                             name <- restart$name
[17:41:07.002]                             if (is.null(name)) 
[17:41:07.002]                               next
[17:41:07.002]                             if (!grepl(pattern, name)) 
[17:41:07.002]                               next
[17:41:07.002]                             invokeRestart(restart)
[17:41:07.002]                             muffled <- TRUE
[17:41:07.002]                             break
[17:41:07.002]                           }
[17:41:07.002]                         }
[17:41:07.002]                       }
[17:41:07.002]                       invisible(muffled)
[17:41:07.002]                     }
[17:41:07.002]                     muffleCondition(cond, pattern = "^muffle")
[17:41:07.002]                   }
[17:41:07.002]                 }
[17:41:07.002]             }
[17:41:07.002]         }))
[17:41:07.002]     }, error = function(ex) {
[17:41:07.002]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:07.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:07.002]                 ...future.rng), started = ...future.startTime, 
[17:41:07.002]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:07.002]             version = "1.8"), class = "FutureResult")
[17:41:07.002]     }, finally = {
[17:41:07.002]         if (!identical(...future.workdir, getwd())) 
[17:41:07.002]             setwd(...future.workdir)
[17:41:07.002]         {
[17:41:07.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:07.002]                 ...future.oldOptions$nwarnings <- NULL
[17:41:07.002]             }
[17:41:07.002]             base::options(...future.oldOptions)
[17:41:07.002]             if (.Platform$OS.type == "windows") {
[17:41:07.002]                 old_names <- names(...future.oldEnvVars)
[17:41:07.002]                 envs <- base::Sys.getenv()
[17:41:07.002]                 names <- names(envs)
[17:41:07.002]                 common <- intersect(names, old_names)
[17:41:07.002]                 added <- setdiff(names, old_names)
[17:41:07.002]                 removed <- setdiff(old_names, names)
[17:41:07.002]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:07.002]                   envs[common]]
[17:41:07.002]                 NAMES <- toupper(changed)
[17:41:07.002]                 args <- list()
[17:41:07.002]                 for (kk in seq_along(NAMES)) {
[17:41:07.002]                   name <- changed[[kk]]
[17:41:07.002]                   NAME <- NAMES[[kk]]
[17:41:07.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:07.002]                     next
[17:41:07.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:07.002]                 }
[17:41:07.002]                 NAMES <- toupper(added)
[17:41:07.002]                 for (kk in seq_along(NAMES)) {
[17:41:07.002]                   name <- added[[kk]]
[17:41:07.002]                   NAME <- NAMES[[kk]]
[17:41:07.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:07.002]                     next
[17:41:07.002]                   args[[name]] <- ""
[17:41:07.002]                 }
[17:41:07.002]                 NAMES <- toupper(removed)
[17:41:07.002]                 for (kk in seq_along(NAMES)) {
[17:41:07.002]                   name <- removed[[kk]]
[17:41:07.002]                   NAME <- NAMES[[kk]]
[17:41:07.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:07.002]                     next
[17:41:07.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:07.002]                 }
[17:41:07.002]                 if (length(args) > 0) 
[17:41:07.002]                   base::do.call(base::Sys.setenv, args = args)
[17:41:07.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:07.002]             }
[17:41:07.002]             else {
[17:41:07.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:07.002]             }
[17:41:07.002]             {
[17:41:07.002]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:07.002]                   0L) {
[17:41:07.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:07.002]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:07.002]                   base::options(opts)
[17:41:07.002]                 }
[17:41:07.002]                 {
[17:41:07.002]                   {
[17:41:07.002]                     NULL
[17:41:07.002]                     RNGkind("Mersenne-Twister")
[17:41:07.002]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:07.002]                       inherits = FALSE)
[17:41:07.002]                   }
[17:41:07.002]                   options(future.plan = NULL)
[17:41:07.002]                   if (is.na(NA_character_)) 
[17:41:07.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:07.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:07.002]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:07.002]                   {
[17:41:07.002]                     future <- SequentialFuture(..., envir = envir)
[17:41:07.002]                     if (!future$lazy) 
[17:41:07.002]                       future <- run(future)
[17:41:07.002]                     invisible(future)
[17:41:07.002]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:07.002]                 }
[17:41:07.002]             }
[17:41:07.002]         }
[17:41:07.002]     })
[17:41:07.002]     if (FALSE) {
[17:41:07.002]         base::sink(type = "output", split = FALSE)
[17:41:07.002]         if (NA) {
[17:41:07.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:07.002]         }
[17:41:07.002]         else {
[17:41:07.002]             ...future.result["stdout"] <- base::list(NULL)
[17:41:07.002]         }
[17:41:07.002]         base::close(...future.stdout)
[17:41:07.002]         ...future.stdout <- NULL
[17:41:07.002]     }
[17:41:07.002]     ...future.result$conditions <- ...future.conditions
[17:41:07.002]     ...future.result$finished <- base::Sys.time()
[17:41:07.002]     ...future.result
[17:41:07.002] }
[17:41:07.004] assign_globals() ...
[17:41:07.004] List of 5
[17:41:07.004]  $ ...future.FUN            :function (x)  
[17:41:07.004]  $ future.call.arguments    : list()
[17:41:07.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:07.004]  $ ...future.elements_ii    :List of 2
[17:41:07.004]   ..$ : int 1
[17:41:07.004]   ..$ : int 0
[17:41:07.004]  $ ...future.seeds_ii       : NULL
[17:41:07.004]  $ ...future.globals.maxSize: NULL
[17:41:07.004]  - attr(*, "resolved")= logi FALSE
[17:41:07.004]  - attr(*, "total_size")= num 4720
[17:41:07.004]  - attr(*, "where")=List of 5
[17:41:07.004]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:07.004]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:07.004]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:07.004]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:07.004]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:07.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:07.004]  - attr(*, "already-done")= logi TRUE
[17:41:07.009] - reassign environment for ‘...future.FUN’
[17:41:07.009] - copied ‘...future.FUN’ to environment
[17:41:07.009] - copied ‘future.call.arguments’ to environment
[17:41:07.009] - copied ‘...future.elements_ii’ to environment
[17:41:07.009] - copied ‘...future.seeds_ii’ to environment
[17:41:07.009] - copied ‘...future.globals.maxSize’ to environment
[17:41:07.009] assign_globals() ... done
[17:41:07.009] plan(): Setting new future strategy stack:
[17:41:07.009] List of future strategies:
[17:41:07.009] 1. sequential:
[17:41:07.009]    - args: function (..., envir = parent.frame())
[17:41:07.009]    - tweaked: FALSE
[17:41:07.009]    - call: NULL
[17:41:07.010] plan(): nbrOfWorkers() = 1
[17:41:07.511] plan(): Setting new future strategy stack:
[17:41:07.512] List of future strategies:
[17:41:07.512] 1. sequential:
[17:41:07.512]    - args: function (..., envir = parent.frame())
[17:41:07.512]    - tweaked: FALSE
[17:41:07.512]    - call: plan(strategy)
[17:41:07.512] plan(): nbrOfWorkers() = 1
[17:41:07.512] SequentialFuture started (and completed)
[17:41:07.512] - Launch lazy future ... done
[17:41:07.513] run() for ‘SequentialFuture’ ... done
[17:41:07.513] Created future:
[17:41:07.513] SequentialFuture:
[17:41:07.513] Label: ‘future_lapply-1’
[17:41:07.513] Expression:
[17:41:07.513] {
[17:41:07.513]     do.call(function(...) {
[17:41:07.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:07.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:07.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:07.513]             on.exit(options(oopts), add = TRUE)
[17:41:07.513]         }
[17:41:07.513]         {
[17:41:07.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:07.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:07.513]                 ...future.FUN(...future.X_jj, ...)
[17:41:07.513]             })
[17:41:07.513]         }
[17:41:07.513]     }, args = future.call.arguments)
[17:41:07.513] }
[17:41:07.513] Lazy evaluation: FALSE
[17:41:07.513] Asynchronous evaluation: FALSE
[17:41:07.513] Local evaluation: TRUE
[17:41:07.513] Environment: R_GlobalEnv
[17:41:07.513] Capture standard output: NA
[17:41:07.513] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:07.513] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:07.513] Packages: <none>
[17:41:07.513] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:07.513] Resolved: TRUE
[17:41:07.513] Value: 112 bytes of class ‘list’
[17:41:07.513] Early signaling: FALSE
[17:41:07.513] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:07.513] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:07.514] Chunk #1 of 1 ... DONE
[17:41:07.514] Launching 1 futures (chunks) ... DONE
[17:41:07.514] Resolving 1 futures (chunks) ...
[17:41:07.514] resolve() on list ...
[17:41:07.514]  recursive: 0
[17:41:07.514]  length: 1
[17:41:07.514] 
[17:41:07.515] resolved() for ‘SequentialFuture’ ...
[17:41:07.515] - state: ‘finished’
[17:41:07.515] - run: TRUE
[17:41:07.515] - result: ‘FutureResult’
[17:41:07.515] resolved() for ‘SequentialFuture’ ... done
[17:41:07.515] Future #1
[17:41:07.515] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:07.515] - nx: 1
[17:41:07.515] - relay: TRUE
[17:41:07.515] - stdout: TRUE
[17:41:07.516] - signal: TRUE
[17:41:07.516] - resignal: FALSE
[17:41:07.516] - force: TRUE
[17:41:07.516] - relayed: [n=1] FALSE
[17:41:07.516] - queued futures: [n=1] FALSE
[17:41:07.516]  - until=1
[17:41:07.516]  - relaying element #1
[17:41:07.516] - relayed: [n=1] TRUE
[17:41:07.516] - queued futures: [n=1] TRUE
[17:41:07.516] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:07.517]  length: 0 (resolved future 1)
[17:41:07.518] Relaying remaining futures
[17:41:07.518] signalConditionsASAP(NULL, pos=0) ...
[17:41:07.518] - nx: 1
[17:41:07.518] - relay: TRUE
[17:41:07.519] - stdout: TRUE
[17:41:07.519] - signal: TRUE
[17:41:07.519] - resignal: FALSE
[17:41:07.519] - force: TRUE
[17:41:07.519] - relayed: [n=1] TRUE
[17:41:07.519] - queued futures: [n=1] TRUE
 - flush all
[17:41:07.519] - relayed: [n=1] TRUE
[17:41:07.519] - queued futures: [n=1] TRUE
[17:41:07.519] signalConditionsASAP(NULL, pos=0) ... done
[17:41:07.519] resolve() on list ... DONE
[17:41:07.520]  - Number of value chunks collected: 1
[17:41:07.520] Resolving 1 futures (chunks) ... DONE
[17:41:07.520] Reducing values from 1 chunks ...
[17:41:07.520]  - Number of values collected after concatenation: 2
[17:41:07.520]  - Number of values expected: 2
[17:41:07.520] Reducing values from 1 chunks ... DONE
[17:41:07.520] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:41:07.520] future_mapply() ...
[17:41:07.521] Number of chunks: 1
[17:41:07.521] getGlobalsAndPackagesXApply() ...
[17:41:07.521]  - future.globals: TRUE
[17:41:07.521] getGlobalsAndPackages() ...
[17:41:07.521] Searching for globals...
[17:41:07.523] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:07.523] Searching for globals ... DONE
[17:41:07.523] Resolving globals: FALSE
[17:41:07.523] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:07.524] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:07.524] - globals: [1] ‘FUN’
[17:41:07.524] 
[17:41:07.524] getGlobalsAndPackages() ... DONE
[17:41:07.524]  - globals found/used: [n=1] ‘FUN’
[17:41:07.524]  - needed namespaces: [n=0] 
[17:41:07.524] Finding globals ... DONE
[17:41:07.524] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:07.524] List of 2
[17:41:07.524]  $ ...future.FUN:function (x, y)  
[17:41:07.524]  $ MoreArgs     : NULL
[17:41:07.524]  - attr(*, "where")=List of 2
[17:41:07.524]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:07.524]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:07.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:07.524]  - attr(*, "resolved")= logi FALSE
[17:41:07.524]  - attr(*, "total_size")= num NA
[17:41:07.527] Packages to be attached in all futures: [n=0] 
[17:41:07.527] getGlobalsAndPackagesXApply() ... DONE
[17:41:07.527] Number of futures (= number of chunks): 1
[17:41:07.527] Launching 1 futures (chunks) ...
[17:41:07.527] Chunk #1 of 1 ...
[17:41:07.528]  - Finding globals in '...' for chunk #1 ...
[17:41:07.528] getGlobalsAndPackages() ...
[17:41:07.528] Searching for globals...
[17:41:07.528] 
[17:41:07.528] Searching for globals ... DONE
[17:41:07.528] - globals: [0] <none>
[17:41:07.528] getGlobalsAndPackages() ... DONE
[17:41:07.528]    + additional globals found: [n=0] 
[17:41:07.529]    + additional namespaces needed: [n=0] 
[17:41:07.529]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:07.529]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:07.529]  - seeds: <none>
[17:41:07.529] getGlobalsAndPackages() ...
[17:41:07.529] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:07.529] Resolving globals: FALSE
[17:41:07.530] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:07.530] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:07.530] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:07.530] 
[17:41:07.530] getGlobalsAndPackages() ... DONE
[17:41:07.531] run() for ‘Future’ ...
[17:41:07.531] - state: ‘created’
[17:41:07.531] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:07.531] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:07.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:07.531]   - Field: ‘label’
[17:41:07.532]   - Field: ‘local’
[17:41:07.532]   - Field: ‘owner’
[17:41:07.532]   - Field: ‘envir’
[17:41:07.532]   - Field: ‘packages’
[17:41:07.532]   - Field: ‘gc’
[17:41:07.532]   - Field: ‘conditions’
[17:41:07.532]   - Field: ‘expr’
[17:41:07.532]   - Field: ‘uuid’
[17:41:07.532]   - Field: ‘seed’
[17:41:07.532]   - Field: ‘version’
[17:41:07.532]   - Field: ‘result’
[17:41:07.533]   - Field: ‘asynchronous’
[17:41:07.533]   - Field: ‘calls’
[17:41:07.533]   - Field: ‘globals’
[17:41:07.533]   - Field: ‘stdout’
[17:41:07.533]   - Field: ‘earlySignal’
[17:41:07.533]   - Field: ‘lazy’
[17:41:07.533]   - Field: ‘state’
[17:41:07.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:07.533] - Launch lazy future ...
[17:41:07.533] Packages needed by the future expression (n = 0): <none>
[17:41:07.534] Packages needed by future strategies (n = 0): <none>
[17:41:07.534] {
[17:41:07.534]     {
[17:41:07.534]         {
[17:41:07.534]             ...future.startTime <- base::Sys.time()
[17:41:07.534]             {
[17:41:07.534]                 {
[17:41:07.534]                   {
[17:41:07.534]                     base::local({
[17:41:07.534]                       has_future <- base::requireNamespace("future", 
[17:41:07.534]                         quietly = TRUE)
[17:41:07.534]                       if (has_future) {
[17:41:07.534]                         ns <- base::getNamespace("future")
[17:41:07.534]                         version <- ns[[".package"]][["version"]]
[17:41:07.534]                         if (is.null(version)) 
[17:41:07.534]                           version <- utils::packageVersion("future")
[17:41:07.534]                       }
[17:41:07.534]                       else {
[17:41:07.534]                         version <- NULL
[17:41:07.534]                       }
[17:41:07.534]                       if (!has_future || version < "1.8.0") {
[17:41:07.534]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:07.534]                           "", base::R.version$version.string), 
[17:41:07.534]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:07.534]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:07.534]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:07.534]                             "release", "version")], collapse = " "), 
[17:41:07.534]                           hostname = base::Sys.info()[["nodename"]])
[17:41:07.534]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:07.534]                           info)
[17:41:07.534]                         info <- base::paste(info, collapse = "; ")
[17:41:07.534]                         if (!has_future) {
[17:41:07.534]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:07.534]                             info)
[17:41:07.534]                         }
[17:41:07.534]                         else {
[17:41:07.534]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:07.534]                             info, version)
[17:41:07.534]                         }
[17:41:07.534]                         base::stop(msg)
[17:41:07.534]                       }
[17:41:07.534]                     })
[17:41:07.534]                   }
[17:41:07.534]                   options(future.plan = NULL)
[17:41:07.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:07.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:07.534]                 }
[17:41:07.534]                 ...future.workdir <- getwd()
[17:41:07.534]             }
[17:41:07.534]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:07.534]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:07.534]         }
[17:41:07.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:07.534]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:07.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:07.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:07.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:07.534]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:07.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:07.534]             base::names(...future.oldOptions))
[17:41:07.534]     }
[17:41:07.534]     if (FALSE) {
[17:41:07.534]     }
[17:41:07.534]     else {
[17:41:07.534]         if (FALSE) {
[17:41:07.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:07.534]                 open = "w")
[17:41:07.534]         }
[17:41:07.534]         else {
[17:41:07.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:07.534]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:07.534]         }
[17:41:07.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:07.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:07.534]             base::sink(type = "output", split = FALSE)
[17:41:07.534]             base::close(...future.stdout)
[17:41:07.534]         }, add = TRUE)
[17:41:07.534]     }
[17:41:07.534]     ...future.frame <- base::sys.nframe()
[17:41:07.534]     ...future.conditions <- base::list()
[17:41:07.534]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:07.534]     if (FALSE) {
[17:41:07.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:07.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:07.534]     }
[17:41:07.534]     ...future.result <- base::tryCatch({
[17:41:07.534]         base::withCallingHandlers({
[17:41:07.534]             ...future.value <- base::withVisible(base::local({
[17:41:07.534]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:07.534]                 if (!identical(...future.globals.maxSize.org, 
[17:41:07.534]                   ...future.globals.maxSize)) {
[17:41:07.534]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:07.534]                   on.exit(options(oopts), add = TRUE)
[17:41:07.534]                 }
[17:41:07.534]                 {
[17:41:07.534]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:07.534]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:07.534]                     USE.NAMES = FALSE)
[17:41:07.534]                   do.call(mapply, args = args)
[17:41:07.534]                 }
[17:41:07.534]             }))
[17:41:07.534]             future::FutureResult(value = ...future.value$value, 
[17:41:07.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:07.534]                   ...future.rng), globalenv = if (FALSE) 
[17:41:07.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:07.534]                     ...future.globalenv.names))
[17:41:07.534]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:07.534]         }, condition = base::local({
[17:41:07.534]             c <- base::c
[17:41:07.534]             inherits <- base::inherits
[17:41:07.534]             invokeRestart <- base::invokeRestart
[17:41:07.534]             length <- base::length
[17:41:07.534]             list <- base::list
[17:41:07.534]             seq.int <- base::seq.int
[17:41:07.534]             signalCondition <- base::signalCondition
[17:41:07.534]             sys.calls <- base::sys.calls
[17:41:07.534]             `[[` <- base::`[[`
[17:41:07.534]             `+` <- base::`+`
[17:41:07.534]             `<<-` <- base::`<<-`
[17:41:07.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:07.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:07.534]                   3L)]
[17:41:07.534]             }
[17:41:07.534]             function(cond) {
[17:41:07.534]                 is_error <- inherits(cond, "error")
[17:41:07.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:07.534]                   NULL)
[17:41:07.534]                 if (is_error) {
[17:41:07.534]                   sessionInformation <- function() {
[17:41:07.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:07.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:07.534]                       search = base::search(), system = base::Sys.info())
[17:41:07.534]                   }
[17:41:07.534]                   ...future.conditions[[length(...future.conditions) + 
[17:41:07.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:07.534]                     cond$call), session = sessionInformation(), 
[17:41:07.534]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:07.534]                   signalCondition(cond)
[17:41:07.534]                 }
[17:41:07.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:07.534]                 "immediateCondition"))) {
[17:41:07.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:07.534]                   ...future.conditions[[length(...future.conditions) + 
[17:41:07.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:07.534]                   if (TRUE && !signal) {
[17:41:07.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:07.534]                     {
[17:41:07.534]                       inherits <- base::inherits
[17:41:07.534]                       invokeRestart <- base::invokeRestart
[17:41:07.534]                       is.null <- base::is.null
[17:41:07.534]                       muffled <- FALSE
[17:41:07.534]                       if (inherits(cond, "message")) {
[17:41:07.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:07.534]                         if (muffled) 
[17:41:07.534]                           invokeRestart("muffleMessage")
[17:41:07.534]                       }
[17:41:07.534]                       else if (inherits(cond, "warning")) {
[17:41:07.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:07.534]                         if (muffled) 
[17:41:07.534]                           invokeRestart("muffleWarning")
[17:41:07.534]                       }
[17:41:07.534]                       else if (inherits(cond, "condition")) {
[17:41:07.534]                         if (!is.null(pattern)) {
[17:41:07.534]                           computeRestarts <- base::computeRestarts
[17:41:07.534]                           grepl <- base::grepl
[17:41:07.534]                           restarts <- computeRestarts(cond)
[17:41:07.534]                           for (restart in restarts) {
[17:41:07.534]                             name <- restart$name
[17:41:07.534]                             if (is.null(name)) 
[17:41:07.534]                               next
[17:41:07.534]                             if (!grepl(pattern, name)) 
[17:41:07.534]                               next
[17:41:07.534]                             invokeRestart(restart)
[17:41:07.534]                             muffled <- TRUE
[17:41:07.534]                             break
[17:41:07.534]                           }
[17:41:07.534]                         }
[17:41:07.534]                       }
[17:41:07.534]                       invisible(muffled)
[17:41:07.534]                     }
[17:41:07.534]                     muffleCondition(cond, pattern = "^muffle")
[17:41:07.534]                   }
[17:41:07.534]                 }
[17:41:07.534]                 else {
[17:41:07.534]                   if (TRUE) {
[17:41:07.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:07.534]                     {
[17:41:07.534]                       inherits <- base::inherits
[17:41:07.534]                       invokeRestart <- base::invokeRestart
[17:41:07.534]                       is.null <- base::is.null
[17:41:07.534]                       muffled <- FALSE
[17:41:07.534]                       if (inherits(cond, "message")) {
[17:41:07.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:07.534]                         if (muffled) 
[17:41:07.534]                           invokeRestart("muffleMessage")
[17:41:07.534]                       }
[17:41:07.534]                       else if (inherits(cond, "warning")) {
[17:41:07.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:07.534]                         if (muffled) 
[17:41:07.534]                           invokeRestart("muffleWarning")
[17:41:07.534]                       }
[17:41:07.534]                       else if (inherits(cond, "condition")) {
[17:41:07.534]                         if (!is.null(pattern)) {
[17:41:07.534]                           computeRestarts <- base::computeRestarts
[17:41:07.534]                           grepl <- base::grepl
[17:41:07.534]                           restarts <- computeRestarts(cond)
[17:41:07.534]                           for (restart in restarts) {
[17:41:07.534]                             name <- restart$name
[17:41:07.534]                             if (is.null(name)) 
[17:41:07.534]                               next
[17:41:07.534]                             if (!grepl(pattern, name)) 
[17:41:07.534]                               next
[17:41:07.534]                             invokeRestart(restart)
[17:41:07.534]                             muffled <- TRUE
[17:41:07.534]                             break
[17:41:07.534]                           }
[17:41:07.534]                         }
[17:41:07.534]                       }
[17:41:07.534]                       invisible(muffled)
[17:41:07.534]                     }
[17:41:07.534]                     muffleCondition(cond, pattern = "^muffle")
[17:41:07.534]                   }
[17:41:07.534]                 }
[17:41:07.534]             }
[17:41:07.534]         }))
[17:41:07.534]     }, error = function(ex) {
[17:41:07.534]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:07.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:07.534]                 ...future.rng), started = ...future.startTime, 
[17:41:07.534]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:07.534]             version = "1.8"), class = "FutureResult")
[17:41:07.534]     }, finally = {
[17:41:07.534]         if (!identical(...future.workdir, getwd())) 
[17:41:07.534]             setwd(...future.workdir)
[17:41:07.534]         {
[17:41:07.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:07.534]                 ...future.oldOptions$nwarnings <- NULL
[17:41:07.534]             }
[17:41:07.534]             base::options(...future.oldOptions)
[17:41:07.534]             if (.Platform$OS.type == "windows") {
[17:41:07.534]                 old_names <- names(...future.oldEnvVars)
[17:41:07.534]                 envs <- base::Sys.getenv()
[17:41:07.534]                 names <- names(envs)
[17:41:07.534]                 common <- intersect(names, old_names)
[17:41:07.534]                 added <- setdiff(names, old_names)
[17:41:07.534]                 removed <- setdiff(old_names, names)
[17:41:07.534]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:07.534]                   envs[common]]
[17:41:07.534]                 NAMES <- toupper(changed)
[17:41:07.534]                 args <- list()
[17:41:07.534]                 for (kk in seq_along(NAMES)) {
[17:41:07.534]                   name <- changed[[kk]]
[17:41:07.534]                   NAME <- NAMES[[kk]]
[17:41:07.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:07.534]                     next
[17:41:07.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:07.534]                 }
[17:41:07.534]                 NAMES <- toupper(added)
[17:41:07.534]                 for (kk in seq_along(NAMES)) {
[17:41:07.534]                   name <- added[[kk]]
[17:41:07.534]                   NAME <- NAMES[[kk]]
[17:41:07.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:07.534]                     next
[17:41:07.534]                   args[[name]] <- ""
[17:41:07.534]                 }
[17:41:07.534]                 NAMES <- toupper(removed)
[17:41:07.534]                 for (kk in seq_along(NAMES)) {
[17:41:07.534]                   name <- removed[[kk]]
[17:41:07.534]                   NAME <- NAMES[[kk]]
[17:41:07.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:07.534]                     next
[17:41:07.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:07.534]                 }
[17:41:07.534]                 if (length(args) > 0) 
[17:41:07.534]                   base::do.call(base::Sys.setenv, args = args)
[17:41:07.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:07.534]             }
[17:41:07.534]             else {
[17:41:07.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:07.534]             }
[17:41:07.534]             {
[17:41:07.534]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:07.534]                   0L) {
[17:41:07.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:07.534]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:07.534]                   base::options(opts)
[17:41:07.534]                 }
[17:41:07.534]                 {
[17:41:07.534]                   {
[17:41:07.534]                     NULL
[17:41:07.534]                     RNGkind("Mersenne-Twister")
[17:41:07.534]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:07.534]                       inherits = FALSE)
[17:41:07.534]                   }
[17:41:07.534]                   options(future.plan = NULL)
[17:41:07.534]                   if (is.na(NA_character_)) 
[17:41:07.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:07.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:07.534]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:07.534]                   {
[17:41:07.534]                     future <- SequentialFuture(..., envir = envir)
[17:41:07.534]                     if (!future$lazy) 
[17:41:07.534]                       future <- run(future)
[17:41:07.534]                     invisible(future)
[17:41:07.534]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:07.534]                 }
[17:41:07.534]             }
[17:41:07.534]         }
[17:41:07.534]     })
[17:41:07.534]     if (TRUE) {
[17:41:07.534]         base::sink(type = "output", split = FALSE)
[17:41:07.534]         if (FALSE) {
[17:41:07.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:07.534]         }
[17:41:07.534]         else {
[17:41:07.534]             ...future.result["stdout"] <- base::list(NULL)
[17:41:07.534]         }
[17:41:07.534]         base::close(...future.stdout)
[17:41:07.534]         ...future.stdout <- NULL
[17:41:07.534]     }
[17:41:07.534]     ...future.result$conditions <- ...future.conditions
[17:41:07.534]     ...future.result$finished <- base::Sys.time()
[17:41:07.534]     ...future.result
[17:41:07.534] }
[17:41:07.536] assign_globals() ...
[17:41:07.536] List of 5
[17:41:07.536]  $ ...future.FUN            :function (x, y)  
[17:41:07.536]  $ MoreArgs                 : NULL
[17:41:07.536]  $ ...future.elements_ii    :List of 2
[17:41:07.536]   ..$ :List of 2
[17:41:07.536]   .. ..$ : int 1
[17:41:07.536]   .. ..$ : int 0
[17:41:07.536]   ..$ :List of 2
[17:41:07.536]   .. ..$ : int 0
[17:41:07.536]   .. ..$ : int 1
[17:41:07.536]  $ ...future.seeds_ii       : NULL
[17:41:07.536]  $ ...future.globals.maxSize: NULL
[17:41:07.536]  - attr(*, "resolved")= logi FALSE
[17:41:07.536]  - attr(*, "total_size")= num 6480
[17:41:07.536]  - attr(*, "where")=List of 5
[17:41:07.536]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:07.536]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:07.536]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:07.536]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:07.536]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:07.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:07.536]  - attr(*, "already-done")= logi TRUE
[17:41:07.541] - reassign environment for ‘...future.FUN’
[17:41:07.541] - copied ‘...future.FUN’ to environment
[17:41:07.541] - copied ‘MoreArgs’ to environment
[17:41:07.541] - copied ‘...future.elements_ii’ to environment
[17:41:07.543] - copied ‘...future.seeds_ii’ to environment
[17:41:07.543] - copied ‘...future.globals.maxSize’ to environment
[17:41:07.543] assign_globals() ... done
[17:41:07.543] plan(): Setting new future strategy stack:
[17:41:07.543] List of future strategies:
[17:41:07.543] 1. sequential:
[17:41:07.543]    - args: function (..., envir = parent.frame())
[17:41:07.543]    - tweaked: FALSE
[17:41:07.543]    - call: NULL
[17:41:07.544] plan(): nbrOfWorkers() = 1
[17:41:08.045] plan(): Setting new future strategy stack:
[17:41:08.045] List of future strategies:
[17:41:08.045] 1. sequential:
[17:41:08.045]    - args: function (..., envir = parent.frame())
[17:41:08.045]    - tweaked: FALSE
[17:41:08.045]    - call: plan(strategy)
[17:41:08.046] plan(): nbrOfWorkers() = 1
[17:41:08.046] SequentialFuture started (and completed)
[17:41:08.046] - Launch lazy future ... done
[17:41:08.046] run() for ‘SequentialFuture’ ... done
[17:41:08.047] Created future:
[17:41:08.047] SequentialFuture:
[17:41:08.047] Label: ‘future_mapply-1’
[17:41:08.047] Expression:
[17:41:08.047] {
[17:41:08.047]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:08.047]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:08.047]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:08.047]         on.exit(options(oopts), add = TRUE)
[17:41:08.047]     }
[17:41:08.047]     {
[17:41:08.047]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:08.047]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:08.047]         do.call(mapply, args = args)
[17:41:08.047]     }
[17:41:08.047] }
[17:41:08.047] Lazy evaluation: FALSE
[17:41:08.047] Asynchronous evaluation: FALSE
[17:41:08.047] Local evaluation: TRUE
[17:41:08.047] Environment: R_GlobalEnv
[17:41:08.047] Capture standard output: FALSE
[17:41:08.047] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:08.047] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:08.047] Packages: <none>
[17:41:08.047] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:08.047] Resolved: TRUE
[17:41:08.047] Value: 224 bytes of class ‘list’
[17:41:08.047] Early signaling: FALSE
[17:41:08.047] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:08.047] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:08.048] Chunk #1 of 1 ... DONE
[17:41:08.048] Launching 1 futures (chunks) ... DONE
[17:41:08.048] Resolving 1 futures (chunks) ...
[17:41:08.048] resolve() on list ...
[17:41:08.048]  recursive: 0
[17:41:08.048]  length: 1
[17:41:08.048] 
[17:41:08.048] resolved() for ‘SequentialFuture’ ...
[17:41:08.049] - state: ‘finished’
[17:41:08.049] - run: TRUE
[17:41:08.049] - result: ‘FutureResult’
[17:41:08.049] resolved() for ‘SequentialFuture’ ... done
[17:41:08.049] Future #1
[17:41:08.049] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:08.049] - nx: 1
[17:41:08.049] - relay: TRUE
[17:41:08.049] - stdout: TRUE
[17:41:08.049] - signal: TRUE
[17:41:08.049] - resignal: FALSE
[17:41:08.050] - force: TRUE
[17:41:08.050] - relayed: [n=1] FALSE
[17:41:08.050] - queued futures: [n=1] FALSE
[17:41:08.050]  - until=1
[17:41:08.050]  - relaying element #1
[17:41:08.050] - relayed: [n=1] TRUE
[17:41:08.050] - queued futures: [n=1] TRUE
[17:41:08.050] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:08.050]  length: 0 (resolved future 1)
[17:41:08.050] Relaying remaining futures
[17:41:08.051] signalConditionsASAP(NULL, pos=0) ...
[17:41:08.051] - nx: 1
[17:41:08.051] - relay: TRUE
[17:41:08.051] - stdout: TRUE
[17:41:08.051] - signal: TRUE
[17:41:08.051] - resignal: FALSE
[17:41:08.051] - force: TRUE
[17:41:08.051] - relayed: [n=1] TRUE
[17:41:08.051] - queued futures: [n=1] TRUE
 - flush all
[17:41:08.051] - relayed: [n=1] TRUE
[17:41:08.051] - queued futures: [n=1] TRUE
[17:41:08.052] signalConditionsASAP(NULL, pos=0) ... done
[17:41:08.052] resolve() on list ... DONE
[17:41:08.052]  - Number of value chunks collected: 1
[17:41:08.052] Resolving 1 futures (chunks) ... DONE
[17:41:08.052] Reducing values from 1 chunks ...
[17:41:08.052]  - Number of values collected after concatenation: 2
[17:41:08.052]  - Number of values expected: 2
[17:41:08.052] Reducing values from 1 chunks ... DONE
[17:41:08.052] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:41:08.053] future_mapply() ...
[17:41:08.053] Number of chunks: 1
[17:41:08.053] getGlobalsAndPackagesXApply() ...
[17:41:08.053]  - future.globals: TRUE
[17:41:08.053] getGlobalsAndPackages() ...
[17:41:08.053] Searching for globals...
[17:41:08.055] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:08.055] Searching for globals ... DONE
[17:41:08.055] Resolving globals: FALSE
[17:41:08.055] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:08.056] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:08.056] - globals: [1] ‘FUN’
[17:41:08.056] 
[17:41:08.056] getGlobalsAndPackages() ... DONE
[17:41:08.056]  - globals found/used: [n=1] ‘FUN’
[17:41:08.056]  - needed namespaces: [n=0] 
[17:41:08.056] Finding globals ... DONE
[17:41:08.057] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:08.057] List of 2
[17:41:08.057]  $ ...future.FUN:function (x, y)  
[17:41:08.057]  $ MoreArgs     : NULL
[17:41:08.057]  - attr(*, "where")=List of 2
[17:41:08.057]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:08.057]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:08.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:08.057]  - attr(*, "resolved")= logi FALSE
[17:41:08.057]  - attr(*, "total_size")= num NA
[17:41:08.059] Packages to be attached in all futures: [n=0] 
[17:41:08.059] getGlobalsAndPackagesXApply() ... DONE
[17:41:08.059] Number of futures (= number of chunks): 1
[17:41:08.060] Launching 1 futures (chunks) ...
[17:41:08.060] Chunk #1 of 1 ...
[17:41:08.060]  - Finding globals in '...' for chunk #1 ...
[17:41:08.060] getGlobalsAndPackages() ...
[17:41:08.060] Searching for globals...
[17:41:08.060] 
[17:41:08.060] Searching for globals ... DONE
[17:41:08.060] - globals: [0] <none>
[17:41:08.061] getGlobalsAndPackages() ... DONE
[17:41:08.061]    + additional globals found: [n=0] 
[17:41:08.061]    + additional namespaces needed: [n=0] 
[17:41:08.061]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:08.061]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:08.061]  - seeds: <none>
[17:41:08.061] getGlobalsAndPackages() ...
[17:41:08.061] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:08.061] Resolving globals: FALSE
[17:41:08.062] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:08.062] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:08.062] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:08.062] 
[17:41:08.063] getGlobalsAndPackages() ... DONE
[17:41:08.063] run() for ‘Future’ ...
[17:41:08.063] - state: ‘created’
[17:41:08.063] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:08.063] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:08.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:08.064]   - Field: ‘label’
[17:41:08.064]   - Field: ‘local’
[17:41:08.064]   - Field: ‘owner’
[17:41:08.064]   - Field: ‘envir’
[17:41:08.064]   - Field: ‘packages’
[17:41:08.064]   - Field: ‘gc’
[17:41:08.064]   - Field: ‘conditions’
[17:41:08.064]   - Field: ‘expr’
[17:41:08.064]   - Field: ‘uuid’
[17:41:08.064]   - Field: ‘seed’
[17:41:08.064]   - Field: ‘version’
[17:41:08.065]   - Field: ‘result’
[17:41:08.065]   - Field: ‘asynchronous’
[17:41:08.065]   - Field: ‘calls’
[17:41:08.065]   - Field: ‘globals’
[17:41:08.065]   - Field: ‘stdout’
[17:41:08.065]   - Field: ‘earlySignal’
[17:41:08.065]   - Field: ‘lazy’
[17:41:08.065]   - Field: ‘state’
[17:41:08.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:08.065] - Launch lazy future ...
[17:41:08.066] Packages needed by the future expression (n = 0): <none>
[17:41:08.066] Packages needed by future strategies (n = 0): <none>
[17:41:08.066] {
[17:41:08.066]     {
[17:41:08.066]         {
[17:41:08.066]             ...future.startTime <- base::Sys.time()
[17:41:08.066]             {
[17:41:08.066]                 {
[17:41:08.066]                   {
[17:41:08.066]                     base::local({
[17:41:08.066]                       has_future <- base::requireNamespace("future", 
[17:41:08.066]                         quietly = TRUE)
[17:41:08.066]                       if (has_future) {
[17:41:08.066]                         ns <- base::getNamespace("future")
[17:41:08.066]                         version <- ns[[".package"]][["version"]]
[17:41:08.066]                         if (is.null(version)) 
[17:41:08.066]                           version <- utils::packageVersion("future")
[17:41:08.066]                       }
[17:41:08.066]                       else {
[17:41:08.066]                         version <- NULL
[17:41:08.066]                       }
[17:41:08.066]                       if (!has_future || version < "1.8.0") {
[17:41:08.066]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:08.066]                           "", base::R.version$version.string), 
[17:41:08.066]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:08.066]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:08.066]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:08.066]                             "release", "version")], collapse = " "), 
[17:41:08.066]                           hostname = base::Sys.info()[["nodename"]])
[17:41:08.066]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:08.066]                           info)
[17:41:08.066]                         info <- base::paste(info, collapse = "; ")
[17:41:08.066]                         if (!has_future) {
[17:41:08.066]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:08.066]                             info)
[17:41:08.066]                         }
[17:41:08.066]                         else {
[17:41:08.066]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:08.066]                             info, version)
[17:41:08.066]                         }
[17:41:08.066]                         base::stop(msg)
[17:41:08.066]                       }
[17:41:08.066]                     })
[17:41:08.066]                   }
[17:41:08.066]                   options(future.plan = NULL)
[17:41:08.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:08.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:08.066]                 }
[17:41:08.066]                 ...future.workdir <- getwd()
[17:41:08.066]             }
[17:41:08.066]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:08.066]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:08.066]         }
[17:41:08.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:08.066]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:08.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:08.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:08.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:08.066]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:08.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:08.066]             base::names(...future.oldOptions))
[17:41:08.066]     }
[17:41:08.066]     if (FALSE) {
[17:41:08.066]     }
[17:41:08.066]     else {
[17:41:08.066]         if (TRUE) {
[17:41:08.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:08.066]                 open = "w")
[17:41:08.066]         }
[17:41:08.066]         else {
[17:41:08.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:08.066]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:08.066]         }
[17:41:08.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:08.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:08.066]             base::sink(type = "output", split = FALSE)
[17:41:08.066]             base::close(...future.stdout)
[17:41:08.066]         }, add = TRUE)
[17:41:08.066]     }
[17:41:08.066]     ...future.frame <- base::sys.nframe()
[17:41:08.066]     ...future.conditions <- base::list()
[17:41:08.066]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:08.066]     if (FALSE) {
[17:41:08.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:08.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:08.066]     }
[17:41:08.066]     ...future.result <- base::tryCatch({
[17:41:08.066]         base::withCallingHandlers({
[17:41:08.066]             ...future.value <- base::withVisible(base::local({
[17:41:08.066]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:08.066]                 if (!identical(...future.globals.maxSize.org, 
[17:41:08.066]                   ...future.globals.maxSize)) {
[17:41:08.066]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:08.066]                   on.exit(options(oopts), add = TRUE)
[17:41:08.066]                 }
[17:41:08.066]                 {
[17:41:08.066]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:08.066]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:08.066]                     USE.NAMES = FALSE)
[17:41:08.066]                   do.call(mapply, args = args)
[17:41:08.066]                 }
[17:41:08.066]             }))
[17:41:08.066]             future::FutureResult(value = ...future.value$value, 
[17:41:08.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:08.066]                   ...future.rng), globalenv = if (FALSE) 
[17:41:08.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:08.066]                     ...future.globalenv.names))
[17:41:08.066]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:08.066]         }, condition = base::local({
[17:41:08.066]             c <- base::c
[17:41:08.066]             inherits <- base::inherits
[17:41:08.066]             invokeRestart <- base::invokeRestart
[17:41:08.066]             length <- base::length
[17:41:08.066]             list <- base::list
[17:41:08.066]             seq.int <- base::seq.int
[17:41:08.066]             signalCondition <- base::signalCondition
[17:41:08.066]             sys.calls <- base::sys.calls
[17:41:08.066]             `[[` <- base::`[[`
[17:41:08.066]             `+` <- base::`+`
[17:41:08.066]             `<<-` <- base::`<<-`
[17:41:08.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:08.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:08.066]                   3L)]
[17:41:08.066]             }
[17:41:08.066]             function(cond) {
[17:41:08.066]                 is_error <- inherits(cond, "error")
[17:41:08.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:08.066]                   NULL)
[17:41:08.066]                 if (is_error) {
[17:41:08.066]                   sessionInformation <- function() {
[17:41:08.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:08.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:08.066]                       search = base::search(), system = base::Sys.info())
[17:41:08.066]                   }
[17:41:08.066]                   ...future.conditions[[length(...future.conditions) + 
[17:41:08.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:08.066]                     cond$call), session = sessionInformation(), 
[17:41:08.066]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:08.066]                   signalCondition(cond)
[17:41:08.066]                 }
[17:41:08.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:08.066]                 "immediateCondition"))) {
[17:41:08.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:08.066]                   ...future.conditions[[length(...future.conditions) + 
[17:41:08.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:08.066]                   if (TRUE && !signal) {
[17:41:08.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:08.066]                     {
[17:41:08.066]                       inherits <- base::inherits
[17:41:08.066]                       invokeRestart <- base::invokeRestart
[17:41:08.066]                       is.null <- base::is.null
[17:41:08.066]                       muffled <- FALSE
[17:41:08.066]                       if (inherits(cond, "message")) {
[17:41:08.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:08.066]                         if (muffled) 
[17:41:08.066]                           invokeRestart("muffleMessage")
[17:41:08.066]                       }
[17:41:08.066]                       else if (inherits(cond, "warning")) {
[17:41:08.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:08.066]                         if (muffled) 
[17:41:08.066]                           invokeRestart("muffleWarning")
[17:41:08.066]                       }
[17:41:08.066]                       else if (inherits(cond, "condition")) {
[17:41:08.066]                         if (!is.null(pattern)) {
[17:41:08.066]                           computeRestarts <- base::computeRestarts
[17:41:08.066]                           grepl <- base::grepl
[17:41:08.066]                           restarts <- computeRestarts(cond)
[17:41:08.066]                           for (restart in restarts) {
[17:41:08.066]                             name <- restart$name
[17:41:08.066]                             if (is.null(name)) 
[17:41:08.066]                               next
[17:41:08.066]                             if (!grepl(pattern, name)) 
[17:41:08.066]                               next
[17:41:08.066]                             invokeRestart(restart)
[17:41:08.066]                             muffled <- TRUE
[17:41:08.066]                             break
[17:41:08.066]                           }
[17:41:08.066]                         }
[17:41:08.066]                       }
[17:41:08.066]                       invisible(muffled)
[17:41:08.066]                     }
[17:41:08.066]                     muffleCondition(cond, pattern = "^muffle")
[17:41:08.066]                   }
[17:41:08.066]                 }
[17:41:08.066]                 else {
[17:41:08.066]                   if (TRUE) {
[17:41:08.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:08.066]                     {
[17:41:08.066]                       inherits <- base::inherits
[17:41:08.066]                       invokeRestart <- base::invokeRestart
[17:41:08.066]                       is.null <- base::is.null
[17:41:08.066]                       muffled <- FALSE
[17:41:08.066]                       if (inherits(cond, "message")) {
[17:41:08.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:08.066]                         if (muffled) 
[17:41:08.066]                           invokeRestart("muffleMessage")
[17:41:08.066]                       }
[17:41:08.066]                       else if (inherits(cond, "warning")) {
[17:41:08.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:08.066]                         if (muffled) 
[17:41:08.066]                           invokeRestart("muffleWarning")
[17:41:08.066]                       }
[17:41:08.066]                       else if (inherits(cond, "condition")) {
[17:41:08.066]                         if (!is.null(pattern)) {
[17:41:08.066]                           computeRestarts <- base::computeRestarts
[17:41:08.066]                           grepl <- base::grepl
[17:41:08.066]                           restarts <- computeRestarts(cond)
[17:41:08.066]                           for (restart in restarts) {
[17:41:08.066]                             name <- restart$name
[17:41:08.066]                             if (is.null(name)) 
[17:41:08.066]                               next
[17:41:08.066]                             if (!grepl(pattern, name)) 
[17:41:08.066]                               next
[17:41:08.066]                             invokeRestart(restart)
[17:41:08.066]                             muffled <- TRUE
[17:41:08.066]                             break
[17:41:08.066]                           }
[17:41:08.066]                         }
[17:41:08.066]                       }
[17:41:08.066]                       invisible(muffled)
[17:41:08.066]                     }
[17:41:08.066]                     muffleCondition(cond, pattern = "^muffle")
[17:41:08.066]                   }
[17:41:08.066]                 }
[17:41:08.066]             }
[17:41:08.066]         }))
[17:41:08.066]     }, error = function(ex) {
[17:41:08.066]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:08.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:08.066]                 ...future.rng), started = ...future.startTime, 
[17:41:08.066]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:08.066]             version = "1.8"), class = "FutureResult")
[17:41:08.066]     }, finally = {
[17:41:08.066]         if (!identical(...future.workdir, getwd())) 
[17:41:08.066]             setwd(...future.workdir)
[17:41:08.066]         {
[17:41:08.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:08.066]                 ...future.oldOptions$nwarnings <- NULL
[17:41:08.066]             }
[17:41:08.066]             base::options(...future.oldOptions)
[17:41:08.066]             if (.Platform$OS.type == "windows") {
[17:41:08.066]                 old_names <- names(...future.oldEnvVars)
[17:41:08.066]                 envs <- base::Sys.getenv()
[17:41:08.066]                 names <- names(envs)
[17:41:08.066]                 common <- intersect(names, old_names)
[17:41:08.066]                 added <- setdiff(names, old_names)
[17:41:08.066]                 removed <- setdiff(old_names, names)
[17:41:08.066]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:08.066]                   envs[common]]
[17:41:08.066]                 NAMES <- toupper(changed)
[17:41:08.066]                 args <- list()
[17:41:08.066]                 for (kk in seq_along(NAMES)) {
[17:41:08.066]                   name <- changed[[kk]]
[17:41:08.066]                   NAME <- NAMES[[kk]]
[17:41:08.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:08.066]                     next
[17:41:08.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:08.066]                 }
[17:41:08.066]                 NAMES <- toupper(added)
[17:41:08.066]                 for (kk in seq_along(NAMES)) {
[17:41:08.066]                   name <- added[[kk]]
[17:41:08.066]                   NAME <- NAMES[[kk]]
[17:41:08.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:08.066]                     next
[17:41:08.066]                   args[[name]] <- ""
[17:41:08.066]                 }
[17:41:08.066]                 NAMES <- toupper(removed)
[17:41:08.066]                 for (kk in seq_along(NAMES)) {
[17:41:08.066]                   name <- removed[[kk]]
[17:41:08.066]                   NAME <- NAMES[[kk]]
[17:41:08.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:08.066]                     next
[17:41:08.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:08.066]                 }
[17:41:08.066]                 if (length(args) > 0) 
[17:41:08.066]                   base::do.call(base::Sys.setenv, args = args)
[17:41:08.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:08.066]             }
[17:41:08.066]             else {
[17:41:08.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:08.066]             }
[17:41:08.066]             {
[17:41:08.066]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:08.066]                   0L) {
[17:41:08.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:08.066]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:08.066]                   base::options(opts)
[17:41:08.066]                 }
[17:41:08.066]                 {
[17:41:08.066]                   {
[17:41:08.066]                     NULL
[17:41:08.066]                     RNGkind("Mersenne-Twister")
[17:41:08.066]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:08.066]                       inherits = FALSE)
[17:41:08.066]                   }
[17:41:08.066]                   options(future.plan = NULL)
[17:41:08.066]                   if (is.na(NA_character_)) 
[17:41:08.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:08.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:08.066]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:08.066]                   {
[17:41:08.066]                     future <- SequentialFuture(..., envir = envir)
[17:41:08.066]                     if (!future$lazy) 
[17:41:08.066]                       future <- run(future)
[17:41:08.066]                     invisible(future)
[17:41:08.066]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:08.066]                 }
[17:41:08.066]             }
[17:41:08.066]         }
[17:41:08.066]     })
[17:41:08.066]     if (TRUE) {
[17:41:08.066]         base::sink(type = "output", split = FALSE)
[17:41:08.066]         if (TRUE) {
[17:41:08.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:08.066]         }
[17:41:08.066]         else {
[17:41:08.066]             ...future.result["stdout"] <- base::list(NULL)
[17:41:08.066]         }
[17:41:08.066]         base::close(...future.stdout)
[17:41:08.066]         ...future.stdout <- NULL
[17:41:08.066]     }
[17:41:08.066]     ...future.result$conditions <- ...future.conditions
[17:41:08.066]     ...future.result$finished <- base::Sys.time()
[17:41:08.066]     ...future.result
[17:41:08.066] }
[17:41:08.068] assign_globals() ...
[17:41:08.068] List of 5
[17:41:08.068]  $ ...future.FUN            :function (x, y)  
[17:41:08.068]  $ MoreArgs                 : NULL
[17:41:08.068]  $ ...future.elements_ii    :List of 2
[17:41:08.068]   ..$ :List of 2
[17:41:08.068]   .. ..$ : int 1
[17:41:08.068]   .. ..$ : int 0
[17:41:08.068]   ..$ :List of 2
[17:41:08.068]   .. ..$ : int 0
[17:41:08.068]   .. ..$ : int 1
[17:41:08.068]  $ ...future.seeds_ii       : NULL
[17:41:08.068]  $ ...future.globals.maxSize: NULL
[17:41:08.068]  - attr(*, "resolved")= logi FALSE
[17:41:08.068]  - attr(*, "total_size")= num 6480
[17:41:08.068]  - attr(*, "where")=List of 5
[17:41:08.068]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:08.068]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:08.068]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:08.068]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:08.068]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:08.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:08.068]  - attr(*, "already-done")= logi TRUE
[17:41:08.075] - reassign environment for ‘...future.FUN’
[17:41:08.075] - copied ‘...future.FUN’ to environment
[17:41:08.075] - copied ‘MoreArgs’ to environment
[17:41:08.075] - copied ‘...future.elements_ii’ to environment
[17:41:08.075] - copied ‘...future.seeds_ii’ to environment
[17:41:08.076] - copied ‘...future.globals.maxSize’ to environment
[17:41:08.076] assign_globals() ... done
[17:41:08.076] plan(): Setting new future strategy stack:
[17:41:08.076] List of future strategies:
[17:41:08.076] 1. sequential:
[17:41:08.076]    - args: function (..., envir = parent.frame())
[17:41:08.076]    - tweaked: FALSE
[17:41:08.076]    - call: NULL
[17:41:08.076] plan(): nbrOfWorkers() = 1
[17:41:08.578] plan(): Setting new future strategy stack:
[17:41:08.578] List of future strategies:
[17:41:08.578] 1. sequential:
[17:41:08.578]    - args: function (..., envir = parent.frame())
[17:41:08.578]    - tweaked: FALSE
[17:41:08.578]    - call: plan(strategy)
[17:41:08.579] plan(): nbrOfWorkers() = 1
[17:41:08.579] SequentialFuture started (and completed)
[17:41:08.579] - Launch lazy future ... done
[17:41:08.579] run() for ‘SequentialFuture’ ... done
[17:41:08.579] Created future:
[17:41:08.579] SequentialFuture:
[17:41:08.579] Label: ‘future_mapply-1’
[17:41:08.579] Expression:
[17:41:08.579] {
[17:41:08.579]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:08.579]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:08.579]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:08.579]         on.exit(options(oopts), add = TRUE)
[17:41:08.579]     }
[17:41:08.579]     {
[17:41:08.579]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:08.579]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:08.579]         do.call(mapply, args = args)
[17:41:08.579]     }
[17:41:08.579] }
[17:41:08.579] Lazy evaluation: FALSE
[17:41:08.579] Asynchronous evaluation: FALSE
[17:41:08.579] Local evaluation: TRUE
[17:41:08.579] Environment: R_GlobalEnv
[17:41:08.579] Capture standard output: TRUE
[17:41:08.579] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:08.579] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:08.579] Packages: <none>
[17:41:08.579] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:08.579] Resolved: TRUE
[17:41:08.579] Value: 224 bytes of class ‘list’
[17:41:08.579] Early signaling: FALSE
[17:41:08.579] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:08.579] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:08.580] Chunk #1 of 1 ... DONE
[17:41:08.580] Launching 1 futures (chunks) ... DONE
[17:41:08.581] Resolving 1 futures (chunks) ...
[17:41:08.581] resolve() on list ...
[17:41:08.581]  recursive: 0
[17:41:08.581]  length: 1
[17:41:08.581] 
[17:41:08.581] resolved() for ‘SequentialFuture’ ...
[17:41:08.581] - state: ‘finished’
[17:41:08.581] - run: TRUE
[17:41:08.581] - result: ‘FutureResult’
[17:41:08.581] resolved() for ‘SequentialFuture’ ... done
[17:41:08.581] Future #1
[17:41:08.582] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:08.582] - nx: 1
[17:41:08.582] - relay: TRUE
[17:41:08.582] - stdout: TRUE
[17:41:08.582] - signal: TRUE
[17:41:08.582] - resignal: FALSE
[17:41:08.582] - force: TRUE
[17:41:08.582] - relayed: [n=1] FALSE
[17:41:08.582] - queued futures: [n=1] FALSE
[17:41:08.582]  - until=1
[17:41:08.583]  - relaying element #1
[17:41:08.583] - relayed: [n=1] TRUE
[17:41:08.583] - queued futures: [n=1] TRUE
[17:41:08.583] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:08.583]  length: 0 (resolved future 1)
[17:41:08.583] Relaying remaining futures
[17:41:08.583] signalConditionsASAP(NULL, pos=0) ...
[17:41:08.583] - nx: 1
[17:41:08.583] - relay: TRUE
[17:41:08.583] - stdout: TRUE
[17:41:08.584] - signal: TRUE
[17:41:08.584] - resignal: FALSE
[17:41:08.584] - force: TRUE
[17:41:08.584] - relayed: [n=1] TRUE
[17:41:08.584] - queued futures: [n=1] TRUE
 - flush all
[17:41:08.584] - relayed: [n=1] TRUE
[17:41:08.584] - queued futures: [n=1] TRUE
[17:41:08.584] signalConditionsASAP(NULL, pos=0) ... done
[17:41:08.584] resolve() on list ... DONE
[17:41:08.584]  - Number of value chunks collected: 1
[17:41:08.585] Resolving 1 futures (chunks) ... DONE
[17:41:08.585] Reducing values from 1 chunks ...
[17:41:08.585]  - Number of values collected after concatenation: 2
[17:41:08.585]  - Number of values expected: 2
[17:41:08.585] Reducing values from 1 chunks ... DONE
[17:41:08.585] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:41:08.585] future_mapply() ...
[17:41:08.586] Number of chunks: 1
[17:41:08.586] getGlobalsAndPackagesXApply() ...
[17:41:08.586]  - future.globals: TRUE
[17:41:08.586] getGlobalsAndPackages() ...
[17:41:08.586] Searching for globals...
[17:41:08.587] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:08.588] Searching for globals ... DONE
[17:41:08.588] Resolving globals: FALSE
[17:41:08.588] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:08.588] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:08.589] - globals: [1] ‘FUN’
[17:41:08.589] 
[17:41:08.589] getGlobalsAndPackages() ... DONE
[17:41:08.589]  - globals found/used: [n=1] ‘FUN’
[17:41:08.589]  - needed namespaces: [n=0] 
[17:41:08.589] Finding globals ... DONE
[17:41:08.589] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:08.589] List of 2
[17:41:08.589]  $ ...future.FUN:function (x, y)  
[17:41:08.589]  $ MoreArgs     : NULL
[17:41:08.589]  - attr(*, "where")=List of 2
[17:41:08.589]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:08.589]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:08.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:08.589]  - attr(*, "resolved")= logi FALSE
[17:41:08.589]  - attr(*, "total_size")= num NA
[17:41:08.592] Packages to be attached in all futures: [n=0] 
[17:41:08.592] getGlobalsAndPackagesXApply() ... DONE
[17:41:08.592] Number of futures (= number of chunks): 1
[17:41:08.592] Launching 1 futures (chunks) ...
[17:41:08.592] Chunk #1 of 1 ...
[17:41:08.592]  - Finding globals in '...' for chunk #1 ...
[17:41:08.593] getGlobalsAndPackages() ...
[17:41:08.593] Searching for globals...
[17:41:08.593] 
[17:41:08.593] Searching for globals ... DONE
[17:41:08.593] - globals: [0] <none>
[17:41:08.593] getGlobalsAndPackages() ... DONE
[17:41:08.595]    + additional globals found: [n=0] 
[17:41:08.595]    + additional namespaces needed: [n=0] 
[17:41:08.595]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:08.595]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:08.595]  - seeds: <none>
[17:41:08.595] getGlobalsAndPackages() ...
[17:41:08.596] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:08.596] Resolving globals: FALSE
[17:41:08.596] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:08.597] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:08.597] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:08.597] 
[17:41:08.597] getGlobalsAndPackages() ... DONE
[17:41:08.597] run() for ‘Future’ ...
[17:41:08.597] - state: ‘created’
[17:41:08.597] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:08.598] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:08.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:08.598]   - Field: ‘label’
[17:41:08.598]   - Field: ‘local’
[17:41:08.598]   - Field: ‘owner’
[17:41:08.598]   - Field: ‘envir’
[17:41:08.598]   - Field: ‘packages’
[17:41:08.598]   - Field: ‘gc’
[17:41:08.599]   - Field: ‘conditions’
[17:41:08.599]   - Field: ‘expr’
[17:41:08.599]   - Field: ‘uuid’
[17:41:08.599]   - Field: ‘seed’
[17:41:08.599]   - Field: ‘version’
[17:41:08.599]   - Field: ‘result’
[17:41:08.599]   - Field: ‘asynchronous’
[17:41:08.599]   - Field: ‘calls’
[17:41:08.599]   - Field: ‘globals’
[17:41:08.599]   - Field: ‘stdout’
[17:41:08.600]   - Field: ‘earlySignal’
[17:41:08.600]   - Field: ‘lazy’
[17:41:08.600]   - Field: ‘state’
[17:41:08.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:08.600] - Launch lazy future ...
[17:41:08.600] Packages needed by the future expression (n = 0): <none>
[17:41:08.600] Packages needed by future strategies (n = 0): <none>
[17:41:08.601] {
[17:41:08.601]     {
[17:41:08.601]         {
[17:41:08.601]             ...future.startTime <- base::Sys.time()
[17:41:08.601]             {
[17:41:08.601]                 {
[17:41:08.601]                   {
[17:41:08.601]                     base::local({
[17:41:08.601]                       has_future <- base::requireNamespace("future", 
[17:41:08.601]                         quietly = TRUE)
[17:41:08.601]                       if (has_future) {
[17:41:08.601]                         ns <- base::getNamespace("future")
[17:41:08.601]                         version <- ns[[".package"]][["version"]]
[17:41:08.601]                         if (is.null(version)) 
[17:41:08.601]                           version <- utils::packageVersion("future")
[17:41:08.601]                       }
[17:41:08.601]                       else {
[17:41:08.601]                         version <- NULL
[17:41:08.601]                       }
[17:41:08.601]                       if (!has_future || version < "1.8.0") {
[17:41:08.601]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:08.601]                           "", base::R.version$version.string), 
[17:41:08.601]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:08.601]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:08.601]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:08.601]                             "release", "version")], collapse = " "), 
[17:41:08.601]                           hostname = base::Sys.info()[["nodename"]])
[17:41:08.601]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:08.601]                           info)
[17:41:08.601]                         info <- base::paste(info, collapse = "; ")
[17:41:08.601]                         if (!has_future) {
[17:41:08.601]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:08.601]                             info)
[17:41:08.601]                         }
[17:41:08.601]                         else {
[17:41:08.601]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:08.601]                             info, version)
[17:41:08.601]                         }
[17:41:08.601]                         base::stop(msg)
[17:41:08.601]                       }
[17:41:08.601]                     })
[17:41:08.601]                   }
[17:41:08.601]                   options(future.plan = NULL)
[17:41:08.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:08.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:08.601]                 }
[17:41:08.601]                 ...future.workdir <- getwd()
[17:41:08.601]             }
[17:41:08.601]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:08.601]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:08.601]         }
[17:41:08.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:08.601]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:08.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:08.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:08.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:08.601]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:08.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:08.601]             base::names(...future.oldOptions))
[17:41:08.601]     }
[17:41:08.601]     if (TRUE) {
[17:41:08.601]     }
[17:41:08.601]     else {
[17:41:08.601]         if (NA) {
[17:41:08.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:08.601]                 open = "w")
[17:41:08.601]         }
[17:41:08.601]         else {
[17:41:08.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:08.601]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:08.601]         }
[17:41:08.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:08.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:08.601]             base::sink(type = "output", split = FALSE)
[17:41:08.601]             base::close(...future.stdout)
[17:41:08.601]         }, add = TRUE)
[17:41:08.601]     }
[17:41:08.601]     ...future.frame <- base::sys.nframe()
[17:41:08.601]     ...future.conditions <- base::list()
[17:41:08.601]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:08.601]     if (FALSE) {
[17:41:08.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:08.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:08.601]     }
[17:41:08.601]     ...future.result <- base::tryCatch({
[17:41:08.601]         base::withCallingHandlers({
[17:41:08.601]             ...future.value <- base::withVisible(base::local({
[17:41:08.601]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:08.601]                 if (!identical(...future.globals.maxSize.org, 
[17:41:08.601]                   ...future.globals.maxSize)) {
[17:41:08.601]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:08.601]                   on.exit(options(oopts), add = TRUE)
[17:41:08.601]                 }
[17:41:08.601]                 {
[17:41:08.601]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:08.601]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:08.601]                     USE.NAMES = FALSE)
[17:41:08.601]                   do.call(mapply, args = args)
[17:41:08.601]                 }
[17:41:08.601]             }))
[17:41:08.601]             future::FutureResult(value = ...future.value$value, 
[17:41:08.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:08.601]                   ...future.rng), globalenv = if (FALSE) 
[17:41:08.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:08.601]                     ...future.globalenv.names))
[17:41:08.601]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:08.601]         }, condition = base::local({
[17:41:08.601]             c <- base::c
[17:41:08.601]             inherits <- base::inherits
[17:41:08.601]             invokeRestart <- base::invokeRestart
[17:41:08.601]             length <- base::length
[17:41:08.601]             list <- base::list
[17:41:08.601]             seq.int <- base::seq.int
[17:41:08.601]             signalCondition <- base::signalCondition
[17:41:08.601]             sys.calls <- base::sys.calls
[17:41:08.601]             `[[` <- base::`[[`
[17:41:08.601]             `+` <- base::`+`
[17:41:08.601]             `<<-` <- base::`<<-`
[17:41:08.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:08.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:08.601]                   3L)]
[17:41:08.601]             }
[17:41:08.601]             function(cond) {
[17:41:08.601]                 is_error <- inherits(cond, "error")
[17:41:08.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:08.601]                   NULL)
[17:41:08.601]                 if (is_error) {
[17:41:08.601]                   sessionInformation <- function() {
[17:41:08.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:08.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:08.601]                       search = base::search(), system = base::Sys.info())
[17:41:08.601]                   }
[17:41:08.601]                   ...future.conditions[[length(...future.conditions) + 
[17:41:08.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:08.601]                     cond$call), session = sessionInformation(), 
[17:41:08.601]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:08.601]                   signalCondition(cond)
[17:41:08.601]                 }
[17:41:08.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:08.601]                 "immediateCondition"))) {
[17:41:08.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:08.601]                   ...future.conditions[[length(...future.conditions) + 
[17:41:08.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:08.601]                   if (TRUE && !signal) {
[17:41:08.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:08.601]                     {
[17:41:08.601]                       inherits <- base::inherits
[17:41:08.601]                       invokeRestart <- base::invokeRestart
[17:41:08.601]                       is.null <- base::is.null
[17:41:08.601]                       muffled <- FALSE
[17:41:08.601]                       if (inherits(cond, "message")) {
[17:41:08.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:08.601]                         if (muffled) 
[17:41:08.601]                           invokeRestart("muffleMessage")
[17:41:08.601]                       }
[17:41:08.601]                       else if (inherits(cond, "warning")) {
[17:41:08.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:08.601]                         if (muffled) 
[17:41:08.601]                           invokeRestart("muffleWarning")
[17:41:08.601]                       }
[17:41:08.601]                       else if (inherits(cond, "condition")) {
[17:41:08.601]                         if (!is.null(pattern)) {
[17:41:08.601]                           computeRestarts <- base::computeRestarts
[17:41:08.601]                           grepl <- base::grepl
[17:41:08.601]                           restarts <- computeRestarts(cond)
[17:41:08.601]                           for (restart in restarts) {
[17:41:08.601]                             name <- restart$name
[17:41:08.601]                             if (is.null(name)) 
[17:41:08.601]                               next
[17:41:08.601]                             if (!grepl(pattern, name)) 
[17:41:08.601]                               next
[17:41:08.601]                             invokeRestart(restart)
[17:41:08.601]                             muffled <- TRUE
[17:41:08.601]                             break
[17:41:08.601]                           }
[17:41:08.601]                         }
[17:41:08.601]                       }
[17:41:08.601]                       invisible(muffled)
[17:41:08.601]                     }
[17:41:08.601]                     muffleCondition(cond, pattern = "^muffle")
[17:41:08.601]                   }
[17:41:08.601]                 }
[17:41:08.601]                 else {
[17:41:08.601]                   if (TRUE) {
[17:41:08.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:08.601]                     {
[17:41:08.601]                       inherits <- base::inherits
[17:41:08.601]                       invokeRestart <- base::invokeRestart
[17:41:08.601]                       is.null <- base::is.null
[17:41:08.601]                       muffled <- FALSE
[17:41:08.601]                       if (inherits(cond, "message")) {
[17:41:08.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:08.601]                         if (muffled) 
[17:41:08.601]                           invokeRestart("muffleMessage")
[17:41:08.601]                       }
[17:41:08.601]                       else if (inherits(cond, "warning")) {
[17:41:08.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:08.601]                         if (muffled) 
[17:41:08.601]                           invokeRestart("muffleWarning")
[17:41:08.601]                       }
[17:41:08.601]                       else if (inherits(cond, "condition")) {
[17:41:08.601]                         if (!is.null(pattern)) {
[17:41:08.601]                           computeRestarts <- base::computeRestarts
[17:41:08.601]                           grepl <- base::grepl
[17:41:08.601]                           restarts <- computeRestarts(cond)
[17:41:08.601]                           for (restart in restarts) {
[17:41:08.601]                             name <- restart$name
[17:41:08.601]                             if (is.null(name)) 
[17:41:08.601]                               next
[17:41:08.601]                             if (!grepl(pattern, name)) 
[17:41:08.601]                               next
[17:41:08.601]                             invokeRestart(restart)
[17:41:08.601]                             muffled <- TRUE
[17:41:08.601]                             break
[17:41:08.601]                           }
[17:41:08.601]                         }
[17:41:08.601]                       }
[17:41:08.601]                       invisible(muffled)
[17:41:08.601]                     }
[17:41:08.601]                     muffleCondition(cond, pattern = "^muffle")
[17:41:08.601]                   }
[17:41:08.601]                 }
[17:41:08.601]             }
[17:41:08.601]         }))
[17:41:08.601]     }, error = function(ex) {
[17:41:08.601]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:08.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:08.601]                 ...future.rng), started = ...future.startTime, 
[17:41:08.601]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:08.601]             version = "1.8"), class = "FutureResult")
[17:41:08.601]     }, finally = {
[17:41:08.601]         if (!identical(...future.workdir, getwd())) 
[17:41:08.601]             setwd(...future.workdir)
[17:41:08.601]         {
[17:41:08.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:08.601]                 ...future.oldOptions$nwarnings <- NULL
[17:41:08.601]             }
[17:41:08.601]             base::options(...future.oldOptions)
[17:41:08.601]             if (.Platform$OS.type == "windows") {
[17:41:08.601]                 old_names <- names(...future.oldEnvVars)
[17:41:08.601]                 envs <- base::Sys.getenv()
[17:41:08.601]                 names <- names(envs)
[17:41:08.601]                 common <- intersect(names, old_names)
[17:41:08.601]                 added <- setdiff(names, old_names)
[17:41:08.601]                 removed <- setdiff(old_names, names)
[17:41:08.601]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:08.601]                   envs[common]]
[17:41:08.601]                 NAMES <- toupper(changed)
[17:41:08.601]                 args <- list()
[17:41:08.601]                 for (kk in seq_along(NAMES)) {
[17:41:08.601]                   name <- changed[[kk]]
[17:41:08.601]                   NAME <- NAMES[[kk]]
[17:41:08.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:08.601]                     next
[17:41:08.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:08.601]                 }
[17:41:08.601]                 NAMES <- toupper(added)
[17:41:08.601]                 for (kk in seq_along(NAMES)) {
[17:41:08.601]                   name <- added[[kk]]
[17:41:08.601]                   NAME <- NAMES[[kk]]
[17:41:08.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:08.601]                     next
[17:41:08.601]                   args[[name]] <- ""
[17:41:08.601]                 }
[17:41:08.601]                 NAMES <- toupper(removed)
[17:41:08.601]                 for (kk in seq_along(NAMES)) {
[17:41:08.601]                   name <- removed[[kk]]
[17:41:08.601]                   NAME <- NAMES[[kk]]
[17:41:08.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:08.601]                     next
[17:41:08.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:08.601]                 }
[17:41:08.601]                 if (length(args) > 0) 
[17:41:08.601]                   base::do.call(base::Sys.setenv, args = args)
[17:41:08.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:08.601]             }
[17:41:08.601]             else {
[17:41:08.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:08.601]             }
[17:41:08.601]             {
[17:41:08.601]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:08.601]                   0L) {
[17:41:08.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:08.601]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:08.601]                   base::options(opts)
[17:41:08.601]                 }
[17:41:08.601]                 {
[17:41:08.601]                   {
[17:41:08.601]                     NULL
[17:41:08.601]                     RNGkind("Mersenne-Twister")
[17:41:08.601]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:08.601]                       inherits = FALSE)
[17:41:08.601]                   }
[17:41:08.601]                   options(future.plan = NULL)
[17:41:08.601]                   if (is.na(NA_character_)) 
[17:41:08.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:08.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:08.601]                   future::plan(list(function (..., envir = parent.frame()) 
[17:41:08.601]                   {
[17:41:08.601]                     future <- SequentialFuture(..., envir = envir)
[17:41:08.601]                     if (!future$lazy) 
[17:41:08.601]                       future <- run(future)
[17:41:08.601]                     invisible(future)
[17:41:08.601]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:08.601]                 }
[17:41:08.601]             }
[17:41:08.601]         }
[17:41:08.601]     })
[17:41:08.601]     if (FALSE) {
[17:41:08.601]         base::sink(type = "output", split = FALSE)
[17:41:08.601]         if (NA) {
[17:41:08.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:08.601]         }
[17:41:08.601]         else {
[17:41:08.601]             ...future.result["stdout"] <- base::list(NULL)
[17:41:08.601]         }
[17:41:08.601]         base::close(...future.stdout)
[17:41:08.601]         ...future.stdout <- NULL
[17:41:08.601]     }
[17:41:08.601]     ...future.result$conditions <- ...future.conditions
[17:41:08.601]     ...future.result$finished <- base::Sys.time()
[17:41:08.601]     ...future.result
[17:41:08.601] }
[17:41:08.602] assign_globals() ...
[17:41:08.602] List of 5
[17:41:08.602]  $ ...future.FUN            :function (x, y)  
[17:41:08.602]  $ MoreArgs                 : NULL
[17:41:08.602]  $ ...future.elements_ii    :List of 2
[17:41:08.602]   ..$ :List of 2
[17:41:08.602]   .. ..$ : int 1
[17:41:08.602]   .. ..$ : int 0
[17:41:08.602]   ..$ :List of 2
[17:41:08.602]   .. ..$ : int 0
[17:41:08.602]   .. ..$ : int 1
[17:41:08.602]  $ ...future.seeds_ii       : NULL
[17:41:08.602]  $ ...future.globals.maxSize: NULL
[17:41:08.602]  - attr(*, "resolved")= logi FALSE
[17:41:08.602]  - attr(*, "total_size")= num 6480
[17:41:08.602]  - attr(*, "where")=List of 5
[17:41:08.602]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:08.602]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:08.602]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:08.602]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:08.602]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:08.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:08.602]  - attr(*, "already-done")= logi TRUE
[17:41:08.608] - reassign environment for ‘...future.FUN’
[17:41:08.608] - copied ‘...future.FUN’ to environment
[17:41:08.608] - copied ‘MoreArgs’ to environment
[17:41:08.608] - copied ‘...future.elements_ii’ to environment
[17:41:08.608] - copied ‘...future.seeds_ii’ to environment
[17:41:08.608] - copied ‘...future.globals.maxSize’ to environment
[17:41:08.608] assign_globals() ... done
[17:41:08.609] plan(): Setting new future strategy stack:
[17:41:08.609] List of future strategies:
[17:41:08.609] 1. sequential:
[17:41:08.609]    - args: function (..., envir = parent.frame())
[17:41:08.609]    - tweaked: FALSE
[17:41:08.609]    - call: NULL
[17:41:08.609] plan(): nbrOfWorkers() = 1
[17:41:09.111] plan(): Setting new future strategy stack:
[17:41:09.111] List of future strategies:
[17:41:09.111] 1. sequential:
[17:41:09.111]    - args: function (..., envir = parent.frame())
[17:41:09.111]    - tweaked: FALSE
[17:41:09.111]    - call: plan(strategy)
[17:41:09.111] plan(): nbrOfWorkers() = 1
[17:41:09.112] SequentialFuture started (and completed)
[17:41:09.112] - Launch lazy future ... done
[17:41:09.112] run() for ‘SequentialFuture’ ... done
[17:41:09.112] Created future:
[17:41:09.112] SequentialFuture:
[17:41:09.112] Label: ‘future_mapply-1’
[17:41:09.112] Expression:
[17:41:09.112] {
[17:41:09.112]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:09.112]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:09.112]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:09.112]         on.exit(options(oopts), add = TRUE)
[17:41:09.112]     }
[17:41:09.112]     {
[17:41:09.112]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:09.112]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:09.112]         do.call(mapply, args = args)
[17:41:09.112]     }
[17:41:09.112] }
[17:41:09.112] Lazy evaluation: FALSE
[17:41:09.112] Asynchronous evaluation: FALSE
[17:41:09.112] Local evaluation: TRUE
[17:41:09.112] Environment: R_GlobalEnv
[17:41:09.112] Capture standard output: NA
[17:41:09.112] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:09.112] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:09.112] Packages: <none>
[17:41:09.112] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:09.112] Resolved: TRUE
[17:41:09.112] Value: 224 bytes of class ‘list’
[17:41:09.112] Early signaling: FALSE
[17:41:09.112] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:09.112] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:09.113] Chunk #1 of 1 ... DONE
[17:41:09.113] Launching 1 futures (chunks) ... DONE
[17:41:09.113] Resolving 1 futures (chunks) ...
[17:41:09.113] resolve() on list ...
[17:41:09.113]  recursive: 0
[17:41:09.114]  length: 1
[17:41:09.114] 
[17:41:09.114] resolved() for ‘SequentialFuture’ ...
[17:41:09.114] - state: ‘finished’
[17:41:09.114] - run: TRUE
[17:41:09.114] - result: ‘FutureResult’
[17:41:09.114] resolved() for ‘SequentialFuture’ ... done
[17:41:09.114] Future #1
[17:41:09.114] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:09.114] - nx: 1
[17:41:09.115] - relay: TRUE
[17:41:09.115] - stdout: TRUE
[17:41:09.115] - signal: TRUE
[17:41:09.115] - resignal: FALSE
[17:41:09.115] - force: TRUE
[17:41:09.115] - relayed: [n=1] FALSE
[17:41:09.115] - queued futures: [n=1] FALSE
[17:41:09.115]  - until=1
[17:41:09.115]  - relaying element #1
[17:41:09.115] - relayed: [n=1] TRUE
[17:41:09.115] - queued futures: [n=1] TRUE
[17:41:09.116] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:09.116]  length: 0 (resolved future 1)
[17:41:09.116] Relaying remaining futures
[17:41:09.116] signalConditionsASAP(NULL, pos=0) ...
[17:41:09.116] - nx: 1
[17:41:09.116] - relay: TRUE
[17:41:09.116] - stdout: TRUE
[17:41:09.116] - signal: TRUE
[17:41:09.116] - resignal: FALSE
[17:41:09.116] - force: TRUE
[17:41:09.116] - relayed: [n=1] TRUE
[17:41:09.116] - queued futures: [n=1] TRUE
 - flush all
[17:41:09.117] - relayed: [n=1] TRUE
[17:41:09.117] - queued futures: [n=1] TRUE
[17:41:09.117] signalConditionsASAP(NULL, pos=0) ... done
[17:41:09.117] resolve() on list ... DONE
[17:41:09.117]  - Number of value chunks collected: 1
[17:41:09.117] Resolving 1 futures (chunks) ... DONE
[17:41:09.117] Reducing values from 1 chunks ...
[17:41:09.117]  - Number of values collected after concatenation: 2
[17:41:09.117]  - Number of values expected: 2
[17:41:09.117] Reducing values from 1 chunks ... DONE
[17:41:09.118] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[17:41:09.118] plan(): Setting new future strategy stack:
[17:41:09.118] List of future strategies:
[17:41:09.118] 1. multicore:
[17:41:09.118]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:09.118]    - tweaked: FALSE
[17:41:09.118]    - call: plan(strategy)
[17:41:09.122] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:41:09.124] future_lapply() ...
[17:41:09.128] Number of chunks: 1
[17:41:09.128] getGlobalsAndPackagesXApply() ...
[17:41:09.128]  - future.globals: TRUE
[17:41:09.128] getGlobalsAndPackages() ...
[17:41:09.128] Searching for globals...
[17:41:09.130] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:09.130] Searching for globals ... DONE
[17:41:09.130] Resolving globals: FALSE
[17:41:09.130] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:09.131] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:09.131] - globals: [1] ‘FUN’
[17:41:09.131] 
[17:41:09.131] getGlobalsAndPackages() ... DONE
[17:41:09.131]  - globals found/used: [n=1] ‘FUN’
[17:41:09.131]  - needed namespaces: [n=0] 
[17:41:09.131] Finding globals ... DONE
[17:41:09.131]  - use_args: TRUE
[17:41:09.131]  - Getting '...' globals ...
[17:41:09.132] resolve() on list ...
[17:41:09.132]  recursive: 0
[17:41:09.132]  length: 1
[17:41:09.132]  elements: ‘...’
[17:41:09.132]  length: 0 (resolved future 1)
[17:41:09.132] resolve() on list ... DONE
[17:41:09.132]    - '...' content: [n=0] 
[17:41:09.132] List of 1
[17:41:09.132]  $ ...: list()
[17:41:09.132]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:09.132]  - attr(*, "where")=List of 1
[17:41:09.132]   ..$ ...:<environment: 0x55c988043940> 
[17:41:09.132]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:09.132]  - attr(*, "resolved")= logi TRUE
[17:41:09.132]  - attr(*, "total_size")= num NA
[17:41:09.135]  - Getting '...' globals ... DONE
[17:41:09.135] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:09.135] List of 2
[17:41:09.135]  $ ...future.FUN:function (x)  
[17:41:09.135]  $ ...          : list()
[17:41:09.135]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:09.135]  - attr(*, "where")=List of 2
[17:41:09.135]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:09.135]   ..$ ...          :<environment: 0x55c988043940> 
[17:41:09.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:09.135]  - attr(*, "resolved")= logi FALSE
[17:41:09.135]  - attr(*, "total_size")= num 4720
[17:41:09.138] Packages to be attached in all futures: [n=0] 
[17:41:09.138] getGlobalsAndPackagesXApply() ... DONE
[17:41:09.138] Number of futures (= number of chunks): 1
[17:41:09.138] Launching 1 futures (chunks) ...
[17:41:09.138] Chunk #1 of 1 ...
[17:41:09.138]  - Finding globals in 'X' for chunk #1 ...
[17:41:09.138] getGlobalsAndPackages() ...
[17:41:09.139] Searching for globals...
[17:41:09.139] 
[17:41:09.139] Searching for globals ... DONE
[17:41:09.139] - globals: [0] <none>
[17:41:09.139] getGlobalsAndPackages() ... DONE
[17:41:09.139]    + additional globals found: [n=0] 
[17:41:09.139]    + additional namespaces needed: [n=0] 
[17:41:09.139]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:09.140]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:09.140]  - seeds: <none>
[17:41:09.140] getGlobalsAndPackages() ...
[17:41:09.140] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:09.140] Resolving globals: FALSE
[17:41:09.140] Tweak future expression to call with '...' arguments ...
[17:41:09.140] {
[17:41:09.140]     do.call(function(...) {
[17:41:09.140]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:09.140]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:09.140]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:09.140]             on.exit(options(oopts), add = TRUE)
[17:41:09.140]         }
[17:41:09.140]         {
[17:41:09.140]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:09.140]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:09.140]                 ...future.FUN(...future.X_jj, ...)
[17:41:09.140]             })
[17:41:09.140]         }
[17:41:09.140]     }, args = future.call.arguments)
[17:41:09.140] }
[17:41:09.140] Tweak future expression to call with '...' arguments ... DONE
[17:41:09.141] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:09.141] 
[17:41:09.141] getGlobalsAndPackages() ... DONE
[17:41:09.141] run() for ‘Future’ ...
[17:41:09.141] - state: ‘created’
[17:41:09.141] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:09.145] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:09.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:09.145]   - Field: ‘label’
[17:41:09.145]   - Field: ‘local’
[17:41:09.145]   - Field: ‘owner’
[17:41:09.145]   - Field: ‘envir’
[17:41:09.145]   - Field: ‘packages’
[17:41:09.146]   - Field: ‘gc’
[17:41:09.146]   - Field: ‘conditions’
[17:41:09.146]   - Field: ‘expr’
[17:41:09.146]   - Field: ‘uuid’
[17:41:09.146]   - Field: ‘seed’
[17:41:09.146]   - Field: ‘version’
[17:41:09.146]   - Field: ‘result’
[17:41:09.146]   - Field: ‘asynchronous’
[17:41:09.146]   - Field: ‘calls’
[17:41:09.146]   - Field: ‘globals’
[17:41:09.146]   - Field: ‘stdout’
[17:41:09.147]   - Field: ‘earlySignal’
[17:41:09.147]   - Field: ‘lazy’
[17:41:09.147]   - Field: ‘state’
[17:41:09.147] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:09.147] - Launch lazy future ...
[17:41:09.147] Packages needed by the future expression (n = 0): <none>
[17:41:09.147] Packages needed by future strategies (n = 0): <none>
[17:41:09.148] {
[17:41:09.148]     {
[17:41:09.148]         {
[17:41:09.148]             ...future.startTime <- base::Sys.time()
[17:41:09.148]             {
[17:41:09.148]                 {
[17:41:09.148]                   {
[17:41:09.148]                     base::local({
[17:41:09.148]                       has_future <- base::requireNamespace("future", 
[17:41:09.148]                         quietly = TRUE)
[17:41:09.148]                       if (has_future) {
[17:41:09.148]                         ns <- base::getNamespace("future")
[17:41:09.148]                         version <- ns[[".package"]][["version"]]
[17:41:09.148]                         if (is.null(version)) 
[17:41:09.148]                           version <- utils::packageVersion("future")
[17:41:09.148]                       }
[17:41:09.148]                       else {
[17:41:09.148]                         version <- NULL
[17:41:09.148]                       }
[17:41:09.148]                       if (!has_future || version < "1.8.0") {
[17:41:09.148]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:09.148]                           "", base::R.version$version.string), 
[17:41:09.148]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:09.148]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:09.148]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:09.148]                             "release", "version")], collapse = " "), 
[17:41:09.148]                           hostname = base::Sys.info()[["nodename"]])
[17:41:09.148]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:09.148]                           info)
[17:41:09.148]                         info <- base::paste(info, collapse = "; ")
[17:41:09.148]                         if (!has_future) {
[17:41:09.148]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:09.148]                             info)
[17:41:09.148]                         }
[17:41:09.148]                         else {
[17:41:09.148]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:09.148]                             info, version)
[17:41:09.148]                         }
[17:41:09.148]                         base::stop(msg)
[17:41:09.148]                       }
[17:41:09.148]                     })
[17:41:09.148]                   }
[17:41:09.148]                   options(future.plan = NULL)
[17:41:09.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:09.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:09.148]                 }
[17:41:09.148]                 ...future.workdir <- getwd()
[17:41:09.148]             }
[17:41:09.148]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:09.148]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:09.148]         }
[17:41:09.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:09.148]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:09.148]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:09.148]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:09.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:09.148]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:09.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:09.148]             base::names(...future.oldOptions))
[17:41:09.148]     }
[17:41:09.148]     if (FALSE) {
[17:41:09.148]     }
[17:41:09.148]     else {
[17:41:09.148]         if (FALSE) {
[17:41:09.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:09.148]                 open = "w")
[17:41:09.148]         }
[17:41:09.148]         else {
[17:41:09.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:09.148]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:09.148]         }
[17:41:09.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:09.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:09.148]             base::sink(type = "output", split = FALSE)
[17:41:09.148]             base::close(...future.stdout)
[17:41:09.148]         }, add = TRUE)
[17:41:09.148]     }
[17:41:09.148]     ...future.frame <- base::sys.nframe()
[17:41:09.148]     ...future.conditions <- base::list()
[17:41:09.148]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:09.148]     if (FALSE) {
[17:41:09.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:09.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:09.148]     }
[17:41:09.148]     ...future.result <- base::tryCatch({
[17:41:09.148]         base::withCallingHandlers({
[17:41:09.148]             ...future.value <- base::withVisible(base::local({
[17:41:09.148]                 do.call(function(...) {
[17:41:09.148]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:09.148]                   if (!identical(...future.globals.maxSize.org, 
[17:41:09.148]                     ...future.globals.maxSize)) {
[17:41:09.148]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:09.148]                     on.exit(options(oopts), add = TRUE)
[17:41:09.148]                   }
[17:41:09.148]                   {
[17:41:09.148]                     lapply(seq_along(...future.elements_ii), 
[17:41:09.148]                       FUN = function(jj) {
[17:41:09.148]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:09.148]                         ...future.FUN(...future.X_jj, ...)
[17:41:09.148]                       })
[17:41:09.148]                   }
[17:41:09.148]                 }, args = future.call.arguments)
[17:41:09.148]             }))
[17:41:09.148]             future::FutureResult(value = ...future.value$value, 
[17:41:09.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:09.148]                   ...future.rng), globalenv = if (FALSE) 
[17:41:09.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:09.148]                     ...future.globalenv.names))
[17:41:09.148]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:09.148]         }, condition = base::local({
[17:41:09.148]             c <- base::c
[17:41:09.148]             inherits <- base::inherits
[17:41:09.148]             invokeRestart <- base::invokeRestart
[17:41:09.148]             length <- base::length
[17:41:09.148]             list <- base::list
[17:41:09.148]             seq.int <- base::seq.int
[17:41:09.148]             signalCondition <- base::signalCondition
[17:41:09.148]             sys.calls <- base::sys.calls
[17:41:09.148]             `[[` <- base::`[[`
[17:41:09.148]             `+` <- base::`+`
[17:41:09.148]             `<<-` <- base::`<<-`
[17:41:09.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:09.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:09.148]                   3L)]
[17:41:09.148]             }
[17:41:09.148]             function(cond) {
[17:41:09.148]                 is_error <- inherits(cond, "error")
[17:41:09.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:09.148]                   NULL)
[17:41:09.148]                 if (is_error) {
[17:41:09.148]                   sessionInformation <- function() {
[17:41:09.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:09.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:09.148]                       search = base::search(), system = base::Sys.info())
[17:41:09.148]                   }
[17:41:09.148]                   ...future.conditions[[length(...future.conditions) + 
[17:41:09.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:09.148]                     cond$call), session = sessionInformation(), 
[17:41:09.148]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:09.148]                   signalCondition(cond)
[17:41:09.148]                 }
[17:41:09.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:09.148]                 "immediateCondition"))) {
[17:41:09.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:09.148]                   ...future.conditions[[length(...future.conditions) + 
[17:41:09.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:09.148]                   if (TRUE && !signal) {
[17:41:09.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:09.148]                     {
[17:41:09.148]                       inherits <- base::inherits
[17:41:09.148]                       invokeRestart <- base::invokeRestart
[17:41:09.148]                       is.null <- base::is.null
[17:41:09.148]                       muffled <- FALSE
[17:41:09.148]                       if (inherits(cond, "message")) {
[17:41:09.148]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:09.148]                         if (muffled) 
[17:41:09.148]                           invokeRestart("muffleMessage")
[17:41:09.148]                       }
[17:41:09.148]                       else if (inherits(cond, "warning")) {
[17:41:09.148]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:09.148]                         if (muffled) 
[17:41:09.148]                           invokeRestart("muffleWarning")
[17:41:09.148]                       }
[17:41:09.148]                       else if (inherits(cond, "condition")) {
[17:41:09.148]                         if (!is.null(pattern)) {
[17:41:09.148]                           computeRestarts <- base::computeRestarts
[17:41:09.148]                           grepl <- base::grepl
[17:41:09.148]                           restarts <- computeRestarts(cond)
[17:41:09.148]                           for (restart in restarts) {
[17:41:09.148]                             name <- restart$name
[17:41:09.148]                             if (is.null(name)) 
[17:41:09.148]                               next
[17:41:09.148]                             if (!grepl(pattern, name)) 
[17:41:09.148]                               next
[17:41:09.148]                             invokeRestart(restart)
[17:41:09.148]                             muffled <- TRUE
[17:41:09.148]                             break
[17:41:09.148]                           }
[17:41:09.148]                         }
[17:41:09.148]                       }
[17:41:09.148]                       invisible(muffled)
[17:41:09.148]                     }
[17:41:09.148]                     muffleCondition(cond, pattern = "^muffle")
[17:41:09.148]                   }
[17:41:09.148]                 }
[17:41:09.148]                 else {
[17:41:09.148]                   if (TRUE) {
[17:41:09.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:09.148]                     {
[17:41:09.148]                       inherits <- base::inherits
[17:41:09.148]                       invokeRestart <- base::invokeRestart
[17:41:09.148]                       is.null <- base::is.null
[17:41:09.148]                       muffled <- FALSE
[17:41:09.148]                       if (inherits(cond, "message")) {
[17:41:09.148]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:09.148]                         if (muffled) 
[17:41:09.148]                           invokeRestart("muffleMessage")
[17:41:09.148]                       }
[17:41:09.148]                       else if (inherits(cond, "warning")) {
[17:41:09.148]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:09.148]                         if (muffled) 
[17:41:09.148]                           invokeRestart("muffleWarning")
[17:41:09.148]                       }
[17:41:09.148]                       else if (inherits(cond, "condition")) {
[17:41:09.148]                         if (!is.null(pattern)) {
[17:41:09.148]                           computeRestarts <- base::computeRestarts
[17:41:09.148]                           grepl <- base::grepl
[17:41:09.148]                           restarts <- computeRestarts(cond)
[17:41:09.148]                           for (restart in restarts) {
[17:41:09.148]                             name <- restart$name
[17:41:09.148]                             if (is.null(name)) 
[17:41:09.148]                               next
[17:41:09.148]                             if (!grepl(pattern, name)) 
[17:41:09.148]                               next
[17:41:09.148]                             invokeRestart(restart)
[17:41:09.148]                             muffled <- TRUE
[17:41:09.148]                             break
[17:41:09.148]                           }
[17:41:09.148]                         }
[17:41:09.148]                       }
[17:41:09.148]                       invisible(muffled)
[17:41:09.148]                     }
[17:41:09.148]                     muffleCondition(cond, pattern = "^muffle")
[17:41:09.148]                   }
[17:41:09.148]                 }
[17:41:09.148]             }
[17:41:09.148]         }))
[17:41:09.148]     }, error = function(ex) {
[17:41:09.148]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:09.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:09.148]                 ...future.rng), started = ...future.startTime, 
[17:41:09.148]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:09.148]             version = "1.8"), class = "FutureResult")
[17:41:09.148]     }, finally = {
[17:41:09.148]         if (!identical(...future.workdir, getwd())) 
[17:41:09.148]             setwd(...future.workdir)
[17:41:09.148]         {
[17:41:09.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:09.148]                 ...future.oldOptions$nwarnings <- NULL
[17:41:09.148]             }
[17:41:09.148]             base::options(...future.oldOptions)
[17:41:09.148]             if (.Platform$OS.type == "windows") {
[17:41:09.148]                 old_names <- names(...future.oldEnvVars)
[17:41:09.148]                 envs <- base::Sys.getenv()
[17:41:09.148]                 names <- names(envs)
[17:41:09.148]                 common <- intersect(names, old_names)
[17:41:09.148]                 added <- setdiff(names, old_names)
[17:41:09.148]                 removed <- setdiff(old_names, names)
[17:41:09.148]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:09.148]                   envs[common]]
[17:41:09.148]                 NAMES <- toupper(changed)
[17:41:09.148]                 args <- list()
[17:41:09.148]                 for (kk in seq_along(NAMES)) {
[17:41:09.148]                   name <- changed[[kk]]
[17:41:09.148]                   NAME <- NAMES[[kk]]
[17:41:09.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:09.148]                     next
[17:41:09.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:09.148]                 }
[17:41:09.148]                 NAMES <- toupper(added)
[17:41:09.148]                 for (kk in seq_along(NAMES)) {
[17:41:09.148]                   name <- added[[kk]]
[17:41:09.148]                   NAME <- NAMES[[kk]]
[17:41:09.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:09.148]                     next
[17:41:09.148]                   args[[name]] <- ""
[17:41:09.148]                 }
[17:41:09.148]                 NAMES <- toupper(removed)
[17:41:09.148]                 for (kk in seq_along(NAMES)) {
[17:41:09.148]                   name <- removed[[kk]]
[17:41:09.148]                   NAME <- NAMES[[kk]]
[17:41:09.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:09.148]                     next
[17:41:09.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:09.148]                 }
[17:41:09.148]                 if (length(args) > 0) 
[17:41:09.148]                   base::do.call(base::Sys.setenv, args = args)
[17:41:09.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:09.148]             }
[17:41:09.148]             else {
[17:41:09.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:09.148]             }
[17:41:09.148]             {
[17:41:09.148]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:09.148]                   0L) {
[17:41:09.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:09.148]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:09.148]                   base::options(opts)
[17:41:09.148]                 }
[17:41:09.148]                 {
[17:41:09.148]                   {
[17:41:09.148]                     NULL
[17:41:09.148]                     RNGkind("Mersenne-Twister")
[17:41:09.148]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:09.148]                       inherits = FALSE)
[17:41:09.148]                   }
[17:41:09.148]                   options(future.plan = NULL)
[17:41:09.148]                   if (is.na(NA_character_)) 
[17:41:09.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:09.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:09.148]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:09.148]                     envir = parent.frame()) 
[17:41:09.148]                   {
[17:41:09.148]                     default_workers <- missing(workers)
[17:41:09.148]                     if (is.function(workers)) 
[17:41:09.148]                       workers <- workers()
[17:41:09.148]                     workers <- structure(as.integer(workers), 
[17:41:09.148]                       class = class(workers))
[17:41:09.148]                     stop_if_not(is.finite(workers), workers >= 
[17:41:09.148]                       1L)
[17:41:09.148]                     if ((workers == 1L && !inherits(workers, 
[17:41:09.148]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:09.148]                       if (default_workers) 
[17:41:09.148]                         supportsMulticore(warn = TRUE)
[17:41:09.148]                       return(sequential(..., envir = envir))
[17:41:09.148]                     }
[17:41:09.148]                     oopts <- options(mc.cores = workers)
[17:41:09.148]                     on.exit(options(oopts))
[17:41:09.148]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:09.148]                       envir = envir)
[17:41:09.148]                     if (!future$lazy) 
[17:41:09.148]                       future <- run(future)
[17:41:09.148]                     invisible(future)
[17:41:09.148]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:09.148]                 }
[17:41:09.148]             }
[17:41:09.148]         }
[17:41:09.148]     })
[17:41:09.148]     if (TRUE) {
[17:41:09.148]         base::sink(type = "output", split = FALSE)
[17:41:09.148]         if (FALSE) {
[17:41:09.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:09.148]         }
[17:41:09.148]         else {
[17:41:09.148]             ...future.result["stdout"] <- base::list(NULL)
[17:41:09.148]         }
[17:41:09.148]         base::close(...future.stdout)
[17:41:09.148]         ...future.stdout <- NULL
[17:41:09.148]     }
[17:41:09.148]     ...future.result$conditions <- ...future.conditions
[17:41:09.148]     ...future.result$finished <- base::Sys.time()
[17:41:09.148]     ...future.result
[17:41:09.148] }
[17:41:09.149] assign_globals() ...
[17:41:09.150] List of 5
[17:41:09.150]  $ ...future.FUN            :function (x)  
[17:41:09.150]  $ future.call.arguments    : list()
[17:41:09.150]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:09.150]  $ ...future.elements_ii    :List of 2
[17:41:09.150]   ..$ : int 1
[17:41:09.150]   ..$ : int 0
[17:41:09.150]  $ ...future.seeds_ii       : NULL
[17:41:09.150]  $ ...future.globals.maxSize: NULL
[17:41:09.150]  - attr(*, "resolved")= logi FALSE
[17:41:09.150]  - attr(*, "total_size")= num 4720
[17:41:09.150]  - attr(*, "where")=List of 5
[17:41:09.150]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:09.150]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:09.150]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:09.150]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:09.150]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:09.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:09.150]  - attr(*, "already-done")= logi TRUE
[17:41:09.156] - reassign environment for ‘...future.FUN’
[17:41:09.156] - copied ‘...future.FUN’ to environment
[17:41:09.156] - copied ‘future.call.arguments’ to environment
[17:41:09.156] - copied ‘...future.elements_ii’ to environment
[17:41:09.156] - copied ‘...future.seeds_ii’ to environment
[17:41:09.156] - copied ‘...future.globals.maxSize’ to environment
[17:41:09.157] assign_globals() ... done
[17:41:09.157] plan(): Setting new future strategy stack:
[17:41:09.157] List of future strategies:
[17:41:09.157] 1. sequential:
[17:41:09.157]    - args: function (..., envir = parent.frame())
[17:41:09.157]    - tweaked: FALSE
[17:41:09.157]    - call: NULL
[17:41:09.157] plan(): nbrOfWorkers() = 1
[17:41:09.659] plan(): Setting new future strategy stack:
[17:41:09.659] List of future strategies:
[17:41:09.659] 1. multicore:
[17:41:09.659]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:09.659]    - tweaked: FALSE
[17:41:09.659]    - call: plan(strategy)
[17:41:09.663] plan(): nbrOfWorkers() = 1
[17:41:09.663] SequentialFuture started (and completed)
[17:41:09.664] - Launch lazy future ... done
[17:41:09.664] run() for ‘SequentialFuture’ ... done
[17:41:09.664] Created future:
[17:41:09.664] SequentialFuture:
[17:41:09.664] Label: ‘future_lapply-1’
[17:41:09.664] Expression:
[17:41:09.664] {
[17:41:09.664]     do.call(function(...) {
[17:41:09.664]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:09.664]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:09.664]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:09.664]             on.exit(options(oopts), add = TRUE)
[17:41:09.664]         }
[17:41:09.664]         {
[17:41:09.664]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:09.664]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:09.664]                 ...future.FUN(...future.X_jj, ...)
[17:41:09.664]             })
[17:41:09.664]         }
[17:41:09.664]     }, args = future.call.arguments)
[17:41:09.664] }
[17:41:09.664] Lazy evaluation: FALSE
[17:41:09.664] Asynchronous evaluation: FALSE
[17:41:09.664] Local evaluation: TRUE
[17:41:09.664] Environment: R_GlobalEnv
[17:41:09.664] Capture standard output: FALSE
[17:41:09.664] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:09.664] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:09.664] Packages: <none>
[17:41:09.664] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:09.664] Resolved: TRUE
[17:41:09.664] Value: 112 bytes of class ‘list’
[17:41:09.664] Early signaling: FALSE
[17:41:09.664] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:09.664] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:09.665] Chunk #1 of 1 ... DONE
[17:41:09.665] Launching 1 futures (chunks) ... DONE
[17:41:09.666] Resolving 1 futures (chunks) ...
[17:41:09.666] resolve() on list ...
[17:41:09.666]  recursive: 0
[17:41:09.666]  length: 1
[17:41:09.666] 
[17:41:09.666] resolved() for ‘SequentialFuture’ ...
[17:41:09.666] - state: ‘finished’
[17:41:09.666] - run: TRUE
[17:41:09.666] - result: ‘FutureResult’
[17:41:09.666] resolved() for ‘SequentialFuture’ ... done
[17:41:09.667] Future #1
[17:41:09.667] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:09.667] - nx: 1
[17:41:09.667] - relay: TRUE
[17:41:09.667] - stdout: TRUE
[17:41:09.667] - signal: TRUE
[17:41:09.667] - resignal: FALSE
[17:41:09.667] - force: TRUE
[17:41:09.667] - relayed: [n=1] FALSE
[17:41:09.667] - queued futures: [n=1] FALSE
[17:41:09.667]  - until=1
[17:41:09.668]  - relaying element #1
[17:41:09.668] - relayed: [n=1] TRUE
[17:41:09.668] - queued futures: [n=1] TRUE
[17:41:09.668] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:09.668]  length: 0 (resolved future 1)
[17:41:09.668] Relaying remaining futures
[17:41:09.668] signalConditionsASAP(NULL, pos=0) ...
[17:41:09.668] - nx: 1
[17:41:09.668] - relay: TRUE
[17:41:09.668] - stdout: TRUE
[17:41:09.669] - signal: TRUE
[17:41:09.669] - resignal: FALSE
[17:41:09.669] - force: TRUE
[17:41:09.669] - relayed: [n=1] TRUE
[17:41:09.669] - queued futures: [n=1] TRUE
 - flush all
[17:41:09.669] - relayed: [n=1] TRUE
[17:41:09.669] - queued futures: [n=1] TRUE
[17:41:09.669] signalConditionsASAP(NULL, pos=0) ... done
[17:41:09.669] resolve() on list ... DONE
[17:41:09.669]  - Number of value chunks collected: 1
[17:41:09.670] Resolving 1 futures (chunks) ... DONE
[17:41:09.670] Reducing values from 1 chunks ...
[17:41:09.670]  - Number of values collected after concatenation: 2
[17:41:09.670]  - Number of values expected: 2
[17:41:09.670] Reducing values from 1 chunks ... DONE
[17:41:09.670] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:41:09.670] future_lapply() ...
[17:41:09.674] Number of chunks: 1
[17:41:09.674] getGlobalsAndPackagesXApply() ...
[17:41:09.674]  - future.globals: TRUE
[17:41:09.674] getGlobalsAndPackages() ...
[17:41:09.674] Searching for globals...
[17:41:09.676] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:09.676] Searching for globals ... DONE
[17:41:09.676] Resolving globals: FALSE
[17:41:09.676] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:09.677] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:09.677] - globals: [1] ‘FUN’
[17:41:09.677] 
[17:41:09.677] getGlobalsAndPackages() ... DONE
[17:41:09.677]  - globals found/used: [n=1] ‘FUN’
[17:41:09.677]  - needed namespaces: [n=0] 
[17:41:09.677] Finding globals ... DONE
[17:41:09.677]  - use_args: TRUE
[17:41:09.678]  - Getting '...' globals ...
[17:41:09.678] resolve() on list ...
[17:41:09.678]  recursive: 0
[17:41:09.678]  length: 1
[17:41:09.678]  elements: ‘...’
[17:41:09.678]  length: 0 (resolved future 1)
[17:41:09.678] resolve() on list ... DONE
[17:41:09.678]    - '...' content: [n=0] 
[17:41:09.678] List of 1
[17:41:09.678]  $ ...: list()
[17:41:09.678]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:09.678]  - attr(*, "where")=List of 1
[17:41:09.678]   ..$ ...:<environment: 0x55c988922038> 
[17:41:09.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:09.678]  - attr(*, "resolved")= logi TRUE
[17:41:09.678]  - attr(*, "total_size")= num NA
[17:41:09.681]  - Getting '...' globals ... DONE
[17:41:09.681] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:09.681] List of 2
[17:41:09.681]  $ ...future.FUN:function (x)  
[17:41:09.681]  $ ...          : list()
[17:41:09.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:09.681]  - attr(*, "where")=List of 2
[17:41:09.681]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:09.681]   ..$ ...          :<environment: 0x55c988922038> 
[17:41:09.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:09.681]  - attr(*, "resolved")= logi FALSE
[17:41:09.681]  - attr(*, "total_size")= num 4720
[17:41:09.686] Packages to be attached in all futures: [n=0] 
[17:41:09.686] getGlobalsAndPackagesXApply() ... DONE
[17:41:09.686] Number of futures (= number of chunks): 1
[17:41:09.686] Launching 1 futures (chunks) ...
[17:41:09.686] Chunk #1 of 1 ...
[17:41:09.686]  - Finding globals in 'X' for chunk #1 ...
[17:41:09.686] getGlobalsAndPackages() ...
[17:41:09.686] Searching for globals...
[17:41:09.687] 
[17:41:09.687] Searching for globals ... DONE
[17:41:09.687] - globals: [0] <none>
[17:41:09.687] getGlobalsAndPackages() ... DONE
[17:41:09.687]    + additional globals found: [n=0] 
[17:41:09.687]    + additional namespaces needed: [n=0] 
[17:41:09.687]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:09.687]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:09.687]  - seeds: <none>
[17:41:09.687] getGlobalsAndPackages() ...
[17:41:09.688] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:09.688] Resolving globals: FALSE
[17:41:09.688] Tweak future expression to call with '...' arguments ...
[17:41:09.688] {
[17:41:09.688]     do.call(function(...) {
[17:41:09.688]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:09.688]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:09.688]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:09.688]             on.exit(options(oopts), add = TRUE)
[17:41:09.688]         }
[17:41:09.688]         {
[17:41:09.688]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:09.688]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:09.688]                 ...future.FUN(...future.X_jj, ...)
[17:41:09.688]             })
[17:41:09.688]         }
[17:41:09.688]     }, args = future.call.arguments)
[17:41:09.688] }
[17:41:09.688] Tweak future expression to call with '...' arguments ... DONE
[17:41:09.688] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:09.689] 
[17:41:09.689] getGlobalsAndPackages() ... DONE
[17:41:09.689] run() for ‘Future’ ...
[17:41:09.689] - state: ‘created’
[17:41:09.689] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:09.693] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:09.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:09.693]   - Field: ‘label’
[17:41:09.693]   - Field: ‘local’
[17:41:09.693]   - Field: ‘owner’
[17:41:09.693]   - Field: ‘envir’
[17:41:09.693]   - Field: ‘packages’
[17:41:09.693]   - Field: ‘gc’
[17:41:09.693]   - Field: ‘conditions’
[17:41:09.693]   - Field: ‘expr’
[17:41:09.694]   - Field: ‘uuid’
[17:41:09.694]   - Field: ‘seed’
[17:41:09.694]   - Field: ‘version’
[17:41:09.694]   - Field: ‘result’
[17:41:09.694]   - Field: ‘asynchronous’
[17:41:09.694]   - Field: ‘calls’
[17:41:09.694]   - Field: ‘globals’
[17:41:09.694]   - Field: ‘stdout’
[17:41:09.694]   - Field: ‘earlySignal’
[17:41:09.694]   - Field: ‘lazy’
[17:41:09.694]   - Field: ‘state’
[17:41:09.695] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:09.695] - Launch lazy future ...
[17:41:09.695] Packages needed by the future expression (n = 0): <none>
[17:41:09.695] Packages needed by future strategies (n = 0): <none>
[17:41:09.695] {
[17:41:09.695]     {
[17:41:09.695]         {
[17:41:09.695]             ...future.startTime <- base::Sys.time()
[17:41:09.695]             {
[17:41:09.695]                 {
[17:41:09.695]                   {
[17:41:09.695]                     base::local({
[17:41:09.695]                       has_future <- base::requireNamespace("future", 
[17:41:09.695]                         quietly = TRUE)
[17:41:09.695]                       if (has_future) {
[17:41:09.695]                         ns <- base::getNamespace("future")
[17:41:09.695]                         version <- ns[[".package"]][["version"]]
[17:41:09.695]                         if (is.null(version)) 
[17:41:09.695]                           version <- utils::packageVersion("future")
[17:41:09.695]                       }
[17:41:09.695]                       else {
[17:41:09.695]                         version <- NULL
[17:41:09.695]                       }
[17:41:09.695]                       if (!has_future || version < "1.8.0") {
[17:41:09.695]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:09.695]                           "", base::R.version$version.string), 
[17:41:09.695]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:09.695]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:09.695]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:09.695]                             "release", "version")], collapse = " "), 
[17:41:09.695]                           hostname = base::Sys.info()[["nodename"]])
[17:41:09.695]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:09.695]                           info)
[17:41:09.695]                         info <- base::paste(info, collapse = "; ")
[17:41:09.695]                         if (!has_future) {
[17:41:09.695]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:09.695]                             info)
[17:41:09.695]                         }
[17:41:09.695]                         else {
[17:41:09.695]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:09.695]                             info, version)
[17:41:09.695]                         }
[17:41:09.695]                         base::stop(msg)
[17:41:09.695]                       }
[17:41:09.695]                     })
[17:41:09.695]                   }
[17:41:09.695]                   options(future.plan = NULL)
[17:41:09.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:09.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:09.695]                 }
[17:41:09.695]                 ...future.workdir <- getwd()
[17:41:09.695]             }
[17:41:09.695]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:09.695]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:09.695]         }
[17:41:09.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:09.695]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:09.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:09.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:09.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:09.695]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:09.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:09.695]             base::names(...future.oldOptions))
[17:41:09.695]     }
[17:41:09.695]     if (FALSE) {
[17:41:09.695]     }
[17:41:09.695]     else {
[17:41:09.695]         if (TRUE) {
[17:41:09.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:09.695]                 open = "w")
[17:41:09.695]         }
[17:41:09.695]         else {
[17:41:09.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:09.695]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:09.695]         }
[17:41:09.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:09.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:09.695]             base::sink(type = "output", split = FALSE)
[17:41:09.695]             base::close(...future.stdout)
[17:41:09.695]         }, add = TRUE)
[17:41:09.695]     }
[17:41:09.695]     ...future.frame <- base::sys.nframe()
[17:41:09.695]     ...future.conditions <- base::list()
[17:41:09.695]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:09.695]     if (FALSE) {
[17:41:09.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:09.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:09.695]     }
[17:41:09.695]     ...future.result <- base::tryCatch({
[17:41:09.695]         base::withCallingHandlers({
[17:41:09.695]             ...future.value <- base::withVisible(base::local({
[17:41:09.695]                 do.call(function(...) {
[17:41:09.695]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:09.695]                   if (!identical(...future.globals.maxSize.org, 
[17:41:09.695]                     ...future.globals.maxSize)) {
[17:41:09.695]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:09.695]                     on.exit(options(oopts), add = TRUE)
[17:41:09.695]                   }
[17:41:09.695]                   {
[17:41:09.695]                     lapply(seq_along(...future.elements_ii), 
[17:41:09.695]                       FUN = function(jj) {
[17:41:09.695]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:09.695]                         ...future.FUN(...future.X_jj, ...)
[17:41:09.695]                       })
[17:41:09.695]                   }
[17:41:09.695]                 }, args = future.call.arguments)
[17:41:09.695]             }))
[17:41:09.695]             future::FutureResult(value = ...future.value$value, 
[17:41:09.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:09.695]                   ...future.rng), globalenv = if (FALSE) 
[17:41:09.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:09.695]                     ...future.globalenv.names))
[17:41:09.695]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:09.695]         }, condition = base::local({
[17:41:09.695]             c <- base::c
[17:41:09.695]             inherits <- base::inherits
[17:41:09.695]             invokeRestart <- base::invokeRestart
[17:41:09.695]             length <- base::length
[17:41:09.695]             list <- base::list
[17:41:09.695]             seq.int <- base::seq.int
[17:41:09.695]             signalCondition <- base::signalCondition
[17:41:09.695]             sys.calls <- base::sys.calls
[17:41:09.695]             `[[` <- base::`[[`
[17:41:09.695]             `+` <- base::`+`
[17:41:09.695]             `<<-` <- base::`<<-`
[17:41:09.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:09.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:09.695]                   3L)]
[17:41:09.695]             }
[17:41:09.695]             function(cond) {
[17:41:09.695]                 is_error <- inherits(cond, "error")
[17:41:09.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:09.695]                   NULL)
[17:41:09.695]                 if (is_error) {
[17:41:09.695]                   sessionInformation <- function() {
[17:41:09.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:09.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:09.695]                       search = base::search(), system = base::Sys.info())
[17:41:09.695]                   }
[17:41:09.695]                   ...future.conditions[[length(...future.conditions) + 
[17:41:09.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:09.695]                     cond$call), session = sessionInformation(), 
[17:41:09.695]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:09.695]                   signalCondition(cond)
[17:41:09.695]                 }
[17:41:09.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:09.695]                 "immediateCondition"))) {
[17:41:09.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:09.695]                   ...future.conditions[[length(...future.conditions) + 
[17:41:09.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:09.695]                   if (TRUE && !signal) {
[17:41:09.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:09.695]                     {
[17:41:09.695]                       inherits <- base::inherits
[17:41:09.695]                       invokeRestart <- base::invokeRestart
[17:41:09.695]                       is.null <- base::is.null
[17:41:09.695]                       muffled <- FALSE
[17:41:09.695]                       if (inherits(cond, "message")) {
[17:41:09.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:09.695]                         if (muffled) 
[17:41:09.695]                           invokeRestart("muffleMessage")
[17:41:09.695]                       }
[17:41:09.695]                       else if (inherits(cond, "warning")) {
[17:41:09.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:09.695]                         if (muffled) 
[17:41:09.695]                           invokeRestart("muffleWarning")
[17:41:09.695]                       }
[17:41:09.695]                       else if (inherits(cond, "condition")) {
[17:41:09.695]                         if (!is.null(pattern)) {
[17:41:09.695]                           computeRestarts <- base::computeRestarts
[17:41:09.695]                           grepl <- base::grepl
[17:41:09.695]                           restarts <- computeRestarts(cond)
[17:41:09.695]                           for (restart in restarts) {
[17:41:09.695]                             name <- restart$name
[17:41:09.695]                             if (is.null(name)) 
[17:41:09.695]                               next
[17:41:09.695]                             if (!grepl(pattern, name)) 
[17:41:09.695]                               next
[17:41:09.695]                             invokeRestart(restart)
[17:41:09.695]                             muffled <- TRUE
[17:41:09.695]                             break
[17:41:09.695]                           }
[17:41:09.695]                         }
[17:41:09.695]                       }
[17:41:09.695]                       invisible(muffled)
[17:41:09.695]                     }
[17:41:09.695]                     muffleCondition(cond, pattern = "^muffle")
[17:41:09.695]                   }
[17:41:09.695]                 }
[17:41:09.695]                 else {
[17:41:09.695]                   if (TRUE) {
[17:41:09.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:09.695]                     {
[17:41:09.695]                       inherits <- base::inherits
[17:41:09.695]                       invokeRestart <- base::invokeRestart
[17:41:09.695]                       is.null <- base::is.null
[17:41:09.695]                       muffled <- FALSE
[17:41:09.695]                       if (inherits(cond, "message")) {
[17:41:09.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:09.695]                         if (muffled) 
[17:41:09.695]                           invokeRestart("muffleMessage")
[17:41:09.695]                       }
[17:41:09.695]                       else if (inherits(cond, "warning")) {
[17:41:09.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:09.695]                         if (muffled) 
[17:41:09.695]                           invokeRestart("muffleWarning")
[17:41:09.695]                       }
[17:41:09.695]                       else if (inherits(cond, "condition")) {
[17:41:09.695]                         if (!is.null(pattern)) {
[17:41:09.695]                           computeRestarts <- base::computeRestarts
[17:41:09.695]                           grepl <- base::grepl
[17:41:09.695]                           restarts <- computeRestarts(cond)
[17:41:09.695]                           for (restart in restarts) {
[17:41:09.695]                             name <- restart$name
[17:41:09.695]                             if (is.null(name)) 
[17:41:09.695]                               next
[17:41:09.695]                             if (!grepl(pattern, name)) 
[17:41:09.695]                               next
[17:41:09.695]                             invokeRestart(restart)
[17:41:09.695]                             muffled <- TRUE
[17:41:09.695]                             break
[17:41:09.695]                           }
[17:41:09.695]                         }
[17:41:09.695]                       }
[17:41:09.695]                       invisible(muffled)
[17:41:09.695]                     }
[17:41:09.695]                     muffleCondition(cond, pattern = "^muffle")
[17:41:09.695]                   }
[17:41:09.695]                 }
[17:41:09.695]             }
[17:41:09.695]         }))
[17:41:09.695]     }, error = function(ex) {
[17:41:09.695]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:09.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:09.695]                 ...future.rng), started = ...future.startTime, 
[17:41:09.695]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:09.695]             version = "1.8"), class = "FutureResult")
[17:41:09.695]     }, finally = {
[17:41:09.695]         if (!identical(...future.workdir, getwd())) 
[17:41:09.695]             setwd(...future.workdir)
[17:41:09.695]         {
[17:41:09.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:09.695]                 ...future.oldOptions$nwarnings <- NULL
[17:41:09.695]             }
[17:41:09.695]             base::options(...future.oldOptions)
[17:41:09.695]             if (.Platform$OS.type == "windows") {
[17:41:09.695]                 old_names <- names(...future.oldEnvVars)
[17:41:09.695]                 envs <- base::Sys.getenv()
[17:41:09.695]                 names <- names(envs)
[17:41:09.695]                 common <- intersect(names, old_names)
[17:41:09.695]                 added <- setdiff(names, old_names)
[17:41:09.695]                 removed <- setdiff(old_names, names)
[17:41:09.695]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:09.695]                   envs[common]]
[17:41:09.695]                 NAMES <- toupper(changed)
[17:41:09.695]                 args <- list()
[17:41:09.695]                 for (kk in seq_along(NAMES)) {
[17:41:09.695]                   name <- changed[[kk]]
[17:41:09.695]                   NAME <- NAMES[[kk]]
[17:41:09.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:09.695]                     next
[17:41:09.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:09.695]                 }
[17:41:09.695]                 NAMES <- toupper(added)
[17:41:09.695]                 for (kk in seq_along(NAMES)) {
[17:41:09.695]                   name <- added[[kk]]
[17:41:09.695]                   NAME <- NAMES[[kk]]
[17:41:09.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:09.695]                     next
[17:41:09.695]                   args[[name]] <- ""
[17:41:09.695]                 }
[17:41:09.695]                 NAMES <- toupper(removed)
[17:41:09.695]                 for (kk in seq_along(NAMES)) {
[17:41:09.695]                   name <- removed[[kk]]
[17:41:09.695]                   NAME <- NAMES[[kk]]
[17:41:09.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:09.695]                     next
[17:41:09.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:09.695]                 }
[17:41:09.695]                 if (length(args) > 0) 
[17:41:09.695]                   base::do.call(base::Sys.setenv, args = args)
[17:41:09.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:09.695]             }
[17:41:09.695]             else {
[17:41:09.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:09.695]             }
[17:41:09.695]             {
[17:41:09.695]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:09.695]                   0L) {
[17:41:09.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:09.695]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:09.695]                   base::options(opts)
[17:41:09.695]                 }
[17:41:09.695]                 {
[17:41:09.695]                   {
[17:41:09.695]                     NULL
[17:41:09.695]                     RNGkind("Mersenne-Twister")
[17:41:09.695]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:09.695]                       inherits = FALSE)
[17:41:09.695]                   }
[17:41:09.695]                   options(future.plan = NULL)
[17:41:09.695]                   if (is.na(NA_character_)) 
[17:41:09.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:09.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:09.695]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:09.695]                     envir = parent.frame()) 
[17:41:09.695]                   {
[17:41:09.695]                     default_workers <- missing(workers)
[17:41:09.695]                     if (is.function(workers)) 
[17:41:09.695]                       workers <- workers()
[17:41:09.695]                     workers <- structure(as.integer(workers), 
[17:41:09.695]                       class = class(workers))
[17:41:09.695]                     stop_if_not(is.finite(workers), workers >= 
[17:41:09.695]                       1L)
[17:41:09.695]                     if ((workers == 1L && !inherits(workers, 
[17:41:09.695]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:09.695]                       if (default_workers) 
[17:41:09.695]                         supportsMulticore(warn = TRUE)
[17:41:09.695]                       return(sequential(..., envir = envir))
[17:41:09.695]                     }
[17:41:09.695]                     oopts <- options(mc.cores = workers)
[17:41:09.695]                     on.exit(options(oopts))
[17:41:09.695]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:09.695]                       envir = envir)
[17:41:09.695]                     if (!future$lazy) 
[17:41:09.695]                       future <- run(future)
[17:41:09.695]                     invisible(future)
[17:41:09.695]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:09.695]                 }
[17:41:09.695]             }
[17:41:09.695]         }
[17:41:09.695]     })
[17:41:09.695]     if (TRUE) {
[17:41:09.695]         base::sink(type = "output", split = FALSE)
[17:41:09.695]         if (TRUE) {
[17:41:09.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:09.695]         }
[17:41:09.695]         else {
[17:41:09.695]             ...future.result["stdout"] <- base::list(NULL)
[17:41:09.695]         }
[17:41:09.695]         base::close(...future.stdout)
[17:41:09.695]         ...future.stdout <- NULL
[17:41:09.695]     }
[17:41:09.695]     ...future.result$conditions <- ...future.conditions
[17:41:09.695]     ...future.result$finished <- base::Sys.time()
[17:41:09.695]     ...future.result
[17:41:09.695] }
[17:41:09.697] assign_globals() ...
[17:41:09.697] List of 5
[17:41:09.697]  $ ...future.FUN            :function (x)  
[17:41:09.697]  $ future.call.arguments    : list()
[17:41:09.697]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:09.697]  $ ...future.elements_ii    :List of 2
[17:41:09.697]   ..$ : int 1
[17:41:09.697]   ..$ : int 0
[17:41:09.697]  $ ...future.seeds_ii       : NULL
[17:41:09.697]  $ ...future.globals.maxSize: NULL
[17:41:09.697]  - attr(*, "resolved")= logi FALSE
[17:41:09.697]  - attr(*, "total_size")= num 4720
[17:41:09.697]  - attr(*, "where")=List of 5
[17:41:09.697]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:09.697]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:09.697]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:09.697]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:09.697]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:09.697]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:09.697]  - attr(*, "already-done")= logi TRUE
[17:41:09.702] - reassign environment for ‘...future.FUN’
[17:41:09.702] - copied ‘...future.FUN’ to environment
[17:41:09.702] - copied ‘future.call.arguments’ to environment
[17:41:09.702] - copied ‘...future.elements_ii’ to environment
[17:41:09.702] - copied ‘...future.seeds_ii’ to environment
[17:41:09.702] - copied ‘...future.globals.maxSize’ to environment
[17:41:09.702] assign_globals() ... done
[17:41:09.703] plan(): Setting new future strategy stack:
[17:41:09.703] List of future strategies:
[17:41:09.703] 1. sequential:
[17:41:09.703]    - args: function (..., envir = parent.frame())
[17:41:09.703]    - tweaked: FALSE
[17:41:09.703]    - call: NULL
[17:41:09.703] plan(): nbrOfWorkers() = 1
[17:41:10.205] plan(): Setting new future strategy stack:
[17:41:10.205] List of future strategies:
[17:41:10.205] 1. multicore:
[17:41:10.205]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:10.205]    - tweaked: FALSE
[17:41:10.205]    - call: plan(strategy)
[17:41:10.209] plan(): nbrOfWorkers() = 1
[17:41:10.210] SequentialFuture started (and completed)
[17:41:10.210] - Launch lazy future ... done
[17:41:10.210] run() for ‘SequentialFuture’ ... done
[17:41:10.210] Created future:
[17:41:10.210] SequentialFuture:
[17:41:10.210] Label: ‘future_lapply-1’
[17:41:10.210] Expression:
[17:41:10.210] {
[17:41:10.210]     do.call(function(...) {
[17:41:10.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:10.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:10.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:10.210]             on.exit(options(oopts), add = TRUE)
[17:41:10.210]         }
[17:41:10.210]         {
[17:41:10.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:10.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:10.210]                 ...future.FUN(...future.X_jj, ...)
[17:41:10.210]             })
[17:41:10.210]         }
[17:41:10.210]     }, args = future.call.arguments)
[17:41:10.210] }
[17:41:10.210] Lazy evaluation: FALSE
[17:41:10.210] Asynchronous evaluation: FALSE
[17:41:10.210] Local evaluation: TRUE
[17:41:10.210] Environment: R_GlobalEnv
[17:41:10.210] Capture standard output: TRUE
[17:41:10.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:10.210] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:10.210] Packages: <none>
[17:41:10.210] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:10.210] Resolved: TRUE
[17:41:10.210] Value: 112 bytes of class ‘list’
[17:41:10.210] Early signaling: FALSE
[17:41:10.210] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:10.210] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:10.211] Chunk #1 of 1 ... DONE
[17:41:10.211] Launching 1 futures (chunks) ... DONE
[17:41:10.212] Resolving 1 futures (chunks) ...
[17:41:10.212] resolve() on list ...
[17:41:10.212]  recursive: 0
[17:41:10.212]  length: 1
[17:41:10.212] 
[17:41:10.212] resolved() for ‘SequentialFuture’ ...
[17:41:10.212] - state: ‘finished’
[17:41:10.212] - run: TRUE
[17:41:10.212] - result: ‘FutureResult’
[17:41:10.212] resolved() for ‘SequentialFuture’ ... done
[17:41:10.213] Future #1
[17:41:10.215] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:10.215] - nx: 1
[17:41:10.215] - relay: TRUE
[17:41:10.215] - stdout: TRUE
[17:41:10.215] - signal: TRUE
[17:41:10.215] - resignal: FALSE
[17:41:10.215] - force: TRUE
[17:41:10.215] - relayed: [n=1] FALSE
[17:41:10.215] - queued futures: [n=1] FALSE
[17:41:10.215]  - until=1
[17:41:10.216]  - relaying element #1
[17:41:10.216] - relayed: [n=1] TRUE
[17:41:10.216] - queued futures: [n=1] TRUE
[17:41:10.216] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:10.216]  length: 0 (resolved future 1)
[17:41:10.216] Relaying remaining futures
[17:41:10.216] signalConditionsASAP(NULL, pos=0) ...
[17:41:10.216] - nx: 1
[17:41:10.216] - relay: TRUE
[17:41:10.216] - stdout: TRUE
[17:41:10.217] - signal: TRUE
[17:41:10.217] - resignal: FALSE
[17:41:10.217] - force: TRUE
[17:41:10.217] - relayed: [n=1] TRUE
[17:41:10.217] - queued futures: [n=1] TRUE
 - flush all
[17:41:10.217] - relayed: [n=1] TRUE
[17:41:10.217] - queued futures: [n=1] TRUE
[17:41:10.217] signalConditionsASAP(NULL, pos=0) ... done
[17:41:10.217] resolve() on list ... DONE
[17:41:10.217]  - Number of value chunks collected: 1
[17:41:10.218] Resolving 1 futures (chunks) ... DONE
[17:41:10.218] Reducing values from 1 chunks ...
[17:41:10.218]  - Number of values collected after concatenation: 2
[17:41:10.218]  - Number of values expected: 2
[17:41:10.218] Reducing values from 1 chunks ... DONE
[17:41:10.218] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:41:10.218] future_lapply() ...
[17:41:10.222] Number of chunks: 1
[17:41:10.222] getGlobalsAndPackagesXApply() ...
[17:41:10.222]  - future.globals: TRUE
[17:41:10.222] getGlobalsAndPackages() ...
[17:41:10.223] Searching for globals...
[17:41:10.224] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:10.224] Searching for globals ... DONE
[17:41:10.224] Resolving globals: FALSE
[17:41:10.224] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:10.225] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:10.225] - globals: [1] ‘FUN’
[17:41:10.225] 
[17:41:10.225] getGlobalsAndPackages() ... DONE
[17:41:10.225]  - globals found/used: [n=1] ‘FUN’
[17:41:10.225]  - needed namespaces: [n=0] 
[17:41:10.225] Finding globals ... DONE
[17:41:10.226]  - use_args: TRUE
[17:41:10.226]  - Getting '...' globals ...
[17:41:10.226] resolve() on list ...
[17:41:10.226]  recursive: 0
[17:41:10.226]  length: 1
[17:41:10.226]  elements: ‘...’
[17:41:10.226]  length: 0 (resolved future 1)
[17:41:10.226] resolve() on list ... DONE
[17:41:10.227]    - '...' content: [n=0] 
[17:41:10.227] List of 1
[17:41:10.227]  $ ...: list()
[17:41:10.227]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:10.227]  - attr(*, "where")=List of 1
[17:41:10.227]   ..$ ...:<environment: 0x55c986852340> 
[17:41:10.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:10.227]  - attr(*, "resolved")= logi TRUE
[17:41:10.227]  - attr(*, "total_size")= num NA
[17:41:10.229]  - Getting '...' globals ... DONE
[17:41:10.229] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:10.229] List of 2
[17:41:10.229]  $ ...future.FUN:function (x)  
[17:41:10.229]  $ ...          : list()
[17:41:10.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:10.229]  - attr(*, "where")=List of 2
[17:41:10.229]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:10.229]   ..$ ...          :<environment: 0x55c986852340> 
[17:41:10.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:10.229]  - attr(*, "resolved")= logi FALSE
[17:41:10.229]  - attr(*, "total_size")= num 4720
[17:41:10.232] Packages to be attached in all futures: [n=0] 
[17:41:10.232] getGlobalsAndPackagesXApply() ... DONE
[17:41:10.232] Number of futures (= number of chunks): 1
[17:41:10.233] Launching 1 futures (chunks) ...
[17:41:10.233] Chunk #1 of 1 ...
[17:41:10.233]  - Finding globals in 'X' for chunk #1 ...
[17:41:10.233] getGlobalsAndPackages() ...
[17:41:10.233] Searching for globals...
[17:41:10.233] 
[17:41:10.233] Searching for globals ... DONE
[17:41:10.233] - globals: [0] <none>
[17:41:10.233] getGlobalsAndPackages() ... DONE
[17:41:10.233]    + additional globals found: [n=0] 
[17:41:10.234]    + additional namespaces needed: [n=0] 
[17:41:10.234]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:10.234]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:10.234]  - seeds: <none>
[17:41:10.234] getGlobalsAndPackages() ...
[17:41:10.234] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:10.234] Resolving globals: FALSE
[17:41:10.234] Tweak future expression to call with '...' arguments ...
[17:41:10.234] {
[17:41:10.234]     do.call(function(...) {
[17:41:10.234]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:10.234]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:10.234]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:10.234]             on.exit(options(oopts), add = TRUE)
[17:41:10.234]         }
[17:41:10.234]         {
[17:41:10.234]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:10.234]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:10.234]                 ...future.FUN(...future.X_jj, ...)
[17:41:10.234]             })
[17:41:10.234]         }
[17:41:10.234]     }, args = future.call.arguments)
[17:41:10.234] }
[17:41:10.235] Tweak future expression to call with '...' arguments ... DONE
[17:41:10.235] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:10.235] 
[17:41:10.235] getGlobalsAndPackages() ... DONE
[17:41:10.236] run() for ‘Future’ ...
[17:41:10.236] - state: ‘created’
[17:41:10.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:10.239] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:10.239] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:10.239]   - Field: ‘label’
[17:41:10.239]   - Field: ‘local’
[17:41:10.240]   - Field: ‘owner’
[17:41:10.240]   - Field: ‘envir’
[17:41:10.240]   - Field: ‘packages’
[17:41:10.240]   - Field: ‘gc’
[17:41:10.240]   - Field: ‘conditions’
[17:41:10.240]   - Field: ‘expr’
[17:41:10.240]   - Field: ‘uuid’
[17:41:10.240]   - Field: ‘seed’
[17:41:10.242]   - Field: ‘version’
[17:41:10.242]   - Field: ‘result’
[17:41:10.242]   - Field: ‘asynchronous’
[17:41:10.242]   - Field: ‘calls’
[17:41:10.242]   - Field: ‘globals’
[17:41:10.242]   - Field: ‘stdout’
[17:41:10.242]   - Field: ‘earlySignal’
[17:41:10.242]   - Field: ‘lazy’
[17:41:10.242]   - Field: ‘state’
[17:41:10.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:10.243] - Launch lazy future ...
[17:41:10.243] Packages needed by the future expression (n = 0): <none>
[17:41:10.243] Packages needed by future strategies (n = 0): <none>
[17:41:10.243] {
[17:41:10.243]     {
[17:41:10.243]         {
[17:41:10.243]             ...future.startTime <- base::Sys.time()
[17:41:10.243]             {
[17:41:10.243]                 {
[17:41:10.243]                   {
[17:41:10.243]                     base::local({
[17:41:10.243]                       has_future <- base::requireNamespace("future", 
[17:41:10.243]                         quietly = TRUE)
[17:41:10.243]                       if (has_future) {
[17:41:10.243]                         ns <- base::getNamespace("future")
[17:41:10.243]                         version <- ns[[".package"]][["version"]]
[17:41:10.243]                         if (is.null(version)) 
[17:41:10.243]                           version <- utils::packageVersion("future")
[17:41:10.243]                       }
[17:41:10.243]                       else {
[17:41:10.243]                         version <- NULL
[17:41:10.243]                       }
[17:41:10.243]                       if (!has_future || version < "1.8.0") {
[17:41:10.243]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:10.243]                           "", base::R.version$version.string), 
[17:41:10.243]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:10.243]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:10.243]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:10.243]                             "release", "version")], collapse = " "), 
[17:41:10.243]                           hostname = base::Sys.info()[["nodename"]])
[17:41:10.243]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:10.243]                           info)
[17:41:10.243]                         info <- base::paste(info, collapse = "; ")
[17:41:10.243]                         if (!has_future) {
[17:41:10.243]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:10.243]                             info)
[17:41:10.243]                         }
[17:41:10.243]                         else {
[17:41:10.243]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:10.243]                             info, version)
[17:41:10.243]                         }
[17:41:10.243]                         base::stop(msg)
[17:41:10.243]                       }
[17:41:10.243]                     })
[17:41:10.243]                   }
[17:41:10.243]                   options(future.plan = NULL)
[17:41:10.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:10.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:10.243]                 }
[17:41:10.243]                 ...future.workdir <- getwd()
[17:41:10.243]             }
[17:41:10.243]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:10.243]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:10.243]         }
[17:41:10.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:10.243]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:10.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:10.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:10.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:10.243]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:10.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:10.243]             base::names(...future.oldOptions))
[17:41:10.243]     }
[17:41:10.243]     if (TRUE) {
[17:41:10.243]     }
[17:41:10.243]     else {
[17:41:10.243]         if (NA) {
[17:41:10.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:10.243]                 open = "w")
[17:41:10.243]         }
[17:41:10.243]         else {
[17:41:10.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:10.243]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:10.243]         }
[17:41:10.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:10.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:10.243]             base::sink(type = "output", split = FALSE)
[17:41:10.243]             base::close(...future.stdout)
[17:41:10.243]         }, add = TRUE)
[17:41:10.243]     }
[17:41:10.243]     ...future.frame <- base::sys.nframe()
[17:41:10.243]     ...future.conditions <- base::list()
[17:41:10.243]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:10.243]     if (FALSE) {
[17:41:10.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:10.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:10.243]     }
[17:41:10.243]     ...future.result <- base::tryCatch({
[17:41:10.243]         base::withCallingHandlers({
[17:41:10.243]             ...future.value <- base::withVisible(base::local({
[17:41:10.243]                 do.call(function(...) {
[17:41:10.243]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:10.243]                   if (!identical(...future.globals.maxSize.org, 
[17:41:10.243]                     ...future.globals.maxSize)) {
[17:41:10.243]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:10.243]                     on.exit(options(oopts), add = TRUE)
[17:41:10.243]                   }
[17:41:10.243]                   {
[17:41:10.243]                     lapply(seq_along(...future.elements_ii), 
[17:41:10.243]                       FUN = function(jj) {
[17:41:10.243]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:10.243]                         ...future.FUN(...future.X_jj, ...)
[17:41:10.243]                       })
[17:41:10.243]                   }
[17:41:10.243]                 }, args = future.call.arguments)
[17:41:10.243]             }))
[17:41:10.243]             future::FutureResult(value = ...future.value$value, 
[17:41:10.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:10.243]                   ...future.rng), globalenv = if (FALSE) 
[17:41:10.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:10.243]                     ...future.globalenv.names))
[17:41:10.243]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:10.243]         }, condition = base::local({
[17:41:10.243]             c <- base::c
[17:41:10.243]             inherits <- base::inherits
[17:41:10.243]             invokeRestart <- base::invokeRestart
[17:41:10.243]             length <- base::length
[17:41:10.243]             list <- base::list
[17:41:10.243]             seq.int <- base::seq.int
[17:41:10.243]             signalCondition <- base::signalCondition
[17:41:10.243]             sys.calls <- base::sys.calls
[17:41:10.243]             `[[` <- base::`[[`
[17:41:10.243]             `+` <- base::`+`
[17:41:10.243]             `<<-` <- base::`<<-`
[17:41:10.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:10.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:10.243]                   3L)]
[17:41:10.243]             }
[17:41:10.243]             function(cond) {
[17:41:10.243]                 is_error <- inherits(cond, "error")
[17:41:10.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:10.243]                   NULL)
[17:41:10.243]                 if (is_error) {
[17:41:10.243]                   sessionInformation <- function() {
[17:41:10.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:10.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:10.243]                       search = base::search(), system = base::Sys.info())
[17:41:10.243]                   }
[17:41:10.243]                   ...future.conditions[[length(...future.conditions) + 
[17:41:10.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:10.243]                     cond$call), session = sessionInformation(), 
[17:41:10.243]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:10.243]                   signalCondition(cond)
[17:41:10.243]                 }
[17:41:10.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:10.243]                 "immediateCondition"))) {
[17:41:10.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:10.243]                   ...future.conditions[[length(...future.conditions) + 
[17:41:10.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:10.243]                   if (TRUE && !signal) {
[17:41:10.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:10.243]                     {
[17:41:10.243]                       inherits <- base::inherits
[17:41:10.243]                       invokeRestart <- base::invokeRestart
[17:41:10.243]                       is.null <- base::is.null
[17:41:10.243]                       muffled <- FALSE
[17:41:10.243]                       if (inherits(cond, "message")) {
[17:41:10.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:10.243]                         if (muffled) 
[17:41:10.243]                           invokeRestart("muffleMessage")
[17:41:10.243]                       }
[17:41:10.243]                       else if (inherits(cond, "warning")) {
[17:41:10.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:10.243]                         if (muffled) 
[17:41:10.243]                           invokeRestart("muffleWarning")
[17:41:10.243]                       }
[17:41:10.243]                       else if (inherits(cond, "condition")) {
[17:41:10.243]                         if (!is.null(pattern)) {
[17:41:10.243]                           computeRestarts <- base::computeRestarts
[17:41:10.243]                           grepl <- base::grepl
[17:41:10.243]                           restarts <- computeRestarts(cond)
[17:41:10.243]                           for (restart in restarts) {
[17:41:10.243]                             name <- restart$name
[17:41:10.243]                             if (is.null(name)) 
[17:41:10.243]                               next
[17:41:10.243]                             if (!grepl(pattern, name)) 
[17:41:10.243]                               next
[17:41:10.243]                             invokeRestart(restart)
[17:41:10.243]                             muffled <- TRUE
[17:41:10.243]                             break
[17:41:10.243]                           }
[17:41:10.243]                         }
[17:41:10.243]                       }
[17:41:10.243]                       invisible(muffled)
[17:41:10.243]                     }
[17:41:10.243]                     muffleCondition(cond, pattern = "^muffle")
[17:41:10.243]                   }
[17:41:10.243]                 }
[17:41:10.243]                 else {
[17:41:10.243]                   if (TRUE) {
[17:41:10.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:10.243]                     {
[17:41:10.243]                       inherits <- base::inherits
[17:41:10.243]                       invokeRestart <- base::invokeRestart
[17:41:10.243]                       is.null <- base::is.null
[17:41:10.243]                       muffled <- FALSE
[17:41:10.243]                       if (inherits(cond, "message")) {
[17:41:10.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:10.243]                         if (muffled) 
[17:41:10.243]                           invokeRestart("muffleMessage")
[17:41:10.243]                       }
[17:41:10.243]                       else if (inherits(cond, "warning")) {
[17:41:10.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:10.243]                         if (muffled) 
[17:41:10.243]                           invokeRestart("muffleWarning")
[17:41:10.243]                       }
[17:41:10.243]                       else if (inherits(cond, "condition")) {
[17:41:10.243]                         if (!is.null(pattern)) {
[17:41:10.243]                           computeRestarts <- base::computeRestarts
[17:41:10.243]                           grepl <- base::grepl
[17:41:10.243]                           restarts <- computeRestarts(cond)
[17:41:10.243]                           for (restart in restarts) {
[17:41:10.243]                             name <- restart$name
[17:41:10.243]                             if (is.null(name)) 
[17:41:10.243]                               next
[17:41:10.243]                             if (!grepl(pattern, name)) 
[17:41:10.243]                               next
[17:41:10.243]                             invokeRestart(restart)
[17:41:10.243]                             muffled <- TRUE
[17:41:10.243]                             break
[17:41:10.243]                           }
[17:41:10.243]                         }
[17:41:10.243]                       }
[17:41:10.243]                       invisible(muffled)
[17:41:10.243]                     }
[17:41:10.243]                     muffleCondition(cond, pattern = "^muffle")
[17:41:10.243]                   }
[17:41:10.243]                 }
[17:41:10.243]             }
[17:41:10.243]         }))
[17:41:10.243]     }, error = function(ex) {
[17:41:10.243]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:10.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:10.243]                 ...future.rng), started = ...future.startTime, 
[17:41:10.243]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:10.243]             version = "1.8"), class = "FutureResult")
[17:41:10.243]     }, finally = {
[17:41:10.243]         if (!identical(...future.workdir, getwd())) 
[17:41:10.243]             setwd(...future.workdir)
[17:41:10.243]         {
[17:41:10.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:10.243]                 ...future.oldOptions$nwarnings <- NULL
[17:41:10.243]             }
[17:41:10.243]             base::options(...future.oldOptions)
[17:41:10.243]             if (.Platform$OS.type == "windows") {
[17:41:10.243]                 old_names <- names(...future.oldEnvVars)
[17:41:10.243]                 envs <- base::Sys.getenv()
[17:41:10.243]                 names <- names(envs)
[17:41:10.243]                 common <- intersect(names, old_names)
[17:41:10.243]                 added <- setdiff(names, old_names)
[17:41:10.243]                 removed <- setdiff(old_names, names)
[17:41:10.243]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:10.243]                   envs[common]]
[17:41:10.243]                 NAMES <- toupper(changed)
[17:41:10.243]                 args <- list()
[17:41:10.243]                 for (kk in seq_along(NAMES)) {
[17:41:10.243]                   name <- changed[[kk]]
[17:41:10.243]                   NAME <- NAMES[[kk]]
[17:41:10.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:10.243]                     next
[17:41:10.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:10.243]                 }
[17:41:10.243]                 NAMES <- toupper(added)
[17:41:10.243]                 for (kk in seq_along(NAMES)) {
[17:41:10.243]                   name <- added[[kk]]
[17:41:10.243]                   NAME <- NAMES[[kk]]
[17:41:10.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:10.243]                     next
[17:41:10.243]                   args[[name]] <- ""
[17:41:10.243]                 }
[17:41:10.243]                 NAMES <- toupper(removed)
[17:41:10.243]                 for (kk in seq_along(NAMES)) {
[17:41:10.243]                   name <- removed[[kk]]
[17:41:10.243]                   NAME <- NAMES[[kk]]
[17:41:10.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:10.243]                     next
[17:41:10.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:10.243]                 }
[17:41:10.243]                 if (length(args) > 0) 
[17:41:10.243]                   base::do.call(base::Sys.setenv, args = args)
[17:41:10.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:10.243]             }
[17:41:10.243]             else {
[17:41:10.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:10.243]             }
[17:41:10.243]             {
[17:41:10.243]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:10.243]                   0L) {
[17:41:10.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:10.243]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:10.243]                   base::options(opts)
[17:41:10.243]                 }
[17:41:10.243]                 {
[17:41:10.243]                   {
[17:41:10.243]                     NULL
[17:41:10.243]                     RNGkind("Mersenne-Twister")
[17:41:10.243]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:10.243]                       inherits = FALSE)
[17:41:10.243]                   }
[17:41:10.243]                   options(future.plan = NULL)
[17:41:10.243]                   if (is.na(NA_character_)) 
[17:41:10.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:10.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:10.243]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:10.243]                     envir = parent.frame()) 
[17:41:10.243]                   {
[17:41:10.243]                     default_workers <- missing(workers)
[17:41:10.243]                     if (is.function(workers)) 
[17:41:10.243]                       workers <- workers()
[17:41:10.243]                     workers <- structure(as.integer(workers), 
[17:41:10.243]                       class = class(workers))
[17:41:10.243]                     stop_if_not(is.finite(workers), workers >= 
[17:41:10.243]                       1L)
[17:41:10.243]                     if ((workers == 1L && !inherits(workers, 
[17:41:10.243]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:10.243]                       if (default_workers) 
[17:41:10.243]                         supportsMulticore(warn = TRUE)
[17:41:10.243]                       return(sequential(..., envir = envir))
[17:41:10.243]                     }
[17:41:10.243]                     oopts <- options(mc.cores = workers)
[17:41:10.243]                     on.exit(options(oopts))
[17:41:10.243]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:10.243]                       envir = envir)
[17:41:10.243]                     if (!future$lazy) 
[17:41:10.243]                       future <- run(future)
[17:41:10.243]                     invisible(future)
[17:41:10.243]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:10.243]                 }
[17:41:10.243]             }
[17:41:10.243]         }
[17:41:10.243]     })
[17:41:10.243]     if (FALSE) {
[17:41:10.243]         base::sink(type = "output", split = FALSE)
[17:41:10.243]         if (NA) {
[17:41:10.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:10.243]         }
[17:41:10.243]         else {
[17:41:10.243]             ...future.result["stdout"] <- base::list(NULL)
[17:41:10.243]         }
[17:41:10.243]         base::close(...future.stdout)
[17:41:10.243]         ...future.stdout <- NULL
[17:41:10.243]     }
[17:41:10.243]     ...future.result$conditions <- ...future.conditions
[17:41:10.243]     ...future.result$finished <- base::Sys.time()
[17:41:10.243]     ...future.result
[17:41:10.243] }
[17:41:10.245] assign_globals() ...
[17:41:10.245] List of 5
[17:41:10.245]  $ ...future.FUN            :function (x)  
[17:41:10.245]  $ future.call.arguments    : list()
[17:41:10.245]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:10.245]  $ ...future.elements_ii    :List of 2
[17:41:10.245]   ..$ : int 1
[17:41:10.245]   ..$ : int 0
[17:41:10.245]  $ ...future.seeds_ii       : NULL
[17:41:10.245]  $ ...future.globals.maxSize: NULL
[17:41:10.245]  - attr(*, "resolved")= logi FALSE
[17:41:10.245]  - attr(*, "total_size")= num 4720
[17:41:10.245]  - attr(*, "where")=List of 5
[17:41:10.245]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:10.245]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:10.245]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:10.245]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:10.245]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:10.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:10.245]  - attr(*, "already-done")= logi TRUE
[17:41:10.250] - reassign environment for ‘...future.FUN’
[17:41:10.250] - copied ‘...future.FUN’ to environment
[17:41:10.250] - copied ‘future.call.arguments’ to environment
[17:41:10.250] - copied ‘...future.elements_ii’ to environment
[17:41:10.250] - copied ‘...future.seeds_ii’ to environment
[17:41:10.250] - copied ‘...future.globals.maxSize’ to environment
[17:41:10.250] assign_globals() ... done
[17:41:10.251] plan(): Setting new future strategy stack:
[17:41:10.251] List of future strategies:
[17:41:10.251] 1. sequential:
[17:41:10.251]    - args: function (..., envir = parent.frame())
[17:41:10.251]    - tweaked: FALSE
[17:41:10.251]    - call: NULL
[17:41:10.251] plan(): nbrOfWorkers() = 1
[17:41:10.753] plan(): Setting new future strategy stack:
[17:41:10.753] List of future strategies:
[17:41:10.753] 1. multicore:
[17:41:10.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:10.753]    - tweaked: FALSE
[17:41:10.753]    - call: plan(strategy)
[17:41:10.757] plan(): nbrOfWorkers() = 1
[17:41:10.757] SequentialFuture started (and completed)
[17:41:10.758] - Launch lazy future ... done
[17:41:10.758] run() for ‘SequentialFuture’ ... done
[17:41:10.758] Created future:
[17:41:10.758] SequentialFuture:
[17:41:10.758] Label: ‘future_lapply-1’
[17:41:10.758] Expression:
[17:41:10.758] {
[17:41:10.758]     do.call(function(...) {
[17:41:10.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:10.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:10.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:10.758]             on.exit(options(oopts), add = TRUE)
[17:41:10.758]         }
[17:41:10.758]         {
[17:41:10.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:10.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:10.758]                 ...future.FUN(...future.X_jj, ...)
[17:41:10.758]             })
[17:41:10.758]         }
[17:41:10.758]     }, args = future.call.arguments)
[17:41:10.758] }
[17:41:10.758] Lazy evaluation: FALSE
[17:41:10.758] Asynchronous evaluation: FALSE
[17:41:10.758] Local evaluation: TRUE
[17:41:10.758] Environment: R_GlobalEnv
[17:41:10.758] Capture standard output: NA
[17:41:10.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:10.758] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:10.758] Packages: <none>
[17:41:10.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:10.758] Resolved: TRUE
[17:41:10.758] Value: 112 bytes of class ‘list’
[17:41:10.758] Early signaling: FALSE
[17:41:10.758] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:10.758] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:10.759] Chunk #1 of 1 ... DONE
[17:41:10.759] Launching 1 futures (chunks) ... DONE
[17:41:10.760] Resolving 1 futures (chunks) ...
[17:41:10.760] resolve() on list ...
[17:41:10.760]  recursive: 0
[17:41:10.760]  length: 1
[17:41:10.760] 
[17:41:10.760] resolved() for ‘SequentialFuture’ ...
[17:41:10.760] - state: ‘finished’
[17:41:10.760] - run: TRUE
[17:41:10.760] - result: ‘FutureResult’
[17:41:10.760] resolved() for ‘SequentialFuture’ ... done
[17:41:10.761] Future #1
[17:41:10.761] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:10.761] - nx: 1
[17:41:10.761] - relay: TRUE
[17:41:10.761] - stdout: TRUE
[17:41:10.761] - signal: TRUE
[17:41:10.761] - resignal: FALSE
[17:41:10.761] - force: TRUE
[17:41:10.761] - relayed: [n=1] FALSE
[17:41:10.761] - queued futures: [n=1] FALSE
[17:41:10.762]  - until=1
[17:41:10.762]  - relaying element #1
[17:41:10.762] - relayed: [n=1] TRUE
[17:41:10.762] - queued futures: [n=1] TRUE
[17:41:10.762] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:10.762]  length: 0 (resolved future 1)
[17:41:10.762] Relaying remaining futures
[17:41:10.762] signalConditionsASAP(NULL, pos=0) ...
[17:41:10.762] - nx: 1
[17:41:10.762] - relay: TRUE
[17:41:10.763] - stdout: TRUE
[17:41:10.763] - signal: TRUE
[17:41:10.763] - resignal: FALSE
[17:41:10.763] - force: TRUE
[17:41:10.763] - relayed: [n=1] TRUE
[17:41:10.763] - queued futures: [n=1] TRUE
 - flush all
[17:41:10.763] - relayed: [n=1] TRUE
[17:41:10.763] - queued futures: [n=1] TRUE
[17:41:10.763] signalConditionsASAP(NULL, pos=0) ... done
[17:41:10.763] resolve() on list ... DONE
[17:41:10.764]  - Number of value chunks collected: 1
[17:41:10.764] Resolving 1 futures (chunks) ... DONE
[17:41:10.764] Reducing values from 1 chunks ...
[17:41:10.764]  - Number of values collected after concatenation: 2
[17:41:10.764]  - Number of values expected: 2
[17:41:10.764] Reducing values from 1 chunks ... DONE
[17:41:10.764] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:41:10.764] future_mapply() ...
[17:41:10.768] Number of chunks: 1
[17:41:10.768] getGlobalsAndPackagesXApply() ...
[17:41:10.768]  - future.globals: TRUE
[17:41:10.768] getGlobalsAndPackages() ...
[17:41:10.768] Searching for globals...
[17:41:10.770] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:10.770] Searching for globals ... DONE
[17:41:10.770] Resolving globals: FALSE
[17:41:10.770] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:10.771] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:10.771] - globals: [1] ‘FUN’
[17:41:10.771] 
[17:41:10.771] getGlobalsAndPackages() ... DONE
[17:41:10.771]  - globals found/used: [n=1] ‘FUN’
[17:41:10.771]  - needed namespaces: [n=0] 
[17:41:10.771] Finding globals ... DONE
[17:41:10.773] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:10.773] List of 2
[17:41:10.773]  $ ...future.FUN:function (x, y)  
[17:41:10.773]  $ MoreArgs     : NULL
[17:41:10.773]  - attr(*, "where")=List of 2
[17:41:10.773]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:10.773]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:10.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:10.773]  - attr(*, "resolved")= logi FALSE
[17:41:10.773]  - attr(*, "total_size")= num NA
[17:41:10.776] Packages to be attached in all futures: [n=0] 
[17:41:10.776] getGlobalsAndPackagesXApply() ... DONE
[17:41:10.776] Number of futures (= number of chunks): 1
[17:41:10.776] Launching 1 futures (chunks) ...
[17:41:10.776] Chunk #1 of 1 ...
[17:41:10.777]  - Finding globals in '...' for chunk #1 ...
[17:41:10.777] getGlobalsAndPackages() ...
[17:41:10.777] Searching for globals...
[17:41:10.777] 
[17:41:10.777] Searching for globals ... DONE
[17:41:10.777] - globals: [0] <none>
[17:41:10.777] getGlobalsAndPackages() ... DONE
[17:41:10.777]    + additional globals found: [n=0] 
[17:41:10.778]    + additional namespaces needed: [n=0] 
[17:41:10.778]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:10.778]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:10.778]  - seeds: <none>
[17:41:10.778] getGlobalsAndPackages() ...
[17:41:10.778] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:10.778] Resolving globals: FALSE
[17:41:10.779] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:10.779] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:10.779] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:10.779] 
[17:41:10.779] getGlobalsAndPackages() ... DONE
[17:41:10.780] run() for ‘Future’ ...
[17:41:10.780] - state: ‘created’
[17:41:10.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:10.783] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:10.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:10.783]   - Field: ‘label’
[17:41:10.784]   - Field: ‘local’
[17:41:10.784]   - Field: ‘owner’
[17:41:10.784]   - Field: ‘envir’
[17:41:10.784]   - Field: ‘packages’
[17:41:10.784]   - Field: ‘gc’
[17:41:10.784]   - Field: ‘conditions’
[17:41:10.784]   - Field: ‘expr’
[17:41:10.784]   - Field: ‘uuid’
[17:41:10.784]   - Field: ‘seed’
[17:41:10.784]   - Field: ‘version’
[17:41:10.784]   - Field: ‘result’
[17:41:10.785]   - Field: ‘asynchronous’
[17:41:10.785]   - Field: ‘calls’
[17:41:10.785]   - Field: ‘globals’
[17:41:10.785]   - Field: ‘stdout’
[17:41:10.785]   - Field: ‘earlySignal’
[17:41:10.785]   - Field: ‘lazy’
[17:41:10.785]   - Field: ‘state’
[17:41:10.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:10.785] - Launch lazy future ...
[17:41:10.785] Packages needed by the future expression (n = 0): <none>
[17:41:10.786] Packages needed by future strategies (n = 0): <none>
[17:41:10.786] {
[17:41:10.786]     {
[17:41:10.786]         {
[17:41:10.786]             ...future.startTime <- base::Sys.time()
[17:41:10.786]             {
[17:41:10.786]                 {
[17:41:10.786]                   {
[17:41:10.786]                     base::local({
[17:41:10.786]                       has_future <- base::requireNamespace("future", 
[17:41:10.786]                         quietly = TRUE)
[17:41:10.786]                       if (has_future) {
[17:41:10.786]                         ns <- base::getNamespace("future")
[17:41:10.786]                         version <- ns[[".package"]][["version"]]
[17:41:10.786]                         if (is.null(version)) 
[17:41:10.786]                           version <- utils::packageVersion("future")
[17:41:10.786]                       }
[17:41:10.786]                       else {
[17:41:10.786]                         version <- NULL
[17:41:10.786]                       }
[17:41:10.786]                       if (!has_future || version < "1.8.0") {
[17:41:10.786]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:10.786]                           "", base::R.version$version.string), 
[17:41:10.786]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:10.786]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:10.786]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:10.786]                             "release", "version")], collapse = " "), 
[17:41:10.786]                           hostname = base::Sys.info()[["nodename"]])
[17:41:10.786]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:10.786]                           info)
[17:41:10.786]                         info <- base::paste(info, collapse = "; ")
[17:41:10.786]                         if (!has_future) {
[17:41:10.786]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:10.786]                             info)
[17:41:10.786]                         }
[17:41:10.786]                         else {
[17:41:10.786]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:10.786]                             info, version)
[17:41:10.786]                         }
[17:41:10.786]                         base::stop(msg)
[17:41:10.786]                       }
[17:41:10.786]                     })
[17:41:10.786]                   }
[17:41:10.786]                   options(future.plan = NULL)
[17:41:10.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:10.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:10.786]                 }
[17:41:10.786]                 ...future.workdir <- getwd()
[17:41:10.786]             }
[17:41:10.786]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:10.786]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:10.786]         }
[17:41:10.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:10.786]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:10.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:10.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:10.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:10.786]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:10.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:10.786]             base::names(...future.oldOptions))
[17:41:10.786]     }
[17:41:10.786]     if (FALSE) {
[17:41:10.786]     }
[17:41:10.786]     else {
[17:41:10.786]         if (FALSE) {
[17:41:10.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:10.786]                 open = "w")
[17:41:10.786]         }
[17:41:10.786]         else {
[17:41:10.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:10.786]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:10.786]         }
[17:41:10.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:10.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:10.786]             base::sink(type = "output", split = FALSE)
[17:41:10.786]             base::close(...future.stdout)
[17:41:10.786]         }, add = TRUE)
[17:41:10.786]     }
[17:41:10.786]     ...future.frame <- base::sys.nframe()
[17:41:10.786]     ...future.conditions <- base::list()
[17:41:10.786]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:10.786]     if (FALSE) {
[17:41:10.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:10.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:10.786]     }
[17:41:10.786]     ...future.result <- base::tryCatch({
[17:41:10.786]         base::withCallingHandlers({
[17:41:10.786]             ...future.value <- base::withVisible(base::local({
[17:41:10.786]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:10.786]                 if (!identical(...future.globals.maxSize.org, 
[17:41:10.786]                   ...future.globals.maxSize)) {
[17:41:10.786]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:10.786]                   on.exit(options(oopts), add = TRUE)
[17:41:10.786]                 }
[17:41:10.786]                 {
[17:41:10.786]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:10.786]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:10.786]                     USE.NAMES = FALSE)
[17:41:10.786]                   do.call(mapply, args = args)
[17:41:10.786]                 }
[17:41:10.786]             }))
[17:41:10.786]             future::FutureResult(value = ...future.value$value, 
[17:41:10.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:10.786]                   ...future.rng), globalenv = if (FALSE) 
[17:41:10.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:10.786]                     ...future.globalenv.names))
[17:41:10.786]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:10.786]         }, condition = base::local({
[17:41:10.786]             c <- base::c
[17:41:10.786]             inherits <- base::inherits
[17:41:10.786]             invokeRestart <- base::invokeRestart
[17:41:10.786]             length <- base::length
[17:41:10.786]             list <- base::list
[17:41:10.786]             seq.int <- base::seq.int
[17:41:10.786]             signalCondition <- base::signalCondition
[17:41:10.786]             sys.calls <- base::sys.calls
[17:41:10.786]             `[[` <- base::`[[`
[17:41:10.786]             `+` <- base::`+`
[17:41:10.786]             `<<-` <- base::`<<-`
[17:41:10.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:10.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:10.786]                   3L)]
[17:41:10.786]             }
[17:41:10.786]             function(cond) {
[17:41:10.786]                 is_error <- inherits(cond, "error")
[17:41:10.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:10.786]                   NULL)
[17:41:10.786]                 if (is_error) {
[17:41:10.786]                   sessionInformation <- function() {
[17:41:10.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:10.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:10.786]                       search = base::search(), system = base::Sys.info())
[17:41:10.786]                   }
[17:41:10.786]                   ...future.conditions[[length(...future.conditions) + 
[17:41:10.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:10.786]                     cond$call), session = sessionInformation(), 
[17:41:10.786]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:10.786]                   signalCondition(cond)
[17:41:10.786]                 }
[17:41:10.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:10.786]                 "immediateCondition"))) {
[17:41:10.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:10.786]                   ...future.conditions[[length(...future.conditions) + 
[17:41:10.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:10.786]                   if (TRUE && !signal) {
[17:41:10.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:10.786]                     {
[17:41:10.786]                       inherits <- base::inherits
[17:41:10.786]                       invokeRestart <- base::invokeRestart
[17:41:10.786]                       is.null <- base::is.null
[17:41:10.786]                       muffled <- FALSE
[17:41:10.786]                       if (inherits(cond, "message")) {
[17:41:10.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:10.786]                         if (muffled) 
[17:41:10.786]                           invokeRestart("muffleMessage")
[17:41:10.786]                       }
[17:41:10.786]                       else if (inherits(cond, "warning")) {
[17:41:10.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:10.786]                         if (muffled) 
[17:41:10.786]                           invokeRestart("muffleWarning")
[17:41:10.786]                       }
[17:41:10.786]                       else if (inherits(cond, "condition")) {
[17:41:10.786]                         if (!is.null(pattern)) {
[17:41:10.786]                           computeRestarts <- base::computeRestarts
[17:41:10.786]                           grepl <- base::grepl
[17:41:10.786]                           restarts <- computeRestarts(cond)
[17:41:10.786]                           for (restart in restarts) {
[17:41:10.786]                             name <- restart$name
[17:41:10.786]                             if (is.null(name)) 
[17:41:10.786]                               next
[17:41:10.786]                             if (!grepl(pattern, name)) 
[17:41:10.786]                               next
[17:41:10.786]                             invokeRestart(restart)
[17:41:10.786]                             muffled <- TRUE
[17:41:10.786]                             break
[17:41:10.786]                           }
[17:41:10.786]                         }
[17:41:10.786]                       }
[17:41:10.786]                       invisible(muffled)
[17:41:10.786]                     }
[17:41:10.786]                     muffleCondition(cond, pattern = "^muffle")
[17:41:10.786]                   }
[17:41:10.786]                 }
[17:41:10.786]                 else {
[17:41:10.786]                   if (TRUE) {
[17:41:10.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:10.786]                     {
[17:41:10.786]                       inherits <- base::inherits
[17:41:10.786]                       invokeRestart <- base::invokeRestart
[17:41:10.786]                       is.null <- base::is.null
[17:41:10.786]                       muffled <- FALSE
[17:41:10.786]                       if (inherits(cond, "message")) {
[17:41:10.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:10.786]                         if (muffled) 
[17:41:10.786]                           invokeRestart("muffleMessage")
[17:41:10.786]                       }
[17:41:10.786]                       else if (inherits(cond, "warning")) {
[17:41:10.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:10.786]                         if (muffled) 
[17:41:10.786]                           invokeRestart("muffleWarning")
[17:41:10.786]                       }
[17:41:10.786]                       else if (inherits(cond, "condition")) {
[17:41:10.786]                         if (!is.null(pattern)) {
[17:41:10.786]                           computeRestarts <- base::computeRestarts
[17:41:10.786]                           grepl <- base::grepl
[17:41:10.786]                           restarts <- computeRestarts(cond)
[17:41:10.786]                           for (restart in restarts) {
[17:41:10.786]                             name <- restart$name
[17:41:10.786]                             if (is.null(name)) 
[17:41:10.786]                               next
[17:41:10.786]                             if (!grepl(pattern, name)) 
[17:41:10.786]                               next
[17:41:10.786]                             invokeRestart(restart)
[17:41:10.786]                             muffled <- TRUE
[17:41:10.786]                             break
[17:41:10.786]                           }
[17:41:10.786]                         }
[17:41:10.786]                       }
[17:41:10.786]                       invisible(muffled)
[17:41:10.786]                     }
[17:41:10.786]                     muffleCondition(cond, pattern = "^muffle")
[17:41:10.786]                   }
[17:41:10.786]                 }
[17:41:10.786]             }
[17:41:10.786]         }))
[17:41:10.786]     }, error = function(ex) {
[17:41:10.786]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:10.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:10.786]                 ...future.rng), started = ...future.startTime, 
[17:41:10.786]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:10.786]             version = "1.8"), class = "FutureResult")
[17:41:10.786]     }, finally = {
[17:41:10.786]         if (!identical(...future.workdir, getwd())) 
[17:41:10.786]             setwd(...future.workdir)
[17:41:10.786]         {
[17:41:10.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:10.786]                 ...future.oldOptions$nwarnings <- NULL
[17:41:10.786]             }
[17:41:10.786]             base::options(...future.oldOptions)
[17:41:10.786]             if (.Platform$OS.type == "windows") {
[17:41:10.786]                 old_names <- names(...future.oldEnvVars)
[17:41:10.786]                 envs <- base::Sys.getenv()
[17:41:10.786]                 names <- names(envs)
[17:41:10.786]                 common <- intersect(names, old_names)
[17:41:10.786]                 added <- setdiff(names, old_names)
[17:41:10.786]                 removed <- setdiff(old_names, names)
[17:41:10.786]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:10.786]                   envs[common]]
[17:41:10.786]                 NAMES <- toupper(changed)
[17:41:10.786]                 args <- list()
[17:41:10.786]                 for (kk in seq_along(NAMES)) {
[17:41:10.786]                   name <- changed[[kk]]
[17:41:10.786]                   NAME <- NAMES[[kk]]
[17:41:10.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:10.786]                     next
[17:41:10.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:10.786]                 }
[17:41:10.786]                 NAMES <- toupper(added)
[17:41:10.786]                 for (kk in seq_along(NAMES)) {
[17:41:10.786]                   name <- added[[kk]]
[17:41:10.786]                   NAME <- NAMES[[kk]]
[17:41:10.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:10.786]                     next
[17:41:10.786]                   args[[name]] <- ""
[17:41:10.786]                 }
[17:41:10.786]                 NAMES <- toupper(removed)
[17:41:10.786]                 for (kk in seq_along(NAMES)) {
[17:41:10.786]                   name <- removed[[kk]]
[17:41:10.786]                   NAME <- NAMES[[kk]]
[17:41:10.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:10.786]                     next
[17:41:10.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:10.786]                 }
[17:41:10.786]                 if (length(args) > 0) 
[17:41:10.786]                   base::do.call(base::Sys.setenv, args = args)
[17:41:10.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:10.786]             }
[17:41:10.786]             else {
[17:41:10.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:10.786]             }
[17:41:10.786]             {
[17:41:10.786]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:10.786]                   0L) {
[17:41:10.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:10.786]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:10.786]                   base::options(opts)
[17:41:10.786]                 }
[17:41:10.786]                 {
[17:41:10.786]                   {
[17:41:10.786]                     NULL
[17:41:10.786]                     RNGkind("Mersenne-Twister")
[17:41:10.786]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:10.786]                       inherits = FALSE)
[17:41:10.786]                   }
[17:41:10.786]                   options(future.plan = NULL)
[17:41:10.786]                   if (is.na(NA_character_)) 
[17:41:10.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:10.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:10.786]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:10.786]                     envir = parent.frame()) 
[17:41:10.786]                   {
[17:41:10.786]                     default_workers <- missing(workers)
[17:41:10.786]                     if (is.function(workers)) 
[17:41:10.786]                       workers <- workers()
[17:41:10.786]                     workers <- structure(as.integer(workers), 
[17:41:10.786]                       class = class(workers))
[17:41:10.786]                     stop_if_not(is.finite(workers), workers >= 
[17:41:10.786]                       1L)
[17:41:10.786]                     if ((workers == 1L && !inherits(workers, 
[17:41:10.786]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:10.786]                       if (default_workers) 
[17:41:10.786]                         supportsMulticore(warn = TRUE)
[17:41:10.786]                       return(sequential(..., envir = envir))
[17:41:10.786]                     }
[17:41:10.786]                     oopts <- options(mc.cores = workers)
[17:41:10.786]                     on.exit(options(oopts))
[17:41:10.786]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:10.786]                       envir = envir)
[17:41:10.786]                     if (!future$lazy) 
[17:41:10.786]                       future <- run(future)
[17:41:10.786]                     invisible(future)
[17:41:10.786]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:10.786]                 }
[17:41:10.786]             }
[17:41:10.786]         }
[17:41:10.786]     })
[17:41:10.786]     if (TRUE) {
[17:41:10.786]         base::sink(type = "output", split = FALSE)
[17:41:10.786]         if (FALSE) {
[17:41:10.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:10.786]         }
[17:41:10.786]         else {
[17:41:10.786]             ...future.result["stdout"] <- base::list(NULL)
[17:41:10.786]         }
[17:41:10.786]         base::close(...future.stdout)
[17:41:10.786]         ...future.stdout <- NULL
[17:41:10.786]     }
[17:41:10.786]     ...future.result$conditions <- ...future.conditions
[17:41:10.786]     ...future.result$finished <- base::Sys.time()
[17:41:10.786]     ...future.result
[17:41:10.786] }
[17:41:10.788] assign_globals() ...
[17:41:10.788] List of 5
[17:41:10.788]  $ ...future.FUN            :function (x, y)  
[17:41:10.788]  $ MoreArgs                 : NULL
[17:41:10.788]  $ ...future.elements_ii    :List of 2
[17:41:10.788]   ..$ :List of 2
[17:41:10.788]   .. ..$ : int 1
[17:41:10.788]   .. ..$ : int 0
[17:41:10.788]   ..$ :List of 2
[17:41:10.788]   .. ..$ : int 0
[17:41:10.788]   .. ..$ : int 1
[17:41:10.788]  $ ...future.seeds_ii       : NULL
[17:41:10.788]  $ ...future.globals.maxSize: NULL
[17:41:10.788]  - attr(*, "resolved")= logi FALSE
[17:41:10.788]  - attr(*, "total_size")= num 6480
[17:41:10.788]  - attr(*, "where")=List of 5
[17:41:10.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:10.788]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:10.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:10.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:10.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:10.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:10.788]  - attr(*, "already-done")= logi TRUE
[17:41:10.793] - reassign environment for ‘...future.FUN’
[17:41:10.793] - copied ‘...future.FUN’ to environment
[17:41:10.793] - copied ‘MoreArgs’ to environment
[17:41:10.794] - copied ‘...future.elements_ii’ to environment
[17:41:10.794] - copied ‘...future.seeds_ii’ to environment
[17:41:10.794] - copied ‘...future.globals.maxSize’ to environment
[17:41:10.794] assign_globals() ... done
[17:41:10.794] plan(): Setting new future strategy stack:
[17:41:10.794] List of future strategies:
[17:41:10.794] 1. sequential:
[17:41:10.794]    - args: function (..., envir = parent.frame())
[17:41:10.794]    - tweaked: FALSE
[17:41:10.794]    - call: NULL
[17:41:10.795] plan(): nbrOfWorkers() = 1
[17:41:11.296] plan(): Setting new future strategy stack:
[17:41:11.296] List of future strategies:
[17:41:11.296] 1. multicore:
[17:41:11.296]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:11.296]    - tweaked: FALSE
[17:41:11.296]    - call: plan(strategy)
[17:41:11.301] plan(): nbrOfWorkers() = 1
[17:41:11.301] SequentialFuture started (and completed)
[17:41:11.301] - Launch lazy future ... done
[17:41:11.301] run() for ‘SequentialFuture’ ... done
[17:41:11.301] Created future:
[17:41:11.301] SequentialFuture:
[17:41:11.301] Label: ‘future_mapply-1’
[17:41:11.301] Expression:
[17:41:11.301] {
[17:41:11.301]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:11.301]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:11.301]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:11.301]         on.exit(options(oopts), add = TRUE)
[17:41:11.301]     }
[17:41:11.301]     {
[17:41:11.301]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:11.301]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:11.301]         do.call(mapply, args = args)
[17:41:11.301]     }
[17:41:11.301] }
[17:41:11.301] Lazy evaluation: FALSE
[17:41:11.301] Asynchronous evaluation: FALSE
[17:41:11.301] Local evaluation: TRUE
[17:41:11.301] Environment: R_GlobalEnv
[17:41:11.301] Capture standard output: FALSE
[17:41:11.301] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:11.301] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:11.301] Packages: <none>
[17:41:11.301] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:11.301] Resolved: TRUE
[17:41:11.301] Value: 224 bytes of class ‘list’
[17:41:11.301] Early signaling: FALSE
[17:41:11.301] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:11.301] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:11.304] Chunk #1 of 1 ... DONE
[17:41:11.304] Launching 1 futures (chunks) ... DONE
[17:41:11.304] Resolving 1 futures (chunks) ...
[17:41:11.304] resolve() on list ...
[17:41:11.305]  recursive: 0
[17:41:11.305]  length: 1
[17:41:11.305] 
[17:41:11.305] resolved() for ‘SequentialFuture’ ...
[17:41:11.305] - state: ‘finished’
[17:41:11.305] - run: TRUE
[17:41:11.305] - result: ‘FutureResult’
[17:41:11.305] resolved() for ‘SequentialFuture’ ... done
[17:41:11.305] Future #1
[17:41:11.305] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:11.306] - nx: 1
[17:41:11.306] - relay: TRUE
[17:41:11.306] - stdout: TRUE
[17:41:11.306] - signal: TRUE
[17:41:11.306] - resignal: FALSE
[17:41:11.306] - force: TRUE
[17:41:11.306] - relayed: [n=1] FALSE
[17:41:11.306] - queued futures: [n=1] FALSE
[17:41:11.306]  - until=1
[17:41:11.306]  - relaying element #1
[17:41:11.306] - relayed: [n=1] TRUE
[17:41:11.307] - queued futures: [n=1] TRUE
[17:41:11.307] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:11.307]  length: 0 (resolved future 1)
[17:41:11.307] Relaying remaining futures
[17:41:11.307] signalConditionsASAP(NULL, pos=0) ...
[17:41:11.307] - nx: 1
[17:41:11.307] - relay: TRUE
[17:41:11.307] - stdout: TRUE
[17:41:11.307] - signal: TRUE
[17:41:11.307] - resignal: FALSE
[17:41:11.308] - force: TRUE
[17:41:11.308] - relayed: [n=1] TRUE
[17:41:11.308] - queued futures: [n=1] TRUE
 - flush all
[17:41:11.308] - relayed: [n=1] TRUE
[17:41:11.308] - queued futures: [n=1] TRUE
[17:41:11.308] signalConditionsASAP(NULL, pos=0) ... done
[17:41:11.308] resolve() on list ... DONE
[17:41:11.308]  - Number of value chunks collected: 1
[17:41:11.308] Resolving 1 futures (chunks) ... DONE
[17:41:11.308] Reducing values from 1 chunks ...
[17:41:11.308]  - Number of values collected after concatenation: 2
[17:41:11.309]  - Number of values expected: 2
[17:41:11.309] Reducing values from 1 chunks ... DONE
[17:41:11.309] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:41:11.309] future_mapply() ...
[17:41:11.313] Number of chunks: 1
[17:41:11.313] getGlobalsAndPackagesXApply() ...
[17:41:11.313]  - future.globals: TRUE
[17:41:11.313] getGlobalsAndPackages() ...
[17:41:11.313] Searching for globals...
[17:41:11.314] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:11.315] Searching for globals ... DONE
[17:41:11.315] Resolving globals: FALSE
[17:41:11.315] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:11.315] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:11.316] - globals: [1] ‘FUN’
[17:41:11.316] 
[17:41:11.316] getGlobalsAndPackages() ... DONE
[17:41:11.316]  - globals found/used: [n=1] ‘FUN’
[17:41:11.316]  - needed namespaces: [n=0] 
[17:41:11.316] Finding globals ... DONE
[17:41:11.316] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:11.316] List of 2
[17:41:11.316]  $ ...future.FUN:function (x, y)  
[17:41:11.316]  $ MoreArgs     : NULL
[17:41:11.316]  - attr(*, "where")=List of 2
[17:41:11.316]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:11.316]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:11.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:11.316]  - attr(*, "resolved")= logi FALSE
[17:41:11.316]  - attr(*, "total_size")= num NA
[17:41:11.319] Packages to be attached in all futures: [n=0] 
[17:41:11.319] getGlobalsAndPackagesXApply() ... DONE
[17:41:11.319] Number of futures (= number of chunks): 1
[17:41:11.319] Launching 1 futures (chunks) ...
[17:41:11.319] Chunk #1 of 1 ...
[17:41:11.319]  - Finding globals in '...' for chunk #1 ...
[17:41:11.320] getGlobalsAndPackages() ...
[17:41:11.320] Searching for globals...
[17:41:11.320] 
[17:41:11.320] Searching for globals ... DONE
[17:41:11.320] - globals: [0] <none>
[17:41:11.320] getGlobalsAndPackages() ... DONE
[17:41:11.320]    + additional globals found: [n=0] 
[17:41:11.320]    + additional namespaces needed: [n=0] 
[17:41:11.320]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:11.321]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:11.321]  - seeds: <none>
[17:41:11.321] getGlobalsAndPackages() ...
[17:41:11.321] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:11.321] Resolving globals: FALSE
[17:41:11.321] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:11.322] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:11.322] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:11.322] 
[17:41:11.322] getGlobalsAndPackages() ... DONE
[17:41:11.322] run() for ‘Future’ ...
[17:41:11.323] - state: ‘created’
[17:41:11.323] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:11.326] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:11.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:11.326]   - Field: ‘label’
[17:41:11.326]   - Field: ‘local’
[17:41:11.327]   - Field: ‘owner’
[17:41:11.327]   - Field: ‘envir’
[17:41:11.327]   - Field: ‘packages’
[17:41:11.327]   - Field: ‘gc’
[17:41:11.327]   - Field: ‘conditions’
[17:41:11.327]   - Field: ‘expr’
[17:41:11.327]   - Field: ‘uuid’
[17:41:11.327]   - Field: ‘seed’
[17:41:11.327]   - Field: ‘version’
[17:41:11.327]   - Field: ‘result’
[17:41:11.327]   - Field: ‘asynchronous’
[17:41:11.328]   - Field: ‘calls’
[17:41:11.328]   - Field: ‘globals’
[17:41:11.328]   - Field: ‘stdout’
[17:41:11.328]   - Field: ‘earlySignal’
[17:41:11.328]   - Field: ‘lazy’
[17:41:11.328]   - Field: ‘state’
[17:41:11.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:11.328] - Launch lazy future ...
[17:41:11.328] Packages needed by the future expression (n = 0): <none>
[17:41:11.329] Packages needed by future strategies (n = 0): <none>
[17:41:11.329] {
[17:41:11.329]     {
[17:41:11.329]         {
[17:41:11.329]             ...future.startTime <- base::Sys.time()
[17:41:11.329]             {
[17:41:11.329]                 {
[17:41:11.329]                   {
[17:41:11.329]                     base::local({
[17:41:11.329]                       has_future <- base::requireNamespace("future", 
[17:41:11.329]                         quietly = TRUE)
[17:41:11.329]                       if (has_future) {
[17:41:11.329]                         ns <- base::getNamespace("future")
[17:41:11.329]                         version <- ns[[".package"]][["version"]]
[17:41:11.329]                         if (is.null(version)) 
[17:41:11.329]                           version <- utils::packageVersion("future")
[17:41:11.329]                       }
[17:41:11.329]                       else {
[17:41:11.329]                         version <- NULL
[17:41:11.329]                       }
[17:41:11.329]                       if (!has_future || version < "1.8.0") {
[17:41:11.329]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:11.329]                           "", base::R.version$version.string), 
[17:41:11.329]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:11.329]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:11.329]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:11.329]                             "release", "version")], collapse = " "), 
[17:41:11.329]                           hostname = base::Sys.info()[["nodename"]])
[17:41:11.329]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:11.329]                           info)
[17:41:11.329]                         info <- base::paste(info, collapse = "; ")
[17:41:11.329]                         if (!has_future) {
[17:41:11.329]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:11.329]                             info)
[17:41:11.329]                         }
[17:41:11.329]                         else {
[17:41:11.329]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:11.329]                             info, version)
[17:41:11.329]                         }
[17:41:11.329]                         base::stop(msg)
[17:41:11.329]                       }
[17:41:11.329]                     })
[17:41:11.329]                   }
[17:41:11.329]                   options(future.plan = NULL)
[17:41:11.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:11.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:11.329]                 }
[17:41:11.329]                 ...future.workdir <- getwd()
[17:41:11.329]             }
[17:41:11.329]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:11.329]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:11.329]         }
[17:41:11.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:11.329]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:11.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:11.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:11.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:11.329]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:11.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:11.329]             base::names(...future.oldOptions))
[17:41:11.329]     }
[17:41:11.329]     if (FALSE) {
[17:41:11.329]     }
[17:41:11.329]     else {
[17:41:11.329]         if (TRUE) {
[17:41:11.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:11.329]                 open = "w")
[17:41:11.329]         }
[17:41:11.329]         else {
[17:41:11.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:11.329]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:11.329]         }
[17:41:11.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:11.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:11.329]             base::sink(type = "output", split = FALSE)
[17:41:11.329]             base::close(...future.stdout)
[17:41:11.329]         }, add = TRUE)
[17:41:11.329]     }
[17:41:11.329]     ...future.frame <- base::sys.nframe()
[17:41:11.329]     ...future.conditions <- base::list()
[17:41:11.329]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:11.329]     if (FALSE) {
[17:41:11.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:11.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:11.329]     }
[17:41:11.329]     ...future.result <- base::tryCatch({
[17:41:11.329]         base::withCallingHandlers({
[17:41:11.329]             ...future.value <- base::withVisible(base::local({
[17:41:11.329]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:11.329]                 if (!identical(...future.globals.maxSize.org, 
[17:41:11.329]                   ...future.globals.maxSize)) {
[17:41:11.329]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:11.329]                   on.exit(options(oopts), add = TRUE)
[17:41:11.329]                 }
[17:41:11.329]                 {
[17:41:11.329]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:11.329]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:11.329]                     USE.NAMES = FALSE)
[17:41:11.329]                   do.call(mapply, args = args)
[17:41:11.329]                 }
[17:41:11.329]             }))
[17:41:11.329]             future::FutureResult(value = ...future.value$value, 
[17:41:11.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:11.329]                   ...future.rng), globalenv = if (FALSE) 
[17:41:11.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:11.329]                     ...future.globalenv.names))
[17:41:11.329]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:11.329]         }, condition = base::local({
[17:41:11.329]             c <- base::c
[17:41:11.329]             inherits <- base::inherits
[17:41:11.329]             invokeRestart <- base::invokeRestart
[17:41:11.329]             length <- base::length
[17:41:11.329]             list <- base::list
[17:41:11.329]             seq.int <- base::seq.int
[17:41:11.329]             signalCondition <- base::signalCondition
[17:41:11.329]             sys.calls <- base::sys.calls
[17:41:11.329]             `[[` <- base::`[[`
[17:41:11.329]             `+` <- base::`+`
[17:41:11.329]             `<<-` <- base::`<<-`
[17:41:11.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:11.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:11.329]                   3L)]
[17:41:11.329]             }
[17:41:11.329]             function(cond) {
[17:41:11.329]                 is_error <- inherits(cond, "error")
[17:41:11.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:11.329]                   NULL)
[17:41:11.329]                 if (is_error) {
[17:41:11.329]                   sessionInformation <- function() {
[17:41:11.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:11.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:11.329]                       search = base::search(), system = base::Sys.info())
[17:41:11.329]                   }
[17:41:11.329]                   ...future.conditions[[length(...future.conditions) + 
[17:41:11.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:11.329]                     cond$call), session = sessionInformation(), 
[17:41:11.329]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:11.329]                   signalCondition(cond)
[17:41:11.329]                 }
[17:41:11.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:11.329]                 "immediateCondition"))) {
[17:41:11.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:11.329]                   ...future.conditions[[length(...future.conditions) + 
[17:41:11.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:11.329]                   if (TRUE && !signal) {
[17:41:11.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:11.329]                     {
[17:41:11.329]                       inherits <- base::inherits
[17:41:11.329]                       invokeRestart <- base::invokeRestart
[17:41:11.329]                       is.null <- base::is.null
[17:41:11.329]                       muffled <- FALSE
[17:41:11.329]                       if (inherits(cond, "message")) {
[17:41:11.329]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:11.329]                         if (muffled) 
[17:41:11.329]                           invokeRestart("muffleMessage")
[17:41:11.329]                       }
[17:41:11.329]                       else if (inherits(cond, "warning")) {
[17:41:11.329]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:11.329]                         if (muffled) 
[17:41:11.329]                           invokeRestart("muffleWarning")
[17:41:11.329]                       }
[17:41:11.329]                       else if (inherits(cond, "condition")) {
[17:41:11.329]                         if (!is.null(pattern)) {
[17:41:11.329]                           computeRestarts <- base::computeRestarts
[17:41:11.329]                           grepl <- base::grepl
[17:41:11.329]                           restarts <- computeRestarts(cond)
[17:41:11.329]                           for (restart in restarts) {
[17:41:11.329]                             name <- restart$name
[17:41:11.329]                             if (is.null(name)) 
[17:41:11.329]                               next
[17:41:11.329]                             if (!grepl(pattern, name)) 
[17:41:11.329]                               next
[17:41:11.329]                             invokeRestart(restart)
[17:41:11.329]                             muffled <- TRUE
[17:41:11.329]                             break
[17:41:11.329]                           }
[17:41:11.329]                         }
[17:41:11.329]                       }
[17:41:11.329]                       invisible(muffled)
[17:41:11.329]                     }
[17:41:11.329]                     muffleCondition(cond, pattern = "^muffle")
[17:41:11.329]                   }
[17:41:11.329]                 }
[17:41:11.329]                 else {
[17:41:11.329]                   if (TRUE) {
[17:41:11.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:11.329]                     {
[17:41:11.329]                       inherits <- base::inherits
[17:41:11.329]                       invokeRestart <- base::invokeRestart
[17:41:11.329]                       is.null <- base::is.null
[17:41:11.329]                       muffled <- FALSE
[17:41:11.329]                       if (inherits(cond, "message")) {
[17:41:11.329]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:11.329]                         if (muffled) 
[17:41:11.329]                           invokeRestart("muffleMessage")
[17:41:11.329]                       }
[17:41:11.329]                       else if (inherits(cond, "warning")) {
[17:41:11.329]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:11.329]                         if (muffled) 
[17:41:11.329]                           invokeRestart("muffleWarning")
[17:41:11.329]                       }
[17:41:11.329]                       else if (inherits(cond, "condition")) {
[17:41:11.329]                         if (!is.null(pattern)) {
[17:41:11.329]                           computeRestarts <- base::computeRestarts
[17:41:11.329]                           grepl <- base::grepl
[17:41:11.329]                           restarts <- computeRestarts(cond)
[17:41:11.329]                           for (restart in restarts) {
[17:41:11.329]                             name <- restart$name
[17:41:11.329]                             if (is.null(name)) 
[17:41:11.329]                               next
[17:41:11.329]                             if (!grepl(pattern, name)) 
[17:41:11.329]                               next
[17:41:11.329]                             invokeRestart(restart)
[17:41:11.329]                             muffled <- TRUE
[17:41:11.329]                             break
[17:41:11.329]                           }
[17:41:11.329]                         }
[17:41:11.329]                       }
[17:41:11.329]                       invisible(muffled)
[17:41:11.329]                     }
[17:41:11.329]                     muffleCondition(cond, pattern = "^muffle")
[17:41:11.329]                   }
[17:41:11.329]                 }
[17:41:11.329]             }
[17:41:11.329]         }))
[17:41:11.329]     }, error = function(ex) {
[17:41:11.329]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:11.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:11.329]                 ...future.rng), started = ...future.startTime, 
[17:41:11.329]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:11.329]             version = "1.8"), class = "FutureResult")
[17:41:11.329]     }, finally = {
[17:41:11.329]         if (!identical(...future.workdir, getwd())) 
[17:41:11.329]             setwd(...future.workdir)
[17:41:11.329]         {
[17:41:11.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:11.329]                 ...future.oldOptions$nwarnings <- NULL
[17:41:11.329]             }
[17:41:11.329]             base::options(...future.oldOptions)
[17:41:11.329]             if (.Platform$OS.type == "windows") {
[17:41:11.329]                 old_names <- names(...future.oldEnvVars)
[17:41:11.329]                 envs <- base::Sys.getenv()
[17:41:11.329]                 names <- names(envs)
[17:41:11.329]                 common <- intersect(names, old_names)
[17:41:11.329]                 added <- setdiff(names, old_names)
[17:41:11.329]                 removed <- setdiff(old_names, names)
[17:41:11.329]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:11.329]                   envs[common]]
[17:41:11.329]                 NAMES <- toupper(changed)
[17:41:11.329]                 args <- list()
[17:41:11.329]                 for (kk in seq_along(NAMES)) {
[17:41:11.329]                   name <- changed[[kk]]
[17:41:11.329]                   NAME <- NAMES[[kk]]
[17:41:11.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:11.329]                     next
[17:41:11.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:11.329]                 }
[17:41:11.329]                 NAMES <- toupper(added)
[17:41:11.329]                 for (kk in seq_along(NAMES)) {
[17:41:11.329]                   name <- added[[kk]]
[17:41:11.329]                   NAME <- NAMES[[kk]]
[17:41:11.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:11.329]                     next
[17:41:11.329]                   args[[name]] <- ""
[17:41:11.329]                 }
[17:41:11.329]                 NAMES <- toupper(removed)
[17:41:11.329]                 for (kk in seq_along(NAMES)) {
[17:41:11.329]                   name <- removed[[kk]]
[17:41:11.329]                   NAME <- NAMES[[kk]]
[17:41:11.329]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:11.329]                     next
[17:41:11.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:11.329]                 }
[17:41:11.329]                 if (length(args) > 0) 
[17:41:11.329]                   base::do.call(base::Sys.setenv, args = args)
[17:41:11.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:11.329]             }
[17:41:11.329]             else {
[17:41:11.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:11.329]             }
[17:41:11.329]             {
[17:41:11.329]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:11.329]                   0L) {
[17:41:11.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:11.329]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:11.329]                   base::options(opts)
[17:41:11.329]                 }
[17:41:11.329]                 {
[17:41:11.329]                   {
[17:41:11.329]                     NULL
[17:41:11.329]                     RNGkind("Mersenne-Twister")
[17:41:11.329]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:11.329]                       inherits = FALSE)
[17:41:11.329]                   }
[17:41:11.329]                   options(future.plan = NULL)
[17:41:11.329]                   if (is.na(NA_character_)) 
[17:41:11.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:11.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:11.329]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:11.329]                     envir = parent.frame()) 
[17:41:11.329]                   {
[17:41:11.329]                     default_workers <- missing(workers)
[17:41:11.329]                     if (is.function(workers)) 
[17:41:11.329]                       workers <- workers()
[17:41:11.329]                     workers <- structure(as.integer(workers), 
[17:41:11.329]                       class = class(workers))
[17:41:11.329]                     stop_if_not(is.finite(workers), workers >= 
[17:41:11.329]                       1L)
[17:41:11.329]                     if ((workers == 1L && !inherits(workers, 
[17:41:11.329]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:11.329]                       if (default_workers) 
[17:41:11.329]                         supportsMulticore(warn = TRUE)
[17:41:11.329]                       return(sequential(..., envir = envir))
[17:41:11.329]                     }
[17:41:11.329]                     oopts <- options(mc.cores = workers)
[17:41:11.329]                     on.exit(options(oopts))
[17:41:11.329]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:11.329]                       envir = envir)
[17:41:11.329]                     if (!future$lazy) 
[17:41:11.329]                       future <- run(future)
[17:41:11.329]                     invisible(future)
[17:41:11.329]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:11.329]                 }
[17:41:11.329]             }
[17:41:11.329]         }
[17:41:11.329]     })
[17:41:11.329]     if (TRUE) {
[17:41:11.329]         base::sink(type = "output", split = FALSE)
[17:41:11.329]         if (TRUE) {
[17:41:11.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:11.329]         }
[17:41:11.329]         else {
[17:41:11.329]             ...future.result["stdout"] <- base::list(NULL)
[17:41:11.329]         }
[17:41:11.329]         base::close(...future.stdout)
[17:41:11.329]         ...future.stdout <- NULL
[17:41:11.329]     }
[17:41:11.329]     ...future.result$conditions <- ...future.conditions
[17:41:11.329]     ...future.result$finished <- base::Sys.time()
[17:41:11.329]     ...future.result
[17:41:11.329] }
[17:41:11.331] assign_globals() ...
[17:41:11.331] List of 5
[17:41:11.331]  $ ...future.FUN            :function (x, y)  
[17:41:11.331]  $ MoreArgs                 : NULL
[17:41:11.331]  $ ...future.elements_ii    :List of 2
[17:41:11.331]   ..$ :List of 2
[17:41:11.331]   .. ..$ : int 1
[17:41:11.331]   .. ..$ : int 0
[17:41:11.331]   ..$ :List of 2
[17:41:11.331]   .. ..$ : int 0
[17:41:11.331]   .. ..$ : int 1
[17:41:11.331]  $ ...future.seeds_ii       : NULL
[17:41:11.331]  $ ...future.globals.maxSize: NULL
[17:41:11.331]  - attr(*, "resolved")= logi FALSE
[17:41:11.331]  - attr(*, "total_size")= num 6480
[17:41:11.331]  - attr(*, "where")=List of 5
[17:41:11.331]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:11.331]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:11.331]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:11.331]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:11.331]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:11.331]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:11.331]  - attr(*, "already-done")= logi TRUE
[17:41:11.338] - reassign environment for ‘...future.FUN’
[17:41:11.338] - copied ‘...future.FUN’ to environment
[17:41:11.338] - copied ‘MoreArgs’ to environment
[17:41:11.338] - copied ‘...future.elements_ii’ to environment
[17:41:11.338] - copied ‘...future.seeds_ii’ to environment
[17:41:11.338] - copied ‘...future.globals.maxSize’ to environment
[17:41:11.338] assign_globals() ... done
[17:41:11.339] plan(): Setting new future strategy stack:
[17:41:11.339] List of future strategies:
[17:41:11.339] 1. sequential:
[17:41:11.339]    - args: function (..., envir = parent.frame())
[17:41:11.339]    - tweaked: FALSE
[17:41:11.339]    - call: NULL
[17:41:11.339] plan(): nbrOfWorkers() = 1
[17:41:11.841] plan(): Setting new future strategy stack:
[17:41:11.841] List of future strategies:
[17:41:11.841] 1. multicore:
[17:41:11.841]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:11.841]    - tweaked: FALSE
[17:41:11.841]    - call: plan(strategy)
[17:41:11.845] plan(): nbrOfWorkers() = 1
[17:41:11.845] SequentialFuture started (and completed)
[17:41:11.845] - Launch lazy future ... done
[17:41:11.845] run() for ‘SequentialFuture’ ... done
[17:41:11.846] Created future:
[17:41:11.846] SequentialFuture:
[17:41:11.846] Label: ‘future_mapply-1’
[17:41:11.846] Expression:
[17:41:11.846] {
[17:41:11.846]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:11.846]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:11.846]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:11.846]         on.exit(options(oopts), add = TRUE)
[17:41:11.846]     }
[17:41:11.846]     {
[17:41:11.846]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:11.846]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:11.846]         do.call(mapply, args = args)
[17:41:11.846]     }
[17:41:11.846] }
[17:41:11.846] Lazy evaluation: FALSE
[17:41:11.846] Asynchronous evaluation: FALSE
[17:41:11.846] Local evaluation: TRUE
[17:41:11.846] Environment: R_GlobalEnv
[17:41:11.846] Capture standard output: TRUE
[17:41:11.846] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:11.846] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:11.846] Packages: <none>
[17:41:11.846] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:11.846] Resolved: TRUE
[17:41:11.846] Value: 224 bytes of class ‘list’
[17:41:11.846] Early signaling: FALSE
[17:41:11.846] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:11.846] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:11.847] Chunk #1 of 1 ... DONE
[17:41:11.847] Launching 1 futures (chunks) ... DONE
[17:41:11.847] Resolving 1 futures (chunks) ...
[17:41:11.847] resolve() on list ...
[17:41:11.847]  recursive: 0
[17:41:11.847]  length: 1
[17:41:11.847] 
[17:41:11.847] resolved() for ‘SequentialFuture’ ...
[17:41:11.847] - state: ‘finished’
[17:41:11.848] - run: TRUE
[17:41:11.848] - result: ‘FutureResult’
[17:41:11.848] resolved() for ‘SequentialFuture’ ... done
[17:41:11.848] Future #1
[17:41:11.848] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:11.848] - nx: 1
[17:41:11.848] - relay: TRUE
[17:41:11.848] - stdout: TRUE
[17:41:11.848] - signal: TRUE
[17:41:11.848] - resignal: FALSE
[17:41:11.848] - force: TRUE
[17:41:11.849] - relayed: [n=1] FALSE
[17:41:11.849] - queued futures: [n=1] FALSE
[17:41:11.849]  - until=1
[17:41:11.849]  - relaying element #1
[17:41:11.849] - relayed: [n=1] TRUE
[17:41:11.849] - queued futures: [n=1] TRUE
[17:41:11.849] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:11.849]  length: 0 (resolved future 1)
[17:41:11.849] Relaying remaining futures
[17:41:11.849] signalConditionsASAP(NULL, pos=0) ...
[17:41:11.850] - nx: 1
[17:41:11.850] - relay: TRUE
[17:41:11.850] - stdout: TRUE
[17:41:11.850] - signal: TRUE
[17:41:11.850] - resignal: FALSE
[17:41:11.850] - force: TRUE
[17:41:11.850] - relayed: [n=1] TRUE
[17:41:11.850] - queued futures: [n=1] TRUE
 - flush all
[17:41:11.850] - relayed: [n=1] TRUE
[17:41:11.850] - queued futures: [n=1] TRUE
[17:41:11.850] signalConditionsASAP(NULL, pos=0) ... done
[17:41:11.851] resolve() on list ... DONE
[17:41:11.851]  - Number of value chunks collected: 1
[17:41:11.851] Resolving 1 futures (chunks) ... DONE
[17:41:11.851] Reducing values from 1 chunks ...
[17:41:11.851]  - Number of values collected after concatenation: 2
[17:41:11.851]  - Number of values expected: 2
[17:41:11.851] Reducing values from 1 chunks ... DONE
[17:41:11.851] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:41:11.852] future_mapply() ...
[17:41:11.855] Number of chunks: 1
[17:41:11.855] getGlobalsAndPackagesXApply() ...
[17:41:11.855]  - future.globals: TRUE
[17:41:11.855] getGlobalsAndPackages() ...
[17:41:11.855] Searching for globals...
[17:41:11.857] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:11.857] Searching for globals ... DONE
[17:41:11.857] Resolving globals: FALSE
[17:41:11.857] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:11.858] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:11.858] - globals: [1] ‘FUN’
[17:41:11.858] 
[17:41:11.858] getGlobalsAndPackages() ... DONE
[17:41:11.858]  - globals found/used: [n=1] ‘FUN’
[17:41:11.858]  - needed namespaces: [n=0] 
[17:41:11.858] Finding globals ... DONE
[17:41:11.859] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:11.859] List of 2
[17:41:11.859]  $ ...future.FUN:function (x, y)  
[17:41:11.859]  $ MoreArgs     : NULL
[17:41:11.859]  - attr(*, "where")=List of 2
[17:41:11.859]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:11.859]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:11.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:11.859]  - attr(*, "resolved")= logi FALSE
[17:41:11.859]  - attr(*, "total_size")= num NA
[17:41:11.863] Packages to be attached in all futures: [n=0] 
[17:41:11.863] getGlobalsAndPackagesXApply() ... DONE
[17:41:11.863] Number of futures (= number of chunks): 1
[17:41:11.863] Launching 1 futures (chunks) ...
[17:41:11.864] Chunk #1 of 1 ...
[17:41:11.864]  - Finding globals in '...' for chunk #1 ...
[17:41:11.864] getGlobalsAndPackages() ...
[17:41:11.864] Searching for globals...
[17:41:11.864] 
[17:41:11.864] Searching for globals ... DONE
[17:41:11.864] - globals: [0] <none>
[17:41:11.865] getGlobalsAndPackages() ... DONE
[17:41:11.865]    + additional globals found: [n=0] 
[17:41:11.865]    + additional namespaces needed: [n=0] 
[17:41:11.865]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:11.865]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:11.865]  - seeds: <none>
[17:41:11.865] getGlobalsAndPackages() ...
[17:41:11.865] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:11.865] Resolving globals: FALSE
[17:41:11.866] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:11.866] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:11.866] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:11.866] 
[17:41:11.867] getGlobalsAndPackages() ... DONE
[17:41:11.867] run() for ‘Future’ ...
[17:41:11.867] - state: ‘created’
[17:41:11.867] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:11.871] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:11.871] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:11.871]   - Field: ‘label’
[17:41:11.871]   - Field: ‘local’
[17:41:11.871]   - Field: ‘owner’
[17:41:11.871]   - Field: ‘envir’
[17:41:11.871]   - Field: ‘packages’
[17:41:11.871]   - Field: ‘gc’
[17:41:11.872]   - Field: ‘conditions’
[17:41:11.872]   - Field: ‘expr’
[17:41:11.872]   - Field: ‘uuid’
[17:41:11.872]   - Field: ‘seed’
[17:41:11.872]   - Field: ‘version’
[17:41:11.872]   - Field: ‘result’
[17:41:11.872]   - Field: ‘asynchronous’
[17:41:11.872]   - Field: ‘calls’
[17:41:11.872]   - Field: ‘globals’
[17:41:11.872]   - Field: ‘stdout’
[17:41:11.872]   - Field: ‘earlySignal’
[17:41:11.873]   - Field: ‘lazy’
[17:41:11.873]   - Field: ‘state’
[17:41:11.873] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:11.873] - Launch lazy future ...
[17:41:11.873] Packages needed by the future expression (n = 0): <none>
[17:41:11.873] Packages needed by future strategies (n = 0): <none>
[17:41:11.874] {
[17:41:11.874]     {
[17:41:11.874]         {
[17:41:11.874]             ...future.startTime <- base::Sys.time()
[17:41:11.874]             {
[17:41:11.874]                 {
[17:41:11.874]                   {
[17:41:11.874]                     base::local({
[17:41:11.874]                       has_future <- base::requireNamespace("future", 
[17:41:11.874]                         quietly = TRUE)
[17:41:11.874]                       if (has_future) {
[17:41:11.874]                         ns <- base::getNamespace("future")
[17:41:11.874]                         version <- ns[[".package"]][["version"]]
[17:41:11.874]                         if (is.null(version)) 
[17:41:11.874]                           version <- utils::packageVersion("future")
[17:41:11.874]                       }
[17:41:11.874]                       else {
[17:41:11.874]                         version <- NULL
[17:41:11.874]                       }
[17:41:11.874]                       if (!has_future || version < "1.8.0") {
[17:41:11.874]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:11.874]                           "", base::R.version$version.string), 
[17:41:11.874]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:11.874]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:11.874]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:11.874]                             "release", "version")], collapse = " "), 
[17:41:11.874]                           hostname = base::Sys.info()[["nodename"]])
[17:41:11.874]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:11.874]                           info)
[17:41:11.874]                         info <- base::paste(info, collapse = "; ")
[17:41:11.874]                         if (!has_future) {
[17:41:11.874]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:11.874]                             info)
[17:41:11.874]                         }
[17:41:11.874]                         else {
[17:41:11.874]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:11.874]                             info, version)
[17:41:11.874]                         }
[17:41:11.874]                         base::stop(msg)
[17:41:11.874]                       }
[17:41:11.874]                     })
[17:41:11.874]                   }
[17:41:11.874]                   options(future.plan = NULL)
[17:41:11.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:11.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:11.874]                 }
[17:41:11.874]                 ...future.workdir <- getwd()
[17:41:11.874]             }
[17:41:11.874]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:11.874]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:11.874]         }
[17:41:11.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:11.874]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:11.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:11.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:11.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:11.874]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:11.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:11.874]             base::names(...future.oldOptions))
[17:41:11.874]     }
[17:41:11.874]     if (TRUE) {
[17:41:11.874]     }
[17:41:11.874]     else {
[17:41:11.874]         if (NA) {
[17:41:11.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:11.874]                 open = "w")
[17:41:11.874]         }
[17:41:11.874]         else {
[17:41:11.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:11.874]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:11.874]         }
[17:41:11.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:11.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:11.874]             base::sink(type = "output", split = FALSE)
[17:41:11.874]             base::close(...future.stdout)
[17:41:11.874]         }, add = TRUE)
[17:41:11.874]     }
[17:41:11.874]     ...future.frame <- base::sys.nframe()
[17:41:11.874]     ...future.conditions <- base::list()
[17:41:11.874]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:11.874]     if (FALSE) {
[17:41:11.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:11.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:11.874]     }
[17:41:11.874]     ...future.result <- base::tryCatch({
[17:41:11.874]         base::withCallingHandlers({
[17:41:11.874]             ...future.value <- base::withVisible(base::local({
[17:41:11.874]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:11.874]                 if (!identical(...future.globals.maxSize.org, 
[17:41:11.874]                   ...future.globals.maxSize)) {
[17:41:11.874]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:11.874]                   on.exit(options(oopts), add = TRUE)
[17:41:11.874]                 }
[17:41:11.874]                 {
[17:41:11.874]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:11.874]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:11.874]                     USE.NAMES = FALSE)
[17:41:11.874]                   do.call(mapply, args = args)
[17:41:11.874]                 }
[17:41:11.874]             }))
[17:41:11.874]             future::FutureResult(value = ...future.value$value, 
[17:41:11.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:11.874]                   ...future.rng), globalenv = if (FALSE) 
[17:41:11.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:11.874]                     ...future.globalenv.names))
[17:41:11.874]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:11.874]         }, condition = base::local({
[17:41:11.874]             c <- base::c
[17:41:11.874]             inherits <- base::inherits
[17:41:11.874]             invokeRestart <- base::invokeRestart
[17:41:11.874]             length <- base::length
[17:41:11.874]             list <- base::list
[17:41:11.874]             seq.int <- base::seq.int
[17:41:11.874]             signalCondition <- base::signalCondition
[17:41:11.874]             sys.calls <- base::sys.calls
[17:41:11.874]             `[[` <- base::`[[`
[17:41:11.874]             `+` <- base::`+`
[17:41:11.874]             `<<-` <- base::`<<-`
[17:41:11.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:11.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:11.874]                   3L)]
[17:41:11.874]             }
[17:41:11.874]             function(cond) {
[17:41:11.874]                 is_error <- inherits(cond, "error")
[17:41:11.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:11.874]                   NULL)
[17:41:11.874]                 if (is_error) {
[17:41:11.874]                   sessionInformation <- function() {
[17:41:11.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:11.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:11.874]                       search = base::search(), system = base::Sys.info())
[17:41:11.874]                   }
[17:41:11.874]                   ...future.conditions[[length(...future.conditions) + 
[17:41:11.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:11.874]                     cond$call), session = sessionInformation(), 
[17:41:11.874]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:11.874]                   signalCondition(cond)
[17:41:11.874]                 }
[17:41:11.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:11.874]                 "immediateCondition"))) {
[17:41:11.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:11.874]                   ...future.conditions[[length(...future.conditions) + 
[17:41:11.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:11.874]                   if (TRUE && !signal) {
[17:41:11.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:11.874]                     {
[17:41:11.874]                       inherits <- base::inherits
[17:41:11.874]                       invokeRestart <- base::invokeRestart
[17:41:11.874]                       is.null <- base::is.null
[17:41:11.874]                       muffled <- FALSE
[17:41:11.874]                       if (inherits(cond, "message")) {
[17:41:11.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:11.874]                         if (muffled) 
[17:41:11.874]                           invokeRestart("muffleMessage")
[17:41:11.874]                       }
[17:41:11.874]                       else if (inherits(cond, "warning")) {
[17:41:11.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:11.874]                         if (muffled) 
[17:41:11.874]                           invokeRestart("muffleWarning")
[17:41:11.874]                       }
[17:41:11.874]                       else if (inherits(cond, "condition")) {
[17:41:11.874]                         if (!is.null(pattern)) {
[17:41:11.874]                           computeRestarts <- base::computeRestarts
[17:41:11.874]                           grepl <- base::grepl
[17:41:11.874]                           restarts <- computeRestarts(cond)
[17:41:11.874]                           for (restart in restarts) {
[17:41:11.874]                             name <- restart$name
[17:41:11.874]                             if (is.null(name)) 
[17:41:11.874]                               next
[17:41:11.874]                             if (!grepl(pattern, name)) 
[17:41:11.874]                               next
[17:41:11.874]                             invokeRestart(restart)
[17:41:11.874]                             muffled <- TRUE
[17:41:11.874]                             break
[17:41:11.874]                           }
[17:41:11.874]                         }
[17:41:11.874]                       }
[17:41:11.874]                       invisible(muffled)
[17:41:11.874]                     }
[17:41:11.874]                     muffleCondition(cond, pattern = "^muffle")
[17:41:11.874]                   }
[17:41:11.874]                 }
[17:41:11.874]                 else {
[17:41:11.874]                   if (TRUE) {
[17:41:11.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:11.874]                     {
[17:41:11.874]                       inherits <- base::inherits
[17:41:11.874]                       invokeRestart <- base::invokeRestart
[17:41:11.874]                       is.null <- base::is.null
[17:41:11.874]                       muffled <- FALSE
[17:41:11.874]                       if (inherits(cond, "message")) {
[17:41:11.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:11.874]                         if (muffled) 
[17:41:11.874]                           invokeRestart("muffleMessage")
[17:41:11.874]                       }
[17:41:11.874]                       else if (inherits(cond, "warning")) {
[17:41:11.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:11.874]                         if (muffled) 
[17:41:11.874]                           invokeRestart("muffleWarning")
[17:41:11.874]                       }
[17:41:11.874]                       else if (inherits(cond, "condition")) {
[17:41:11.874]                         if (!is.null(pattern)) {
[17:41:11.874]                           computeRestarts <- base::computeRestarts
[17:41:11.874]                           grepl <- base::grepl
[17:41:11.874]                           restarts <- computeRestarts(cond)
[17:41:11.874]                           for (restart in restarts) {
[17:41:11.874]                             name <- restart$name
[17:41:11.874]                             if (is.null(name)) 
[17:41:11.874]                               next
[17:41:11.874]                             if (!grepl(pattern, name)) 
[17:41:11.874]                               next
[17:41:11.874]                             invokeRestart(restart)
[17:41:11.874]                             muffled <- TRUE
[17:41:11.874]                             break
[17:41:11.874]                           }
[17:41:11.874]                         }
[17:41:11.874]                       }
[17:41:11.874]                       invisible(muffled)
[17:41:11.874]                     }
[17:41:11.874]                     muffleCondition(cond, pattern = "^muffle")
[17:41:11.874]                   }
[17:41:11.874]                 }
[17:41:11.874]             }
[17:41:11.874]         }))
[17:41:11.874]     }, error = function(ex) {
[17:41:11.874]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:11.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:11.874]                 ...future.rng), started = ...future.startTime, 
[17:41:11.874]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:11.874]             version = "1.8"), class = "FutureResult")
[17:41:11.874]     }, finally = {
[17:41:11.874]         if (!identical(...future.workdir, getwd())) 
[17:41:11.874]             setwd(...future.workdir)
[17:41:11.874]         {
[17:41:11.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:11.874]                 ...future.oldOptions$nwarnings <- NULL
[17:41:11.874]             }
[17:41:11.874]             base::options(...future.oldOptions)
[17:41:11.874]             if (.Platform$OS.type == "windows") {
[17:41:11.874]                 old_names <- names(...future.oldEnvVars)
[17:41:11.874]                 envs <- base::Sys.getenv()
[17:41:11.874]                 names <- names(envs)
[17:41:11.874]                 common <- intersect(names, old_names)
[17:41:11.874]                 added <- setdiff(names, old_names)
[17:41:11.874]                 removed <- setdiff(old_names, names)
[17:41:11.874]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:11.874]                   envs[common]]
[17:41:11.874]                 NAMES <- toupper(changed)
[17:41:11.874]                 args <- list()
[17:41:11.874]                 for (kk in seq_along(NAMES)) {
[17:41:11.874]                   name <- changed[[kk]]
[17:41:11.874]                   NAME <- NAMES[[kk]]
[17:41:11.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:11.874]                     next
[17:41:11.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:11.874]                 }
[17:41:11.874]                 NAMES <- toupper(added)
[17:41:11.874]                 for (kk in seq_along(NAMES)) {
[17:41:11.874]                   name <- added[[kk]]
[17:41:11.874]                   NAME <- NAMES[[kk]]
[17:41:11.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:11.874]                     next
[17:41:11.874]                   args[[name]] <- ""
[17:41:11.874]                 }
[17:41:11.874]                 NAMES <- toupper(removed)
[17:41:11.874]                 for (kk in seq_along(NAMES)) {
[17:41:11.874]                   name <- removed[[kk]]
[17:41:11.874]                   NAME <- NAMES[[kk]]
[17:41:11.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:11.874]                     next
[17:41:11.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:11.874]                 }
[17:41:11.874]                 if (length(args) > 0) 
[17:41:11.874]                   base::do.call(base::Sys.setenv, args = args)
[17:41:11.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:11.874]             }
[17:41:11.874]             else {
[17:41:11.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:11.874]             }
[17:41:11.874]             {
[17:41:11.874]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:11.874]                   0L) {
[17:41:11.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:11.874]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:11.874]                   base::options(opts)
[17:41:11.874]                 }
[17:41:11.874]                 {
[17:41:11.874]                   {
[17:41:11.874]                     NULL
[17:41:11.874]                     RNGkind("Mersenne-Twister")
[17:41:11.874]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:11.874]                       inherits = FALSE)
[17:41:11.874]                   }
[17:41:11.874]                   options(future.plan = NULL)
[17:41:11.874]                   if (is.na(NA_character_)) 
[17:41:11.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:11.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:11.874]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:11.874]                     envir = parent.frame()) 
[17:41:11.874]                   {
[17:41:11.874]                     default_workers <- missing(workers)
[17:41:11.874]                     if (is.function(workers)) 
[17:41:11.874]                       workers <- workers()
[17:41:11.874]                     workers <- structure(as.integer(workers), 
[17:41:11.874]                       class = class(workers))
[17:41:11.874]                     stop_if_not(is.finite(workers), workers >= 
[17:41:11.874]                       1L)
[17:41:11.874]                     if ((workers == 1L && !inherits(workers, 
[17:41:11.874]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:11.874]                       if (default_workers) 
[17:41:11.874]                         supportsMulticore(warn = TRUE)
[17:41:11.874]                       return(sequential(..., envir = envir))
[17:41:11.874]                     }
[17:41:11.874]                     oopts <- options(mc.cores = workers)
[17:41:11.874]                     on.exit(options(oopts))
[17:41:11.874]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:11.874]                       envir = envir)
[17:41:11.874]                     if (!future$lazy) 
[17:41:11.874]                       future <- run(future)
[17:41:11.874]                     invisible(future)
[17:41:11.874]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:11.874]                 }
[17:41:11.874]             }
[17:41:11.874]         }
[17:41:11.874]     })
[17:41:11.874]     if (FALSE) {
[17:41:11.874]         base::sink(type = "output", split = FALSE)
[17:41:11.874]         if (NA) {
[17:41:11.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:11.874]         }
[17:41:11.874]         else {
[17:41:11.874]             ...future.result["stdout"] <- base::list(NULL)
[17:41:11.874]         }
[17:41:11.874]         base::close(...future.stdout)
[17:41:11.874]         ...future.stdout <- NULL
[17:41:11.874]     }
[17:41:11.874]     ...future.result$conditions <- ...future.conditions
[17:41:11.874]     ...future.result$finished <- base::Sys.time()
[17:41:11.874]     ...future.result
[17:41:11.874] }
[17:41:11.875] assign_globals() ...
[17:41:11.875] List of 5
[17:41:11.875]  $ ...future.FUN            :function (x, y)  
[17:41:11.875]  $ MoreArgs                 : NULL
[17:41:11.875]  $ ...future.elements_ii    :List of 2
[17:41:11.875]   ..$ :List of 2
[17:41:11.875]   .. ..$ : int 1
[17:41:11.875]   .. ..$ : int 0
[17:41:11.875]   ..$ :List of 2
[17:41:11.875]   .. ..$ : int 0
[17:41:11.875]   .. ..$ : int 1
[17:41:11.875]  $ ...future.seeds_ii       : NULL
[17:41:11.875]  $ ...future.globals.maxSize: NULL
[17:41:11.875]  - attr(*, "resolved")= logi FALSE
[17:41:11.875]  - attr(*, "total_size")= num 6480
[17:41:11.875]  - attr(*, "where")=List of 5
[17:41:11.875]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:11.875]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:11.875]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:11.875]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:11.875]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:11.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:11.875]  - attr(*, "already-done")= logi TRUE
[17:41:11.881] - reassign environment for ‘...future.FUN’
[17:41:11.881] - copied ‘...future.FUN’ to environment
[17:41:11.881] - copied ‘MoreArgs’ to environment
[17:41:11.881] - copied ‘...future.elements_ii’ to environment
[17:41:11.881] - copied ‘...future.seeds_ii’ to environment
[17:41:11.881] - copied ‘...future.globals.maxSize’ to environment
[17:41:11.882] assign_globals() ... done
[17:41:11.882] plan(): Setting new future strategy stack:
[17:41:11.882] List of future strategies:
[17:41:11.882] 1. sequential:
[17:41:11.882]    - args: function (..., envir = parent.frame())
[17:41:11.882]    - tweaked: FALSE
[17:41:11.882]    - call: NULL
[17:41:11.882] plan(): nbrOfWorkers() = 1
[17:41:12.384] plan(): Setting new future strategy stack:
[17:41:12.384] List of future strategies:
[17:41:12.384] 1. multicore:
[17:41:12.384]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:12.384]    - tweaked: FALSE
[17:41:12.384]    - call: plan(strategy)
[17:41:12.388] plan(): nbrOfWorkers() = 1
[17:41:12.388] SequentialFuture started (and completed)
[17:41:12.389] - Launch lazy future ... done
[17:41:12.389] run() for ‘SequentialFuture’ ... done
[17:41:12.389] Created future:
[17:41:12.389] SequentialFuture:
[17:41:12.389] Label: ‘future_mapply-1’
[17:41:12.389] Expression:
[17:41:12.389] {
[17:41:12.389]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:12.389]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:12.389]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:12.389]         on.exit(options(oopts), add = TRUE)
[17:41:12.389]     }
[17:41:12.389]     {
[17:41:12.389]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:12.389]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:12.389]         do.call(mapply, args = args)
[17:41:12.389]     }
[17:41:12.389] }
[17:41:12.389] Lazy evaluation: FALSE
[17:41:12.389] Asynchronous evaluation: FALSE
[17:41:12.389] Local evaluation: TRUE
[17:41:12.389] Environment: R_GlobalEnv
[17:41:12.389] Capture standard output: NA
[17:41:12.389] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:12.389] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:12.389] Packages: <none>
[17:41:12.389] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:12.389] Resolved: TRUE
[17:41:12.389] Value: 224 bytes of class ‘list’
[17:41:12.389] Early signaling: FALSE
[17:41:12.389] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:12.389] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:12.390] Chunk #1 of 1 ... DONE
[17:41:12.390] Launching 1 futures (chunks) ... DONE
[17:41:12.390] Resolving 1 futures (chunks) ...
[17:41:12.415] resolve() on list ...
[17:41:12.416]  recursive: 0
[17:41:12.416]  length: 1
[17:41:12.416] 
[17:41:12.416] resolved() for ‘SequentialFuture’ ...
[17:41:12.416] - state: ‘finished’
[17:41:12.416] - run: TRUE
[17:41:12.416] - result: ‘FutureResult’
[17:41:12.416] resolved() for ‘SequentialFuture’ ... done
[17:41:12.417] Future #1
[17:41:12.417] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:12.417] - nx: 1
[17:41:12.417] - relay: TRUE
[17:41:12.417] - stdout: TRUE
[17:41:12.417] - signal: TRUE
[17:41:12.417] - resignal: FALSE
[17:41:12.417] - force: TRUE
[17:41:12.417] - relayed: [n=1] FALSE
[17:41:12.418] - queued futures: [n=1] FALSE
[17:41:12.418]  - until=1
[17:41:12.418]  - relaying element #1
[17:41:12.418] - relayed: [n=1] TRUE
[17:41:12.418] - queued futures: [n=1] TRUE
[17:41:12.418] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:12.418]  length: 0 (resolved future 1)
[17:41:12.418] Relaying remaining futures
[17:41:12.418] signalConditionsASAP(NULL, pos=0) ...
[17:41:12.419] - nx: 1
[17:41:12.419] - relay: TRUE
[17:41:12.419] - stdout: TRUE
[17:41:12.419] - signal: TRUE
[17:41:12.419] - resignal: FALSE
[17:41:12.419] - force: TRUE
[17:41:12.419] - relayed: [n=1] TRUE
[17:41:12.419] - queued futures: [n=1] TRUE
 - flush all
[17:41:12.419] - relayed: [n=1] TRUE
[17:41:12.419] - queued futures: [n=1] TRUE
[17:41:12.419] signalConditionsASAP(NULL, pos=0) ... done
[17:41:12.420] resolve() on list ... DONE
[17:41:12.420]  - Number of value chunks collected: 1
[17:41:12.420] Resolving 1 futures (chunks) ... DONE
[17:41:12.420] Reducing values from 1 chunks ...
[17:41:12.420]  - Number of values collected after concatenation: 2
[17:41:12.420]  - Number of values expected: 2
[17:41:12.420] Reducing values from 1 chunks ... DONE
[17:41:12.420] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[17:41:12.421] plan(): Setting new future strategy stack:
[17:41:12.421] List of future strategies:
[17:41:12.421] 1. multisession:
[17:41:12.421]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:12.421]    - tweaked: FALSE
[17:41:12.421]    - call: plan(strategy)
[17:41:12.421] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:41:12.421] multisession:
[17:41:12.421] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:12.421] - tweaked: FALSE
[17:41:12.421] - call: plan(strategy)
[17:41:12.425] getGlobalsAndPackages() ...
[17:41:12.425] Not searching for globals
[17:41:12.425] - globals: [0] <none>
[17:41:12.425] getGlobalsAndPackages() ... DONE
[17:41:12.426] Packages needed by the future expression (n = 0): <none>
[17:41:12.426] Packages needed by future strategies (n = 0): <none>
[17:41:12.426] {
[17:41:12.426]     {
[17:41:12.426]         {
[17:41:12.426]             ...future.startTime <- base::Sys.time()
[17:41:12.426]             {
[17:41:12.426]                 {
[17:41:12.426]                   {
[17:41:12.426]                     base::local({
[17:41:12.426]                       has_future <- base::requireNamespace("future", 
[17:41:12.426]                         quietly = TRUE)
[17:41:12.426]                       if (has_future) {
[17:41:12.426]                         ns <- base::getNamespace("future")
[17:41:12.426]                         version <- ns[[".package"]][["version"]]
[17:41:12.426]                         if (is.null(version)) 
[17:41:12.426]                           version <- utils::packageVersion("future")
[17:41:12.426]                       }
[17:41:12.426]                       else {
[17:41:12.426]                         version <- NULL
[17:41:12.426]                       }
[17:41:12.426]                       if (!has_future || version < "1.8.0") {
[17:41:12.426]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:12.426]                           "", base::R.version$version.string), 
[17:41:12.426]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:12.426]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:12.426]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:12.426]                             "release", "version")], collapse = " "), 
[17:41:12.426]                           hostname = base::Sys.info()[["nodename"]])
[17:41:12.426]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:12.426]                           info)
[17:41:12.426]                         info <- base::paste(info, collapse = "; ")
[17:41:12.426]                         if (!has_future) {
[17:41:12.426]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:12.426]                             info)
[17:41:12.426]                         }
[17:41:12.426]                         else {
[17:41:12.426]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:12.426]                             info, version)
[17:41:12.426]                         }
[17:41:12.426]                         base::stop(msg)
[17:41:12.426]                       }
[17:41:12.426]                     })
[17:41:12.426]                   }
[17:41:12.426]                   options(future.plan = NULL)
[17:41:12.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:12.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:12.426]                 }
[17:41:12.426]                 ...future.workdir <- getwd()
[17:41:12.426]             }
[17:41:12.426]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:12.426]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:12.426]         }
[17:41:12.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:12.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:12.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:12.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:12.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:12.426]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:12.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:12.426]             base::names(...future.oldOptions))
[17:41:12.426]     }
[17:41:12.426]     if (FALSE) {
[17:41:12.426]     }
[17:41:12.426]     else {
[17:41:12.426]         if (TRUE) {
[17:41:12.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:12.426]                 open = "w")
[17:41:12.426]         }
[17:41:12.426]         else {
[17:41:12.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:12.426]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:12.426]         }
[17:41:12.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:12.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:12.426]             base::sink(type = "output", split = FALSE)
[17:41:12.426]             base::close(...future.stdout)
[17:41:12.426]         }, add = TRUE)
[17:41:12.426]     }
[17:41:12.426]     ...future.frame <- base::sys.nframe()
[17:41:12.426]     ...future.conditions <- base::list()
[17:41:12.426]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:12.426]     if (FALSE) {
[17:41:12.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:12.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:12.426]     }
[17:41:12.426]     ...future.result <- base::tryCatch({
[17:41:12.426]         base::withCallingHandlers({
[17:41:12.426]             ...future.value <- base::withVisible(base::local(NA))
[17:41:12.426]             future::FutureResult(value = ...future.value$value, 
[17:41:12.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:12.426]                   ...future.rng), globalenv = if (FALSE) 
[17:41:12.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:12.426]                     ...future.globalenv.names))
[17:41:12.426]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:12.426]         }, condition = base::local({
[17:41:12.426]             c <- base::c
[17:41:12.426]             inherits <- base::inherits
[17:41:12.426]             invokeRestart <- base::invokeRestart
[17:41:12.426]             length <- base::length
[17:41:12.426]             list <- base::list
[17:41:12.426]             seq.int <- base::seq.int
[17:41:12.426]             signalCondition <- base::signalCondition
[17:41:12.426]             sys.calls <- base::sys.calls
[17:41:12.426]             `[[` <- base::`[[`
[17:41:12.426]             `+` <- base::`+`
[17:41:12.426]             `<<-` <- base::`<<-`
[17:41:12.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:12.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:12.426]                   3L)]
[17:41:12.426]             }
[17:41:12.426]             function(cond) {
[17:41:12.426]                 is_error <- inherits(cond, "error")
[17:41:12.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:12.426]                   NULL)
[17:41:12.426]                 if (is_error) {
[17:41:12.426]                   sessionInformation <- function() {
[17:41:12.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:12.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:12.426]                       search = base::search(), system = base::Sys.info())
[17:41:12.426]                   }
[17:41:12.426]                   ...future.conditions[[length(...future.conditions) + 
[17:41:12.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:12.426]                     cond$call), session = sessionInformation(), 
[17:41:12.426]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:12.426]                   signalCondition(cond)
[17:41:12.426]                 }
[17:41:12.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:12.426]                 "immediateCondition"))) {
[17:41:12.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:12.426]                   ...future.conditions[[length(...future.conditions) + 
[17:41:12.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:12.426]                   if (TRUE && !signal) {
[17:41:12.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:12.426]                     {
[17:41:12.426]                       inherits <- base::inherits
[17:41:12.426]                       invokeRestart <- base::invokeRestart
[17:41:12.426]                       is.null <- base::is.null
[17:41:12.426]                       muffled <- FALSE
[17:41:12.426]                       if (inherits(cond, "message")) {
[17:41:12.426]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:12.426]                         if (muffled) 
[17:41:12.426]                           invokeRestart("muffleMessage")
[17:41:12.426]                       }
[17:41:12.426]                       else if (inherits(cond, "warning")) {
[17:41:12.426]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:12.426]                         if (muffled) 
[17:41:12.426]                           invokeRestart("muffleWarning")
[17:41:12.426]                       }
[17:41:12.426]                       else if (inherits(cond, "condition")) {
[17:41:12.426]                         if (!is.null(pattern)) {
[17:41:12.426]                           computeRestarts <- base::computeRestarts
[17:41:12.426]                           grepl <- base::grepl
[17:41:12.426]                           restarts <- computeRestarts(cond)
[17:41:12.426]                           for (restart in restarts) {
[17:41:12.426]                             name <- restart$name
[17:41:12.426]                             if (is.null(name)) 
[17:41:12.426]                               next
[17:41:12.426]                             if (!grepl(pattern, name)) 
[17:41:12.426]                               next
[17:41:12.426]                             invokeRestart(restart)
[17:41:12.426]                             muffled <- TRUE
[17:41:12.426]                             break
[17:41:12.426]                           }
[17:41:12.426]                         }
[17:41:12.426]                       }
[17:41:12.426]                       invisible(muffled)
[17:41:12.426]                     }
[17:41:12.426]                     muffleCondition(cond, pattern = "^muffle")
[17:41:12.426]                   }
[17:41:12.426]                 }
[17:41:12.426]                 else {
[17:41:12.426]                   if (TRUE) {
[17:41:12.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:12.426]                     {
[17:41:12.426]                       inherits <- base::inherits
[17:41:12.426]                       invokeRestart <- base::invokeRestart
[17:41:12.426]                       is.null <- base::is.null
[17:41:12.426]                       muffled <- FALSE
[17:41:12.426]                       if (inherits(cond, "message")) {
[17:41:12.426]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:12.426]                         if (muffled) 
[17:41:12.426]                           invokeRestart("muffleMessage")
[17:41:12.426]                       }
[17:41:12.426]                       else if (inherits(cond, "warning")) {
[17:41:12.426]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:12.426]                         if (muffled) 
[17:41:12.426]                           invokeRestart("muffleWarning")
[17:41:12.426]                       }
[17:41:12.426]                       else if (inherits(cond, "condition")) {
[17:41:12.426]                         if (!is.null(pattern)) {
[17:41:12.426]                           computeRestarts <- base::computeRestarts
[17:41:12.426]                           grepl <- base::grepl
[17:41:12.426]                           restarts <- computeRestarts(cond)
[17:41:12.426]                           for (restart in restarts) {
[17:41:12.426]                             name <- restart$name
[17:41:12.426]                             if (is.null(name)) 
[17:41:12.426]                               next
[17:41:12.426]                             if (!grepl(pattern, name)) 
[17:41:12.426]                               next
[17:41:12.426]                             invokeRestart(restart)
[17:41:12.426]                             muffled <- TRUE
[17:41:12.426]                             break
[17:41:12.426]                           }
[17:41:12.426]                         }
[17:41:12.426]                       }
[17:41:12.426]                       invisible(muffled)
[17:41:12.426]                     }
[17:41:12.426]                     muffleCondition(cond, pattern = "^muffle")
[17:41:12.426]                   }
[17:41:12.426]                 }
[17:41:12.426]             }
[17:41:12.426]         }))
[17:41:12.426]     }, error = function(ex) {
[17:41:12.426]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:12.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:12.426]                 ...future.rng), started = ...future.startTime, 
[17:41:12.426]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:12.426]             version = "1.8"), class = "FutureResult")
[17:41:12.426]     }, finally = {
[17:41:12.426]         if (!identical(...future.workdir, getwd())) 
[17:41:12.426]             setwd(...future.workdir)
[17:41:12.426]         {
[17:41:12.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:12.426]                 ...future.oldOptions$nwarnings <- NULL
[17:41:12.426]             }
[17:41:12.426]             base::options(...future.oldOptions)
[17:41:12.426]             if (.Platform$OS.type == "windows") {
[17:41:12.426]                 old_names <- names(...future.oldEnvVars)
[17:41:12.426]                 envs <- base::Sys.getenv()
[17:41:12.426]                 names <- names(envs)
[17:41:12.426]                 common <- intersect(names, old_names)
[17:41:12.426]                 added <- setdiff(names, old_names)
[17:41:12.426]                 removed <- setdiff(old_names, names)
[17:41:12.426]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:12.426]                   envs[common]]
[17:41:12.426]                 NAMES <- toupper(changed)
[17:41:12.426]                 args <- list()
[17:41:12.426]                 for (kk in seq_along(NAMES)) {
[17:41:12.426]                   name <- changed[[kk]]
[17:41:12.426]                   NAME <- NAMES[[kk]]
[17:41:12.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:12.426]                     next
[17:41:12.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:12.426]                 }
[17:41:12.426]                 NAMES <- toupper(added)
[17:41:12.426]                 for (kk in seq_along(NAMES)) {
[17:41:12.426]                   name <- added[[kk]]
[17:41:12.426]                   NAME <- NAMES[[kk]]
[17:41:12.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:12.426]                     next
[17:41:12.426]                   args[[name]] <- ""
[17:41:12.426]                 }
[17:41:12.426]                 NAMES <- toupper(removed)
[17:41:12.426]                 for (kk in seq_along(NAMES)) {
[17:41:12.426]                   name <- removed[[kk]]
[17:41:12.426]                   NAME <- NAMES[[kk]]
[17:41:12.426]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:12.426]                     next
[17:41:12.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:12.426]                 }
[17:41:12.426]                 if (length(args) > 0) 
[17:41:12.426]                   base::do.call(base::Sys.setenv, args = args)
[17:41:12.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:12.426]             }
[17:41:12.426]             else {
[17:41:12.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:12.426]             }
[17:41:12.426]             {
[17:41:12.426]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:12.426]                   0L) {
[17:41:12.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:12.426]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:12.426]                   base::options(opts)
[17:41:12.426]                 }
[17:41:12.426]                 {
[17:41:12.426]                   {
[17:41:12.426]                     NULL
[17:41:12.426]                     RNGkind("Mersenne-Twister")
[17:41:12.426]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:12.426]                       inherits = FALSE)
[17:41:12.426]                   }
[17:41:12.426]                   options(future.plan = NULL)
[17:41:12.426]                   if (is.na(NA_character_)) 
[17:41:12.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:12.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:12.426]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:12.426]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:12.426]                     envir = parent.frame()) 
[17:41:12.426]                   {
[17:41:12.426]                     if (is.function(workers)) 
[17:41:12.426]                       workers <- workers()
[17:41:12.426]                     workers <- structure(as.integer(workers), 
[17:41:12.426]                       class = class(workers))
[17:41:12.426]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:12.426]                       workers >= 1)
[17:41:12.426]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:12.426]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:12.426]                     }
[17:41:12.426]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:12.426]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:12.426]                       envir = envir)
[17:41:12.426]                     if (!future$lazy) 
[17:41:12.426]                       future <- run(future)
[17:41:12.426]                     invisible(future)
[17:41:12.426]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:12.426]                 }
[17:41:12.426]             }
[17:41:12.426]         }
[17:41:12.426]     })
[17:41:12.426]     if (TRUE) {
[17:41:12.426]         base::sink(type = "output", split = FALSE)
[17:41:12.426]         if (TRUE) {
[17:41:12.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:12.426]         }
[17:41:12.426]         else {
[17:41:12.426]             ...future.result["stdout"] <- base::list(NULL)
[17:41:12.426]         }
[17:41:12.426]         base::close(...future.stdout)
[17:41:12.426]         ...future.stdout <- NULL
[17:41:12.426]     }
[17:41:12.426]     ...future.result$conditions <- ...future.conditions
[17:41:12.426]     ...future.result$finished <- base::Sys.time()
[17:41:12.426]     ...future.result
[17:41:12.426] }
[17:41:12.428] plan(): Setting new future strategy stack:
[17:41:12.428] List of future strategies:
[17:41:12.428] 1. sequential:
[17:41:12.428]    - args: function (..., envir = parent.frame())
[17:41:12.428]    - tweaked: FALSE
[17:41:12.428]    - call: NULL
[17:41:12.429] plan(): nbrOfWorkers() = 1
[17:41:12.429] plan(): Setting new future strategy stack:
[17:41:12.429] List of future strategies:
[17:41:12.429] 1. multisession:
[17:41:12.429]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:12.429]    - tweaked: FALSE
[17:41:12.429]    - call: plan(strategy)
[17:41:12.433] plan(): nbrOfWorkers() = 1
[17:41:12.433] SequentialFuture started (and completed)
[17:41:12.433] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:41:12.436] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:41:12.437] future_lapply() ...
[17:41:12.440] Number of chunks: 1
[17:41:12.440] getGlobalsAndPackagesXApply() ...
[17:41:12.440]  - future.globals: TRUE
[17:41:12.441] getGlobalsAndPackages() ...
[17:41:12.441] Searching for globals...
[17:41:12.442] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:12.442] Searching for globals ... DONE
[17:41:12.442] Resolving globals: FALSE
[17:41:12.443] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:12.443] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:12.443] - globals: [1] ‘FUN’
[17:41:12.443] 
[17:41:12.443] getGlobalsAndPackages() ... DONE
[17:41:12.443]  - globals found/used: [n=1] ‘FUN’
[17:41:12.443]  - needed namespaces: [n=0] 
[17:41:12.444] Finding globals ... DONE
[17:41:12.444]  - use_args: TRUE
[17:41:12.444]  - Getting '...' globals ...
[17:41:12.444] resolve() on list ...
[17:41:12.444]  recursive: 0
[17:41:12.444]  length: 1
[17:41:12.444]  elements: ‘...’
[17:41:12.444]  length: 0 (resolved future 1)
[17:41:12.445] resolve() on list ... DONE
[17:41:12.445]    - '...' content: [n=0] 
[17:41:12.445] List of 1
[17:41:12.445]  $ ...: list()
[17:41:12.445]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:12.445]  - attr(*, "where")=List of 1
[17:41:12.445]   ..$ ...:<environment: 0x55c9885540f0> 
[17:41:12.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:12.445]  - attr(*, "resolved")= logi TRUE
[17:41:12.445]  - attr(*, "total_size")= num NA
[17:41:12.447]  - Getting '...' globals ... DONE
[17:41:12.447] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:12.447] List of 2
[17:41:12.447]  $ ...future.FUN:function (x)  
[17:41:12.447]  $ ...          : list()
[17:41:12.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:12.447]  - attr(*, "where")=List of 2
[17:41:12.447]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:12.447]   ..$ ...          :<environment: 0x55c9885540f0> 
[17:41:12.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:12.447]  - attr(*, "resolved")= logi FALSE
[17:41:12.447]  - attr(*, "total_size")= num 4720
[17:41:12.450] Packages to be attached in all futures: [n=0] 
[17:41:12.450] getGlobalsAndPackagesXApply() ... DONE
[17:41:12.451] Number of futures (= number of chunks): 1
[17:41:12.452] Launching 1 futures (chunks) ...
[17:41:12.452] Chunk #1 of 1 ...
[17:41:12.452]  - Finding globals in 'X' for chunk #1 ...
[17:41:12.452] getGlobalsAndPackages() ...
[17:41:12.452] Searching for globals...
[17:41:12.452] 
[17:41:12.452] Searching for globals ... DONE
[17:41:12.453] - globals: [0] <none>
[17:41:12.453] getGlobalsAndPackages() ... DONE
[17:41:12.453]    + additional globals found: [n=0] 
[17:41:12.453]    + additional namespaces needed: [n=0] 
[17:41:12.453]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:12.453]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:12.453]  - seeds: <none>
[17:41:12.453] getGlobalsAndPackages() ...
[17:41:12.453] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:12.454] Resolving globals: FALSE
[17:41:12.454] Tweak future expression to call with '...' arguments ...
[17:41:12.454] {
[17:41:12.454]     do.call(function(...) {
[17:41:12.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:12.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:12.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:12.454]             on.exit(options(oopts), add = TRUE)
[17:41:12.454]         }
[17:41:12.454]         {
[17:41:12.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:12.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:12.454]                 ...future.FUN(...future.X_jj, ...)
[17:41:12.454]             })
[17:41:12.454]         }
[17:41:12.454]     }, args = future.call.arguments)
[17:41:12.454] }
[17:41:12.454] Tweak future expression to call with '...' arguments ... DONE
[17:41:12.454] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:12.454] 
[17:41:12.455] getGlobalsAndPackages() ... DONE
[17:41:12.455] run() for ‘Future’ ...
[17:41:12.455] - state: ‘created’
[17:41:12.455] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:12.458] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:12.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:12.459]   - Field: ‘label’
[17:41:12.459]   - Field: ‘local’
[17:41:12.459]   - Field: ‘owner’
[17:41:12.459]   - Field: ‘envir’
[17:41:12.459]   - Field: ‘packages’
[17:41:12.459]   - Field: ‘gc’
[17:41:12.459]   - Field: ‘conditions’
[17:41:12.459]   - Field: ‘expr’
[17:41:12.459]   - Field: ‘uuid’
[17:41:12.459]   - Field: ‘seed’
[17:41:12.460]   - Field: ‘version’
[17:41:12.460]   - Field: ‘result’
[17:41:12.460]   - Field: ‘asynchronous’
[17:41:12.460]   - Field: ‘calls’
[17:41:12.460]   - Field: ‘globals’
[17:41:12.460]   - Field: ‘stdout’
[17:41:12.460]   - Field: ‘earlySignal’
[17:41:12.460]   - Field: ‘lazy’
[17:41:12.460]   - Field: ‘state’
[17:41:12.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:12.460] - Launch lazy future ...
[17:41:12.461] Packages needed by the future expression (n = 0): <none>
[17:41:12.461] Packages needed by future strategies (n = 0): <none>
[17:41:12.461] {
[17:41:12.461]     {
[17:41:12.461]         {
[17:41:12.461]             ...future.startTime <- base::Sys.time()
[17:41:12.461]             {
[17:41:12.461]                 {
[17:41:12.461]                   {
[17:41:12.461]                     base::local({
[17:41:12.461]                       has_future <- base::requireNamespace("future", 
[17:41:12.461]                         quietly = TRUE)
[17:41:12.461]                       if (has_future) {
[17:41:12.461]                         ns <- base::getNamespace("future")
[17:41:12.461]                         version <- ns[[".package"]][["version"]]
[17:41:12.461]                         if (is.null(version)) 
[17:41:12.461]                           version <- utils::packageVersion("future")
[17:41:12.461]                       }
[17:41:12.461]                       else {
[17:41:12.461]                         version <- NULL
[17:41:12.461]                       }
[17:41:12.461]                       if (!has_future || version < "1.8.0") {
[17:41:12.461]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:12.461]                           "", base::R.version$version.string), 
[17:41:12.461]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:12.461]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:12.461]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:12.461]                             "release", "version")], collapse = " "), 
[17:41:12.461]                           hostname = base::Sys.info()[["nodename"]])
[17:41:12.461]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:12.461]                           info)
[17:41:12.461]                         info <- base::paste(info, collapse = "; ")
[17:41:12.461]                         if (!has_future) {
[17:41:12.461]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:12.461]                             info)
[17:41:12.461]                         }
[17:41:12.461]                         else {
[17:41:12.461]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:12.461]                             info, version)
[17:41:12.461]                         }
[17:41:12.461]                         base::stop(msg)
[17:41:12.461]                       }
[17:41:12.461]                     })
[17:41:12.461]                   }
[17:41:12.461]                   options(future.plan = NULL)
[17:41:12.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:12.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:12.461]                 }
[17:41:12.461]                 ...future.workdir <- getwd()
[17:41:12.461]             }
[17:41:12.461]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:12.461]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:12.461]         }
[17:41:12.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:12.461]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:12.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:12.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:12.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:12.461]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:12.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:12.461]             base::names(...future.oldOptions))
[17:41:12.461]     }
[17:41:12.461]     if (FALSE) {
[17:41:12.461]     }
[17:41:12.461]     else {
[17:41:12.461]         if (FALSE) {
[17:41:12.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:12.461]                 open = "w")
[17:41:12.461]         }
[17:41:12.461]         else {
[17:41:12.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:12.461]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:12.461]         }
[17:41:12.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:12.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:12.461]             base::sink(type = "output", split = FALSE)
[17:41:12.461]             base::close(...future.stdout)
[17:41:12.461]         }, add = TRUE)
[17:41:12.461]     }
[17:41:12.461]     ...future.frame <- base::sys.nframe()
[17:41:12.461]     ...future.conditions <- base::list()
[17:41:12.461]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:12.461]     if (FALSE) {
[17:41:12.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:12.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:12.461]     }
[17:41:12.461]     ...future.result <- base::tryCatch({
[17:41:12.461]         base::withCallingHandlers({
[17:41:12.461]             ...future.value <- base::withVisible(base::local({
[17:41:12.461]                 do.call(function(...) {
[17:41:12.461]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:12.461]                   if (!identical(...future.globals.maxSize.org, 
[17:41:12.461]                     ...future.globals.maxSize)) {
[17:41:12.461]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:12.461]                     on.exit(options(oopts), add = TRUE)
[17:41:12.461]                   }
[17:41:12.461]                   {
[17:41:12.461]                     lapply(seq_along(...future.elements_ii), 
[17:41:12.461]                       FUN = function(jj) {
[17:41:12.461]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:12.461]                         ...future.FUN(...future.X_jj, ...)
[17:41:12.461]                       })
[17:41:12.461]                   }
[17:41:12.461]                 }, args = future.call.arguments)
[17:41:12.461]             }))
[17:41:12.461]             future::FutureResult(value = ...future.value$value, 
[17:41:12.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:12.461]                   ...future.rng), globalenv = if (FALSE) 
[17:41:12.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:12.461]                     ...future.globalenv.names))
[17:41:12.461]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:12.461]         }, condition = base::local({
[17:41:12.461]             c <- base::c
[17:41:12.461]             inherits <- base::inherits
[17:41:12.461]             invokeRestart <- base::invokeRestart
[17:41:12.461]             length <- base::length
[17:41:12.461]             list <- base::list
[17:41:12.461]             seq.int <- base::seq.int
[17:41:12.461]             signalCondition <- base::signalCondition
[17:41:12.461]             sys.calls <- base::sys.calls
[17:41:12.461]             `[[` <- base::`[[`
[17:41:12.461]             `+` <- base::`+`
[17:41:12.461]             `<<-` <- base::`<<-`
[17:41:12.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:12.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:12.461]                   3L)]
[17:41:12.461]             }
[17:41:12.461]             function(cond) {
[17:41:12.461]                 is_error <- inherits(cond, "error")
[17:41:12.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:12.461]                   NULL)
[17:41:12.461]                 if (is_error) {
[17:41:12.461]                   sessionInformation <- function() {
[17:41:12.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:12.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:12.461]                       search = base::search(), system = base::Sys.info())
[17:41:12.461]                   }
[17:41:12.461]                   ...future.conditions[[length(...future.conditions) + 
[17:41:12.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:12.461]                     cond$call), session = sessionInformation(), 
[17:41:12.461]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:12.461]                   signalCondition(cond)
[17:41:12.461]                 }
[17:41:12.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:12.461]                 "immediateCondition"))) {
[17:41:12.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:12.461]                   ...future.conditions[[length(...future.conditions) + 
[17:41:12.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:12.461]                   if (TRUE && !signal) {
[17:41:12.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:12.461]                     {
[17:41:12.461]                       inherits <- base::inherits
[17:41:12.461]                       invokeRestart <- base::invokeRestart
[17:41:12.461]                       is.null <- base::is.null
[17:41:12.461]                       muffled <- FALSE
[17:41:12.461]                       if (inherits(cond, "message")) {
[17:41:12.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:12.461]                         if (muffled) 
[17:41:12.461]                           invokeRestart("muffleMessage")
[17:41:12.461]                       }
[17:41:12.461]                       else if (inherits(cond, "warning")) {
[17:41:12.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:12.461]                         if (muffled) 
[17:41:12.461]                           invokeRestart("muffleWarning")
[17:41:12.461]                       }
[17:41:12.461]                       else if (inherits(cond, "condition")) {
[17:41:12.461]                         if (!is.null(pattern)) {
[17:41:12.461]                           computeRestarts <- base::computeRestarts
[17:41:12.461]                           grepl <- base::grepl
[17:41:12.461]                           restarts <- computeRestarts(cond)
[17:41:12.461]                           for (restart in restarts) {
[17:41:12.461]                             name <- restart$name
[17:41:12.461]                             if (is.null(name)) 
[17:41:12.461]                               next
[17:41:12.461]                             if (!grepl(pattern, name)) 
[17:41:12.461]                               next
[17:41:12.461]                             invokeRestart(restart)
[17:41:12.461]                             muffled <- TRUE
[17:41:12.461]                             break
[17:41:12.461]                           }
[17:41:12.461]                         }
[17:41:12.461]                       }
[17:41:12.461]                       invisible(muffled)
[17:41:12.461]                     }
[17:41:12.461]                     muffleCondition(cond, pattern = "^muffle")
[17:41:12.461]                   }
[17:41:12.461]                 }
[17:41:12.461]                 else {
[17:41:12.461]                   if (TRUE) {
[17:41:12.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:12.461]                     {
[17:41:12.461]                       inherits <- base::inherits
[17:41:12.461]                       invokeRestart <- base::invokeRestart
[17:41:12.461]                       is.null <- base::is.null
[17:41:12.461]                       muffled <- FALSE
[17:41:12.461]                       if (inherits(cond, "message")) {
[17:41:12.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:12.461]                         if (muffled) 
[17:41:12.461]                           invokeRestart("muffleMessage")
[17:41:12.461]                       }
[17:41:12.461]                       else if (inherits(cond, "warning")) {
[17:41:12.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:12.461]                         if (muffled) 
[17:41:12.461]                           invokeRestart("muffleWarning")
[17:41:12.461]                       }
[17:41:12.461]                       else if (inherits(cond, "condition")) {
[17:41:12.461]                         if (!is.null(pattern)) {
[17:41:12.461]                           computeRestarts <- base::computeRestarts
[17:41:12.461]                           grepl <- base::grepl
[17:41:12.461]                           restarts <- computeRestarts(cond)
[17:41:12.461]                           for (restart in restarts) {
[17:41:12.461]                             name <- restart$name
[17:41:12.461]                             if (is.null(name)) 
[17:41:12.461]                               next
[17:41:12.461]                             if (!grepl(pattern, name)) 
[17:41:12.461]                               next
[17:41:12.461]                             invokeRestart(restart)
[17:41:12.461]                             muffled <- TRUE
[17:41:12.461]                             break
[17:41:12.461]                           }
[17:41:12.461]                         }
[17:41:12.461]                       }
[17:41:12.461]                       invisible(muffled)
[17:41:12.461]                     }
[17:41:12.461]                     muffleCondition(cond, pattern = "^muffle")
[17:41:12.461]                   }
[17:41:12.461]                 }
[17:41:12.461]             }
[17:41:12.461]         }))
[17:41:12.461]     }, error = function(ex) {
[17:41:12.461]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:12.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:12.461]                 ...future.rng), started = ...future.startTime, 
[17:41:12.461]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:12.461]             version = "1.8"), class = "FutureResult")
[17:41:12.461]     }, finally = {
[17:41:12.461]         if (!identical(...future.workdir, getwd())) 
[17:41:12.461]             setwd(...future.workdir)
[17:41:12.461]         {
[17:41:12.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:12.461]                 ...future.oldOptions$nwarnings <- NULL
[17:41:12.461]             }
[17:41:12.461]             base::options(...future.oldOptions)
[17:41:12.461]             if (.Platform$OS.type == "windows") {
[17:41:12.461]                 old_names <- names(...future.oldEnvVars)
[17:41:12.461]                 envs <- base::Sys.getenv()
[17:41:12.461]                 names <- names(envs)
[17:41:12.461]                 common <- intersect(names, old_names)
[17:41:12.461]                 added <- setdiff(names, old_names)
[17:41:12.461]                 removed <- setdiff(old_names, names)
[17:41:12.461]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:12.461]                   envs[common]]
[17:41:12.461]                 NAMES <- toupper(changed)
[17:41:12.461]                 args <- list()
[17:41:12.461]                 for (kk in seq_along(NAMES)) {
[17:41:12.461]                   name <- changed[[kk]]
[17:41:12.461]                   NAME <- NAMES[[kk]]
[17:41:12.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:12.461]                     next
[17:41:12.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:12.461]                 }
[17:41:12.461]                 NAMES <- toupper(added)
[17:41:12.461]                 for (kk in seq_along(NAMES)) {
[17:41:12.461]                   name <- added[[kk]]
[17:41:12.461]                   NAME <- NAMES[[kk]]
[17:41:12.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:12.461]                     next
[17:41:12.461]                   args[[name]] <- ""
[17:41:12.461]                 }
[17:41:12.461]                 NAMES <- toupper(removed)
[17:41:12.461]                 for (kk in seq_along(NAMES)) {
[17:41:12.461]                   name <- removed[[kk]]
[17:41:12.461]                   NAME <- NAMES[[kk]]
[17:41:12.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:12.461]                     next
[17:41:12.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:12.461]                 }
[17:41:12.461]                 if (length(args) > 0) 
[17:41:12.461]                   base::do.call(base::Sys.setenv, args = args)
[17:41:12.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:12.461]             }
[17:41:12.461]             else {
[17:41:12.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:12.461]             }
[17:41:12.461]             {
[17:41:12.461]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:12.461]                   0L) {
[17:41:12.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:12.461]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:12.461]                   base::options(opts)
[17:41:12.461]                 }
[17:41:12.461]                 {
[17:41:12.461]                   {
[17:41:12.461]                     NULL
[17:41:12.461]                     RNGkind("Mersenne-Twister")
[17:41:12.461]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:12.461]                       inherits = FALSE)
[17:41:12.461]                   }
[17:41:12.461]                   options(future.plan = NULL)
[17:41:12.461]                   if (is.na(NA_character_)) 
[17:41:12.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:12.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:12.461]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:12.461]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:12.461]                     envir = parent.frame()) 
[17:41:12.461]                   {
[17:41:12.461]                     if (is.function(workers)) 
[17:41:12.461]                       workers <- workers()
[17:41:12.461]                     workers <- structure(as.integer(workers), 
[17:41:12.461]                       class = class(workers))
[17:41:12.461]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:12.461]                       workers >= 1)
[17:41:12.461]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:12.461]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:12.461]                     }
[17:41:12.461]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:12.461]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:12.461]                       envir = envir)
[17:41:12.461]                     if (!future$lazy) 
[17:41:12.461]                       future <- run(future)
[17:41:12.461]                     invisible(future)
[17:41:12.461]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:12.461]                 }
[17:41:12.461]             }
[17:41:12.461]         }
[17:41:12.461]     })
[17:41:12.461]     if (TRUE) {
[17:41:12.461]         base::sink(type = "output", split = FALSE)
[17:41:12.461]         if (FALSE) {
[17:41:12.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:12.461]         }
[17:41:12.461]         else {
[17:41:12.461]             ...future.result["stdout"] <- base::list(NULL)
[17:41:12.461]         }
[17:41:12.461]         base::close(...future.stdout)
[17:41:12.461]         ...future.stdout <- NULL
[17:41:12.461]     }
[17:41:12.461]     ...future.result$conditions <- ...future.conditions
[17:41:12.461]     ...future.result$finished <- base::Sys.time()
[17:41:12.461]     ...future.result
[17:41:12.461] }
[17:41:12.463] assign_globals() ...
[17:41:12.463] List of 5
[17:41:12.463]  $ ...future.FUN            :function (x)  
[17:41:12.463]  $ future.call.arguments    : list()
[17:41:12.463]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:12.463]  $ ...future.elements_ii    :List of 2
[17:41:12.463]   ..$ : int 1
[17:41:12.463]   ..$ : int 0
[17:41:12.463]  $ ...future.seeds_ii       : NULL
[17:41:12.463]  $ ...future.globals.maxSize: NULL
[17:41:12.463]  - attr(*, "resolved")= logi FALSE
[17:41:12.463]  - attr(*, "total_size")= num 4720
[17:41:12.463]  - attr(*, "where")=List of 5
[17:41:12.463]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:12.463]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:12.463]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:12.463]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:12.463]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:12.463]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:12.463]  - attr(*, "already-done")= logi TRUE
[17:41:12.469] - reassign environment for ‘...future.FUN’
[17:41:12.469] - copied ‘...future.FUN’ to environment
[17:41:12.469] - copied ‘future.call.arguments’ to environment
[17:41:12.469] - copied ‘...future.elements_ii’ to environment
[17:41:12.469] - copied ‘...future.seeds_ii’ to environment
[17:41:12.469] - copied ‘...future.globals.maxSize’ to environment
[17:41:12.469] assign_globals() ... done
[17:41:12.469] plan(): Setting new future strategy stack:
[17:41:12.469] List of future strategies:
[17:41:12.469] 1. sequential:
[17:41:12.469]    - args: function (..., envir = parent.frame())
[17:41:12.469]    - tweaked: FALSE
[17:41:12.469]    - call: NULL
[17:41:12.470] plan(): nbrOfWorkers() = 1
[17:41:12.971] plan(): Setting new future strategy stack:
[17:41:12.972] List of future strategies:
[17:41:12.972] 1. multisession:
[17:41:12.972]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:12.972]    - tweaked: FALSE
[17:41:12.972]    - call: plan(strategy)
[17:41:12.976] plan(): nbrOfWorkers() = 1
[17:41:12.976] SequentialFuture started (and completed)
[17:41:12.976] - Launch lazy future ... done
[17:41:12.976] run() for ‘SequentialFuture’ ... done
[17:41:12.976] Created future:
[17:41:12.976] SequentialFuture:
[17:41:12.976] Label: ‘future_lapply-1’
[17:41:12.976] Expression:
[17:41:12.976] {
[17:41:12.976]     do.call(function(...) {
[17:41:12.976]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:12.976]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:12.976]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:12.976]             on.exit(options(oopts), add = TRUE)
[17:41:12.976]         }
[17:41:12.976]         {
[17:41:12.976]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:12.976]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:12.976]                 ...future.FUN(...future.X_jj, ...)
[17:41:12.976]             })
[17:41:12.976]         }
[17:41:12.976]     }, args = future.call.arguments)
[17:41:12.976] }
[17:41:12.976] Lazy evaluation: FALSE
[17:41:12.976] Asynchronous evaluation: FALSE
[17:41:12.976] Local evaluation: TRUE
[17:41:12.976] Environment: R_GlobalEnv
[17:41:12.976] Capture standard output: FALSE
[17:41:12.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:12.976] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:12.976] Packages: <none>
[17:41:12.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:12.976] Resolved: TRUE
[17:41:12.976] Value: 112 bytes of class ‘list’
[17:41:12.976] Early signaling: FALSE
[17:41:12.976] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:12.976] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:12.978] Chunk #1 of 1 ... DONE
[17:41:12.978] Launching 1 futures (chunks) ... DONE
[17:41:12.978] Resolving 1 futures (chunks) ...
[17:41:12.978] resolve() on list ...
[17:41:12.978]  recursive: 0
[17:41:12.978]  length: 1
[17:41:12.978] 
[17:41:12.978] resolved() for ‘SequentialFuture’ ...
[17:41:12.978] - state: ‘finished’
[17:41:12.978] - run: TRUE
[17:41:12.979] - result: ‘FutureResult’
[17:41:12.979] resolved() for ‘SequentialFuture’ ... done
[17:41:12.979] Future #1
[17:41:12.979] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:12.979] - nx: 1
[17:41:12.979] - relay: TRUE
[17:41:12.979] - stdout: TRUE
[17:41:12.979] - signal: TRUE
[17:41:12.979] - resignal: FALSE
[17:41:12.979] - force: TRUE
[17:41:12.979] - relayed: [n=1] FALSE
[17:41:12.980] - queued futures: [n=1] FALSE
[17:41:12.980]  - until=1
[17:41:12.980]  - relaying element #1
[17:41:12.980] - relayed: [n=1] TRUE
[17:41:12.980] - queued futures: [n=1] TRUE
[17:41:12.980] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:12.980]  length: 0 (resolved future 1)
[17:41:12.980] Relaying remaining futures
[17:41:12.980] signalConditionsASAP(NULL, pos=0) ...
[17:41:12.981] - nx: 1
[17:41:12.981] - relay: TRUE
[17:41:12.981] - stdout: TRUE
[17:41:12.981] - signal: TRUE
[17:41:12.981] - resignal: FALSE
[17:41:12.981] - force: TRUE
[17:41:12.981] - relayed: [n=1] TRUE
[17:41:12.981] - queued futures: [n=1] TRUE
 - flush all
[17:41:12.981] - relayed: [n=1] TRUE
[17:41:12.981] - queued futures: [n=1] TRUE
[17:41:12.981] signalConditionsASAP(NULL, pos=0) ... done
[17:41:12.982] resolve() on list ... DONE
[17:41:12.982]  - Number of value chunks collected: 1
[17:41:12.982] Resolving 1 futures (chunks) ... DONE
[17:41:12.982] Reducing values from 1 chunks ...
[17:41:12.982]  - Number of values collected after concatenation: 2
[17:41:12.982]  - Number of values expected: 2
[17:41:12.982] Reducing values from 1 chunks ... DONE
[17:41:12.982] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:41:12.983] future_lapply() ...
[17:41:12.988] Number of chunks: 1
[17:41:12.988] getGlobalsAndPackagesXApply() ...
[17:41:12.988]  - future.globals: TRUE
[17:41:12.988] getGlobalsAndPackages() ...
[17:41:12.988] Searching for globals...
[17:41:12.990] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:12.990] Searching for globals ... DONE
[17:41:12.990] Resolving globals: FALSE
[17:41:12.990] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:12.991] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:12.991] - globals: [1] ‘FUN’
[17:41:12.991] 
[17:41:12.991] getGlobalsAndPackages() ... DONE
[17:41:12.991]  - globals found/used: [n=1] ‘FUN’
[17:41:12.991]  - needed namespaces: [n=0] 
[17:41:12.991] Finding globals ... DONE
[17:41:12.992]  - use_args: TRUE
[17:41:12.992]  - Getting '...' globals ...
[17:41:12.992] resolve() on list ...
[17:41:12.992]  recursive: 0
[17:41:12.992]  length: 1
[17:41:12.992]  elements: ‘...’
[17:41:12.992]  length: 0 (resolved future 1)
[17:41:12.992] resolve() on list ... DONE
[17:41:12.992]    - '...' content: [n=0] 
[17:41:12.993] List of 1
[17:41:12.993]  $ ...: list()
[17:41:12.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:12.993]  - attr(*, "where")=List of 1
[17:41:12.993]   ..$ ...:<environment: 0x55c988e70a00> 
[17:41:12.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:12.993]  - attr(*, "resolved")= logi TRUE
[17:41:12.993]  - attr(*, "total_size")= num NA
[17:41:12.995]  - Getting '...' globals ... DONE
[17:41:12.995] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:12.995] List of 2
[17:41:12.995]  $ ...future.FUN:function (x)  
[17:41:12.995]  $ ...          : list()
[17:41:12.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:12.995]  - attr(*, "where")=List of 2
[17:41:12.995]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:12.995]   ..$ ...          :<environment: 0x55c988e70a00> 
[17:41:12.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:12.995]  - attr(*, "resolved")= logi FALSE
[17:41:12.995]  - attr(*, "total_size")= num 4720
[17:41:12.998] Packages to be attached in all futures: [n=0] 
[17:41:12.998] getGlobalsAndPackagesXApply() ... DONE
[17:41:12.998] Number of futures (= number of chunks): 1
[17:41:12.998] Launching 1 futures (chunks) ...
[17:41:12.998] Chunk #1 of 1 ...
[17:41:12.999]  - Finding globals in 'X' for chunk #1 ...
[17:41:12.999] getGlobalsAndPackages() ...
[17:41:12.999] Searching for globals...
[17:41:12.999] 
[17:41:12.999] Searching for globals ... DONE
[17:41:12.999] - globals: [0] <none>
[17:41:12.999] getGlobalsAndPackages() ... DONE
[17:41:12.999]    + additional globals found: [n=0] 
[17:41:13.000]    + additional namespaces needed: [n=0] 
[17:41:13.000]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:13.000]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:13.000]  - seeds: <none>
[17:41:13.000] getGlobalsAndPackages() ...
[17:41:13.000] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:13.000] Resolving globals: FALSE
[17:41:13.000] Tweak future expression to call with '...' arguments ...
[17:41:13.000] {
[17:41:13.000]     do.call(function(...) {
[17:41:13.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:13.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:13.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:13.000]             on.exit(options(oopts), add = TRUE)
[17:41:13.000]         }
[17:41:13.000]         {
[17:41:13.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:13.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:13.000]                 ...future.FUN(...future.X_jj, ...)
[17:41:13.000]             })
[17:41:13.000]         }
[17:41:13.000]     }, args = future.call.arguments)
[17:41:13.000] }
[17:41:13.001] Tweak future expression to call with '...' arguments ... DONE
[17:41:13.001] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:13.001] 
[17:41:13.001] getGlobalsAndPackages() ... DONE
[17:41:13.001] run() for ‘Future’ ...
[17:41:13.002] - state: ‘created’
[17:41:13.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:13.005] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:13.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:13.005]   - Field: ‘label’
[17:41:13.005]   - Field: ‘local’
[17:41:13.006]   - Field: ‘owner’
[17:41:13.006]   - Field: ‘envir’
[17:41:13.006]   - Field: ‘packages’
[17:41:13.006]   - Field: ‘gc’
[17:41:13.006]   - Field: ‘conditions’
[17:41:13.006]   - Field: ‘expr’
[17:41:13.006]   - Field: ‘uuid’
[17:41:13.006]   - Field: ‘seed’
[17:41:13.006]   - Field: ‘version’
[17:41:13.006]   - Field: ‘result’
[17:41:13.006]   - Field: ‘asynchronous’
[17:41:13.007]   - Field: ‘calls’
[17:41:13.007]   - Field: ‘globals’
[17:41:13.007]   - Field: ‘stdout’
[17:41:13.007]   - Field: ‘earlySignal’
[17:41:13.007]   - Field: ‘lazy’
[17:41:13.007]   - Field: ‘state’
[17:41:13.007] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:13.007] - Launch lazy future ...
[17:41:13.007] Packages needed by the future expression (n = 0): <none>
[17:41:13.008] Packages needed by future strategies (n = 0): <none>
[17:41:13.008] {
[17:41:13.008]     {
[17:41:13.008]         {
[17:41:13.008]             ...future.startTime <- base::Sys.time()
[17:41:13.008]             {
[17:41:13.008]                 {
[17:41:13.008]                   {
[17:41:13.008]                     base::local({
[17:41:13.008]                       has_future <- base::requireNamespace("future", 
[17:41:13.008]                         quietly = TRUE)
[17:41:13.008]                       if (has_future) {
[17:41:13.008]                         ns <- base::getNamespace("future")
[17:41:13.008]                         version <- ns[[".package"]][["version"]]
[17:41:13.008]                         if (is.null(version)) 
[17:41:13.008]                           version <- utils::packageVersion("future")
[17:41:13.008]                       }
[17:41:13.008]                       else {
[17:41:13.008]                         version <- NULL
[17:41:13.008]                       }
[17:41:13.008]                       if (!has_future || version < "1.8.0") {
[17:41:13.008]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:13.008]                           "", base::R.version$version.string), 
[17:41:13.008]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:13.008]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:13.008]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:13.008]                             "release", "version")], collapse = " "), 
[17:41:13.008]                           hostname = base::Sys.info()[["nodename"]])
[17:41:13.008]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:13.008]                           info)
[17:41:13.008]                         info <- base::paste(info, collapse = "; ")
[17:41:13.008]                         if (!has_future) {
[17:41:13.008]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:13.008]                             info)
[17:41:13.008]                         }
[17:41:13.008]                         else {
[17:41:13.008]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:13.008]                             info, version)
[17:41:13.008]                         }
[17:41:13.008]                         base::stop(msg)
[17:41:13.008]                       }
[17:41:13.008]                     })
[17:41:13.008]                   }
[17:41:13.008]                   options(future.plan = NULL)
[17:41:13.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:13.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:13.008]                 }
[17:41:13.008]                 ...future.workdir <- getwd()
[17:41:13.008]             }
[17:41:13.008]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:13.008]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:13.008]         }
[17:41:13.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:13.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:13.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:13.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:13.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:13.008]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:13.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:13.008]             base::names(...future.oldOptions))
[17:41:13.008]     }
[17:41:13.008]     if (FALSE) {
[17:41:13.008]     }
[17:41:13.008]     else {
[17:41:13.008]         if (TRUE) {
[17:41:13.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:13.008]                 open = "w")
[17:41:13.008]         }
[17:41:13.008]         else {
[17:41:13.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:13.008]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:13.008]         }
[17:41:13.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:13.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:13.008]             base::sink(type = "output", split = FALSE)
[17:41:13.008]             base::close(...future.stdout)
[17:41:13.008]         }, add = TRUE)
[17:41:13.008]     }
[17:41:13.008]     ...future.frame <- base::sys.nframe()
[17:41:13.008]     ...future.conditions <- base::list()
[17:41:13.008]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:13.008]     if (FALSE) {
[17:41:13.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:13.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:13.008]     }
[17:41:13.008]     ...future.result <- base::tryCatch({
[17:41:13.008]         base::withCallingHandlers({
[17:41:13.008]             ...future.value <- base::withVisible(base::local({
[17:41:13.008]                 do.call(function(...) {
[17:41:13.008]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:13.008]                   if (!identical(...future.globals.maxSize.org, 
[17:41:13.008]                     ...future.globals.maxSize)) {
[17:41:13.008]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:13.008]                     on.exit(options(oopts), add = TRUE)
[17:41:13.008]                   }
[17:41:13.008]                   {
[17:41:13.008]                     lapply(seq_along(...future.elements_ii), 
[17:41:13.008]                       FUN = function(jj) {
[17:41:13.008]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:13.008]                         ...future.FUN(...future.X_jj, ...)
[17:41:13.008]                       })
[17:41:13.008]                   }
[17:41:13.008]                 }, args = future.call.arguments)
[17:41:13.008]             }))
[17:41:13.008]             future::FutureResult(value = ...future.value$value, 
[17:41:13.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:13.008]                   ...future.rng), globalenv = if (FALSE) 
[17:41:13.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:13.008]                     ...future.globalenv.names))
[17:41:13.008]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:13.008]         }, condition = base::local({
[17:41:13.008]             c <- base::c
[17:41:13.008]             inherits <- base::inherits
[17:41:13.008]             invokeRestart <- base::invokeRestart
[17:41:13.008]             length <- base::length
[17:41:13.008]             list <- base::list
[17:41:13.008]             seq.int <- base::seq.int
[17:41:13.008]             signalCondition <- base::signalCondition
[17:41:13.008]             sys.calls <- base::sys.calls
[17:41:13.008]             `[[` <- base::`[[`
[17:41:13.008]             `+` <- base::`+`
[17:41:13.008]             `<<-` <- base::`<<-`
[17:41:13.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:13.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:13.008]                   3L)]
[17:41:13.008]             }
[17:41:13.008]             function(cond) {
[17:41:13.008]                 is_error <- inherits(cond, "error")
[17:41:13.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:13.008]                   NULL)
[17:41:13.008]                 if (is_error) {
[17:41:13.008]                   sessionInformation <- function() {
[17:41:13.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:13.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:13.008]                       search = base::search(), system = base::Sys.info())
[17:41:13.008]                   }
[17:41:13.008]                   ...future.conditions[[length(...future.conditions) + 
[17:41:13.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:13.008]                     cond$call), session = sessionInformation(), 
[17:41:13.008]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:13.008]                   signalCondition(cond)
[17:41:13.008]                 }
[17:41:13.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:13.008]                 "immediateCondition"))) {
[17:41:13.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:13.008]                   ...future.conditions[[length(...future.conditions) + 
[17:41:13.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:13.008]                   if (TRUE && !signal) {
[17:41:13.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:13.008]                     {
[17:41:13.008]                       inherits <- base::inherits
[17:41:13.008]                       invokeRestart <- base::invokeRestart
[17:41:13.008]                       is.null <- base::is.null
[17:41:13.008]                       muffled <- FALSE
[17:41:13.008]                       if (inherits(cond, "message")) {
[17:41:13.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:13.008]                         if (muffled) 
[17:41:13.008]                           invokeRestart("muffleMessage")
[17:41:13.008]                       }
[17:41:13.008]                       else if (inherits(cond, "warning")) {
[17:41:13.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:13.008]                         if (muffled) 
[17:41:13.008]                           invokeRestart("muffleWarning")
[17:41:13.008]                       }
[17:41:13.008]                       else if (inherits(cond, "condition")) {
[17:41:13.008]                         if (!is.null(pattern)) {
[17:41:13.008]                           computeRestarts <- base::computeRestarts
[17:41:13.008]                           grepl <- base::grepl
[17:41:13.008]                           restarts <- computeRestarts(cond)
[17:41:13.008]                           for (restart in restarts) {
[17:41:13.008]                             name <- restart$name
[17:41:13.008]                             if (is.null(name)) 
[17:41:13.008]                               next
[17:41:13.008]                             if (!grepl(pattern, name)) 
[17:41:13.008]                               next
[17:41:13.008]                             invokeRestart(restart)
[17:41:13.008]                             muffled <- TRUE
[17:41:13.008]                             break
[17:41:13.008]                           }
[17:41:13.008]                         }
[17:41:13.008]                       }
[17:41:13.008]                       invisible(muffled)
[17:41:13.008]                     }
[17:41:13.008]                     muffleCondition(cond, pattern = "^muffle")
[17:41:13.008]                   }
[17:41:13.008]                 }
[17:41:13.008]                 else {
[17:41:13.008]                   if (TRUE) {
[17:41:13.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:13.008]                     {
[17:41:13.008]                       inherits <- base::inherits
[17:41:13.008]                       invokeRestart <- base::invokeRestart
[17:41:13.008]                       is.null <- base::is.null
[17:41:13.008]                       muffled <- FALSE
[17:41:13.008]                       if (inherits(cond, "message")) {
[17:41:13.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:13.008]                         if (muffled) 
[17:41:13.008]                           invokeRestart("muffleMessage")
[17:41:13.008]                       }
[17:41:13.008]                       else if (inherits(cond, "warning")) {
[17:41:13.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:13.008]                         if (muffled) 
[17:41:13.008]                           invokeRestart("muffleWarning")
[17:41:13.008]                       }
[17:41:13.008]                       else if (inherits(cond, "condition")) {
[17:41:13.008]                         if (!is.null(pattern)) {
[17:41:13.008]                           computeRestarts <- base::computeRestarts
[17:41:13.008]                           grepl <- base::grepl
[17:41:13.008]                           restarts <- computeRestarts(cond)
[17:41:13.008]                           for (restart in restarts) {
[17:41:13.008]                             name <- restart$name
[17:41:13.008]                             if (is.null(name)) 
[17:41:13.008]                               next
[17:41:13.008]                             if (!grepl(pattern, name)) 
[17:41:13.008]                               next
[17:41:13.008]                             invokeRestart(restart)
[17:41:13.008]                             muffled <- TRUE
[17:41:13.008]                             break
[17:41:13.008]                           }
[17:41:13.008]                         }
[17:41:13.008]                       }
[17:41:13.008]                       invisible(muffled)
[17:41:13.008]                     }
[17:41:13.008]                     muffleCondition(cond, pattern = "^muffle")
[17:41:13.008]                   }
[17:41:13.008]                 }
[17:41:13.008]             }
[17:41:13.008]         }))
[17:41:13.008]     }, error = function(ex) {
[17:41:13.008]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:13.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:13.008]                 ...future.rng), started = ...future.startTime, 
[17:41:13.008]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:13.008]             version = "1.8"), class = "FutureResult")
[17:41:13.008]     }, finally = {
[17:41:13.008]         if (!identical(...future.workdir, getwd())) 
[17:41:13.008]             setwd(...future.workdir)
[17:41:13.008]         {
[17:41:13.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:13.008]                 ...future.oldOptions$nwarnings <- NULL
[17:41:13.008]             }
[17:41:13.008]             base::options(...future.oldOptions)
[17:41:13.008]             if (.Platform$OS.type == "windows") {
[17:41:13.008]                 old_names <- names(...future.oldEnvVars)
[17:41:13.008]                 envs <- base::Sys.getenv()
[17:41:13.008]                 names <- names(envs)
[17:41:13.008]                 common <- intersect(names, old_names)
[17:41:13.008]                 added <- setdiff(names, old_names)
[17:41:13.008]                 removed <- setdiff(old_names, names)
[17:41:13.008]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:13.008]                   envs[common]]
[17:41:13.008]                 NAMES <- toupper(changed)
[17:41:13.008]                 args <- list()
[17:41:13.008]                 for (kk in seq_along(NAMES)) {
[17:41:13.008]                   name <- changed[[kk]]
[17:41:13.008]                   NAME <- NAMES[[kk]]
[17:41:13.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:13.008]                     next
[17:41:13.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:13.008]                 }
[17:41:13.008]                 NAMES <- toupper(added)
[17:41:13.008]                 for (kk in seq_along(NAMES)) {
[17:41:13.008]                   name <- added[[kk]]
[17:41:13.008]                   NAME <- NAMES[[kk]]
[17:41:13.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:13.008]                     next
[17:41:13.008]                   args[[name]] <- ""
[17:41:13.008]                 }
[17:41:13.008]                 NAMES <- toupper(removed)
[17:41:13.008]                 for (kk in seq_along(NAMES)) {
[17:41:13.008]                   name <- removed[[kk]]
[17:41:13.008]                   NAME <- NAMES[[kk]]
[17:41:13.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:13.008]                     next
[17:41:13.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:13.008]                 }
[17:41:13.008]                 if (length(args) > 0) 
[17:41:13.008]                   base::do.call(base::Sys.setenv, args = args)
[17:41:13.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:13.008]             }
[17:41:13.008]             else {
[17:41:13.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:13.008]             }
[17:41:13.008]             {
[17:41:13.008]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:13.008]                   0L) {
[17:41:13.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:13.008]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:13.008]                   base::options(opts)
[17:41:13.008]                 }
[17:41:13.008]                 {
[17:41:13.008]                   {
[17:41:13.008]                     NULL
[17:41:13.008]                     RNGkind("Mersenne-Twister")
[17:41:13.008]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:13.008]                       inherits = FALSE)
[17:41:13.008]                   }
[17:41:13.008]                   options(future.plan = NULL)
[17:41:13.008]                   if (is.na(NA_character_)) 
[17:41:13.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:13.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:13.008]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:13.008]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:13.008]                     envir = parent.frame()) 
[17:41:13.008]                   {
[17:41:13.008]                     if (is.function(workers)) 
[17:41:13.008]                       workers <- workers()
[17:41:13.008]                     workers <- structure(as.integer(workers), 
[17:41:13.008]                       class = class(workers))
[17:41:13.008]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:13.008]                       workers >= 1)
[17:41:13.008]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:13.008]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:13.008]                     }
[17:41:13.008]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:13.008]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:13.008]                       envir = envir)
[17:41:13.008]                     if (!future$lazy) 
[17:41:13.008]                       future <- run(future)
[17:41:13.008]                     invisible(future)
[17:41:13.008]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:13.008]                 }
[17:41:13.008]             }
[17:41:13.008]         }
[17:41:13.008]     })
[17:41:13.008]     if (TRUE) {
[17:41:13.008]         base::sink(type = "output", split = FALSE)
[17:41:13.008]         if (TRUE) {
[17:41:13.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:13.008]         }
[17:41:13.008]         else {
[17:41:13.008]             ...future.result["stdout"] <- base::list(NULL)
[17:41:13.008]         }
[17:41:13.008]         base::close(...future.stdout)
[17:41:13.008]         ...future.stdout <- NULL
[17:41:13.008]     }
[17:41:13.008]     ...future.result$conditions <- ...future.conditions
[17:41:13.008]     ...future.result$finished <- base::Sys.time()
[17:41:13.008]     ...future.result
[17:41:13.008] }
[17:41:13.010] assign_globals() ...
[17:41:13.010] List of 5
[17:41:13.010]  $ ...future.FUN            :function (x)  
[17:41:13.010]  $ future.call.arguments    : list()
[17:41:13.010]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:13.010]  $ ...future.elements_ii    :List of 2
[17:41:13.010]   ..$ : int 1
[17:41:13.010]   ..$ : int 0
[17:41:13.010]  $ ...future.seeds_ii       : NULL
[17:41:13.010]  $ ...future.globals.maxSize: NULL
[17:41:13.010]  - attr(*, "resolved")= logi FALSE
[17:41:13.010]  - attr(*, "total_size")= num 4720
[17:41:13.010]  - attr(*, "where")=List of 5
[17:41:13.010]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:13.010]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:13.010]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:13.010]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:13.010]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:13.010]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:13.010]  - attr(*, "already-done")= logi TRUE
[17:41:13.015] - reassign environment for ‘...future.FUN’
[17:41:13.016] - copied ‘...future.FUN’ to environment
[17:41:13.016] - copied ‘future.call.arguments’ to environment
[17:41:13.016] - copied ‘...future.elements_ii’ to environment
[17:41:13.016] - copied ‘...future.seeds_ii’ to environment
[17:41:13.016] - copied ‘...future.globals.maxSize’ to environment
[17:41:13.017] assign_globals() ... done
[17:41:13.017] plan(): Setting new future strategy stack:
[17:41:13.017] List of future strategies:
[17:41:13.017] 1. sequential:
[17:41:13.017]    - args: function (..., envir = parent.frame())
[17:41:13.017]    - tweaked: FALSE
[17:41:13.017]    - call: NULL
[17:41:13.017] plan(): nbrOfWorkers() = 1
[17:41:13.519] plan(): Setting new future strategy stack:
[17:41:13.519] List of future strategies:
[17:41:13.519] 1. multisession:
[17:41:13.519]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:13.519]    - tweaked: FALSE
[17:41:13.519]    - call: plan(strategy)
[17:41:13.523] plan(): nbrOfWorkers() = 1
[17:41:13.523] SequentialFuture started (and completed)
[17:41:13.524] - Launch lazy future ... done
[17:41:13.524] run() for ‘SequentialFuture’ ... done
[17:41:13.524] Created future:
[17:41:13.524] SequentialFuture:
[17:41:13.524] Label: ‘future_lapply-1’
[17:41:13.524] Expression:
[17:41:13.524] {
[17:41:13.524]     do.call(function(...) {
[17:41:13.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:13.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:13.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:13.524]             on.exit(options(oopts), add = TRUE)
[17:41:13.524]         }
[17:41:13.524]         {
[17:41:13.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:13.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:13.524]                 ...future.FUN(...future.X_jj, ...)
[17:41:13.524]             })
[17:41:13.524]         }
[17:41:13.524]     }, args = future.call.arguments)
[17:41:13.524] }
[17:41:13.524] Lazy evaluation: FALSE
[17:41:13.524] Asynchronous evaluation: FALSE
[17:41:13.524] Local evaluation: TRUE
[17:41:13.524] Environment: R_GlobalEnv
[17:41:13.524] Capture standard output: TRUE
[17:41:13.524] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:13.524] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:13.524] Packages: <none>
[17:41:13.524] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:13.524] Resolved: TRUE
[17:41:13.524] Value: 112 bytes of class ‘list’
[17:41:13.524] Early signaling: FALSE
[17:41:13.524] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:13.524] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:13.525] Chunk #1 of 1 ... DONE
[17:41:13.525] Launching 1 futures (chunks) ... DONE
[17:41:13.525] Resolving 1 futures (chunks) ...
[17:41:13.525] resolve() on list ...
[17:41:13.525]  recursive: 0
[17:41:13.526]  length: 1
[17:41:13.526] 
[17:41:13.526] resolved() for ‘SequentialFuture’ ...
[17:41:13.526] - state: ‘finished’
[17:41:13.526] - run: TRUE
[17:41:13.526] - result: ‘FutureResult’
[17:41:13.526] resolved() for ‘SequentialFuture’ ... done
[17:41:13.526] Future #1
[17:41:13.526] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:13.526] - nx: 1
[17:41:13.527] - relay: TRUE
[17:41:13.527] - stdout: TRUE
[17:41:13.527] - signal: TRUE
[17:41:13.527] - resignal: FALSE
[17:41:13.527] - force: TRUE
[17:41:13.527] - relayed: [n=1] FALSE
[17:41:13.527] - queued futures: [n=1] FALSE
[17:41:13.527]  - until=1
[17:41:13.527]  - relaying element #1
[17:41:13.528] - relayed: [n=1] TRUE
[17:41:13.528] - queued futures: [n=1] TRUE
[17:41:13.528] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:13.528]  length: 0 (resolved future 1)
[17:41:13.528] Relaying remaining futures
[17:41:13.528] signalConditionsASAP(NULL, pos=0) ...
[17:41:13.528] - nx: 1
[17:41:13.528] - relay: TRUE
[17:41:13.528] - stdout: TRUE
[17:41:13.528] - signal: TRUE
[17:41:13.528] - resignal: FALSE
[17:41:13.528] - force: TRUE
[17:41:13.529] - relayed: [n=1] TRUE
[17:41:13.529] - queued futures: [n=1] TRUE
 - flush all
[17:41:13.529] - relayed: [n=1] TRUE
[17:41:13.529] - queued futures: [n=1] TRUE
[17:41:13.529] signalConditionsASAP(NULL, pos=0) ... done
[17:41:13.529] resolve() on list ... DONE
[17:41:13.529]  - Number of value chunks collected: 1
[17:41:13.529] Resolving 1 futures (chunks) ... DONE
[17:41:13.529] Reducing values from 1 chunks ...
[17:41:13.529]  - Number of values collected after concatenation: 2
[17:41:13.530]  - Number of values expected: 2
[17:41:13.530] Reducing values from 1 chunks ... DONE
[17:41:13.530] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:41:13.530] future_lapply() ...
[17:41:13.534] Number of chunks: 1
[17:41:13.534] getGlobalsAndPackagesXApply() ...
[17:41:13.534]  - future.globals: TRUE
[17:41:13.534] getGlobalsAndPackages() ...
[17:41:13.534] Searching for globals...
[17:41:13.536] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:13.536] Searching for globals ... DONE
[17:41:13.536] Resolving globals: FALSE
[17:41:13.536] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:13.536] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:13.537] - globals: [1] ‘FUN’
[17:41:13.537] 
[17:41:13.537] getGlobalsAndPackages() ... DONE
[17:41:13.537]  - globals found/used: [n=1] ‘FUN’
[17:41:13.537]  - needed namespaces: [n=0] 
[17:41:13.537] Finding globals ... DONE
[17:41:13.537]  - use_args: TRUE
[17:41:13.537]  - Getting '...' globals ...
[17:41:13.538] resolve() on list ...
[17:41:13.538]  recursive: 0
[17:41:13.538]  length: 1
[17:41:13.538]  elements: ‘...’
[17:41:13.538]  length: 0 (resolved future 1)
[17:41:13.538] resolve() on list ... DONE
[17:41:13.538]    - '...' content: [n=0] 
[17:41:13.538] List of 1
[17:41:13.538]  $ ...: list()
[17:41:13.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:13.538]  - attr(*, "where")=List of 1
[17:41:13.538]   ..$ ...:<environment: 0x55c9884339b8> 
[17:41:13.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:13.538]  - attr(*, "resolved")= logi TRUE
[17:41:13.538]  - attr(*, "total_size")= num NA
[17:41:13.541]  - Getting '...' globals ... DONE
[17:41:13.541] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:13.541] List of 2
[17:41:13.541]  $ ...future.FUN:function (x)  
[17:41:13.541]  $ ...          : list()
[17:41:13.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:13.541]  - attr(*, "where")=List of 2
[17:41:13.541]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:13.541]   ..$ ...          :<environment: 0x55c9884339b8> 
[17:41:13.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:13.541]  - attr(*, "resolved")= logi FALSE
[17:41:13.541]  - attr(*, "total_size")= num 4720
[17:41:13.544] Packages to be attached in all futures: [n=0] 
[17:41:13.544] getGlobalsAndPackagesXApply() ... DONE
[17:41:13.544] Number of futures (= number of chunks): 1
[17:41:13.544] Launching 1 futures (chunks) ...
[17:41:13.544] Chunk #1 of 1 ...
[17:41:13.544]  - Finding globals in 'X' for chunk #1 ...
[17:41:13.545] getGlobalsAndPackages() ...
[17:41:13.545] Searching for globals...
[17:41:13.545] 
[17:41:13.545] Searching for globals ... DONE
[17:41:13.545] - globals: [0] <none>
[17:41:13.545] getGlobalsAndPackages() ... DONE
[17:41:13.545]    + additional globals found: [n=0] 
[17:41:13.545]    + additional namespaces needed: [n=0] 
[17:41:13.545]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:13.546]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:13.546]  - seeds: <none>
[17:41:13.546] getGlobalsAndPackages() ...
[17:41:13.546] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:13.546] Resolving globals: FALSE
[17:41:13.546] Tweak future expression to call with '...' arguments ...
[17:41:13.548] {
[17:41:13.548]     do.call(function(...) {
[17:41:13.548]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:13.548]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:13.548]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:13.548]             on.exit(options(oopts), add = TRUE)
[17:41:13.548]         }
[17:41:13.548]         {
[17:41:13.548]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:13.548]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:13.548]                 ...future.FUN(...future.X_jj, ...)
[17:41:13.548]             })
[17:41:13.548]         }
[17:41:13.548]     }, args = future.call.arguments)
[17:41:13.548] }
[17:41:13.548] Tweak future expression to call with '...' arguments ... DONE
[17:41:13.548] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:13.548] 
[17:41:13.549] getGlobalsAndPackages() ... DONE
[17:41:13.549] run() for ‘Future’ ...
[17:41:13.549] - state: ‘created’
[17:41:13.549] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:13.552] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:13.553] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:13.553]   - Field: ‘label’
[17:41:13.553]   - Field: ‘local’
[17:41:13.553]   - Field: ‘owner’
[17:41:13.553]   - Field: ‘envir’
[17:41:13.553]   - Field: ‘packages’
[17:41:13.553]   - Field: ‘gc’
[17:41:13.553]   - Field: ‘conditions’
[17:41:13.553]   - Field: ‘expr’
[17:41:13.554]   - Field: ‘uuid’
[17:41:13.554]   - Field: ‘seed’
[17:41:13.554]   - Field: ‘version’
[17:41:13.554]   - Field: ‘result’
[17:41:13.554]   - Field: ‘asynchronous’
[17:41:13.554]   - Field: ‘calls’
[17:41:13.554]   - Field: ‘globals’
[17:41:13.554]   - Field: ‘stdout’
[17:41:13.554]   - Field: ‘earlySignal’
[17:41:13.554]   - Field: ‘lazy’
[17:41:13.554]   - Field: ‘state’
[17:41:13.555] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:13.555] - Launch lazy future ...
[17:41:13.555] Packages needed by the future expression (n = 0): <none>
[17:41:13.555] Packages needed by future strategies (n = 0): <none>
[17:41:13.555] {
[17:41:13.555]     {
[17:41:13.555]         {
[17:41:13.555]             ...future.startTime <- base::Sys.time()
[17:41:13.555]             {
[17:41:13.555]                 {
[17:41:13.555]                   {
[17:41:13.555]                     base::local({
[17:41:13.555]                       has_future <- base::requireNamespace("future", 
[17:41:13.555]                         quietly = TRUE)
[17:41:13.555]                       if (has_future) {
[17:41:13.555]                         ns <- base::getNamespace("future")
[17:41:13.555]                         version <- ns[[".package"]][["version"]]
[17:41:13.555]                         if (is.null(version)) 
[17:41:13.555]                           version <- utils::packageVersion("future")
[17:41:13.555]                       }
[17:41:13.555]                       else {
[17:41:13.555]                         version <- NULL
[17:41:13.555]                       }
[17:41:13.555]                       if (!has_future || version < "1.8.0") {
[17:41:13.555]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:13.555]                           "", base::R.version$version.string), 
[17:41:13.555]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:13.555]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:13.555]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:13.555]                             "release", "version")], collapse = " "), 
[17:41:13.555]                           hostname = base::Sys.info()[["nodename"]])
[17:41:13.555]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:13.555]                           info)
[17:41:13.555]                         info <- base::paste(info, collapse = "; ")
[17:41:13.555]                         if (!has_future) {
[17:41:13.555]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:13.555]                             info)
[17:41:13.555]                         }
[17:41:13.555]                         else {
[17:41:13.555]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:13.555]                             info, version)
[17:41:13.555]                         }
[17:41:13.555]                         base::stop(msg)
[17:41:13.555]                       }
[17:41:13.555]                     })
[17:41:13.555]                   }
[17:41:13.555]                   options(future.plan = NULL)
[17:41:13.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:13.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:13.555]                 }
[17:41:13.555]                 ...future.workdir <- getwd()
[17:41:13.555]             }
[17:41:13.555]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:13.555]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:13.555]         }
[17:41:13.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:13.555]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:13.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:13.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:13.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:13.555]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:13.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:13.555]             base::names(...future.oldOptions))
[17:41:13.555]     }
[17:41:13.555]     if (TRUE) {
[17:41:13.555]     }
[17:41:13.555]     else {
[17:41:13.555]         if (NA) {
[17:41:13.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:13.555]                 open = "w")
[17:41:13.555]         }
[17:41:13.555]         else {
[17:41:13.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:13.555]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:13.555]         }
[17:41:13.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:13.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:13.555]             base::sink(type = "output", split = FALSE)
[17:41:13.555]             base::close(...future.stdout)
[17:41:13.555]         }, add = TRUE)
[17:41:13.555]     }
[17:41:13.555]     ...future.frame <- base::sys.nframe()
[17:41:13.555]     ...future.conditions <- base::list()
[17:41:13.555]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:13.555]     if (FALSE) {
[17:41:13.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:13.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:13.555]     }
[17:41:13.555]     ...future.result <- base::tryCatch({
[17:41:13.555]         base::withCallingHandlers({
[17:41:13.555]             ...future.value <- base::withVisible(base::local({
[17:41:13.555]                 do.call(function(...) {
[17:41:13.555]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:13.555]                   if (!identical(...future.globals.maxSize.org, 
[17:41:13.555]                     ...future.globals.maxSize)) {
[17:41:13.555]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:13.555]                     on.exit(options(oopts), add = TRUE)
[17:41:13.555]                   }
[17:41:13.555]                   {
[17:41:13.555]                     lapply(seq_along(...future.elements_ii), 
[17:41:13.555]                       FUN = function(jj) {
[17:41:13.555]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:13.555]                         ...future.FUN(...future.X_jj, ...)
[17:41:13.555]                       })
[17:41:13.555]                   }
[17:41:13.555]                 }, args = future.call.arguments)
[17:41:13.555]             }))
[17:41:13.555]             future::FutureResult(value = ...future.value$value, 
[17:41:13.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:13.555]                   ...future.rng), globalenv = if (FALSE) 
[17:41:13.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:13.555]                     ...future.globalenv.names))
[17:41:13.555]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:13.555]         }, condition = base::local({
[17:41:13.555]             c <- base::c
[17:41:13.555]             inherits <- base::inherits
[17:41:13.555]             invokeRestart <- base::invokeRestart
[17:41:13.555]             length <- base::length
[17:41:13.555]             list <- base::list
[17:41:13.555]             seq.int <- base::seq.int
[17:41:13.555]             signalCondition <- base::signalCondition
[17:41:13.555]             sys.calls <- base::sys.calls
[17:41:13.555]             `[[` <- base::`[[`
[17:41:13.555]             `+` <- base::`+`
[17:41:13.555]             `<<-` <- base::`<<-`
[17:41:13.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:13.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:13.555]                   3L)]
[17:41:13.555]             }
[17:41:13.555]             function(cond) {
[17:41:13.555]                 is_error <- inherits(cond, "error")
[17:41:13.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:13.555]                   NULL)
[17:41:13.555]                 if (is_error) {
[17:41:13.555]                   sessionInformation <- function() {
[17:41:13.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:13.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:13.555]                       search = base::search(), system = base::Sys.info())
[17:41:13.555]                   }
[17:41:13.555]                   ...future.conditions[[length(...future.conditions) + 
[17:41:13.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:13.555]                     cond$call), session = sessionInformation(), 
[17:41:13.555]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:13.555]                   signalCondition(cond)
[17:41:13.555]                 }
[17:41:13.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:13.555]                 "immediateCondition"))) {
[17:41:13.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:13.555]                   ...future.conditions[[length(...future.conditions) + 
[17:41:13.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:13.555]                   if (TRUE && !signal) {
[17:41:13.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:13.555]                     {
[17:41:13.555]                       inherits <- base::inherits
[17:41:13.555]                       invokeRestart <- base::invokeRestart
[17:41:13.555]                       is.null <- base::is.null
[17:41:13.555]                       muffled <- FALSE
[17:41:13.555]                       if (inherits(cond, "message")) {
[17:41:13.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:13.555]                         if (muffled) 
[17:41:13.555]                           invokeRestart("muffleMessage")
[17:41:13.555]                       }
[17:41:13.555]                       else if (inherits(cond, "warning")) {
[17:41:13.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:13.555]                         if (muffled) 
[17:41:13.555]                           invokeRestart("muffleWarning")
[17:41:13.555]                       }
[17:41:13.555]                       else if (inherits(cond, "condition")) {
[17:41:13.555]                         if (!is.null(pattern)) {
[17:41:13.555]                           computeRestarts <- base::computeRestarts
[17:41:13.555]                           grepl <- base::grepl
[17:41:13.555]                           restarts <- computeRestarts(cond)
[17:41:13.555]                           for (restart in restarts) {
[17:41:13.555]                             name <- restart$name
[17:41:13.555]                             if (is.null(name)) 
[17:41:13.555]                               next
[17:41:13.555]                             if (!grepl(pattern, name)) 
[17:41:13.555]                               next
[17:41:13.555]                             invokeRestart(restart)
[17:41:13.555]                             muffled <- TRUE
[17:41:13.555]                             break
[17:41:13.555]                           }
[17:41:13.555]                         }
[17:41:13.555]                       }
[17:41:13.555]                       invisible(muffled)
[17:41:13.555]                     }
[17:41:13.555]                     muffleCondition(cond, pattern = "^muffle")
[17:41:13.555]                   }
[17:41:13.555]                 }
[17:41:13.555]                 else {
[17:41:13.555]                   if (TRUE) {
[17:41:13.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:13.555]                     {
[17:41:13.555]                       inherits <- base::inherits
[17:41:13.555]                       invokeRestart <- base::invokeRestart
[17:41:13.555]                       is.null <- base::is.null
[17:41:13.555]                       muffled <- FALSE
[17:41:13.555]                       if (inherits(cond, "message")) {
[17:41:13.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:13.555]                         if (muffled) 
[17:41:13.555]                           invokeRestart("muffleMessage")
[17:41:13.555]                       }
[17:41:13.555]                       else if (inherits(cond, "warning")) {
[17:41:13.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:13.555]                         if (muffled) 
[17:41:13.555]                           invokeRestart("muffleWarning")
[17:41:13.555]                       }
[17:41:13.555]                       else if (inherits(cond, "condition")) {
[17:41:13.555]                         if (!is.null(pattern)) {
[17:41:13.555]                           computeRestarts <- base::computeRestarts
[17:41:13.555]                           grepl <- base::grepl
[17:41:13.555]                           restarts <- computeRestarts(cond)
[17:41:13.555]                           for (restart in restarts) {
[17:41:13.555]                             name <- restart$name
[17:41:13.555]                             if (is.null(name)) 
[17:41:13.555]                               next
[17:41:13.555]                             if (!grepl(pattern, name)) 
[17:41:13.555]                               next
[17:41:13.555]                             invokeRestart(restart)
[17:41:13.555]                             muffled <- TRUE
[17:41:13.555]                             break
[17:41:13.555]                           }
[17:41:13.555]                         }
[17:41:13.555]                       }
[17:41:13.555]                       invisible(muffled)
[17:41:13.555]                     }
[17:41:13.555]                     muffleCondition(cond, pattern = "^muffle")
[17:41:13.555]                   }
[17:41:13.555]                 }
[17:41:13.555]             }
[17:41:13.555]         }))
[17:41:13.555]     }, error = function(ex) {
[17:41:13.555]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:13.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:13.555]                 ...future.rng), started = ...future.startTime, 
[17:41:13.555]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:13.555]             version = "1.8"), class = "FutureResult")
[17:41:13.555]     }, finally = {
[17:41:13.555]         if (!identical(...future.workdir, getwd())) 
[17:41:13.555]             setwd(...future.workdir)
[17:41:13.555]         {
[17:41:13.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:13.555]                 ...future.oldOptions$nwarnings <- NULL
[17:41:13.555]             }
[17:41:13.555]             base::options(...future.oldOptions)
[17:41:13.555]             if (.Platform$OS.type == "windows") {
[17:41:13.555]                 old_names <- names(...future.oldEnvVars)
[17:41:13.555]                 envs <- base::Sys.getenv()
[17:41:13.555]                 names <- names(envs)
[17:41:13.555]                 common <- intersect(names, old_names)
[17:41:13.555]                 added <- setdiff(names, old_names)
[17:41:13.555]                 removed <- setdiff(old_names, names)
[17:41:13.555]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:13.555]                   envs[common]]
[17:41:13.555]                 NAMES <- toupper(changed)
[17:41:13.555]                 args <- list()
[17:41:13.555]                 for (kk in seq_along(NAMES)) {
[17:41:13.555]                   name <- changed[[kk]]
[17:41:13.555]                   NAME <- NAMES[[kk]]
[17:41:13.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:13.555]                     next
[17:41:13.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:13.555]                 }
[17:41:13.555]                 NAMES <- toupper(added)
[17:41:13.555]                 for (kk in seq_along(NAMES)) {
[17:41:13.555]                   name <- added[[kk]]
[17:41:13.555]                   NAME <- NAMES[[kk]]
[17:41:13.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:13.555]                     next
[17:41:13.555]                   args[[name]] <- ""
[17:41:13.555]                 }
[17:41:13.555]                 NAMES <- toupper(removed)
[17:41:13.555]                 for (kk in seq_along(NAMES)) {
[17:41:13.555]                   name <- removed[[kk]]
[17:41:13.555]                   NAME <- NAMES[[kk]]
[17:41:13.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:13.555]                     next
[17:41:13.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:13.555]                 }
[17:41:13.555]                 if (length(args) > 0) 
[17:41:13.555]                   base::do.call(base::Sys.setenv, args = args)
[17:41:13.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:13.555]             }
[17:41:13.555]             else {
[17:41:13.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:13.555]             }
[17:41:13.555]             {
[17:41:13.555]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:13.555]                   0L) {
[17:41:13.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:13.555]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:13.555]                   base::options(opts)
[17:41:13.555]                 }
[17:41:13.555]                 {
[17:41:13.555]                   {
[17:41:13.555]                     NULL
[17:41:13.555]                     RNGkind("Mersenne-Twister")
[17:41:13.555]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:13.555]                       inherits = FALSE)
[17:41:13.555]                   }
[17:41:13.555]                   options(future.plan = NULL)
[17:41:13.555]                   if (is.na(NA_character_)) 
[17:41:13.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:13.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:13.555]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:13.555]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:13.555]                     envir = parent.frame()) 
[17:41:13.555]                   {
[17:41:13.555]                     if (is.function(workers)) 
[17:41:13.555]                       workers <- workers()
[17:41:13.555]                     workers <- structure(as.integer(workers), 
[17:41:13.555]                       class = class(workers))
[17:41:13.555]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:13.555]                       workers >= 1)
[17:41:13.555]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:13.555]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:13.555]                     }
[17:41:13.555]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:13.555]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:13.555]                       envir = envir)
[17:41:13.555]                     if (!future$lazy) 
[17:41:13.555]                       future <- run(future)
[17:41:13.555]                     invisible(future)
[17:41:13.555]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:13.555]                 }
[17:41:13.555]             }
[17:41:13.555]         }
[17:41:13.555]     })
[17:41:13.555]     if (FALSE) {
[17:41:13.555]         base::sink(type = "output", split = FALSE)
[17:41:13.555]         if (NA) {
[17:41:13.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:13.555]         }
[17:41:13.555]         else {
[17:41:13.555]             ...future.result["stdout"] <- base::list(NULL)
[17:41:13.555]         }
[17:41:13.555]         base::close(...future.stdout)
[17:41:13.555]         ...future.stdout <- NULL
[17:41:13.555]     }
[17:41:13.555]     ...future.result$conditions <- ...future.conditions
[17:41:13.555]     ...future.result$finished <- base::Sys.time()
[17:41:13.555]     ...future.result
[17:41:13.555] }
[17:41:13.557] assign_globals() ...
[17:41:13.557] List of 5
[17:41:13.557]  $ ...future.FUN            :function (x)  
[17:41:13.557]  $ future.call.arguments    : list()
[17:41:13.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:13.557]  $ ...future.elements_ii    :List of 2
[17:41:13.557]   ..$ : int 1
[17:41:13.557]   ..$ : int 0
[17:41:13.557]  $ ...future.seeds_ii       : NULL
[17:41:13.557]  $ ...future.globals.maxSize: NULL
[17:41:13.557]  - attr(*, "resolved")= logi FALSE
[17:41:13.557]  - attr(*, "total_size")= num 4720
[17:41:13.557]  - attr(*, "where")=List of 5
[17:41:13.557]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:13.557]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:13.557]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:13.557]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:13.557]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:13.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:13.557]  - attr(*, "already-done")= logi TRUE
[17:41:13.562] - reassign environment for ‘...future.FUN’
[17:41:13.562] - copied ‘...future.FUN’ to environment
[17:41:13.562] - copied ‘future.call.arguments’ to environment
[17:41:13.562] - copied ‘...future.elements_ii’ to environment
[17:41:13.562] - copied ‘...future.seeds_ii’ to environment
[17:41:13.562] - copied ‘...future.globals.maxSize’ to environment
[17:41:13.563] assign_globals() ... done
[17:41:13.563] plan(): Setting new future strategy stack:
[17:41:13.563] List of future strategies:
[17:41:13.563] 1. sequential:
[17:41:13.563]    - args: function (..., envir = parent.frame())
[17:41:13.563]    - tweaked: FALSE
[17:41:13.563]    - call: NULL
[17:41:13.563] plan(): nbrOfWorkers() = 1
[17:41:14.065] plan(): Setting new future strategy stack:
[17:41:14.065] List of future strategies:
[17:41:14.065] 1. multisession:
[17:41:14.065]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:14.065]    - tweaked: FALSE
[17:41:14.065]    - call: plan(strategy)
[17:41:14.069] plan(): nbrOfWorkers() = 1
[17:41:14.069] SequentialFuture started (and completed)
[17:41:14.069] - Launch lazy future ... done
[17:41:14.070] run() for ‘SequentialFuture’ ... done
[17:41:14.070] Created future:
[17:41:14.070] SequentialFuture:
[17:41:14.070] Label: ‘future_lapply-1’
[17:41:14.070] Expression:
[17:41:14.070] {
[17:41:14.070]     do.call(function(...) {
[17:41:14.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:14.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:14.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:14.070]             on.exit(options(oopts), add = TRUE)
[17:41:14.070]         }
[17:41:14.070]         {
[17:41:14.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:14.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:14.070]                 ...future.FUN(...future.X_jj, ...)
[17:41:14.070]             })
[17:41:14.070]         }
[17:41:14.070]     }, args = future.call.arguments)
[17:41:14.070] }
[17:41:14.070] Lazy evaluation: FALSE
[17:41:14.070] Asynchronous evaluation: FALSE
[17:41:14.070] Local evaluation: TRUE
[17:41:14.070] Environment: R_GlobalEnv
[17:41:14.070] Capture standard output: NA
[17:41:14.070] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:14.070] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:14.070] Packages: <none>
[17:41:14.070] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:14.070] Resolved: TRUE
[17:41:14.070] Value: 112 bytes of class ‘list’
[17:41:14.070] Early signaling: FALSE
[17:41:14.070] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:14.070] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:14.071] Chunk #1 of 1 ... DONE
[17:41:14.071] Launching 1 futures (chunks) ... DONE
[17:41:14.071] Resolving 1 futures (chunks) ...
[17:41:14.071] resolve() on list ...
[17:41:14.072]  recursive: 0
[17:41:14.072]  length: 1
[17:41:14.072] 
[17:41:14.072] resolved() for ‘SequentialFuture’ ...
[17:41:14.072] - state: ‘finished’
[17:41:14.072] - run: TRUE
[17:41:14.072] - result: ‘FutureResult’
[17:41:14.072] resolved() for ‘SequentialFuture’ ... done
[17:41:14.072] Future #1
[17:41:14.072] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:14.073] - nx: 1
[17:41:14.073] - relay: TRUE
[17:41:14.073] - stdout: TRUE
[17:41:14.073] - signal: TRUE
[17:41:14.073] - resignal: FALSE
[17:41:14.073] - force: TRUE
[17:41:14.073] - relayed: [n=1] FALSE
[17:41:14.073] - queued futures: [n=1] FALSE
[17:41:14.073]  - until=1
[17:41:14.073]  - relaying element #1
[17:41:14.074] - relayed: [n=1] TRUE
[17:41:14.074] - queued futures: [n=1] TRUE
[17:41:14.074] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:14.074]  length: 0 (resolved future 1)
[17:41:14.074] Relaying remaining futures
[17:41:14.074] signalConditionsASAP(NULL, pos=0) ...
[17:41:14.074] - nx: 1
[17:41:14.074] - relay: TRUE
[17:41:14.074] - stdout: TRUE
[17:41:14.074] - signal: TRUE
[17:41:14.074] - resignal: FALSE
[17:41:14.074] - force: TRUE
[17:41:14.075] - relayed: [n=1] TRUE
[17:41:14.075] - queued futures: [n=1] TRUE
 - flush all
[17:41:14.075] - relayed: [n=1] TRUE
[17:41:14.075] - queued futures: [n=1] TRUE
[17:41:14.075] signalConditionsASAP(NULL, pos=0) ... done
[17:41:14.075] resolve() on list ... DONE
[17:41:14.075]  - Number of value chunks collected: 1
[17:41:14.075] Resolving 1 futures (chunks) ... DONE
[17:41:14.075] Reducing values from 1 chunks ...
[17:41:14.076]  - Number of values collected after concatenation: 2
[17:41:14.076]  - Number of values expected: 2
[17:41:14.076] Reducing values from 1 chunks ... DONE
[17:41:14.076] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:41:14.076] future_mapply() ...
[17:41:14.079] Number of chunks: 1
[17:41:14.079] getGlobalsAndPackagesXApply() ...
[17:41:14.080]  - future.globals: TRUE
[17:41:14.080] getGlobalsAndPackages() ...
[17:41:14.080] Searching for globals...
[17:41:14.083] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:14.083] Searching for globals ... DONE
[17:41:14.083] Resolving globals: FALSE
[17:41:14.084] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:14.084] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:14.084] - globals: [1] ‘FUN’
[17:41:14.084] 
[17:41:14.084] getGlobalsAndPackages() ... DONE
[17:41:14.084]  - globals found/used: [n=1] ‘FUN’
[17:41:14.085]  - needed namespaces: [n=0] 
[17:41:14.085] Finding globals ... DONE
[17:41:14.085] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:14.085] List of 2
[17:41:14.085]  $ ...future.FUN:function (x, y)  
[17:41:14.085]  $ MoreArgs     : NULL
[17:41:14.085]  - attr(*, "where")=List of 2
[17:41:14.085]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:14.085]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:14.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:14.085]  - attr(*, "resolved")= logi FALSE
[17:41:14.085]  - attr(*, "total_size")= num NA
[17:41:14.088] Packages to be attached in all futures: [n=0] 
[17:41:14.088] getGlobalsAndPackagesXApply() ... DONE
[17:41:14.088] Number of futures (= number of chunks): 1
[17:41:14.088] Launching 1 futures (chunks) ...
[17:41:14.088] Chunk #1 of 1 ...
[17:41:14.088]  - Finding globals in '...' for chunk #1 ...
[17:41:14.088] getGlobalsAndPackages() ...
[17:41:14.088] Searching for globals...
[17:41:14.089] 
[17:41:14.089] Searching for globals ... DONE
[17:41:14.089] - globals: [0] <none>
[17:41:14.089] getGlobalsAndPackages() ... DONE
[17:41:14.089]    + additional globals found: [n=0] 
[17:41:14.089]    + additional namespaces needed: [n=0] 
[17:41:14.089]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:14.089]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:14.090]  - seeds: <none>
[17:41:14.090] getGlobalsAndPackages() ...
[17:41:14.090] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:14.090] Resolving globals: FALSE
[17:41:14.090] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:14.091] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:14.091] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:14.091] 
[17:41:14.091] getGlobalsAndPackages() ... DONE
[17:41:14.091] run() for ‘Future’ ...
[17:41:14.091] - state: ‘created’
[17:41:14.092] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:14.095] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:14.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:14.095]   - Field: ‘label’
[17:41:14.095]   - Field: ‘local’
[17:41:14.095]   - Field: ‘owner’
[17:41:14.095]   - Field: ‘envir’
[17:41:14.096]   - Field: ‘packages’
[17:41:14.096]   - Field: ‘gc’
[17:41:14.096]   - Field: ‘conditions’
[17:41:14.096]   - Field: ‘expr’
[17:41:14.096]   - Field: ‘uuid’
[17:41:14.096]   - Field: ‘seed’
[17:41:14.096]   - Field: ‘version’
[17:41:14.096]   - Field: ‘result’
[17:41:14.096]   - Field: ‘asynchronous’
[17:41:14.096]   - Field: ‘calls’
[17:41:14.096]   - Field: ‘globals’
[17:41:14.097]   - Field: ‘stdout’
[17:41:14.097]   - Field: ‘earlySignal’
[17:41:14.097]   - Field: ‘lazy’
[17:41:14.097]   - Field: ‘state’
[17:41:14.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:14.097] - Launch lazy future ...
[17:41:14.097] Packages needed by the future expression (n = 0): <none>
[17:41:14.097] Packages needed by future strategies (n = 0): <none>
[17:41:14.098] {
[17:41:14.098]     {
[17:41:14.098]         {
[17:41:14.098]             ...future.startTime <- base::Sys.time()
[17:41:14.098]             {
[17:41:14.098]                 {
[17:41:14.098]                   {
[17:41:14.098]                     base::local({
[17:41:14.098]                       has_future <- base::requireNamespace("future", 
[17:41:14.098]                         quietly = TRUE)
[17:41:14.098]                       if (has_future) {
[17:41:14.098]                         ns <- base::getNamespace("future")
[17:41:14.098]                         version <- ns[[".package"]][["version"]]
[17:41:14.098]                         if (is.null(version)) 
[17:41:14.098]                           version <- utils::packageVersion("future")
[17:41:14.098]                       }
[17:41:14.098]                       else {
[17:41:14.098]                         version <- NULL
[17:41:14.098]                       }
[17:41:14.098]                       if (!has_future || version < "1.8.0") {
[17:41:14.098]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:14.098]                           "", base::R.version$version.string), 
[17:41:14.098]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:14.098]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:14.098]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:14.098]                             "release", "version")], collapse = " "), 
[17:41:14.098]                           hostname = base::Sys.info()[["nodename"]])
[17:41:14.098]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:14.098]                           info)
[17:41:14.098]                         info <- base::paste(info, collapse = "; ")
[17:41:14.098]                         if (!has_future) {
[17:41:14.098]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:14.098]                             info)
[17:41:14.098]                         }
[17:41:14.098]                         else {
[17:41:14.098]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:14.098]                             info, version)
[17:41:14.098]                         }
[17:41:14.098]                         base::stop(msg)
[17:41:14.098]                       }
[17:41:14.098]                     })
[17:41:14.098]                   }
[17:41:14.098]                   options(future.plan = NULL)
[17:41:14.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:14.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:14.098]                 }
[17:41:14.098]                 ...future.workdir <- getwd()
[17:41:14.098]             }
[17:41:14.098]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:14.098]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:14.098]         }
[17:41:14.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:14.098]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:14.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:14.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:14.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:14.098]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:14.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:14.098]             base::names(...future.oldOptions))
[17:41:14.098]     }
[17:41:14.098]     if (FALSE) {
[17:41:14.098]     }
[17:41:14.098]     else {
[17:41:14.098]         if (FALSE) {
[17:41:14.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:14.098]                 open = "w")
[17:41:14.098]         }
[17:41:14.098]         else {
[17:41:14.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:14.098]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:14.098]         }
[17:41:14.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:14.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:14.098]             base::sink(type = "output", split = FALSE)
[17:41:14.098]             base::close(...future.stdout)
[17:41:14.098]         }, add = TRUE)
[17:41:14.098]     }
[17:41:14.098]     ...future.frame <- base::sys.nframe()
[17:41:14.098]     ...future.conditions <- base::list()
[17:41:14.098]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:14.098]     if (FALSE) {
[17:41:14.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:14.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:14.098]     }
[17:41:14.098]     ...future.result <- base::tryCatch({
[17:41:14.098]         base::withCallingHandlers({
[17:41:14.098]             ...future.value <- base::withVisible(base::local({
[17:41:14.098]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:14.098]                 if (!identical(...future.globals.maxSize.org, 
[17:41:14.098]                   ...future.globals.maxSize)) {
[17:41:14.098]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:14.098]                   on.exit(options(oopts), add = TRUE)
[17:41:14.098]                 }
[17:41:14.098]                 {
[17:41:14.098]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:14.098]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:14.098]                     USE.NAMES = FALSE)
[17:41:14.098]                   do.call(mapply, args = args)
[17:41:14.098]                 }
[17:41:14.098]             }))
[17:41:14.098]             future::FutureResult(value = ...future.value$value, 
[17:41:14.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:14.098]                   ...future.rng), globalenv = if (FALSE) 
[17:41:14.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:14.098]                     ...future.globalenv.names))
[17:41:14.098]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:14.098]         }, condition = base::local({
[17:41:14.098]             c <- base::c
[17:41:14.098]             inherits <- base::inherits
[17:41:14.098]             invokeRestart <- base::invokeRestart
[17:41:14.098]             length <- base::length
[17:41:14.098]             list <- base::list
[17:41:14.098]             seq.int <- base::seq.int
[17:41:14.098]             signalCondition <- base::signalCondition
[17:41:14.098]             sys.calls <- base::sys.calls
[17:41:14.098]             `[[` <- base::`[[`
[17:41:14.098]             `+` <- base::`+`
[17:41:14.098]             `<<-` <- base::`<<-`
[17:41:14.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:14.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:14.098]                   3L)]
[17:41:14.098]             }
[17:41:14.098]             function(cond) {
[17:41:14.098]                 is_error <- inherits(cond, "error")
[17:41:14.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:14.098]                   NULL)
[17:41:14.098]                 if (is_error) {
[17:41:14.098]                   sessionInformation <- function() {
[17:41:14.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:14.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:14.098]                       search = base::search(), system = base::Sys.info())
[17:41:14.098]                   }
[17:41:14.098]                   ...future.conditions[[length(...future.conditions) + 
[17:41:14.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:14.098]                     cond$call), session = sessionInformation(), 
[17:41:14.098]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:14.098]                   signalCondition(cond)
[17:41:14.098]                 }
[17:41:14.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:14.098]                 "immediateCondition"))) {
[17:41:14.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:14.098]                   ...future.conditions[[length(...future.conditions) + 
[17:41:14.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:14.098]                   if (TRUE && !signal) {
[17:41:14.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:14.098]                     {
[17:41:14.098]                       inherits <- base::inherits
[17:41:14.098]                       invokeRestart <- base::invokeRestart
[17:41:14.098]                       is.null <- base::is.null
[17:41:14.098]                       muffled <- FALSE
[17:41:14.098]                       if (inherits(cond, "message")) {
[17:41:14.098]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:14.098]                         if (muffled) 
[17:41:14.098]                           invokeRestart("muffleMessage")
[17:41:14.098]                       }
[17:41:14.098]                       else if (inherits(cond, "warning")) {
[17:41:14.098]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:14.098]                         if (muffled) 
[17:41:14.098]                           invokeRestart("muffleWarning")
[17:41:14.098]                       }
[17:41:14.098]                       else if (inherits(cond, "condition")) {
[17:41:14.098]                         if (!is.null(pattern)) {
[17:41:14.098]                           computeRestarts <- base::computeRestarts
[17:41:14.098]                           grepl <- base::grepl
[17:41:14.098]                           restarts <- computeRestarts(cond)
[17:41:14.098]                           for (restart in restarts) {
[17:41:14.098]                             name <- restart$name
[17:41:14.098]                             if (is.null(name)) 
[17:41:14.098]                               next
[17:41:14.098]                             if (!grepl(pattern, name)) 
[17:41:14.098]                               next
[17:41:14.098]                             invokeRestart(restart)
[17:41:14.098]                             muffled <- TRUE
[17:41:14.098]                             break
[17:41:14.098]                           }
[17:41:14.098]                         }
[17:41:14.098]                       }
[17:41:14.098]                       invisible(muffled)
[17:41:14.098]                     }
[17:41:14.098]                     muffleCondition(cond, pattern = "^muffle")
[17:41:14.098]                   }
[17:41:14.098]                 }
[17:41:14.098]                 else {
[17:41:14.098]                   if (TRUE) {
[17:41:14.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:14.098]                     {
[17:41:14.098]                       inherits <- base::inherits
[17:41:14.098]                       invokeRestart <- base::invokeRestart
[17:41:14.098]                       is.null <- base::is.null
[17:41:14.098]                       muffled <- FALSE
[17:41:14.098]                       if (inherits(cond, "message")) {
[17:41:14.098]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:14.098]                         if (muffled) 
[17:41:14.098]                           invokeRestart("muffleMessage")
[17:41:14.098]                       }
[17:41:14.098]                       else if (inherits(cond, "warning")) {
[17:41:14.098]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:14.098]                         if (muffled) 
[17:41:14.098]                           invokeRestart("muffleWarning")
[17:41:14.098]                       }
[17:41:14.098]                       else if (inherits(cond, "condition")) {
[17:41:14.098]                         if (!is.null(pattern)) {
[17:41:14.098]                           computeRestarts <- base::computeRestarts
[17:41:14.098]                           grepl <- base::grepl
[17:41:14.098]                           restarts <- computeRestarts(cond)
[17:41:14.098]                           for (restart in restarts) {
[17:41:14.098]                             name <- restart$name
[17:41:14.098]                             if (is.null(name)) 
[17:41:14.098]                               next
[17:41:14.098]                             if (!grepl(pattern, name)) 
[17:41:14.098]                               next
[17:41:14.098]                             invokeRestart(restart)
[17:41:14.098]                             muffled <- TRUE
[17:41:14.098]                             break
[17:41:14.098]                           }
[17:41:14.098]                         }
[17:41:14.098]                       }
[17:41:14.098]                       invisible(muffled)
[17:41:14.098]                     }
[17:41:14.098]                     muffleCondition(cond, pattern = "^muffle")
[17:41:14.098]                   }
[17:41:14.098]                 }
[17:41:14.098]             }
[17:41:14.098]         }))
[17:41:14.098]     }, error = function(ex) {
[17:41:14.098]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:14.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:14.098]                 ...future.rng), started = ...future.startTime, 
[17:41:14.098]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:14.098]             version = "1.8"), class = "FutureResult")
[17:41:14.098]     }, finally = {
[17:41:14.098]         if (!identical(...future.workdir, getwd())) 
[17:41:14.098]             setwd(...future.workdir)
[17:41:14.098]         {
[17:41:14.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:14.098]                 ...future.oldOptions$nwarnings <- NULL
[17:41:14.098]             }
[17:41:14.098]             base::options(...future.oldOptions)
[17:41:14.098]             if (.Platform$OS.type == "windows") {
[17:41:14.098]                 old_names <- names(...future.oldEnvVars)
[17:41:14.098]                 envs <- base::Sys.getenv()
[17:41:14.098]                 names <- names(envs)
[17:41:14.098]                 common <- intersect(names, old_names)
[17:41:14.098]                 added <- setdiff(names, old_names)
[17:41:14.098]                 removed <- setdiff(old_names, names)
[17:41:14.098]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:14.098]                   envs[common]]
[17:41:14.098]                 NAMES <- toupper(changed)
[17:41:14.098]                 args <- list()
[17:41:14.098]                 for (kk in seq_along(NAMES)) {
[17:41:14.098]                   name <- changed[[kk]]
[17:41:14.098]                   NAME <- NAMES[[kk]]
[17:41:14.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:14.098]                     next
[17:41:14.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:14.098]                 }
[17:41:14.098]                 NAMES <- toupper(added)
[17:41:14.098]                 for (kk in seq_along(NAMES)) {
[17:41:14.098]                   name <- added[[kk]]
[17:41:14.098]                   NAME <- NAMES[[kk]]
[17:41:14.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:14.098]                     next
[17:41:14.098]                   args[[name]] <- ""
[17:41:14.098]                 }
[17:41:14.098]                 NAMES <- toupper(removed)
[17:41:14.098]                 for (kk in seq_along(NAMES)) {
[17:41:14.098]                   name <- removed[[kk]]
[17:41:14.098]                   NAME <- NAMES[[kk]]
[17:41:14.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:14.098]                     next
[17:41:14.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:14.098]                 }
[17:41:14.098]                 if (length(args) > 0) 
[17:41:14.098]                   base::do.call(base::Sys.setenv, args = args)
[17:41:14.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:14.098]             }
[17:41:14.098]             else {
[17:41:14.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:14.098]             }
[17:41:14.098]             {
[17:41:14.098]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:14.098]                   0L) {
[17:41:14.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:14.098]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:14.098]                   base::options(opts)
[17:41:14.098]                 }
[17:41:14.098]                 {
[17:41:14.098]                   {
[17:41:14.098]                     NULL
[17:41:14.098]                     RNGkind("Mersenne-Twister")
[17:41:14.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:14.098]                       inherits = FALSE)
[17:41:14.098]                   }
[17:41:14.098]                   options(future.plan = NULL)
[17:41:14.098]                   if (is.na(NA_character_)) 
[17:41:14.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:14.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:14.098]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:14.098]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:14.098]                     envir = parent.frame()) 
[17:41:14.098]                   {
[17:41:14.098]                     if (is.function(workers)) 
[17:41:14.098]                       workers <- workers()
[17:41:14.098]                     workers <- structure(as.integer(workers), 
[17:41:14.098]                       class = class(workers))
[17:41:14.098]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:14.098]                       workers >= 1)
[17:41:14.098]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:14.098]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:14.098]                     }
[17:41:14.098]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:14.098]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:14.098]                       envir = envir)
[17:41:14.098]                     if (!future$lazy) 
[17:41:14.098]                       future <- run(future)
[17:41:14.098]                     invisible(future)
[17:41:14.098]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:14.098]                 }
[17:41:14.098]             }
[17:41:14.098]         }
[17:41:14.098]     })
[17:41:14.098]     if (TRUE) {
[17:41:14.098]         base::sink(type = "output", split = FALSE)
[17:41:14.098]         if (FALSE) {
[17:41:14.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:14.098]         }
[17:41:14.098]         else {
[17:41:14.098]             ...future.result["stdout"] <- base::list(NULL)
[17:41:14.098]         }
[17:41:14.098]         base::close(...future.stdout)
[17:41:14.098]         ...future.stdout <- NULL
[17:41:14.098]     }
[17:41:14.098]     ...future.result$conditions <- ...future.conditions
[17:41:14.098]     ...future.result$finished <- base::Sys.time()
[17:41:14.098]     ...future.result
[17:41:14.098] }
[17:41:14.100] assign_globals() ...
[17:41:14.100] List of 5
[17:41:14.100]  $ ...future.FUN            :function (x, y)  
[17:41:14.100]  $ MoreArgs                 : NULL
[17:41:14.100]  $ ...future.elements_ii    :List of 2
[17:41:14.100]   ..$ :List of 2
[17:41:14.100]   .. ..$ : int 1
[17:41:14.100]   .. ..$ : int 0
[17:41:14.100]   ..$ :List of 2
[17:41:14.100]   .. ..$ : int 0
[17:41:14.100]   .. ..$ : int 1
[17:41:14.100]  $ ...future.seeds_ii       : NULL
[17:41:14.100]  $ ...future.globals.maxSize: NULL
[17:41:14.100]  - attr(*, "resolved")= logi FALSE
[17:41:14.100]  - attr(*, "total_size")= num 6480
[17:41:14.100]  - attr(*, "where")=List of 5
[17:41:14.100]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:14.100]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:14.100]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:14.100]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:14.100]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:14.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:14.100]  - attr(*, "already-done")= logi TRUE
[17:41:14.105] - reassign environment for ‘...future.FUN’
[17:41:14.105] - copied ‘...future.FUN’ to environment
[17:41:14.105] - copied ‘MoreArgs’ to environment
[17:41:14.105] - copied ‘...future.elements_ii’ to environment
[17:41:14.105] - copied ‘...future.seeds_ii’ to environment
[17:41:14.106] - copied ‘...future.globals.maxSize’ to environment
[17:41:14.106] assign_globals() ... done
[17:41:14.106] plan(): Setting new future strategy stack:
[17:41:14.106] List of future strategies:
[17:41:14.106] 1. sequential:
[17:41:14.106]    - args: function (..., envir = parent.frame())
[17:41:14.106]    - tweaked: FALSE
[17:41:14.106]    - call: NULL
[17:41:14.106] plan(): nbrOfWorkers() = 1
[17:41:14.608] plan(): Setting new future strategy stack:
[17:41:14.608] List of future strategies:
[17:41:14.608] 1. multisession:
[17:41:14.608]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:14.608]    - tweaked: FALSE
[17:41:14.608]    - call: plan(strategy)
[17:41:14.612] plan(): nbrOfWorkers() = 1
[17:41:14.612] SequentialFuture started (and completed)
[17:41:14.612] - Launch lazy future ... done
[17:41:14.613] run() for ‘SequentialFuture’ ... done
[17:41:14.613] Created future:
[17:41:14.613] SequentialFuture:
[17:41:14.613] Label: ‘future_mapply-1’
[17:41:14.613] Expression:
[17:41:14.613] {
[17:41:14.613]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:14.613]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:14.613]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:14.613]         on.exit(options(oopts), add = TRUE)
[17:41:14.613]     }
[17:41:14.613]     {
[17:41:14.613]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:14.613]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:14.613]         do.call(mapply, args = args)
[17:41:14.613]     }
[17:41:14.613] }
[17:41:14.613] Lazy evaluation: FALSE
[17:41:14.613] Asynchronous evaluation: FALSE
[17:41:14.613] Local evaluation: TRUE
[17:41:14.613] Environment: R_GlobalEnv
[17:41:14.613] Capture standard output: FALSE
[17:41:14.613] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:14.613] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:14.613] Packages: <none>
[17:41:14.613] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:14.613] Resolved: TRUE
[17:41:14.613] Value: 224 bytes of class ‘list’
[17:41:14.613] Early signaling: FALSE
[17:41:14.613] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:14.613] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:14.614] Chunk #1 of 1 ... DONE
[17:41:14.614] Launching 1 futures (chunks) ... DONE
[17:41:14.614] Resolving 1 futures (chunks) ...
[17:41:14.616] resolve() on list ...
[17:41:14.616]  recursive: 0
[17:41:14.616]  length: 1
[17:41:14.616] 
[17:41:14.616] resolved() for ‘SequentialFuture’ ...
[17:41:14.616] - state: ‘finished’
[17:41:14.616] - run: TRUE
[17:41:14.617] - result: ‘FutureResult’
[17:41:14.617] resolved() for ‘SequentialFuture’ ... done
[17:41:14.617] Future #1
[17:41:14.617] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:14.617] - nx: 1
[17:41:14.617] - relay: TRUE
[17:41:14.617] - stdout: TRUE
[17:41:14.617] - signal: TRUE
[17:41:14.617] - resignal: FALSE
[17:41:14.618] - force: TRUE
[17:41:14.618] - relayed: [n=1] FALSE
[17:41:14.618] - queued futures: [n=1] FALSE
[17:41:14.618]  - until=1
[17:41:14.618]  - relaying element #1
[17:41:14.618] - relayed: [n=1] TRUE
[17:41:14.618] - queued futures: [n=1] TRUE
[17:41:14.618] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:14.619]  length: 0 (resolved future 1)
[17:41:14.619] Relaying remaining futures
[17:41:14.619] signalConditionsASAP(NULL, pos=0) ...
[17:41:14.619] - nx: 1
[17:41:14.619] - relay: TRUE
[17:41:14.619] - stdout: TRUE
[17:41:14.619] - signal: TRUE
[17:41:14.619] - resignal: FALSE
[17:41:14.619] - force: TRUE
[17:41:14.619] - relayed: [n=1] TRUE
[17:41:14.619] - queued futures: [n=1] TRUE
 - flush all
[17:41:14.620] - relayed: [n=1] TRUE
[17:41:14.620] - queued futures: [n=1] TRUE
[17:41:14.620] signalConditionsASAP(NULL, pos=0) ... done
[17:41:14.620] resolve() on list ... DONE
[17:41:14.620]  - Number of value chunks collected: 1
[17:41:14.620] Resolving 1 futures (chunks) ... DONE
[17:41:14.620] Reducing values from 1 chunks ...
[17:41:14.620]  - Number of values collected after concatenation: 2
[17:41:14.620]  - Number of values expected: 2
[17:41:14.620] Reducing values from 1 chunks ... DONE
[17:41:14.621] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:41:14.621] future_mapply() ...
[17:41:14.624] Number of chunks: 1
[17:41:14.624] getGlobalsAndPackagesXApply() ...
[17:41:14.624]  - future.globals: TRUE
[17:41:14.625] getGlobalsAndPackages() ...
[17:41:14.625] Searching for globals...
[17:41:14.626] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:14.626] Searching for globals ... DONE
[17:41:14.626] Resolving globals: FALSE
[17:41:14.627] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:14.627] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:14.627] - globals: [1] ‘FUN’
[17:41:14.627] 
[17:41:14.627] getGlobalsAndPackages() ... DONE
[17:41:14.628]  - globals found/used: [n=1] ‘FUN’
[17:41:14.628]  - needed namespaces: [n=0] 
[17:41:14.628] Finding globals ... DONE
[17:41:14.628] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:14.628] List of 2
[17:41:14.628]  $ ...future.FUN:function (x, y)  
[17:41:14.628]  $ MoreArgs     : NULL
[17:41:14.628]  - attr(*, "where")=List of 2
[17:41:14.628]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:14.628]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:14.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:14.628]  - attr(*, "resolved")= logi FALSE
[17:41:14.628]  - attr(*, "total_size")= num NA
[17:41:14.631] Packages to be attached in all futures: [n=0] 
[17:41:14.631] getGlobalsAndPackagesXApply() ... DONE
[17:41:14.631] Number of futures (= number of chunks): 1
[17:41:14.631] Launching 1 futures (chunks) ...
[17:41:14.631] Chunk #1 of 1 ...
[17:41:14.631]  - Finding globals in '...' for chunk #1 ...
[17:41:14.631] getGlobalsAndPackages() ...
[17:41:14.631] Searching for globals...
[17:41:14.632] 
[17:41:14.632] Searching for globals ... DONE
[17:41:14.632] - globals: [0] <none>
[17:41:14.632] getGlobalsAndPackages() ... DONE
[17:41:14.632]    + additional globals found: [n=0] 
[17:41:14.632]    + additional namespaces needed: [n=0] 
[17:41:14.632]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:14.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:14.632]  - seeds: <none>
[17:41:14.633] getGlobalsAndPackages() ...
[17:41:14.633] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:14.633] Resolving globals: FALSE
[17:41:14.633] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:14.634] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:14.634] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:14.634] 
[17:41:14.634] getGlobalsAndPackages() ... DONE
[17:41:14.634] run() for ‘Future’ ...
[17:41:14.634] - state: ‘created’
[17:41:14.634] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:14.638] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:14.638] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:14.638]   - Field: ‘label’
[17:41:14.638]   - Field: ‘local’
[17:41:14.638]   - Field: ‘owner’
[17:41:14.638]   - Field: ‘envir’
[17:41:14.638]   - Field: ‘packages’
[17:41:14.638]   - Field: ‘gc’
[17:41:14.638]   - Field: ‘conditions’
[17:41:14.639]   - Field: ‘expr’
[17:41:14.639]   - Field: ‘uuid’
[17:41:14.639]   - Field: ‘seed’
[17:41:14.639]   - Field: ‘version’
[17:41:14.639]   - Field: ‘result’
[17:41:14.639]   - Field: ‘asynchronous’
[17:41:14.639]   - Field: ‘calls’
[17:41:14.639]   - Field: ‘globals’
[17:41:14.639]   - Field: ‘stdout’
[17:41:14.639]   - Field: ‘earlySignal’
[17:41:14.640]   - Field: ‘lazy’
[17:41:14.640]   - Field: ‘state’
[17:41:14.640] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:14.640] - Launch lazy future ...
[17:41:14.640] Packages needed by the future expression (n = 0): <none>
[17:41:14.640] Packages needed by future strategies (n = 0): <none>
[17:41:14.641] {
[17:41:14.641]     {
[17:41:14.641]         {
[17:41:14.641]             ...future.startTime <- base::Sys.time()
[17:41:14.641]             {
[17:41:14.641]                 {
[17:41:14.641]                   {
[17:41:14.641]                     base::local({
[17:41:14.641]                       has_future <- base::requireNamespace("future", 
[17:41:14.641]                         quietly = TRUE)
[17:41:14.641]                       if (has_future) {
[17:41:14.641]                         ns <- base::getNamespace("future")
[17:41:14.641]                         version <- ns[[".package"]][["version"]]
[17:41:14.641]                         if (is.null(version)) 
[17:41:14.641]                           version <- utils::packageVersion("future")
[17:41:14.641]                       }
[17:41:14.641]                       else {
[17:41:14.641]                         version <- NULL
[17:41:14.641]                       }
[17:41:14.641]                       if (!has_future || version < "1.8.0") {
[17:41:14.641]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:14.641]                           "", base::R.version$version.string), 
[17:41:14.641]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:14.641]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:14.641]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:14.641]                             "release", "version")], collapse = " "), 
[17:41:14.641]                           hostname = base::Sys.info()[["nodename"]])
[17:41:14.641]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:14.641]                           info)
[17:41:14.641]                         info <- base::paste(info, collapse = "; ")
[17:41:14.641]                         if (!has_future) {
[17:41:14.641]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:14.641]                             info)
[17:41:14.641]                         }
[17:41:14.641]                         else {
[17:41:14.641]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:14.641]                             info, version)
[17:41:14.641]                         }
[17:41:14.641]                         base::stop(msg)
[17:41:14.641]                       }
[17:41:14.641]                     })
[17:41:14.641]                   }
[17:41:14.641]                   options(future.plan = NULL)
[17:41:14.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:14.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:14.641]                 }
[17:41:14.641]                 ...future.workdir <- getwd()
[17:41:14.641]             }
[17:41:14.641]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:14.641]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:14.641]         }
[17:41:14.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:14.641]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:14.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:14.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:14.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:14.641]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:14.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:14.641]             base::names(...future.oldOptions))
[17:41:14.641]     }
[17:41:14.641]     if (FALSE) {
[17:41:14.641]     }
[17:41:14.641]     else {
[17:41:14.641]         if (TRUE) {
[17:41:14.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:14.641]                 open = "w")
[17:41:14.641]         }
[17:41:14.641]         else {
[17:41:14.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:14.641]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:14.641]         }
[17:41:14.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:14.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:14.641]             base::sink(type = "output", split = FALSE)
[17:41:14.641]             base::close(...future.stdout)
[17:41:14.641]         }, add = TRUE)
[17:41:14.641]     }
[17:41:14.641]     ...future.frame <- base::sys.nframe()
[17:41:14.641]     ...future.conditions <- base::list()
[17:41:14.641]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:14.641]     if (FALSE) {
[17:41:14.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:14.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:14.641]     }
[17:41:14.641]     ...future.result <- base::tryCatch({
[17:41:14.641]         base::withCallingHandlers({
[17:41:14.641]             ...future.value <- base::withVisible(base::local({
[17:41:14.641]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:14.641]                 if (!identical(...future.globals.maxSize.org, 
[17:41:14.641]                   ...future.globals.maxSize)) {
[17:41:14.641]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:14.641]                   on.exit(options(oopts), add = TRUE)
[17:41:14.641]                 }
[17:41:14.641]                 {
[17:41:14.641]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:14.641]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:14.641]                     USE.NAMES = FALSE)
[17:41:14.641]                   do.call(mapply, args = args)
[17:41:14.641]                 }
[17:41:14.641]             }))
[17:41:14.641]             future::FutureResult(value = ...future.value$value, 
[17:41:14.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:14.641]                   ...future.rng), globalenv = if (FALSE) 
[17:41:14.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:14.641]                     ...future.globalenv.names))
[17:41:14.641]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:14.641]         }, condition = base::local({
[17:41:14.641]             c <- base::c
[17:41:14.641]             inherits <- base::inherits
[17:41:14.641]             invokeRestart <- base::invokeRestart
[17:41:14.641]             length <- base::length
[17:41:14.641]             list <- base::list
[17:41:14.641]             seq.int <- base::seq.int
[17:41:14.641]             signalCondition <- base::signalCondition
[17:41:14.641]             sys.calls <- base::sys.calls
[17:41:14.641]             `[[` <- base::`[[`
[17:41:14.641]             `+` <- base::`+`
[17:41:14.641]             `<<-` <- base::`<<-`
[17:41:14.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:14.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:14.641]                   3L)]
[17:41:14.641]             }
[17:41:14.641]             function(cond) {
[17:41:14.641]                 is_error <- inherits(cond, "error")
[17:41:14.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:14.641]                   NULL)
[17:41:14.641]                 if (is_error) {
[17:41:14.641]                   sessionInformation <- function() {
[17:41:14.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:14.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:14.641]                       search = base::search(), system = base::Sys.info())
[17:41:14.641]                   }
[17:41:14.641]                   ...future.conditions[[length(...future.conditions) + 
[17:41:14.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:14.641]                     cond$call), session = sessionInformation(), 
[17:41:14.641]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:14.641]                   signalCondition(cond)
[17:41:14.641]                 }
[17:41:14.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:14.641]                 "immediateCondition"))) {
[17:41:14.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:14.641]                   ...future.conditions[[length(...future.conditions) + 
[17:41:14.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:14.641]                   if (TRUE && !signal) {
[17:41:14.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:14.641]                     {
[17:41:14.641]                       inherits <- base::inherits
[17:41:14.641]                       invokeRestart <- base::invokeRestart
[17:41:14.641]                       is.null <- base::is.null
[17:41:14.641]                       muffled <- FALSE
[17:41:14.641]                       if (inherits(cond, "message")) {
[17:41:14.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:14.641]                         if (muffled) 
[17:41:14.641]                           invokeRestart("muffleMessage")
[17:41:14.641]                       }
[17:41:14.641]                       else if (inherits(cond, "warning")) {
[17:41:14.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:14.641]                         if (muffled) 
[17:41:14.641]                           invokeRestart("muffleWarning")
[17:41:14.641]                       }
[17:41:14.641]                       else if (inherits(cond, "condition")) {
[17:41:14.641]                         if (!is.null(pattern)) {
[17:41:14.641]                           computeRestarts <- base::computeRestarts
[17:41:14.641]                           grepl <- base::grepl
[17:41:14.641]                           restarts <- computeRestarts(cond)
[17:41:14.641]                           for (restart in restarts) {
[17:41:14.641]                             name <- restart$name
[17:41:14.641]                             if (is.null(name)) 
[17:41:14.641]                               next
[17:41:14.641]                             if (!grepl(pattern, name)) 
[17:41:14.641]                               next
[17:41:14.641]                             invokeRestart(restart)
[17:41:14.641]                             muffled <- TRUE
[17:41:14.641]                             break
[17:41:14.641]                           }
[17:41:14.641]                         }
[17:41:14.641]                       }
[17:41:14.641]                       invisible(muffled)
[17:41:14.641]                     }
[17:41:14.641]                     muffleCondition(cond, pattern = "^muffle")
[17:41:14.641]                   }
[17:41:14.641]                 }
[17:41:14.641]                 else {
[17:41:14.641]                   if (TRUE) {
[17:41:14.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:14.641]                     {
[17:41:14.641]                       inherits <- base::inherits
[17:41:14.641]                       invokeRestart <- base::invokeRestart
[17:41:14.641]                       is.null <- base::is.null
[17:41:14.641]                       muffled <- FALSE
[17:41:14.641]                       if (inherits(cond, "message")) {
[17:41:14.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:14.641]                         if (muffled) 
[17:41:14.641]                           invokeRestart("muffleMessage")
[17:41:14.641]                       }
[17:41:14.641]                       else if (inherits(cond, "warning")) {
[17:41:14.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:14.641]                         if (muffled) 
[17:41:14.641]                           invokeRestart("muffleWarning")
[17:41:14.641]                       }
[17:41:14.641]                       else if (inherits(cond, "condition")) {
[17:41:14.641]                         if (!is.null(pattern)) {
[17:41:14.641]                           computeRestarts <- base::computeRestarts
[17:41:14.641]                           grepl <- base::grepl
[17:41:14.641]                           restarts <- computeRestarts(cond)
[17:41:14.641]                           for (restart in restarts) {
[17:41:14.641]                             name <- restart$name
[17:41:14.641]                             if (is.null(name)) 
[17:41:14.641]                               next
[17:41:14.641]                             if (!grepl(pattern, name)) 
[17:41:14.641]                               next
[17:41:14.641]                             invokeRestart(restart)
[17:41:14.641]                             muffled <- TRUE
[17:41:14.641]                             break
[17:41:14.641]                           }
[17:41:14.641]                         }
[17:41:14.641]                       }
[17:41:14.641]                       invisible(muffled)
[17:41:14.641]                     }
[17:41:14.641]                     muffleCondition(cond, pattern = "^muffle")
[17:41:14.641]                   }
[17:41:14.641]                 }
[17:41:14.641]             }
[17:41:14.641]         }))
[17:41:14.641]     }, error = function(ex) {
[17:41:14.641]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:14.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:14.641]                 ...future.rng), started = ...future.startTime, 
[17:41:14.641]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:14.641]             version = "1.8"), class = "FutureResult")
[17:41:14.641]     }, finally = {
[17:41:14.641]         if (!identical(...future.workdir, getwd())) 
[17:41:14.641]             setwd(...future.workdir)
[17:41:14.641]         {
[17:41:14.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:14.641]                 ...future.oldOptions$nwarnings <- NULL
[17:41:14.641]             }
[17:41:14.641]             base::options(...future.oldOptions)
[17:41:14.641]             if (.Platform$OS.type == "windows") {
[17:41:14.641]                 old_names <- names(...future.oldEnvVars)
[17:41:14.641]                 envs <- base::Sys.getenv()
[17:41:14.641]                 names <- names(envs)
[17:41:14.641]                 common <- intersect(names, old_names)
[17:41:14.641]                 added <- setdiff(names, old_names)
[17:41:14.641]                 removed <- setdiff(old_names, names)
[17:41:14.641]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:14.641]                   envs[common]]
[17:41:14.641]                 NAMES <- toupper(changed)
[17:41:14.641]                 args <- list()
[17:41:14.641]                 for (kk in seq_along(NAMES)) {
[17:41:14.641]                   name <- changed[[kk]]
[17:41:14.641]                   NAME <- NAMES[[kk]]
[17:41:14.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:14.641]                     next
[17:41:14.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:14.641]                 }
[17:41:14.641]                 NAMES <- toupper(added)
[17:41:14.641]                 for (kk in seq_along(NAMES)) {
[17:41:14.641]                   name <- added[[kk]]
[17:41:14.641]                   NAME <- NAMES[[kk]]
[17:41:14.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:14.641]                     next
[17:41:14.641]                   args[[name]] <- ""
[17:41:14.641]                 }
[17:41:14.641]                 NAMES <- toupper(removed)
[17:41:14.641]                 for (kk in seq_along(NAMES)) {
[17:41:14.641]                   name <- removed[[kk]]
[17:41:14.641]                   NAME <- NAMES[[kk]]
[17:41:14.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:14.641]                     next
[17:41:14.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:14.641]                 }
[17:41:14.641]                 if (length(args) > 0) 
[17:41:14.641]                   base::do.call(base::Sys.setenv, args = args)
[17:41:14.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:14.641]             }
[17:41:14.641]             else {
[17:41:14.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:14.641]             }
[17:41:14.641]             {
[17:41:14.641]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:14.641]                   0L) {
[17:41:14.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:14.641]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:14.641]                   base::options(opts)
[17:41:14.641]                 }
[17:41:14.641]                 {
[17:41:14.641]                   {
[17:41:14.641]                     NULL
[17:41:14.641]                     RNGkind("Mersenne-Twister")
[17:41:14.641]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:14.641]                       inherits = FALSE)
[17:41:14.641]                   }
[17:41:14.641]                   options(future.plan = NULL)
[17:41:14.641]                   if (is.na(NA_character_)) 
[17:41:14.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:14.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:14.641]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:14.641]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:14.641]                     envir = parent.frame()) 
[17:41:14.641]                   {
[17:41:14.641]                     if (is.function(workers)) 
[17:41:14.641]                       workers <- workers()
[17:41:14.641]                     workers <- structure(as.integer(workers), 
[17:41:14.641]                       class = class(workers))
[17:41:14.641]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:14.641]                       workers >= 1)
[17:41:14.641]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:14.641]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:14.641]                     }
[17:41:14.641]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:14.641]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:14.641]                       envir = envir)
[17:41:14.641]                     if (!future$lazy) 
[17:41:14.641]                       future <- run(future)
[17:41:14.641]                     invisible(future)
[17:41:14.641]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:14.641]                 }
[17:41:14.641]             }
[17:41:14.641]         }
[17:41:14.641]     })
[17:41:14.641]     if (TRUE) {
[17:41:14.641]         base::sink(type = "output", split = FALSE)
[17:41:14.641]         if (TRUE) {
[17:41:14.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:14.641]         }
[17:41:14.641]         else {
[17:41:14.641]             ...future.result["stdout"] <- base::list(NULL)
[17:41:14.641]         }
[17:41:14.641]         base::close(...future.stdout)
[17:41:14.641]         ...future.stdout <- NULL
[17:41:14.641]     }
[17:41:14.641]     ...future.result$conditions <- ...future.conditions
[17:41:14.641]     ...future.result$finished <- base::Sys.time()
[17:41:14.641]     ...future.result
[17:41:14.641] }
[17:41:14.642] assign_globals() ...
[17:41:14.642] List of 5
[17:41:14.642]  $ ...future.FUN            :function (x, y)  
[17:41:14.642]  $ MoreArgs                 : NULL
[17:41:14.642]  $ ...future.elements_ii    :List of 2
[17:41:14.642]   ..$ :List of 2
[17:41:14.642]   .. ..$ : int 1
[17:41:14.642]   .. ..$ : int 0
[17:41:14.642]   ..$ :List of 2
[17:41:14.642]   .. ..$ : int 0
[17:41:14.642]   .. ..$ : int 1
[17:41:14.642]  $ ...future.seeds_ii       : NULL
[17:41:14.642]  $ ...future.globals.maxSize: NULL
[17:41:14.642]  - attr(*, "resolved")= logi FALSE
[17:41:14.642]  - attr(*, "total_size")= num 6480
[17:41:14.642]  - attr(*, "where")=List of 5
[17:41:14.642]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:14.642]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:14.642]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:14.642]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:14.642]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:14.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:14.642]  - attr(*, "already-done")= logi TRUE
[17:41:14.650] - reassign environment for ‘...future.FUN’
[17:41:14.650] - copied ‘...future.FUN’ to environment
[17:41:14.650] - copied ‘MoreArgs’ to environment
[17:41:14.650] - copied ‘...future.elements_ii’ to environment
[17:41:14.650] - copied ‘...future.seeds_ii’ to environment
[17:41:14.650] - copied ‘...future.globals.maxSize’ to environment
[17:41:14.650] assign_globals() ... done
[17:41:14.650] plan(): Setting new future strategy stack:
[17:41:14.651] List of future strategies:
[17:41:14.651] 1. sequential:
[17:41:14.651]    - args: function (..., envir = parent.frame())
[17:41:14.651]    - tweaked: FALSE
[17:41:14.651]    - call: NULL
[17:41:14.651] plan(): nbrOfWorkers() = 1
[17:41:15.153] plan(): Setting new future strategy stack:
[17:41:15.153] List of future strategies:
[17:41:15.153] 1. multisession:
[17:41:15.153]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:15.153]    - tweaked: FALSE
[17:41:15.153]    - call: plan(strategy)
[17:41:15.157] plan(): nbrOfWorkers() = 1
[17:41:15.157] SequentialFuture started (and completed)
[17:41:15.158] - Launch lazy future ... done
[17:41:15.158] run() for ‘SequentialFuture’ ... done
[17:41:15.158] Created future:
[17:41:15.158] SequentialFuture:
[17:41:15.158] Label: ‘future_mapply-1’
[17:41:15.158] Expression:
[17:41:15.158] {
[17:41:15.158]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.158]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:15.158]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.158]         on.exit(options(oopts), add = TRUE)
[17:41:15.158]     }
[17:41:15.158]     {
[17:41:15.158]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:15.158]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:15.158]         do.call(mapply, args = args)
[17:41:15.158]     }
[17:41:15.158] }
[17:41:15.158] Lazy evaluation: FALSE
[17:41:15.158] Asynchronous evaluation: FALSE
[17:41:15.158] Local evaluation: TRUE
[17:41:15.158] Environment: R_GlobalEnv
[17:41:15.158] Capture standard output: TRUE
[17:41:15.158] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:15.158] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:15.158] Packages: <none>
[17:41:15.158] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:15.158] Resolved: TRUE
[17:41:15.158] Value: 224 bytes of class ‘list’
[17:41:15.158] Early signaling: FALSE
[17:41:15.158] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:15.158] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:15.159] Chunk #1 of 1 ... DONE
[17:41:15.159] Launching 1 futures (chunks) ... DONE
[17:41:15.159] Resolving 1 futures (chunks) ...
[17:41:15.160] resolve() on list ...
[17:41:15.160]  recursive: 0
[17:41:15.160]  length: 1
[17:41:15.160] 
[17:41:15.160] resolved() for ‘SequentialFuture’ ...
[17:41:15.160] - state: ‘finished’
[17:41:15.160] - run: TRUE
[17:41:15.160] - result: ‘FutureResult’
[17:41:15.160] resolved() for ‘SequentialFuture’ ... done
[17:41:15.161] Future #1
[17:41:15.161] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:15.161] - nx: 1
[17:41:15.161] - relay: TRUE
[17:41:15.161] - stdout: TRUE
[17:41:15.161] - signal: TRUE
[17:41:15.161] - resignal: FALSE
[17:41:15.161] - force: TRUE
[17:41:15.161] - relayed: [n=1] FALSE
[17:41:15.161] - queued futures: [n=1] FALSE
[17:41:15.161]  - until=1
[17:41:15.162]  - relaying element #1
[17:41:15.162] - relayed: [n=1] TRUE
[17:41:15.162] - queued futures: [n=1] TRUE
[17:41:15.162] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:15.162]  length: 0 (resolved future 1)
[17:41:15.162] Relaying remaining futures
[17:41:15.162] signalConditionsASAP(NULL, pos=0) ...
[17:41:15.162] - nx: 1
[17:41:15.162] - relay: TRUE
[17:41:15.163] - stdout: TRUE
[17:41:15.163] - signal: TRUE
[17:41:15.163] - resignal: FALSE
[17:41:15.163] - force: TRUE
[17:41:15.163] - relayed: [n=1] TRUE
[17:41:15.163] - queued futures: [n=1] TRUE
 - flush all
[17:41:15.163] - relayed: [n=1] TRUE
[17:41:15.163] - queued futures: [n=1] TRUE
[17:41:15.163] signalConditionsASAP(NULL, pos=0) ... done
[17:41:15.163] resolve() on list ... DONE
[17:41:15.164]  - Number of value chunks collected: 1
[17:41:15.164] Resolving 1 futures (chunks) ... DONE
[17:41:15.164] Reducing values from 1 chunks ...
[17:41:15.164]  - Number of values collected after concatenation: 2
[17:41:15.164]  - Number of values expected: 2
[17:41:15.164] Reducing values from 1 chunks ... DONE
[17:41:15.164] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:41:15.164] future_mapply() ...
[17:41:15.168] Number of chunks: 1
[17:41:15.168] getGlobalsAndPackagesXApply() ...
[17:41:15.168]  - future.globals: TRUE
[17:41:15.168] getGlobalsAndPackages() ...
[17:41:15.168] Searching for globals...
[17:41:15.170] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:15.170] Searching for globals ... DONE
[17:41:15.170] Resolving globals: FALSE
[17:41:15.170] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:15.171] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:15.171] - globals: [1] ‘FUN’
[17:41:15.171] 
[17:41:15.171] getGlobalsAndPackages() ... DONE
[17:41:15.171]  - globals found/used: [n=1] ‘FUN’
[17:41:15.171]  - needed namespaces: [n=0] 
[17:41:15.171] Finding globals ... DONE
[17:41:15.172] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:15.172] List of 2
[17:41:15.172]  $ ...future.FUN:function (x, y)  
[17:41:15.172]  $ MoreArgs     : NULL
[17:41:15.172]  - attr(*, "where")=List of 2
[17:41:15.172]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:15.172]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:15.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:15.172]  - attr(*, "resolved")= logi FALSE
[17:41:15.172]  - attr(*, "total_size")= num NA
[17:41:15.174] Packages to be attached in all futures: [n=0] 
[17:41:15.174] getGlobalsAndPackagesXApply() ... DONE
[17:41:15.175] Number of futures (= number of chunks): 1
[17:41:15.175] Launching 1 futures (chunks) ...
[17:41:15.175] Chunk #1 of 1 ...
[17:41:15.175]  - Finding globals in '...' for chunk #1 ...
[17:41:15.175] getGlobalsAndPackages() ...
[17:41:15.175] Searching for globals...
[17:41:15.176] 
[17:41:15.176] Searching for globals ... DONE
[17:41:15.176] - globals: [0] <none>
[17:41:15.176] getGlobalsAndPackages() ... DONE
[17:41:15.176]    + additional globals found: [n=0] 
[17:41:15.176]    + additional namespaces needed: [n=0] 
[17:41:15.176]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:15.176]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:41:15.176]  - seeds: <none>
[17:41:15.176] getGlobalsAndPackages() ...
[17:41:15.177] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:15.177] Resolving globals: FALSE
[17:41:15.177] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:41:15.179] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:15.179] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:15.179] 
[17:41:15.179] getGlobalsAndPackages() ... DONE
[17:41:15.180] run() for ‘Future’ ...
[17:41:15.180] - state: ‘created’
[17:41:15.180] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:15.184] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:15.184] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:15.184]   - Field: ‘label’
[17:41:15.184]   - Field: ‘local’
[17:41:15.184]   - Field: ‘owner’
[17:41:15.184]   - Field: ‘envir’
[17:41:15.184]   - Field: ‘packages’
[17:41:15.184]   - Field: ‘gc’
[17:41:15.184]   - Field: ‘conditions’
[17:41:15.185]   - Field: ‘expr’
[17:41:15.185]   - Field: ‘uuid’
[17:41:15.185]   - Field: ‘seed’
[17:41:15.185]   - Field: ‘version’
[17:41:15.185]   - Field: ‘result’
[17:41:15.185]   - Field: ‘asynchronous’
[17:41:15.185]   - Field: ‘calls’
[17:41:15.185]   - Field: ‘globals’
[17:41:15.185]   - Field: ‘stdout’
[17:41:15.185]   - Field: ‘earlySignal’
[17:41:15.186]   - Field: ‘lazy’
[17:41:15.186]   - Field: ‘state’
[17:41:15.186] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:15.186] - Launch lazy future ...
[17:41:15.186] Packages needed by the future expression (n = 0): <none>
[17:41:15.186] Packages needed by future strategies (n = 0): <none>
[17:41:15.187] {
[17:41:15.187]     {
[17:41:15.187]         {
[17:41:15.187]             ...future.startTime <- base::Sys.time()
[17:41:15.187]             {
[17:41:15.187]                 {
[17:41:15.187]                   {
[17:41:15.187]                     base::local({
[17:41:15.187]                       has_future <- base::requireNamespace("future", 
[17:41:15.187]                         quietly = TRUE)
[17:41:15.187]                       if (has_future) {
[17:41:15.187]                         ns <- base::getNamespace("future")
[17:41:15.187]                         version <- ns[[".package"]][["version"]]
[17:41:15.187]                         if (is.null(version)) 
[17:41:15.187]                           version <- utils::packageVersion("future")
[17:41:15.187]                       }
[17:41:15.187]                       else {
[17:41:15.187]                         version <- NULL
[17:41:15.187]                       }
[17:41:15.187]                       if (!has_future || version < "1.8.0") {
[17:41:15.187]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:15.187]                           "", base::R.version$version.string), 
[17:41:15.187]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:15.187]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:15.187]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:15.187]                             "release", "version")], collapse = " "), 
[17:41:15.187]                           hostname = base::Sys.info()[["nodename"]])
[17:41:15.187]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:15.187]                           info)
[17:41:15.187]                         info <- base::paste(info, collapse = "; ")
[17:41:15.187]                         if (!has_future) {
[17:41:15.187]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:15.187]                             info)
[17:41:15.187]                         }
[17:41:15.187]                         else {
[17:41:15.187]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:15.187]                             info, version)
[17:41:15.187]                         }
[17:41:15.187]                         base::stop(msg)
[17:41:15.187]                       }
[17:41:15.187]                     })
[17:41:15.187]                   }
[17:41:15.187]                   options(future.plan = NULL)
[17:41:15.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:15.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:15.187]                 }
[17:41:15.187]                 ...future.workdir <- getwd()
[17:41:15.187]             }
[17:41:15.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:15.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:15.187]         }
[17:41:15.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:15.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:41:15.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:15.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:15.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:15.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:15.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:15.187]             base::names(...future.oldOptions))
[17:41:15.187]     }
[17:41:15.187]     if (TRUE) {
[17:41:15.187]     }
[17:41:15.187]     else {
[17:41:15.187]         if (NA) {
[17:41:15.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:15.187]                 open = "w")
[17:41:15.187]         }
[17:41:15.187]         else {
[17:41:15.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:15.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:15.187]         }
[17:41:15.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:15.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:15.187]             base::sink(type = "output", split = FALSE)
[17:41:15.187]             base::close(...future.stdout)
[17:41:15.187]         }, add = TRUE)
[17:41:15.187]     }
[17:41:15.187]     ...future.frame <- base::sys.nframe()
[17:41:15.187]     ...future.conditions <- base::list()
[17:41:15.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:15.187]     if (FALSE) {
[17:41:15.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:15.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:15.187]     }
[17:41:15.187]     ...future.result <- base::tryCatch({
[17:41:15.187]         base::withCallingHandlers({
[17:41:15.187]             ...future.value <- base::withVisible(base::local({
[17:41:15.187]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.187]                 if (!identical(...future.globals.maxSize.org, 
[17:41:15.187]                   ...future.globals.maxSize)) {
[17:41:15.187]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.187]                   on.exit(options(oopts), add = TRUE)
[17:41:15.187]                 }
[17:41:15.187]                 {
[17:41:15.187]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:15.187]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:15.187]                     USE.NAMES = FALSE)
[17:41:15.187]                   do.call(mapply, args = args)
[17:41:15.187]                 }
[17:41:15.187]             }))
[17:41:15.187]             future::FutureResult(value = ...future.value$value, 
[17:41:15.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:15.187]                   ...future.rng), globalenv = if (FALSE) 
[17:41:15.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:15.187]                     ...future.globalenv.names))
[17:41:15.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:15.187]         }, condition = base::local({
[17:41:15.187]             c <- base::c
[17:41:15.187]             inherits <- base::inherits
[17:41:15.187]             invokeRestart <- base::invokeRestart
[17:41:15.187]             length <- base::length
[17:41:15.187]             list <- base::list
[17:41:15.187]             seq.int <- base::seq.int
[17:41:15.187]             signalCondition <- base::signalCondition
[17:41:15.187]             sys.calls <- base::sys.calls
[17:41:15.187]             `[[` <- base::`[[`
[17:41:15.187]             `+` <- base::`+`
[17:41:15.187]             `<<-` <- base::`<<-`
[17:41:15.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:15.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:15.187]                   3L)]
[17:41:15.187]             }
[17:41:15.187]             function(cond) {
[17:41:15.187]                 is_error <- inherits(cond, "error")
[17:41:15.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:15.187]                   NULL)
[17:41:15.187]                 if (is_error) {
[17:41:15.187]                   sessionInformation <- function() {
[17:41:15.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:15.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:15.187]                       search = base::search(), system = base::Sys.info())
[17:41:15.187]                   }
[17:41:15.187]                   ...future.conditions[[length(...future.conditions) + 
[17:41:15.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:15.187]                     cond$call), session = sessionInformation(), 
[17:41:15.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:15.187]                   signalCondition(cond)
[17:41:15.187]                 }
[17:41:15.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:15.187]                 "immediateCondition"))) {
[17:41:15.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:15.187]                   ...future.conditions[[length(...future.conditions) + 
[17:41:15.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:15.187]                   if (TRUE && !signal) {
[17:41:15.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:15.187]                     {
[17:41:15.187]                       inherits <- base::inherits
[17:41:15.187]                       invokeRestart <- base::invokeRestart
[17:41:15.187]                       is.null <- base::is.null
[17:41:15.187]                       muffled <- FALSE
[17:41:15.187]                       if (inherits(cond, "message")) {
[17:41:15.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:15.187]                         if (muffled) 
[17:41:15.187]                           invokeRestart("muffleMessage")
[17:41:15.187]                       }
[17:41:15.187]                       else if (inherits(cond, "warning")) {
[17:41:15.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:15.187]                         if (muffled) 
[17:41:15.187]                           invokeRestart("muffleWarning")
[17:41:15.187]                       }
[17:41:15.187]                       else if (inherits(cond, "condition")) {
[17:41:15.187]                         if (!is.null(pattern)) {
[17:41:15.187]                           computeRestarts <- base::computeRestarts
[17:41:15.187]                           grepl <- base::grepl
[17:41:15.187]                           restarts <- computeRestarts(cond)
[17:41:15.187]                           for (restart in restarts) {
[17:41:15.187]                             name <- restart$name
[17:41:15.187]                             if (is.null(name)) 
[17:41:15.187]                               next
[17:41:15.187]                             if (!grepl(pattern, name)) 
[17:41:15.187]                               next
[17:41:15.187]                             invokeRestart(restart)
[17:41:15.187]                             muffled <- TRUE
[17:41:15.187]                             break
[17:41:15.187]                           }
[17:41:15.187]                         }
[17:41:15.187]                       }
[17:41:15.187]                       invisible(muffled)
[17:41:15.187]                     }
[17:41:15.187]                     muffleCondition(cond, pattern = "^muffle")
[17:41:15.187]                   }
[17:41:15.187]                 }
[17:41:15.187]                 else {
[17:41:15.187]                   if (TRUE) {
[17:41:15.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:15.187]                     {
[17:41:15.187]                       inherits <- base::inherits
[17:41:15.187]                       invokeRestart <- base::invokeRestart
[17:41:15.187]                       is.null <- base::is.null
[17:41:15.187]                       muffled <- FALSE
[17:41:15.187]                       if (inherits(cond, "message")) {
[17:41:15.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:15.187]                         if (muffled) 
[17:41:15.187]                           invokeRestart("muffleMessage")
[17:41:15.187]                       }
[17:41:15.187]                       else if (inherits(cond, "warning")) {
[17:41:15.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:15.187]                         if (muffled) 
[17:41:15.187]                           invokeRestart("muffleWarning")
[17:41:15.187]                       }
[17:41:15.187]                       else if (inherits(cond, "condition")) {
[17:41:15.187]                         if (!is.null(pattern)) {
[17:41:15.187]                           computeRestarts <- base::computeRestarts
[17:41:15.187]                           grepl <- base::grepl
[17:41:15.187]                           restarts <- computeRestarts(cond)
[17:41:15.187]                           for (restart in restarts) {
[17:41:15.187]                             name <- restart$name
[17:41:15.187]                             if (is.null(name)) 
[17:41:15.187]                               next
[17:41:15.187]                             if (!grepl(pattern, name)) 
[17:41:15.187]                               next
[17:41:15.187]                             invokeRestart(restart)
[17:41:15.187]                             muffled <- TRUE
[17:41:15.187]                             break
[17:41:15.187]                           }
[17:41:15.187]                         }
[17:41:15.187]                       }
[17:41:15.187]                       invisible(muffled)
[17:41:15.187]                     }
[17:41:15.187]                     muffleCondition(cond, pattern = "^muffle")
[17:41:15.187]                   }
[17:41:15.187]                 }
[17:41:15.187]             }
[17:41:15.187]         }))
[17:41:15.187]     }, error = function(ex) {
[17:41:15.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:15.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:15.187]                 ...future.rng), started = ...future.startTime, 
[17:41:15.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:15.187]             version = "1.8"), class = "FutureResult")
[17:41:15.187]     }, finally = {
[17:41:15.187]         if (!identical(...future.workdir, getwd())) 
[17:41:15.187]             setwd(...future.workdir)
[17:41:15.187]         {
[17:41:15.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:15.187]                 ...future.oldOptions$nwarnings <- NULL
[17:41:15.187]             }
[17:41:15.187]             base::options(...future.oldOptions)
[17:41:15.187]             if (.Platform$OS.type == "windows") {
[17:41:15.187]                 old_names <- names(...future.oldEnvVars)
[17:41:15.187]                 envs <- base::Sys.getenv()
[17:41:15.187]                 names <- names(envs)
[17:41:15.187]                 common <- intersect(names, old_names)
[17:41:15.187]                 added <- setdiff(names, old_names)
[17:41:15.187]                 removed <- setdiff(old_names, names)
[17:41:15.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:15.187]                   envs[common]]
[17:41:15.187]                 NAMES <- toupper(changed)
[17:41:15.187]                 args <- list()
[17:41:15.187]                 for (kk in seq_along(NAMES)) {
[17:41:15.187]                   name <- changed[[kk]]
[17:41:15.187]                   NAME <- NAMES[[kk]]
[17:41:15.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.187]                     next
[17:41:15.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:15.187]                 }
[17:41:15.187]                 NAMES <- toupper(added)
[17:41:15.187]                 for (kk in seq_along(NAMES)) {
[17:41:15.187]                   name <- added[[kk]]
[17:41:15.187]                   NAME <- NAMES[[kk]]
[17:41:15.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.187]                     next
[17:41:15.187]                   args[[name]] <- ""
[17:41:15.187]                 }
[17:41:15.187]                 NAMES <- toupper(removed)
[17:41:15.187]                 for (kk in seq_along(NAMES)) {
[17:41:15.187]                   name <- removed[[kk]]
[17:41:15.187]                   NAME <- NAMES[[kk]]
[17:41:15.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.187]                     next
[17:41:15.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:15.187]                 }
[17:41:15.187]                 if (length(args) > 0) 
[17:41:15.187]                   base::do.call(base::Sys.setenv, args = args)
[17:41:15.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:15.187]             }
[17:41:15.187]             else {
[17:41:15.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:15.187]             }
[17:41:15.187]             {
[17:41:15.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:15.187]                   0L) {
[17:41:15.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:15.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:15.187]                   base::options(opts)
[17:41:15.187]                 }
[17:41:15.187]                 {
[17:41:15.187]                   {
[17:41:15.187]                     NULL
[17:41:15.187]                     RNGkind("Mersenne-Twister")
[17:41:15.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:15.187]                       inherits = FALSE)
[17:41:15.187]                   }
[17:41:15.187]                   options(future.plan = NULL)
[17:41:15.187]                   if (is.na(NA_character_)) 
[17:41:15.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:15.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:15.187]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:15.187]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:15.187]                     envir = parent.frame()) 
[17:41:15.187]                   {
[17:41:15.187]                     if (is.function(workers)) 
[17:41:15.187]                       workers <- workers()
[17:41:15.187]                     workers <- structure(as.integer(workers), 
[17:41:15.187]                       class = class(workers))
[17:41:15.187]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:15.187]                       workers >= 1)
[17:41:15.187]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:15.187]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:15.187]                     }
[17:41:15.187]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:15.187]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:15.187]                       envir = envir)
[17:41:15.187]                     if (!future$lazy) 
[17:41:15.187]                       future <- run(future)
[17:41:15.187]                     invisible(future)
[17:41:15.187]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:15.187]                 }
[17:41:15.187]             }
[17:41:15.187]         }
[17:41:15.187]     })
[17:41:15.187]     if (FALSE) {
[17:41:15.187]         base::sink(type = "output", split = FALSE)
[17:41:15.187]         if (NA) {
[17:41:15.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:15.187]         }
[17:41:15.187]         else {
[17:41:15.187]             ...future.result["stdout"] <- base::list(NULL)
[17:41:15.187]         }
[17:41:15.187]         base::close(...future.stdout)
[17:41:15.187]         ...future.stdout <- NULL
[17:41:15.187]     }
[17:41:15.187]     ...future.result$conditions <- ...future.conditions
[17:41:15.187]     ...future.result$finished <- base::Sys.time()
[17:41:15.187]     ...future.result
[17:41:15.187] }
[17:41:15.188] assign_globals() ...
[17:41:15.189] List of 5
[17:41:15.189]  $ ...future.FUN            :function (x, y)  
[17:41:15.189]  $ MoreArgs                 : NULL
[17:41:15.189]  $ ...future.elements_ii    :List of 2
[17:41:15.189]   ..$ :List of 2
[17:41:15.189]   .. ..$ : int 1
[17:41:15.189]   .. ..$ : int 0
[17:41:15.189]   ..$ :List of 2
[17:41:15.189]   .. ..$ : int 0
[17:41:15.189]   .. ..$ : int 1
[17:41:15.189]  $ ...future.seeds_ii       : NULL
[17:41:15.189]  $ ...future.globals.maxSize: NULL
[17:41:15.189]  - attr(*, "resolved")= logi FALSE
[17:41:15.189]  - attr(*, "total_size")= num 6480
[17:41:15.189]  - attr(*, "where")=List of 5
[17:41:15.189]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:15.189]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:15.189]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:15.189]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:15.189]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:15.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:15.189]  - attr(*, "already-done")= logi TRUE
[17:41:15.194] - reassign environment for ‘...future.FUN’
[17:41:15.194] - copied ‘...future.FUN’ to environment
[17:41:15.194] - copied ‘MoreArgs’ to environment
[17:41:15.194] - copied ‘...future.elements_ii’ to environment
[17:41:15.194] - copied ‘...future.seeds_ii’ to environment
[17:41:15.195] - copied ‘...future.globals.maxSize’ to environment
[17:41:15.195] assign_globals() ... done
[17:41:15.195] plan(): Setting new future strategy stack:
[17:41:15.195] List of future strategies:
[17:41:15.195] 1. sequential:
[17:41:15.195]    - args: function (..., envir = parent.frame())
[17:41:15.195]    - tweaked: FALSE
[17:41:15.195]    - call: NULL
[17:41:15.195] plan(): nbrOfWorkers() = 1
[17:41:15.697] plan(): Setting new future strategy stack:
[17:41:15.697] List of future strategies:
[17:41:15.697] 1. multisession:
[17:41:15.697]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:15.697]    - tweaked: FALSE
[17:41:15.697]    - call: plan(strategy)
[17:41:15.701] plan(): nbrOfWorkers() = 1
[17:41:15.702] SequentialFuture started (and completed)
[17:41:15.702] - Launch lazy future ... done
[17:41:15.702] run() for ‘SequentialFuture’ ... done
[17:41:15.702] Created future:
[17:41:15.702] SequentialFuture:
[17:41:15.702] Label: ‘future_mapply-1’
[17:41:15.702] Expression:
[17:41:15.702] {
[17:41:15.702]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.702]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:15.702]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.702]         on.exit(options(oopts), add = TRUE)
[17:41:15.702]     }
[17:41:15.702]     {
[17:41:15.702]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:15.702]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:15.702]         do.call(mapply, args = args)
[17:41:15.702]     }
[17:41:15.702] }
[17:41:15.702] Lazy evaluation: FALSE
[17:41:15.702] Asynchronous evaluation: FALSE
[17:41:15.702] Local evaluation: TRUE
[17:41:15.702] Environment: R_GlobalEnv
[17:41:15.702] Capture standard output: NA
[17:41:15.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:15.702] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:15.702] Packages: <none>
[17:41:15.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:15.702] Resolved: TRUE
[17:41:15.702] Value: 224 bytes of class ‘list’
[17:41:15.702] Early signaling: FALSE
[17:41:15.702] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:15.702] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:15.703] Chunk #1 of 1 ... DONE
[17:41:15.704] Launching 1 futures (chunks) ... DONE
[17:41:15.704] Resolving 1 futures (chunks) ...
[17:41:15.704] resolve() on list ...
[17:41:15.704]  recursive: 0
[17:41:15.704]  length: 1
[17:41:15.704] 
[17:41:15.704] resolved() for ‘SequentialFuture’ ...
[17:41:15.704] - state: ‘finished’
[17:41:15.704] - run: TRUE
[17:41:15.704] - result: ‘FutureResult’
[17:41:15.705] resolved() for ‘SequentialFuture’ ... done
[17:41:15.705] Future #1
[17:41:15.705] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:41:15.705] - nx: 1
[17:41:15.705] - relay: TRUE
[17:41:15.705] - stdout: TRUE
[17:41:15.705] - signal: TRUE
[17:41:15.705] - resignal: FALSE
[17:41:15.705] - force: TRUE
[17:41:15.705] - relayed: [n=1] FALSE
[17:41:15.705] - queued futures: [n=1] FALSE
[17:41:15.706]  - until=1
[17:41:15.706]  - relaying element #1
[17:41:15.706] - relayed: [n=1] TRUE
[17:41:15.706] - queued futures: [n=1] TRUE
[17:41:15.706] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:41:15.706]  length: 0 (resolved future 1)
[17:41:15.706] Relaying remaining futures
[17:41:15.706] signalConditionsASAP(NULL, pos=0) ...
[17:41:15.706] - nx: 1
[17:41:15.706] - relay: TRUE
[17:41:15.707] - stdout: TRUE
[17:41:15.707] - signal: TRUE
[17:41:15.707] - resignal: FALSE
[17:41:15.707] - force: TRUE
[17:41:15.707] - relayed: [n=1] TRUE
[17:41:15.707] - queued futures: [n=1] TRUE
 - flush all
[17:41:15.707] - relayed: [n=1] TRUE
[17:41:15.707] - queued futures: [n=1] TRUE
[17:41:15.707] signalConditionsASAP(NULL, pos=0) ... done
[17:41:15.707] resolve() on list ... DONE
[17:41:15.708]  - Number of value chunks collected: 1
[17:41:15.708] Resolving 1 futures (chunks) ... DONE
[17:41:15.708] Reducing values from 1 chunks ...
[17:41:15.708]  - Number of values collected after concatenation: 2
[17:41:15.708]  - Number of values expected: 2
[17:41:15.708] Reducing values from 1 chunks ... DONE
[17:41:15.708] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[17:41:15.714] plan(): Setting new future strategy stack:
[17:41:15.714] List of future strategies:
[17:41:15.714] 1. multicore:
[17:41:15.714]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:15.714]    - tweaked: FALSE
[17:41:15.714]    - call: plan(strategy)
[17:41:15.718] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:41:15.718] future_lapply() ...
[17:41:15.723] Number of chunks: 2
[17:41:15.724] getGlobalsAndPackagesXApply() ...
[17:41:15.724]  - future.globals: TRUE
[17:41:15.724] getGlobalsAndPackages() ...
[17:41:15.724] Searching for globals...
[17:41:15.725] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:15.725] Searching for globals ... DONE
[17:41:15.725] Resolving globals: FALSE
[17:41:15.726] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:15.726] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:15.726] - globals: [1] ‘FUN’
[17:41:15.726] 
[17:41:15.726] getGlobalsAndPackages() ... DONE
[17:41:15.727]  - globals found/used: [n=1] ‘FUN’
[17:41:15.727]  - needed namespaces: [n=0] 
[17:41:15.727] Finding globals ... DONE
[17:41:15.727]  - use_args: TRUE
[17:41:15.727]  - Getting '...' globals ...
[17:41:15.727] resolve() on list ...
[17:41:15.727]  recursive: 0
[17:41:15.727]  length: 1
[17:41:15.728]  elements: ‘...’
[17:41:15.728]  length: 0 (resolved future 1)
[17:41:15.728] resolve() on list ... DONE
[17:41:15.728]    - '...' content: [n=0] 
[17:41:15.728] List of 1
[17:41:15.728]  $ ...: list()
[17:41:15.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:15.728]  - attr(*, "where")=List of 1
[17:41:15.728]   ..$ ...:<environment: 0x55c9872b42f0> 
[17:41:15.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:15.728]  - attr(*, "resolved")= logi TRUE
[17:41:15.728]  - attr(*, "total_size")= num NA
[17:41:15.730]  - Getting '...' globals ... DONE
[17:41:15.731] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:15.731] List of 2
[17:41:15.731]  $ ...future.FUN:function (x)  
[17:41:15.731]  $ ...          : list()
[17:41:15.731]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:15.731]  - attr(*, "where")=List of 2
[17:41:15.731]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:15.731]   ..$ ...          :<environment: 0x55c9872b42f0> 
[17:41:15.731]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:15.731]  - attr(*, "resolved")= logi FALSE
[17:41:15.731]  - attr(*, "total_size")= num 4720
[17:41:15.733] Packages to be attached in all futures: [n=0] 
[17:41:15.733] getGlobalsAndPackagesXApply() ... DONE
[17:41:15.734] Number of futures (= number of chunks): 2
[17:41:15.734] Launching 2 futures (chunks) ...
[17:41:15.734] Chunk #1 of 2 ...
[17:41:15.734]  - Finding globals in 'X' for chunk #1 ...
[17:41:15.734] getGlobalsAndPackages() ...
[17:41:15.734] Searching for globals...
[17:41:15.734] 
[17:41:15.734] Searching for globals ... DONE
[17:41:15.735] - globals: [0] <none>
[17:41:15.735] getGlobalsAndPackages() ... DONE
[17:41:15.735]    + additional globals found: [n=0] 
[17:41:15.735]    + additional namespaces needed: [n=0] 
[17:41:15.735]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:15.735]  - seeds: <none>
[17:41:15.735] getGlobalsAndPackages() ...
[17:41:15.735] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:15.735] Resolving globals: FALSE
[17:41:15.735] Tweak future expression to call with '...' arguments ...
[17:41:15.736] {
[17:41:15.736]     do.call(function(...) {
[17:41:15.736]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.736]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:15.736]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.736]             on.exit(options(oopts), add = TRUE)
[17:41:15.736]         }
[17:41:15.736]         {
[17:41:15.736]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:15.736]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:15.736]                 ...future.FUN(...future.X_jj, ...)
[17:41:15.736]             })
[17:41:15.736]         }
[17:41:15.736]     }, args = future.call.arguments)
[17:41:15.736] }
[17:41:15.736] Tweak future expression to call with '...' arguments ... DONE
[17:41:15.736] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:15.736] 
[17:41:15.736] getGlobalsAndPackages() ... DONE
[17:41:15.737] run() for ‘Future’ ...
[17:41:15.737] - state: ‘created’
[17:41:15.737] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:15.740] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:15.740] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:15.741]   - Field: ‘label’
[17:41:15.741]   - Field: ‘local’
[17:41:15.741]   - Field: ‘owner’
[17:41:15.741]   - Field: ‘envir’
[17:41:15.741]   - Field: ‘workers’
[17:41:15.741]   - Field: ‘packages’
[17:41:15.741]   - Field: ‘gc’
[17:41:15.741]   - Field: ‘job’
[17:41:15.741]   - Field: ‘conditions’
[17:41:15.741]   - Field: ‘expr’
[17:41:15.741]   - Field: ‘uuid’
[17:41:15.742]   - Field: ‘seed’
[17:41:15.742]   - Field: ‘version’
[17:41:15.743]   - Field: ‘result’
[17:41:15.743]   - Field: ‘asynchronous’
[17:41:15.743]   - Field: ‘calls’
[17:41:15.743]   - Field: ‘globals’
[17:41:15.744]   - Field: ‘stdout’
[17:41:15.744]   - Field: ‘earlySignal’
[17:41:15.744]   - Field: ‘lazy’
[17:41:15.744]   - Field: ‘state’
[17:41:15.744] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:15.744] - Launch lazy future ...
[17:41:15.745] Packages needed by the future expression (n = 0): <none>
[17:41:15.745] Packages needed by future strategies (n = 0): <none>
[17:41:15.746] {
[17:41:15.746]     {
[17:41:15.746]         {
[17:41:15.746]             ...future.startTime <- base::Sys.time()
[17:41:15.746]             {
[17:41:15.746]                 {
[17:41:15.746]                   {
[17:41:15.746]                     {
[17:41:15.746]                       base::local({
[17:41:15.746]                         has_future <- base::requireNamespace("future", 
[17:41:15.746]                           quietly = TRUE)
[17:41:15.746]                         if (has_future) {
[17:41:15.746]                           ns <- base::getNamespace("future")
[17:41:15.746]                           version <- ns[[".package"]][["version"]]
[17:41:15.746]                           if (is.null(version)) 
[17:41:15.746]                             version <- utils::packageVersion("future")
[17:41:15.746]                         }
[17:41:15.746]                         else {
[17:41:15.746]                           version <- NULL
[17:41:15.746]                         }
[17:41:15.746]                         if (!has_future || version < "1.8.0") {
[17:41:15.746]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:15.746]                             "", base::R.version$version.string), 
[17:41:15.746]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:15.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:15.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:15.746]                               "release", "version")], collapse = " "), 
[17:41:15.746]                             hostname = base::Sys.info()[["nodename"]])
[17:41:15.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:15.746]                             info)
[17:41:15.746]                           info <- base::paste(info, collapse = "; ")
[17:41:15.746]                           if (!has_future) {
[17:41:15.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:15.746]                               info)
[17:41:15.746]                           }
[17:41:15.746]                           else {
[17:41:15.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:15.746]                               info, version)
[17:41:15.746]                           }
[17:41:15.746]                           base::stop(msg)
[17:41:15.746]                         }
[17:41:15.746]                       })
[17:41:15.746]                     }
[17:41:15.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:15.746]                     base::options(mc.cores = 1L)
[17:41:15.746]                   }
[17:41:15.746]                   options(future.plan = NULL)
[17:41:15.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:15.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:15.746]                 }
[17:41:15.746]                 ...future.workdir <- getwd()
[17:41:15.746]             }
[17:41:15.746]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:15.746]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:15.746]         }
[17:41:15.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:15.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:15.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:15.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:15.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:15.746]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:15.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:15.746]             base::names(...future.oldOptions))
[17:41:15.746]     }
[17:41:15.746]     if (FALSE) {
[17:41:15.746]     }
[17:41:15.746]     else {
[17:41:15.746]         if (FALSE) {
[17:41:15.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:15.746]                 open = "w")
[17:41:15.746]         }
[17:41:15.746]         else {
[17:41:15.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:15.746]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:15.746]         }
[17:41:15.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:15.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:15.746]             base::sink(type = "output", split = FALSE)
[17:41:15.746]             base::close(...future.stdout)
[17:41:15.746]         }, add = TRUE)
[17:41:15.746]     }
[17:41:15.746]     ...future.frame <- base::sys.nframe()
[17:41:15.746]     ...future.conditions <- base::list()
[17:41:15.746]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:15.746]     if (FALSE) {
[17:41:15.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:15.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:15.746]     }
[17:41:15.746]     ...future.result <- base::tryCatch({
[17:41:15.746]         base::withCallingHandlers({
[17:41:15.746]             ...future.value <- base::withVisible(base::local({
[17:41:15.746]                 withCallingHandlers({
[17:41:15.746]                   {
[17:41:15.746]                     do.call(function(...) {
[17:41:15.746]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.746]                       if (!identical(...future.globals.maxSize.org, 
[17:41:15.746]                         ...future.globals.maxSize)) {
[17:41:15.746]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.746]                         on.exit(options(oopts), add = TRUE)
[17:41:15.746]                       }
[17:41:15.746]                       {
[17:41:15.746]                         lapply(seq_along(...future.elements_ii), 
[17:41:15.746]                           FUN = function(jj) {
[17:41:15.746]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:15.746]                             ...future.FUN(...future.X_jj, ...)
[17:41:15.746]                           })
[17:41:15.746]                       }
[17:41:15.746]                     }, args = future.call.arguments)
[17:41:15.746]                   }
[17:41:15.746]                 }, immediateCondition = function(cond) {
[17:41:15.746]                   save_rds <- function (object, pathname, ...) 
[17:41:15.746]                   {
[17:41:15.746]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:15.746]                     if (file_test("-f", pathname_tmp)) {
[17:41:15.746]                       fi_tmp <- file.info(pathname_tmp)
[17:41:15.746]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:15.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:15.746]                         fi_tmp[["mtime"]])
[17:41:15.746]                     }
[17:41:15.746]                     tryCatch({
[17:41:15.746]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:15.746]                     }, error = function(ex) {
[17:41:15.746]                       msg <- conditionMessage(ex)
[17:41:15.746]                       fi_tmp <- file.info(pathname_tmp)
[17:41:15.746]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:15.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:15.746]                         fi_tmp[["mtime"]], msg)
[17:41:15.746]                       ex$message <- msg
[17:41:15.746]                       stop(ex)
[17:41:15.746]                     })
[17:41:15.746]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:15.746]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:15.746]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:15.746]                       fi_tmp <- file.info(pathname_tmp)
[17:41:15.746]                       fi <- file.info(pathname)
[17:41:15.746]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:15.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:15.746]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:15.746]                         fi[["size"]], fi[["mtime"]])
[17:41:15.746]                       stop(msg)
[17:41:15.746]                     }
[17:41:15.746]                     invisible(pathname)
[17:41:15.746]                   }
[17:41:15.746]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:15.746]                     rootPath = tempdir()) 
[17:41:15.746]                   {
[17:41:15.746]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:15.746]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:15.746]                       tmpdir = path, fileext = ".rds")
[17:41:15.746]                     save_rds(obj, file)
[17:41:15.746]                   }
[17:41:15.746]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:15.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:15.746]                   {
[17:41:15.746]                     inherits <- base::inherits
[17:41:15.746]                     invokeRestart <- base::invokeRestart
[17:41:15.746]                     is.null <- base::is.null
[17:41:15.746]                     muffled <- FALSE
[17:41:15.746]                     if (inherits(cond, "message")) {
[17:41:15.746]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:15.746]                       if (muffled) 
[17:41:15.746]                         invokeRestart("muffleMessage")
[17:41:15.746]                     }
[17:41:15.746]                     else if (inherits(cond, "warning")) {
[17:41:15.746]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:15.746]                       if (muffled) 
[17:41:15.746]                         invokeRestart("muffleWarning")
[17:41:15.746]                     }
[17:41:15.746]                     else if (inherits(cond, "condition")) {
[17:41:15.746]                       if (!is.null(pattern)) {
[17:41:15.746]                         computeRestarts <- base::computeRestarts
[17:41:15.746]                         grepl <- base::grepl
[17:41:15.746]                         restarts <- computeRestarts(cond)
[17:41:15.746]                         for (restart in restarts) {
[17:41:15.746]                           name <- restart$name
[17:41:15.746]                           if (is.null(name)) 
[17:41:15.746]                             next
[17:41:15.746]                           if (!grepl(pattern, name)) 
[17:41:15.746]                             next
[17:41:15.746]                           invokeRestart(restart)
[17:41:15.746]                           muffled <- TRUE
[17:41:15.746]                           break
[17:41:15.746]                         }
[17:41:15.746]                       }
[17:41:15.746]                     }
[17:41:15.746]                     invisible(muffled)
[17:41:15.746]                   }
[17:41:15.746]                   muffleCondition(cond)
[17:41:15.746]                 })
[17:41:15.746]             }))
[17:41:15.746]             future::FutureResult(value = ...future.value$value, 
[17:41:15.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:15.746]                   ...future.rng), globalenv = if (FALSE) 
[17:41:15.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:15.746]                     ...future.globalenv.names))
[17:41:15.746]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:15.746]         }, condition = base::local({
[17:41:15.746]             c <- base::c
[17:41:15.746]             inherits <- base::inherits
[17:41:15.746]             invokeRestart <- base::invokeRestart
[17:41:15.746]             length <- base::length
[17:41:15.746]             list <- base::list
[17:41:15.746]             seq.int <- base::seq.int
[17:41:15.746]             signalCondition <- base::signalCondition
[17:41:15.746]             sys.calls <- base::sys.calls
[17:41:15.746]             `[[` <- base::`[[`
[17:41:15.746]             `+` <- base::`+`
[17:41:15.746]             `<<-` <- base::`<<-`
[17:41:15.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:15.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:15.746]                   3L)]
[17:41:15.746]             }
[17:41:15.746]             function(cond) {
[17:41:15.746]                 is_error <- inherits(cond, "error")
[17:41:15.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:15.746]                   NULL)
[17:41:15.746]                 if (is_error) {
[17:41:15.746]                   sessionInformation <- function() {
[17:41:15.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:15.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:15.746]                       search = base::search(), system = base::Sys.info())
[17:41:15.746]                   }
[17:41:15.746]                   ...future.conditions[[length(...future.conditions) + 
[17:41:15.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:15.746]                     cond$call), session = sessionInformation(), 
[17:41:15.746]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:15.746]                   signalCondition(cond)
[17:41:15.746]                 }
[17:41:15.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:15.746]                 "immediateCondition"))) {
[17:41:15.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:15.746]                   ...future.conditions[[length(...future.conditions) + 
[17:41:15.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:15.746]                   if (TRUE && !signal) {
[17:41:15.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:15.746]                     {
[17:41:15.746]                       inherits <- base::inherits
[17:41:15.746]                       invokeRestart <- base::invokeRestart
[17:41:15.746]                       is.null <- base::is.null
[17:41:15.746]                       muffled <- FALSE
[17:41:15.746]                       if (inherits(cond, "message")) {
[17:41:15.746]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:15.746]                         if (muffled) 
[17:41:15.746]                           invokeRestart("muffleMessage")
[17:41:15.746]                       }
[17:41:15.746]                       else if (inherits(cond, "warning")) {
[17:41:15.746]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:15.746]                         if (muffled) 
[17:41:15.746]                           invokeRestart("muffleWarning")
[17:41:15.746]                       }
[17:41:15.746]                       else if (inherits(cond, "condition")) {
[17:41:15.746]                         if (!is.null(pattern)) {
[17:41:15.746]                           computeRestarts <- base::computeRestarts
[17:41:15.746]                           grepl <- base::grepl
[17:41:15.746]                           restarts <- computeRestarts(cond)
[17:41:15.746]                           for (restart in restarts) {
[17:41:15.746]                             name <- restart$name
[17:41:15.746]                             if (is.null(name)) 
[17:41:15.746]                               next
[17:41:15.746]                             if (!grepl(pattern, name)) 
[17:41:15.746]                               next
[17:41:15.746]                             invokeRestart(restart)
[17:41:15.746]                             muffled <- TRUE
[17:41:15.746]                             break
[17:41:15.746]                           }
[17:41:15.746]                         }
[17:41:15.746]                       }
[17:41:15.746]                       invisible(muffled)
[17:41:15.746]                     }
[17:41:15.746]                     muffleCondition(cond, pattern = "^muffle")
[17:41:15.746]                   }
[17:41:15.746]                 }
[17:41:15.746]                 else {
[17:41:15.746]                   if (TRUE) {
[17:41:15.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:15.746]                     {
[17:41:15.746]                       inherits <- base::inherits
[17:41:15.746]                       invokeRestart <- base::invokeRestart
[17:41:15.746]                       is.null <- base::is.null
[17:41:15.746]                       muffled <- FALSE
[17:41:15.746]                       if (inherits(cond, "message")) {
[17:41:15.746]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:15.746]                         if (muffled) 
[17:41:15.746]                           invokeRestart("muffleMessage")
[17:41:15.746]                       }
[17:41:15.746]                       else if (inherits(cond, "warning")) {
[17:41:15.746]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:15.746]                         if (muffled) 
[17:41:15.746]                           invokeRestart("muffleWarning")
[17:41:15.746]                       }
[17:41:15.746]                       else if (inherits(cond, "condition")) {
[17:41:15.746]                         if (!is.null(pattern)) {
[17:41:15.746]                           computeRestarts <- base::computeRestarts
[17:41:15.746]                           grepl <- base::grepl
[17:41:15.746]                           restarts <- computeRestarts(cond)
[17:41:15.746]                           for (restart in restarts) {
[17:41:15.746]                             name <- restart$name
[17:41:15.746]                             if (is.null(name)) 
[17:41:15.746]                               next
[17:41:15.746]                             if (!grepl(pattern, name)) 
[17:41:15.746]                               next
[17:41:15.746]                             invokeRestart(restart)
[17:41:15.746]                             muffled <- TRUE
[17:41:15.746]                             break
[17:41:15.746]                           }
[17:41:15.746]                         }
[17:41:15.746]                       }
[17:41:15.746]                       invisible(muffled)
[17:41:15.746]                     }
[17:41:15.746]                     muffleCondition(cond, pattern = "^muffle")
[17:41:15.746]                   }
[17:41:15.746]                 }
[17:41:15.746]             }
[17:41:15.746]         }))
[17:41:15.746]     }, error = function(ex) {
[17:41:15.746]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:15.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:15.746]                 ...future.rng), started = ...future.startTime, 
[17:41:15.746]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:15.746]             version = "1.8"), class = "FutureResult")
[17:41:15.746]     }, finally = {
[17:41:15.746]         if (!identical(...future.workdir, getwd())) 
[17:41:15.746]             setwd(...future.workdir)
[17:41:15.746]         {
[17:41:15.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:15.746]                 ...future.oldOptions$nwarnings <- NULL
[17:41:15.746]             }
[17:41:15.746]             base::options(...future.oldOptions)
[17:41:15.746]             if (.Platform$OS.type == "windows") {
[17:41:15.746]                 old_names <- names(...future.oldEnvVars)
[17:41:15.746]                 envs <- base::Sys.getenv()
[17:41:15.746]                 names <- names(envs)
[17:41:15.746]                 common <- intersect(names, old_names)
[17:41:15.746]                 added <- setdiff(names, old_names)
[17:41:15.746]                 removed <- setdiff(old_names, names)
[17:41:15.746]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:15.746]                   envs[common]]
[17:41:15.746]                 NAMES <- toupper(changed)
[17:41:15.746]                 args <- list()
[17:41:15.746]                 for (kk in seq_along(NAMES)) {
[17:41:15.746]                   name <- changed[[kk]]
[17:41:15.746]                   NAME <- NAMES[[kk]]
[17:41:15.746]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.746]                     next
[17:41:15.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:15.746]                 }
[17:41:15.746]                 NAMES <- toupper(added)
[17:41:15.746]                 for (kk in seq_along(NAMES)) {
[17:41:15.746]                   name <- added[[kk]]
[17:41:15.746]                   NAME <- NAMES[[kk]]
[17:41:15.746]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.746]                     next
[17:41:15.746]                   args[[name]] <- ""
[17:41:15.746]                 }
[17:41:15.746]                 NAMES <- toupper(removed)
[17:41:15.746]                 for (kk in seq_along(NAMES)) {
[17:41:15.746]                   name <- removed[[kk]]
[17:41:15.746]                   NAME <- NAMES[[kk]]
[17:41:15.746]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.746]                     next
[17:41:15.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:15.746]                 }
[17:41:15.746]                 if (length(args) > 0) 
[17:41:15.746]                   base::do.call(base::Sys.setenv, args = args)
[17:41:15.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:15.746]             }
[17:41:15.746]             else {
[17:41:15.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:15.746]             }
[17:41:15.746]             {
[17:41:15.746]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:15.746]                   0L) {
[17:41:15.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:15.746]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:15.746]                   base::options(opts)
[17:41:15.746]                 }
[17:41:15.746]                 {
[17:41:15.746]                   {
[17:41:15.746]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:15.746]                     NULL
[17:41:15.746]                   }
[17:41:15.746]                   options(future.plan = NULL)
[17:41:15.746]                   if (is.na(NA_character_)) 
[17:41:15.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:15.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:15.746]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:15.746]                     envir = parent.frame()) 
[17:41:15.746]                   {
[17:41:15.746]                     default_workers <- missing(workers)
[17:41:15.746]                     if (is.function(workers)) 
[17:41:15.746]                       workers <- workers()
[17:41:15.746]                     workers <- structure(as.integer(workers), 
[17:41:15.746]                       class = class(workers))
[17:41:15.746]                     stop_if_not(is.finite(workers), workers >= 
[17:41:15.746]                       1L)
[17:41:15.746]                     if ((workers == 1L && !inherits(workers, 
[17:41:15.746]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:15.746]                       if (default_workers) 
[17:41:15.746]                         supportsMulticore(warn = TRUE)
[17:41:15.746]                       return(sequential(..., envir = envir))
[17:41:15.746]                     }
[17:41:15.746]                     oopts <- options(mc.cores = workers)
[17:41:15.746]                     on.exit(options(oopts))
[17:41:15.746]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:15.746]                       envir = envir)
[17:41:15.746]                     if (!future$lazy) 
[17:41:15.746]                       future <- run(future)
[17:41:15.746]                     invisible(future)
[17:41:15.746]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:15.746]                 }
[17:41:15.746]             }
[17:41:15.746]         }
[17:41:15.746]     })
[17:41:15.746]     if (TRUE) {
[17:41:15.746]         base::sink(type = "output", split = FALSE)
[17:41:15.746]         if (FALSE) {
[17:41:15.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:15.746]         }
[17:41:15.746]         else {
[17:41:15.746]             ...future.result["stdout"] <- base::list(NULL)
[17:41:15.746]         }
[17:41:15.746]         base::close(...future.stdout)
[17:41:15.746]         ...future.stdout <- NULL
[17:41:15.746]     }
[17:41:15.746]     ...future.result$conditions <- ...future.conditions
[17:41:15.746]     ...future.result$finished <- base::Sys.time()
[17:41:15.746]     ...future.result
[17:41:15.746] }
[17:41:15.748] assign_globals() ...
[17:41:15.748] List of 5
[17:41:15.748]  $ ...future.FUN            :function (x)  
[17:41:15.748]  $ future.call.arguments    : list()
[17:41:15.748]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:15.748]  $ ...future.elements_ii    :List of 1
[17:41:15.748]   ..$ : int 1
[17:41:15.748]  $ ...future.seeds_ii       : NULL
[17:41:15.748]  $ ...future.globals.maxSize: NULL
[17:41:15.748]  - attr(*, "where")=List of 5
[17:41:15.748]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:15.748]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:15.748]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:15.748]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:15.748]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:15.748]  - attr(*, "resolved")= logi FALSE
[17:41:15.748]  - attr(*, "total_size")= num 4720
[17:41:15.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:15.748]  - attr(*, "already-done")= logi TRUE
[17:41:15.753] - reassign environment for ‘...future.FUN’
[17:41:15.753] - copied ‘...future.FUN’ to environment
[17:41:15.753] - copied ‘future.call.arguments’ to environment
[17:41:15.753] - copied ‘...future.elements_ii’ to environment
[17:41:15.753] - copied ‘...future.seeds_ii’ to environment
[17:41:15.753] - copied ‘...future.globals.maxSize’ to environment
[17:41:15.753] assign_globals() ... done
[17:41:15.754] requestCore(): workers = 2
[17:41:15.757] MulticoreFuture started
[17:41:15.757] - Launch lazy future ... done
[17:41:15.757] plan(): Setting new future strategy stack:
[17:41:15.757] run() for ‘MulticoreFuture’ ... done
[17:41:15.758] Created future:
[17:41:15.758] List of future strategies:
[17:41:15.758] 1. sequential:
[17:41:15.758]    - args: function (..., envir = parent.frame())
[17:41:15.758]    - tweaked: FALSE
[17:41:15.758]    - call: NULL
[17:41:15.759] plan(): nbrOfWorkers() = 1
[17:41:15.758] MulticoreFuture:
[17:41:15.758] Label: ‘future_lapply-1’
[17:41:15.758] Expression:
[17:41:15.758] {
[17:41:15.758]     do.call(function(...) {
[17:41:15.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:15.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.758]             on.exit(options(oopts), add = TRUE)
[17:41:15.758]         }
[17:41:15.758]         {
[17:41:15.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:15.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:15.758]                 ...future.FUN(...future.X_jj, ...)
[17:41:15.758]             })
[17:41:15.758]         }
[17:41:15.758]     }, args = future.call.arguments)
[17:41:15.758] }
[17:41:15.758] Lazy evaluation: FALSE
[17:41:15.758] Asynchronous evaluation: TRUE
[17:41:15.758] Local evaluation: TRUE
[17:41:15.758] Environment: R_GlobalEnv
[17:41:15.758] Capture standard output: FALSE
[17:41:15.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:15.758] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:15.758] Packages: <none>
[17:41:15.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:15.758] Resolved: FALSE
[17:41:15.758] Value: <not collected>
[17:41:15.758] Conditions captured: <none>
[17:41:15.758] Early signaling: FALSE
[17:41:15.758] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:15.758] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:15.773] Chunk #1 of 2 ... DONE
[17:41:15.774] Chunk #2 of 2 ...
[17:41:15.774]  - Finding globals in 'X' for chunk #2 ...
[17:41:15.774] getGlobalsAndPackages() ...
[17:41:15.774] Searching for globals...
[17:41:15.775] 
[17:41:15.775] Searching for globals ... DONE
[17:41:15.775] - globals: [0] <none>
[17:41:15.776] getGlobalsAndPackages() ... DONE
[17:41:15.776]    + additional globals found: [n=0] 
[17:41:15.776]    + additional namespaces needed: [n=0] 
[17:41:15.776]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:15.776]  - seeds: <none>
[17:41:15.777] getGlobalsAndPackages() ...
[17:41:15.777] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:15.777] Resolving globals: FALSE
[17:41:15.777] Tweak future expression to call with '...' arguments ...
[17:41:15.777] {
[17:41:15.777]     do.call(function(...) {
[17:41:15.777]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.777]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:15.777]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.777]             on.exit(options(oopts), add = TRUE)
[17:41:15.777]         }
[17:41:15.777]         {
[17:41:15.777]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:15.777]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:15.777]                 ...future.FUN(...future.X_jj, ...)
[17:41:15.777]             })
[17:41:15.777]         }
[17:41:15.777]     }, args = future.call.arguments)
[17:41:15.777] }
[17:41:15.778] Tweak future expression to call with '...' arguments ... DONE
[17:41:15.779] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:15.779] 
[17:41:15.779] getGlobalsAndPackages() ... DONE
[17:41:15.780] run() for ‘Future’ ...
[17:41:15.780] - state: ‘created’
[17:41:15.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:15.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:15.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:15.786]   - Field: ‘label’
[17:41:15.786]   - Field: ‘local’
[17:41:15.786]   - Field: ‘owner’
[17:41:15.786]   - Field: ‘envir’
[17:41:15.786]   - Field: ‘workers’
[17:41:15.787]   - Field: ‘packages’
[17:41:15.787]   - Field: ‘gc’
[17:41:15.787]   - Field: ‘job’
[17:41:15.787]   - Field: ‘conditions’
[17:41:15.787]   - Field: ‘expr’
[17:41:15.788]   - Field: ‘uuid’
[17:41:15.788]   - Field: ‘seed’
[17:41:15.788]   - Field: ‘version’
[17:41:15.788]   - Field: ‘result’
[17:41:15.788]   - Field: ‘asynchronous’
[17:41:15.788]   - Field: ‘calls’
[17:41:15.788]   - Field: ‘globals’
[17:41:15.789]   - Field: ‘stdout’
[17:41:15.789]   - Field: ‘earlySignal’
[17:41:15.789]   - Field: ‘lazy’
[17:41:15.789]   - Field: ‘state’
[17:41:15.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:15.789] - Launch lazy future ...
[17:41:15.790] Packages needed by the future expression (n = 0): <none>
[17:41:15.790] Packages needed by future strategies (n = 0): <none>
[17:41:15.791] {
[17:41:15.791]     {
[17:41:15.791]         {
[17:41:15.791]             ...future.startTime <- base::Sys.time()
[17:41:15.791]             {
[17:41:15.791]                 {
[17:41:15.791]                   {
[17:41:15.791]                     {
[17:41:15.791]                       base::local({
[17:41:15.791]                         has_future <- base::requireNamespace("future", 
[17:41:15.791]                           quietly = TRUE)
[17:41:15.791]                         if (has_future) {
[17:41:15.791]                           ns <- base::getNamespace("future")
[17:41:15.791]                           version <- ns[[".package"]][["version"]]
[17:41:15.791]                           if (is.null(version)) 
[17:41:15.791]                             version <- utils::packageVersion("future")
[17:41:15.791]                         }
[17:41:15.791]                         else {
[17:41:15.791]                           version <- NULL
[17:41:15.791]                         }
[17:41:15.791]                         if (!has_future || version < "1.8.0") {
[17:41:15.791]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:15.791]                             "", base::R.version$version.string), 
[17:41:15.791]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:15.791]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:15.791]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:15.791]                               "release", "version")], collapse = " "), 
[17:41:15.791]                             hostname = base::Sys.info()[["nodename"]])
[17:41:15.791]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:15.791]                             info)
[17:41:15.791]                           info <- base::paste(info, collapse = "; ")
[17:41:15.791]                           if (!has_future) {
[17:41:15.791]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:15.791]                               info)
[17:41:15.791]                           }
[17:41:15.791]                           else {
[17:41:15.791]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:15.791]                               info, version)
[17:41:15.791]                           }
[17:41:15.791]                           base::stop(msg)
[17:41:15.791]                         }
[17:41:15.791]                       })
[17:41:15.791]                     }
[17:41:15.791]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:15.791]                     base::options(mc.cores = 1L)
[17:41:15.791]                   }
[17:41:15.791]                   options(future.plan = NULL)
[17:41:15.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:15.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:15.791]                 }
[17:41:15.791]                 ...future.workdir <- getwd()
[17:41:15.791]             }
[17:41:15.791]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:15.791]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:15.791]         }
[17:41:15.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:15.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:15.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:15.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:15.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:15.791]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:15.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:15.791]             base::names(...future.oldOptions))
[17:41:15.791]     }
[17:41:15.791]     if (FALSE) {
[17:41:15.791]     }
[17:41:15.791]     else {
[17:41:15.791]         if (FALSE) {
[17:41:15.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:15.791]                 open = "w")
[17:41:15.791]         }
[17:41:15.791]         else {
[17:41:15.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:15.791]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:15.791]         }
[17:41:15.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:15.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:15.791]             base::sink(type = "output", split = FALSE)
[17:41:15.791]             base::close(...future.stdout)
[17:41:15.791]         }, add = TRUE)
[17:41:15.791]     }
[17:41:15.791]     ...future.frame <- base::sys.nframe()
[17:41:15.791]     ...future.conditions <- base::list()
[17:41:15.791]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:15.791]     if (FALSE) {
[17:41:15.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:15.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:15.791]     }
[17:41:15.791]     ...future.result <- base::tryCatch({
[17:41:15.791]         base::withCallingHandlers({
[17:41:15.791]             ...future.value <- base::withVisible(base::local({
[17:41:15.791]                 withCallingHandlers({
[17:41:15.791]                   {
[17:41:15.791]                     do.call(function(...) {
[17:41:15.791]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.791]                       if (!identical(...future.globals.maxSize.org, 
[17:41:15.791]                         ...future.globals.maxSize)) {
[17:41:15.791]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.791]                         on.exit(options(oopts), add = TRUE)
[17:41:15.791]                       }
[17:41:15.791]                       {
[17:41:15.791]                         lapply(seq_along(...future.elements_ii), 
[17:41:15.791]                           FUN = function(jj) {
[17:41:15.791]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:15.791]                             ...future.FUN(...future.X_jj, ...)
[17:41:15.791]                           })
[17:41:15.791]                       }
[17:41:15.791]                     }, args = future.call.arguments)
[17:41:15.791]                   }
[17:41:15.791]                 }, immediateCondition = function(cond) {
[17:41:15.791]                   save_rds <- function (object, pathname, ...) 
[17:41:15.791]                   {
[17:41:15.791]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:15.791]                     if (file_test("-f", pathname_tmp)) {
[17:41:15.791]                       fi_tmp <- file.info(pathname_tmp)
[17:41:15.791]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:15.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:15.791]                         fi_tmp[["mtime"]])
[17:41:15.791]                     }
[17:41:15.791]                     tryCatch({
[17:41:15.791]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:15.791]                     }, error = function(ex) {
[17:41:15.791]                       msg <- conditionMessage(ex)
[17:41:15.791]                       fi_tmp <- file.info(pathname_tmp)
[17:41:15.791]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:15.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:15.791]                         fi_tmp[["mtime"]], msg)
[17:41:15.791]                       ex$message <- msg
[17:41:15.791]                       stop(ex)
[17:41:15.791]                     })
[17:41:15.791]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:15.791]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:15.791]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:15.791]                       fi_tmp <- file.info(pathname_tmp)
[17:41:15.791]                       fi <- file.info(pathname)
[17:41:15.791]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:15.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:15.791]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:15.791]                         fi[["size"]], fi[["mtime"]])
[17:41:15.791]                       stop(msg)
[17:41:15.791]                     }
[17:41:15.791]                     invisible(pathname)
[17:41:15.791]                   }
[17:41:15.791]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:15.791]                     rootPath = tempdir()) 
[17:41:15.791]                   {
[17:41:15.791]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:15.791]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:15.791]                       tmpdir = path, fileext = ".rds")
[17:41:15.791]                     save_rds(obj, file)
[17:41:15.791]                   }
[17:41:15.791]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:15.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:15.791]                   {
[17:41:15.791]                     inherits <- base::inherits
[17:41:15.791]                     invokeRestart <- base::invokeRestart
[17:41:15.791]                     is.null <- base::is.null
[17:41:15.791]                     muffled <- FALSE
[17:41:15.791]                     if (inherits(cond, "message")) {
[17:41:15.791]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:15.791]                       if (muffled) 
[17:41:15.791]                         invokeRestart("muffleMessage")
[17:41:15.791]                     }
[17:41:15.791]                     else if (inherits(cond, "warning")) {
[17:41:15.791]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:15.791]                       if (muffled) 
[17:41:15.791]                         invokeRestart("muffleWarning")
[17:41:15.791]                     }
[17:41:15.791]                     else if (inherits(cond, "condition")) {
[17:41:15.791]                       if (!is.null(pattern)) {
[17:41:15.791]                         computeRestarts <- base::computeRestarts
[17:41:15.791]                         grepl <- base::grepl
[17:41:15.791]                         restarts <- computeRestarts(cond)
[17:41:15.791]                         for (restart in restarts) {
[17:41:15.791]                           name <- restart$name
[17:41:15.791]                           if (is.null(name)) 
[17:41:15.791]                             next
[17:41:15.791]                           if (!grepl(pattern, name)) 
[17:41:15.791]                             next
[17:41:15.791]                           invokeRestart(restart)
[17:41:15.791]                           muffled <- TRUE
[17:41:15.791]                           break
[17:41:15.791]                         }
[17:41:15.791]                       }
[17:41:15.791]                     }
[17:41:15.791]                     invisible(muffled)
[17:41:15.791]                   }
[17:41:15.791]                   muffleCondition(cond)
[17:41:15.791]                 })
[17:41:15.791]             }))
[17:41:15.791]             future::FutureResult(value = ...future.value$value, 
[17:41:15.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:15.791]                   ...future.rng), globalenv = if (FALSE) 
[17:41:15.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:15.791]                     ...future.globalenv.names))
[17:41:15.791]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:15.791]         }, condition = base::local({
[17:41:15.791]             c <- base::c
[17:41:15.791]             inherits <- base::inherits
[17:41:15.791]             invokeRestart <- base::invokeRestart
[17:41:15.791]             length <- base::length
[17:41:15.791]             list <- base::list
[17:41:15.791]             seq.int <- base::seq.int
[17:41:15.791]             signalCondition <- base::signalCondition
[17:41:15.791]             sys.calls <- base::sys.calls
[17:41:15.791]             `[[` <- base::`[[`
[17:41:15.791]             `+` <- base::`+`
[17:41:15.791]             `<<-` <- base::`<<-`
[17:41:15.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:15.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:15.791]                   3L)]
[17:41:15.791]             }
[17:41:15.791]             function(cond) {
[17:41:15.791]                 is_error <- inherits(cond, "error")
[17:41:15.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:15.791]                   NULL)
[17:41:15.791]                 if (is_error) {
[17:41:15.791]                   sessionInformation <- function() {
[17:41:15.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:15.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:15.791]                       search = base::search(), system = base::Sys.info())
[17:41:15.791]                   }
[17:41:15.791]                   ...future.conditions[[length(...future.conditions) + 
[17:41:15.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:15.791]                     cond$call), session = sessionInformation(), 
[17:41:15.791]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:15.791]                   signalCondition(cond)
[17:41:15.791]                 }
[17:41:15.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:15.791]                 "immediateCondition"))) {
[17:41:15.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:15.791]                   ...future.conditions[[length(...future.conditions) + 
[17:41:15.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:15.791]                   if (TRUE && !signal) {
[17:41:15.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:15.791]                     {
[17:41:15.791]                       inherits <- base::inherits
[17:41:15.791]                       invokeRestart <- base::invokeRestart
[17:41:15.791]                       is.null <- base::is.null
[17:41:15.791]                       muffled <- FALSE
[17:41:15.791]                       if (inherits(cond, "message")) {
[17:41:15.791]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:15.791]                         if (muffled) 
[17:41:15.791]                           invokeRestart("muffleMessage")
[17:41:15.791]                       }
[17:41:15.791]                       else if (inherits(cond, "warning")) {
[17:41:15.791]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:15.791]                         if (muffled) 
[17:41:15.791]                           invokeRestart("muffleWarning")
[17:41:15.791]                       }
[17:41:15.791]                       else if (inherits(cond, "condition")) {
[17:41:15.791]                         if (!is.null(pattern)) {
[17:41:15.791]                           computeRestarts <- base::computeRestarts
[17:41:15.791]                           grepl <- base::grepl
[17:41:15.791]                           restarts <- computeRestarts(cond)
[17:41:15.791]                           for (restart in restarts) {
[17:41:15.791]                             name <- restart$name
[17:41:15.791]                             if (is.null(name)) 
[17:41:15.791]                               next
[17:41:15.791]                             if (!grepl(pattern, name)) 
[17:41:15.791]                               next
[17:41:15.791]                             invokeRestart(restart)
[17:41:15.791]                             muffled <- TRUE
[17:41:15.791]                             break
[17:41:15.791]                           }
[17:41:15.791]                         }
[17:41:15.791]                       }
[17:41:15.791]                       invisible(muffled)
[17:41:15.791]                     }
[17:41:15.791]                     muffleCondition(cond, pattern = "^muffle")
[17:41:15.791]                   }
[17:41:15.791]                 }
[17:41:15.791]                 else {
[17:41:15.791]                   if (TRUE) {
[17:41:15.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:15.791]                     {
[17:41:15.791]                       inherits <- base::inherits
[17:41:15.791]                       invokeRestart <- base::invokeRestart
[17:41:15.791]                       is.null <- base::is.null
[17:41:15.791]                       muffled <- FALSE
[17:41:15.791]                       if (inherits(cond, "message")) {
[17:41:15.791]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:15.791]                         if (muffled) 
[17:41:15.791]                           invokeRestart("muffleMessage")
[17:41:15.791]                       }
[17:41:15.791]                       else if (inherits(cond, "warning")) {
[17:41:15.791]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:15.791]                         if (muffled) 
[17:41:15.791]                           invokeRestart("muffleWarning")
[17:41:15.791]                       }
[17:41:15.791]                       else if (inherits(cond, "condition")) {
[17:41:15.791]                         if (!is.null(pattern)) {
[17:41:15.791]                           computeRestarts <- base::computeRestarts
[17:41:15.791]                           grepl <- base::grepl
[17:41:15.791]                           restarts <- computeRestarts(cond)
[17:41:15.791]                           for (restart in restarts) {
[17:41:15.791]                             name <- restart$name
[17:41:15.791]                             if (is.null(name)) 
[17:41:15.791]                               next
[17:41:15.791]                             if (!grepl(pattern, name)) 
[17:41:15.791]                               next
[17:41:15.791]                             invokeRestart(restart)
[17:41:15.791]                             muffled <- TRUE
[17:41:15.791]                             break
[17:41:15.791]                           }
[17:41:15.791]                         }
[17:41:15.791]                       }
[17:41:15.791]                       invisible(muffled)
[17:41:15.791]                     }
[17:41:15.791]                     muffleCondition(cond, pattern = "^muffle")
[17:41:15.791]                   }
[17:41:15.791]                 }
[17:41:15.791]             }
[17:41:15.791]         }))
[17:41:15.791]     }, error = function(ex) {
[17:41:15.791]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:15.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:15.791]                 ...future.rng), started = ...future.startTime, 
[17:41:15.791]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:15.791]             version = "1.8"), class = "FutureResult")
[17:41:15.791]     }, finally = {
[17:41:15.791]         if (!identical(...future.workdir, getwd())) 
[17:41:15.791]             setwd(...future.workdir)
[17:41:15.791]         {
[17:41:15.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:15.791]                 ...future.oldOptions$nwarnings <- NULL
[17:41:15.791]             }
[17:41:15.791]             base::options(...future.oldOptions)
[17:41:15.791]             if (.Platform$OS.type == "windows") {
[17:41:15.791]                 old_names <- names(...future.oldEnvVars)
[17:41:15.791]                 envs <- base::Sys.getenv()
[17:41:15.791]                 names <- names(envs)
[17:41:15.791]                 common <- intersect(names, old_names)
[17:41:15.791]                 added <- setdiff(names, old_names)
[17:41:15.791]                 removed <- setdiff(old_names, names)
[17:41:15.791]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:15.791]                   envs[common]]
[17:41:15.791]                 NAMES <- toupper(changed)
[17:41:15.791]                 args <- list()
[17:41:15.791]                 for (kk in seq_along(NAMES)) {
[17:41:15.791]                   name <- changed[[kk]]
[17:41:15.791]                   NAME <- NAMES[[kk]]
[17:41:15.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.791]                     next
[17:41:15.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:15.791]                 }
[17:41:15.791]                 NAMES <- toupper(added)
[17:41:15.791]                 for (kk in seq_along(NAMES)) {
[17:41:15.791]                   name <- added[[kk]]
[17:41:15.791]                   NAME <- NAMES[[kk]]
[17:41:15.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.791]                     next
[17:41:15.791]                   args[[name]] <- ""
[17:41:15.791]                 }
[17:41:15.791]                 NAMES <- toupper(removed)
[17:41:15.791]                 for (kk in seq_along(NAMES)) {
[17:41:15.791]                   name <- removed[[kk]]
[17:41:15.791]                   NAME <- NAMES[[kk]]
[17:41:15.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:15.791]                     next
[17:41:15.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:15.791]                 }
[17:41:15.791]                 if (length(args) > 0) 
[17:41:15.791]                   base::do.call(base::Sys.setenv, args = args)
[17:41:15.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:15.791]             }
[17:41:15.791]             else {
[17:41:15.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:15.791]             }
[17:41:15.791]             {
[17:41:15.791]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:15.791]                   0L) {
[17:41:15.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:15.791]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:15.791]                   base::options(opts)
[17:41:15.791]                 }
[17:41:15.791]                 {
[17:41:15.791]                   {
[17:41:15.791]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:15.791]                     NULL
[17:41:15.791]                   }
[17:41:15.791]                   options(future.plan = NULL)
[17:41:15.791]                   if (is.na(NA_character_)) 
[17:41:15.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:15.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:15.791]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:15.791]                     envir = parent.frame()) 
[17:41:15.791]                   {
[17:41:15.791]                     default_workers <- missing(workers)
[17:41:15.791]                     if (is.function(workers)) 
[17:41:15.791]                       workers <- workers()
[17:41:15.791]                     workers <- structure(as.integer(workers), 
[17:41:15.791]                       class = class(workers))
[17:41:15.791]                     stop_if_not(is.finite(workers), workers >= 
[17:41:15.791]                       1L)
[17:41:15.791]                     if ((workers == 1L && !inherits(workers, 
[17:41:15.791]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:15.791]                       if (default_workers) 
[17:41:15.791]                         supportsMulticore(warn = TRUE)
[17:41:15.791]                       return(sequential(..., envir = envir))
[17:41:15.791]                     }
[17:41:15.791]                     oopts <- options(mc.cores = workers)
[17:41:15.791]                     on.exit(options(oopts))
[17:41:15.791]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:15.791]                       envir = envir)
[17:41:15.791]                     if (!future$lazy) 
[17:41:15.791]                       future <- run(future)
[17:41:15.791]                     invisible(future)
[17:41:15.791]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:15.791]                 }
[17:41:15.791]             }
[17:41:15.791]         }
[17:41:15.791]     })
[17:41:15.791]     if (TRUE) {
[17:41:15.791]         base::sink(type = "output", split = FALSE)
[17:41:15.791]         if (FALSE) {
[17:41:15.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:15.791]         }
[17:41:15.791]         else {
[17:41:15.791]             ...future.result["stdout"] <- base::list(NULL)
[17:41:15.791]         }
[17:41:15.791]         base::close(...future.stdout)
[17:41:15.791]         ...future.stdout <- NULL
[17:41:15.791]     }
[17:41:15.791]     ...future.result$conditions <- ...future.conditions
[17:41:15.791]     ...future.result$finished <- base::Sys.time()
[17:41:15.791]     ...future.result
[17:41:15.791] }
[17:41:15.794] assign_globals() ...
[17:41:15.794] List of 5
[17:41:15.794]  $ ...future.FUN            :function (x)  
[17:41:15.794]  $ future.call.arguments    : list()
[17:41:15.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:15.794]  $ ...future.elements_ii    :List of 1
[17:41:15.794]   ..$ : int 0
[17:41:15.794]  $ ...future.seeds_ii       : NULL
[17:41:15.794]  $ ...future.globals.maxSize: NULL
[17:41:15.794]  - attr(*, "where")=List of 5
[17:41:15.794]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:15.794]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:15.794]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:15.794]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:15.794]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:15.794]  - attr(*, "resolved")= logi FALSE
[17:41:15.794]  - attr(*, "total_size")= num 4720
[17:41:15.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:15.794]  - attr(*, "already-done")= logi TRUE
[17:41:15.805] - reassign environment for ‘...future.FUN’
[17:41:15.805] - copied ‘...future.FUN’ to environment
[17:41:15.806] - copied ‘future.call.arguments’ to environment
[17:41:15.806] - copied ‘...future.elements_ii’ to environment
[17:41:15.806] - copied ‘...future.seeds_ii’ to environment
[17:41:15.806] - copied ‘...future.globals.maxSize’ to environment
[17:41:15.806] assign_globals() ... done
[17:41:15.806] requestCore(): workers = 2
[17:41:15.813] MulticoreFuture started
[17:41:15.813] - Launch lazy future ... done
[17:41:15.814] run() for ‘MulticoreFuture’ ... done
[17:41:15.814] Created future:
[17:41:15.814] plan(): Setting new future strategy stack:
[17:41:15.814] List of future strategies:
[17:41:15.814] 1. sequential:
[17:41:15.814]    - args: function (..., envir = parent.frame())
[17:41:15.814]    - tweaked: FALSE
[17:41:15.814]    - call: NULL
[17:41:15.815] plan(): nbrOfWorkers() = 1
[17:41:15.817] plan(): Setting new future strategy stack:
[17:41:15.818] List of future strategies:
[17:41:15.818] 1. multicore:
[17:41:15.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:15.818]    - tweaked: FALSE
[17:41:15.818]    - call: plan(strategy)
[17:41:15.822] plan(): nbrOfWorkers() = 2
[17:41:15.814] MulticoreFuture:
[17:41:15.814] Label: ‘future_lapply-2’
[17:41:15.814] Expression:
[17:41:15.814] {
[17:41:15.814]     do.call(function(...) {
[17:41:15.814]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:15.814]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:15.814]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:15.814]             on.exit(options(oopts), add = TRUE)
[17:41:15.814]         }
[17:41:15.814]         {
[17:41:15.814]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:15.814]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:15.814]                 ...future.FUN(...future.X_jj, ...)
[17:41:15.814]             })
[17:41:15.814]         }
[17:41:15.814]     }, args = future.call.arguments)
[17:41:15.814] }
[17:41:15.814] Lazy evaluation: FALSE
[17:41:15.814] Asynchronous evaluation: TRUE
[17:41:15.814] Local evaluation: TRUE
[17:41:15.814] Environment: R_GlobalEnv
[17:41:15.814] Capture standard output: FALSE
[17:41:15.814] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:15.814] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:15.814] Packages: <none>
[17:41:15.814] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:15.814] Resolved: TRUE
[17:41:15.814] Value: <not collected>
[17:41:15.814] Conditions captured: <none>
[17:41:15.814] Early signaling: FALSE
[17:41:15.814] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:15.814] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:15.824] Chunk #2 of 2 ... DONE
[17:41:15.824] Launching 2 futures (chunks) ... DONE
[17:41:15.824] Resolving 2 futures (chunks) ...
[17:41:15.824] resolve() on list ...
[17:41:15.824]  recursive: 0
[17:41:15.824]  length: 2
[17:41:15.824] 
[17:41:15.835] Future #2
[17:41:15.838] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:41:15.838] - nx: 2
[17:41:15.838] - relay: TRUE
[17:41:15.838] - stdout: TRUE
[17:41:15.838] - signal: TRUE
[17:41:15.838] - resignal: FALSE
[17:41:15.839] - force: TRUE
[17:41:15.839] - relayed: [n=2] FALSE, FALSE
[17:41:15.839] - queued futures: [n=2] FALSE, FALSE
[17:41:15.839]  - until=1
[17:41:15.839]  - relaying element #1
[17:41:15.839] - relayed: [n=2] FALSE, FALSE
[17:41:15.839] - queued futures: [n=2] FALSE, TRUE
[17:41:15.840] signalConditionsASAP(NULL, pos=2) ... done
[17:41:15.840]  length: 1 (resolved future 2)
[17:41:16.261] plan(): Setting new future strategy stack:
[17:41:16.262] List of future strategies:
[17:41:16.262] 1. multicore:
[17:41:16.262]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:16.262]    - tweaked: FALSE
[17:41:16.262]    - call: plan(strategy)
[17:41:16.266] plan(): nbrOfWorkers() = 2
[17:41:16.266] Future #1
[17:41:16.267] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:41:16.268] - nx: 2
[17:41:16.268] - relay: TRUE
[17:41:16.268] - stdout: TRUE
[17:41:16.268] - signal: TRUE
[17:41:16.268] - resignal: FALSE
[17:41:16.268] - force: TRUE
[17:41:16.268] - relayed: [n=2] FALSE, FALSE
[17:41:16.268] - queued futures: [n=2] FALSE, TRUE
[17:41:16.268]  - until=1
[17:41:16.268]  - relaying element #1
[17:41:16.269] - relayed: [n=2] TRUE, FALSE
[17:41:16.269] - queued futures: [n=2] TRUE, TRUE
[17:41:16.269] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:41:16.269]  length: 0 (resolved future 1)
[17:41:16.269] Relaying remaining futures
[17:41:16.269] signalConditionsASAP(NULL, pos=0) ...
[17:41:16.269] - nx: 2
[17:41:16.269] - relay: TRUE
[17:41:16.270] - stdout: TRUE
[17:41:16.270] - signal: TRUE
[17:41:16.270] - resignal: FALSE
[17:41:16.270] - force: TRUE
[17:41:16.270] - relayed: [n=2] TRUE, FALSE
[17:41:16.270] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:16.270]  - relaying element #2
[17:41:16.270] - relayed: [n=2] TRUE, TRUE
[17:41:16.271] - queued futures: [n=2] TRUE, TRUE
[17:41:16.271] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:41:16.271] resolve() on list ... DONE
[17:41:16.271]  - Number of value chunks collected: 2
[17:41:16.271] Resolving 2 futures (chunks) ... DONE
[17:41:16.271] Reducing values from 2 chunks ...
[17:41:16.271]  - Number of values collected after concatenation: 2
[17:41:16.272]  - Number of values expected: 2
[17:41:16.272] Reducing values from 2 chunks ... DONE
[17:41:16.272] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:41:16.272] future_lapply() ...
[17:41:16.277] Number of chunks: 2
[17:41:16.277] getGlobalsAndPackagesXApply() ...
[17:41:16.278]  - future.globals: TRUE
[17:41:16.278] getGlobalsAndPackages() ...
[17:41:16.278] Searching for globals...
[17:41:16.279] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:16.280] Searching for globals ... DONE
[17:41:16.280] Resolving globals: FALSE
[17:41:16.280] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:16.281] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:16.281] - globals: [1] ‘FUN’
[17:41:16.281] 
[17:41:16.281] getGlobalsAndPackages() ... DONE
[17:41:16.281]  - globals found/used: [n=1] ‘FUN’
[17:41:16.281]  - needed namespaces: [n=0] 
[17:41:16.281] Finding globals ... DONE
[17:41:16.281]  - use_args: TRUE
[17:41:16.282]  - Getting '...' globals ...
[17:41:16.282] resolve() on list ...
[17:41:16.282]  recursive: 0
[17:41:16.282]  length: 1
[17:41:16.282]  elements: ‘...’
[17:41:16.282]  length: 0 (resolved future 1)
[17:41:16.283] resolve() on list ... DONE
[17:41:16.284]    - '...' content: [n=0] 
[17:41:16.285] List of 1
[17:41:16.285]  $ ...: list()
[17:41:16.285]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:16.285]  - attr(*, "where")=List of 1
[17:41:16.285]   ..$ ...:<environment: 0x55c988a317d8> 
[17:41:16.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:16.285]  - attr(*, "resolved")= logi TRUE
[17:41:16.285]  - attr(*, "total_size")= num NA
[17:41:16.288]  - Getting '...' globals ... DONE
[17:41:16.288] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:16.289] List of 2
[17:41:16.289]  $ ...future.FUN:function (x)  
[17:41:16.289]  $ ...          : list()
[17:41:16.289]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:16.289]  - attr(*, "where")=List of 2
[17:41:16.289]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:16.289]   ..$ ...          :<environment: 0x55c988a317d8> 
[17:41:16.289]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:16.289]  - attr(*, "resolved")= logi FALSE
[17:41:16.289]  - attr(*, "total_size")= num 4720
[17:41:16.292] Packages to be attached in all futures: [n=0] 
[17:41:16.292] getGlobalsAndPackagesXApply() ... DONE
[17:41:16.292] Number of futures (= number of chunks): 2
[17:41:16.292] Launching 2 futures (chunks) ...
[17:41:16.292] Chunk #1 of 2 ...
[17:41:16.293]  - Finding globals in 'X' for chunk #1 ...
[17:41:16.293] getGlobalsAndPackages() ...
[17:41:16.293] Searching for globals...
[17:41:16.293] 
[17:41:16.293] Searching for globals ... DONE
[17:41:16.293] - globals: [0] <none>
[17:41:16.293] getGlobalsAndPackages() ... DONE
[17:41:16.293]    + additional globals found: [n=0] 
[17:41:16.293]    + additional namespaces needed: [n=0] 
[17:41:16.294]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:16.294]  - seeds: <none>
[17:41:16.294] getGlobalsAndPackages() ...
[17:41:16.294] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:16.294] Resolving globals: FALSE
[17:41:16.294] Tweak future expression to call with '...' arguments ...
[17:41:16.294] {
[17:41:16.294]     do.call(function(...) {
[17:41:16.294]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.294]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:16.294]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.294]             on.exit(options(oopts), add = TRUE)
[17:41:16.294]         }
[17:41:16.294]         {
[17:41:16.294]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:16.294]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.294]                 ...future.FUN(...future.X_jj, ...)
[17:41:16.294]             })
[17:41:16.294]         }
[17:41:16.294]     }, args = future.call.arguments)
[17:41:16.294] }
[17:41:16.294] Tweak future expression to call with '...' arguments ... DONE
[17:41:16.295] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:16.295] 
[17:41:16.295] getGlobalsAndPackages() ... DONE
[17:41:16.295] run() for ‘Future’ ...
[17:41:16.295] - state: ‘created’
[17:41:16.296] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:16.299] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:16.299] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:16.299]   - Field: ‘label’
[17:41:16.300]   - Field: ‘local’
[17:41:16.300]   - Field: ‘owner’
[17:41:16.300]   - Field: ‘envir’
[17:41:16.300]   - Field: ‘workers’
[17:41:16.300]   - Field: ‘packages’
[17:41:16.300]   - Field: ‘gc’
[17:41:16.300]   - Field: ‘job’
[17:41:16.300]   - Field: ‘conditions’
[17:41:16.300]   - Field: ‘expr’
[17:41:16.300]   - Field: ‘uuid’
[17:41:16.300]   - Field: ‘seed’
[17:41:16.301]   - Field: ‘version’
[17:41:16.301]   - Field: ‘result’
[17:41:16.301]   - Field: ‘asynchronous’
[17:41:16.301]   - Field: ‘calls’
[17:41:16.301]   - Field: ‘globals’
[17:41:16.301]   - Field: ‘stdout’
[17:41:16.301]   - Field: ‘earlySignal’
[17:41:16.301]   - Field: ‘lazy’
[17:41:16.301]   - Field: ‘state’
[17:41:16.301] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:16.301] - Launch lazy future ...
[17:41:16.302] Packages needed by the future expression (n = 0): <none>
[17:41:16.302] Packages needed by future strategies (n = 0): <none>
[17:41:16.302] {
[17:41:16.302]     {
[17:41:16.302]         {
[17:41:16.302]             ...future.startTime <- base::Sys.time()
[17:41:16.302]             {
[17:41:16.302]                 {
[17:41:16.302]                   {
[17:41:16.302]                     {
[17:41:16.302]                       base::local({
[17:41:16.302]                         has_future <- base::requireNamespace("future", 
[17:41:16.302]                           quietly = TRUE)
[17:41:16.302]                         if (has_future) {
[17:41:16.302]                           ns <- base::getNamespace("future")
[17:41:16.302]                           version <- ns[[".package"]][["version"]]
[17:41:16.302]                           if (is.null(version)) 
[17:41:16.302]                             version <- utils::packageVersion("future")
[17:41:16.302]                         }
[17:41:16.302]                         else {
[17:41:16.302]                           version <- NULL
[17:41:16.302]                         }
[17:41:16.302]                         if (!has_future || version < "1.8.0") {
[17:41:16.302]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:16.302]                             "", base::R.version$version.string), 
[17:41:16.302]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:16.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:16.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:16.302]                               "release", "version")], collapse = " "), 
[17:41:16.302]                             hostname = base::Sys.info()[["nodename"]])
[17:41:16.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:16.302]                             info)
[17:41:16.302]                           info <- base::paste(info, collapse = "; ")
[17:41:16.302]                           if (!has_future) {
[17:41:16.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:16.302]                               info)
[17:41:16.302]                           }
[17:41:16.302]                           else {
[17:41:16.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:16.302]                               info, version)
[17:41:16.302]                           }
[17:41:16.302]                           base::stop(msg)
[17:41:16.302]                         }
[17:41:16.302]                       })
[17:41:16.302]                     }
[17:41:16.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:16.302]                     base::options(mc.cores = 1L)
[17:41:16.302]                   }
[17:41:16.302]                   options(future.plan = NULL)
[17:41:16.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:16.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:16.302]                 }
[17:41:16.302]                 ...future.workdir <- getwd()
[17:41:16.302]             }
[17:41:16.302]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:16.302]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:16.302]         }
[17:41:16.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:16.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:16.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:16.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:16.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:16.302]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:16.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:16.302]             base::names(...future.oldOptions))
[17:41:16.302]     }
[17:41:16.302]     if (FALSE) {
[17:41:16.302]     }
[17:41:16.302]     else {
[17:41:16.302]         if (TRUE) {
[17:41:16.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:16.302]                 open = "w")
[17:41:16.302]         }
[17:41:16.302]         else {
[17:41:16.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:16.302]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:16.302]         }
[17:41:16.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:16.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:16.302]             base::sink(type = "output", split = FALSE)
[17:41:16.302]             base::close(...future.stdout)
[17:41:16.302]         }, add = TRUE)
[17:41:16.302]     }
[17:41:16.302]     ...future.frame <- base::sys.nframe()
[17:41:16.302]     ...future.conditions <- base::list()
[17:41:16.302]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:16.302]     if (FALSE) {
[17:41:16.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:16.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:16.302]     }
[17:41:16.302]     ...future.result <- base::tryCatch({
[17:41:16.302]         base::withCallingHandlers({
[17:41:16.302]             ...future.value <- base::withVisible(base::local({
[17:41:16.302]                 withCallingHandlers({
[17:41:16.302]                   {
[17:41:16.302]                     do.call(function(...) {
[17:41:16.302]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.302]                       if (!identical(...future.globals.maxSize.org, 
[17:41:16.302]                         ...future.globals.maxSize)) {
[17:41:16.302]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.302]                         on.exit(options(oopts), add = TRUE)
[17:41:16.302]                       }
[17:41:16.302]                       {
[17:41:16.302]                         lapply(seq_along(...future.elements_ii), 
[17:41:16.302]                           FUN = function(jj) {
[17:41:16.302]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.302]                             ...future.FUN(...future.X_jj, ...)
[17:41:16.302]                           })
[17:41:16.302]                       }
[17:41:16.302]                     }, args = future.call.arguments)
[17:41:16.302]                   }
[17:41:16.302]                 }, immediateCondition = function(cond) {
[17:41:16.302]                   save_rds <- function (object, pathname, ...) 
[17:41:16.302]                   {
[17:41:16.302]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:16.302]                     if (file_test("-f", pathname_tmp)) {
[17:41:16.302]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.302]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:16.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.302]                         fi_tmp[["mtime"]])
[17:41:16.302]                     }
[17:41:16.302]                     tryCatch({
[17:41:16.302]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:16.302]                     }, error = function(ex) {
[17:41:16.302]                       msg <- conditionMessage(ex)
[17:41:16.302]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.302]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:16.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.302]                         fi_tmp[["mtime"]], msg)
[17:41:16.302]                       ex$message <- msg
[17:41:16.302]                       stop(ex)
[17:41:16.302]                     })
[17:41:16.302]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:16.302]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:16.302]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:16.302]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.302]                       fi <- file.info(pathname)
[17:41:16.302]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:16.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.302]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:16.302]                         fi[["size"]], fi[["mtime"]])
[17:41:16.302]                       stop(msg)
[17:41:16.302]                     }
[17:41:16.302]                     invisible(pathname)
[17:41:16.302]                   }
[17:41:16.302]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:16.302]                     rootPath = tempdir()) 
[17:41:16.302]                   {
[17:41:16.302]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:16.302]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:16.302]                       tmpdir = path, fileext = ".rds")
[17:41:16.302]                     save_rds(obj, file)
[17:41:16.302]                   }
[17:41:16.302]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:16.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.302]                   {
[17:41:16.302]                     inherits <- base::inherits
[17:41:16.302]                     invokeRestart <- base::invokeRestart
[17:41:16.302]                     is.null <- base::is.null
[17:41:16.302]                     muffled <- FALSE
[17:41:16.302]                     if (inherits(cond, "message")) {
[17:41:16.302]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:16.302]                       if (muffled) 
[17:41:16.302]                         invokeRestart("muffleMessage")
[17:41:16.302]                     }
[17:41:16.302]                     else if (inherits(cond, "warning")) {
[17:41:16.302]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:16.302]                       if (muffled) 
[17:41:16.302]                         invokeRestart("muffleWarning")
[17:41:16.302]                     }
[17:41:16.302]                     else if (inherits(cond, "condition")) {
[17:41:16.302]                       if (!is.null(pattern)) {
[17:41:16.302]                         computeRestarts <- base::computeRestarts
[17:41:16.302]                         grepl <- base::grepl
[17:41:16.302]                         restarts <- computeRestarts(cond)
[17:41:16.302]                         for (restart in restarts) {
[17:41:16.302]                           name <- restart$name
[17:41:16.302]                           if (is.null(name)) 
[17:41:16.302]                             next
[17:41:16.302]                           if (!grepl(pattern, name)) 
[17:41:16.302]                             next
[17:41:16.302]                           invokeRestart(restart)
[17:41:16.302]                           muffled <- TRUE
[17:41:16.302]                           break
[17:41:16.302]                         }
[17:41:16.302]                       }
[17:41:16.302]                     }
[17:41:16.302]                     invisible(muffled)
[17:41:16.302]                   }
[17:41:16.302]                   muffleCondition(cond)
[17:41:16.302]                 })
[17:41:16.302]             }))
[17:41:16.302]             future::FutureResult(value = ...future.value$value, 
[17:41:16.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:16.302]                   ...future.rng), globalenv = if (FALSE) 
[17:41:16.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:16.302]                     ...future.globalenv.names))
[17:41:16.302]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:16.302]         }, condition = base::local({
[17:41:16.302]             c <- base::c
[17:41:16.302]             inherits <- base::inherits
[17:41:16.302]             invokeRestart <- base::invokeRestart
[17:41:16.302]             length <- base::length
[17:41:16.302]             list <- base::list
[17:41:16.302]             seq.int <- base::seq.int
[17:41:16.302]             signalCondition <- base::signalCondition
[17:41:16.302]             sys.calls <- base::sys.calls
[17:41:16.302]             `[[` <- base::`[[`
[17:41:16.302]             `+` <- base::`+`
[17:41:16.302]             `<<-` <- base::`<<-`
[17:41:16.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:16.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:16.302]                   3L)]
[17:41:16.302]             }
[17:41:16.302]             function(cond) {
[17:41:16.302]                 is_error <- inherits(cond, "error")
[17:41:16.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:16.302]                   NULL)
[17:41:16.302]                 if (is_error) {
[17:41:16.302]                   sessionInformation <- function() {
[17:41:16.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:16.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:16.302]                       search = base::search(), system = base::Sys.info())
[17:41:16.302]                   }
[17:41:16.302]                   ...future.conditions[[length(...future.conditions) + 
[17:41:16.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:16.302]                     cond$call), session = sessionInformation(), 
[17:41:16.302]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:16.302]                   signalCondition(cond)
[17:41:16.302]                 }
[17:41:16.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:16.302]                 "immediateCondition"))) {
[17:41:16.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:16.302]                   ...future.conditions[[length(...future.conditions) + 
[17:41:16.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:16.302]                   if (TRUE && !signal) {
[17:41:16.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.302]                     {
[17:41:16.302]                       inherits <- base::inherits
[17:41:16.302]                       invokeRestart <- base::invokeRestart
[17:41:16.302]                       is.null <- base::is.null
[17:41:16.302]                       muffled <- FALSE
[17:41:16.302]                       if (inherits(cond, "message")) {
[17:41:16.302]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:16.302]                         if (muffled) 
[17:41:16.302]                           invokeRestart("muffleMessage")
[17:41:16.302]                       }
[17:41:16.302]                       else if (inherits(cond, "warning")) {
[17:41:16.302]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:16.302]                         if (muffled) 
[17:41:16.302]                           invokeRestart("muffleWarning")
[17:41:16.302]                       }
[17:41:16.302]                       else if (inherits(cond, "condition")) {
[17:41:16.302]                         if (!is.null(pattern)) {
[17:41:16.302]                           computeRestarts <- base::computeRestarts
[17:41:16.302]                           grepl <- base::grepl
[17:41:16.302]                           restarts <- computeRestarts(cond)
[17:41:16.302]                           for (restart in restarts) {
[17:41:16.302]                             name <- restart$name
[17:41:16.302]                             if (is.null(name)) 
[17:41:16.302]                               next
[17:41:16.302]                             if (!grepl(pattern, name)) 
[17:41:16.302]                               next
[17:41:16.302]                             invokeRestart(restart)
[17:41:16.302]                             muffled <- TRUE
[17:41:16.302]                             break
[17:41:16.302]                           }
[17:41:16.302]                         }
[17:41:16.302]                       }
[17:41:16.302]                       invisible(muffled)
[17:41:16.302]                     }
[17:41:16.302]                     muffleCondition(cond, pattern = "^muffle")
[17:41:16.302]                   }
[17:41:16.302]                 }
[17:41:16.302]                 else {
[17:41:16.302]                   if (TRUE) {
[17:41:16.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.302]                     {
[17:41:16.302]                       inherits <- base::inherits
[17:41:16.302]                       invokeRestart <- base::invokeRestart
[17:41:16.302]                       is.null <- base::is.null
[17:41:16.302]                       muffled <- FALSE
[17:41:16.302]                       if (inherits(cond, "message")) {
[17:41:16.302]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:16.302]                         if (muffled) 
[17:41:16.302]                           invokeRestart("muffleMessage")
[17:41:16.302]                       }
[17:41:16.302]                       else if (inherits(cond, "warning")) {
[17:41:16.302]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:16.302]                         if (muffled) 
[17:41:16.302]                           invokeRestart("muffleWarning")
[17:41:16.302]                       }
[17:41:16.302]                       else if (inherits(cond, "condition")) {
[17:41:16.302]                         if (!is.null(pattern)) {
[17:41:16.302]                           computeRestarts <- base::computeRestarts
[17:41:16.302]                           grepl <- base::grepl
[17:41:16.302]                           restarts <- computeRestarts(cond)
[17:41:16.302]                           for (restart in restarts) {
[17:41:16.302]                             name <- restart$name
[17:41:16.302]                             if (is.null(name)) 
[17:41:16.302]                               next
[17:41:16.302]                             if (!grepl(pattern, name)) 
[17:41:16.302]                               next
[17:41:16.302]                             invokeRestart(restart)
[17:41:16.302]                             muffled <- TRUE
[17:41:16.302]                             break
[17:41:16.302]                           }
[17:41:16.302]                         }
[17:41:16.302]                       }
[17:41:16.302]                       invisible(muffled)
[17:41:16.302]                     }
[17:41:16.302]                     muffleCondition(cond, pattern = "^muffle")
[17:41:16.302]                   }
[17:41:16.302]                 }
[17:41:16.302]             }
[17:41:16.302]         }))
[17:41:16.302]     }, error = function(ex) {
[17:41:16.302]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:16.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:16.302]                 ...future.rng), started = ...future.startTime, 
[17:41:16.302]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:16.302]             version = "1.8"), class = "FutureResult")
[17:41:16.302]     }, finally = {
[17:41:16.302]         if (!identical(...future.workdir, getwd())) 
[17:41:16.302]             setwd(...future.workdir)
[17:41:16.302]         {
[17:41:16.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:16.302]                 ...future.oldOptions$nwarnings <- NULL
[17:41:16.302]             }
[17:41:16.302]             base::options(...future.oldOptions)
[17:41:16.302]             if (.Platform$OS.type == "windows") {
[17:41:16.302]                 old_names <- names(...future.oldEnvVars)
[17:41:16.302]                 envs <- base::Sys.getenv()
[17:41:16.302]                 names <- names(envs)
[17:41:16.302]                 common <- intersect(names, old_names)
[17:41:16.302]                 added <- setdiff(names, old_names)
[17:41:16.302]                 removed <- setdiff(old_names, names)
[17:41:16.302]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:16.302]                   envs[common]]
[17:41:16.302]                 NAMES <- toupper(changed)
[17:41:16.302]                 args <- list()
[17:41:16.302]                 for (kk in seq_along(NAMES)) {
[17:41:16.302]                   name <- changed[[kk]]
[17:41:16.302]                   NAME <- NAMES[[kk]]
[17:41:16.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.302]                     next
[17:41:16.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:16.302]                 }
[17:41:16.302]                 NAMES <- toupper(added)
[17:41:16.302]                 for (kk in seq_along(NAMES)) {
[17:41:16.302]                   name <- added[[kk]]
[17:41:16.302]                   NAME <- NAMES[[kk]]
[17:41:16.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.302]                     next
[17:41:16.302]                   args[[name]] <- ""
[17:41:16.302]                 }
[17:41:16.302]                 NAMES <- toupper(removed)
[17:41:16.302]                 for (kk in seq_along(NAMES)) {
[17:41:16.302]                   name <- removed[[kk]]
[17:41:16.302]                   NAME <- NAMES[[kk]]
[17:41:16.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.302]                     next
[17:41:16.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:16.302]                 }
[17:41:16.302]                 if (length(args) > 0) 
[17:41:16.302]                   base::do.call(base::Sys.setenv, args = args)
[17:41:16.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:16.302]             }
[17:41:16.302]             else {
[17:41:16.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:16.302]             }
[17:41:16.302]             {
[17:41:16.302]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:16.302]                   0L) {
[17:41:16.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:16.302]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:16.302]                   base::options(opts)
[17:41:16.302]                 }
[17:41:16.302]                 {
[17:41:16.302]                   {
[17:41:16.302]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:16.302]                     NULL
[17:41:16.302]                   }
[17:41:16.302]                   options(future.plan = NULL)
[17:41:16.302]                   if (is.na(NA_character_)) 
[17:41:16.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:16.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:16.302]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:16.302]                     envir = parent.frame()) 
[17:41:16.302]                   {
[17:41:16.302]                     default_workers <- missing(workers)
[17:41:16.302]                     if (is.function(workers)) 
[17:41:16.302]                       workers <- workers()
[17:41:16.302]                     workers <- structure(as.integer(workers), 
[17:41:16.302]                       class = class(workers))
[17:41:16.302]                     stop_if_not(is.finite(workers), workers >= 
[17:41:16.302]                       1L)
[17:41:16.302]                     if ((workers == 1L && !inherits(workers, 
[17:41:16.302]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:16.302]                       if (default_workers) 
[17:41:16.302]                         supportsMulticore(warn = TRUE)
[17:41:16.302]                       return(sequential(..., envir = envir))
[17:41:16.302]                     }
[17:41:16.302]                     oopts <- options(mc.cores = workers)
[17:41:16.302]                     on.exit(options(oopts))
[17:41:16.302]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:16.302]                       envir = envir)
[17:41:16.302]                     if (!future$lazy) 
[17:41:16.302]                       future <- run(future)
[17:41:16.302]                     invisible(future)
[17:41:16.302]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:16.302]                 }
[17:41:16.302]             }
[17:41:16.302]         }
[17:41:16.302]     })
[17:41:16.302]     if (TRUE) {
[17:41:16.302]         base::sink(type = "output", split = FALSE)
[17:41:16.302]         if (TRUE) {
[17:41:16.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:16.302]         }
[17:41:16.302]         else {
[17:41:16.302]             ...future.result["stdout"] <- base::list(NULL)
[17:41:16.302]         }
[17:41:16.302]         base::close(...future.stdout)
[17:41:16.302]         ...future.stdout <- NULL
[17:41:16.302]     }
[17:41:16.302]     ...future.result$conditions <- ...future.conditions
[17:41:16.302]     ...future.result$finished <- base::Sys.time()
[17:41:16.302]     ...future.result
[17:41:16.302] }
[17:41:16.305] assign_globals() ...
[17:41:16.305] List of 5
[17:41:16.305]  $ ...future.FUN            :function (x)  
[17:41:16.305]  $ future.call.arguments    : list()
[17:41:16.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:16.305]  $ ...future.elements_ii    :List of 1
[17:41:16.305]   ..$ : int 1
[17:41:16.305]  $ ...future.seeds_ii       : NULL
[17:41:16.305]  $ ...future.globals.maxSize: NULL
[17:41:16.305]  - attr(*, "where")=List of 5
[17:41:16.305]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:16.305]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:16.305]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:16.305]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:16.305]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:16.305]  - attr(*, "resolved")= logi FALSE
[17:41:16.305]  - attr(*, "total_size")= num 4720
[17:41:16.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:16.305]  - attr(*, "already-done")= logi TRUE
[17:41:16.310] - reassign environment for ‘...future.FUN’
[17:41:16.310] - copied ‘...future.FUN’ to environment
[17:41:16.310] - copied ‘future.call.arguments’ to environment
[17:41:16.310] - copied ‘...future.elements_ii’ to environment
[17:41:16.310] - copied ‘...future.seeds_ii’ to environment
[17:41:16.310] - copied ‘...future.globals.maxSize’ to environment
[17:41:16.310] assign_globals() ... done
[17:41:16.310] requestCore(): workers = 2
[17:41:16.312] MulticoreFuture started
[17:41:16.313] - Launch lazy future ... done
[17:41:16.313] run() for ‘MulticoreFuture’ ... done
[17:41:16.313] Created future:
[17:41:16.314] plan(): Setting new future strategy stack:
[17:41:16.314] List of future strategies:
[17:41:16.314] 1. sequential:
[17:41:16.314]    - args: function (..., envir = parent.frame())
[17:41:16.314]    - tweaked: FALSE
[17:41:16.314]    - call: NULL
[17:41:16.315] plan(): nbrOfWorkers() = 1
[17:41:16.313] MulticoreFuture:
[17:41:16.313] Label: ‘future_lapply-1’
[17:41:16.313] Expression:
[17:41:16.313] {
[17:41:16.313]     do.call(function(...) {
[17:41:16.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:16.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.313]             on.exit(options(oopts), add = TRUE)
[17:41:16.313]         }
[17:41:16.313]         {
[17:41:16.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:16.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.313]                 ...future.FUN(...future.X_jj, ...)
[17:41:16.313]             })
[17:41:16.313]         }
[17:41:16.313]     }, args = future.call.arguments)
[17:41:16.313] }
[17:41:16.313] Lazy evaluation: FALSE
[17:41:16.313] Asynchronous evaluation: TRUE
[17:41:16.313] Local evaluation: TRUE
[17:41:16.313] Environment: R_GlobalEnv
[17:41:16.313] Capture standard output: TRUE
[17:41:16.313] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:16.313] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:16.313] Packages: <none>
[17:41:16.313] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:16.313] Resolved: FALSE
[17:41:16.313] Value: <not collected>
[17:41:16.313] Conditions captured: <none>
[17:41:16.313] Early signaling: FALSE
[17:41:16.313] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:16.313] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:16.331] Chunk #1 of 2 ... DONE
[17:41:16.332] Chunk #2 of 2 ...
[17:41:16.332]  - Finding globals in 'X' for chunk #2 ...
[17:41:16.333] getGlobalsAndPackages() ...
[17:41:16.333] Searching for globals...
[17:41:16.334] 
[17:41:16.334] Searching for globals ... DONE
[17:41:16.335] - globals: [0] <none>
[17:41:16.335] getGlobalsAndPackages() ... DONE
[17:41:16.335]    + additional globals found: [n=0] 
[17:41:16.335]    + additional namespaces needed: [n=0] 
[17:41:16.336]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:16.336]  - seeds: <none>
[17:41:16.336] getGlobalsAndPackages() ...
[17:41:16.336] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:16.336] Resolving globals: FALSE
[17:41:16.336] Tweak future expression to call with '...' arguments ...
[17:41:16.337] {
[17:41:16.337]     do.call(function(...) {
[17:41:16.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:16.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.337]             on.exit(options(oopts), add = TRUE)
[17:41:16.337]         }
[17:41:16.337]         {
[17:41:16.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:16.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.337]                 ...future.FUN(...future.X_jj, ...)
[17:41:16.337]             })
[17:41:16.337]         }
[17:41:16.337]     }, args = future.call.arguments)
[17:41:16.337] }
[17:41:16.337] Tweak future expression to call with '...' arguments ... DONE
[17:41:16.338] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:16.338] 
[17:41:16.339] getGlobalsAndPackages() ... DONE
[17:41:16.339] run() for ‘Future’ ...
[17:41:16.339] - state: ‘created’
[17:41:16.340] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:16.344] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:16.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:16.345]   - Field: ‘label’
[17:41:16.345]   - Field: ‘local’
[17:41:16.345]   - Field: ‘owner’
[17:41:16.345]   - Field: ‘envir’
[17:41:16.345]   - Field: ‘workers’
[17:41:16.345]   - Field: ‘packages’
[17:41:16.346]   - Field: ‘gc’
[17:41:16.346]   - Field: ‘job’
[17:41:16.346]   - Field: ‘conditions’
[17:41:16.346]   - Field: ‘expr’
[17:41:16.346]   - Field: ‘uuid’
[17:41:16.346]   - Field: ‘seed’
[17:41:16.346]   - Field: ‘version’
[17:41:16.346]   - Field: ‘result’
[17:41:16.347]   - Field: ‘asynchronous’
[17:41:16.347]   - Field: ‘calls’
[17:41:16.347]   - Field: ‘globals’
[17:41:16.347]   - Field: ‘stdout’
[17:41:16.347]   - Field: ‘earlySignal’
[17:41:16.347]   - Field: ‘lazy’
[17:41:16.347]   - Field: ‘state’
[17:41:16.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:16.348] - Launch lazy future ...
[17:41:16.348] Packages needed by the future expression (n = 0): <none>
[17:41:16.348] Packages needed by future strategies (n = 0): <none>
[17:41:16.349] {
[17:41:16.349]     {
[17:41:16.349]         {
[17:41:16.349]             ...future.startTime <- base::Sys.time()
[17:41:16.349]             {
[17:41:16.349]                 {
[17:41:16.349]                   {
[17:41:16.349]                     {
[17:41:16.349]                       base::local({
[17:41:16.349]                         has_future <- base::requireNamespace("future", 
[17:41:16.349]                           quietly = TRUE)
[17:41:16.349]                         if (has_future) {
[17:41:16.349]                           ns <- base::getNamespace("future")
[17:41:16.349]                           version <- ns[[".package"]][["version"]]
[17:41:16.349]                           if (is.null(version)) 
[17:41:16.349]                             version <- utils::packageVersion("future")
[17:41:16.349]                         }
[17:41:16.349]                         else {
[17:41:16.349]                           version <- NULL
[17:41:16.349]                         }
[17:41:16.349]                         if (!has_future || version < "1.8.0") {
[17:41:16.349]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:16.349]                             "", base::R.version$version.string), 
[17:41:16.349]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:16.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:16.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:16.349]                               "release", "version")], collapse = " "), 
[17:41:16.349]                             hostname = base::Sys.info()[["nodename"]])
[17:41:16.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:16.349]                             info)
[17:41:16.349]                           info <- base::paste(info, collapse = "; ")
[17:41:16.349]                           if (!has_future) {
[17:41:16.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:16.349]                               info)
[17:41:16.349]                           }
[17:41:16.349]                           else {
[17:41:16.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:16.349]                               info, version)
[17:41:16.349]                           }
[17:41:16.349]                           base::stop(msg)
[17:41:16.349]                         }
[17:41:16.349]                       })
[17:41:16.349]                     }
[17:41:16.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:16.349]                     base::options(mc.cores = 1L)
[17:41:16.349]                   }
[17:41:16.349]                   options(future.plan = NULL)
[17:41:16.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:16.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:16.349]                 }
[17:41:16.349]                 ...future.workdir <- getwd()
[17:41:16.349]             }
[17:41:16.349]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:16.349]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:16.349]         }
[17:41:16.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:16.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:16.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:16.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:16.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:16.349]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:16.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:16.349]             base::names(...future.oldOptions))
[17:41:16.349]     }
[17:41:16.349]     if (FALSE) {
[17:41:16.349]     }
[17:41:16.349]     else {
[17:41:16.349]         if (TRUE) {
[17:41:16.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:16.349]                 open = "w")
[17:41:16.349]         }
[17:41:16.349]         else {
[17:41:16.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:16.349]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:16.349]         }
[17:41:16.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:16.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:16.349]             base::sink(type = "output", split = FALSE)
[17:41:16.349]             base::close(...future.stdout)
[17:41:16.349]         }, add = TRUE)
[17:41:16.349]     }
[17:41:16.349]     ...future.frame <- base::sys.nframe()
[17:41:16.349]     ...future.conditions <- base::list()
[17:41:16.349]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:16.349]     if (FALSE) {
[17:41:16.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:16.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:16.349]     }
[17:41:16.349]     ...future.result <- base::tryCatch({
[17:41:16.349]         base::withCallingHandlers({
[17:41:16.349]             ...future.value <- base::withVisible(base::local({
[17:41:16.349]                 withCallingHandlers({
[17:41:16.349]                   {
[17:41:16.349]                     do.call(function(...) {
[17:41:16.349]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.349]                       if (!identical(...future.globals.maxSize.org, 
[17:41:16.349]                         ...future.globals.maxSize)) {
[17:41:16.349]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.349]                         on.exit(options(oopts), add = TRUE)
[17:41:16.349]                       }
[17:41:16.349]                       {
[17:41:16.349]                         lapply(seq_along(...future.elements_ii), 
[17:41:16.349]                           FUN = function(jj) {
[17:41:16.349]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.349]                             ...future.FUN(...future.X_jj, ...)
[17:41:16.349]                           })
[17:41:16.349]                       }
[17:41:16.349]                     }, args = future.call.arguments)
[17:41:16.349]                   }
[17:41:16.349]                 }, immediateCondition = function(cond) {
[17:41:16.349]                   save_rds <- function (object, pathname, ...) 
[17:41:16.349]                   {
[17:41:16.349]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:16.349]                     if (file_test("-f", pathname_tmp)) {
[17:41:16.349]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.349]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:16.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.349]                         fi_tmp[["mtime"]])
[17:41:16.349]                     }
[17:41:16.349]                     tryCatch({
[17:41:16.349]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:16.349]                     }, error = function(ex) {
[17:41:16.349]                       msg <- conditionMessage(ex)
[17:41:16.349]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.349]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:16.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.349]                         fi_tmp[["mtime"]], msg)
[17:41:16.349]                       ex$message <- msg
[17:41:16.349]                       stop(ex)
[17:41:16.349]                     })
[17:41:16.349]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:16.349]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:16.349]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:16.349]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.349]                       fi <- file.info(pathname)
[17:41:16.349]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:16.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.349]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:16.349]                         fi[["size"]], fi[["mtime"]])
[17:41:16.349]                       stop(msg)
[17:41:16.349]                     }
[17:41:16.349]                     invisible(pathname)
[17:41:16.349]                   }
[17:41:16.349]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:16.349]                     rootPath = tempdir()) 
[17:41:16.349]                   {
[17:41:16.349]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:16.349]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:16.349]                       tmpdir = path, fileext = ".rds")
[17:41:16.349]                     save_rds(obj, file)
[17:41:16.349]                   }
[17:41:16.349]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:16.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.349]                   {
[17:41:16.349]                     inherits <- base::inherits
[17:41:16.349]                     invokeRestart <- base::invokeRestart
[17:41:16.349]                     is.null <- base::is.null
[17:41:16.349]                     muffled <- FALSE
[17:41:16.349]                     if (inherits(cond, "message")) {
[17:41:16.349]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:16.349]                       if (muffled) 
[17:41:16.349]                         invokeRestart("muffleMessage")
[17:41:16.349]                     }
[17:41:16.349]                     else if (inherits(cond, "warning")) {
[17:41:16.349]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:16.349]                       if (muffled) 
[17:41:16.349]                         invokeRestart("muffleWarning")
[17:41:16.349]                     }
[17:41:16.349]                     else if (inherits(cond, "condition")) {
[17:41:16.349]                       if (!is.null(pattern)) {
[17:41:16.349]                         computeRestarts <- base::computeRestarts
[17:41:16.349]                         grepl <- base::grepl
[17:41:16.349]                         restarts <- computeRestarts(cond)
[17:41:16.349]                         for (restart in restarts) {
[17:41:16.349]                           name <- restart$name
[17:41:16.349]                           if (is.null(name)) 
[17:41:16.349]                             next
[17:41:16.349]                           if (!grepl(pattern, name)) 
[17:41:16.349]                             next
[17:41:16.349]                           invokeRestart(restart)
[17:41:16.349]                           muffled <- TRUE
[17:41:16.349]                           break
[17:41:16.349]                         }
[17:41:16.349]                       }
[17:41:16.349]                     }
[17:41:16.349]                     invisible(muffled)
[17:41:16.349]                   }
[17:41:16.349]                   muffleCondition(cond)
[17:41:16.349]                 })
[17:41:16.349]             }))
[17:41:16.349]             future::FutureResult(value = ...future.value$value, 
[17:41:16.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:16.349]                   ...future.rng), globalenv = if (FALSE) 
[17:41:16.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:16.349]                     ...future.globalenv.names))
[17:41:16.349]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:16.349]         }, condition = base::local({
[17:41:16.349]             c <- base::c
[17:41:16.349]             inherits <- base::inherits
[17:41:16.349]             invokeRestart <- base::invokeRestart
[17:41:16.349]             length <- base::length
[17:41:16.349]             list <- base::list
[17:41:16.349]             seq.int <- base::seq.int
[17:41:16.349]             signalCondition <- base::signalCondition
[17:41:16.349]             sys.calls <- base::sys.calls
[17:41:16.349]             `[[` <- base::`[[`
[17:41:16.349]             `+` <- base::`+`
[17:41:16.349]             `<<-` <- base::`<<-`
[17:41:16.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:16.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:16.349]                   3L)]
[17:41:16.349]             }
[17:41:16.349]             function(cond) {
[17:41:16.349]                 is_error <- inherits(cond, "error")
[17:41:16.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:16.349]                   NULL)
[17:41:16.349]                 if (is_error) {
[17:41:16.349]                   sessionInformation <- function() {
[17:41:16.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:16.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:16.349]                       search = base::search(), system = base::Sys.info())
[17:41:16.349]                   }
[17:41:16.349]                   ...future.conditions[[length(...future.conditions) + 
[17:41:16.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:16.349]                     cond$call), session = sessionInformation(), 
[17:41:16.349]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:16.349]                   signalCondition(cond)
[17:41:16.349]                 }
[17:41:16.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:16.349]                 "immediateCondition"))) {
[17:41:16.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:16.349]                   ...future.conditions[[length(...future.conditions) + 
[17:41:16.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:16.349]                   if (TRUE && !signal) {
[17:41:16.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.349]                     {
[17:41:16.349]                       inherits <- base::inherits
[17:41:16.349]                       invokeRestart <- base::invokeRestart
[17:41:16.349]                       is.null <- base::is.null
[17:41:16.349]                       muffled <- FALSE
[17:41:16.349]                       if (inherits(cond, "message")) {
[17:41:16.349]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:16.349]                         if (muffled) 
[17:41:16.349]                           invokeRestart("muffleMessage")
[17:41:16.349]                       }
[17:41:16.349]                       else if (inherits(cond, "warning")) {
[17:41:16.349]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:16.349]                         if (muffled) 
[17:41:16.349]                           invokeRestart("muffleWarning")
[17:41:16.349]                       }
[17:41:16.349]                       else if (inherits(cond, "condition")) {
[17:41:16.349]                         if (!is.null(pattern)) {
[17:41:16.349]                           computeRestarts <- base::computeRestarts
[17:41:16.349]                           grepl <- base::grepl
[17:41:16.349]                           restarts <- computeRestarts(cond)
[17:41:16.349]                           for (restart in restarts) {
[17:41:16.349]                             name <- restart$name
[17:41:16.349]                             if (is.null(name)) 
[17:41:16.349]                               next
[17:41:16.349]                             if (!grepl(pattern, name)) 
[17:41:16.349]                               next
[17:41:16.349]                             invokeRestart(restart)
[17:41:16.349]                             muffled <- TRUE
[17:41:16.349]                             break
[17:41:16.349]                           }
[17:41:16.349]                         }
[17:41:16.349]                       }
[17:41:16.349]                       invisible(muffled)
[17:41:16.349]                     }
[17:41:16.349]                     muffleCondition(cond, pattern = "^muffle")
[17:41:16.349]                   }
[17:41:16.349]                 }
[17:41:16.349]                 else {
[17:41:16.349]                   if (TRUE) {
[17:41:16.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.349]                     {
[17:41:16.349]                       inherits <- base::inherits
[17:41:16.349]                       invokeRestart <- base::invokeRestart
[17:41:16.349]                       is.null <- base::is.null
[17:41:16.349]                       muffled <- FALSE
[17:41:16.349]                       if (inherits(cond, "message")) {
[17:41:16.349]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:16.349]                         if (muffled) 
[17:41:16.349]                           invokeRestart("muffleMessage")
[17:41:16.349]                       }
[17:41:16.349]                       else if (inherits(cond, "warning")) {
[17:41:16.349]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:16.349]                         if (muffled) 
[17:41:16.349]                           invokeRestart("muffleWarning")
[17:41:16.349]                       }
[17:41:16.349]                       else if (inherits(cond, "condition")) {
[17:41:16.349]                         if (!is.null(pattern)) {
[17:41:16.349]                           computeRestarts <- base::computeRestarts
[17:41:16.349]                           grepl <- base::grepl
[17:41:16.349]                           restarts <- computeRestarts(cond)
[17:41:16.349]                           for (restart in restarts) {
[17:41:16.349]                             name <- restart$name
[17:41:16.349]                             if (is.null(name)) 
[17:41:16.349]                               next
[17:41:16.349]                             if (!grepl(pattern, name)) 
[17:41:16.349]                               next
[17:41:16.349]                             invokeRestart(restart)
[17:41:16.349]                             muffled <- TRUE
[17:41:16.349]                             break
[17:41:16.349]                           }
[17:41:16.349]                         }
[17:41:16.349]                       }
[17:41:16.349]                       invisible(muffled)
[17:41:16.349]                     }
[17:41:16.349]                     muffleCondition(cond, pattern = "^muffle")
[17:41:16.349]                   }
[17:41:16.349]                 }
[17:41:16.349]             }
[17:41:16.349]         }))
[17:41:16.349]     }, error = function(ex) {
[17:41:16.349]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:16.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:16.349]                 ...future.rng), started = ...future.startTime, 
[17:41:16.349]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:16.349]             version = "1.8"), class = "FutureResult")
[17:41:16.349]     }, finally = {
[17:41:16.349]         if (!identical(...future.workdir, getwd())) 
[17:41:16.349]             setwd(...future.workdir)
[17:41:16.349]         {
[17:41:16.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:16.349]                 ...future.oldOptions$nwarnings <- NULL
[17:41:16.349]             }
[17:41:16.349]             base::options(...future.oldOptions)
[17:41:16.349]             if (.Platform$OS.type == "windows") {
[17:41:16.349]                 old_names <- names(...future.oldEnvVars)
[17:41:16.349]                 envs <- base::Sys.getenv()
[17:41:16.349]                 names <- names(envs)
[17:41:16.349]                 common <- intersect(names, old_names)
[17:41:16.349]                 added <- setdiff(names, old_names)
[17:41:16.349]                 removed <- setdiff(old_names, names)
[17:41:16.349]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:16.349]                   envs[common]]
[17:41:16.349]                 NAMES <- toupper(changed)
[17:41:16.349]                 args <- list()
[17:41:16.349]                 for (kk in seq_along(NAMES)) {
[17:41:16.349]                   name <- changed[[kk]]
[17:41:16.349]                   NAME <- NAMES[[kk]]
[17:41:16.349]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.349]                     next
[17:41:16.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:16.349]                 }
[17:41:16.349]                 NAMES <- toupper(added)
[17:41:16.349]                 for (kk in seq_along(NAMES)) {
[17:41:16.349]                   name <- added[[kk]]
[17:41:16.349]                   NAME <- NAMES[[kk]]
[17:41:16.349]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.349]                     next
[17:41:16.349]                   args[[name]] <- ""
[17:41:16.349]                 }
[17:41:16.349]                 NAMES <- toupper(removed)
[17:41:16.349]                 for (kk in seq_along(NAMES)) {
[17:41:16.349]                   name <- removed[[kk]]
[17:41:16.349]                   NAME <- NAMES[[kk]]
[17:41:16.349]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.349]                     next
[17:41:16.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:16.349]                 }
[17:41:16.349]                 if (length(args) > 0) 
[17:41:16.349]                   base::do.call(base::Sys.setenv, args = args)
[17:41:16.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:16.349]             }
[17:41:16.349]             else {
[17:41:16.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:16.349]             }
[17:41:16.349]             {
[17:41:16.349]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:16.349]                   0L) {
[17:41:16.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:16.349]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:16.349]                   base::options(opts)
[17:41:16.349]                 }
[17:41:16.349]                 {
[17:41:16.349]                   {
[17:41:16.349]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:16.349]                     NULL
[17:41:16.349]                   }
[17:41:16.349]                   options(future.plan = NULL)
[17:41:16.349]                   if (is.na(NA_character_)) 
[17:41:16.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:16.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:16.349]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:16.349]                     envir = parent.frame()) 
[17:41:16.349]                   {
[17:41:16.349]                     default_workers <- missing(workers)
[17:41:16.349]                     if (is.function(workers)) 
[17:41:16.349]                       workers <- workers()
[17:41:16.349]                     workers <- structure(as.integer(workers), 
[17:41:16.349]                       class = class(workers))
[17:41:16.349]                     stop_if_not(is.finite(workers), workers >= 
[17:41:16.349]                       1L)
[17:41:16.349]                     if ((workers == 1L && !inherits(workers, 
[17:41:16.349]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:16.349]                       if (default_workers) 
[17:41:16.349]                         supportsMulticore(warn = TRUE)
[17:41:16.349]                       return(sequential(..., envir = envir))
[17:41:16.349]                     }
[17:41:16.349]                     oopts <- options(mc.cores = workers)
[17:41:16.349]                     on.exit(options(oopts))
[17:41:16.349]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:16.349]                       envir = envir)
[17:41:16.349]                     if (!future$lazy) 
[17:41:16.349]                       future <- run(future)
[17:41:16.349]                     invisible(future)
[17:41:16.349]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:16.349]                 }
[17:41:16.349]             }
[17:41:16.349]         }
[17:41:16.349]     })
[17:41:16.349]     if (TRUE) {
[17:41:16.349]         base::sink(type = "output", split = FALSE)
[17:41:16.349]         if (TRUE) {
[17:41:16.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:16.349]         }
[17:41:16.349]         else {
[17:41:16.349]             ...future.result["stdout"] <- base::list(NULL)
[17:41:16.349]         }
[17:41:16.349]         base::close(...future.stdout)
[17:41:16.349]         ...future.stdout <- NULL
[17:41:16.349]     }
[17:41:16.349]     ...future.result$conditions <- ...future.conditions
[17:41:16.349]     ...future.result$finished <- base::Sys.time()
[17:41:16.349]     ...future.result
[17:41:16.349] }
[17:41:16.352] assign_globals() ...
[17:41:16.352] List of 5
[17:41:16.352]  $ ...future.FUN            :function (x)  
[17:41:16.352]  $ future.call.arguments    : list()
[17:41:16.352]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:16.352]  $ ...future.elements_ii    :List of 1
[17:41:16.352]   ..$ : int 0
[17:41:16.352]  $ ...future.seeds_ii       : NULL
[17:41:16.352]  $ ...future.globals.maxSize: NULL
[17:41:16.352]  - attr(*, "where")=List of 5
[17:41:16.352]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:16.352]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:16.352]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:16.352]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:16.352]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:16.352]  - attr(*, "resolved")= logi FALSE
[17:41:16.352]  - attr(*, "total_size")= num 4720
[17:41:16.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:16.352]  - attr(*, "already-done")= logi TRUE
[17:41:16.358] - reassign environment for ‘...future.FUN’
[17:41:16.358] - copied ‘...future.FUN’ to environment
[17:41:16.358] - copied ‘future.call.arguments’ to environment
[17:41:16.358] - copied ‘...future.elements_ii’ to environment
[17:41:16.358] - copied ‘...future.seeds_ii’ to environment
[17:41:16.358] - copied ‘...future.globals.maxSize’ to environment
[17:41:16.358] assign_globals() ... done
[17:41:16.359] requestCore(): workers = 2
[17:41:16.361] MulticoreFuture started
[17:41:16.361] - Launch lazy future ... done
[17:41:16.361] run() for ‘MulticoreFuture’ ... done
[17:41:16.362] Created future:
[17:41:16.362] plan(): Setting new future strategy stack:
[17:41:16.362] List of future strategies:
[17:41:16.362] 1. sequential:
[17:41:16.362]    - args: function (..., envir = parent.frame())
[17:41:16.362]    - tweaked: FALSE
[17:41:16.362]    - call: NULL
[17:41:16.363] plan(): nbrOfWorkers() = 1
[17:41:16.365] plan(): Setting new future strategy stack:
[17:41:16.365] List of future strategies:
[17:41:16.365] 1. multicore:
[17:41:16.365]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:16.365]    - tweaked: FALSE
[17:41:16.365]    - call: plan(strategy)
[17:41:16.370] plan(): nbrOfWorkers() = 2
[17:41:16.362] MulticoreFuture:
[17:41:16.362] Label: ‘future_lapply-2’
[17:41:16.362] Expression:
[17:41:16.362] {
[17:41:16.362]     do.call(function(...) {
[17:41:16.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:16.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.362]             on.exit(options(oopts), add = TRUE)
[17:41:16.362]         }
[17:41:16.362]         {
[17:41:16.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:16.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.362]                 ...future.FUN(...future.X_jj, ...)
[17:41:16.362]             })
[17:41:16.362]         }
[17:41:16.362]     }, args = future.call.arguments)
[17:41:16.362] }
[17:41:16.362] Lazy evaluation: FALSE
[17:41:16.362] Asynchronous evaluation: TRUE
[17:41:16.362] Local evaluation: TRUE
[17:41:16.362] Environment: R_GlobalEnv
[17:41:16.362] Capture standard output: TRUE
[17:41:16.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:16.362] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:16.362] Packages: <none>
[17:41:16.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:16.362] Resolved: TRUE
[17:41:16.362] Value: <not collected>
[17:41:16.362] Conditions captured: <none>
[17:41:16.362] Early signaling: FALSE
[17:41:16.362] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:16.362] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:16.371] Chunk #2 of 2 ... DONE
[17:41:16.372] Launching 2 futures (chunks) ... DONE
[17:41:16.372] Resolving 2 futures (chunks) ...
[17:41:16.372] resolve() on list ...
[17:41:16.372]  recursive: 0
[17:41:16.372]  length: 2
[17:41:16.372] 
[17:41:16.383] Future #2
[17:41:16.384] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:41:16.384] - nx: 2
[17:41:16.384] - relay: TRUE
[17:41:16.384] - stdout: TRUE
[17:41:16.385] - signal: TRUE
[17:41:16.385] - resignal: FALSE
[17:41:16.385] - force: TRUE
[17:41:16.385] - relayed: [n=2] FALSE, FALSE
[17:41:16.385] - queued futures: [n=2] FALSE, FALSE
[17:41:16.385]  - until=1
[17:41:16.385]  - relaying element #1
[17:41:16.385] - relayed: [n=2] FALSE, FALSE
[17:41:16.386] - queued futures: [n=2] FALSE, TRUE
[17:41:16.386] signalConditionsASAP(NULL, pos=2) ... done
[17:41:16.386]  length: 1 (resolved future 2)
[17:41:16.821] plan(): Setting new future strategy stack:
[17:41:16.821] List of future strategies:
[17:41:16.821] 1. multicore:
[17:41:16.821]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:16.821]    - tweaked: FALSE
[17:41:16.821]    - call: plan(strategy)
[17:41:16.826] plan(): nbrOfWorkers() = 2
[17:41:16.827] Future #1
[17:41:16.828] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:41:16.828] - nx: 2
[17:41:16.828] - relay: TRUE
[17:41:16.828] - stdout: TRUE
[17:41:16.828] - signal: TRUE
[17:41:16.829] - resignal: FALSE
[17:41:16.829] - force: TRUE
[17:41:16.831] - relayed: [n=2] FALSE, FALSE
[17:41:16.831] - queued futures: [n=2] FALSE, TRUE
[17:41:16.832]  - until=1
[17:41:16.832]  - relaying element #1
[17:41:16.832] - relayed: [n=2] TRUE, FALSE
[17:41:16.832] - queued futures: [n=2] TRUE, TRUE
[17:41:16.833] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:41:16.833]  length: 0 (resolved future 1)
[17:41:16.833] Relaying remaining futures
[17:41:16.833] signalConditionsASAP(NULL, pos=0) ...
[17:41:16.833] - nx: 2
[17:41:16.833] - relay: TRUE
[17:41:16.834] - stdout: TRUE
[17:41:16.834] - signal: TRUE
[17:41:16.834] - resignal: FALSE
[17:41:16.834] - force: TRUE
[17:41:16.834] - relayed: [n=2] TRUE, FALSE
[17:41:16.834] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:16.835]  - relaying element #2
[17:41:16.835] - relayed: [n=2] TRUE, TRUE
[17:41:16.835] - queued futures: [n=2] TRUE, TRUE
[17:41:16.835] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:41:16.835] resolve() on list ... DONE
[17:41:16.835]  - Number of value chunks collected: 2
[17:41:16.836] Resolving 2 futures (chunks) ... DONE
[17:41:16.836] Reducing values from 2 chunks ...
[17:41:16.836]  - Number of values collected after concatenation: 2
[17:41:16.836]  - Number of values expected: 2
[17:41:16.836] Reducing values from 2 chunks ... DONE
[17:41:16.836] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:41:16.837] future_lapply() ...
[17:41:16.842] Number of chunks: 2
[17:41:16.842] getGlobalsAndPackagesXApply() ...
[17:41:16.842]  - future.globals: TRUE
[17:41:16.842] getGlobalsAndPackages() ...
[17:41:16.842] Searching for globals...
[17:41:16.844] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:16.844] Searching for globals ... DONE
[17:41:16.844] Resolving globals: FALSE
[17:41:16.845] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:16.845] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:16.845] - globals: [1] ‘FUN’
[17:41:16.845] 
[17:41:16.845] getGlobalsAndPackages() ... DONE
[17:41:16.845]  - globals found/used: [n=1] ‘FUN’
[17:41:16.846]  - needed namespaces: [n=0] 
[17:41:16.846] Finding globals ... DONE
[17:41:16.846]  - use_args: TRUE
[17:41:16.846]  - Getting '...' globals ...
[17:41:16.846] resolve() on list ...
[17:41:16.846]  recursive: 0
[17:41:16.846]  length: 1
[17:41:16.846]  elements: ‘...’
[17:41:16.847]  length: 0 (resolved future 1)
[17:41:16.847] resolve() on list ... DONE
[17:41:16.847]    - '...' content: [n=0] 
[17:41:16.847] List of 1
[17:41:16.847]  $ ...: list()
[17:41:16.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:16.847]  - attr(*, "where")=List of 1
[17:41:16.847]   ..$ ...:<environment: 0x55c987353e10> 
[17:41:16.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:16.847]  - attr(*, "resolved")= logi TRUE
[17:41:16.847]  - attr(*, "total_size")= num NA
[17:41:16.850]  - Getting '...' globals ... DONE
[17:41:16.850] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:16.850] List of 2
[17:41:16.850]  $ ...future.FUN:function (x)  
[17:41:16.850]  $ ...          : list()
[17:41:16.850]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:16.850]  - attr(*, "where")=List of 2
[17:41:16.850]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:16.850]   ..$ ...          :<environment: 0x55c987353e10> 
[17:41:16.850]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:16.850]  - attr(*, "resolved")= logi FALSE
[17:41:16.850]  - attr(*, "total_size")= num 4720
[17:41:16.853] Packages to be attached in all futures: [n=0] 
[17:41:16.853] getGlobalsAndPackagesXApply() ... DONE
[17:41:16.853] Number of futures (= number of chunks): 2
[17:41:16.853] Launching 2 futures (chunks) ...
[17:41:16.854] Chunk #1 of 2 ...
[17:41:16.854]  - Finding globals in 'X' for chunk #1 ...
[17:41:16.854] getGlobalsAndPackages() ...
[17:41:16.854] Searching for globals...
[17:41:16.854] 
[17:41:16.854] Searching for globals ... DONE
[17:41:16.854] - globals: [0] <none>
[17:41:16.854] getGlobalsAndPackages() ... DONE
[17:41:16.854]    + additional globals found: [n=0] 
[17:41:16.855]    + additional namespaces needed: [n=0] 
[17:41:16.855]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:16.855]  - seeds: <none>
[17:41:16.855] getGlobalsAndPackages() ...
[17:41:16.855] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:16.855] Resolving globals: FALSE
[17:41:16.855] Tweak future expression to call with '...' arguments ...
[17:41:16.855] {
[17:41:16.855]     do.call(function(...) {
[17:41:16.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:16.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.855]             on.exit(options(oopts), add = TRUE)
[17:41:16.855]         }
[17:41:16.855]         {
[17:41:16.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:16.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.855]                 ...future.FUN(...future.X_jj, ...)
[17:41:16.855]             })
[17:41:16.855]         }
[17:41:16.855]     }, args = future.call.arguments)
[17:41:16.855] }
[17:41:16.856] Tweak future expression to call with '...' arguments ... DONE
[17:41:16.856] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:16.856] 
[17:41:16.856] getGlobalsAndPackages() ... DONE
[17:41:16.856] run() for ‘Future’ ...
[17:41:16.857] - state: ‘created’
[17:41:16.857] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:16.860] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:16.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:16.861]   - Field: ‘label’
[17:41:16.861]   - Field: ‘local’
[17:41:16.862]   - Field: ‘owner’
[17:41:16.862]   - Field: ‘envir’
[17:41:16.863]   - Field: ‘workers’
[17:41:16.863]   - Field: ‘packages’
[17:41:16.863]   - Field: ‘gc’
[17:41:16.863]   - Field: ‘job’
[17:41:16.863]   - Field: ‘conditions’
[17:41:16.863]   - Field: ‘expr’
[17:41:16.863]   - Field: ‘uuid’
[17:41:16.863]   - Field: ‘seed’
[17:41:16.863]   - Field: ‘version’
[17:41:16.864]   - Field: ‘result’
[17:41:16.864]   - Field: ‘asynchronous’
[17:41:16.864]   - Field: ‘calls’
[17:41:16.864]   - Field: ‘globals’
[17:41:16.864]   - Field: ‘stdout’
[17:41:16.864]   - Field: ‘earlySignal’
[17:41:16.864]   - Field: ‘lazy’
[17:41:16.864]   - Field: ‘state’
[17:41:16.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:16.864] - Launch lazy future ...
[17:41:16.865] Packages needed by the future expression (n = 0): <none>
[17:41:16.865] Packages needed by future strategies (n = 0): <none>
[17:41:16.865] {
[17:41:16.865]     {
[17:41:16.865]         {
[17:41:16.865]             ...future.startTime <- base::Sys.time()
[17:41:16.865]             {
[17:41:16.865]                 {
[17:41:16.865]                   {
[17:41:16.865]                     {
[17:41:16.865]                       base::local({
[17:41:16.865]                         has_future <- base::requireNamespace("future", 
[17:41:16.865]                           quietly = TRUE)
[17:41:16.865]                         if (has_future) {
[17:41:16.865]                           ns <- base::getNamespace("future")
[17:41:16.865]                           version <- ns[[".package"]][["version"]]
[17:41:16.865]                           if (is.null(version)) 
[17:41:16.865]                             version <- utils::packageVersion("future")
[17:41:16.865]                         }
[17:41:16.865]                         else {
[17:41:16.865]                           version <- NULL
[17:41:16.865]                         }
[17:41:16.865]                         if (!has_future || version < "1.8.0") {
[17:41:16.865]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:16.865]                             "", base::R.version$version.string), 
[17:41:16.865]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:16.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:16.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:16.865]                               "release", "version")], collapse = " "), 
[17:41:16.865]                             hostname = base::Sys.info()[["nodename"]])
[17:41:16.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:16.865]                             info)
[17:41:16.865]                           info <- base::paste(info, collapse = "; ")
[17:41:16.865]                           if (!has_future) {
[17:41:16.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:16.865]                               info)
[17:41:16.865]                           }
[17:41:16.865]                           else {
[17:41:16.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:16.865]                               info, version)
[17:41:16.865]                           }
[17:41:16.865]                           base::stop(msg)
[17:41:16.865]                         }
[17:41:16.865]                       })
[17:41:16.865]                     }
[17:41:16.865]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:16.865]                     base::options(mc.cores = 1L)
[17:41:16.865]                   }
[17:41:16.865]                   options(future.plan = NULL)
[17:41:16.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:16.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:16.865]                 }
[17:41:16.865]                 ...future.workdir <- getwd()
[17:41:16.865]             }
[17:41:16.865]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:16.865]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:16.865]         }
[17:41:16.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:16.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:16.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:16.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:16.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:16.865]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:16.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:16.865]             base::names(...future.oldOptions))
[17:41:16.865]     }
[17:41:16.865]     if (TRUE) {
[17:41:16.865]     }
[17:41:16.865]     else {
[17:41:16.865]         if (NA) {
[17:41:16.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:16.865]                 open = "w")
[17:41:16.865]         }
[17:41:16.865]         else {
[17:41:16.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:16.865]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:16.865]         }
[17:41:16.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:16.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:16.865]             base::sink(type = "output", split = FALSE)
[17:41:16.865]             base::close(...future.stdout)
[17:41:16.865]         }, add = TRUE)
[17:41:16.865]     }
[17:41:16.865]     ...future.frame <- base::sys.nframe()
[17:41:16.865]     ...future.conditions <- base::list()
[17:41:16.865]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:16.865]     if (FALSE) {
[17:41:16.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:16.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:16.865]     }
[17:41:16.865]     ...future.result <- base::tryCatch({
[17:41:16.865]         base::withCallingHandlers({
[17:41:16.865]             ...future.value <- base::withVisible(base::local({
[17:41:16.865]                 withCallingHandlers({
[17:41:16.865]                   {
[17:41:16.865]                     do.call(function(...) {
[17:41:16.865]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.865]                       if (!identical(...future.globals.maxSize.org, 
[17:41:16.865]                         ...future.globals.maxSize)) {
[17:41:16.865]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.865]                         on.exit(options(oopts), add = TRUE)
[17:41:16.865]                       }
[17:41:16.865]                       {
[17:41:16.865]                         lapply(seq_along(...future.elements_ii), 
[17:41:16.865]                           FUN = function(jj) {
[17:41:16.865]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.865]                             ...future.FUN(...future.X_jj, ...)
[17:41:16.865]                           })
[17:41:16.865]                       }
[17:41:16.865]                     }, args = future.call.arguments)
[17:41:16.865]                   }
[17:41:16.865]                 }, immediateCondition = function(cond) {
[17:41:16.865]                   save_rds <- function (object, pathname, ...) 
[17:41:16.865]                   {
[17:41:16.865]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:16.865]                     if (file_test("-f", pathname_tmp)) {
[17:41:16.865]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.865]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:16.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.865]                         fi_tmp[["mtime"]])
[17:41:16.865]                     }
[17:41:16.865]                     tryCatch({
[17:41:16.865]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:16.865]                     }, error = function(ex) {
[17:41:16.865]                       msg <- conditionMessage(ex)
[17:41:16.865]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.865]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:16.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.865]                         fi_tmp[["mtime"]], msg)
[17:41:16.865]                       ex$message <- msg
[17:41:16.865]                       stop(ex)
[17:41:16.865]                     })
[17:41:16.865]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:16.865]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:16.865]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:16.865]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.865]                       fi <- file.info(pathname)
[17:41:16.865]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:16.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.865]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:16.865]                         fi[["size"]], fi[["mtime"]])
[17:41:16.865]                       stop(msg)
[17:41:16.865]                     }
[17:41:16.865]                     invisible(pathname)
[17:41:16.865]                   }
[17:41:16.865]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:16.865]                     rootPath = tempdir()) 
[17:41:16.865]                   {
[17:41:16.865]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:16.865]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:16.865]                       tmpdir = path, fileext = ".rds")
[17:41:16.865]                     save_rds(obj, file)
[17:41:16.865]                   }
[17:41:16.865]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:16.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.865]                   {
[17:41:16.865]                     inherits <- base::inherits
[17:41:16.865]                     invokeRestart <- base::invokeRestart
[17:41:16.865]                     is.null <- base::is.null
[17:41:16.865]                     muffled <- FALSE
[17:41:16.865]                     if (inherits(cond, "message")) {
[17:41:16.865]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:16.865]                       if (muffled) 
[17:41:16.865]                         invokeRestart("muffleMessage")
[17:41:16.865]                     }
[17:41:16.865]                     else if (inherits(cond, "warning")) {
[17:41:16.865]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:16.865]                       if (muffled) 
[17:41:16.865]                         invokeRestart("muffleWarning")
[17:41:16.865]                     }
[17:41:16.865]                     else if (inherits(cond, "condition")) {
[17:41:16.865]                       if (!is.null(pattern)) {
[17:41:16.865]                         computeRestarts <- base::computeRestarts
[17:41:16.865]                         grepl <- base::grepl
[17:41:16.865]                         restarts <- computeRestarts(cond)
[17:41:16.865]                         for (restart in restarts) {
[17:41:16.865]                           name <- restart$name
[17:41:16.865]                           if (is.null(name)) 
[17:41:16.865]                             next
[17:41:16.865]                           if (!grepl(pattern, name)) 
[17:41:16.865]                             next
[17:41:16.865]                           invokeRestart(restart)
[17:41:16.865]                           muffled <- TRUE
[17:41:16.865]                           break
[17:41:16.865]                         }
[17:41:16.865]                       }
[17:41:16.865]                     }
[17:41:16.865]                     invisible(muffled)
[17:41:16.865]                   }
[17:41:16.865]                   muffleCondition(cond)
[17:41:16.865]                 })
[17:41:16.865]             }))
[17:41:16.865]             future::FutureResult(value = ...future.value$value, 
[17:41:16.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:16.865]                   ...future.rng), globalenv = if (FALSE) 
[17:41:16.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:16.865]                     ...future.globalenv.names))
[17:41:16.865]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:16.865]         }, condition = base::local({
[17:41:16.865]             c <- base::c
[17:41:16.865]             inherits <- base::inherits
[17:41:16.865]             invokeRestart <- base::invokeRestart
[17:41:16.865]             length <- base::length
[17:41:16.865]             list <- base::list
[17:41:16.865]             seq.int <- base::seq.int
[17:41:16.865]             signalCondition <- base::signalCondition
[17:41:16.865]             sys.calls <- base::sys.calls
[17:41:16.865]             `[[` <- base::`[[`
[17:41:16.865]             `+` <- base::`+`
[17:41:16.865]             `<<-` <- base::`<<-`
[17:41:16.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:16.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:16.865]                   3L)]
[17:41:16.865]             }
[17:41:16.865]             function(cond) {
[17:41:16.865]                 is_error <- inherits(cond, "error")
[17:41:16.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:16.865]                   NULL)
[17:41:16.865]                 if (is_error) {
[17:41:16.865]                   sessionInformation <- function() {
[17:41:16.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:16.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:16.865]                       search = base::search(), system = base::Sys.info())
[17:41:16.865]                   }
[17:41:16.865]                   ...future.conditions[[length(...future.conditions) + 
[17:41:16.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:16.865]                     cond$call), session = sessionInformation(), 
[17:41:16.865]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:16.865]                   signalCondition(cond)
[17:41:16.865]                 }
[17:41:16.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:16.865]                 "immediateCondition"))) {
[17:41:16.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:16.865]                   ...future.conditions[[length(...future.conditions) + 
[17:41:16.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:16.865]                   if (TRUE && !signal) {
[17:41:16.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.865]                     {
[17:41:16.865]                       inherits <- base::inherits
[17:41:16.865]                       invokeRestart <- base::invokeRestart
[17:41:16.865]                       is.null <- base::is.null
[17:41:16.865]                       muffled <- FALSE
[17:41:16.865]                       if (inherits(cond, "message")) {
[17:41:16.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:16.865]                         if (muffled) 
[17:41:16.865]                           invokeRestart("muffleMessage")
[17:41:16.865]                       }
[17:41:16.865]                       else if (inherits(cond, "warning")) {
[17:41:16.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:16.865]                         if (muffled) 
[17:41:16.865]                           invokeRestart("muffleWarning")
[17:41:16.865]                       }
[17:41:16.865]                       else if (inherits(cond, "condition")) {
[17:41:16.865]                         if (!is.null(pattern)) {
[17:41:16.865]                           computeRestarts <- base::computeRestarts
[17:41:16.865]                           grepl <- base::grepl
[17:41:16.865]                           restarts <- computeRestarts(cond)
[17:41:16.865]                           for (restart in restarts) {
[17:41:16.865]                             name <- restart$name
[17:41:16.865]                             if (is.null(name)) 
[17:41:16.865]                               next
[17:41:16.865]                             if (!grepl(pattern, name)) 
[17:41:16.865]                               next
[17:41:16.865]                             invokeRestart(restart)
[17:41:16.865]                             muffled <- TRUE
[17:41:16.865]                             break
[17:41:16.865]                           }
[17:41:16.865]                         }
[17:41:16.865]                       }
[17:41:16.865]                       invisible(muffled)
[17:41:16.865]                     }
[17:41:16.865]                     muffleCondition(cond, pattern = "^muffle")
[17:41:16.865]                   }
[17:41:16.865]                 }
[17:41:16.865]                 else {
[17:41:16.865]                   if (TRUE) {
[17:41:16.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.865]                     {
[17:41:16.865]                       inherits <- base::inherits
[17:41:16.865]                       invokeRestart <- base::invokeRestart
[17:41:16.865]                       is.null <- base::is.null
[17:41:16.865]                       muffled <- FALSE
[17:41:16.865]                       if (inherits(cond, "message")) {
[17:41:16.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:16.865]                         if (muffled) 
[17:41:16.865]                           invokeRestart("muffleMessage")
[17:41:16.865]                       }
[17:41:16.865]                       else if (inherits(cond, "warning")) {
[17:41:16.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:16.865]                         if (muffled) 
[17:41:16.865]                           invokeRestart("muffleWarning")
[17:41:16.865]                       }
[17:41:16.865]                       else if (inherits(cond, "condition")) {
[17:41:16.865]                         if (!is.null(pattern)) {
[17:41:16.865]                           computeRestarts <- base::computeRestarts
[17:41:16.865]                           grepl <- base::grepl
[17:41:16.865]                           restarts <- computeRestarts(cond)
[17:41:16.865]                           for (restart in restarts) {
[17:41:16.865]                             name <- restart$name
[17:41:16.865]                             if (is.null(name)) 
[17:41:16.865]                               next
[17:41:16.865]                             if (!grepl(pattern, name)) 
[17:41:16.865]                               next
[17:41:16.865]                             invokeRestart(restart)
[17:41:16.865]                             muffled <- TRUE
[17:41:16.865]                             break
[17:41:16.865]                           }
[17:41:16.865]                         }
[17:41:16.865]                       }
[17:41:16.865]                       invisible(muffled)
[17:41:16.865]                     }
[17:41:16.865]                     muffleCondition(cond, pattern = "^muffle")
[17:41:16.865]                   }
[17:41:16.865]                 }
[17:41:16.865]             }
[17:41:16.865]         }))
[17:41:16.865]     }, error = function(ex) {
[17:41:16.865]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:16.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:16.865]                 ...future.rng), started = ...future.startTime, 
[17:41:16.865]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:16.865]             version = "1.8"), class = "FutureResult")
[17:41:16.865]     }, finally = {
[17:41:16.865]         if (!identical(...future.workdir, getwd())) 
[17:41:16.865]             setwd(...future.workdir)
[17:41:16.865]         {
[17:41:16.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:16.865]                 ...future.oldOptions$nwarnings <- NULL
[17:41:16.865]             }
[17:41:16.865]             base::options(...future.oldOptions)
[17:41:16.865]             if (.Platform$OS.type == "windows") {
[17:41:16.865]                 old_names <- names(...future.oldEnvVars)
[17:41:16.865]                 envs <- base::Sys.getenv()
[17:41:16.865]                 names <- names(envs)
[17:41:16.865]                 common <- intersect(names, old_names)
[17:41:16.865]                 added <- setdiff(names, old_names)
[17:41:16.865]                 removed <- setdiff(old_names, names)
[17:41:16.865]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:16.865]                   envs[common]]
[17:41:16.865]                 NAMES <- toupper(changed)
[17:41:16.865]                 args <- list()
[17:41:16.865]                 for (kk in seq_along(NAMES)) {
[17:41:16.865]                   name <- changed[[kk]]
[17:41:16.865]                   NAME <- NAMES[[kk]]
[17:41:16.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.865]                     next
[17:41:16.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:16.865]                 }
[17:41:16.865]                 NAMES <- toupper(added)
[17:41:16.865]                 for (kk in seq_along(NAMES)) {
[17:41:16.865]                   name <- added[[kk]]
[17:41:16.865]                   NAME <- NAMES[[kk]]
[17:41:16.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.865]                     next
[17:41:16.865]                   args[[name]] <- ""
[17:41:16.865]                 }
[17:41:16.865]                 NAMES <- toupper(removed)
[17:41:16.865]                 for (kk in seq_along(NAMES)) {
[17:41:16.865]                   name <- removed[[kk]]
[17:41:16.865]                   NAME <- NAMES[[kk]]
[17:41:16.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.865]                     next
[17:41:16.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:16.865]                 }
[17:41:16.865]                 if (length(args) > 0) 
[17:41:16.865]                   base::do.call(base::Sys.setenv, args = args)
[17:41:16.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:16.865]             }
[17:41:16.865]             else {
[17:41:16.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:16.865]             }
[17:41:16.865]             {
[17:41:16.865]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:16.865]                   0L) {
[17:41:16.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:16.865]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:16.865]                   base::options(opts)
[17:41:16.865]                 }
[17:41:16.865]                 {
[17:41:16.865]                   {
[17:41:16.865]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:16.865]                     NULL
[17:41:16.865]                   }
[17:41:16.865]                   options(future.plan = NULL)
[17:41:16.865]                   if (is.na(NA_character_)) 
[17:41:16.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:16.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:16.865]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:16.865]                     envir = parent.frame()) 
[17:41:16.865]                   {
[17:41:16.865]                     default_workers <- missing(workers)
[17:41:16.865]                     if (is.function(workers)) 
[17:41:16.865]                       workers <- workers()
[17:41:16.865]                     workers <- structure(as.integer(workers), 
[17:41:16.865]                       class = class(workers))
[17:41:16.865]                     stop_if_not(is.finite(workers), workers >= 
[17:41:16.865]                       1L)
[17:41:16.865]                     if ((workers == 1L && !inherits(workers, 
[17:41:16.865]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:16.865]                       if (default_workers) 
[17:41:16.865]                         supportsMulticore(warn = TRUE)
[17:41:16.865]                       return(sequential(..., envir = envir))
[17:41:16.865]                     }
[17:41:16.865]                     oopts <- options(mc.cores = workers)
[17:41:16.865]                     on.exit(options(oopts))
[17:41:16.865]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:16.865]                       envir = envir)
[17:41:16.865]                     if (!future$lazy) 
[17:41:16.865]                       future <- run(future)
[17:41:16.865]                     invisible(future)
[17:41:16.865]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:16.865]                 }
[17:41:16.865]             }
[17:41:16.865]         }
[17:41:16.865]     })
[17:41:16.865]     if (FALSE) {
[17:41:16.865]         base::sink(type = "output", split = FALSE)
[17:41:16.865]         if (NA) {
[17:41:16.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:16.865]         }
[17:41:16.865]         else {
[17:41:16.865]             ...future.result["stdout"] <- base::list(NULL)
[17:41:16.865]         }
[17:41:16.865]         base::close(...future.stdout)
[17:41:16.865]         ...future.stdout <- NULL
[17:41:16.865]     }
[17:41:16.865]     ...future.result$conditions <- ...future.conditions
[17:41:16.865]     ...future.result$finished <- base::Sys.time()
[17:41:16.865]     ...future.result
[17:41:16.865] }
[17:41:16.868] assign_globals() ...
[17:41:16.868] List of 5
[17:41:16.868]  $ ...future.FUN            :function (x)  
[17:41:16.868]  $ future.call.arguments    : list()
[17:41:16.868]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:16.868]  $ ...future.elements_ii    :List of 1
[17:41:16.868]   ..$ : int 1
[17:41:16.868]  $ ...future.seeds_ii       : NULL
[17:41:16.868]  $ ...future.globals.maxSize: NULL
[17:41:16.868]  - attr(*, "where")=List of 5
[17:41:16.868]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:16.868]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:16.868]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:16.868]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:16.868]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:16.868]  - attr(*, "resolved")= logi FALSE
[17:41:16.868]  - attr(*, "total_size")= num 4720
[17:41:16.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:16.868]  - attr(*, "already-done")= logi TRUE
[17:41:16.872] - reassign environment for ‘...future.FUN’
[17:41:16.872] - copied ‘...future.FUN’ to environment
[17:41:16.872] - copied ‘future.call.arguments’ to environment
[17:41:16.873] - copied ‘...future.elements_ii’ to environment
[17:41:16.873] - copied ‘...future.seeds_ii’ to environment
[17:41:16.873] - copied ‘...future.globals.maxSize’ to environment
[17:41:16.873] assign_globals() ... done
[17:41:16.873] requestCore(): workers = 2
[17:41:16.875] MulticoreFuture started
[17:41:16.876] - Launch lazy future ... done
[17:41:16.876] run() for ‘MulticoreFuture’ ... done
[17:41:16.876] Created future:
[17:41:16.876] plan(): Setting new future strategy stack:
[17:41:16.877] List of future strategies:
[17:41:16.877] 1. sequential:
[17:41:16.877]    - args: function (..., envir = parent.frame())
[17:41:16.877]    - tweaked: FALSE
[17:41:16.877]    - call: NULL
[17:41:16.877] plan(): nbrOfWorkers() = 1
[17:41:16.876] MulticoreFuture:
[17:41:16.876] Label: ‘future_lapply-1’
[17:41:16.876] Expression:
[17:41:16.876] {
[17:41:16.876]     do.call(function(...) {
[17:41:16.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:16.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.876]             on.exit(options(oopts), add = TRUE)
[17:41:16.876]         }
[17:41:16.876]         {
[17:41:16.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:16.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.876]                 ...future.FUN(...future.X_jj, ...)
[17:41:16.876]             })
[17:41:16.876]         }
[17:41:16.876]     }, args = future.call.arguments)
[17:41:16.876] }
[17:41:16.876] Lazy evaluation: FALSE
[17:41:16.876] Asynchronous evaluation: TRUE
[17:41:16.876] Local evaluation: TRUE
[17:41:16.876] Environment: R_GlobalEnv
[17:41:16.876] Capture standard output: NA
[17:41:16.876] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:16.876] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:16.876] Packages: <none>
[17:41:16.876] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:16.876] Resolved: FALSE
[17:41:16.876] Value: <not collected>
[17:41:16.876] Conditions captured: <none>
[17:41:16.876] Early signaling: FALSE
[17:41:16.876] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:16.876] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:16.889] Chunk #1 of 2 ... DONE
[17:41:16.890] Chunk #2 of 2 ...
[17:41:16.890]  - Finding globals in 'X' for chunk #2 ...
[17:41:16.890] getGlobalsAndPackages() ...
[17:41:16.890] Searching for globals...
[17:41:16.891] 
[17:41:16.891] Searching for globals ... DONE
[17:41:16.891] - globals: [0] <none>
[17:41:16.891] getGlobalsAndPackages() ... DONE
[17:41:16.891]    + additional globals found: [n=0] 
[17:41:16.891]    + additional namespaces needed: [n=0] 
[17:41:16.892]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:16.892]  - seeds: <none>
[17:41:16.892] getGlobalsAndPackages() ...
[17:41:16.892] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:16.892] Resolving globals: FALSE
[17:41:16.892] Tweak future expression to call with '...' arguments ...
[17:41:16.893] {
[17:41:16.893]     do.call(function(...) {
[17:41:16.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:16.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.893]             on.exit(options(oopts), add = TRUE)
[17:41:16.893]         }
[17:41:16.893]         {
[17:41:16.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:16.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.893]                 ...future.FUN(...future.X_jj, ...)
[17:41:16.893]             })
[17:41:16.893]         }
[17:41:16.893]     }, args = future.call.arguments)
[17:41:16.893] }
[17:41:16.893] Tweak future expression to call with '...' arguments ... DONE
[17:41:16.894] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:16.894] 
[17:41:16.894] getGlobalsAndPackages() ... DONE
[17:41:16.895] run() for ‘Future’ ...
[17:41:16.895] - state: ‘created’
[17:41:16.895] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:16.900] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:16.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:16.901]   - Field: ‘label’
[17:41:16.901]   - Field: ‘local’
[17:41:16.901]   - Field: ‘owner’
[17:41:16.901]   - Field: ‘envir’
[17:41:16.902]   - Field: ‘workers’
[17:41:16.902]   - Field: ‘packages’
[17:41:16.902]   - Field: ‘gc’
[17:41:16.902]   - Field: ‘job’
[17:41:16.902]   - Field: ‘conditions’
[17:41:16.902]   - Field: ‘expr’
[17:41:16.903]   - Field: ‘uuid’
[17:41:16.903]   - Field: ‘seed’
[17:41:16.903]   - Field: ‘version’
[17:41:16.903]   - Field: ‘result’
[17:41:16.903]   - Field: ‘asynchronous’
[17:41:16.903]   - Field: ‘calls’
[17:41:16.903]   - Field: ‘globals’
[17:41:16.904]   - Field: ‘stdout’
[17:41:16.904]   - Field: ‘earlySignal’
[17:41:16.904]   - Field: ‘lazy’
[17:41:16.904]   - Field: ‘state’
[17:41:16.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:16.904] - Launch lazy future ...
[17:41:16.905] Packages needed by the future expression (n = 0): <none>
[17:41:16.905] Packages needed by future strategies (n = 0): <none>
[17:41:16.906] {
[17:41:16.906]     {
[17:41:16.906]         {
[17:41:16.906]             ...future.startTime <- base::Sys.time()
[17:41:16.906]             {
[17:41:16.906]                 {
[17:41:16.906]                   {
[17:41:16.906]                     {
[17:41:16.906]                       base::local({
[17:41:16.906]                         has_future <- base::requireNamespace("future", 
[17:41:16.906]                           quietly = TRUE)
[17:41:16.906]                         if (has_future) {
[17:41:16.906]                           ns <- base::getNamespace("future")
[17:41:16.906]                           version <- ns[[".package"]][["version"]]
[17:41:16.906]                           if (is.null(version)) 
[17:41:16.906]                             version <- utils::packageVersion("future")
[17:41:16.906]                         }
[17:41:16.906]                         else {
[17:41:16.906]                           version <- NULL
[17:41:16.906]                         }
[17:41:16.906]                         if (!has_future || version < "1.8.0") {
[17:41:16.906]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:16.906]                             "", base::R.version$version.string), 
[17:41:16.906]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:16.906]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:16.906]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:16.906]                               "release", "version")], collapse = " "), 
[17:41:16.906]                             hostname = base::Sys.info()[["nodename"]])
[17:41:16.906]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:16.906]                             info)
[17:41:16.906]                           info <- base::paste(info, collapse = "; ")
[17:41:16.906]                           if (!has_future) {
[17:41:16.906]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:16.906]                               info)
[17:41:16.906]                           }
[17:41:16.906]                           else {
[17:41:16.906]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:16.906]                               info, version)
[17:41:16.906]                           }
[17:41:16.906]                           base::stop(msg)
[17:41:16.906]                         }
[17:41:16.906]                       })
[17:41:16.906]                     }
[17:41:16.906]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:16.906]                     base::options(mc.cores = 1L)
[17:41:16.906]                   }
[17:41:16.906]                   options(future.plan = NULL)
[17:41:16.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:16.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:16.906]                 }
[17:41:16.906]                 ...future.workdir <- getwd()
[17:41:16.906]             }
[17:41:16.906]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:16.906]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:16.906]         }
[17:41:16.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:16.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:16.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:16.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:16.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:16.906]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:16.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:16.906]             base::names(...future.oldOptions))
[17:41:16.906]     }
[17:41:16.906]     if (TRUE) {
[17:41:16.906]     }
[17:41:16.906]     else {
[17:41:16.906]         if (NA) {
[17:41:16.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:16.906]                 open = "w")
[17:41:16.906]         }
[17:41:16.906]         else {
[17:41:16.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:16.906]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:16.906]         }
[17:41:16.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:16.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:16.906]             base::sink(type = "output", split = FALSE)
[17:41:16.906]             base::close(...future.stdout)
[17:41:16.906]         }, add = TRUE)
[17:41:16.906]     }
[17:41:16.906]     ...future.frame <- base::sys.nframe()
[17:41:16.906]     ...future.conditions <- base::list()
[17:41:16.906]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:16.906]     if (FALSE) {
[17:41:16.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:16.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:16.906]     }
[17:41:16.906]     ...future.result <- base::tryCatch({
[17:41:16.906]         base::withCallingHandlers({
[17:41:16.906]             ...future.value <- base::withVisible(base::local({
[17:41:16.906]                 withCallingHandlers({
[17:41:16.906]                   {
[17:41:16.906]                     do.call(function(...) {
[17:41:16.906]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.906]                       if (!identical(...future.globals.maxSize.org, 
[17:41:16.906]                         ...future.globals.maxSize)) {
[17:41:16.906]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.906]                         on.exit(options(oopts), add = TRUE)
[17:41:16.906]                       }
[17:41:16.906]                       {
[17:41:16.906]                         lapply(seq_along(...future.elements_ii), 
[17:41:16.906]                           FUN = function(jj) {
[17:41:16.906]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.906]                             ...future.FUN(...future.X_jj, ...)
[17:41:16.906]                           })
[17:41:16.906]                       }
[17:41:16.906]                     }, args = future.call.arguments)
[17:41:16.906]                   }
[17:41:16.906]                 }, immediateCondition = function(cond) {
[17:41:16.906]                   save_rds <- function (object, pathname, ...) 
[17:41:16.906]                   {
[17:41:16.906]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:16.906]                     if (file_test("-f", pathname_tmp)) {
[17:41:16.906]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.906]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:16.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.906]                         fi_tmp[["mtime"]])
[17:41:16.906]                     }
[17:41:16.906]                     tryCatch({
[17:41:16.906]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:16.906]                     }, error = function(ex) {
[17:41:16.906]                       msg <- conditionMessage(ex)
[17:41:16.906]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.906]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:16.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.906]                         fi_tmp[["mtime"]], msg)
[17:41:16.906]                       ex$message <- msg
[17:41:16.906]                       stop(ex)
[17:41:16.906]                     })
[17:41:16.906]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:16.906]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:16.906]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:16.906]                       fi_tmp <- file.info(pathname_tmp)
[17:41:16.906]                       fi <- file.info(pathname)
[17:41:16.906]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:16.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:16.906]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:16.906]                         fi[["size"]], fi[["mtime"]])
[17:41:16.906]                       stop(msg)
[17:41:16.906]                     }
[17:41:16.906]                     invisible(pathname)
[17:41:16.906]                   }
[17:41:16.906]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:16.906]                     rootPath = tempdir()) 
[17:41:16.906]                   {
[17:41:16.906]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:16.906]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:16.906]                       tmpdir = path, fileext = ".rds")
[17:41:16.906]                     save_rds(obj, file)
[17:41:16.906]                   }
[17:41:16.906]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:16.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.906]                   {
[17:41:16.906]                     inherits <- base::inherits
[17:41:16.906]                     invokeRestart <- base::invokeRestart
[17:41:16.906]                     is.null <- base::is.null
[17:41:16.906]                     muffled <- FALSE
[17:41:16.906]                     if (inherits(cond, "message")) {
[17:41:16.906]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:16.906]                       if (muffled) 
[17:41:16.906]                         invokeRestart("muffleMessage")
[17:41:16.906]                     }
[17:41:16.906]                     else if (inherits(cond, "warning")) {
[17:41:16.906]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:16.906]                       if (muffled) 
[17:41:16.906]                         invokeRestart("muffleWarning")
[17:41:16.906]                     }
[17:41:16.906]                     else if (inherits(cond, "condition")) {
[17:41:16.906]                       if (!is.null(pattern)) {
[17:41:16.906]                         computeRestarts <- base::computeRestarts
[17:41:16.906]                         grepl <- base::grepl
[17:41:16.906]                         restarts <- computeRestarts(cond)
[17:41:16.906]                         for (restart in restarts) {
[17:41:16.906]                           name <- restart$name
[17:41:16.906]                           if (is.null(name)) 
[17:41:16.906]                             next
[17:41:16.906]                           if (!grepl(pattern, name)) 
[17:41:16.906]                             next
[17:41:16.906]                           invokeRestart(restart)
[17:41:16.906]                           muffled <- TRUE
[17:41:16.906]                           break
[17:41:16.906]                         }
[17:41:16.906]                       }
[17:41:16.906]                     }
[17:41:16.906]                     invisible(muffled)
[17:41:16.906]                   }
[17:41:16.906]                   muffleCondition(cond)
[17:41:16.906]                 })
[17:41:16.906]             }))
[17:41:16.906]             future::FutureResult(value = ...future.value$value, 
[17:41:16.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:16.906]                   ...future.rng), globalenv = if (FALSE) 
[17:41:16.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:16.906]                     ...future.globalenv.names))
[17:41:16.906]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:16.906]         }, condition = base::local({
[17:41:16.906]             c <- base::c
[17:41:16.906]             inherits <- base::inherits
[17:41:16.906]             invokeRestart <- base::invokeRestart
[17:41:16.906]             length <- base::length
[17:41:16.906]             list <- base::list
[17:41:16.906]             seq.int <- base::seq.int
[17:41:16.906]             signalCondition <- base::signalCondition
[17:41:16.906]             sys.calls <- base::sys.calls
[17:41:16.906]             `[[` <- base::`[[`
[17:41:16.906]             `+` <- base::`+`
[17:41:16.906]             `<<-` <- base::`<<-`
[17:41:16.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:16.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:16.906]                   3L)]
[17:41:16.906]             }
[17:41:16.906]             function(cond) {
[17:41:16.906]                 is_error <- inherits(cond, "error")
[17:41:16.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:16.906]                   NULL)
[17:41:16.906]                 if (is_error) {
[17:41:16.906]                   sessionInformation <- function() {
[17:41:16.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:16.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:16.906]                       search = base::search(), system = base::Sys.info())
[17:41:16.906]                   }
[17:41:16.906]                   ...future.conditions[[length(...future.conditions) + 
[17:41:16.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:16.906]                     cond$call), session = sessionInformation(), 
[17:41:16.906]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:16.906]                   signalCondition(cond)
[17:41:16.906]                 }
[17:41:16.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:16.906]                 "immediateCondition"))) {
[17:41:16.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:16.906]                   ...future.conditions[[length(...future.conditions) + 
[17:41:16.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:16.906]                   if (TRUE && !signal) {
[17:41:16.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.906]                     {
[17:41:16.906]                       inherits <- base::inherits
[17:41:16.906]                       invokeRestart <- base::invokeRestart
[17:41:16.906]                       is.null <- base::is.null
[17:41:16.906]                       muffled <- FALSE
[17:41:16.906]                       if (inherits(cond, "message")) {
[17:41:16.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:16.906]                         if (muffled) 
[17:41:16.906]                           invokeRestart("muffleMessage")
[17:41:16.906]                       }
[17:41:16.906]                       else if (inherits(cond, "warning")) {
[17:41:16.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:16.906]                         if (muffled) 
[17:41:16.906]                           invokeRestart("muffleWarning")
[17:41:16.906]                       }
[17:41:16.906]                       else if (inherits(cond, "condition")) {
[17:41:16.906]                         if (!is.null(pattern)) {
[17:41:16.906]                           computeRestarts <- base::computeRestarts
[17:41:16.906]                           grepl <- base::grepl
[17:41:16.906]                           restarts <- computeRestarts(cond)
[17:41:16.906]                           for (restart in restarts) {
[17:41:16.906]                             name <- restart$name
[17:41:16.906]                             if (is.null(name)) 
[17:41:16.906]                               next
[17:41:16.906]                             if (!grepl(pattern, name)) 
[17:41:16.906]                               next
[17:41:16.906]                             invokeRestart(restart)
[17:41:16.906]                             muffled <- TRUE
[17:41:16.906]                             break
[17:41:16.906]                           }
[17:41:16.906]                         }
[17:41:16.906]                       }
[17:41:16.906]                       invisible(muffled)
[17:41:16.906]                     }
[17:41:16.906]                     muffleCondition(cond, pattern = "^muffle")
[17:41:16.906]                   }
[17:41:16.906]                 }
[17:41:16.906]                 else {
[17:41:16.906]                   if (TRUE) {
[17:41:16.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:16.906]                     {
[17:41:16.906]                       inherits <- base::inherits
[17:41:16.906]                       invokeRestart <- base::invokeRestart
[17:41:16.906]                       is.null <- base::is.null
[17:41:16.906]                       muffled <- FALSE
[17:41:16.906]                       if (inherits(cond, "message")) {
[17:41:16.906]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:16.906]                         if (muffled) 
[17:41:16.906]                           invokeRestart("muffleMessage")
[17:41:16.906]                       }
[17:41:16.906]                       else if (inherits(cond, "warning")) {
[17:41:16.906]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:16.906]                         if (muffled) 
[17:41:16.906]                           invokeRestart("muffleWarning")
[17:41:16.906]                       }
[17:41:16.906]                       else if (inherits(cond, "condition")) {
[17:41:16.906]                         if (!is.null(pattern)) {
[17:41:16.906]                           computeRestarts <- base::computeRestarts
[17:41:16.906]                           grepl <- base::grepl
[17:41:16.906]                           restarts <- computeRestarts(cond)
[17:41:16.906]                           for (restart in restarts) {
[17:41:16.906]                             name <- restart$name
[17:41:16.906]                             if (is.null(name)) 
[17:41:16.906]                               next
[17:41:16.906]                             if (!grepl(pattern, name)) 
[17:41:16.906]                               next
[17:41:16.906]                             invokeRestart(restart)
[17:41:16.906]                             muffled <- TRUE
[17:41:16.906]                             break
[17:41:16.906]                           }
[17:41:16.906]                         }
[17:41:16.906]                       }
[17:41:16.906]                       invisible(muffled)
[17:41:16.906]                     }
[17:41:16.906]                     muffleCondition(cond, pattern = "^muffle")
[17:41:16.906]                   }
[17:41:16.906]                 }
[17:41:16.906]             }
[17:41:16.906]         }))
[17:41:16.906]     }, error = function(ex) {
[17:41:16.906]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:16.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:16.906]                 ...future.rng), started = ...future.startTime, 
[17:41:16.906]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:16.906]             version = "1.8"), class = "FutureResult")
[17:41:16.906]     }, finally = {
[17:41:16.906]         if (!identical(...future.workdir, getwd())) 
[17:41:16.906]             setwd(...future.workdir)
[17:41:16.906]         {
[17:41:16.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:16.906]                 ...future.oldOptions$nwarnings <- NULL
[17:41:16.906]             }
[17:41:16.906]             base::options(...future.oldOptions)
[17:41:16.906]             if (.Platform$OS.type == "windows") {
[17:41:16.906]                 old_names <- names(...future.oldEnvVars)
[17:41:16.906]                 envs <- base::Sys.getenv()
[17:41:16.906]                 names <- names(envs)
[17:41:16.906]                 common <- intersect(names, old_names)
[17:41:16.906]                 added <- setdiff(names, old_names)
[17:41:16.906]                 removed <- setdiff(old_names, names)
[17:41:16.906]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:16.906]                   envs[common]]
[17:41:16.906]                 NAMES <- toupper(changed)
[17:41:16.906]                 args <- list()
[17:41:16.906]                 for (kk in seq_along(NAMES)) {
[17:41:16.906]                   name <- changed[[kk]]
[17:41:16.906]                   NAME <- NAMES[[kk]]
[17:41:16.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.906]                     next
[17:41:16.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:16.906]                 }
[17:41:16.906]                 NAMES <- toupper(added)
[17:41:16.906]                 for (kk in seq_along(NAMES)) {
[17:41:16.906]                   name <- added[[kk]]
[17:41:16.906]                   NAME <- NAMES[[kk]]
[17:41:16.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.906]                     next
[17:41:16.906]                   args[[name]] <- ""
[17:41:16.906]                 }
[17:41:16.906]                 NAMES <- toupper(removed)
[17:41:16.906]                 for (kk in seq_along(NAMES)) {
[17:41:16.906]                   name <- removed[[kk]]
[17:41:16.906]                   NAME <- NAMES[[kk]]
[17:41:16.906]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:16.906]                     next
[17:41:16.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:16.906]                 }
[17:41:16.906]                 if (length(args) > 0) 
[17:41:16.906]                   base::do.call(base::Sys.setenv, args = args)
[17:41:16.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:16.906]             }
[17:41:16.906]             else {
[17:41:16.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:16.906]             }
[17:41:16.906]             {
[17:41:16.906]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:16.906]                   0L) {
[17:41:16.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:16.906]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:16.906]                   base::options(opts)
[17:41:16.906]                 }
[17:41:16.906]                 {
[17:41:16.906]                   {
[17:41:16.906]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:16.906]                     NULL
[17:41:16.906]                   }
[17:41:16.906]                   options(future.plan = NULL)
[17:41:16.906]                   if (is.na(NA_character_)) 
[17:41:16.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:16.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:16.906]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:16.906]                     envir = parent.frame()) 
[17:41:16.906]                   {
[17:41:16.906]                     default_workers <- missing(workers)
[17:41:16.906]                     if (is.function(workers)) 
[17:41:16.906]                       workers <- workers()
[17:41:16.906]                     workers <- structure(as.integer(workers), 
[17:41:16.906]                       class = class(workers))
[17:41:16.906]                     stop_if_not(is.finite(workers), workers >= 
[17:41:16.906]                       1L)
[17:41:16.906]                     if ((workers == 1L && !inherits(workers, 
[17:41:16.906]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:16.906]                       if (default_workers) 
[17:41:16.906]                         supportsMulticore(warn = TRUE)
[17:41:16.906]                       return(sequential(..., envir = envir))
[17:41:16.906]                     }
[17:41:16.906]                     oopts <- options(mc.cores = workers)
[17:41:16.906]                     on.exit(options(oopts))
[17:41:16.906]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:16.906]                       envir = envir)
[17:41:16.906]                     if (!future$lazy) 
[17:41:16.906]                       future <- run(future)
[17:41:16.906]                     invisible(future)
[17:41:16.906]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:16.906]                 }
[17:41:16.906]             }
[17:41:16.906]         }
[17:41:16.906]     })
[17:41:16.906]     if (FALSE) {
[17:41:16.906]         base::sink(type = "output", split = FALSE)
[17:41:16.906]         if (NA) {
[17:41:16.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:16.906]         }
[17:41:16.906]         else {
[17:41:16.906]             ...future.result["stdout"] <- base::list(NULL)
[17:41:16.906]         }
[17:41:16.906]         base::close(...future.stdout)
[17:41:16.906]         ...future.stdout <- NULL
[17:41:16.906]     }
[17:41:16.906]     ...future.result$conditions <- ...future.conditions
[17:41:16.906]     ...future.result$finished <- base::Sys.time()
[17:41:16.906]     ...future.result
[17:41:16.906] }
[17:41:16.909] assign_globals() ...
[17:41:16.909] List of 5
[17:41:16.909]  $ ...future.FUN            :function (x)  
[17:41:16.909]  $ future.call.arguments    : list()
[17:41:16.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:16.909]  $ ...future.elements_ii    :List of 1
[17:41:16.909]   ..$ : int 0
[17:41:16.909]  $ ...future.seeds_ii       : NULL
[17:41:16.909]  $ ...future.globals.maxSize: NULL
[17:41:16.909]  - attr(*, "where")=List of 5
[17:41:16.909]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:16.909]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:41:16.909]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:16.909]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:16.909]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:16.909]  - attr(*, "resolved")= logi FALSE
[17:41:16.909]  - attr(*, "total_size")= num 4720
[17:41:16.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:16.909]  - attr(*, "already-done")= logi TRUE
[17:41:16.921] - reassign environment for ‘...future.FUN’
[17:41:16.921] - copied ‘...future.FUN’ to environment
[17:41:16.921] - copied ‘future.call.arguments’ to environment
[17:41:16.921] - copied ‘...future.elements_ii’ to environment
[17:41:16.921] - copied ‘...future.seeds_ii’ to environment
[17:41:16.921] - copied ‘...future.globals.maxSize’ to environment
[17:41:16.922] assign_globals() ... done
[17:41:16.922] requestCore(): workers = 2
[17:41:16.925] MulticoreFuture started
[17:41:16.925] - Launch lazy future ... done
[17:41:16.925] run() for ‘MulticoreFuture’ ... done
[17:41:16.926] Created future:
[17:41:16.926] plan(): Setting new future strategy stack:
[17:41:16.926] List of future strategies:
[17:41:16.926] 1. sequential:
[17:41:16.926]    - args: function (..., envir = parent.frame())
[17:41:16.926]    - tweaked: FALSE
[17:41:16.926]    - call: NULL
[17:41:16.927] plan(): nbrOfWorkers() = 1
[17:41:16.929] plan(): Setting new future strategy stack:
[17:41:16.929] List of future strategies:
[17:41:16.929] 1. multicore:
[17:41:16.929]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:16.929]    - tweaked: FALSE
[17:41:16.929]    - call: plan(strategy)
[17:41:16.934] plan(): nbrOfWorkers() = 2
[17:41:16.926] MulticoreFuture:
[17:41:16.926] Label: ‘future_lapply-2’
[17:41:16.926] Expression:
[17:41:16.926] {
[17:41:16.926]     do.call(function(...) {
[17:41:16.926]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:16.926]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:16.926]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:16.926]             on.exit(options(oopts), add = TRUE)
[17:41:16.926]         }
[17:41:16.926]         {
[17:41:16.926]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:16.926]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:16.926]                 ...future.FUN(...future.X_jj, ...)
[17:41:16.926]             })
[17:41:16.926]         }
[17:41:16.926]     }, args = future.call.arguments)
[17:41:16.926] }
[17:41:16.926] Lazy evaluation: FALSE
[17:41:16.926] Asynchronous evaluation: TRUE
[17:41:16.926] Local evaluation: TRUE
[17:41:16.926] Environment: R_GlobalEnv
[17:41:16.926] Capture standard output: NA
[17:41:16.926] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:16.926] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:16.926] Packages: <none>
[17:41:16.926] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:16.926] Resolved: TRUE
[17:41:16.926] Value: <not collected>
[17:41:16.926] Conditions captured: <none>
[17:41:16.926] Early signaling: FALSE
[17:41:16.926] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:16.926] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:16.936] Chunk #2 of 2 ... DONE
[17:41:16.936] Launching 2 futures (chunks) ... DONE
[17:41:16.936] Resolving 2 futures (chunks) ...
[17:41:16.936] resolve() on list ...
[17:41:16.936]  recursive: 0
[17:41:16.936]  length: 2
[17:41:16.937] 
[17:41:16.947] Future #2
[17:41:16.948] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:41:16.948] - nx: 2
[17:41:16.949] - relay: TRUE
[17:41:16.949] - stdout: TRUE
[17:41:16.949] - signal: TRUE
[17:41:16.949] - resignal: FALSE
[17:41:16.949] - force: TRUE
[17:41:16.949] - relayed: [n=2] FALSE, FALSE
[17:41:16.949] - queued futures: [n=2] FALSE, FALSE
[17:41:16.950]  - until=1
[17:41:16.950]  - relaying element #1
[17:41:16.950] - relayed: [n=2] FALSE, FALSE
[17:41:16.950] - queued futures: [n=2] FALSE, TRUE
[17:41:16.950] signalConditionsASAP(NULL, pos=2) ... done
[17:41:16.950]  length: 1 (resolved future 2)
[17:41:17.380] plan(): Setting new future strategy stack:
[17:41:17.380] List of future strategies:
[17:41:17.380] 1. multicore:
[17:41:17.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:17.380]    - tweaked: FALSE
[17:41:17.380]    - call: plan(strategy)
[17:41:17.385] plan(): nbrOfWorkers() = 2
[17:41:17.389] Future #1
[17:41:17.390] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:41:17.390] - nx: 2
[17:41:17.390] - relay: TRUE
[17:41:17.390] - stdout: TRUE
[17:41:17.390] - signal: TRUE
[17:41:17.391] - resignal: FALSE
[17:41:17.391] - force: TRUE
[17:41:17.391] - relayed: [n=2] FALSE, FALSE
[17:41:17.391] - queued futures: [n=2] FALSE, TRUE
[17:41:17.391]  - until=1
[17:41:17.391]  - relaying element #1
[17:41:17.391] - relayed: [n=2] TRUE, FALSE
[17:41:17.392] - queued futures: [n=2] TRUE, TRUE
[17:41:17.392] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:41:17.392]  length: 0 (resolved future 1)
[17:41:17.392] Relaying remaining futures
[17:41:17.392] signalConditionsASAP(NULL, pos=0) ...
[17:41:17.392] - nx: 2
[17:41:17.392] - relay: TRUE
[17:41:17.392] - stdout: TRUE
[17:41:17.392] - signal: TRUE
[17:41:17.393] - resignal: FALSE
[17:41:17.393] - force: TRUE
[17:41:17.393] - relayed: [n=2] TRUE, FALSE
[17:41:17.393] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:17.393]  - relaying element #2
[17:41:17.393] - relayed: [n=2] TRUE, TRUE
[17:41:17.393] - queued futures: [n=2] TRUE, TRUE
[17:41:17.393] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:41:17.394] resolve() on list ... DONE
[17:41:17.394]  - Number of value chunks collected: 2
[17:41:17.394] Resolving 2 futures (chunks) ... DONE
[17:41:17.394] Reducing values from 2 chunks ...
[17:41:17.394]  - Number of values collected after concatenation: 2
[17:41:17.394]  - Number of values expected: 2
[17:41:17.394] Reducing values from 2 chunks ... DONE
[17:41:17.394] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:41:17.395] future_mapply() ...
[17:41:17.399] Number of chunks: 2
[17:41:17.399] getGlobalsAndPackagesXApply() ...
[17:41:17.399]  - future.globals: TRUE
[17:41:17.400] getGlobalsAndPackages() ...
[17:41:17.400] Searching for globals...
[17:41:17.402] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:17.402] Searching for globals ... DONE
[17:41:17.402] Resolving globals: FALSE
[17:41:17.403] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:17.403] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:17.403] - globals: [1] ‘FUN’
[17:41:17.403] 
[17:41:17.403] getGlobalsAndPackages() ... DONE
[17:41:17.403]  - globals found/used: [n=1] ‘FUN’
[17:41:17.404]  - needed namespaces: [n=0] 
[17:41:17.404] Finding globals ... DONE
[17:41:17.404] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:17.404] List of 2
[17:41:17.404]  $ ...future.FUN:function (x, y)  
[17:41:17.404]  $ MoreArgs     : NULL
[17:41:17.404]  - attr(*, "where")=List of 2
[17:41:17.404]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:17.404]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:17.404]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:17.404]  - attr(*, "resolved")= logi FALSE
[17:41:17.404]  - attr(*, "total_size")= num NA
[17:41:17.409] Packages to be attached in all futures: [n=0] 
[17:41:17.410] getGlobalsAndPackagesXApply() ... DONE
[17:41:17.410] Number of futures (= number of chunks): 2
[17:41:17.410] Launching 2 futures (chunks) ...
[17:41:17.410] Chunk #1 of 2 ...
[17:41:17.410]  - Finding globals in '...' for chunk #1 ...
[17:41:17.410] getGlobalsAndPackages() ...
[17:41:17.410] Searching for globals...
[17:41:17.411] 
[17:41:17.411] Searching for globals ... DONE
[17:41:17.411] - globals: [0] <none>
[17:41:17.411] getGlobalsAndPackages() ... DONE
[17:41:17.411]    + additional globals found: [n=0] 
[17:41:17.411]    + additional namespaces needed: [n=0] 
[17:41:17.412]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:17.412]  - seeds: <none>
[17:41:17.412] getGlobalsAndPackages() ...
[17:41:17.412] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:17.412] Resolving globals: FALSE
[17:41:17.413] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:17.413] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:17.413] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:17.414] 
[17:41:17.414] getGlobalsAndPackages() ... DONE
[17:41:17.414] run() for ‘Future’ ...
[17:41:17.414] - state: ‘created’
[17:41:17.414] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:17.418] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:17.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:17.418]   - Field: ‘label’
[17:41:17.418]   - Field: ‘local’
[17:41:17.418]   - Field: ‘owner’
[17:41:17.418]   - Field: ‘envir’
[17:41:17.418]   - Field: ‘workers’
[17:41:17.419]   - Field: ‘packages’
[17:41:17.419]   - Field: ‘gc’
[17:41:17.419]   - Field: ‘job’
[17:41:17.419]   - Field: ‘conditions’
[17:41:17.419]   - Field: ‘expr’
[17:41:17.419]   - Field: ‘uuid’
[17:41:17.419]   - Field: ‘seed’
[17:41:17.419]   - Field: ‘version’
[17:41:17.419]   - Field: ‘result’
[17:41:17.419]   - Field: ‘asynchronous’
[17:41:17.420]   - Field: ‘calls’
[17:41:17.420]   - Field: ‘globals’
[17:41:17.420]   - Field: ‘stdout’
[17:41:17.420]   - Field: ‘earlySignal’
[17:41:17.420]   - Field: ‘lazy’
[17:41:17.420]   - Field: ‘state’
[17:41:17.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:17.420] - Launch lazy future ...
[17:41:17.420] Packages needed by the future expression (n = 0): <none>
[17:41:17.421] Packages needed by future strategies (n = 0): <none>
[17:41:17.421] {
[17:41:17.421]     {
[17:41:17.421]         {
[17:41:17.421]             ...future.startTime <- base::Sys.time()
[17:41:17.421]             {
[17:41:17.421]                 {
[17:41:17.421]                   {
[17:41:17.421]                     {
[17:41:17.421]                       base::local({
[17:41:17.421]                         has_future <- base::requireNamespace("future", 
[17:41:17.421]                           quietly = TRUE)
[17:41:17.421]                         if (has_future) {
[17:41:17.421]                           ns <- base::getNamespace("future")
[17:41:17.421]                           version <- ns[[".package"]][["version"]]
[17:41:17.421]                           if (is.null(version)) 
[17:41:17.421]                             version <- utils::packageVersion("future")
[17:41:17.421]                         }
[17:41:17.421]                         else {
[17:41:17.421]                           version <- NULL
[17:41:17.421]                         }
[17:41:17.421]                         if (!has_future || version < "1.8.0") {
[17:41:17.421]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:17.421]                             "", base::R.version$version.string), 
[17:41:17.421]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:17.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:17.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:17.421]                               "release", "version")], collapse = " "), 
[17:41:17.421]                             hostname = base::Sys.info()[["nodename"]])
[17:41:17.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:17.421]                             info)
[17:41:17.421]                           info <- base::paste(info, collapse = "; ")
[17:41:17.421]                           if (!has_future) {
[17:41:17.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:17.421]                               info)
[17:41:17.421]                           }
[17:41:17.421]                           else {
[17:41:17.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:17.421]                               info, version)
[17:41:17.421]                           }
[17:41:17.421]                           base::stop(msg)
[17:41:17.421]                         }
[17:41:17.421]                       })
[17:41:17.421]                     }
[17:41:17.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:17.421]                     base::options(mc.cores = 1L)
[17:41:17.421]                   }
[17:41:17.421]                   options(future.plan = NULL)
[17:41:17.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:17.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:17.421]                 }
[17:41:17.421]                 ...future.workdir <- getwd()
[17:41:17.421]             }
[17:41:17.421]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:17.421]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:17.421]         }
[17:41:17.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:17.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:17.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:17.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:17.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:17.421]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:17.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:17.421]             base::names(...future.oldOptions))
[17:41:17.421]     }
[17:41:17.421]     if (FALSE) {
[17:41:17.421]     }
[17:41:17.421]     else {
[17:41:17.421]         if (FALSE) {
[17:41:17.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:17.421]                 open = "w")
[17:41:17.421]         }
[17:41:17.421]         else {
[17:41:17.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:17.421]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:17.421]         }
[17:41:17.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:17.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:17.421]             base::sink(type = "output", split = FALSE)
[17:41:17.421]             base::close(...future.stdout)
[17:41:17.421]         }, add = TRUE)
[17:41:17.421]     }
[17:41:17.421]     ...future.frame <- base::sys.nframe()
[17:41:17.421]     ...future.conditions <- base::list()
[17:41:17.421]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:17.421]     if (FALSE) {
[17:41:17.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:17.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:17.421]     }
[17:41:17.421]     ...future.result <- base::tryCatch({
[17:41:17.421]         base::withCallingHandlers({
[17:41:17.421]             ...future.value <- base::withVisible(base::local({
[17:41:17.421]                 withCallingHandlers({
[17:41:17.421]                   {
[17:41:17.421]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:17.421]                     if (!identical(...future.globals.maxSize.org, 
[17:41:17.421]                       ...future.globals.maxSize)) {
[17:41:17.421]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:17.421]                       on.exit(options(oopts), add = TRUE)
[17:41:17.421]                     }
[17:41:17.421]                     {
[17:41:17.421]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:17.421]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:17.421]                         USE.NAMES = FALSE)
[17:41:17.421]                       do.call(mapply, args = args)
[17:41:17.421]                     }
[17:41:17.421]                   }
[17:41:17.421]                 }, immediateCondition = function(cond) {
[17:41:17.421]                   save_rds <- function (object, pathname, ...) 
[17:41:17.421]                   {
[17:41:17.421]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:17.421]                     if (file_test("-f", pathname_tmp)) {
[17:41:17.421]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.421]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:17.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.421]                         fi_tmp[["mtime"]])
[17:41:17.421]                     }
[17:41:17.421]                     tryCatch({
[17:41:17.421]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:17.421]                     }, error = function(ex) {
[17:41:17.421]                       msg <- conditionMessage(ex)
[17:41:17.421]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.421]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:17.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.421]                         fi_tmp[["mtime"]], msg)
[17:41:17.421]                       ex$message <- msg
[17:41:17.421]                       stop(ex)
[17:41:17.421]                     })
[17:41:17.421]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:17.421]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:17.421]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:17.421]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.421]                       fi <- file.info(pathname)
[17:41:17.421]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:17.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.421]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:17.421]                         fi[["size"]], fi[["mtime"]])
[17:41:17.421]                       stop(msg)
[17:41:17.421]                     }
[17:41:17.421]                     invisible(pathname)
[17:41:17.421]                   }
[17:41:17.421]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:17.421]                     rootPath = tempdir()) 
[17:41:17.421]                   {
[17:41:17.421]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:17.421]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:17.421]                       tmpdir = path, fileext = ".rds")
[17:41:17.421]                     save_rds(obj, file)
[17:41:17.421]                   }
[17:41:17.421]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:17.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.421]                   {
[17:41:17.421]                     inherits <- base::inherits
[17:41:17.421]                     invokeRestart <- base::invokeRestart
[17:41:17.421]                     is.null <- base::is.null
[17:41:17.421]                     muffled <- FALSE
[17:41:17.421]                     if (inherits(cond, "message")) {
[17:41:17.421]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:17.421]                       if (muffled) 
[17:41:17.421]                         invokeRestart("muffleMessage")
[17:41:17.421]                     }
[17:41:17.421]                     else if (inherits(cond, "warning")) {
[17:41:17.421]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:17.421]                       if (muffled) 
[17:41:17.421]                         invokeRestart("muffleWarning")
[17:41:17.421]                     }
[17:41:17.421]                     else if (inherits(cond, "condition")) {
[17:41:17.421]                       if (!is.null(pattern)) {
[17:41:17.421]                         computeRestarts <- base::computeRestarts
[17:41:17.421]                         grepl <- base::grepl
[17:41:17.421]                         restarts <- computeRestarts(cond)
[17:41:17.421]                         for (restart in restarts) {
[17:41:17.421]                           name <- restart$name
[17:41:17.421]                           if (is.null(name)) 
[17:41:17.421]                             next
[17:41:17.421]                           if (!grepl(pattern, name)) 
[17:41:17.421]                             next
[17:41:17.421]                           invokeRestart(restart)
[17:41:17.421]                           muffled <- TRUE
[17:41:17.421]                           break
[17:41:17.421]                         }
[17:41:17.421]                       }
[17:41:17.421]                     }
[17:41:17.421]                     invisible(muffled)
[17:41:17.421]                   }
[17:41:17.421]                   muffleCondition(cond)
[17:41:17.421]                 })
[17:41:17.421]             }))
[17:41:17.421]             future::FutureResult(value = ...future.value$value, 
[17:41:17.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:17.421]                   ...future.rng), globalenv = if (FALSE) 
[17:41:17.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:17.421]                     ...future.globalenv.names))
[17:41:17.421]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:17.421]         }, condition = base::local({
[17:41:17.421]             c <- base::c
[17:41:17.421]             inherits <- base::inherits
[17:41:17.421]             invokeRestart <- base::invokeRestart
[17:41:17.421]             length <- base::length
[17:41:17.421]             list <- base::list
[17:41:17.421]             seq.int <- base::seq.int
[17:41:17.421]             signalCondition <- base::signalCondition
[17:41:17.421]             sys.calls <- base::sys.calls
[17:41:17.421]             `[[` <- base::`[[`
[17:41:17.421]             `+` <- base::`+`
[17:41:17.421]             `<<-` <- base::`<<-`
[17:41:17.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:17.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:17.421]                   3L)]
[17:41:17.421]             }
[17:41:17.421]             function(cond) {
[17:41:17.421]                 is_error <- inherits(cond, "error")
[17:41:17.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:17.421]                   NULL)
[17:41:17.421]                 if (is_error) {
[17:41:17.421]                   sessionInformation <- function() {
[17:41:17.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:17.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:17.421]                       search = base::search(), system = base::Sys.info())
[17:41:17.421]                   }
[17:41:17.421]                   ...future.conditions[[length(...future.conditions) + 
[17:41:17.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:17.421]                     cond$call), session = sessionInformation(), 
[17:41:17.421]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:17.421]                   signalCondition(cond)
[17:41:17.421]                 }
[17:41:17.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:17.421]                 "immediateCondition"))) {
[17:41:17.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:17.421]                   ...future.conditions[[length(...future.conditions) + 
[17:41:17.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:17.421]                   if (TRUE && !signal) {
[17:41:17.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.421]                     {
[17:41:17.421]                       inherits <- base::inherits
[17:41:17.421]                       invokeRestart <- base::invokeRestart
[17:41:17.421]                       is.null <- base::is.null
[17:41:17.421]                       muffled <- FALSE
[17:41:17.421]                       if (inherits(cond, "message")) {
[17:41:17.421]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:17.421]                         if (muffled) 
[17:41:17.421]                           invokeRestart("muffleMessage")
[17:41:17.421]                       }
[17:41:17.421]                       else if (inherits(cond, "warning")) {
[17:41:17.421]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:17.421]                         if (muffled) 
[17:41:17.421]                           invokeRestart("muffleWarning")
[17:41:17.421]                       }
[17:41:17.421]                       else if (inherits(cond, "condition")) {
[17:41:17.421]                         if (!is.null(pattern)) {
[17:41:17.421]                           computeRestarts <- base::computeRestarts
[17:41:17.421]                           grepl <- base::grepl
[17:41:17.421]                           restarts <- computeRestarts(cond)
[17:41:17.421]                           for (restart in restarts) {
[17:41:17.421]                             name <- restart$name
[17:41:17.421]                             if (is.null(name)) 
[17:41:17.421]                               next
[17:41:17.421]                             if (!grepl(pattern, name)) 
[17:41:17.421]                               next
[17:41:17.421]                             invokeRestart(restart)
[17:41:17.421]                             muffled <- TRUE
[17:41:17.421]                             break
[17:41:17.421]                           }
[17:41:17.421]                         }
[17:41:17.421]                       }
[17:41:17.421]                       invisible(muffled)
[17:41:17.421]                     }
[17:41:17.421]                     muffleCondition(cond, pattern = "^muffle")
[17:41:17.421]                   }
[17:41:17.421]                 }
[17:41:17.421]                 else {
[17:41:17.421]                   if (TRUE) {
[17:41:17.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.421]                     {
[17:41:17.421]                       inherits <- base::inherits
[17:41:17.421]                       invokeRestart <- base::invokeRestart
[17:41:17.421]                       is.null <- base::is.null
[17:41:17.421]                       muffled <- FALSE
[17:41:17.421]                       if (inherits(cond, "message")) {
[17:41:17.421]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:17.421]                         if (muffled) 
[17:41:17.421]                           invokeRestart("muffleMessage")
[17:41:17.421]                       }
[17:41:17.421]                       else if (inherits(cond, "warning")) {
[17:41:17.421]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:17.421]                         if (muffled) 
[17:41:17.421]                           invokeRestart("muffleWarning")
[17:41:17.421]                       }
[17:41:17.421]                       else if (inherits(cond, "condition")) {
[17:41:17.421]                         if (!is.null(pattern)) {
[17:41:17.421]                           computeRestarts <- base::computeRestarts
[17:41:17.421]                           grepl <- base::grepl
[17:41:17.421]                           restarts <- computeRestarts(cond)
[17:41:17.421]                           for (restart in restarts) {
[17:41:17.421]                             name <- restart$name
[17:41:17.421]                             if (is.null(name)) 
[17:41:17.421]                               next
[17:41:17.421]                             if (!grepl(pattern, name)) 
[17:41:17.421]                               next
[17:41:17.421]                             invokeRestart(restart)
[17:41:17.421]                             muffled <- TRUE
[17:41:17.421]                             break
[17:41:17.421]                           }
[17:41:17.421]                         }
[17:41:17.421]                       }
[17:41:17.421]                       invisible(muffled)
[17:41:17.421]                     }
[17:41:17.421]                     muffleCondition(cond, pattern = "^muffle")
[17:41:17.421]                   }
[17:41:17.421]                 }
[17:41:17.421]             }
[17:41:17.421]         }))
[17:41:17.421]     }, error = function(ex) {
[17:41:17.421]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:17.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:17.421]                 ...future.rng), started = ...future.startTime, 
[17:41:17.421]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:17.421]             version = "1.8"), class = "FutureResult")
[17:41:17.421]     }, finally = {
[17:41:17.421]         if (!identical(...future.workdir, getwd())) 
[17:41:17.421]             setwd(...future.workdir)
[17:41:17.421]         {
[17:41:17.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:17.421]                 ...future.oldOptions$nwarnings <- NULL
[17:41:17.421]             }
[17:41:17.421]             base::options(...future.oldOptions)
[17:41:17.421]             if (.Platform$OS.type == "windows") {
[17:41:17.421]                 old_names <- names(...future.oldEnvVars)
[17:41:17.421]                 envs <- base::Sys.getenv()
[17:41:17.421]                 names <- names(envs)
[17:41:17.421]                 common <- intersect(names, old_names)
[17:41:17.421]                 added <- setdiff(names, old_names)
[17:41:17.421]                 removed <- setdiff(old_names, names)
[17:41:17.421]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:17.421]                   envs[common]]
[17:41:17.421]                 NAMES <- toupper(changed)
[17:41:17.421]                 args <- list()
[17:41:17.421]                 for (kk in seq_along(NAMES)) {
[17:41:17.421]                   name <- changed[[kk]]
[17:41:17.421]                   NAME <- NAMES[[kk]]
[17:41:17.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.421]                     next
[17:41:17.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:17.421]                 }
[17:41:17.421]                 NAMES <- toupper(added)
[17:41:17.421]                 for (kk in seq_along(NAMES)) {
[17:41:17.421]                   name <- added[[kk]]
[17:41:17.421]                   NAME <- NAMES[[kk]]
[17:41:17.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.421]                     next
[17:41:17.421]                   args[[name]] <- ""
[17:41:17.421]                 }
[17:41:17.421]                 NAMES <- toupper(removed)
[17:41:17.421]                 for (kk in seq_along(NAMES)) {
[17:41:17.421]                   name <- removed[[kk]]
[17:41:17.421]                   NAME <- NAMES[[kk]]
[17:41:17.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.421]                     next
[17:41:17.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:17.421]                 }
[17:41:17.421]                 if (length(args) > 0) 
[17:41:17.421]                   base::do.call(base::Sys.setenv, args = args)
[17:41:17.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:17.421]             }
[17:41:17.421]             else {
[17:41:17.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:17.421]             }
[17:41:17.421]             {
[17:41:17.421]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:17.421]                   0L) {
[17:41:17.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:17.421]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:17.421]                   base::options(opts)
[17:41:17.421]                 }
[17:41:17.421]                 {
[17:41:17.421]                   {
[17:41:17.421]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:17.421]                     NULL
[17:41:17.421]                   }
[17:41:17.421]                   options(future.plan = NULL)
[17:41:17.421]                   if (is.na(NA_character_)) 
[17:41:17.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:17.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:17.421]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:17.421]                     envir = parent.frame()) 
[17:41:17.421]                   {
[17:41:17.421]                     default_workers <- missing(workers)
[17:41:17.421]                     if (is.function(workers)) 
[17:41:17.421]                       workers <- workers()
[17:41:17.421]                     workers <- structure(as.integer(workers), 
[17:41:17.421]                       class = class(workers))
[17:41:17.421]                     stop_if_not(is.finite(workers), workers >= 
[17:41:17.421]                       1L)
[17:41:17.421]                     if ((workers == 1L && !inherits(workers, 
[17:41:17.421]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:17.421]                       if (default_workers) 
[17:41:17.421]                         supportsMulticore(warn = TRUE)
[17:41:17.421]                       return(sequential(..., envir = envir))
[17:41:17.421]                     }
[17:41:17.421]                     oopts <- options(mc.cores = workers)
[17:41:17.421]                     on.exit(options(oopts))
[17:41:17.421]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:17.421]                       envir = envir)
[17:41:17.421]                     if (!future$lazy) 
[17:41:17.421]                       future <- run(future)
[17:41:17.421]                     invisible(future)
[17:41:17.421]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:17.421]                 }
[17:41:17.421]             }
[17:41:17.421]         }
[17:41:17.421]     })
[17:41:17.421]     if (TRUE) {
[17:41:17.421]         base::sink(type = "output", split = FALSE)
[17:41:17.421]         if (FALSE) {
[17:41:17.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:17.421]         }
[17:41:17.421]         else {
[17:41:17.421]             ...future.result["stdout"] <- base::list(NULL)
[17:41:17.421]         }
[17:41:17.421]         base::close(...future.stdout)
[17:41:17.421]         ...future.stdout <- NULL
[17:41:17.421]     }
[17:41:17.421]     ...future.result$conditions <- ...future.conditions
[17:41:17.421]     ...future.result$finished <- base::Sys.time()
[17:41:17.421]     ...future.result
[17:41:17.421] }
[17:41:17.424] assign_globals() ...
[17:41:17.424] List of 5
[17:41:17.424]  $ ...future.FUN            :function (x, y)  
[17:41:17.424]  $ MoreArgs                 : NULL
[17:41:17.424]  $ ...future.elements_ii    :List of 2
[17:41:17.424]   ..$ :List of 1
[17:41:17.424]   .. ..$ : int 1
[17:41:17.424]   ..$ :List of 1
[17:41:17.424]   .. ..$ : int 0
[17:41:17.424]  $ ...future.seeds_ii       : NULL
[17:41:17.424]  $ ...future.globals.maxSize: NULL
[17:41:17.424]  - attr(*, "where")=List of 5
[17:41:17.424]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:17.424]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:17.424]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:17.424]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:17.424]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:17.424]  - attr(*, "resolved")= logi FALSE
[17:41:17.424]  - attr(*, "total_size")= num 6368
[17:41:17.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:17.424]  - attr(*, "already-done")= logi TRUE
[17:41:17.429] - reassign environment for ‘...future.FUN’
[17:41:17.429] - copied ‘...future.FUN’ to environment
[17:41:17.429] - copied ‘MoreArgs’ to environment
[17:41:17.429] - copied ‘...future.elements_ii’ to environment
[17:41:17.429] - copied ‘...future.seeds_ii’ to environment
[17:41:17.429] - copied ‘...future.globals.maxSize’ to environment
[17:41:17.429] assign_globals() ... done
[17:41:17.429] requestCore(): workers = 2
[17:41:17.432] MulticoreFuture started
[17:41:17.432] - Launch lazy future ... done
[17:41:17.432] run() for ‘MulticoreFuture’ ... done
[17:41:17.432] Created future:
[17:41:17.433] plan(): Setting new future strategy stack:
[17:41:17.433] List of future strategies:
[17:41:17.433] 1. sequential:
[17:41:17.433]    - args: function (..., envir = parent.frame())
[17:41:17.433]    - tweaked: FALSE
[17:41:17.433]    - call: NULL
[17:41:17.434] plan(): nbrOfWorkers() = 1
[17:41:17.433] MulticoreFuture:
[17:41:17.433] Label: ‘future_mapply-1’
[17:41:17.433] Expression:
[17:41:17.433] {
[17:41:17.433]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:17.433]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:17.433]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:17.433]         on.exit(options(oopts), add = TRUE)
[17:41:17.433]     }
[17:41:17.433]     {
[17:41:17.433]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:17.433]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:17.433]         do.call(mapply, args = args)
[17:41:17.433]     }
[17:41:17.433] }
[17:41:17.433] Lazy evaluation: FALSE
[17:41:17.433] Asynchronous evaluation: TRUE
[17:41:17.433] Local evaluation: TRUE
[17:41:17.433] Environment: R_GlobalEnv
[17:41:17.433] Capture standard output: FALSE
[17:41:17.433] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:17.433] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:17.433] Packages: <none>
[17:41:17.433] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:17.433] Resolved: FALSE
[17:41:17.433] Value: <not collected>
[17:41:17.433] Conditions captured: <none>
[17:41:17.433] Early signaling: FALSE
[17:41:17.433] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:17.433] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:17.445] Chunk #1 of 2 ... DONE
[17:41:17.445] Chunk #2 of 2 ...
[17:41:17.446]  - Finding globals in '...' for chunk #2 ...
[17:41:17.446] getGlobalsAndPackages() ...
[17:41:17.446] Searching for globals...
[17:41:17.446] 
[17:41:17.447] Searching for globals ... DONE
[17:41:17.447] - globals: [0] <none>
[17:41:17.447] getGlobalsAndPackages() ... DONE
[17:41:17.447]    + additional globals found: [n=0] 
[17:41:17.447]    + additional namespaces needed: [n=0] 
[17:41:17.447]  - Finding globals in '...' for chunk #2 ... DONE
[17:41:17.448]  - seeds: <none>
[17:41:17.448] getGlobalsAndPackages() ...
[17:41:17.448] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:17.448] Resolving globals: FALSE
[17:41:17.449] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:17.450] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:17.450] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:17.450] 
[17:41:17.453] getGlobalsAndPackages() ... DONE
[17:41:17.454] run() for ‘Future’ ...
[17:41:17.455] - state: ‘created’
[17:41:17.455] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:17.462] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:17.462] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:17.462]   - Field: ‘label’
[17:41:17.462]   - Field: ‘local’
[17:41:17.462]   - Field: ‘owner’
[17:41:17.463]   - Field: ‘envir’
[17:41:17.463]   - Field: ‘workers’
[17:41:17.463]   - Field: ‘packages’
[17:41:17.463]   - Field: ‘gc’
[17:41:17.463]   - Field: ‘job’
[17:41:17.464]   - Field: ‘conditions’
[17:41:17.464]   - Field: ‘expr’
[17:41:17.464]   - Field: ‘uuid’
[17:41:17.464]   - Field: ‘seed’
[17:41:17.465]   - Field: ‘version’
[17:41:17.465]   - Field: ‘result’
[17:41:17.465]   - Field: ‘asynchronous’
[17:41:17.465]   - Field: ‘calls’
[17:41:17.465]   - Field: ‘globals’
[17:41:17.466]   - Field: ‘stdout’
[17:41:17.466]   - Field: ‘earlySignal’
[17:41:17.466]   - Field: ‘lazy’
[17:41:17.466]   - Field: ‘state’
[17:41:17.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:17.466] - Launch lazy future ...
[17:41:17.467] Packages needed by the future expression (n = 0): <none>
[17:41:17.467] Packages needed by future strategies (n = 0): <none>
[17:41:17.468] {
[17:41:17.468]     {
[17:41:17.468]         {
[17:41:17.468]             ...future.startTime <- base::Sys.time()
[17:41:17.468]             {
[17:41:17.468]                 {
[17:41:17.468]                   {
[17:41:17.468]                     {
[17:41:17.468]                       base::local({
[17:41:17.468]                         has_future <- base::requireNamespace("future", 
[17:41:17.468]                           quietly = TRUE)
[17:41:17.468]                         if (has_future) {
[17:41:17.468]                           ns <- base::getNamespace("future")
[17:41:17.468]                           version <- ns[[".package"]][["version"]]
[17:41:17.468]                           if (is.null(version)) 
[17:41:17.468]                             version <- utils::packageVersion("future")
[17:41:17.468]                         }
[17:41:17.468]                         else {
[17:41:17.468]                           version <- NULL
[17:41:17.468]                         }
[17:41:17.468]                         if (!has_future || version < "1.8.0") {
[17:41:17.468]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:17.468]                             "", base::R.version$version.string), 
[17:41:17.468]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:17.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:17.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:17.468]                               "release", "version")], collapse = " "), 
[17:41:17.468]                             hostname = base::Sys.info()[["nodename"]])
[17:41:17.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:17.468]                             info)
[17:41:17.468]                           info <- base::paste(info, collapse = "; ")
[17:41:17.468]                           if (!has_future) {
[17:41:17.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:17.468]                               info)
[17:41:17.468]                           }
[17:41:17.468]                           else {
[17:41:17.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:17.468]                               info, version)
[17:41:17.468]                           }
[17:41:17.468]                           base::stop(msg)
[17:41:17.468]                         }
[17:41:17.468]                       })
[17:41:17.468]                     }
[17:41:17.468]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:17.468]                     base::options(mc.cores = 1L)
[17:41:17.468]                   }
[17:41:17.468]                   options(future.plan = NULL)
[17:41:17.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:17.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:17.468]                 }
[17:41:17.468]                 ...future.workdir <- getwd()
[17:41:17.468]             }
[17:41:17.468]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:17.468]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:17.468]         }
[17:41:17.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:17.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:17.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:17.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:17.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:17.468]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:17.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:17.468]             base::names(...future.oldOptions))
[17:41:17.468]     }
[17:41:17.468]     if (FALSE) {
[17:41:17.468]     }
[17:41:17.468]     else {
[17:41:17.468]         if (FALSE) {
[17:41:17.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:17.468]                 open = "w")
[17:41:17.468]         }
[17:41:17.468]         else {
[17:41:17.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:17.468]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:17.468]         }
[17:41:17.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:17.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:17.468]             base::sink(type = "output", split = FALSE)
[17:41:17.468]             base::close(...future.stdout)
[17:41:17.468]         }, add = TRUE)
[17:41:17.468]     }
[17:41:17.468]     ...future.frame <- base::sys.nframe()
[17:41:17.468]     ...future.conditions <- base::list()
[17:41:17.468]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:17.468]     if (FALSE) {
[17:41:17.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:17.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:17.468]     }
[17:41:17.468]     ...future.result <- base::tryCatch({
[17:41:17.468]         base::withCallingHandlers({
[17:41:17.468]             ...future.value <- base::withVisible(base::local({
[17:41:17.468]                 withCallingHandlers({
[17:41:17.468]                   {
[17:41:17.468]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:17.468]                     if (!identical(...future.globals.maxSize.org, 
[17:41:17.468]                       ...future.globals.maxSize)) {
[17:41:17.468]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:17.468]                       on.exit(options(oopts), add = TRUE)
[17:41:17.468]                     }
[17:41:17.468]                     {
[17:41:17.468]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:17.468]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:17.468]                         USE.NAMES = FALSE)
[17:41:17.468]                       do.call(mapply, args = args)
[17:41:17.468]                     }
[17:41:17.468]                   }
[17:41:17.468]                 }, immediateCondition = function(cond) {
[17:41:17.468]                   save_rds <- function (object, pathname, ...) 
[17:41:17.468]                   {
[17:41:17.468]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:17.468]                     if (file_test("-f", pathname_tmp)) {
[17:41:17.468]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.468]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:17.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.468]                         fi_tmp[["mtime"]])
[17:41:17.468]                     }
[17:41:17.468]                     tryCatch({
[17:41:17.468]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:17.468]                     }, error = function(ex) {
[17:41:17.468]                       msg <- conditionMessage(ex)
[17:41:17.468]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.468]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:17.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.468]                         fi_tmp[["mtime"]], msg)
[17:41:17.468]                       ex$message <- msg
[17:41:17.468]                       stop(ex)
[17:41:17.468]                     })
[17:41:17.468]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:17.468]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:17.468]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:17.468]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.468]                       fi <- file.info(pathname)
[17:41:17.468]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:17.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.468]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:17.468]                         fi[["size"]], fi[["mtime"]])
[17:41:17.468]                       stop(msg)
[17:41:17.468]                     }
[17:41:17.468]                     invisible(pathname)
[17:41:17.468]                   }
[17:41:17.468]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:17.468]                     rootPath = tempdir()) 
[17:41:17.468]                   {
[17:41:17.468]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:17.468]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:17.468]                       tmpdir = path, fileext = ".rds")
[17:41:17.468]                     save_rds(obj, file)
[17:41:17.468]                   }
[17:41:17.468]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:17.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.468]                   {
[17:41:17.468]                     inherits <- base::inherits
[17:41:17.468]                     invokeRestart <- base::invokeRestart
[17:41:17.468]                     is.null <- base::is.null
[17:41:17.468]                     muffled <- FALSE
[17:41:17.468]                     if (inherits(cond, "message")) {
[17:41:17.468]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:17.468]                       if (muffled) 
[17:41:17.468]                         invokeRestart("muffleMessage")
[17:41:17.468]                     }
[17:41:17.468]                     else if (inherits(cond, "warning")) {
[17:41:17.468]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:17.468]                       if (muffled) 
[17:41:17.468]                         invokeRestart("muffleWarning")
[17:41:17.468]                     }
[17:41:17.468]                     else if (inherits(cond, "condition")) {
[17:41:17.468]                       if (!is.null(pattern)) {
[17:41:17.468]                         computeRestarts <- base::computeRestarts
[17:41:17.468]                         grepl <- base::grepl
[17:41:17.468]                         restarts <- computeRestarts(cond)
[17:41:17.468]                         for (restart in restarts) {
[17:41:17.468]                           name <- restart$name
[17:41:17.468]                           if (is.null(name)) 
[17:41:17.468]                             next
[17:41:17.468]                           if (!grepl(pattern, name)) 
[17:41:17.468]                             next
[17:41:17.468]                           invokeRestart(restart)
[17:41:17.468]                           muffled <- TRUE
[17:41:17.468]                           break
[17:41:17.468]                         }
[17:41:17.468]                       }
[17:41:17.468]                     }
[17:41:17.468]                     invisible(muffled)
[17:41:17.468]                   }
[17:41:17.468]                   muffleCondition(cond)
[17:41:17.468]                 })
[17:41:17.468]             }))
[17:41:17.468]             future::FutureResult(value = ...future.value$value, 
[17:41:17.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:17.468]                   ...future.rng), globalenv = if (FALSE) 
[17:41:17.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:17.468]                     ...future.globalenv.names))
[17:41:17.468]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:17.468]         }, condition = base::local({
[17:41:17.468]             c <- base::c
[17:41:17.468]             inherits <- base::inherits
[17:41:17.468]             invokeRestart <- base::invokeRestart
[17:41:17.468]             length <- base::length
[17:41:17.468]             list <- base::list
[17:41:17.468]             seq.int <- base::seq.int
[17:41:17.468]             signalCondition <- base::signalCondition
[17:41:17.468]             sys.calls <- base::sys.calls
[17:41:17.468]             `[[` <- base::`[[`
[17:41:17.468]             `+` <- base::`+`
[17:41:17.468]             `<<-` <- base::`<<-`
[17:41:17.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:17.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:17.468]                   3L)]
[17:41:17.468]             }
[17:41:17.468]             function(cond) {
[17:41:17.468]                 is_error <- inherits(cond, "error")
[17:41:17.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:17.468]                   NULL)
[17:41:17.468]                 if (is_error) {
[17:41:17.468]                   sessionInformation <- function() {
[17:41:17.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:17.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:17.468]                       search = base::search(), system = base::Sys.info())
[17:41:17.468]                   }
[17:41:17.468]                   ...future.conditions[[length(...future.conditions) + 
[17:41:17.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:17.468]                     cond$call), session = sessionInformation(), 
[17:41:17.468]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:17.468]                   signalCondition(cond)
[17:41:17.468]                 }
[17:41:17.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:17.468]                 "immediateCondition"))) {
[17:41:17.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:17.468]                   ...future.conditions[[length(...future.conditions) + 
[17:41:17.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:17.468]                   if (TRUE && !signal) {
[17:41:17.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.468]                     {
[17:41:17.468]                       inherits <- base::inherits
[17:41:17.468]                       invokeRestart <- base::invokeRestart
[17:41:17.468]                       is.null <- base::is.null
[17:41:17.468]                       muffled <- FALSE
[17:41:17.468]                       if (inherits(cond, "message")) {
[17:41:17.468]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:17.468]                         if (muffled) 
[17:41:17.468]                           invokeRestart("muffleMessage")
[17:41:17.468]                       }
[17:41:17.468]                       else if (inherits(cond, "warning")) {
[17:41:17.468]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:17.468]                         if (muffled) 
[17:41:17.468]                           invokeRestart("muffleWarning")
[17:41:17.468]                       }
[17:41:17.468]                       else if (inherits(cond, "condition")) {
[17:41:17.468]                         if (!is.null(pattern)) {
[17:41:17.468]                           computeRestarts <- base::computeRestarts
[17:41:17.468]                           grepl <- base::grepl
[17:41:17.468]                           restarts <- computeRestarts(cond)
[17:41:17.468]                           for (restart in restarts) {
[17:41:17.468]                             name <- restart$name
[17:41:17.468]                             if (is.null(name)) 
[17:41:17.468]                               next
[17:41:17.468]                             if (!grepl(pattern, name)) 
[17:41:17.468]                               next
[17:41:17.468]                             invokeRestart(restart)
[17:41:17.468]                             muffled <- TRUE
[17:41:17.468]                             break
[17:41:17.468]                           }
[17:41:17.468]                         }
[17:41:17.468]                       }
[17:41:17.468]                       invisible(muffled)
[17:41:17.468]                     }
[17:41:17.468]                     muffleCondition(cond, pattern = "^muffle")
[17:41:17.468]                   }
[17:41:17.468]                 }
[17:41:17.468]                 else {
[17:41:17.468]                   if (TRUE) {
[17:41:17.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.468]                     {
[17:41:17.468]                       inherits <- base::inherits
[17:41:17.468]                       invokeRestart <- base::invokeRestart
[17:41:17.468]                       is.null <- base::is.null
[17:41:17.468]                       muffled <- FALSE
[17:41:17.468]                       if (inherits(cond, "message")) {
[17:41:17.468]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:17.468]                         if (muffled) 
[17:41:17.468]                           invokeRestart("muffleMessage")
[17:41:17.468]                       }
[17:41:17.468]                       else if (inherits(cond, "warning")) {
[17:41:17.468]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:17.468]                         if (muffled) 
[17:41:17.468]                           invokeRestart("muffleWarning")
[17:41:17.468]                       }
[17:41:17.468]                       else if (inherits(cond, "condition")) {
[17:41:17.468]                         if (!is.null(pattern)) {
[17:41:17.468]                           computeRestarts <- base::computeRestarts
[17:41:17.468]                           grepl <- base::grepl
[17:41:17.468]                           restarts <- computeRestarts(cond)
[17:41:17.468]                           for (restart in restarts) {
[17:41:17.468]                             name <- restart$name
[17:41:17.468]                             if (is.null(name)) 
[17:41:17.468]                               next
[17:41:17.468]                             if (!grepl(pattern, name)) 
[17:41:17.468]                               next
[17:41:17.468]                             invokeRestart(restart)
[17:41:17.468]                             muffled <- TRUE
[17:41:17.468]                             break
[17:41:17.468]                           }
[17:41:17.468]                         }
[17:41:17.468]                       }
[17:41:17.468]                       invisible(muffled)
[17:41:17.468]                     }
[17:41:17.468]                     muffleCondition(cond, pattern = "^muffle")
[17:41:17.468]                   }
[17:41:17.468]                 }
[17:41:17.468]             }
[17:41:17.468]         }))
[17:41:17.468]     }, error = function(ex) {
[17:41:17.468]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:17.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:17.468]                 ...future.rng), started = ...future.startTime, 
[17:41:17.468]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:17.468]             version = "1.8"), class = "FutureResult")
[17:41:17.468]     }, finally = {
[17:41:17.468]         if (!identical(...future.workdir, getwd())) 
[17:41:17.468]             setwd(...future.workdir)
[17:41:17.468]         {
[17:41:17.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:17.468]                 ...future.oldOptions$nwarnings <- NULL
[17:41:17.468]             }
[17:41:17.468]             base::options(...future.oldOptions)
[17:41:17.468]             if (.Platform$OS.type == "windows") {
[17:41:17.468]                 old_names <- names(...future.oldEnvVars)
[17:41:17.468]                 envs <- base::Sys.getenv()
[17:41:17.468]                 names <- names(envs)
[17:41:17.468]                 common <- intersect(names, old_names)
[17:41:17.468]                 added <- setdiff(names, old_names)
[17:41:17.468]                 removed <- setdiff(old_names, names)
[17:41:17.468]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:17.468]                   envs[common]]
[17:41:17.468]                 NAMES <- toupper(changed)
[17:41:17.468]                 args <- list()
[17:41:17.468]                 for (kk in seq_along(NAMES)) {
[17:41:17.468]                   name <- changed[[kk]]
[17:41:17.468]                   NAME <- NAMES[[kk]]
[17:41:17.468]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.468]                     next
[17:41:17.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:17.468]                 }
[17:41:17.468]                 NAMES <- toupper(added)
[17:41:17.468]                 for (kk in seq_along(NAMES)) {
[17:41:17.468]                   name <- added[[kk]]
[17:41:17.468]                   NAME <- NAMES[[kk]]
[17:41:17.468]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.468]                     next
[17:41:17.468]                   args[[name]] <- ""
[17:41:17.468]                 }
[17:41:17.468]                 NAMES <- toupper(removed)
[17:41:17.468]                 for (kk in seq_along(NAMES)) {
[17:41:17.468]                   name <- removed[[kk]]
[17:41:17.468]                   NAME <- NAMES[[kk]]
[17:41:17.468]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.468]                     next
[17:41:17.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:17.468]                 }
[17:41:17.468]                 if (length(args) > 0) 
[17:41:17.468]                   base::do.call(base::Sys.setenv, args = args)
[17:41:17.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:17.468]             }
[17:41:17.468]             else {
[17:41:17.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:17.468]             }
[17:41:17.468]             {
[17:41:17.468]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:17.468]                   0L) {
[17:41:17.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:17.468]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:17.468]                   base::options(opts)
[17:41:17.468]                 }
[17:41:17.468]                 {
[17:41:17.468]                   {
[17:41:17.468]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:17.468]                     NULL
[17:41:17.468]                   }
[17:41:17.468]                   options(future.plan = NULL)
[17:41:17.468]                   if (is.na(NA_character_)) 
[17:41:17.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:17.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:17.468]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:17.468]                     envir = parent.frame()) 
[17:41:17.468]                   {
[17:41:17.468]                     default_workers <- missing(workers)
[17:41:17.468]                     if (is.function(workers)) 
[17:41:17.468]                       workers <- workers()
[17:41:17.468]                     workers <- structure(as.integer(workers), 
[17:41:17.468]                       class = class(workers))
[17:41:17.468]                     stop_if_not(is.finite(workers), workers >= 
[17:41:17.468]                       1L)
[17:41:17.468]                     if ((workers == 1L && !inherits(workers, 
[17:41:17.468]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:17.468]                       if (default_workers) 
[17:41:17.468]                         supportsMulticore(warn = TRUE)
[17:41:17.468]                       return(sequential(..., envir = envir))
[17:41:17.468]                     }
[17:41:17.468]                     oopts <- options(mc.cores = workers)
[17:41:17.468]                     on.exit(options(oopts))
[17:41:17.468]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:17.468]                       envir = envir)
[17:41:17.468]                     if (!future$lazy) 
[17:41:17.468]                       future <- run(future)
[17:41:17.468]                     invisible(future)
[17:41:17.468]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:17.468]                 }
[17:41:17.468]             }
[17:41:17.468]         }
[17:41:17.468]     })
[17:41:17.468]     if (TRUE) {
[17:41:17.468]         base::sink(type = "output", split = FALSE)
[17:41:17.468]         if (FALSE) {
[17:41:17.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:17.468]         }
[17:41:17.468]         else {
[17:41:17.468]             ...future.result["stdout"] <- base::list(NULL)
[17:41:17.468]         }
[17:41:17.468]         base::close(...future.stdout)
[17:41:17.468]         ...future.stdout <- NULL
[17:41:17.468]     }
[17:41:17.468]     ...future.result$conditions <- ...future.conditions
[17:41:17.468]     ...future.result$finished <- base::Sys.time()
[17:41:17.468]     ...future.result
[17:41:17.468] }
[17:41:17.470] assign_globals() ...
[17:41:17.470] List of 5
[17:41:17.470]  $ ...future.FUN            :function (x, y)  
[17:41:17.470]  $ MoreArgs                 : NULL
[17:41:17.470]  $ ...future.elements_ii    :List of 2
[17:41:17.470]   ..$ :List of 1
[17:41:17.470]   .. ..$ : int 0
[17:41:17.470]   ..$ :List of 1
[17:41:17.470]   .. ..$ : int 1
[17:41:17.470]  $ ...future.seeds_ii       : NULL
[17:41:17.470]  $ ...future.globals.maxSize: NULL
[17:41:17.470]  - attr(*, "where")=List of 5
[17:41:17.470]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:17.470]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:17.470]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:17.470]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:17.470]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:17.470]  - attr(*, "resolved")= logi FALSE
[17:41:17.470]  - attr(*, "total_size")= num 6368
[17:41:17.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:17.470]  - attr(*, "already-done")= logi TRUE
[17:41:17.477] - reassign environment for ‘...future.FUN’
[17:41:17.478] - copied ‘...future.FUN’ to environment
[17:41:17.478] - copied ‘MoreArgs’ to environment
[17:41:17.478] - copied ‘...future.elements_ii’ to environment
[17:41:17.478] - copied ‘...future.seeds_ii’ to environment
[17:41:17.478] - copied ‘...future.globals.maxSize’ to environment
[17:41:17.478] assign_globals() ... done
[17:41:17.478] requestCore(): workers = 2
[17:41:17.480] MulticoreFuture started
[17:41:17.481] - Launch lazy future ... done
[17:41:17.481] run() for ‘MulticoreFuture’ ... done
[17:41:17.481] Created future:
[17:41:17.481] plan(): Setting new future strategy stack:
[17:41:17.482] List of future strategies:
[17:41:17.482] 1. sequential:
[17:41:17.482]    - args: function (..., envir = parent.frame())
[17:41:17.482]    - tweaked: FALSE
[17:41:17.482]    - call: NULL
[17:41:17.482] plan(): nbrOfWorkers() = 1
[17:41:17.484] plan(): Setting new future strategy stack:
[17:41:17.485] List of future strategies:
[17:41:17.485] 1. multicore:
[17:41:17.485]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:17.485]    - tweaked: FALSE
[17:41:17.485]    - call: plan(strategy)
[17:41:17.490] plan(): nbrOfWorkers() = 2
[17:41:17.481] MulticoreFuture:
[17:41:17.481] Label: ‘future_mapply-2’
[17:41:17.481] Expression:
[17:41:17.481] {
[17:41:17.481]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:17.481]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:17.481]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:17.481]         on.exit(options(oopts), add = TRUE)
[17:41:17.481]     }
[17:41:17.481]     {
[17:41:17.481]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:17.481]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:17.481]         do.call(mapply, args = args)
[17:41:17.481]     }
[17:41:17.481] }
[17:41:17.481] Lazy evaluation: FALSE
[17:41:17.481] Asynchronous evaluation: TRUE
[17:41:17.481] Local evaluation: TRUE
[17:41:17.481] Environment: R_GlobalEnv
[17:41:17.481] Capture standard output: FALSE
[17:41:17.481] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:17.481] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:17.481] Packages: <none>
[17:41:17.481] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:17.481] Resolved: TRUE
[17:41:17.481] Value: <not collected>
[17:41:17.481] Conditions captured: <none>
[17:41:17.481] Early signaling: FALSE
[17:41:17.481] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:17.481] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:17.491] Chunk #2 of 2 ... DONE
[17:41:17.491] Launching 2 futures (chunks) ... DONE
[17:41:17.491] Resolving 2 futures (chunks) ...
[17:41:17.492] resolve() on list ...
[17:41:17.492]  recursive: 0
[17:41:17.492]  length: 2
[17:41:17.492] 
[17:41:17.503] Future #2
[17:41:17.504] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:41:17.504] - nx: 2
[17:41:17.504] - relay: TRUE
[17:41:17.504] - stdout: TRUE
[17:41:17.504] - signal: TRUE
[17:41:17.505] - resignal: FALSE
[17:41:17.505] - force: TRUE
[17:41:17.505] - relayed: [n=2] FALSE, FALSE
[17:41:17.505] - queued futures: [n=2] FALSE, FALSE
[17:41:17.505]  - until=1
[17:41:17.505]  - relaying element #1
[17:41:17.505] - relayed: [n=2] FALSE, FALSE
[17:41:17.506] - queued futures: [n=2] FALSE, TRUE
[17:41:17.506] signalConditionsASAP(NULL, pos=2) ... done
[17:41:17.506]  length: 1 (resolved future 2)
[17:41:17.936] plan(): Setting new future strategy stack:
[17:41:17.937] List of future strategies:
[17:41:17.937] 1. multicore:
[17:41:17.937]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:17.937]    - tweaked: FALSE
[17:41:17.937]    - call: plan(strategy)
[17:41:17.941] plan(): nbrOfWorkers() = 2
[17:41:17.944] Future #1
[17:41:17.945] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:41:17.945] - nx: 2
[17:41:17.945] - relay: TRUE
[17:41:17.945] - stdout: TRUE
[17:41:17.945] - signal: TRUE
[17:41:17.945] - resignal: FALSE
[17:41:17.945] - force: TRUE
[17:41:17.945] - relayed: [n=2] FALSE, FALSE
[17:41:17.945] - queued futures: [n=2] FALSE, TRUE
[17:41:17.946]  - until=1
[17:41:17.946]  - relaying element #1
[17:41:17.946] - relayed: [n=2] TRUE, FALSE
[17:41:17.946] - queued futures: [n=2] TRUE, TRUE
[17:41:17.946] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:41:17.946]  length: 0 (resolved future 1)
[17:41:17.946] Relaying remaining futures
[17:41:17.947] signalConditionsASAP(NULL, pos=0) ...
[17:41:17.947] - nx: 2
[17:41:17.947] - relay: TRUE
[17:41:17.947] - stdout: TRUE
[17:41:17.947] - signal: TRUE
[17:41:17.947] - resignal: FALSE
[17:41:17.947] - force: TRUE
[17:41:17.947] - relayed: [n=2] TRUE, FALSE
[17:41:17.947] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:17.948]  - relaying element #2
[17:41:17.950] - relayed: [n=2] TRUE, TRUE
[17:41:17.950] - queued futures: [n=2] TRUE, TRUE
[17:41:17.951] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:41:17.951] resolve() on list ... DONE
[17:41:17.951]  - Number of value chunks collected: 2
[17:41:17.951] Resolving 2 futures (chunks) ... DONE
[17:41:17.952] Reducing values from 2 chunks ...
[17:41:17.952]  - Number of values collected after concatenation: 2
[17:41:17.952]  - Number of values expected: 2
[17:41:17.952] Reducing values from 2 chunks ... DONE
[17:41:17.952] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:41:17.953] future_mapply() ...
[17:41:17.958] Number of chunks: 2
[17:41:17.958] getGlobalsAndPackagesXApply() ...
[17:41:17.958]  - future.globals: TRUE
[17:41:17.958] getGlobalsAndPackages() ...
[17:41:17.958] Searching for globals...
[17:41:17.960] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:17.960] Searching for globals ... DONE
[17:41:17.961] Resolving globals: FALSE
[17:41:17.961] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:17.961] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:17.962] - globals: [1] ‘FUN’
[17:41:17.962] 
[17:41:17.962] getGlobalsAndPackages() ... DONE
[17:41:17.962]  - globals found/used: [n=1] ‘FUN’
[17:41:17.962]  - needed namespaces: [n=0] 
[17:41:17.962] Finding globals ... DONE
[17:41:17.962] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:17.963] List of 2
[17:41:17.963]  $ ...future.FUN:function (x, y)  
[17:41:17.963]  $ MoreArgs     : NULL
[17:41:17.963]  - attr(*, "where")=List of 2
[17:41:17.963]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:17.963]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:17.963]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:17.963]  - attr(*, "resolved")= logi FALSE
[17:41:17.963]  - attr(*, "total_size")= num NA
[17:41:17.965] Packages to be attached in all futures: [n=0] 
[17:41:17.966] getGlobalsAndPackagesXApply() ... DONE
[17:41:17.966] Number of futures (= number of chunks): 2
[17:41:17.966] Launching 2 futures (chunks) ...
[17:41:17.966] Chunk #1 of 2 ...
[17:41:17.966]  - Finding globals in '...' for chunk #1 ...
[17:41:17.966] getGlobalsAndPackages() ...
[17:41:17.966] Searching for globals...
[17:41:17.967] 
[17:41:17.967] Searching for globals ... DONE
[17:41:17.967] - globals: [0] <none>
[17:41:17.967] getGlobalsAndPackages() ... DONE
[17:41:17.967]    + additional globals found: [n=0] 
[17:41:17.967]    + additional namespaces needed: [n=0] 
[17:41:17.967]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:17.967]  - seeds: <none>
[17:41:17.968] getGlobalsAndPackages() ...
[17:41:17.968] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:17.968] Resolving globals: FALSE
[17:41:17.968] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:17.969] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:17.969] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:17.969] 
[17:41:17.969] getGlobalsAndPackages() ... DONE
[17:41:17.969] run() for ‘Future’ ...
[17:41:17.969] - state: ‘created’
[17:41:17.970] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:17.973] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:17.973] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:17.973]   - Field: ‘label’
[17:41:17.974]   - Field: ‘local’
[17:41:17.974]   - Field: ‘owner’
[17:41:17.974]   - Field: ‘envir’
[17:41:17.974]   - Field: ‘workers’
[17:41:17.974]   - Field: ‘packages’
[17:41:17.974]   - Field: ‘gc’
[17:41:17.974]   - Field: ‘job’
[17:41:17.974]   - Field: ‘conditions’
[17:41:17.974]   - Field: ‘expr’
[17:41:17.974]   - Field: ‘uuid’
[17:41:17.974]   - Field: ‘seed’
[17:41:17.975]   - Field: ‘version’
[17:41:17.975]   - Field: ‘result’
[17:41:17.975]   - Field: ‘asynchronous’
[17:41:17.975]   - Field: ‘calls’
[17:41:17.975]   - Field: ‘globals’
[17:41:17.975]   - Field: ‘stdout’
[17:41:17.975]   - Field: ‘earlySignal’
[17:41:17.975]   - Field: ‘lazy’
[17:41:17.975]   - Field: ‘state’
[17:41:17.975] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:17.976] - Launch lazy future ...
[17:41:17.976] Packages needed by the future expression (n = 0): <none>
[17:41:17.976] Packages needed by future strategies (n = 0): <none>
[17:41:17.976] {
[17:41:17.976]     {
[17:41:17.976]         {
[17:41:17.976]             ...future.startTime <- base::Sys.time()
[17:41:17.976]             {
[17:41:17.976]                 {
[17:41:17.976]                   {
[17:41:17.976]                     {
[17:41:17.976]                       base::local({
[17:41:17.976]                         has_future <- base::requireNamespace("future", 
[17:41:17.976]                           quietly = TRUE)
[17:41:17.976]                         if (has_future) {
[17:41:17.976]                           ns <- base::getNamespace("future")
[17:41:17.976]                           version <- ns[[".package"]][["version"]]
[17:41:17.976]                           if (is.null(version)) 
[17:41:17.976]                             version <- utils::packageVersion("future")
[17:41:17.976]                         }
[17:41:17.976]                         else {
[17:41:17.976]                           version <- NULL
[17:41:17.976]                         }
[17:41:17.976]                         if (!has_future || version < "1.8.0") {
[17:41:17.976]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:17.976]                             "", base::R.version$version.string), 
[17:41:17.976]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:17.976]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:17.976]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:17.976]                               "release", "version")], collapse = " "), 
[17:41:17.976]                             hostname = base::Sys.info()[["nodename"]])
[17:41:17.976]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:17.976]                             info)
[17:41:17.976]                           info <- base::paste(info, collapse = "; ")
[17:41:17.976]                           if (!has_future) {
[17:41:17.976]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:17.976]                               info)
[17:41:17.976]                           }
[17:41:17.976]                           else {
[17:41:17.976]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:17.976]                               info, version)
[17:41:17.976]                           }
[17:41:17.976]                           base::stop(msg)
[17:41:17.976]                         }
[17:41:17.976]                       })
[17:41:17.976]                     }
[17:41:17.976]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:17.976]                     base::options(mc.cores = 1L)
[17:41:17.976]                   }
[17:41:17.976]                   options(future.plan = NULL)
[17:41:17.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:17.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:17.976]                 }
[17:41:17.976]                 ...future.workdir <- getwd()
[17:41:17.976]             }
[17:41:17.976]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:17.976]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:17.976]         }
[17:41:17.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:17.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:17.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:17.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:17.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:17.976]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:17.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:17.976]             base::names(...future.oldOptions))
[17:41:17.976]     }
[17:41:17.976]     if (FALSE) {
[17:41:17.976]     }
[17:41:17.976]     else {
[17:41:17.976]         if (TRUE) {
[17:41:17.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:17.976]                 open = "w")
[17:41:17.976]         }
[17:41:17.976]         else {
[17:41:17.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:17.976]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:17.976]         }
[17:41:17.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:17.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:17.976]             base::sink(type = "output", split = FALSE)
[17:41:17.976]             base::close(...future.stdout)
[17:41:17.976]         }, add = TRUE)
[17:41:17.976]     }
[17:41:17.976]     ...future.frame <- base::sys.nframe()
[17:41:17.976]     ...future.conditions <- base::list()
[17:41:17.976]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:17.976]     if (FALSE) {
[17:41:17.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:17.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:17.976]     }
[17:41:17.976]     ...future.result <- base::tryCatch({
[17:41:17.976]         base::withCallingHandlers({
[17:41:17.976]             ...future.value <- base::withVisible(base::local({
[17:41:17.976]                 withCallingHandlers({
[17:41:17.976]                   {
[17:41:17.976]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:17.976]                     if (!identical(...future.globals.maxSize.org, 
[17:41:17.976]                       ...future.globals.maxSize)) {
[17:41:17.976]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:17.976]                       on.exit(options(oopts), add = TRUE)
[17:41:17.976]                     }
[17:41:17.976]                     {
[17:41:17.976]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:17.976]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:17.976]                         USE.NAMES = FALSE)
[17:41:17.976]                       do.call(mapply, args = args)
[17:41:17.976]                     }
[17:41:17.976]                   }
[17:41:17.976]                 }, immediateCondition = function(cond) {
[17:41:17.976]                   save_rds <- function (object, pathname, ...) 
[17:41:17.976]                   {
[17:41:17.976]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:17.976]                     if (file_test("-f", pathname_tmp)) {
[17:41:17.976]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.976]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:17.976]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.976]                         fi_tmp[["mtime"]])
[17:41:17.976]                     }
[17:41:17.976]                     tryCatch({
[17:41:17.976]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:17.976]                     }, error = function(ex) {
[17:41:17.976]                       msg <- conditionMessage(ex)
[17:41:17.976]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.976]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:17.976]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.976]                         fi_tmp[["mtime"]], msg)
[17:41:17.976]                       ex$message <- msg
[17:41:17.976]                       stop(ex)
[17:41:17.976]                     })
[17:41:17.976]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:17.976]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:17.976]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:17.976]                       fi_tmp <- file.info(pathname_tmp)
[17:41:17.976]                       fi <- file.info(pathname)
[17:41:17.976]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:17.976]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:17.976]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:17.976]                         fi[["size"]], fi[["mtime"]])
[17:41:17.976]                       stop(msg)
[17:41:17.976]                     }
[17:41:17.976]                     invisible(pathname)
[17:41:17.976]                   }
[17:41:17.976]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:17.976]                     rootPath = tempdir()) 
[17:41:17.976]                   {
[17:41:17.976]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:17.976]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:17.976]                       tmpdir = path, fileext = ".rds")
[17:41:17.976]                     save_rds(obj, file)
[17:41:17.976]                   }
[17:41:17.976]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:17.976]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.976]                   {
[17:41:17.976]                     inherits <- base::inherits
[17:41:17.976]                     invokeRestart <- base::invokeRestart
[17:41:17.976]                     is.null <- base::is.null
[17:41:17.976]                     muffled <- FALSE
[17:41:17.976]                     if (inherits(cond, "message")) {
[17:41:17.976]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:17.976]                       if (muffled) 
[17:41:17.976]                         invokeRestart("muffleMessage")
[17:41:17.976]                     }
[17:41:17.976]                     else if (inherits(cond, "warning")) {
[17:41:17.976]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:17.976]                       if (muffled) 
[17:41:17.976]                         invokeRestart("muffleWarning")
[17:41:17.976]                     }
[17:41:17.976]                     else if (inherits(cond, "condition")) {
[17:41:17.976]                       if (!is.null(pattern)) {
[17:41:17.976]                         computeRestarts <- base::computeRestarts
[17:41:17.976]                         grepl <- base::grepl
[17:41:17.976]                         restarts <- computeRestarts(cond)
[17:41:17.976]                         for (restart in restarts) {
[17:41:17.976]                           name <- restart$name
[17:41:17.976]                           if (is.null(name)) 
[17:41:17.976]                             next
[17:41:17.976]                           if (!grepl(pattern, name)) 
[17:41:17.976]                             next
[17:41:17.976]                           invokeRestart(restart)
[17:41:17.976]                           muffled <- TRUE
[17:41:17.976]                           break
[17:41:17.976]                         }
[17:41:17.976]                       }
[17:41:17.976]                     }
[17:41:17.976]                     invisible(muffled)
[17:41:17.976]                   }
[17:41:17.976]                   muffleCondition(cond)
[17:41:17.976]                 })
[17:41:17.976]             }))
[17:41:17.976]             future::FutureResult(value = ...future.value$value, 
[17:41:17.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:17.976]                   ...future.rng), globalenv = if (FALSE) 
[17:41:17.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:17.976]                     ...future.globalenv.names))
[17:41:17.976]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:17.976]         }, condition = base::local({
[17:41:17.976]             c <- base::c
[17:41:17.976]             inherits <- base::inherits
[17:41:17.976]             invokeRestart <- base::invokeRestart
[17:41:17.976]             length <- base::length
[17:41:17.976]             list <- base::list
[17:41:17.976]             seq.int <- base::seq.int
[17:41:17.976]             signalCondition <- base::signalCondition
[17:41:17.976]             sys.calls <- base::sys.calls
[17:41:17.976]             `[[` <- base::`[[`
[17:41:17.976]             `+` <- base::`+`
[17:41:17.976]             `<<-` <- base::`<<-`
[17:41:17.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:17.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:17.976]                   3L)]
[17:41:17.976]             }
[17:41:17.976]             function(cond) {
[17:41:17.976]                 is_error <- inherits(cond, "error")
[17:41:17.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:17.976]                   NULL)
[17:41:17.976]                 if (is_error) {
[17:41:17.976]                   sessionInformation <- function() {
[17:41:17.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:17.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:17.976]                       search = base::search(), system = base::Sys.info())
[17:41:17.976]                   }
[17:41:17.976]                   ...future.conditions[[length(...future.conditions) + 
[17:41:17.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:17.976]                     cond$call), session = sessionInformation(), 
[17:41:17.976]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:17.976]                   signalCondition(cond)
[17:41:17.976]                 }
[17:41:17.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:17.976]                 "immediateCondition"))) {
[17:41:17.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:17.976]                   ...future.conditions[[length(...future.conditions) + 
[17:41:17.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:17.976]                   if (TRUE && !signal) {
[17:41:17.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.976]                     {
[17:41:17.976]                       inherits <- base::inherits
[17:41:17.976]                       invokeRestart <- base::invokeRestart
[17:41:17.976]                       is.null <- base::is.null
[17:41:17.976]                       muffled <- FALSE
[17:41:17.976]                       if (inherits(cond, "message")) {
[17:41:17.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:17.976]                         if (muffled) 
[17:41:17.976]                           invokeRestart("muffleMessage")
[17:41:17.976]                       }
[17:41:17.976]                       else if (inherits(cond, "warning")) {
[17:41:17.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:17.976]                         if (muffled) 
[17:41:17.976]                           invokeRestart("muffleWarning")
[17:41:17.976]                       }
[17:41:17.976]                       else if (inherits(cond, "condition")) {
[17:41:17.976]                         if (!is.null(pattern)) {
[17:41:17.976]                           computeRestarts <- base::computeRestarts
[17:41:17.976]                           grepl <- base::grepl
[17:41:17.976]                           restarts <- computeRestarts(cond)
[17:41:17.976]                           for (restart in restarts) {
[17:41:17.976]                             name <- restart$name
[17:41:17.976]                             if (is.null(name)) 
[17:41:17.976]                               next
[17:41:17.976]                             if (!grepl(pattern, name)) 
[17:41:17.976]                               next
[17:41:17.976]                             invokeRestart(restart)
[17:41:17.976]                             muffled <- TRUE
[17:41:17.976]                             break
[17:41:17.976]                           }
[17:41:17.976]                         }
[17:41:17.976]                       }
[17:41:17.976]                       invisible(muffled)
[17:41:17.976]                     }
[17:41:17.976]                     muffleCondition(cond, pattern = "^muffle")
[17:41:17.976]                   }
[17:41:17.976]                 }
[17:41:17.976]                 else {
[17:41:17.976]                   if (TRUE) {
[17:41:17.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:17.976]                     {
[17:41:17.976]                       inherits <- base::inherits
[17:41:17.976]                       invokeRestart <- base::invokeRestart
[17:41:17.976]                       is.null <- base::is.null
[17:41:17.976]                       muffled <- FALSE
[17:41:17.976]                       if (inherits(cond, "message")) {
[17:41:17.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:17.976]                         if (muffled) 
[17:41:17.976]                           invokeRestart("muffleMessage")
[17:41:17.976]                       }
[17:41:17.976]                       else if (inherits(cond, "warning")) {
[17:41:17.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:17.976]                         if (muffled) 
[17:41:17.976]                           invokeRestart("muffleWarning")
[17:41:17.976]                       }
[17:41:17.976]                       else if (inherits(cond, "condition")) {
[17:41:17.976]                         if (!is.null(pattern)) {
[17:41:17.976]                           computeRestarts <- base::computeRestarts
[17:41:17.976]                           grepl <- base::grepl
[17:41:17.976]                           restarts <- computeRestarts(cond)
[17:41:17.976]                           for (restart in restarts) {
[17:41:17.976]                             name <- restart$name
[17:41:17.976]                             if (is.null(name)) 
[17:41:17.976]                               next
[17:41:17.976]                             if (!grepl(pattern, name)) 
[17:41:17.976]                               next
[17:41:17.976]                             invokeRestart(restart)
[17:41:17.976]                             muffled <- TRUE
[17:41:17.976]                             break
[17:41:17.976]                           }
[17:41:17.976]                         }
[17:41:17.976]                       }
[17:41:17.976]                       invisible(muffled)
[17:41:17.976]                     }
[17:41:17.976]                     muffleCondition(cond, pattern = "^muffle")
[17:41:17.976]                   }
[17:41:17.976]                 }
[17:41:17.976]             }
[17:41:17.976]         }))
[17:41:17.976]     }, error = function(ex) {
[17:41:17.976]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:17.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:17.976]                 ...future.rng), started = ...future.startTime, 
[17:41:17.976]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:17.976]             version = "1.8"), class = "FutureResult")
[17:41:17.976]     }, finally = {
[17:41:17.976]         if (!identical(...future.workdir, getwd())) 
[17:41:17.976]             setwd(...future.workdir)
[17:41:17.976]         {
[17:41:17.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:17.976]                 ...future.oldOptions$nwarnings <- NULL
[17:41:17.976]             }
[17:41:17.976]             base::options(...future.oldOptions)
[17:41:17.976]             if (.Platform$OS.type == "windows") {
[17:41:17.976]                 old_names <- names(...future.oldEnvVars)
[17:41:17.976]                 envs <- base::Sys.getenv()
[17:41:17.976]                 names <- names(envs)
[17:41:17.976]                 common <- intersect(names, old_names)
[17:41:17.976]                 added <- setdiff(names, old_names)
[17:41:17.976]                 removed <- setdiff(old_names, names)
[17:41:17.976]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:17.976]                   envs[common]]
[17:41:17.976]                 NAMES <- toupper(changed)
[17:41:17.976]                 args <- list()
[17:41:17.976]                 for (kk in seq_along(NAMES)) {
[17:41:17.976]                   name <- changed[[kk]]
[17:41:17.976]                   NAME <- NAMES[[kk]]
[17:41:17.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.976]                     next
[17:41:17.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:17.976]                 }
[17:41:17.976]                 NAMES <- toupper(added)
[17:41:17.976]                 for (kk in seq_along(NAMES)) {
[17:41:17.976]                   name <- added[[kk]]
[17:41:17.976]                   NAME <- NAMES[[kk]]
[17:41:17.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.976]                     next
[17:41:17.976]                   args[[name]] <- ""
[17:41:17.976]                 }
[17:41:17.976]                 NAMES <- toupper(removed)
[17:41:17.976]                 for (kk in seq_along(NAMES)) {
[17:41:17.976]                   name <- removed[[kk]]
[17:41:17.976]                   NAME <- NAMES[[kk]]
[17:41:17.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:17.976]                     next
[17:41:17.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:17.976]                 }
[17:41:17.976]                 if (length(args) > 0) 
[17:41:17.976]                   base::do.call(base::Sys.setenv, args = args)
[17:41:17.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:17.976]             }
[17:41:17.976]             else {
[17:41:17.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:17.976]             }
[17:41:17.976]             {
[17:41:17.976]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:17.976]                   0L) {
[17:41:17.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:17.976]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:17.976]                   base::options(opts)
[17:41:17.976]                 }
[17:41:17.976]                 {
[17:41:17.976]                   {
[17:41:17.976]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:17.976]                     NULL
[17:41:17.976]                   }
[17:41:17.976]                   options(future.plan = NULL)
[17:41:17.976]                   if (is.na(NA_character_)) 
[17:41:17.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:17.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:17.976]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:17.976]                     envir = parent.frame()) 
[17:41:17.976]                   {
[17:41:17.976]                     default_workers <- missing(workers)
[17:41:17.976]                     if (is.function(workers)) 
[17:41:17.976]                       workers <- workers()
[17:41:17.976]                     workers <- structure(as.integer(workers), 
[17:41:17.976]                       class = class(workers))
[17:41:17.976]                     stop_if_not(is.finite(workers), workers >= 
[17:41:17.976]                       1L)
[17:41:17.976]                     if ((workers == 1L && !inherits(workers, 
[17:41:17.976]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:17.976]                       if (default_workers) 
[17:41:17.976]                         supportsMulticore(warn = TRUE)
[17:41:17.976]                       return(sequential(..., envir = envir))
[17:41:17.976]                     }
[17:41:17.976]                     oopts <- options(mc.cores = workers)
[17:41:17.976]                     on.exit(options(oopts))
[17:41:17.976]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:17.976]                       envir = envir)
[17:41:17.976]                     if (!future$lazy) 
[17:41:17.976]                       future <- run(future)
[17:41:17.976]                     invisible(future)
[17:41:17.976]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:17.976]                 }
[17:41:17.976]             }
[17:41:17.976]         }
[17:41:17.976]     })
[17:41:17.976]     if (TRUE) {
[17:41:17.976]         base::sink(type = "output", split = FALSE)
[17:41:17.976]         if (TRUE) {
[17:41:17.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:17.976]         }
[17:41:17.976]         else {
[17:41:17.976]             ...future.result["stdout"] <- base::list(NULL)
[17:41:17.976]         }
[17:41:17.976]         base::close(...future.stdout)
[17:41:17.976]         ...future.stdout <- NULL
[17:41:17.976]     }
[17:41:17.976]     ...future.result$conditions <- ...future.conditions
[17:41:17.976]     ...future.result$finished <- base::Sys.time()
[17:41:17.976]     ...future.result
[17:41:17.976] }
[17:41:17.979] assign_globals() ...
[17:41:17.979] List of 5
[17:41:17.979]  $ ...future.FUN            :function (x, y)  
[17:41:17.979]  $ MoreArgs                 : NULL
[17:41:17.979]  $ ...future.elements_ii    :List of 2
[17:41:17.979]   ..$ :List of 1
[17:41:17.979]   .. ..$ : int 1
[17:41:17.979]   ..$ :List of 1
[17:41:17.979]   .. ..$ : int 0
[17:41:17.979]  $ ...future.seeds_ii       : NULL
[17:41:17.979]  $ ...future.globals.maxSize: NULL
[17:41:17.979]  - attr(*, "where")=List of 5
[17:41:17.979]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:17.979]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:17.979]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:17.979]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:17.979]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:17.979]  - attr(*, "resolved")= logi FALSE
[17:41:17.979]  - attr(*, "total_size")= num 6368
[17:41:17.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:17.979]  - attr(*, "already-done")= logi TRUE
[17:41:17.986] - reassign environment for ‘...future.FUN’
[17:41:17.986] - copied ‘...future.FUN’ to environment
[17:41:17.986] - copied ‘MoreArgs’ to environment
[17:41:17.986] - copied ‘...future.elements_ii’ to environment
[17:41:17.986] - copied ‘...future.seeds_ii’ to environment
[17:41:17.986] - copied ‘...future.globals.maxSize’ to environment
[17:41:17.986] assign_globals() ... done
[17:41:17.986] requestCore(): workers = 2
[17:41:17.988] MulticoreFuture started
[17:41:17.989] - Launch lazy future ... done
[17:41:17.989] run() for ‘MulticoreFuture’ ... done
[17:41:17.989] Created future:
[17:41:17.989] plan(): Setting new future strategy stack:
[17:41:17.990] List of future strategies:
[17:41:17.990] 1. sequential:
[17:41:17.990]    - args: function (..., envir = parent.frame())
[17:41:17.990]    - tweaked: FALSE
[17:41:17.990]    - call: NULL
[17:41:17.991] plan(): nbrOfWorkers() = 1
[17:41:17.990] MulticoreFuture:
[17:41:17.990] Label: ‘future_mapply-1’
[17:41:17.990] Expression:
[17:41:17.990] {
[17:41:17.990]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:17.990]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:17.990]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:17.990]         on.exit(options(oopts), add = TRUE)
[17:41:17.990]     }
[17:41:17.990]     {
[17:41:17.990]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:17.990]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:17.990]         do.call(mapply, args = args)
[17:41:17.990]     }
[17:41:17.990] }
[17:41:17.990] Lazy evaluation: FALSE
[17:41:17.990] Asynchronous evaluation: TRUE
[17:41:17.990] Local evaluation: TRUE
[17:41:17.990] Environment: R_GlobalEnv
[17:41:17.990] Capture standard output: TRUE
[17:41:17.990] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:17.990] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:17.990] Packages: <none>
[17:41:17.990] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:17.990] Resolved: FALSE
[17:41:17.990] Value: <not collected>
[17:41:17.990] Conditions captured: <none>
[17:41:17.990] Early signaling: FALSE
[17:41:17.990] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:17.990] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:18.002] Chunk #1 of 2 ... DONE
[17:41:18.003] Chunk #2 of 2 ...
[17:41:18.003]  - Finding globals in '...' for chunk #2 ...
[17:41:18.003] getGlobalsAndPackages() ...
[17:41:18.003] Searching for globals...
[17:41:18.004] 
[17:41:18.004] Searching for globals ... DONE
[17:41:18.004] - globals: [0] <none>
[17:41:18.004] getGlobalsAndPackages() ... DONE
[17:41:18.005]    + additional globals found: [n=0] 
[17:41:18.005]    + additional namespaces needed: [n=0] 
[17:41:18.005]  - Finding globals in '...' for chunk #2 ... DONE
[17:41:18.005]  - seeds: <none>
[17:41:18.005] getGlobalsAndPackages() ...
[17:41:18.005] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:18.006] Resolving globals: FALSE
[17:41:18.006] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:18.007] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:18.008] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:18.008] 
[17:41:18.008] getGlobalsAndPackages() ... DONE
[17:41:18.008] run() for ‘Future’ ...
[17:41:18.009] - state: ‘created’
[17:41:18.009] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:18.013] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:18.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:18.014]   - Field: ‘label’
[17:41:18.014]   - Field: ‘local’
[17:41:18.014]   - Field: ‘owner’
[17:41:18.014]   - Field: ‘envir’
[17:41:18.014]   - Field: ‘workers’
[17:41:18.015]   - Field: ‘packages’
[17:41:18.015]   - Field: ‘gc’
[17:41:18.015]   - Field: ‘job’
[17:41:18.015]   - Field: ‘conditions’
[17:41:18.015]   - Field: ‘expr’
[17:41:18.015]   - Field: ‘uuid’
[17:41:18.015]   - Field: ‘seed’
[17:41:18.016]   - Field: ‘version’
[17:41:18.016]   - Field: ‘result’
[17:41:18.016]   - Field: ‘asynchronous’
[17:41:18.016]   - Field: ‘calls’
[17:41:18.016]   - Field: ‘globals’
[17:41:18.016]   - Field: ‘stdout’
[17:41:18.016]   - Field: ‘earlySignal’
[17:41:18.016]   - Field: ‘lazy’
[17:41:18.017]   - Field: ‘state’
[17:41:18.017] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:18.017] - Launch lazy future ...
[17:41:18.017] Packages needed by the future expression (n = 0): <none>
[17:41:18.018] Packages needed by future strategies (n = 0): <none>
[17:41:18.018] {
[17:41:18.018]     {
[17:41:18.018]         {
[17:41:18.018]             ...future.startTime <- base::Sys.time()
[17:41:18.018]             {
[17:41:18.018]                 {
[17:41:18.018]                   {
[17:41:18.018]                     {
[17:41:18.018]                       base::local({
[17:41:18.018]                         has_future <- base::requireNamespace("future", 
[17:41:18.018]                           quietly = TRUE)
[17:41:18.018]                         if (has_future) {
[17:41:18.018]                           ns <- base::getNamespace("future")
[17:41:18.018]                           version <- ns[[".package"]][["version"]]
[17:41:18.018]                           if (is.null(version)) 
[17:41:18.018]                             version <- utils::packageVersion("future")
[17:41:18.018]                         }
[17:41:18.018]                         else {
[17:41:18.018]                           version <- NULL
[17:41:18.018]                         }
[17:41:18.018]                         if (!has_future || version < "1.8.0") {
[17:41:18.018]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:18.018]                             "", base::R.version$version.string), 
[17:41:18.018]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:18.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:18.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:18.018]                               "release", "version")], collapse = " "), 
[17:41:18.018]                             hostname = base::Sys.info()[["nodename"]])
[17:41:18.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:18.018]                             info)
[17:41:18.018]                           info <- base::paste(info, collapse = "; ")
[17:41:18.018]                           if (!has_future) {
[17:41:18.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:18.018]                               info)
[17:41:18.018]                           }
[17:41:18.018]                           else {
[17:41:18.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:18.018]                               info, version)
[17:41:18.018]                           }
[17:41:18.018]                           base::stop(msg)
[17:41:18.018]                         }
[17:41:18.018]                       })
[17:41:18.018]                     }
[17:41:18.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:18.018]                     base::options(mc.cores = 1L)
[17:41:18.018]                   }
[17:41:18.018]                   options(future.plan = NULL)
[17:41:18.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:18.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:18.018]                 }
[17:41:18.018]                 ...future.workdir <- getwd()
[17:41:18.018]             }
[17:41:18.018]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:18.018]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:18.018]         }
[17:41:18.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:18.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:18.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:18.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:18.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:18.018]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:18.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:18.018]             base::names(...future.oldOptions))
[17:41:18.018]     }
[17:41:18.018]     if (FALSE) {
[17:41:18.018]     }
[17:41:18.018]     else {
[17:41:18.018]         if (TRUE) {
[17:41:18.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:18.018]                 open = "w")
[17:41:18.018]         }
[17:41:18.018]         else {
[17:41:18.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:18.018]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:18.018]         }
[17:41:18.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:18.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:18.018]             base::sink(type = "output", split = FALSE)
[17:41:18.018]             base::close(...future.stdout)
[17:41:18.018]         }, add = TRUE)
[17:41:18.018]     }
[17:41:18.018]     ...future.frame <- base::sys.nframe()
[17:41:18.018]     ...future.conditions <- base::list()
[17:41:18.018]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:18.018]     if (FALSE) {
[17:41:18.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:18.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:18.018]     }
[17:41:18.018]     ...future.result <- base::tryCatch({
[17:41:18.018]         base::withCallingHandlers({
[17:41:18.018]             ...future.value <- base::withVisible(base::local({
[17:41:18.018]                 withCallingHandlers({
[17:41:18.018]                   {
[17:41:18.018]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:18.018]                     if (!identical(...future.globals.maxSize.org, 
[17:41:18.018]                       ...future.globals.maxSize)) {
[17:41:18.018]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:18.018]                       on.exit(options(oopts), add = TRUE)
[17:41:18.018]                     }
[17:41:18.018]                     {
[17:41:18.018]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:18.018]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:18.018]                         USE.NAMES = FALSE)
[17:41:18.018]                       do.call(mapply, args = args)
[17:41:18.018]                     }
[17:41:18.018]                   }
[17:41:18.018]                 }, immediateCondition = function(cond) {
[17:41:18.018]                   save_rds <- function (object, pathname, ...) 
[17:41:18.018]                   {
[17:41:18.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:18.018]                     if (file_test("-f", pathname_tmp)) {
[17:41:18.018]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:18.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.018]                         fi_tmp[["mtime"]])
[17:41:18.018]                     }
[17:41:18.018]                     tryCatch({
[17:41:18.018]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:18.018]                     }, error = function(ex) {
[17:41:18.018]                       msg <- conditionMessage(ex)
[17:41:18.018]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:18.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.018]                         fi_tmp[["mtime"]], msg)
[17:41:18.018]                       ex$message <- msg
[17:41:18.018]                       stop(ex)
[17:41:18.018]                     })
[17:41:18.018]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:18.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:18.018]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:18.018]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.018]                       fi <- file.info(pathname)
[17:41:18.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:18.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:18.018]                         fi[["size"]], fi[["mtime"]])
[17:41:18.018]                       stop(msg)
[17:41:18.018]                     }
[17:41:18.018]                     invisible(pathname)
[17:41:18.018]                   }
[17:41:18.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:18.018]                     rootPath = tempdir()) 
[17:41:18.018]                   {
[17:41:18.018]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:18.018]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:18.018]                       tmpdir = path, fileext = ".rds")
[17:41:18.018]                     save_rds(obj, file)
[17:41:18.018]                   }
[17:41:18.018]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:18.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.018]                   {
[17:41:18.018]                     inherits <- base::inherits
[17:41:18.018]                     invokeRestart <- base::invokeRestart
[17:41:18.018]                     is.null <- base::is.null
[17:41:18.018]                     muffled <- FALSE
[17:41:18.018]                     if (inherits(cond, "message")) {
[17:41:18.018]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:18.018]                       if (muffled) 
[17:41:18.018]                         invokeRestart("muffleMessage")
[17:41:18.018]                     }
[17:41:18.018]                     else if (inherits(cond, "warning")) {
[17:41:18.018]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:18.018]                       if (muffled) 
[17:41:18.018]                         invokeRestart("muffleWarning")
[17:41:18.018]                     }
[17:41:18.018]                     else if (inherits(cond, "condition")) {
[17:41:18.018]                       if (!is.null(pattern)) {
[17:41:18.018]                         computeRestarts <- base::computeRestarts
[17:41:18.018]                         grepl <- base::grepl
[17:41:18.018]                         restarts <- computeRestarts(cond)
[17:41:18.018]                         for (restart in restarts) {
[17:41:18.018]                           name <- restart$name
[17:41:18.018]                           if (is.null(name)) 
[17:41:18.018]                             next
[17:41:18.018]                           if (!grepl(pattern, name)) 
[17:41:18.018]                             next
[17:41:18.018]                           invokeRestart(restart)
[17:41:18.018]                           muffled <- TRUE
[17:41:18.018]                           break
[17:41:18.018]                         }
[17:41:18.018]                       }
[17:41:18.018]                     }
[17:41:18.018]                     invisible(muffled)
[17:41:18.018]                   }
[17:41:18.018]                   muffleCondition(cond)
[17:41:18.018]                 })
[17:41:18.018]             }))
[17:41:18.018]             future::FutureResult(value = ...future.value$value, 
[17:41:18.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:18.018]                   ...future.rng), globalenv = if (FALSE) 
[17:41:18.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:18.018]                     ...future.globalenv.names))
[17:41:18.018]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:18.018]         }, condition = base::local({
[17:41:18.018]             c <- base::c
[17:41:18.018]             inherits <- base::inherits
[17:41:18.018]             invokeRestart <- base::invokeRestart
[17:41:18.018]             length <- base::length
[17:41:18.018]             list <- base::list
[17:41:18.018]             seq.int <- base::seq.int
[17:41:18.018]             signalCondition <- base::signalCondition
[17:41:18.018]             sys.calls <- base::sys.calls
[17:41:18.018]             `[[` <- base::`[[`
[17:41:18.018]             `+` <- base::`+`
[17:41:18.018]             `<<-` <- base::`<<-`
[17:41:18.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:18.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:18.018]                   3L)]
[17:41:18.018]             }
[17:41:18.018]             function(cond) {
[17:41:18.018]                 is_error <- inherits(cond, "error")
[17:41:18.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:18.018]                   NULL)
[17:41:18.018]                 if (is_error) {
[17:41:18.018]                   sessionInformation <- function() {
[17:41:18.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:18.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:18.018]                       search = base::search(), system = base::Sys.info())
[17:41:18.018]                   }
[17:41:18.018]                   ...future.conditions[[length(...future.conditions) + 
[17:41:18.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:18.018]                     cond$call), session = sessionInformation(), 
[17:41:18.018]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:18.018]                   signalCondition(cond)
[17:41:18.018]                 }
[17:41:18.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:18.018]                 "immediateCondition"))) {
[17:41:18.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:18.018]                   ...future.conditions[[length(...future.conditions) + 
[17:41:18.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:18.018]                   if (TRUE && !signal) {
[17:41:18.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.018]                     {
[17:41:18.018]                       inherits <- base::inherits
[17:41:18.018]                       invokeRestart <- base::invokeRestart
[17:41:18.018]                       is.null <- base::is.null
[17:41:18.018]                       muffled <- FALSE
[17:41:18.018]                       if (inherits(cond, "message")) {
[17:41:18.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:18.018]                         if (muffled) 
[17:41:18.018]                           invokeRestart("muffleMessage")
[17:41:18.018]                       }
[17:41:18.018]                       else if (inherits(cond, "warning")) {
[17:41:18.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:18.018]                         if (muffled) 
[17:41:18.018]                           invokeRestart("muffleWarning")
[17:41:18.018]                       }
[17:41:18.018]                       else if (inherits(cond, "condition")) {
[17:41:18.018]                         if (!is.null(pattern)) {
[17:41:18.018]                           computeRestarts <- base::computeRestarts
[17:41:18.018]                           grepl <- base::grepl
[17:41:18.018]                           restarts <- computeRestarts(cond)
[17:41:18.018]                           for (restart in restarts) {
[17:41:18.018]                             name <- restart$name
[17:41:18.018]                             if (is.null(name)) 
[17:41:18.018]                               next
[17:41:18.018]                             if (!grepl(pattern, name)) 
[17:41:18.018]                               next
[17:41:18.018]                             invokeRestart(restart)
[17:41:18.018]                             muffled <- TRUE
[17:41:18.018]                             break
[17:41:18.018]                           }
[17:41:18.018]                         }
[17:41:18.018]                       }
[17:41:18.018]                       invisible(muffled)
[17:41:18.018]                     }
[17:41:18.018]                     muffleCondition(cond, pattern = "^muffle")
[17:41:18.018]                   }
[17:41:18.018]                 }
[17:41:18.018]                 else {
[17:41:18.018]                   if (TRUE) {
[17:41:18.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.018]                     {
[17:41:18.018]                       inherits <- base::inherits
[17:41:18.018]                       invokeRestart <- base::invokeRestart
[17:41:18.018]                       is.null <- base::is.null
[17:41:18.018]                       muffled <- FALSE
[17:41:18.018]                       if (inherits(cond, "message")) {
[17:41:18.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:18.018]                         if (muffled) 
[17:41:18.018]                           invokeRestart("muffleMessage")
[17:41:18.018]                       }
[17:41:18.018]                       else if (inherits(cond, "warning")) {
[17:41:18.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:18.018]                         if (muffled) 
[17:41:18.018]                           invokeRestart("muffleWarning")
[17:41:18.018]                       }
[17:41:18.018]                       else if (inherits(cond, "condition")) {
[17:41:18.018]                         if (!is.null(pattern)) {
[17:41:18.018]                           computeRestarts <- base::computeRestarts
[17:41:18.018]                           grepl <- base::grepl
[17:41:18.018]                           restarts <- computeRestarts(cond)
[17:41:18.018]                           for (restart in restarts) {
[17:41:18.018]                             name <- restart$name
[17:41:18.018]                             if (is.null(name)) 
[17:41:18.018]                               next
[17:41:18.018]                             if (!grepl(pattern, name)) 
[17:41:18.018]                               next
[17:41:18.018]                             invokeRestart(restart)
[17:41:18.018]                             muffled <- TRUE
[17:41:18.018]                             break
[17:41:18.018]                           }
[17:41:18.018]                         }
[17:41:18.018]                       }
[17:41:18.018]                       invisible(muffled)
[17:41:18.018]                     }
[17:41:18.018]                     muffleCondition(cond, pattern = "^muffle")
[17:41:18.018]                   }
[17:41:18.018]                 }
[17:41:18.018]             }
[17:41:18.018]         }))
[17:41:18.018]     }, error = function(ex) {
[17:41:18.018]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:18.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:18.018]                 ...future.rng), started = ...future.startTime, 
[17:41:18.018]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:18.018]             version = "1.8"), class = "FutureResult")
[17:41:18.018]     }, finally = {
[17:41:18.018]         if (!identical(...future.workdir, getwd())) 
[17:41:18.018]             setwd(...future.workdir)
[17:41:18.018]         {
[17:41:18.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:18.018]                 ...future.oldOptions$nwarnings <- NULL
[17:41:18.018]             }
[17:41:18.018]             base::options(...future.oldOptions)
[17:41:18.018]             if (.Platform$OS.type == "windows") {
[17:41:18.018]                 old_names <- names(...future.oldEnvVars)
[17:41:18.018]                 envs <- base::Sys.getenv()
[17:41:18.018]                 names <- names(envs)
[17:41:18.018]                 common <- intersect(names, old_names)
[17:41:18.018]                 added <- setdiff(names, old_names)
[17:41:18.018]                 removed <- setdiff(old_names, names)
[17:41:18.018]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:18.018]                   envs[common]]
[17:41:18.018]                 NAMES <- toupper(changed)
[17:41:18.018]                 args <- list()
[17:41:18.018]                 for (kk in seq_along(NAMES)) {
[17:41:18.018]                   name <- changed[[kk]]
[17:41:18.018]                   NAME <- NAMES[[kk]]
[17:41:18.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.018]                     next
[17:41:18.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:18.018]                 }
[17:41:18.018]                 NAMES <- toupper(added)
[17:41:18.018]                 for (kk in seq_along(NAMES)) {
[17:41:18.018]                   name <- added[[kk]]
[17:41:18.018]                   NAME <- NAMES[[kk]]
[17:41:18.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.018]                     next
[17:41:18.018]                   args[[name]] <- ""
[17:41:18.018]                 }
[17:41:18.018]                 NAMES <- toupper(removed)
[17:41:18.018]                 for (kk in seq_along(NAMES)) {
[17:41:18.018]                   name <- removed[[kk]]
[17:41:18.018]                   NAME <- NAMES[[kk]]
[17:41:18.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.018]                     next
[17:41:18.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:18.018]                 }
[17:41:18.018]                 if (length(args) > 0) 
[17:41:18.018]                   base::do.call(base::Sys.setenv, args = args)
[17:41:18.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:18.018]             }
[17:41:18.018]             else {
[17:41:18.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:18.018]             }
[17:41:18.018]             {
[17:41:18.018]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:18.018]                   0L) {
[17:41:18.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:18.018]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:18.018]                   base::options(opts)
[17:41:18.018]                 }
[17:41:18.018]                 {
[17:41:18.018]                   {
[17:41:18.018]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:18.018]                     NULL
[17:41:18.018]                   }
[17:41:18.018]                   options(future.plan = NULL)
[17:41:18.018]                   if (is.na(NA_character_)) 
[17:41:18.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:18.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:18.018]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:18.018]                     envir = parent.frame()) 
[17:41:18.018]                   {
[17:41:18.018]                     default_workers <- missing(workers)
[17:41:18.018]                     if (is.function(workers)) 
[17:41:18.018]                       workers <- workers()
[17:41:18.018]                     workers <- structure(as.integer(workers), 
[17:41:18.018]                       class = class(workers))
[17:41:18.018]                     stop_if_not(is.finite(workers), workers >= 
[17:41:18.018]                       1L)
[17:41:18.018]                     if ((workers == 1L && !inherits(workers, 
[17:41:18.018]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:18.018]                       if (default_workers) 
[17:41:18.018]                         supportsMulticore(warn = TRUE)
[17:41:18.018]                       return(sequential(..., envir = envir))
[17:41:18.018]                     }
[17:41:18.018]                     oopts <- options(mc.cores = workers)
[17:41:18.018]                     on.exit(options(oopts))
[17:41:18.018]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:18.018]                       envir = envir)
[17:41:18.018]                     if (!future$lazy) 
[17:41:18.018]                       future <- run(future)
[17:41:18.018]                     invisible(future)
[17:41:18.018]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:18.018]                 }
[17:41:18.018]             }
[17:41:18.018]         }
[17:41:18.018]     })
[17:41:18.018]     if (TRUE) {
[17:41:18.018]         base::sink(type = "output", split = FALSE)
[17:41:18.018]         if (TRUE) {
[17:41:18.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:18.018]         }
[17:41:18.018]         else {
[17:41:18.018]             ...future.result["stdout"] <- base::list(NULL)
[17:41:18.018]         }
[17:41:18.018]         base::close(...future.stdout)
[17:41:18.018]         ...future.stdout <- NULL
[17:41:18.018]     }
[17:41:18.018]     ...future.result$conditions <- ...future.conditions
[17:41:18.018]     ...future.result$finished <- base::Sys.time()
[17:41:18.018]     ...future.result
[17:41:18.018] }
[17:41:18.022] assign_globals() ...
[17:41:18.022] List of 5
[17:41:18.022]  $ ...future.FUN            :function (x, y)  
[17:41:18.022]  $ MoreArgs                 : NULL
[17:41:18.022]  $ ...future.elements_ii    :List of 2
[17:41:18.022]   ..$ :List of 1
[17:41:18.022]   .. ..$ : int 0
[17:41:18.022]   ..$ :List of 1
[17:41:18.022]   .. ..$ : int 1
[17:41:18.022]  $ ...future.seeds_ii       : NULL
[17:41:18.022]  $ ...future.globals.maxSize: NULL
[17:41:18.022]  - attr(*, "where")=List of 5
[17:41:18.022]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:18.022]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:18.022]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:18.022]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:18.022]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:18.022]  - attr(*, "resolved")= logi FALSE
[17:41:18.022]  - attr(*, "total_size")= num 6368
[17:41:18.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:18.022]  - attr(*, "already-done")= logi TRUE
[17:41:18.029] - reassign environment for ‘...future.FUN’
[17:41:18.029] - copied ‘...future.FUN’ to environment
[17:41:18.036] - copied ‘MoreArgs’ to environment
[17:41:18.037] - copied ‘...future.elements_ii’ to environment
[17:41:18.037] - copied ‘...future.seeds_ii’ to environment
[17:41:18.037] - copied ‘...future.globals.maxSize’ to environment
[17:41:18.037] assign_globals() ... done
[17:41:18.037] requestCore(): workers = 2
[17:41:18.039] MulticoreFuture started
[17:41:18.040] - Launch lazy future ... done
[17:41:18.041] run() for ‘MulticoreFuture’ ... done
[17:41:18.041] plan(): Setting new future strategy stack:
[17:41:18.041] Created future:
[17:41:18.041] List of future strategies:
[17:41:18.041] 1. sequential:
[17:41:18.041]    - args: function (..., envir = parent.frame())
[17:41:18.041]    - tweaked: FALSE
[17:41:18.041]    - call: NULL
[17:41:18.042] plan(): nbrOfWorkers() = 1
[17:41:18.045] plan(): Setting new future strategy stack:
[17:41:18.046] List of future strategies:
[17:41:18.046] 1. multicore:
[17:41:18.046]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:18.046]    - tweaked: FALSE
[17:41:18.046]    - call: plan(strategy)
[17:41:18.052] plan(): nbrOfWorkers() = 2
[17:41:18.042] MulticoreFuture:
[17:41:18.042] Label: ‘future_mapply-2’
[17:41:18.042] Expression:
[17:41:18.042] {
[17:41:18.042]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:18.042]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:18.042]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:18.042]         on.exit(options(oopts), add = TRUE)
[17:41:18.042]     }
[17:41:18.042]     {
[17:41:18.042]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:18.042]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:18.042]         do.call(mapply, args = args)
[17:41:18.042]     }
[17:41:18.042] }
[17:41:18.042] Lazy evaluation: FALSE
[17:41:18.042] Asynchronous evaluation: TRUE
[17:41:18.042] Local evaluation: TRUE
[17:41:18.042] Environment: R_GlobalEnv
[17:41:18.042] Capture standard output: TRUE
[17:41:18.042] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:18.042] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:18.042] Packages: <none>
[17:41:18.042] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:18.042] Resolved: TRUE
[17:41:18.042] Value: <not collected>
[17:41:18.042] Conditions captured: <none>
[17:41:18.042] Early signaling: FALSE
[17:41:18.042] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:18.042] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:18.053] Chunk #2 of 2 ... DONE
[17:41:18.054] Launching 2 futures (chunks) ... DONE
[17:41:18.054] Resolving 2 futures (chunks) ...
[17:41:18.054] resolve() on list ...
[17:41:18.054]  recursive: 0
[17:41:18.055]  length: 2
[17:41:18.055] 
[17:41:18.066] Future #2
[17:41:18.067] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:41:18.067] - nx: 2
[17:41:18.067] - relay: TRUE
[17:41:18.067] - stdout: TRUE
[17:41:18.068] - signal: TRUE
[17:41:18.068] - resignal: FALSE
[17:41:18.068] - force: TRUE
[17:41:18.068] - relayed: [n=2] FALSE, FALSE
[17:41:18.068] - queued futures: [n=2] FALSE, FALSE
[17:41:18.068]  - until=1
[17:41:18.069]  - relaying element #1
[17:41:18.069] - relayed: [n=2] FALSE, FALSE
[17:41:18.069] - queued futures: [n=2] FALSE, TRUE
[17:41:18.069] signalConditionsASAP(NULL, pos=2) ... done
[17:41:18.070]  length: 1 (resolved future 2)
[17:41:18.493] plan(): Setting new future strategy stack:
[17:41:18.494] List of future strategies:
[17:41:18.494] 1. multicore:
[17:41:18.494]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:18.494]    - tweaked: FALSE
[17:41:18.494]    - call: plan(strategy)
[17:41:18.499] plan(): nbrOfWorkers() = 2
[17:41:18.508] Future #1
[17:41:18.509] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:41:18.510] - nx: 2
[17:41:18.510] - relay: TRUE
[17:41:18.510] - stdout: TRUE
[17:41:18.510] - signal: TRUE
[17:41:18.510] - resignal: FALSE
[17:41:18.510] - force: TRUE
[17:41:18.510] - relayed: [n=2] FALSE, FALSE
[17:41:18.511] - queued futures: [n=2] FALSE, TRUE
[17:41:18.511]  - until=1
[17:41:18.511]  - relaying element #1
[17:41:18.511] - relayed: [n=2] TRUE, FALSE
[17:41:18.511] - queued futures: [n=2] TRUE, TRUE
[17:41:18.511] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:41:18.512]  length: 0 (resolved future 1)
[17:41:18.512] Relaying remaining futures
[17:41:18.512] signalConditionsASAP(NULL, pos=0) ...
[17:41:18.512] - nx: 2
[17:41:18.512] - relay: TRUE
[17:41:18.512] - stdout: TRUE
[17:41:18.513] - signal: TRUE
[17:41:18.513] - resignal: FALSE
[17:41:18.513] - force: TRUE
[17:41:18.513] - relayed: [n=2] TRUE, FALSE
[17:41:18.513] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:18.513]  - relaying element #2
[17:41:18.513] - relayed: [n=2] TRUE, TRUE
[17:41:18.514] - queued futures: [n=2] TRUE, TRUE
[17:41:18.514] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:41:18.514] resolve() on list ... DONE
[17:41:18.514]  - Number of value chunks collected: 2
[17:41:18.514] Resolving 2 futures (chunks) ... DONE
[17:41:18.514] Reducing values from 2 chunks ...
[17:41:18.514]  - Number of values collected after concatenation: 2
[17:41:18.514]  - Number of values expected: 2
[17:41:18.515] Reducing values from 2 chunks ... DONE
[17:41:18.515] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:41:18.515] future_mapply() ...
[17:41:18.519] Number of chunks: 2
[17:41:18.520] getGlobalsAndPackagesXApply() ...
[17:41:18.520]  - future.globals: TRUE
[17:41:18.520] getGlobalsAndPackages() ...
[17:41:18.520] Searching for globals...
[17:41:18.522] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:18.522] Searching for globals ... DONE
[17:41:18.522] Resolving globals: FALSE
[17:41:18.522] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:18.523] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:18.523] - globals: [1] ‘FUN’
[17:41:18.523] 
[17:41:18.523] getGlobalsAndPackages() ... DONE
[17:41:18.523]  - globals found/used: [n=1] ‘FUN’
[17:41:18.523]  - needed namespaces: [n=0] 
[17:41:18.524] Finding globals ... DONE
[17:41:18.524] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:18.524] List of 2
[17:41:18.524]  $ ...future.FUN:function (x, y)  
[17:41:18.524]  $ MoreArgs     : NULL
[17:41:18.524]  - attr(*, "where")=List of 2
[17:41:18.524]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:18.524]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:18.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:18.524]  - attr(*, "resolved")= logi FALSE
[17:41:18.524]  - attr(*, "total_size")= num NA
[17:41:18.527] Packages to be attached in all futures: [n=0] 
[17:41:18.527] getGlobalsAndPackagesXApply() ... DONE
[17:41:18.527] Number of futures (= number of chunks): 2
[17:41:18.527] Launching 2 futures (chunks) ...
[17:41:18.527] Chunk #1 of 2 ...
[17:41:18.527]  - Finding globals in '...' for chunk #1 ...
[17:41:18.528] getGlobalsAndPackages() ...
[17:41:18.528] Searching for globals...
[17:41:18.528] 
[17:41:18.528] Searching for globals ... DONE
[17:41:18.528] - globals: [0] <none>
[17:41:18.528] getGlobalsAndPackages() ... DONE
[17:41:18.528]    + additional globals found: [n=0] 
[17:41:18.528]    + additional namespaces needed: [n=0] 
[17:41:18.529]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:18.529]  - seeds: <none>
[17:41:18.529] getGlobalsAndPackages() ...
[17:41:18.529] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:18.529] Resolving globals: FALSE
[17:41:18.529] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:18.530] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:18.532] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:18.532] 
[17:41:18.532] getGlobalsAndPackages() ... DONE
[17:41:18.532] run() for ‘Future’ ...
[17:41:18.533] - state: ‘created’
[17:41:18.533] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:18.536] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:18.537] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:18.537]   - Field: ‘label’
[17:41:18.537]   - Field: ‘local’
[17:41:18.537]   - Field: ‘owner’
[17:41:18.537]   - Field: ‘envir’
[17:41:18.537]   - Field: ‘workers’
[17:41:18.537]   - Field: ‘packages’
[17:41:18.537]   - Field: ‘gc’
[17:41:18.538]   - Field: ‘job’
[17:41:18.538]   - Field: ‘conditions’
[17:41:18.538]   - Field: ‘expr’
[17:41:18.538]   - Field: ‘uuid’
[17:41:18.538]   - Field: ‘seed’
[17:41:18.538]   - Field: ‘version’
[17:41:18.538]   - Field: ‘result’
[17:41:18.538]   - Field: ‘asynchronous’
[17:41:18.538]   - Field: ‘calls’
[17:41:18.538]   - Field: ‘globals’
[17:41:18.539]   - Field: ‘stdout’
[17:41:18.539]   - Field: ‘earlySignal’
[17:41:18.539]   - Field: ‘lazy’
[17:41:18.539]   - Field: ‘state’
[17:41:18.539] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:18.539] - Launch lazy future ...
[17:41:18.539] Packages needed by the future expression (n = 0): <none>
[17:41:18.540] Packages needed by future strategies (n = 0): <none>
[17:41:18.540] {
[17:41:18.540]     {
[17:41:18.540]         {
[17:41:18.540]             ...future.startTime <- base::Sys.time()
[17:41:18.540]             {
[17:41:18.540]                 {
[17:41:18.540]                   {
[17:41:18.540]                     {
[17:41:18.540]                       base::local({
[17:41:18.540]                         has_future <- base::requireNamespace("future", 
[17:41:18.540]                           quietly = TRUE)
[17:41:18.540]                         if (has_future) {
[17:41:18.540]                           ns <- base::getNamespace("future")
[17:41:18.540]                           version <- ns[[".package"]][["version"]]
[17:41:18.540]                           if (is.null(version)) 
[17:41:18.540]                             version <- utils::packageVersion("future")
[17:41:18.540]                         }
[17:41:18.540]                         else {
[17:41:18.540]                           version <- NULL
[17:41:18.540]                         }
[17:41:18.540]                         if (!has_future || version < "1.8.0") {
[17:41:18.540]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:18.540]                             "", base::R.version$version.string), 
[17:41:18.540]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:18.540]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:18.540]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:18.540]                               "release", "version")], collapse = " "), 
[17:41:18.540]                             hostname = base::Sys.info()[["nodename"]])
[17:41:18.540]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:18.540]                             info)
[17:41:18.540]                           info <- base::paste(info, collapse = "; ")
[17:41:18.540]                           if (!has_future) {
[17:41:18.540]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:18.540]                               info)
[17:41:18.540]                           }
[17:41:18.540]                           else {
[17:41:18.540]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:18.540]                               info, version)
[17:41:18.540]                           }
[17:41:18.540]                           base::stop(msg)
[17:41:18.540]                         }
[17:41:18.540]                       })
[17:41:18.540]                     }
[17:41:18.540]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:18.540]                     base::options(mc.cores = 1L)
[17:41:18.540]                   }
[17:41:18.540]                   options(future.plan = NULL)
[17:41:18.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:18.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:18.540]                 }
[17:41:18.540]                 ...future.workdir <- getwd()
[17:41:18.540]             }
[17:41:18.540]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:18.540]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:18.540]         }
[17:41:18.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:18.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:18.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:18.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:18.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:18.540]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:18.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:18.540]             base::names(...future.oldOptions))
[17:41:18.540]     }
[17:41:18.540]     if (TRUE) {
[17:41:18.540]     }
[17:41:18.540]     else {
[17:41:18.540]         if (NA) {
[17:41:18.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:18.540]                 open = "w")
[17:41:18.540]         }
[17:41:18.540]         else {
[17:41:18.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:18.540]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:18.540]         }
[17:41:18.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:18.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:18.540]             base::sink(type = "output", split = FALSE)
[17:41:18.540]             base::close(...future.stdout)
[17:41:18.540]         }, add = TRUE)
[17:41:18.540]     }
[17:41:18.540]     ...future.frame <- base::sys.nframe()
[17:41:18.540]     ...future.conditions <- base::list()
[17:41:18.540]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:18.540]     if (FALSE) {
[17:41:18.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:18.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:18.540]     }
[17:41:18.540]     ...future.result <- base::tryCatch({
[17:41:18.540]         base::withCallingHandlers({
[17:41:18.540]             ...future.value <- base::withVisible(base::local({
[17:41:18.540]                 withCallingHandlers({
[17:41:18.540]                   {
[17:41:18.540]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:18.540]                     if (!identical(...future.globals.maxSize.org, 
[17:41:18.540]                       ...future.globals.maxSize)) {
[17:41:18.540]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:18.540]                       on.exit(options(oopts), add = TRUE)
[17:41:18.540]                     }
[17:41:18.540]                     {
[17:41:18.540]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:18.540]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:18.540]                         USE.NAMES = FALSE)
[17:41:18.540]                       do.call(mapply, args = args)
[17:41:18.540]                     }
[17:41:18.540]                   }
[17:41:18.540]                 }, immediateCondition = function(cond) {
[17:41:18.540]                   save_rds <- function (object, pathname, ...) 
[17:41:18.540]                   {
[17:41:18.540]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:18.540]                     if (file_test("-f", pathname_tmp)) {
[17:41:18.540]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.540]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:18.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.540]                         fi_tmp[["mtime"]])
[17:41:18.540]                     }
[17:41:18.540]                     tryCatch({
[17:41:18.540]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:18.540]                     }, error = function(ex) {
[17:41:18.540]                       msg <- conditionMessage(ex)
[17:41:18.540]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.540]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:18.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.540]                         fi_tmp[["mtime"]], msg)
[17:41:18.540]                       ex$message <- msg
[17:41:18.540]                       stop(ex)
[17:41:18.540]                     })
[17:41:18.540]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:18.540]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:18.540]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:18.540]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.540]                       fi <- file.info(pathname)
[17:41:18.540]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:18.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.540]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:18.540]                         fi[["size"]], fi[["mtime"]])
[17:41:18.540]                       stop(msg)
[17:41:18.540]                     }
[17:41:18.540]                     invisible(pathname)
[17:41:18.540]                   }
[17:41:18.540]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:18.540]                     rootPath = tempdir()) 
[17:41:18.540]                   {
[17:41:18.540]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:18.540]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:18.540]                       tmpdir = path, fileext = ".rds")
[17:41:18.540]                     save_rds(obj, file)
[17:41:18.540]                   }
[17:41:18.540]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:18.540]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.540]                   {
[17:41:18.540]                     inherits <- base::inherits
[17:41:18.540]                     invokeRestart <- base::invokeRestart
[17:41:18.540]                     is.null <- base::is.null
[17:41:18.540]                     muffled <- FALSE
[17:41:18.540]                     if (inherits(cond, "message")) {
[17:41:18.540]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:18.540]                       if (muffled) 
[17:41:18.540]                         invokeRestart("muffleMessage")
[17:41:18.540]                     }
[17:41:18.540]                     else if (inherits(cond, "warning")) {
[17:41:18.540]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:18.540]                       if (muffled) 
[17:41:18.540]                         invokeRestart("muffleWarning")
[17:41:18.540]                     }
[17:41:18.540]                     else if (inherits(cond, "condition")) {
[17:41:18.540]                       if (!is.null(pattern)) {
[17:41:18.540]                         computeRestarts <- base::computeRestarts
[17:41:18.540]                         grepl <- base::grepl
[17:41:18.540]                         restarts <- computeRestarts(cond)
[17:41:18.540]                         for (restart in restarts) {
[17:41:18.540]                           name <- restart$name
[17:41:18.540]                           if (is.null(name)) 
[17:41:18.540]                             next
[17:41:18.540]                           if (!grepl(pattern, name)) 
[17:41:18.540]                             next
[17:41:18.540]                           invokeRestart(restart)
[17:41:18.540]                           muffled <- TRUE
[17:41:18.540]                           break
[17:41:18.540]                         }
[17:41:18.540]                       }
[17:41:18.540]                     }
[17:41:18.540]                     invisible(muffled)
[17:41:18.540]                   }
[17:41:18.540]                   muffleCondition(cond)
[17:41:18.540]                 })
[17:41:18.540]             }))
[17:41:18.540]             future::FutureResult(value = ...future.value$value, 
[17:41:18.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:18.540]                   ...future.rng), globalenv = if (FALSE) 
[17:41:18.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:18.540]                     ...future.globalenv.names))
[17:41:18.540]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:18.540]         }, condition = base::local({
[17:41:18.540]             c <- base::c
[17:41:18.540]             inherits <- base::inherits
[17:41:18.540]             invokeRestart <- base::invokeRestart
[17:41:18.540]             length <- base::length
[17:41:18.540]             list <- base::list
[17:41:18.540]             seq.int <- base::seq.int
[17:41:18.540]             signalCondition <- base::signalCondition
[17:41:18.540]             sys.calls <- base::sys.calls
[17:41:18.540]             `[[` <- base::`[[`
[17:41:18.540]             `+` <- base::`+`
[17:41:18.540]             `<<-` <- base::`<<-`
[17:41:18.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:18.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:18.540]                   3L)]
[17:41:18.540]             }
[17:41:18.540]             function(cond) {
[17:41:18.540]                 is_error <- inherits(cond, "error")
[17:41:18.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:18.540]                   NULL)
[17:41:18.540]                 if (is_error) {
[17:41:18.540]                   sessionInformation <- function() {
[17:41:18.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:18.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:18.540]                       search = base::search(), system = base::Sys.info())
[17:41:18.540]                   }
[17:41:18.540]                   ...future.conditions[[length(...future.conditions) + 
[17:41:18.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:18.540]                     cond$call), session = sessionInformation(), 
[17:41:18.540]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:18.540]                   signalCondition(cond)
[17:41:18.540]                 }
[17:41:18.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:18.540]                 "immediateCondition"))) {
[17:41:18.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:18.540]                   ...future.conditions[[length(...future.conditions) + 
[17:41:18.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:18.540]                   if (TRUE && !signal) {
[17:41:18.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.540]                     {
[17:41:18.540]                       inherits <- base::inherits
[17:41:18.540]                       invokeRestart <- base::invokeRestart
[17:41:18.540]                       is.null <- base::is.null
[17:41:18.540]                       muffled <- FALSE
[17:41:18.540]                       if (inherits(cond, "message")) {
[17:41:18.540]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:18.540]                         if (muffled) 
[17:41:18.540]                           invokeRestart("muffleMessage")
[17:41:18.540]                       }
[17:41:18.540]                       else if (inherits(cond, "warning")) {
[17:41:18.540]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:18.540]                         if (muffled) 
[17:41:18.540]                           invokeRestart("muffleWarning")
[17:41:18.540]                       }
[17:41:18.540]                       else if (inherits(cond, "condition")) {
[17:41:18.540]                         if (!is.null(pattern)) {
[17:41:18.540]                           computeRestarts <- base::computeRestarts
[17:41:18.540]                           grepl <- base::grepl
[17:41:18.540]                           restarts <- computeRestarts(cond)
[17:41:18.540]                           for (restart in restarts) {
[17:41:18.540]                             name <- restart$name
[17:41:18.540]                             if (is.null(name)) 
[17:41:18.540]                               next
[17:41:18.540]                             if (!grepl(pattern, name)) 
[17:41:18.540]                               next
[17:41:18.540]                             invokeRestart(restart)
[17:41:18.540]                             muffled <- TRUE
[17:41:18.540]                             break
[17:41:18.540]                           }
[17:41:18.540]                         }
[17:41:18.540]                       }
[17:41:18.540]                       invisible(muffled)
[17:41:18.540]                     }
[17:41:18.540]                     muffleCondition(cond, pattern = "^muffle")
[17:41:18.540]                   }
[17:41:18.540]                 }
[17:41:18.540]                 else {
[17:41:18.540]                   if (TRUE) {
[17:41:18.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.540]                     {
[17:41:18.540]                       inherits <- base::inherits
[17:41:18.540]                       invokeRestart <- base::invokeRestart
[17:41:18.540]                       is.null <- base::is.null
[17:41:18.540]                       muffled <- FALSE
[17:41:18.540]                       if (inherits(cond, "message")) {
[17:41:18.540]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:18.540]                         if (muffled) 
[17:41:18.540]                           invokeRestart("muffleMessage")
[17:41:18.540]                       }
[17:41:18.540]                       else if (inherits(cond, "warning")) {
[17:41:18.540]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:18.540]                         if (muffled) 
[17:41:18.540]                           invokeRestart("muffleWarning")
[17:41:18.540]                       }
[17:41:18.540]                       else if (inherits(cond, "condition")) {
[17:41:18.540]                         if (!is.null(pattern)) {
[17:41:18.540]                           computeRestarts <- base::computeRestarts
[17:41:18.540]                           grepl <- base::grepl
[17:41:18.540]                           restarts <- computeRestarts(cond)
[17:41:18.540]                           for (restart in restarts) {
[17:41:18.540]                             name <- restart$name
[17:41:18.540]                             if (is.null(name)) 
[17:41:18.540]                               next
[17:41:18.540]                             if (!grepl(pattern, name)) 
[17:41:18.540]                               next
[17:41:18.540]                             invokeRestart(restart)
[17:41:18.540]                             muffled <- TRUE
[17:41:18.540]                             break
[17:41:18.540]                           }
[17:41:18.540]                         }
[17:41:18.540]                       }
[17:41:18.540]                       invisible(muffled)
[17:41:18.540]                     }
[17:41:18.540]                     muffleCondition(cond, pattern = "^muffle")
[17:41:18.540]                   }
[17:41:18.540]                 }
[17:41:18.540]             }
[17:41:18.540]         }))
[17:41:18.540]     }, error = function(ex) {
[17:41:18.540]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:18.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:18.540]                 ...future.rng), started = ...future.startTime, 
[17:41:18.540]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:18.540]             version = "1.8"), class = "FutureResult")
[17:41:18.540]     }, finally = {
[17:41:18.540]         if (!identical(...future.workdir, getwd())) 
[17:41:18.540]             setwd(...future.workdir)
[17:41:18.540]         {
[17:41:18.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:18.540]                 ...future.oldOptions$nwarnings <- NULL
[17:41:18.540]             }
[17:41:18.540]             base::options(...future.oldOptions)
[17:41:18.540]             if (.Platform$OS.type == "windows") {
[17:41:18.540]                 old_names <- names(...future.oldEnvVars)
[17:41:18.540]                 envs <- base::Sys.getenv()
[17:41:18.540]                 names <- names(envs)
[17:41:18.540]                 common <- intersect(names, old_names)
[17:41:18.540]                 added <- setdiff(names, old_names)
[17:41:18.540]                 removed <- setdiff(old_names, names)
[17:41:18.540]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:18.540]                   envs[common]]
[17:41:18.540]                 NAMES <- toupper(changed)
[17:41:18.540]                 args <- list()
[17:41:18.540]                 for (kk in seq_along(NAMES)) {
[17:41:18.540]                   name <- changed[[kk]]
[17:41:18.540]                   NAME <- NAMES[[kk]]
[17:41:18.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.540]                     next
[17:41:18.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:18.540]                 }
[17:41:18.540]                 NAMES <- toupper(added)
[17:41:18.540]                 for (kk in seq_along(NAMES)) {
[17:41:18.540]                   name <- added[[kk]]
[17:41:18.540]                   NAME <- NAMES[[kk]]
[17:41:18.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.540]                     next
[17:41:18.540]                   args[[name]] <- ""
[17:41:18.540]                 }
[17:41:18.540]                 NAMES <- toupper(removed)
[17:41:18.540]                 for (kk in seq_along(NAMES)) {
[17:41:18.540]                   name <- removed[[kk]]
[17:41:18.540]                   NAME <- NAMES[[kk]]
[17:41:18.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.540]                     next
[17:41:18.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:18.540]                 }
[17:41:18.540]                 if (length(args) > 0) 
[17:41:18.540]                   base::do.call(base::Sys.setenv, args = args)
[17:41:18.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:18.540]             }
[17:41:18.540]             else {
[17:41:18.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:18.540]             }
[17:41:18.540]             {
[17:41:18.540]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:18.540]                   0L) {
[17:41:18.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:18.540]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:18.540]                   base::options(opts)
[17:41:18.540]                 }
[17:41:18.540]                 {
[17:41:18.540]                   {
[17:41:18.540]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:18.540]                     NULL
[17:41:18.540]                   }
[17:41:18.540]                   options(future.plan = NULL)
[17:41:18.540]                   if (is.na(NA_character_)) 
[17:41:18.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:18.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:18.540]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:18.540]                     envir = parent.frame()) 
[17:41:18.540]                   {
[17:41:18.540]                     default_workers <- missing(workers)
[17:41:18.540]                     if (is.function(workers)) 
[17:41:18.540]                       workers <- workers()
[17:41:18.540]                     workers <- structure(as.integer(workers), 
[17:41:18.540]                       class = class(workers))
[17:41:18.540]                     stop_if_not(is.finite(workers), workers >= 
[17:41:18.540]                       1L)
[17:41:18.540]                     if ((workers == 1L && !inherits(workers, 
[17:41:18.540]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:18.540]                       if (default_workers) 
[17:41:18.540]                         supportsMulticore(warn = TRUE)
[17:41:18.540]                       return(sequential(..., envir = envir))
[17:41:18.540]                     }
[17:41:18.540]                     oopts <- options(mc.cores = workers)
[17:41:18.540]                     on.exit(options(oopts))
[17:41:18.540]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:18.540]                       envir = envir)
[17:41:18.540]                     if (!future$lazy) 
[17:41:18.540]                       future <- run(future)
[17:41:18.540]                     invisible(future)
[17:41:18.540]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:18.540]                 }
[17:41:18.540]             }
[17:41:18.540]         }
[17:41:18.540]     })
[17:41:18.540]     if (FALSE) {
[17:41:18.540]         base::sink(type = "output", split = FALSE)
[17:41:18.540]         if (NA) {
[17:41:18.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:18.540]         }
[17:41:18.540]         else {
[17:41:18.540]             ...future.result["stdout"] <- base::list(NULL)
[17:41:18.540]         }
[17:41:18.540]         base::close(...future.stdout)
[17:41:18.540]         ...future.stdout <- NULL
[17:41:18.540]     }
[17:41:18.540]     ...future.result$conditions <- ...future.conditions
[17:41:18.540]     ...future.result$finished <- base::Sys.time()
[17:41:18.540]     ...future.result
[17:41:18.540] }
[17:41:18.543] assign_globals() ...
[17:41:18.543] List of 5
[17:41:18.543]  $ ...future.FUN            :function (x, y)  
[17:41:18.543]  $ MoreArgs                 : NULL
[17:41:18.543]  $ ...future.elements_ii    :List of 2
[17:41:18.543]   ..$ :List of 1
[17:41:18.543]   .. ..$ : int 1
[17:41:18.543]   ..$ :List of 1
[17:41:18.543]   .. ..$ : int 0
[17:41:18.543]  $ ...future.seeds_ii       : NULL
[17:41:18.543]  $ ...future.globals.maxSize: NULL
[17:41:18.543]  - attr(*, "where")=List of 5
[17:41:18.543]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:18.543]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:18.543]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:18.543]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:18.543]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:18.543]  - attr(*, "resolved")= logi FALSE
[17:41:18.543]  - attr(*, "total_size")= num 6368
[17:41:18.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:18.543]  - attr(*, "already-done")= logi TRUE
[17:41:18.548] - reassign environment for ‘...future.FUN’
[17:41:18.548] - copied ‘...future.FUN’ to environment
[17:41:18.548] - copied ‘MoreArgs’ to environment
[17:41:18.548] - copied ‘...future.elements_ii’ to environment
[17:41:18.548] - copied ‘...future.seeds_ii’ to environment
[17:41:18.548] - copied ‘...future.globals.maxSize’ to environment
[17:41:18.548] assign_globals() ... done
[17:41:18.549] requestCore(): workers = 2
[17:41:18.551] MulticoreFuture started
[17:41:18.551] - Launch lazy future ... done
[17:41:18.551] run() for ‘MulticoreFuture’ ... done
[17:41:18.551] Created future:
[17:41:18.552] plan(): Setting new future strategy stack:
[17:41:18.552] List of future strategies:
[17:41:18.552] 1. sequential:
[17:41:18.552]    - args: function (..., envir = parent.frame())
[17:41:18.552]    - tweaked: FALSE
[17:41:18.552]    - call: NULL
[17:41:18.553] plan(): nbrOfWorkers() = 1
[17:41:18.552] MulticoreFuture:
[17:41:18.552] Label: ‘future_mapply-1’
[17:41:18.552] Expression:
[17:41:18.552] {
[17:41:18.552]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:18.552]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:18.552]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:18.552]         on.exit(options(oopts), add = TRUE)
[17:41:18.552]     }
[17:41:18.552]     {
[17:41:18.552]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:18.552]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:18.552]         do.call(mapply, args = args)
[17:41:18.552]     }
[17:41:18.552] }
[17:41:18.552] Lazy evaluation: FALSE
[17:41:18.552] Asynchronous evaluation: TRUE
[17:41:18.552] Local evaluation: TRUE
[17:41:18.552] Environment: R_GlobalEnv
[17:41:18.552] Capture standard output: NA
[17:41:18.552] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:18.552] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:18.552] Packages: <none>
[17:41:18.552] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:18.552] Resolved: FALSE
[17:41:18.552] Value: <not collected>
[17:41:18.552] Conditions captured: <none>
[17:41:18.552] Early signaling: FALSE
[17:41:18.552] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:18.552] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:18.564] Chunk #1 of 2 ... DONE
[17:41:18.564] Chunk #2 of 2 ...
[17:41:18.564]  - Finding globals in '...' for chunk #2 ...
[17:41:18.565] getGlobalsAndPackages() ...
[17:41:18.565] Searching for globals...
[17:41:18.565] 
[17:41:18.566] Searching for globals ... DONE
[17:41:18.566] - globals: [0] <none>
[17:41:18.566] getGlobalsAndPackages() ... DONE
[17:41:18.566]    + additional globals found: [n=0] 
[17:41:18.566]    + additional namespaces needed: [n=0] 
[17:41:18.566]  - Finding globals in '...' for chunk #2 ... DONE
[17:41:18.566]  - seeds: <none>
[17:41:18.567] getGlobalsAndPackages() ...
[17:41:18.567] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:18.567] Resolving globals: FALSE
[17:41:18.568] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:18.569] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:18.569] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:18.569] 
[17:41:18.569] getGlobalsAndPackages() ... DONE
[17:41:18.570] run() for ‘Future’ ...
[17:41:18.570] - state: ‘created’
[17:41:18.570] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:18.575] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:18.575] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:18.576]   - Field: ‘label’
[17:41:18.576]   - Field: ‘local’
[17:41:18.576]   - Field: ‘owner’
[17:41:18.576]   - Field: ‘envir’
[17:41:18.576]   - Field: ‘workers’
[17:41:18.576]   - Field: ‘packages’
[17:41:18.576]   - Field: ‘gc’
[17:41:18.577]   - Field: ‘job’
[17:41:18.577]   - Field: ‘conditions’
[17:41:18.577]   - Field: ‘expr’
[17:41:18.577]   - Field: ‘uuid’
[17:41:18.577]   - Field: ‘seed’
[17:41:18.577]   - Field: ‘version’
[17:41:18.577]   - Field: ‘result’
[17:41:18.578]   - Field: ‘asynchronous’
[17:41:18.578]   - Field: ‘calls’
[17:41:18.578]   - Field: ‘globals’
[17:41:18.578]   - Field: ‘stdout’
[17:41:18.578]   - Field: ‘earlySignal’
[17:41:18.578]   - Field: ‘lazy’
[17:41:18.578]   - Field: ‘state’
[17:41:18.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:18.579] - Launch lazy future ...
[17:41:18.579] Packages needed by the future expression (n = 0): <none>
[17:41:18.579] Packages needed by future strategies (n = 0): <none>
[17:41:18.580] {
[17:41:18.580]     {
[17:41:18.580]         {
[17:41:18.580]             ...future.startTime <- base::Sys.time()
[17:41:18.580]             {
[17:41:18.580]                 {
[17:41:18.580]                   {
[17:41:18.580]                     {
[17:41:18.580]                       base::local({
[17:41:18.580]                         has_future <- base::requireNamespace("future", 
[17:41:18.580]                           quietly = TRUE)
[17:41:18.580]                         if (has_future) {
[17:41:18.580]                           ns <- base::getNamespace("future")
[17:41:18.580]                           version <- ns[[".package"]][["version"]]
[17:41:18.580]                           if (is.null(version)) 
[17:41:18.580]                             version <- utils::packageVersion("future")
[17:41:18.580]                         }
[17:41:18.580]                         else {
[17:41:18.580]                           version <- NULL
[17:41:18.580]                         }
[17:41:18.580]                         if (!has_future || version < "1.8.0") {
[17:41:18.580]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:18.580]                             "", base::R.version$version.string), 
[17:41:18.580]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:18.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:18.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:18.580]                               "release", "version")], collapse = " "), 
[17:41:18.580]                             hostname = base::Sys.info()[["nodename"]])
[17:41:18.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:18.580]                             info)
[17:41:18.580]                           info <- base::paste(info, collapse = "; ")
[17:41:18.580]                           if (!has_future) {
[17:41:18.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:18.580]                               info)
[17:41:18.580]                           }
[17:41:18.580]                           else {
[17:41:18.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:18.580]                               info, version)
[17:41:18.580]                           }
[17:41:18.580]                           base::stop(msg)
[17:41:18.580]                         }
[17:41:18.580]                       })
[17:41:18.580]                     }
[17:41:18.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:18.580]                     base::options(mc.cores = 1L)
[17:41:18.580]                   }
[17:41:18.580]                   options(future.plan = NULL)
[17:41:18.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:18.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:18.580]                 }
[17:41:18.580]                 ...future.workdir <- getwd()
[17:41:18.580]             }
[17:41:18.580]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:18.580]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:18.580]         }
[17:41:18.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:18.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:18.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:18.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:18.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:18.580]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:18.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:18.580]             base::names(...future.oldOptions))
[17:41:18.580]     }
[17:41:18.580]     if (TRUE) {
[17:41:18.580]     }
[17:41:18.580]     else {
[17:41:18.580]         if (NA) {
[17:41:18.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:18.580]                 open = "w")
[17:41:18.580]         }
[17:41:18.580]         else {
[17:41:18.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:18.580]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:18.580]         }
[17:41:18.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:18.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:18.580]             base::sink(type = "output", split = FALSE)
[17:41:18.580]             base::close(...future.stdout)
[17:41:18.580]         }, add = TRUE)
[17:41:18.580]     }
[17:41:18.580]     ...future.frame <- base::sys.nframe()
[17:41:18.580]     ...future.conditions <- base::list()
[17:41:18.580]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:18.580]     if (FALSE) {
[17:41:18.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:18.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:18.580]     }
[17:41:18.580]     ...future.result <- base::tryCatch({
[17:41:18.580]         base::withCallingHandlers({
[17:41:18.580]             ...future.value <- base::withVisible(base::local({
[17:41:18.580]                 withCallingHandlers({
[17:41:18.580]                   {
[17:41:18.580]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:18.580]                     if (!identical(...future.globals.maxSize.org, 
[17:41:18.580]                       ...future.globals.maxSize)) {
[17:41:18.580]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:18.580]                       on.exit(options(oopts), add = TRUE)
[17:41:18.580]                     }
[17:41:18.580]                     {
[17:41:18.580]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:18.580]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:18.580]                         USE.NAMES = FALSE)
[17:41:18.580]                       do.call(mapply, args = args)
[17:41:18.580]                     }
[17:41:18.580]                   }
[17:41:18.580]                 }, immediateCondition = function(cond) {
[17:41:18.580]                   save_rds <- function (object, pathname, ...) 
[17:41:18.580]                   {
[17:41:18.580]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:18.580]                     if (file_test("-f", pathname_tmp)) {
[17:41:18.580]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.580]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:18.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.580]                         fi_tmp[["mtime"]])
[17:41:18.580]                     }
[17:41:18.580]                     tryCatch({
[17:41:18.580]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:18.580]                     }, error = function(ex) {
[17:41:18.580]                       msg <- conditionMessage(ex)
[17:41:18.580]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.580]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:18.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.580]                         fi_tmp[["mtime"]], msg)
[17:41:18.580]                       ex$message <- msg
[17:41:18.580]                       stop(ex)
[17:41:18.580]                     })
[17:41:18.580]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:18.580]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:18.580]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:18.580]                       fi_tmp <- file.info(pathname_tmp)
[17:41:18.580]                       fi <- file.info(pathname)
[17:41:18.580]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:18.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:18.580]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:18.580]                         fi[["size"]], fi[["mtime"]])
[17:41:18.580]                       stop(msg)
[17:41:18.580]                     }
[17:41:18.580]                     invisible(pathname)
[17:41:18.580]                   }
[17:41:18.580]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:18.580]                     rootPath = tempdir()) 
[17:41:18.580]                   {
[17:41:18.580]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:18.580]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:18.580]                       tmpdir = path, fileext = ".rds")
[17:41:18.580]                     save_rds(obj, file)
[17:41:18.580]                   }
[17:41:18.580]                   saveImmediateCondition(cond, path = "/tmp/RtmpsPTK8O/.future/immediateConditions")
[17:41:18.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.580]                   {
[17:41:18.580]                     inherits <- base::inherits
[17:41:18.580]                     invokeRestart <- base::invokeRestart
[17:41:18.580]                     is.null <- base::is.null
[17:41:18.580]                     muffled <- FALSE
[17:41:18.580]                     if (inherits(cond, "message")) {
[17:41:18.580]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:18.580]                       if (muffled) 
[17:41:18.580]                         invokeRestart("muffleMessage")
[17:41:18.580]                     }
[17:41:18.580]                     else if (inherits(cond, "warning")) {
[17:41:18.580]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:18.580]                       if (muffled) 
[17:41:18.580]                         invokeRestart("muffleWarning")
[17:41:18.580]                     }
[17:41:18.580]                     else if (inherits(cond, "condition")) {
[17:41:18.580]                       if (!is.null(pattern)) {
[17:41:18.580]                         computeRestarts <- base::computeRestarts
[17:41:18.580]                         grepl <- base::grepl
[17:41:18.580]                         restarts <- computeRestarts(cond)
[17:41:18.580]                         for (restart in restarts) {
[17:41:18.580]                           name <- restart$name
[17:41:18.580]                           if (is.null(name)) 
[17:41:18.580]                             next
[17:41:18.580]                           if (!grepl(pattern, name)) 
[17:41:18.580]                             next
[17:41:18.580]                           invokeRestart(restart)
[17:41:18.580]                           muffled <- TRUE
[17:41:18.580]                           break
[17:41:18.580]                         }
[17:41:18.580]                       }
[17:41:18.580]                     }
[17:41:18.580]                     invisible(muffled)
[17:41:18.580]                   }
[17:41:18.580]                   muffleCondition(cond)
[17:41:18.580]                 })
[17:41:18.580]             }))
[17:41:18.580]             future::FutureResult(value = ...future.value$value, 
[17:41:18.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:18.580]                   ...future.rng), globalenv = if (FALSE) 
[17:41:18.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:18.580]                     ...future.globalenv.names))
[17:41:18.580]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:18.580]         }, condition = base::local({
[17:41:18.580]             c <- base::c
[17:41:18.580]             inherits <- base::inherits
[17:41:18.580]             invokeRestart <- base::invokeRestart
[17:41:18.580]             length <- base::length
[17:41:18.580]             list <- base::list
[17:41:18.580]             seq.int <- base::seq.int
[17:41:18.580]             signalCondition <- base::signalCondition
[17:41:18.580]             sys.calls <- base::sys.calls
[17:41:18.580]             `[[` <- base::`[[`
[17:41:18.580]             `+` <- base::`+`
[17:41:18.580]             `<<-` <- base::`<<-`
[17:41:18.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:18.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:18.580]                   3L)]
[17:41:18.580]             }
[17:41:18.580]             function(cond) {
[17:41:18.580]                 is_error <- inherits(cond, "error")
[17:41:18.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:18.580]                   NULL)
[17:41:18.580]                 if (is_error) {
[17:41:18.580]                   sessionInformation <- function() {
[17:41:18.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:18.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:18.580]                       search = base::search(), system = base::Sys.info())
[17:41:18.580]                   }
[17:41:18.580]                   ...future.conditions[[length(...future.conditions) + 
[17:41:18.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:18.580]                     cond$call), session = sessionInformation(), 
[17:41:18.580]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:18.580]                   signalCondition(cond)
[17:41:18.580]                 }
[17:41:18.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:18.580]                 "immediateCondition"))) {
[17:41:18.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:18.580]                   ...future.conditions[[length(...future.conditions) + 
[17:41:18.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:18.580]                   if (TRUE && !signal) {
[17:41:18.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.580]                     {
[17:41:18.580]                       inherits <- base::inherits
[17:41:18.580]                       invokeRestart <- base::invokeRestart
[17:41:18.580]                       is.null <- base::is.null
[17:41:18.580]                       muffled <- FALSE
[17:41:18.580]                       if (inherits(cond, "message")) {
[17:41:18.580]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:18.580]                         if (muffled) 
[17:41:18.580]                           invokeRestart("muffleMessage")
[17:41:18.580]                       }
[17:41:18.580]                       else if (inherits(cond, "warning")) {
[17:41:18.580]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:18.580]                         if (muffled) 
[17:41:18.580]                           invokeRestart("muffleWarning")
[17:41:18.580]                       }
[17:41:18.580]                       else if (inherits(cond, "condition")) {
[17:41:18.580]                         if (!is.null(pattern)) {
[17:41:18.580]                           computeRestarts <- base::computeRestarts
[17:41:18.580]                           grepl <- base::grepl
[17:41:18.580]                           restarts <- computeRestarts(cond)
[17:41:18.580]                           for (restart in restarts) {
[17:41:18.580]                             name <- restart$name
[17:41:18.580]                             if (is.null(name)) 
[17:41:18.580]                               next
[17:41:18.580]                             if (!grepl(pattern, name)) 
[17:41:18.580]                               next
[17:41:18.580]                             invokeRestart(restart)
[17:41:18.580]                             muffled <- TRUE
[17:41:18.580]                             break
[17:41:18.580]                           }
[17:41:18.580]                         }
[17:41:18.580]                       }
[17:41:18.580]                       invisible(muffled)
[17:41:18.580]                     }
[17:41:18.580]                     muffleCondition(cond, pattern = "^muffle")
[17:41:18.580]                   }
[17:41:18.580]                 }
[17:41:18.580]                 else {
[17:41:18.580]                   if (TRUE) {
[17:41:18.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:18.580]                     {
[17:41:18.580]                       inherits <- base::inherits
[17:41:18.580]                       invokeRestart <- base::invokeRestart
[17:41:18.580]                       is.null <- base::is.null
[17:41:18.580]                       muffled <- FALSE
[17:41:18.580]                       if (inherits(cond, "message")) {
[17:41:18.580]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:18.580]                         if (muffled) 
[17:41:18.580]                           invokeRestart("muffleMessage")
[17:41:18.580]                       }
[17:41:18.580]                       else if (inherits(cond, "warning")) {
[17:41:18.580]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:18.580]                         if (muffled) 
[17:41:18.580]                           invokeRestart("muffleWarning")
[17:41:18.580]                       }
[17:41:18.580]                       else if (inherits(cond, "condition")) {
[17:41:18.580]                         if (!is.null(pattern)) {
[17:41:18.580]                           computeRestarts <- base::computeRestarts
[17:41:18.580]                           grepl <- base::grepl
[17:41:18.580]                           restarts <- computeRestarts(cond)
[17:41:18.580]                           for (restart in restarts) {
[17:41:18.580]                             name <- restart$name
[17:41:18.580]                             if (is.null(name)) 
[17:41:18.580]                               next
[17:41:18.580]                             if (!grepl(pattern, name)) 
[17:41:18.580]                               next
[17:41:18.580]                             invokeRestart(restart)
[17:41:18.580]                             muffled <- TRUE
[17:41:18.580]                             break
[17:41:18.580]                           }
[17:41:18.580]                         }
[17:41:18.580]                       }
[17:41:18.580]                       invisible(muffled)
[17:41:18.580]                     }
[17:41:18.580]                     muffleCondition(cond, pattern = "^muffle")
[17:41:18.580]                   }
[17:41:18.580]                 }
[17:41:18.580]             }
[17:41:18.580]         }))
[17:41:18.580]     }, error = function(ex) {
[17:41:18.580]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:18.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:18.580]                 ...future.rng), started = ...future.startTime, 
[17:41:18.580]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:18.580]             version = "1.8"), class = "FutureResult")
[17:41:18.580]     }, finally = {
[17:41:18.580]         if (!identical(...future.workdir, getwd())) 
[17:41:18.580]             setwd(...future.workdir)
[17:41:18.580]         {
[17:41:18.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:18.580]                 ...future.oldOptions$nwarnings <- NULL
[17:41:18.580]             }
[17:41:18.580]             base::options(...future.oldOptions)
[17:41:18.580]             if (.Platform$OS.type == "windows") {
[17:41:18.580]                 old_names <- names(...future.oldEnvVars)
[17:41:18.580]                 envs <- base::Sys.getenv()
[17:41:18.580]                 names <- names(envs)
[17:41:18.580]                 common <- intersect(names, old_names)
[17:41:18.580]                 added <- setdiff(names, old_names)
[17:41:18.580]                 removed <- setdiff(old_names, names)
[17:41:18.580]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:18.580]                   envs[common]]
[17:41:18.580]                 NAMES <- toupper(changed)
[17:41:18.580]                 args <- list()
[17:41:18.580]                 for (kk in seq_along(NAMES)) {
[17:41:18.580]                   name <- changed[[kk]]
[17:41:18.580]                   NAME <- NAMES[[kk]]
[17:41:18.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.580]                     next
[17:41:18.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:18.580]                 }
[17:41:18.580]                 NAMES <- toupper(added)
[17:41:18.580]                 for (kk in seq_along(NAMES)) {
[17:41:18.580]                   name <- added[[kk]]
[17:41:18.580]                   NAME <- NAMES[[kk]]
[17:41:18.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.580]                     next
[17:41:18.580]                   args[[name]] <- ""
[17:41:18.580]                 }
[17:41:18.580]                 NAMES <- toupper(removed)
[17:41:18.580]                 for (kk in seq_along(NAMES)) {
[17:41:18.580]                   name <- removed[[kk]]
[17:41:18.580]                   NAME <- NAMES[[kk]]
[17:41:18.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:18.580]                     next
[17:41:18.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:18.580]                 }
[17:41:18.580]                 if (length(args) > 0) 
[17:41:18.580]                   base::do.call(base::Sys.setenv, args = args)
[17:41:18.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:18.580]             }
[17:41:18.580]             else {
[17:41:18.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:18.580]             }
[17:41:18.580]             {
[17:41:18.580]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:18.580]                   0L) {
[17:41:18.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:18.580]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:18.580]                   base::options(opts)
[17:41:18.580]                 }
[17:41:18.580]                 {
[17:41:18.580]                   {
[17:41:18.580]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:18.580]                     NULL
[17:41:18.580]                   }
[17:41:18.580]                   options(future.plan = NULL)
[17:41:18.580]                   if (is.na(NA_character_)) 
[17:41:18.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:18.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:18.580]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:41:18.580]                     envir = parent.frame()) 
[17:41:18.580]                   {
[17:41:18.580]                     default_workers <- missing(workers)
[17:41:18.580]                     if (is.function(workers)) 
[17:41:18.580]                       workers <- workers()
[17:41:18.580]                     workers <- structure(as.integer(workers), 
[17:41:18.580]                       class = class(workers))
[17:41:18.580]                     stop_if_not(is.finite(workers), workers >= 
[17:41:18.580]                       1L)
[17:41:18.580]                     if ((workers == 1L && !inherits(workers, 
[17:41:18.580]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:41:18.580]                       if (default_workers) 
[17:41:18.580]                         supportsMulticore(warn = TRUE)
[17:41:18.580]                       return(sequential(..., envir = envir))
[17:41:18.580]                     }
[17:41:18.580]                     oopts <- options(mc.cores = workers)
[17:41:18.580]                     on.exit(options(oopts))
[17:41:18.580]                     future <- MulticoreFuture(..., workers = workers, 
[17:41:18.580]                       envir = envir)
[17:41:18.580]                     if (!future$lazy) 
[17:41:18.580]                       future <- run(future)
[17:41:18.580]                     invisible(future)
[17:41:18.580]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:18.580]                 }
[17:41:18.580]             }
[17:41:18.580]         }
[17:41:18.580]     })
[17:41:18.580]     if (FALSE) {
[17:41:18.580]         base::sink(type = "output", split = FALSE)
[17:41:18.580]         if (NA) {
[17:41:18.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:18.580]         }
[17:41:18.580]         else {
[17:41:18.580]             ...future.result["stdout"] <- base::list(NULL)
[17:41:18.580]         }
[17:41:18.580]         base::close(...future.stdout)
[17:41:18.580]         ...future.stdout <- NULL
[17:41:18.580]     }
[17:41:18.580]     ...future.result$conditions <- ...future.conditions
[17:41:18.580]     ...future.result$finished <- base::Sys.time()
[17:41:18.580]     ...future.result
[17:41:18.580] }
[17:41:18.586] assign_globals() ...
[17:41:18.586] List of 5
[17:41:18.586]  $ ...future.FUN            :function (x, y)  
[17:41:18.586]  $ MoreArgs                 : NULL
[17:41:18.586]  $ ...future.elements_ii    :List of 2
[17:41:18.586]   ..$ :List of 1
[17:41:18.586]   .. ..$ : int 0
[17:41:18.586]   ..$ :List of 1
[17:41:18.586]   .. ..$ : int 1
[17:41:18.586]  $ ...future.seeds_ii       : NULL
[17:41:18.586]  $ ...future.globals.maxSize: NULL
[17:41:18.586]  - attr(*, "where")=List of 5
[17:41:18.586]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:41:18.586]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:41:18.586]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:41:18.586]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:41:18.586]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:41:18.586]  - attr(*, "resolved")= logi FALSE
[17:41:18.586]  - attr(*, "total_size")= num 6368
[17:41:18.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:18.586]  - attr(*, "already-done")= logi TRUE
[17:41:18.596] - reassign environment for ‘...future.FUN’
[17:41:18.596] - copied ‘...future.FUN’ to environment
[17:41:18.596] - copied ‘MoreArgs’ to environment
[17:41:18.597] - copied ‘...future.elements_ii’ to environment
[17:41:18.597] - copied ‘...future.seeds_ii’ to environment
[17:41:18.597] - copied ‘...future.globals.maxSize’ to environment
[17:41:18.597] assign_globals() ... done
[17:41:18.597] requestCore(): workers = 2
[17:41:18.600] MulticoreFuture started
[17:41:18.600] - Launch lazy future ... done
[17:41:18.600] run() for ‘MulticoreFuture’ ... done
[17:41:18.601] Created future:
[17:41:18.601] plan(): Setting new future strategy stack:
[17:41:18.601] List of future strategies:
[17:41:18.601] 1. sequential:
[17:41:18.601]    - args: function (..., envir = parent.frame())
[17:41:18.601]    - tweaked: FALSE
[17:41:18.601]    - call: NULL
[17:41:18.602] plan(): nbrOfWorkers() = 1
[17:41:18.604] plan(): Setting new future strategy stack:
[17:41:18.604] List of future strategies:
[17:41:18.604] 1. multicore:
[17:41:18.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:18.604]    - tweaked: FALSE
[17:41:18.604]    - call: plan(strategy)
[17:41:18.609] plan(): nbrOfWorkers() = 2
[17:41:18.601] MulticoreFuture:
[17:41:18.601] Label: ‘future_mapply-2’
[17:41:18.601] Expression:
[17:41:18.601] {
[17:41:18.601]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:18.601]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:18.601]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:18.601]         on.exit(options(oopts), add = TRUE)
[17:41:18.601]     }
[17:41:18.601]     {
[17:41:18.601]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:18.601]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:18.601]         do.call(mapply, args = args)
[17:41:18.601]     }
[17:41:18.601] }
[17:41:18.601] Lazy evaluation: FALSE
[17:41:18.601] Asynchronous evaluation: TRUE
[17:41:18.601] Local evaluation: TRUE
[17:41:18.601] Environment: R_GlobalEnv
[17:41:18.601] Capture standard output: NA
[17:41:18.601] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:18.601] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:18.601] Packages: <none>
[17:41:18.601] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:18.601] Resolved: TRUE
[17:41:18.601] Value: <not collected>
[17:41:18.601] Conditions captured: <none>
[17:41:18.601] Early signaling: FALSE
[17:41:18.601] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:18.601] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:18.611] Chunk #2 of 2 ... DONE
[17:41:18.611] Launching 2 futures (chunks) ... DONE
[17:41:18.611] Resolving 2 futures (chunks) ...
[17:41:18.611] resolve() on list ...
[17:41:18.611]  recursive: 0
[17:41:18.611]  length: 2
[17:41:18.612] 
[17:41:18.622] Future #2
[17:41:18.623] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:41:18.623] - nx: 2
[17:41:18.624] - relay: TRUE
[17:41:18.624] - stdout: TRUE
[17:41:18.624] - signal: TRUE
[17:41:18.624] - resignal: FALSE
[17:41:18.624] - force: TRUE
[17:41:18.624] - relayed: [n=2] FALSE, FALSE
[17:41:18.624] - queued futures: [n=2] FALSE, FALSE
[17:41:18.625]  - until=1
[17:41:18.625]  - relaying element #1
[17:41:18.625] - relayed: [n=2] FALSE, FALSE
[17:41:18.625] - queued futures: [n=2] FALSE, TRUE
[17:41:18.625] signalConditionsASAP(NULL, pos=2) ... done
[17:41:18.625]  length: 1 (resolved future 2)
[17:41:19.055] plan(): Setting new future strategy stack:
[17:41:19.056] List of future strategies:
[17:41:19.056] 1. multicore:
[17:41:19.056]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:19.056]    - tweaked: FALSE
[17:41:19.056]    - call: plan(strategy)
[17:41:19.060] plan(): nbrOfWorkers() = 2
[17:41:19.064] Future #1
[17:41:19.065] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:41:19.065] - nx: 2
[17:41:19.065] - relay: TRUE
[17:41:19.065] - stdout: TRUE
[17:41:19.066] - signal: TRUE
[17:41:19.066] - resignal: FALSE
[17:41:19.066] - force: TRUE
[17:41:19.066] - relayed: [n=2] FALSE, FALSE
[17:41:19.066] - queued futures: [n=2] FALSE, TRUE
[17:41:19.066]  - until=1
[17:41:19.067]  - relaying element #1
[17:41:19.067] - relayed: [n=2] TRUE, FALSE
[17:41:19.067] - queued futures: [n=2] TRUE, TRUE
[17:41:19.067] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:41:19.067]  length: 0 (resolved future 1)
[17:41:19.068] Relaying remaining futures
[17:41:19.068] signalConditionsASAP(NULL, pos=0) ...
[17:41:19.068] - nx: 2
[17:41:19.068] - relay: TRUE
[17:41:19.068] - stdout: TRUE
[17:41:19.068] - signal: TRUE
[17:41:19.068] - resignal: FALSE
[17:41:19.069] - force: TRUE
[17:41:19.069] - relayed: [n=2] TRUE, FALSE
[17:41:19.069] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:19.069]  - relaying element #2
[17:41:19.069] - relayed: [n=2] TRUE, TRUE
[17:41:19.070] - queued futures: [n=2] TRUE, TRUE
[17:41:19.070] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:41:19.070] resolve() on list ... DONE
[17:41:19.070]  - Number of value chunks collected: 2
[17:41:19.070] Resolving 2 futures (chunks) ... DONE
[17:41:19.070] Reducing values from 2 chunks ...
[17:41:19.070]  - Number of values collected after concatenation: 2
[17:41:19.071]  - Number of values expected: 2
[17:41:19.071] Reducing values from 2 chunks ... DONE
[17:41:19.071] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[17:41:19.071] plan(): Setting new future strategy stack:
[17:41:19.072] List of future strategies:
[17:41:19.072] 1. multisession:
[17:41:19.072]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:19.072]    - tweaked: FALSE
[17:41:19.072]    - call: plan(strategy)
[17:41:19.072] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:41:19.072] multisession:
[17:41:19.072] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:19.072] - tweaked: FALSE
[17:41:19.072] - call: plan(strategy)
[17:41:19.079] getGlobalsAndPackages() ...
[17:41:19.079] Not searching for globals
[17:41:19.079] - globals: [0] <none>
[17:41:19.079] getGlobalsAndPackages() ... DONE
[17:41:19.080] [local output] makeClusterPSOCK() ...
[17:41:19.126] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:41:19.132] [local output] Base port: 11855
[17:41:19.132] [local output] Getting setup options for 2 cluster nodes ...
[17:41:19.132] [local output]  - Node 1 of 2 ...
[17:41:19.133] [local output] localMachine=TRUE => revtunnel=FALSE

[17:41:19.134] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpsPTK8O/worker.rank=1.parallelly.parent=40410.9dda113481c.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpsPTK8O/worker.rank=1.parallelly.parent=40410.9dda113481c.pid")'’
[17:41:19.321] - Possible to infer worker's PID: TRUE
[17:41:19.322] [local output] Rscript port: 11855

[17:41:19.322] [local output]  - Node 2 of 2 ...
[17:41:19.322] [local output] localMachine=TRUE => revtunnel=FALSE

[17:41:19.323] [local output] Rscript port: 11855

[17:41:19.323] [local output] Getting setup options for 2 cluster nodes ... done
[17:41:19.323] [local output]  - Parallel setup requested for some PSOCK nodes
[17:41:19.324] [local output] Setting up PSOCK nodes in parallel
[17:41:19.324] List of 36
[17:41:19.324]  $ worker          : chr "localhost"
[17:41:19.324]   ..- attr(*, "localhost")= logi TRUE
[17:41:19.324]  $ master          : chr "localhost"
[17:41:19.324]  $ port            : int 11855
[17:41:19.324]  $ connectTimeout  : num 120
[17:41:19.324]  $ timeout         : num 2592000
[17:41:19.324]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:41:19.324]  $ homogeneous     : logi TRUE
[17:41:19.324]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:41:19.324]  $ rscript_envs    : NULL
[17:41:19.324]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:41:19.324]  $ rscript_startup : NULL
[17:41:19.324]  $ rscript_sh      : chr "sh"
[17:41:19.324]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:41:19.324]  $ methods         : logi TRUE
[17:41:19.324]  $ socketOptions   : chr "no-delay"
[17:41:19.324]  $ useXDR          : logi FALSE
[17:41:19.324]  $ outfile         : chr "/dev/null"
[17:41:19.324]  $ renice          : int NA
[17:41:19.324]  $ rshcmd          : NULL
[17:41:19.324]  $ user            : chr(0) 
[17:41:19.324]  $ revtunnel       : logi FALSE
[17:41:19.324]  $ rshlogfile      : NULL
[17:41:19.324]  $ rshopts         : chr(0) 
[17:41:19.324]  $ rank            : int 1
[17:41:19.324]  $ manual          : logi FALSE
[17:41:19.324]  $ dryrun          : logi FALSE
[17:41:19.324]  $ quiet           : logi FALSE
[17:41:19.324]  $ setup_strategy  : chr "parallel"
[17:41:19.324]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:41:19.324]  $ pidfile         : chr "/tmp/RtmpsPTK8O/worker.rank=1.parallelly.parent=40410.9dda113481c.pid"
[17:41:19.324]  $ rshcmd_label    : NULL
[17:41:19.324]  $ rsh_call        : NULL
[17:41:19.324]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:41:19.324]  $ localMachine    : logi TRUE
[17:41:19.324]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:41:19.324]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:41:19.324]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:41:19.324]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:41:19.324]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:41:19.324]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:41:19.324]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:41:19.324]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:41:19.324]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:41:19.324]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:41:19.324]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:41:19.324]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:41:19.324]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:41:19.324]  $ arguments       :List of 28
[17:41:19.324]   ..$ worker          : chr "localhost"
[17:41:19.324]   ..$ master          : NULL
[17:41:19.324]   ..$ port            : int 11855
[17:41:19.324]   ..$ connectTimeout  : num 120
[17:41:19.324]   ..$ timeout         : num 2592000
[17:41:19.324]   ..$ rscript         : NULL
[17:41:19.324]   ..$ homogeneous     : NULL
[17:41:19.324]   ..$ rscript_args    : NULL
[17:41:19.324]   ..$ rscript_envs    : NULL
[17:41:19.324]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:41:19.324]   ..$ rscript_startup : NULL
[17:41:19.324]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:41:19.324]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:41:19.324]   ..$ methods         : logi TRUE
[17:41:19.324]   ..$ socketOptions   : chr "no-delay"
[17:41:19.324]   ..$ useXDR          : logi FALSE
[17:41:19.324]   ..$ outfile         : chr "/dev/null"
[17:41:19.324]   ..$ renice          : int NA
[17:41:19.324]   ..$ rshcmd          : NULL
[17:41:19.324]   ..$ user            : NULL
[17:41:19.324]   ..$ revtunnel       : logi NA
[17:41:19.324]   ..$ rshlogfile      : NULL
[17:41:19.324]   ..$ rshopts         : NULL
[17:41:19.324]   ..$ rank            : int 1
[17:41:19.324]   ..$ manual          : logi FALSE
[17:41:19.324]   ..$ dryrun          : logi FALSE
[17:41:19.324]   ..$ quiet           : logi FALSE
[17:41:19.324]   ..$ setup_strategy  : chr "parallel"
[17:41:19.324]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:41:19.341] [local output] System call to launch all workers:
[17:41:19.341] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpsPTK8O/worker.rank=1.parallelly.parent=40410.9dda113481c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11855 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:41:19.341] [local output] Starting PSOCK main server
[17:41:19.343] [local output] Workers launched
[17:41:19.343] [local output] Waiting for workers to connect back
[17:41:19.343]  - [local output] 0 workers out of 2 ready
[17:41:19.593]  - [local output] 0 workers out of 2 ready
[17:41:19.593]  - [local output] 1 workers out of 2 ready
[17:41:19.595]  - [local output] 1 workers out of 2 ready
[17:41:19.595]  - [local output] 2 workers out of 2 ready
[17:41:19.595] [local output] Launching of workers completed
[17:41:19.595] [local output] Collecting session information from workers
[17:41:19.596] [local output]  - Worker #1 of 2
[17:41:19.597] [local output]  - Worker #2 of 2
[17:41:19.597] [local output] makeClusterPSOCK() ... done
[17:41:19.610] Packages needed by the future expression (n = 0): <none>
[17:41:19.610] Packages needed by future strategies (n = 0): <none>
[17:41:19.610] {
[17:41:19.610]     {
[17:41:19.610]         {
[17:41:19.610]             ...future.startTime <- base::Sys.time()
[17:41:19.610]             {
[17:41:19.610]                 {
[17:41:19.610]                   {
[17:41:19.610]                     {
[17:41:19.610]                       base::local({
[17:41:19.610]                         has_future <- base::requireNamespace("future", 
[17:41:19.610]                           quietly = TRUE)
[17:41:19.610]                         if (has_future) {
[17:41:19.610]                           ns <- base::getNamespace("future")
[17:41:19.610]                           version <- ns[[".package"]][["version"]]
[17:41:19.610]                           if (is.null(version)) 
[17:41:19.610]                             version <- utils::packageVersion("future")
[17:41:19.610]                         }
[17:41:19.610]                         else {
[17:41:19.610]                           version <- NULL
[17:41:19.610]                         }
[17:41:19.610]                         if (!has_future || version < "1.8.0") {
[17:41:19.610]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:19.610]                             "", base::R.version$version.string), 
[17:41:19.610]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:19.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:19.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:19.610]                               "release", "version")], collapse = " "), 
[17:41:19.610]                             hostname = base::Sys.info()[["nodename"]])
[17:41:19.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:19.610]                             info)
[17:41:19.610]                           info <- base::paste(info, collapse = "; ")
[17:41:19.610]                           if (!has_future) {
[17:41:19.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:19.610]                               info)
[17:41:19.610]                           }
[17:41:19.610]                           else {
[17:41:19.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:19.610]                               info, version)
[17:41:19.610]                           }
[17:41:19.610]                           base::stop(msg)
[17:41:19.610]                         }
[17:41:19.610]                       })
[17:41:19.610]                     }
[17:41:19.610]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:19.610]                     base::options(mc.cores = 1L)
[17:41:19.610]                   }
[17:41:19.610]                   options(future.plan = NULL)
[17:41:19.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:19.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:19.610]                 }
[17:41:19.610]                 ...future.workdir <- getwd()
[17:41:19.610]             }
[17:41:19.610]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:19.610]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:19.610]         }
[17:41:19.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:19.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:19.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:19.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:19.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:19.610]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:19.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:19.610]             base::names(...future.oldOptions))
[17:41:19.610]     }
[17:41:19.610]     if (FALSE) {
[17:41:19.610]     }
[17:41:19.610]     else {
[17:41:19.610]         if (TRUE) {
[17:41:19.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:19.610]                 open = "w")
[17:41:19.610]         }
[17:41:19.610]         else {
[17:41:19.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:19.610]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:19.610]         }
[17:41:19.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:19.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:19.610]             base::sink(type = "output", split = FALSE)
[17:41:19.610]             base::close(...future.stdout)
[17:41:19.610]         }, add = TRUE)
[17:41:19.610]     }
[17:41:19.610]     ...future.frame <- base::sys.nframe()
[17:41:19.610]     ...future.conditions <- base::list()
[17:41:19.610]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:19.610]     if (FALSE) {
[17:41:19.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:19.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:19.610]     }
[17:41:19.610]     ...future.result <- base::tryCatch({
[17:41:19.610]         base::withCallingHandlers({
[17:41:19.610]             ...future.value <- base::withVisible(base::local({
[17:41:19.610]                 ...future.makeSendCondition <- local({
[17:41:19.610]                   sendCondition <- NULL
[17:41:19.610]                   function(frame = 1L) {
[17:41:19.610]                     if (is.function(sendCondition)) 
[17:41:19.610]                       return(sendCondition)
[17:41:19.610]                     ns <- getNamespace("parallel")
[17:41:19.610]                     if (exists("sendData", mode = "function", 
[17:41:19.610]                       envir = ns)) {
[17:41:19.610]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:19.610]                         envir = ns)
[17:41:19.610]                       envir <- sys.frame(frame)
[17:41:19.610]                       master <- NULL
[17:41:19.610]                       while (!identical(envir, .GlobalEnv) && 
[17:41:19.610]                         !identical(envir, emptyenv())) {
[17:41:19.610]                         if (exists("master", mode = "list", envir = envir, 
[17:41:19.610]                           inherits = FALSE)) {
[17:41:19.610]                           master <- get("master", mode = "list", 
[17:41:19.610]                             envir = envir, inherits = FALSE)
[17:41:19.610]                           if (inherits(master, c("SOCKnode", 
[17:41:19.610]                             "SOCK0node"))) {
[17:41:19.610]                             sendCondition <<- function(cond) {
[17:41:19.610]                               data <- list(type = "VALUE", value = cond, 
[17:41:19.610]                                 success = TRUE)
[17:41:19.610]                               parallel_sendData(master, data)
[17:41:19.610]                             }
[17:41:19.610]                             return(sendCondition)
[17:41:19.610]                           }
[17:41:19.610]                         }
[17:41:19.610]                         frame <- frame + 1L
[17:41:19.610]                         envir <- sys.frame(frame)
[17:41:19.610]                       }
[17:41:19.610]                     }
[17:41:19.610]                     sendCondition <<- function(cond) NULL
[17:41:19.610]                   }
[17:41:19.610]                 })
[17:41:19.610]                 withCallingHandlers({
[17:41:19.610]                   NA
[17:41:19.610]                 }, immediateCondition = function(cond) {
[17:41:19.610]                   sendCondition <- ...future.makeSendCondition()
[17:41:19.610]                   sendCondition(cond)
[17:41:19.610]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.610]                   {
[17:41:19.610]                     inherits <- base::inherits
[17:41:19.610]                     invokeRestart <- base::invokeRestart
[17:41:19.610]                     is.null <- base::is.null
[17:41:19.610]                     muffled <- FALSE
[17:41:19.610]                     if (inherits(cond, "message")) {
[17:41:19.610]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:19.610]                       if (muffled) 
[17:41:19.610]                         invokeRestart("muffleMessage")
[17:41:19.610]                     }
[17:41:19.610]                     else if (inherits(cond, "warning")) {
[17:41:19.610]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:19.610]                       if (muffled) 
[17:41:19.610]                         invokeRestart("muffleWarning")
[17:41:19.610]                     }
[17:41:19.610]                     else if (inherits(cond, "condition")) {
[17:41:19.610]                       if (!is.null(pattern)) {
[17:41:19.610]                         computeRestarts <- base::computeRestarts
[17:41:19.610]                         grepl <- base::grepl
[17:41:19.610]                         restarts <- computeRestarts(cond)
[17:41:19.610]                         for (restart in restarts) {
[17:41:19.610]                           name <- restart$name
[17:41:19.610]                           if (is.null(name)) 
[17:41:19.610]                             next
[17:41:19.610]                           if (!grepl(pattern, name)) 
[17:41:19.610]                             next
[17:41:19.610]                           invokeRestart(restart)
[17:41:19.610]                           muffled <- TRUE
[17:41:19.610]                           break
[17:41:19.610]                         }
[17:41:19.610]                       }
[17:41:19.610]                     }
[17:41:19.610]                     invisible(muffled)
[17:41:19.610]                   }
[17:41:19.610]                   muffleCondition(cond)
[17:41:19.610]                 })
[17:41:19.610]             }))
[17:41:19.610]             future::FutureResult(value = ...future.value$value, 
[17:41:19.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:19.610]                   ...future.rng), globalenv = if (FALSE) 
[17:41:19.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:19.610]                     ...future.globalenv.names))
[17:41:19.610]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:19.610]         }, condition = base::local({
[17:41:19.610]             c <- base::c
[17:41:19.610]             inherits <- base::inherits
[17:41:19.610]             invokeRestart <- base::invokeRestart
[17:41:19.610]             length <- base::length
[17:41:19.610]             list <- base::list
[17:41:19.610]             seq.int <- base::seq.int
[17:41:19.610]             signalCondition <- base::signalCondition
[17:41:19.610]             sys.calls <- base::sys.calls
[17:41:19.610]             `[[` <- base::`[[`
[17:41:19.610]             `+` <- base::`+`
[17:41:19.610]             `<<-` <- base::`<<-`
[17:41:19.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:19.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:19.610]                   3L)]
[17:41:19.610]             }
[17:41:19.610]             function(cond) {
[17:41:19.610]                 is_error <- inherits(cond, "error")
[17:41:19.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:19.610]                   NULL)
[17:41:19.610]                 if (is_error) {
[17:41:19.610]                   sessionInformation <- function() {
[17:41:19.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:19.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:19.610]                       search = base::search(), system = base::Sys.info())
[17:41:19.610]                   }
[17:41:19.610]                   ...future.conditions[[length(...future.conditions) + 
[17:41:19.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:19.610]                     cond$call), session = sessionInformation(), 
[17:41:19.610]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:19.610]                   signalCondition(cond)
[17:41:19.610]                 }
[17:41:19.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:19.610]                 "immediateCondition"))) {
[17:41:19.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:19.610]                   ...future.conditions[[length(...future.conditions) + 
[17:41:19.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:19.610]                   if (TRUE && !signal) {
[17:41:19.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.610]                     {
[17:41:19.610]                       inherits <- base::inherits
[17:41:19.610]                       invokeRestart <- base::invokeRestart
[17:41:19.610]                       is.null <- base::is.null
[17:41:19.610]                       muffled <- FALSE
[17:41:19.610]                       if (inherits(cond, "message")) {
[17:41:19.610]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:19.610]                         if (muffled) 
[17:41:19.610]                           invokeRestart("muffleMessage")
[17:41:19.610]                       }
[17:41:19.610]                       else if (inherits(cond, "warning")) {
[17:41:19.610]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:19.610]                         if (muffled) 
[17:41:19.610]                           invokeRestart("muffleWarning")
[17:41:19.610]                       }
[17:41:19.610]                       else if (inherits(cond, "condition")) {
[17:41:19.610]                         if (!is.null(pattern)) {
[17:41:19.610]                           computeRestarts <- base::computeRestarts
[17:41:19.610]                           grepl <- base::grepl
[17:41:19.610]                           restarts <- computeRestarts(cond)
[17:41:19.610]                           for (restart in restarts) {
[17:41:19.610]                             name <- restart$name
[17:41:19.610]                             if (is.null(name)) 
[17:41:19.610]                               next
[17:41:19.610]                             if (!grepl(pattern, name)) 
[17:41:19.610]                               next
[17:41:19.610]                             invokeRestart(restart)
[17:41:19.610]                             muffled <- TRUE
[17:41:19.610]                             break
[17:41:19.610]                           }
[17:41:19.610]                         }
[17:41:19.610]                       }
[17:41:19.610]                       invisible(muffled)
[17:41:19.610]                     }
[17:41:19.610]                     muffleCondition(cond, pattern = "^muffle")
[17:41:19.610]                   }
[17:41:19.610]                 }
[17:41:19.610]                 else {
[17:41:19.610]                   if (TRUE) {
[17:41:19.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.610]                     {
[17:41:19.610]                       inherits <- base::inherits
[17:41:19.610]                       invokeRestart <- base::invokeRestart
[17:41:19.610]                       is.null <- base::is.null
[17:41:19.610]                       muffled <- FALSE
[17:41:19.610]                       if (inherits(cond, "message")) {
[17:41:19.610]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:19.610]                         if (muffled) 
[17:41:19.610]                           invokeRestart("muffleMessage")
[17:41:19.610]                       }
[17:41:19.610]                       else if (inherits(cond, "warning")) {
[17:41:19.610]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:19.610]                         if (muffled) 
[17:41:19.610]                           invokeRestart("muffleWarning")
[17:41:19.610]                       }
[17:41:19.610]                       else if (inherits(cond, "condition")) {
[17:41:19.610]                         if (!is.null(pattern)) {
[17:41:19.610]                           computeRestarts <- base::computeRestarts
[17:41:19.610]                           grepl <- base::grepl
[17:41:19.610]                           restarts <- computeRestarts(cond)
[17:41:19.610]                           for (restart in restarts) {
[17:41:19.610]                             name <- restart$name
[17:41:19.610]                             if (is.null(name)) 
[17:41:19.610]                               next
[17:41:19.610]                             if (!grepl(pattern, name)) 
[17:41:19.610]                               next
[17:41:19.610]                             invokeRestart(restart)
[17:41:19.610]                             muffled <- TRUE
[17:41:19.610]                             break
[17:41:19.610]                           }
[17:41:19.610]                         }
[17:41:19.610]                       }
[17:41:19.610]                       invisible(muffled)
[17:41:19.610]                     }
[17:41:19.610]                     muffleCondition(cond, pattern = "^muffle")
[17:41:19.610]                   }
[17:41:19.610]                 }
[17:41:19.610]             }
[17:41:19.610]         }))
[17:41:19.610]     }, error = function(ex) {
[17:41:19.610]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:19.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:19.610]                 ...future.rng), started = ...future.startTime, 
[17:41:19.610]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:19.610]             version = "1.8"), class = "FutureResult")
[17:41:19.610]     }, finally = {
[17:41:19.610]         if (!identical(...future.workdir, getwd())) 
[17:41:19.610]             setwd(...future.workdir)
[17:41:19.610]         {
[17:41:19.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:19.610]                 ...future.oldOptions$nwarnings <- NULL
[17:41:19.610]             }
[17:41:19.610]             base::options(...future.oldOptions)
[17:41:19.610]             if (.Platform$OS.type == "windows") {
[17:41:19.610]                 old_names <- names(...future.oldEnvVars)
[17:41:19.610]                 envs <- base::Sys.getenv()
[17:41:19.610]                 names <- names(envs)
[17:41:19.610]                 common <- intersect(names, old_names)
[17:41:19.610]                 added <- setdiff(names, old_names)
[17:41:19.610]                 removed <- setdiff(old_names, names)
[17:41:19.610]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:19.610]                   envs[common]]
[17:41:19.610]                 NAMES <- toupper(changed)
[17:41:19.610]                 args <- list()
[17:41:19.610]                 for (kk in seq_along(NAMES)) {
[17:41:19.610]                   name <- changed[[kk]]
[17:41:19.610]                   NAME <- NAMES[[kk]]
[17:41:19.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.610]                     next
[17:41:19.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:19.610]                 }
[17:41:19.610]                 NAMES <- toupper(added)
[17:41:19.610]                 for (kk in seq_along(NAMES)) {
[17:41:19.610]                   name <- added[[kk]]
[17:41:19.610]                   NAME <- NAMES[[kk]]
[17:41:19.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.610]                     next
[17:41:19.610]                   args[[name]] <- ""
[17:41:19.610]                 }
[17:41:19.610]                 NAMES <- toupper(removed)
[17:41:19.610]                 for (kk in seq_along(NAMES)) {
[17:41:19.610]                   name <- removed[[kk]]
[17:41:19.610]                   NAME <- NAMES[[kk]]
[17:41:19.610]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.610]                     next
[17:41:19.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:19.610]                 }
[17:41:19.610]                 if (length(args) > 0) 
[17:41:19.610]                   base::do.call(base::Sys.setenv, args = args)
[17:41:19.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:19.610]             }
[17:41:19.610]             else {
[17:41:19.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:19.610]             }
[17:41:19.610]             {
[17:41:19.610]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:19.610]                   0L) {
[17:41:19.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:19.610]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:19.610]                   base::options(opts)
[17:41:19.610]                 }
[17:41:19.610]                 {
[17:41:19.610]                   {
[17:41:19.610]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:19.610]                     NULL
[17:41:19.610]                   }
[17:41:19.610]                   options(future.plan = NULL)
[17:41:19.610]                   if (is.na(NA_character_)) 
[17:41:19.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:19.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:19.610]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:19.610]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:19.610]                     envir = parent.frame()) 
[17:41:19.610]                   {
[17:41:19.610]                     if (is.function(workers)) 
[17:41:19.610]                       workers <- workers()
[17:41:19.610]                     workers <- structure(as.integer(workers), 
[17:41:19.610]                       class = class(workers))
[17:41:19.610]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:19.610]                       workers >= 1)
[17:41:19.610]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:19.610]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:19.610]                     }
[17:41:19.610]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:19.610]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:19.610]                       envir = envir)
[17:41:19.610]                     if (!future$lazy) 
[17:41:19.610]                       future <- run(future)
[17:41:19.610]                     invisible(future)
[17:41:19.610]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:19.610]                 }
[17:41:19.610]             }
[17:41:19.610]         }
[17:41:19.610]     })
[17:41:19.610]     if (TRUE) {
[17:41:19.610]         base::sink(type = "output", split = FALSE)
[17:41:19.610]         if (TRUE) {
[17:41:19.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:19.610]         }
[17:41:19.610]         else {
[17:41:19.610]             ...future.result["stdout"] <- base::list(NULL)
[17:41:19.610]         }
[17:41:19.610]         base::close(...future.stdout)
[17:41:19.610]         ...future.stdout <- NULL
[17:41:19.610]     }
[17:41:19.610]     ...future.result$conditions <- ...future.conditions
[17:41:19.610]     ...future.result$finished <- base::Sys.time()
[17:41:19.610]     ...future.result
[17:41:19.610] }
[17:41:19.684] MultisessionFuture started
[17:41:19.685] result() for ClusterFuture ...
[17:41:19.686] receiveMessageFromWorker() for ClusterFuture ...
[17:41:19.686] - Validating connection of MultisessionFuture
[17:41:19.720] - received message: FutureResult
[17:41:19.720] - Received FutureResult
[17:41:19.720] - Erased future from FutureRegistry
[17:41:19.720] result() for ClusterFuture ...
[17:41:19.720] - result already collected: FutureResult
[17:41:19.720] result() for ClusterFuture ... done
[17:41:19.721] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:19.721] result() for ClusterFuture ... done
[17:41:19.721] result() for ClusterFuture ...
[17:41:19.721] - result already collected: FutureResult
[17:41:19.721] result() for ClusterFuture ... done
[17:41:19.721] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:41:19.725] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:41:19.725] future_lapply() ...
[17:41:19.730] Number of chunks: 2
[17:41:19.730] getGlobalsAndPackagesXApply() ...
[17:41:19.730]  - future.globals: TRUE
[17:41:19.730] getGlobalsAndPackages() ...
[17:41:19.731] Searching for globals...
[17:41:19.732] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:19.733] Searching for globals ... DONE
[17:41:19.733] Resolving globals: FALSE
[17:41:19.733] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:19.734] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:19.734] - globals: [1] ‘FUN’
[17:41:19.734] 
[17:41:19.734] getGlobalsAndPackages() ... DONE
[17:41:19.734]  - globals found/used: [n=1] ‘FUN’
[17:41:19.734]  - needed namespaces: [n=0] 
[17:41:19.734] Finding globals ... DONE
[17:41:19.735]  - use_args: TRUE
[17:41:19.735]  - Getting '...' globals ...
[17:41:19.735] resolve() on list ...
[17:41:19.735]  recursive: 0
[17:41:19.735]  length: 1
[17:41:19.735]  elements: ‘...’
[17:41:19.736]  length: 0 (resolved future 1)
[17:41:19.736] resolve() on list ... DONE
[17:41:19.736]    - '...' content: [n=0] 
[17:41:19.736] List of 1
[17:41:19.736]  $ ...: list()
[17:41:19.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:19.736]  - attr(*, "where")=List of 1
[17:41:19.736]   ..$ ...:<environment: 0x55c989c05270> 
[17:41:19.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:19.736]  - attr(*, "resolved")= logi TRUE
[17:41:19.736]  - attr(*, "total_size")= num NA
[17:41:19.739]  - Getting '...' globals ... DONE
[17:41:19.739] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:19.740] List of 2
[17:41:19.740]  $ ...future.FUN:function (x)  
[17:41:19.740]  $ ...          : list()
[17:41:19.740]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:19.740]  - attr(*, "where")=List of 2
[17:41:19.740]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:19.740]   ..$ ...          :<environment: 0x55c989c05270> 
[17:41:19.740]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:19.740]  - attr(*, "resolved")= logi FALSE
[17:41:19.740]  - attr(*, "total_size")= num 4720
[17:41:19.743] Packages to be attached in all futures: [n=0] 
[17:41:19.743] getGlobalsAndPackagesXApply() ... DONE
[17:41:19.743] Number of futures (= number of chunks): 2
[17:41:19.743] Launching 2 futures (chunks) ...
[17:41:19.744] Chunk #1 of 2 ...
[17:41:19.744]  - Finding globals in 'X' for chunk #1 ...
[17:41:19.744] getGlobalsAndPackages() ...
[17:41:19.744] Searching for globals...
[17:41:19.744] 
[17:41:19.744] Searching for globals ... DONE
[17:41:19.745] - globals: [0] <none>
[17:41:19.745] getGlobalsAndPackages() ... DONE
[17:41:19.745]    + additional globals found: [n=0] 
[17:41:19.745]    + additional namespaces needed: [n=0] 
[17:41:19.745]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:19.745]  - seeds: <none>
[17:41:19.745] getGlobalsAndPackages() ...
[17:41:19.745] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:19.745] Resolving globals: FALSE
[17:41:19.746] Tweak future expression to call with '...' arguments ...
[17:41:19.746] {
[17:41:19.746]     do.call(function(...) {
[17:41:19.746]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:19.746]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:19.746]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:19.746]             on.exit(options(oopts), add = TRUE)
[17:41:19.746]         }
[17:41:19.746]         {
[17:41:19.746]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:19.746]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:19.746]                 ...future.FUN(...future.X_jj, ...)
[17:41:19.746]             })
[17:41:19.746]         }
[17:41:19.746]     }, args = future.call.arguments)
[17:41:19.746] }
[17:41:19.746] Tweak future expression to call with '...' arguments ... DONE
[17:41:19.746] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:19.747] 
[17:41:19.747] getGlobalsAndPackages() ... DONE
[17:41:19.747] run() for ‘Future’ ...
[17:41:19.747] - state: ‘created’
[17:41:19.747] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:19.763] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:19.763] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:19.764]   - Field: ‘node’
[17:41:19.764]   - Field: ‘label’
[17:41:19.764]   - Field: ‘local’
[17:41:19.764]   - Field: ‘owner’
[17:41:19.764]   - Field: ‘envir’
[17:41:19.764]   - Field: ‘workers’
[17:41:19.764]   - Field: ‘packages’
[17:41:19.764]   - Field: ‘gc’
[17:41:19.764]   - Field: ‘conditions’
[17:41:19.765]   - Field: ‘persistent’
[17:41:19.765]   - Field: ‘expr’
[17:41:19.765]   - Field: ‘uuid’
[17:41:19.765]   - Field: ‘seed’
[17:41:19.765]   - Field: ‘version’
[17:41:19.765]   - Field: ‘result’
[17:41:19.765]   - Field: ‘asynchronous’
[17:41:19.765]   - Field: ‘calls’
[17:41:19.765]   - Field: ‘globals’
[17:41:19.766]   - Field: ‘stdout’
[17:41:19.766]   - Field: ‘earlySignal’
[17:41:19.766]   - Field: ‘lazy’
[17:41:19.766]   - Field: ‘state’
[17:41:19.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:19.766] - Launch lazy future ...
[17:41:19.767] Packages needed by the future expression (n = 0): <none>
[17:41:19.767] Packages needed by future strategies (n = 0): <none>
[17:41:19.767] {
[17:41:19.767]     {
[17:41:19.767]         {
[17:41:19.767]             ...future.startTime <- base::Sys.time()
[17:41:19.767]             {
[17:41:19.767]                 {
[17:41:19.767]                   {
[17:41:19.767]                     {
[17:41:19.767]                       base::local({
[17:41:19.767]                         has_future <- base::requireNamespace("future", 
[17:41:19.767]                           quietly = TRUE)
[17:41:19.767]                         if (has_future) {
[17:41:19.767]                           ns <- base::getNamespace("future")
[17:41:19.767]                           version <- ns[[".package"]][["version"]]
[17:41:19.767]                           if (is.null(version)) 
[17:41:19.767]                             version <- utils::packageVersion("future")
[17:41:19.767]                         }
[17:41:19.767]                         else {
[17:41:19.767]                           version <- NULL
[17:41:19.767]                         }
[17:41:19.767]                         if (!has_future || version < "1.8.0") {
[17:41:19.767]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:19.767]                             "", base::R.version$version.string), 
[17:41:19.767]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:19.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:19.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:19.767]                               "release", "version")], collapse = " "), 
[17:41:19.767]                             hostname = base::Sys.info()[["nodename"]])
[17:41:19.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:19.767]                             info)
[17:41:19.767]                           info <- base::paste(info, collapse = "; ")
[17:41:19.767]                           if (!has_future) {
[17:41:19.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:19.767]                               info)
[17:41:19.767]                           }
[17:41:19.767]                           else {
[17:41:19.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:19.767]                               info, version)
[17:41:19.767]                           }
[17:41:19.767]                           base::stop(msg)
[17:41:19.767]                         }
[17:41:19.767]                       })
[17:41:19.767]                     }
[17:41:19.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:19.767]                     base::options(mc.cores = 1L)
[17:41:19.767]                   }
[17:41:19.767]                   options(future.plan = NULL)
[17:41:19.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:19.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:19.767]                 }
[17:41:19.767]                 ...future.workdir <- getwd()
[17:41:19.767]             }
[17:41:19.767]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:19.767]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:19.767]         }
[17:41:19.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:19.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:19.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:19.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:19.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:19.767]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:19.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:19.767]             base::names(...future.oldOptions))
[17:41:19.767]     }
[17:41:19.767]     if (FALSE) {
[17:41:19.767]     }
[17:41:19.767]     else {
[17:41:19.767]         if (FALSE) {
[17:41:19.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:19.767]                 open = "w")
[17:41:19.767]         }
[17:41:19.767]         else {
[17:41:19.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:19.767]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:19.767]         }
[17:41:19.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:19.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:19.767]             base::sink(type = "output", split = FALSE)
[17:41:19.767]             base::close(...future.stdout)
[17:41:19.767]         }, add = TRUE)
[17:41:19.767]     }
[17:41:19.767]     ...future.frame <- base::sys.nframe()
[17:41:19.767]     ...future.conditions <- base::list()
[17:41:19.767]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:19.767]     if (FALSE) {
[17:41:19.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:19.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:19.767]     }
[17:41:19.767]     ...future.result <- base::tryCatch({
[17:41:19.767]         base::withCallingHandlers({
[17:41:19.767]             ...future.value <- base::withVisible(base::local({
[17:41:19.767]                 ...future.makeSendCondition <- local({
[17:41:19.767]                   sendCondition <- NULL
[17:41:19.767]                   function(frame = 1L) {
[17:41:19.767]                     if (is.function(sendCondition)) 
[17:41:19.767]                       return(sendCondition)
[17:41:19.767]                     ns <- getNamespace("parallel")
[17:41:19.767]                     if (exists("sendData", mode = "function", 
[17:41:19.767]                       envir = ns)) {
[17:41:19.767]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:19.767]                         envir = ns)
[17:41:19.767]                       envir <- sys.frame(frame)
[17:41:19.767]                       master <- NULL
[17:41:19.767]                       while (!identical(envir, .GlobalEnv) && 
[17:41:19.767]                         !identical(envir, emptyenv())) {
[17:41:19.767]                         if (exists("master", mode = "list", envir = envir, 
[17:41:19.767]                           inherits = FALSE)) {
[17:41:19.767]                           master <- get("master", mode = "list", 
[17:41:19.767]                             envir = envir, inherits = FALSE)
[17:41:19.767]                           if (inherits(master, c("SOCKnode", 
[17:41:19.767]                             "SOCK0node"))) {
[17:41:19.767]                             sendCondition <<- function(cond) {
[17:41:19.767]                               data <- list(type = "VALUE", value = cond, 
[17:41:19.767]                                 success = TRUE)
[17:41:19.767]                               parallel_sendData(master, data)
[17:41:19.767]                             }
[17:41:19.767]                             return(sendCondition)
[17:41:19.767]                           }
[17:41:19.767]                         }
[17:41:19.767]                         frame <- frame + 1L
[17:41:19.767]                         envir <- sys.frame(frame)
[17:41:19.767]                       }
[17:41:19.767]                     }
[17:41:19.767]                     sendCondition <<- function(cond) NULL
[17:41:19.767]                   }
[17:41:19.767]                 })
[17:41:19.767]                 withCallingHandlers({
[17:41:19.767]                   {
[17:41:19.767]                     do.call(function(...) {
[17:41:19.767]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:19.767]                       if (!identical(...future.globals.maxSize.org, 
[17:41:19.767]                         ...future.globals.maxSize)) {
[17:41:19.767]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:19.767]                         on.exit(options(oopts), add = TRUE)
[17:41:19.767]                       }
[17:41:19.767]                       {
[17:41:19.767]                         lapply(seq_along(...future.elements_ii), 
[17:41:19.767]                           FUN = function(jj) {
[17:41:19.767]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:19.767]                             ...future.FUN(...future.X_jj, ...)
[17:41:19.767]                           })
[17:41:19.767]                       }
[17:41:19.767]                     }, args = future.call.arguments)
[17:41:19.767]                   }
[17:41:19.767]                 }, immediateCondition = function(cond) {
[17:41:19.767]                   sendCondition <- ...future.makeSendCondition()
[17:41:19.767]                   sendCondition(cond)
[17:41:19.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.767]                   {
[17:41:19.767]                     inherits <- base::inherits
[17:41:19.767]                     invokeRestart <- base::invokeRestart
[17:41:19.767]                     is.null <- base::is.null
[17:41:19.767]                     muffled <- FALSE
[17:41:19.767]                     if (inherits(cond, "message")) {
[17:41:19.767]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:19.767]                       if (muffled) 
[17:41:19.767]                         invokeRestart("muffleMessage")
[17:41:19.767]                     }
[17:41:19.767]                     else if (inherits(cond, "warning")) {
[17:41:19.767]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:19.767]                       if (muffled) 
[17:41:19.767]                         invokeRestart("muffleWarning")
[17:41:19.767]                     }
[17:41:19.767]                     else if (inherits(cond, "condition")) {
[17:41:19.767]                       if (!is.null(pattern)) {
[17:41:19.767]                         computeRestarts <- base::computeRestarts
[17:41:19.767]                         grepl <- base::grepl
[17:41:19.767]                         restarts <- computeRestarts(cond)
[17:41:19.767]                         for (restart in restarts) {
[17:41:19.767]                           name <- restart$name
[17:41:19.767]                           if (is.null(name)) 
[17:41:19.767]                             next
[17:41:19.767]                           if (!grepl(pattern, name)) 
[17:41:19.767]                             next
[17:41:19.767]                           invokeRestart(restart)
[17:41:19.767]                           muffled <- TRUE
[17:41:19.767]                           break
[17:41:19.767]                         }
[17:41:19.767]                       }
[17:41:19.767]                     }
[17:41:19.767]                     invisible(muffled)
[17:41:19.767]                   }
[17:41:19.767]                   muffleCondition(cond)
[17:41:19.767]                 })
[17:41:19.767]             }))
[17:41:19.767]             future::FutureResult(value = ...future.value$value, 
[17:41:19.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:19.767]                   ...future.rng), globalenv = if (FALSE) 
[17:41:19.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:19.767]                     ...future.globalenv.names))
[17:41:19.767]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:19.767]         }, condition = base::local({
[17:41:19.767]             c <- base::c
[17:41:19.767]             inherits <- base::inherits
[17:41:19.767]             invokeRestart <- base::invokeRestart
[17:41:19.767]             length <- base::length
[17:41:19.767]             list <- base::list
[17:41:19.767]             seq.int <- base::seq.int
[17:41:19.767]             signalCondition <- base::signalCondition
[17:41:19.767]             sys.calls <- base::sys.calls
[17:41:19.767]             `[[` <- base::`[[`
[17:41:19.767]             `+` <- base::`+`
[17:41:19.767]             `<<-` <- base::`<<-`
[17:41:19.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:19.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:19.767]                   3L)]
[17:41:19.767]             }
[17:41:19.767]             function(cond) {
[17:41:19.767]                 is_error <- inherits(cond, "error")
[17:41:19.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:19.767]                   NULL)
[17:41:19.767]                 if (is_error) {
[17:41:19.767]                   sessionInformation <- function() {
[17:41:19.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:19.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:19.767]                       search = base::search(), system = base::Sys.info())
[17:41:19.767]                   }
[17:41:19.767]                   ...future.conditions[[length(...future.conditions) + 
[17:41:19.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:19.767]                     cond$call), session = sessionInformation(), 
[17:41:19.767]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:19.767]                   signalCondition(cond)
[17:41:19.767]                 }
[17:41:19.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:19.767]                 "immediateCondition"))) {
[17:41:19.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:19.767]                   ...future.conditions[[length(...future.conditions) + 
[17:41:19.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:19.767]                   if (TRUE && !signal) {
[17:41:19.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.767]                     {
[17:41:19.767]                       inherits <- base::inherits
[17:41:19.767]                       invokeRestart <- base::invokeRestart
[17:41:19.767]                       is.null <- base::is.null
[17:41:19.767]                       muffled <- FALSE
[17:41:19.767]                       if (inherits(cond, "message")) {
[17:41:19.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:19.767]                         if (muffled) 
[17:41:19.767]                           invokeRestart("muffleMessage")
[17:41:19.767]                       }
[17:41:19.767]                       else if (inherits(cond, "warning")) {
[17:41:19.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:19.767]                         if (muffled) 
[17:41:19.767]                           invokeRestart("muffleWarning")
[17:41:19.767]                       }
[17:41:19.767]                       else if (inherits(cond, "condition")) {
[17:41:19.767]                         if (!is.null(pattern)) {
[17:41:19.767]                           computeRestarts <- base::computeRestarts
[17:41:19.767]                           grepl <- base::grepl
[17:41:19.767]                           restarts <- computeRestarts(cond)
[17:41:19.767]                           for (restart in restarts) {
[17:41:19.767]                             name <- restart$name
[17:41:19.767]                             if (is.null(name)) 
[17:41:19.767]                               next
[17:41:19.767]                             if (!grepl(pattern, name)) 
[17:41:19.767]                               next
[17:41:19.767]                             invokeRestart(restart)
[17:41:19.767]                             muffled <- TRUE
[17:41:19.767]                             break
[17:41:19.767]                           }
[17:41:19.767]                         }
[17:41:19.767]                       }
[17:41:19.767]                       invisible(muffled)
[17:41:19.767]                     }
[17:41:19.767]                     muffleCondition(cond, pattern = "^muffle")
[17:41:19.767]                   }
[17:41:19.767]                 }
[17:41:19.767]                 else {
[17:41:19.767]                   if (TRUE) {
[17:41:19.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.767]                     {
[17:41:19.767]                       inherits <- base::inherits
[17:41:19.767]                       invokeRestart <- base::invokeRestart
[17:41:19.767]                       is.null <- base::is.null
[17:41:19.767]                       muffled <- FALSE
[17:41:19.767]                       if (inherits(cond, "message")) {
[17:41:19.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:19.767]                         if (muffled) 
[17:41:19.767]                           invokeRestart("muffleMessage")
[17:41:19.767]                       }
[17:41:19.767]                       else if (inherits(cond, "warning")) {
[17:41:19.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:19.767]                         if (muffled) 
[17:41:19.767]                           invokeRestart("muffleWarning")
[17:41:19.767]                       }
[17:41:19.767]                       else if (inherits(cond, "condition")) {
[17:41:19.767]                         if (!is.null(pattern)) {
[17:41:19.767]                           computeRestarts <- base::computeRestarts
[17:41:19.767]                           grepl <- base::grepl
[17:41:19.767]                           restarts <- computeRestarts(cond)
[17:41:19.767]                           for (restart in restarts) {
[17:41:19.767]                             name <- restart$name
[17:41:19.767]                             if (is.null(name)) 
[17:41:19.767]                               next
[17:41:19.767]                             if (!grepl(pattern, name)) 
[17:41:19.767]                               next
[17:41:19.767]                             invokeRestart(restart)
[17:41:19.767]                             muffled <- TRUE
[17:41:19.767]                             break
[17:41:19.767]                           }
[17:41:19.767]                         }
[17:41:19.767]                       }
[17:41:19.767]                       invisible(muffled)
[17:41:19.767]                     }
[17:41:19.767]                     muffleCondition(cond, pattern = "^muffle")
[17:41:19.767]                   }
[17:41:19.767]                 }
[17:41:19.767]             }
[17:41:19.767]         }))
[17:41:19.767]     }, error = function(ex) {
[17:41:19.767]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:19.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:19.767]                 ...future.rng), started = ...future.startTime, 
[17:41:19.767]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:19.767]             version = "1.8"), class = "FutureResult")
[17:41:19.767]     }, finally = {
[17:41:19.767]         if (!identical(...future.workdir, getwd())) 
[17:41:19.767]             setwd(...future.workdir)
[17:41:19.767]         {
[17:41:19.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:19.767]                 ...future.oldOptions$nwarnings <- NULL
[17:41:19.767]             }
[17:41:19.767]             base::options(...future.oldOptions)
[17:41:19.767]             if (.Platform$OS.type == "windows") {
[17:41:19.767]                 old_names <- names(...future.oldEnvVars)
[17:41:19.767]                 envs <- base::Sys.getenv()
[17:41:19.767]                 names <- names(envs)
[17:41:19.767]                 common <- intersect(names, old_names)
[17:41:19.767]                 added <- setdiff(names, old_names)
[17:41:19.767]                 removed <- setdiff(old_names, names)
[17:41:19.767]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:19.767]                   envs[common]]
[17:41:19.767]                 NAMES <- toupper(changed)
[17:41:19.767]                 args <- list()
[17:41:19.767]                 for (kk in seq_along(NAMES)) {
[17:41:19.767]                   name <- changed[[kk]]
[17:41:19.767]                   NAME <- NAMES[[kk]]
[17:41:19.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.767]                     next
[17:41:19.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:19.767]                 }
[17:41:19.767]                 NAMES <- toupper(added)
[17:41:19.767]                 for (kk in seq_along(NAMES)) {
[17:41:19.767]                   name <- added[[kk]]
[17:41:19.767]                   NAME <- NAMES[[kk]]
[17:41:19.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.767]                     next
[17:41:19.767]                   args[[name]] <- ""
[17:41:19.767]                 }
[17:41:19.767]                 NAMES <- toupper(removed)
[17:41:19.767]                 for (kk in seq_along(NAMES)) {
[17:41:19.767]                   name <- removed[[kk]]
[17:41:19.767]                   NAME <- NAMES[[kk]]
[17:41:19.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.767]                     next
[17:41:19.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:19.767]                 }
[17:41:19.767]                 if (length(args) > 0) 
[17:41:19.767]                   base::do.call(base::Sys.setenv, args = args)
[17:41:19.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:19.767]             }
[17:41:19.767]             else {
[17:41:19.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:19.767]             }
[17:41:19.767]             {
[17:41:19.767]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:19.767]                   0L) {
[17:41:19.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:19.767]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:19.767]                   base::options(opts)
[17:41:19.767]                 }
[17:41:19.767]                 {
[17:41:19.767]                   {
[17:41:19.767]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:19.767]                     NULL
[17:41:19.767]                   }
[17:41:19.767]                   options(future.plan = NULL)
[17:41:19.767]                   if (is.na(NA_character_)) 
[17:41:19.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:19.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:19.767]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:19.767]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:19.767]                     envir = parent.frame()) 
[17:41:19.767]                   {
[17:41:19.767]                     if (is.function(workers)) 
[17:41:19.767]                       workers <- workers()
[17:41:19.767]                     workers <- structure(as.integer(workers), 
[17:41:19.767]                       class = class(workers))
[17:41:19.767]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:19.767]                       workers >= 1)
[17:41:19.767]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:19.767]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:19.767]                     }
[17:41:19.767]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:19.767]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:19.767]                       envir = envir)
[17:41:19.767]                     if (!future$lazy) 
[17:41:19.767]                       future <- run(future)
[17:41:19.767]                     invisible(future)
[17:41:19.767]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:19.767]                 }
[17:41:19.767]             }
[17:41:19.767]         }
[17:41:19.767]     })
[17:41:19.767]     if (TRUE) {
[17:41:19.767]         base::sink(type = "output", split = FALSE)
[17:41:19.767]         if (FALSE) {
[17:41:19.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:19.767]         }
[17:41:19.767]         else {
[17:41:19.767]             ...future.result["stdout"] <- base::list(NULL)
[17:41:19.767]         }
[17:41:19.767]         base::close(...future.stdout)
[17:41:19.767]         ...future.stdout <- NULL
[17:41:19.767]     }
[17:41:19.767]     ...future.result$conditions <- ...future.conditions
[17:41:19.767]     ...future.result$finished <- base::Sys.time()
[17:41:19.767]     ...future.result
[17:41:19.767] }
[17:41:19.771] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:41:19.771] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:41:19.772] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:41:19.772] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:19.772] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:19.772] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:41:19.773] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:41:19.773] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:19.774] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:19.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:19.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:19.774] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:41:19.775] MultisessionFuture started
[17:41:19.775] - Launch lazy future ... done
[17:41:19.775] run() for ‘MultisessionFuture’ ... done
[17:41:19.776] Created future:
[17:41:19.776] MultisessionFuture:
[17:41:19.776] Label: ‘future_lapply-1’
[17:41:19.776] Expression:
[17:41:19.776] {
[17:41:19.776]     do.call(function(...) {
[17:41:19.776]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:19.776]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:19.776]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:19.776]             on.exit(options(oopts), add = TRUE)
[17:41:19.776]         }
[17:41:19.776]         {
[17:41:19.776]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:19.776]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:19.776]                 ...future.FUN(...future.X_jj, ...)
[17:41:19.776]             })
[17:41:19.776]         }
[17:41:19.776]     }, args = future.call.arguments)
[17:41:19.776] }
[17:41:19.776] Lazy evaluation: FALSE
[17:41:19.776] Asynchronous evaluation: TRUE
[17:41:19.776] Local evaluation: TRUE
[17:41:19.776] Environment: R_GlobalEnv
[17:41:19.776] Capture standard output: FALSE
[17:41:19.776] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:19.776] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:19.776] Packages: <none>
[17:41:19.776] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:19.776] Resolved: FALSE
[17:41:19.776] Value: <not collected>
[17:41:19.776] Conditions captured: <none>
[17:41:19.776] Early signaling: FALSE
[17:41:19.776] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:19.776] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:19.788] Chunk #1 of 2 ... DONE
[17:41:19.788] Chunk #2 of 2 ...
[17:41:19.788]  - Finding globals in 'X' for chunk #2 ...
[17:41:19.788] getGlobalsAndPackages() ...
[17:41:19.789] Searching for globals...
[17:41:19.789] 
[17:41:19.789] Searching for globals ... DONE
[17:41:19.789] - globals: [0] <none>
[17:41:19.789] getGlobalsAndPackages() ... DONE
[17:41:19.789]    + additional globals found: [n=0] 
[17:41:19.790]    + additional namespaces needed: [n=0] 
[17:41:19.790]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:19.790]  - seeds: <none>
[17:41:19.790] getGlobalsAndPackages() ...
[17:41:19.790] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:19.790] Resolving globals: FALSE
[17:41:19.790] Tweak future expression to call with '...' arguments ...
[17:41:19.790] {
[17:41:19.790]     do.call(function(...) {
[17:41:19.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:19.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:19.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:19.790]             on.exit(options(oopts), add = TRUE)
[17:41:19.790]         }
[17:41:19.790]         {
[17:41:19.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:19.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:19.790]                 ...future.FUN(...future.X_jj, ...)
[17:41:19.790]             })
[17:41:19.790]         }
[17:41:19.790]     }, args = future.call.arguments)
[17:41:19.790] }
[17:41:19.791] Tweak future expression to call with '...' arguments ... DONE
[17:41:19.791] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:19.791] 
[17:41:19.791] getGlobalsAndPackages() ... DONE
[17:41:19.792] run() for ‘Future’ ...
[17:41:19.792] - state: ‘created’
[17:41:19.792] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:19.808] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:19.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:19.808]   - Field: ‘node’
[17:41:19.808]   - Field: ‘label’
[17:41:19.808]   - Field: ‘local’
[17:41:19.808]   - Field: ‘owner’
[17:41:19.808]   - Field: ‘envir’
[17:41:19.809]   - Field: ‘workers’
[17:41:19.809]   - Field: ‘packages’
[17:41:19.809]   - Field: ‘gc’
[17:41:19.809]   - Field: ‘conditions’
[17:41:19.809]   - Field: ‘persistent’
[17:41:19.809]   - Field: ‘expr’
[17:41:19.809]   - Field: ‘uuid’
[17:41:19.809]   - Field: ‘seed’
[17:41:19.809]   - Field: ‘version’
[17:41:19.810]   - Field: ‘result’
[17:41:19.810]   - Field: ‘asynchronous’
[17:41:19.810]   - Field: ‘calls’
[17:41:19.810]   - Field: ‘globals’
[17:41:19.810]   - Field: ‘stdout’
[17:41:19.810]   - Field: ‘earlySignal’
[17:41:19.810]   - Field: ‘lazy’
[17:41:19.810]   - Field: ‘state’
[17:41:19.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:19.811] - Launch lazy future ...
[17:41:19.811] Packages needed by the future expression (n = 0): <none>
[17:41:19.811] Packages needed by future strategies (n = 0): <none>
[17:41:19.812] {
[17:41:19.812]     {
[17:41:19.812]         {
[17:41:19.812]             ...future.startTime <- base::Sys.time()
[17:41:19.812]             {
[17:41:19.812]                 {
[17:41:19.812]                   {
[17:41:19.812]                     {
[17:41:19.812]                       base::local({
[17:41:19.812]                         has_future <- base::requireNamespace("future", 
[17:41:19.812]                           quietly = TRUE)
[17:41:19.812]                         if (has_future) {
[17:41:19.812]                           ns <- base::getNamespace("future")
[17:41:19.812]                           version <- ns[[".package"]][["version"]]
[17:41:19.812]                           if (is.null(version)) 
[17:41:19.812]                             version <- utils::packageVersion("future")
[17:41:19.812]                         }
[17:41:19.812]                         else {
[17:41:19.812]                           version <- NULL
[17:41:19.812]                         }
[17:41:19.812]                         if (!has_future || version < "1.8.0") {
[17:41:19.812]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:19.812]                             "", base::R.version$version.string), 
[17:41:19.812]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:19.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:19.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:19.812]                               "release", "version")], collapse = " "), 
[17:41:19.812]                             hostname = base::Sys.info()[["nodename"]])
[17:41:19.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:19.812]                             info)
[17:41:19.812]                           info <- base::paste(info, collapse = "; ")
[17:41:19.812]                           if (!has_future) {
[17:41:19.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:19.812]                               info)
[17:41:19.812]                           }
[17:41:19.812]                           else {
[17:41:19.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:19.812]                               info, version)
[17:41:19.812]                           }
[17:41:19.812]                           base::stop(msg)
[17:41:19.812]                         }
[17:41:19.812]                       })
[17:41:19.812]                     }
[17:41:19.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:19.812]                     base::options(mc.cores = 1L)
[17:41:19.812]                   }
[17:41:19.812]                   options(future.plan = NULL)
[17:41:19.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:19.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:19.812]                 }
[17:41:19.812]                 ...future.workdir <- getwd()
[17:41:19.812]             }
[17:41:19.812]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:19.812]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:19.812]         }
[17:41:19.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:19.812]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:19.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:19.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:19.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:19.812]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:19.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:19.812]             base::names(...future.oldOptions))
[17:41:19.812]     }
[17:41:19.812]     if (FALSE) {
[17:41:19.812]     }
[17:41:19.812]     else {
[17:41:19.812]         if (FALSE) {
[17:41:19.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:19.812]                 open = "w")
[17:41:19.812]         }
[17:41:19.812]         else {
[17:41:19.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:19.812]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:19.812]         }
[17:41:19.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:19.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:19.812]             base::sink(type = "output", split = FALSE)
[17:41:19.812]             base::close(...future.stdout)
[17:41:19.812]         }, add = TRUE)
[17:41:19.812]     }
[17:41:19.812]     ...future.frame <- base::sys.nframe()
[17:41:19.812]     ...future.conditions <- base::list()
[17:41:19.812]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:19.812]     if (FALSE) {
[17:41:19.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:19.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:19.812]     }
[17:41:19.812]     ...future.result <- base::tryCatch({
[17:41:19.812]         base::withCallingHandlers({
[17:41:19.812]             ...future.value <- base::withVisible(base::local({
[17:41:19.812]                 ...future.makeSendCondition <- local({
[17:41:19.812]                   sendCondition <- NULL
[17:41:19.812]                   function(frame = 1L) {
[17:41:19.812]                     if (is.function(sendCondition)) 
[17:41:19.812]                       return(sendCondition)
[17:41:19.812]                     ns <- getNamespace("parallel")
[17:41:19.812]                     if (exists("sendData", mode = "function", 
[17:41:19.812]                       envir = ns)) {
[17:41:19.812]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:19.812]                         envir = ns)
[17:41:19.812]                       envir <- sys.frame(frame)
[17:41:19.812]                       master <- NULL
[17:41:19.812]                       while (!identical(envir, .GlobalEnv) && 
[17:41:19.812]                         !identical(envir, emptyenv())) {
[17:41:19.812]                         if (exists("master", mode = "list", envir = envir, 
[17:41:19.812]                           inherits = FALSE)) {
[17:41:19.812]                           master <- get("master", mode = "list", 
[17:41:19.812]                             envir = envir, inherits = FALSE)
[17:41:19.812]                           if (inherits(master, c("SOCKnode", 
[17:41:19.812]                             "SOCK0node"))) {
[17:41:19.812]                             sendCondition <<- function(cond) {
[17:41:19.812]                               data <- list(type = "VALUE", value = cond, 
[17:41:19.812]                                 success = TRUE)
[17:41:19.812]                               parallel_sendData(master, data)
[17:41:19.812]                             }
[17:41:19.812]                             return(sendCondition)
[17:41:19.812]                           }
[17:41:19.812]                         }
[17:41:19.812]                         frame <- frame + 1L
[17:41:19.812]                         envir <- sys.frame(frame)
[17:41:19.812]                       }
[17:41:19.812]                     }
[17:41:19.812]                     sendCondition <<- function(cond) NULL
[17:41:19.812]                   }
[17:41:19.812]                 })
[17:41:19.812]                 withCallingHandlers({
[17:41:19.812]                   {
[17:41:19.812]                     do.call(function(...) {
[17:41:19.812]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:19.812]                       if (!identical(...future.globals.maxSize.org, 
[17:41:19.812]                         ...future.globals.maxSize)) {
[17:41:19.812]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:19.812]                         on.exit(options(oopts), add = TRUE)
[17:41:19.812]                       }
[17:41:19.812]                       {
[17:41:19.812]                         lapply(seq_along(...future.elements_ii), 
[17:41:19.812]                           FUN = function(jj) {
[17:41:19.812]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:19.812]                             ...future.FUN(...future.X_jj, ...)
[17:41:19.812]                           })
[17:41:19.812]                       }
[17:41:19.812]                     }, args = future.call.arguments)
[17:41:19.812]                   }
[17:41:19.812]                 }, immediateCondition = function(cond) {
[17:41:19.812]                   sendCondition <- ...future.makeSendCondition()
[17:41:19.812]                   sendCondition(cond)
[17:41:19.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.812]                   {
[17:41:19.812]                     inherits <- base::inherits
[17:41:19.812]                     invokeRestart <- base::invokeRestart
[17:41:19.812]                     is.null <- base::is.null
[17:41:19.812]                     muffled <- FALSE
[17:41:19.812]                     if (inherits(cond, "message")) {
[17:41:19.812]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:19.812]                       if (muffled) 
[17:41:19.812]                         invokeRestart("muffleMessage")
[17:41:19.812]                     }
[17:41:19.812]                     else if (inherits(cond, "warning")) {
[17:41:19.812]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:19.812]                       if (muffled) 
[17:41:19.812]                         invokeRestart("muffleWarning")
[17:41:19.812]                     }
[17:41:19.812]                     else if (inherits(cond, "condition")) {
[17:41:19.812]                       if (!is.null(pattern)) {
[17:41:19.812]                         computeRestarts <- base::computeRestarts
[17:41:19.812]                         grepl <- base::grepl
[17:41:19.812]                         restarts <- computeRestarts(cond)
[17:41:19.812]                         for (restart in restarts) {
[17:41:19.812]                           name <- restart$name
[17:41:19.812]                           if (is.null(name)) 
[17:41:19.812]                             next
[17:41:19.812]                           if (!grepl(pattern, name)) 
[17:41:19.812]                             next
[17:41:19.812]                           invokeRestart(restart)
[17:41:19.812]                           muffled <- TRUE
[17:41:19.812]                           break
[17:41:19.812]                         }
[17:41:19.812]                       }
[17:41:19.812]                     }
[17:41:19.812]                     invisible(muffled)
[17:41:19.812]                   }
[17:41:19.812]                   muffleCondition(cond)
[17:41:19.812]                 })
[17:41:19.812]             }))
[17:41:19.812]             future::FutureResult(value = ...future.value$value, 
[17:41:19.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:19.812]                   ...future.rng), globalenv = if (FALSE) 
[17:41:19.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:19.812]                     ...future.globalenv.names))
[17:41:19.812]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:19.812]         }, condition = base::local({
[17:41:19.812]             c <- base::c
[17:41:19.812]             inherits <- base::inherits
[17:41:19.812]             invokeRestart <- base::invokeRestart
[17:41:19.812]             length <- base::length
[17:41:19.812]             list <- base::list
[17:41:19.812]             seq.int <- base::seq.int
[17:41:19.812]             signalCondition <- base::signalCondition
[17:41:19.812]             sys.calls <- base::sys.calls
[17:41:19.812]             `[[` <- base::`[[`
[17:41:19.812]             `+` <- base::`+`
[17:41:19.812]             `<<-` <- base::`<<-`
[17:41:19.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:19.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:19.812]                   3L)]
[17:41:19.812]             }
[17:41:19.812]             function(cond) {
[17:41:19.812]                 is_error <- inherits(cond, "error")
[17:41:19.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:19.812]                   NULL)
[17:41:19.812]                 if (is_error) {
[17:41:19.812]                   sessionInformation <- function() {
[17:41:19.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:19.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:19.812]                       search = base::search(), system = base::Sys.info())
[17:41:19.812]                   }
[17:41:19.812]                   ...future.conditions[[length(...future.conditions) + 
[17:41:19.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:19.812]                     cond$call), session = sessionInformation(), 
[17:41:19.812]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:19.812]                   signalCondition(cond)
[17:41:19.812]                 }
[17:41:19.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:19.812]                 "immediateCondition"))) {
[17:41:19.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:19.812]                   ...future.conditions[[length(...future.conditions) + 
[17:41:19.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:19.812]                   if (TRUE && !signal) {
[17:41:19.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.812]                     {
[17:41:19.812]                       inherits <- base::inherits
[17:41:19.812]                       invokeRestart <- base::invokeRestart
[17:41:19.812]                       is.null <- base::is.null
[17:41:19.812]                       muffled <- FALSE
[17:41:19.812]                       if (inherits(cond, "message")) {
[17:41:19.812]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:19.812]                         if (muffled) 
[17:41:19.812]                           invokeRestart("muffleMessage")
[17:41:19.812]                       }
[17:41:19.812]                       else if (inherits(cond, "warning")) {
[17:41:19.812]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:19.812]                         if (muffled) 
[17:41:19.812]                           invokeRestart("muffleWarning")
[17:41:19.812]                       }
[17:41:19.812]                       else if (inherits(cond, "condition")) {
[17:41:19.812]                         if (!is.null(pattern)) {
[17:41:19.812]                           computeRestarts <- base::computeRestarts
[17:41:19.812]                           grepl <- base::grepl
[17:41:19.812]                           restarts <- computeRestarts(cond)
[17:41:19.812]                           for (restart in restarts) {
[17:41:19.812]                             name <- restart$name
[17:41:19.812]                             if (is.null(name)) 
[17:41:19.812]                               next
[17:41:19.812]                             if (!grepl(pattern, name)) 
[17:41:19.812]                               next
[17:41:19.812]                             invokeRestart(restart)
[17:41:19.812]                             muffled <- TRUE
[17:41:19.812]                             break
[17:41:19.812]                           }
[17:41:19.812]                         }
[17:41:19.812]                       }
[17:41:19.812]                       invisible(muffled)
[17:41:19.812]                     }
[17:41:19.812]                     muffleCondition(cond, pattern = "^muffle")
[17:41:19.812]                   }
[17:41:19.812]                 }
[17:41:19.812]                 else {
[17:41:19.812]                   if (TRUE) {
[17:41:19.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:19.812]                     {
[17:41:19.812]                       inherits <- base::inherits
[17:41:19.812]                       invokeRestart <- base::invokeRestart
[17:41:19.812]                       is.null <- base::is.null
[17:41:19.812]                       muffled <- FALSE
[17:41:19.812]                       if (inherits(cond, "message")) {
[17:41:19.812]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:19.812]                         if (muffled) 
[17:41:19.812]                           invokeRestart("muffleMessage")
[17:41:19.812]                       }
[17:41:19.812]                       else if (inherits(cond, "warning")) {
[17:41:19.812]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:19.812]                         if (muffled) 
[17:41:19.812]                           invokeRestart("muffleWarning")
[17:41:19.812]                       }
[17:41:19.812]                       else if (inherits(cond, "condition")) {
[17:41:19.812]                         if (!is.null(pattern)) {
[17:41:19.812]                           computeRestarts <- base::computeRestarts
[17:41:19.812]                           grepl <- base::grepl
[17:41:19.812]                           restarts <- computeRestarts(cond)
[17:41:19.812]                           for (restart in restarts) {
[17:41:19.812]                             name <- restart$name
[17:41:19.812]                             if (is.null(name)) 
[17:41:19.812]                               next
[17:41:19.812]                             if (!grepl(pattern, name)) 
[17:41:19.812]                               next
[17:41:19.812]                             invokeRestart(restart)
[17:41:19.812]                             muffled <- TRUE
[17:41:19.812]                             break
[17:41:19.812]                           }
[17:41:19.812]                         }
[17:41:19.812]                       }
[17:41:19.812]                       invisible(muffled)
[17:41:19.812]                     }
[17:41:19.812]                     muffleCondition(cond, pattern = "^muffle")
[17:41:19.812]                   }
[17:41:19.812]                 }
[17:41:19.812]             }
[17:41:19.812]         }))
[17:41:19.812]     }, error = function(ex) {
[17:41:19.812]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:19.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:19.812]                 ...future.rng), started = ...future.startTime, 
[17:41:19.812]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:19.812]             version = "1.8"), class = "FutureResult")
[17:41:19.812]     }, finally = {
[17:41:19.812]         if (!identical(...future.workdir, getwd())) 
[17:41:19.812]             setwd(...future.workdir)
[17:41:19.812]         {
[17:41:19.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:19.812]                 ...future.oldOptions$nwarnings <- NULL
[17:41:19.812]             }
[17:41:19.812]             base::options(...future.oldOptions)
[17:41:19.812]             if (.Platform$OS.type == "windows") {
[17:41:19.812]                 old_names <- names(...future.oldEnvVars)
[17:41:19.812]                 envs <- base::Sys.getenv()
[17:41:19.812]                 names <- names(envs)
[17:41:19.812]                 common <- intersect(names, old_names)
[17:41:19.812]                 added <- setdiff(names, old_names)
[17:41:19.812]                 removed <- setdiff(old_names, names)
[17:41:19.812]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:19.812]                   envs[common]]
[17:41:19.812]                 NAMES <- toupper(changed)
[17:41:19.812]                 args <- list()
[17:41:19.812]                 for (kk in seq_along(NAMES)) {
[17:41:19.812]                   name <- changed[[kk]]
[17:41:19.812]                   NAME <- NAMES[[kk]]
[17:41:19.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.812]                     next
[17:41:19.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:19.812]                 }
[17:41:19.812]                 NAMES <- toupper(added)
[17:41:19.812]                 for (kk in seq_along(NAMES)) {
[17:41:19.812]                   name <- added[[kk]]
[17:41:19.812]                   NAME <- NAMES[[kk]]
[17:41:19.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.812]                     next
[17:41:19.812]                   args[[name]] <- ""
[17:41:19.812]                 }
[17:41:19.812]                 NAMES <- toupper(removed)
[17:41:19.812]                 for (kk in seq_along(NAMES)) {
[17:41:19.812]                   name <- removed[[kk]]
[17:41:19.812]                   NAME <- NAMES[[kk]]
[17:41:19.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:19.812]                     next
[17:41:19.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:19.812]                 }
[17:41:19.812]                 if (length(args) > 0) 
[17:41:19.812]                   base::do.call(base::Sys.setenv, args = args)
[17:41:19.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:19.812]             }
[17:41:19.812]             else {
[17:41:19.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:19.812]             }
[17:41:19.812]             {
[17:41:19.812]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:19.812]                   0L) {
[17:41:19.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:19.812]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:19.812]                   base::options(opts)
[17:41:19.812]                 }
[17:41:19.812]                 {
[17:41:19.812]                   {
[17:41:19.812]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:19.812]                     NULL
[17:41:19.812]                   }
[17:41:19.812]                   options(future.plan = NULL)
[17:41:19.812]                   if (is.na(NA_character_)) 
[17:41:19.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:19.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:19.812]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:19.812]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:19.812]                     envir = parent.frame()) 
[17:41:19.812]                   {
[17:41:19.812]                     if (is.function(workers)) 
[17:41:19.812]                       workers <- workers()
[17:41:19.812]                     workers <- structure(as.integer(workers), 
[17:41:19.812]                       class = class(workers))
[17:41:19.812]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:19.812]                       workers >= 1)
[17:41:19.812]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:19.812]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:19.812]                     }
[17:41:19.812]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:19.812]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:19.812]                       envir = envir)
[17:41:19.812]                     if (!future$lazy) 
[17:41:19.812]                       future <- run(future)
[17:41:19.812]                     invisible(future)
[17:41:19.812]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:19.812]                 }
[17:41:19.812]             }
[17:41:19.812]         }
[17:41:19.812]     })
[17:41:19.812]     if (TRUE) {
[17:41:19.812]         base::sink(type = "output", split = FALSE)
[17:41:19.812]         if (FALSE) {
[17:41:19.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:19.812]         }
[17:41:19.812]         else {
[17:41:19.812]             ...future.result["stdout"] <- base::list(NULL)
[17:41:19.812]         }
[17:41:19.812]         base::close(...future.stdout)
[17:41:19.812]         ...future.stdout <- NULL
[17:41:19.812]     }
[17:41:19.812]     ...future.result$conditions <- ...future.conditions
[17:41:19.812]     ...future.result$finished <- base::Sys.time()
[17:41:19.812]     ...future.result
[17:41:19.812] }
[17:41:19.883] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:41:19.883] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:41:19.884] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:41:19.884] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:19.885] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:19.885] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:41:19.885] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:41:19.885] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:19.886] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:19.886] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:19.886] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:19.886] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:41:19.887] MultisessionFuture started
[17:41:19.887] - Launch lazy future ... done
[17:41:19.887] run() for ‘MultisessionFuture’ ... done
[17:41:19.887] Created future:
[17:41:19.888] MultisessionFuture:
[17:41:19.888] Label: ‘future_lapply-2’
[17:41:19.888] Expression:
[17:41:19.888] {
[17:41:19.888]     do.call(function(...) {
[17:41:19.888]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:19.888]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:19.888]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:19.888]             on.exit(options(oopts), add = TRUE)
[17:41:19.888]         }
[17:41:19.888]         {
[17:41:19.888]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:19.888]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:19.888]                 ...future.FUN(...future.X_jj, ...)
[17:41:19.888]             })
[17:41:19.888]         }
[17:41:19.888]     }, args = future.call.arguments)
[17:41:19.888] }
[17:41:19.888] Lazy evaluation: FALSE
[17:41:19.888] Asynchronous evaluation: TRUE
[17:41:19.888] Local evaluation: TRUE
[17:41:19.888] Environment: R_GlobalEnv
[17:41:19.888] Capture standard output: FALSE
[17:41:19.888] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:19.888] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:19.888] Packages: <none>
[17:41:19.888] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:19.888] Resolved: FALSE
[17:41:19.888] Value: <not collected>
[17:41:19.888] Conditions captured: <none>
[17:41:19.888] Early signaling: FALSE
[17:41:19.888] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:19.888] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:19.899] Chunk #2 of 2 ... DONE
[17:41:19.900] Launching 2 futures (chunks) ... DONE
[17:41:19.900] Resolving 2 futures (chunks) ...
[17:41:19.900] resolve() on list ...
[17:41:19.900]  recursive: 0
[17:41:19.900]  length: 2
[17:41:19.900] 
[17:41:19.976] receiveMessageFromWorker() for ClusterFuture ...
[17:41:19.976] - Validating connection of MultisessionFuture
[17:41:19.977] - received message: FutureResult
[17:41:19.977] - Received FutureResult
[17:41:19.977] - Erased future from FutureRegistry
[17:41:19.977] result() for ClusterFuture ...
[17:41:19.977] - result already collected: FutureResult
[17:41:19.977] result() for ClusterFuture ... done
[17:41:19.977] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:19.977] Future #2
[17:41:19.978] result() for ClusterFuture ...
[17:41:19.978] - result already collected: FutureResult
[17:41:19.978] result() for ClusterFuture ... done
[17:41:19.978] result() for ClusterFuture ...
[17:41:19.978] - result already collected: FutureResult
[17:41:19.978] result() for ClusterFuture ... done
[17:41:19.978] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:19.978] - nx: 2
[17:41:19.978] - relay: TRUE
[17:41:19.978] - stdout: TRUE
[17:41:19.979] - signal: TRUE
[17:41:19.979] - resignal: FALSE
[17:41:19.979] - force: TRUE
[17:41:19.979] - relayed: [n=2] FALSE, FALSE
[17:41:19.979] - queued futures: [n=2] FALSE, FALSE
[17:41:19.979]  - until=1
[17:41:19.979]  - relaying element #1
[17:41:19.979] - relayed: [n=2] FALSE, FALSE
[17:41:19.979] - queued futures: [n=2] FALSE, TRUE
[17:41:19.979] signalConditionsASAP(NULL, pos=2) ... done
[17:41:19.979]  length: 1 (resolved future 2)
[17:41:20.325] receiveMessageFromWorker() for ClusterFuture ...
[17:41:20.325] - Validating connection of MultisessionFuture
[17:41:20.325] - received message: FutureResult
[17:41:20.326] - Received FutureResult
[17:41:20.326] - Erased future from FutureRegistry
[17:41:20.326] result() for ClusterFuture ...
[17:41:20.326] - result already collected: FutureResult
[17:41:20.326] result() for ClusterFuture ... done
[17:41:20.326] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:20.326] Future #1
[17:41:20.326] result() for ClusterFuture ...
[17:41:20.326] - result already collected: FutureResult
[17:41:20.327] result() for ClusterFuture ... done
[17:41:20.327] result() for ClusterFuture ...
[17:41:20.327] - result already collected: FutureResult
[17:41:20.327] result() for ClusterFuture ... done
[17:41:20.327] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:20.327] - nx: 2
[17:41:20.327] - relay: TRUE
[17:41:20.327] - stdout: TRUE
[17:41:20.327] - signal: TRUE
[17:41:20.327] - resignal: FALSE
[17:41:20.327] - force: TRUE
[17:41:20.327] - relayed: [n=2] FALSE, FALSE
[17:41:20.328] - queued futures: [n=2] FALSE, TRUE
[17:41:20.328]  - until=1
[17:41:20.328]  - relaying element #1
[17:41:20.328] result() for ClusterFuture ...
[17:41:20.328] - result already collected: FutureResult
[17:41:20.328] result() for ClusterFuture ... done
[17:41:20.328] result() for ClusterFuture ...
[17:41:20.328] - result already collected: FutureResult
[17:41:20.328] result() for ClusterFuture ... done
[17:41:20.328] result() for ClusterFuture ...
[17:41:20.328] - result already collected: FutureResult
[17:41:20.329] result() for ClusterFuture ... done
[17:41:20.329] result() for ClusterFuture ...
[17:41:20.329] - result already collected: FutureResult
[17:41:20.329] result() for ClusterFuture ... done
[17:41:20.329] - relayed: [n=2] TRUE, FALSE
[17:41:20.329] - queued futures: [n=2] TRUE, TRUE
[17:41:20.329] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:20.329]  length: 0 (resolved future 1)
[17:41:20.329] Relaying remaining futures
[17:41:20.329] signalConditionsASAP(NULL, pos=0) ...
[17:41:20.329] - nx: 2
[17:41:20.330] - relay: TRUE
[17:41:20.330] - stdout: TRUE
[17:41:20.330] - signal: TRUE
[17:41:20.330] - resignal: FALSE
[17:41:20.330] - force: TRUE
[17:41:20.330] - relayed: [n=2] TRUE, FALSE
[17:41:20.330] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:20.330]  - relaying element #2
[17:41:20.330] result() for ClusterFuture ...
[17:41:20.330] - result already collected: FutureResult
[17:41:20.330] result() for ClusterFuture ... done
[17:41:20.331] result() for ClusterFuture ...
[17:41:20.331] - result already collected: FutureResult
[17:41:20.331] result() for ClusterFuture ... done
[17:41:20.331] result() for ClusterFuture ...
[17:41:20.331] - result already collected: FutureResult
[17:41:20.331] result() for ClusterFuture ... done
[17:41:20.331] result() for ClusterFuture ...
[17:41:20.331] - result already collected: FutureResult
[17:41:20.331] result() for ClusterFuture ... done
[17:41:20.331] - relayed: [n=2] TRUE, TRUE
[17:41:20.331] - queued futures: [n=2] TRUE, TRUE
[17:41:20.332] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:41:20.332] resolve() on list ... DONE
[17:41:20.332] result() for ClusterFuture ...
[17:41:20.332] - result already collected: FutureResult
[17:41:20.332] result() for ClusterFuture ... done
[17:41:20.332] result() for ClusterFuture ...
[17:41:20.332] - result already collected: FutureResult
[17:41:20.332] result() for ClusterFuture ... done
[17:41:20.332] result() for ClusterFuture ...
[17:41:20.332] - result already collected: FutureResult
[17:41:20.332] result() for ClusterFuture ... done
[17:41:20.332] result() for ClusterFuture ...
[17:41:20.333] - result already collected: FutureResult
[17:41:20.333] result() for ClusterFuture ... done
[17:41:20.333]  - Number of value chunks collected: 2
[17:41:20.333] Resolving 2 futures (chunks) ... DONE
[17:41:20.333] Reducing values from 2 chunks ...
[17:41:20.333]  - Number of values collected after concatenation: 2
[17:41:20.333]  - Number of values expected: 2
[17:41:20.333] Reducing values from 2 chunks ... DONE
[17:41:20.333] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:41:20.334] future_lapply() ...
[17:41:20.338] Number of chunks: 2
[17:41:20.338] getGlobalsAndPackagesXApply() ...
[17:41:20.338]  - future.globals: TRUE
[17:41:20.338] getGlobalsAndPackages() ...
[17:41:20.338] Searching for globals...
[17:41:20.340] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:20.340] Searching for globals ... DONE
[17:41:20.340] Resolving globals: FALSE
[17:41:20.341] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:20.341] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:20.341] - globals: [1] ‘FUN’
[17:41:20.341] 
[17:41:20.341] getGlobalsAndPackages() ... DONE
[17:41:20.341]  - globals found/used: [n=1] ‘FUN’
[17:41:20.341]  - needed namespaces: [n=0] 
[17:41:20.341] Finding globals ... DONE
[17:41:20.342]  - use_args: TRUE
[17:41:20.342]  - Getting '...' globals ...
[17:41:20.342] resolve() on list ...
[17:41:20.342]  recursive: 0
[17:41:20.342]  length: 1
[17:41:20.342]  elements: ‘...’
[17:41:20.342]  length: 0 (resolved future 1)
[17:41:20.342] resolve() on list ... DONE
[17:41:20.343]    - '...' content: [n=0] 
[17:41:20.343] List of 1
[17:41:20.343]  $ ...: list()
[17:41:20.343]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:20.343]  - attr(*, "where")=List of 1
[17:41:20.343]   ..$ ...:<environment: 0x55c9883a6250> 
[17:41:20.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:20.343]  - attr(*, "resolved")= logi TRUE
[17:41:20.343]  - attr(*, "total_size")= num NA
[17:41:20.345]  - Getting '...' globals ... DONE
[17:41:20.345] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:20.345] List of 2
[17:41:20.345]  $ ...future.FUN:function (x)  
[17:41:20.345]  $ ...          : list()
[17:41:20.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:20.345]  - attr(*, "where")=List of 2
[17:41:20.345]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:20.345]   ..$ ...          :<environment: 0x55c9883a6250> 
[17:41:20.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:20.345]  - attr(*, "resolved")= logi FALSE
[17:41:20.345]  - attr(*, "total_size")= num 4720
[17:41:20.348] Packages to be attached in all futures: [n=0] 
[17:41:20.348] getGlobalsAndPackagesXApply() ... DONE
[17:41:20.348] Number of futures (= number of chunks): 2
[17:41:20.349] Launching 2 futures (chunks) ...
[17:41:20.349] Chunk #1 of 2 ...
[17:41:20.349]  - Finding globals in 'X' for chunk #1 ...
[17:41:20.349] getGlobalsAndPackages() ...
[17:41:20.349] Searching for globals...
[17:41:20.349] 
[17:41:20.349] Searching for globals ... DONE
[17:41:20.349] - globals: [0] <none>
[17:41:20.349] getGlobalsAndPackages() ... DONE
[17:41:20.350]    + additional globals found: [n=0] 
[17:41:20.350]    + additional namespaces needed: [n=0] 
[17:41:20.350]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:20.350]  - seeds: <none>
[17:41:20.350] getGlobalsAndPackages() ...
[17:41:20.350] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:20.350] Resolving globals: FALSE
[17:41:20.350] Tweak future expression to call with '...' arguments ...
[17:41:20.350] {
[17:41:20.350]     do.call(function(...) {
[17:41:20.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:20.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.350]             on.exit(options(oopts), add = TRUE)
[17:41:20.350]         }
[17:41:20.350]         {
[17:41:20.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:20.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.350]                 ...future.FUN(...future.X_jj, ...)
[17:41:20.350]             })
[17:41:20.350]         }
[17:41:20.350]     }, args = future.call.arguments)
[17:41:20.350] }
[17:41:20.351] Tweak future expression to call with '...' arguments ... DONE
[17:41:20.351] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:20.351] 
[17:41:20.351] getGlobalsAndPackages() ... DONE
[17:41:20.351] run() for ‘Future’ ...
[17:41:20.352] - state: ‘created’
[17:41:20.352] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:20.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:20.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:20.366]   - Field: ‘node’
[17:41:20.366]   - Field: ‘label’
[17:41:20.366]   - Field: ‘local’
[17:41:20.366]   - Field: ‘owner’
[17:41:20.366]   - Field: ‘envir’
[17:41:20.367]   - Field: ‘workers’
[17:41:20.367]   - Field: ‘packages’
[17:41:20.367]   - Field: ‘gc’
[17:41:20.367]   - Field: ‘conditions’
[17:41:20.367]   - Field: ‘persistent’
[17:41:20.367]   - Field: ‘expr’
[17:41:20.367]   - Field: ‘uuid’
[17:41:20.367]   - Field: ‘seed’
[17:41:20.367]   - Field: ‘version’
[17:41:20.367]   - Field: ‘result’
[17:41:20.368]   - Field: ‘asynchronous’
[17:41:20.368]   - Field: ‘calls’
[17:41:20.368]   - Field: ‘globals’
[17:41:20.368]   - Field: ‘stdout’
[17:41:20.368]   - Field: ‘earlySignal’
[17:41:20.368]   - Field: ‘lazy’
[17:41:20.368]   - Field: ‘state’
[17:41:20.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:20.368] - Launch lazy future ...
[17:41:20.369] Packages needed by the future expression (n = 0): <none>
[17:41:20.369] Packages needed by future strategies (n = 0): <none>
[17:41:20.369] {
[17:41:20.369]     {
[17:41:20.369]         {
[17:41:20.369]             ...future.startTime <- base::Sys.time()
[17:41:20.369]             {
[17:41:20.369]                 {
[17:41:20.369]                   {
[17:41:20.369]                     {
[17:41:20.369]                       base::local({
[17:41:20.369]                         has_future <- base::requireNamespace("future", 
[17:41:20.369]                           quietly = TRUE)
[17:41:20.369]                         if (has_future) {
[17:41:20.369]                           ns <- base::getNamespace("future")
[17:41:20.369]                           version <- ns[[".package"]][["version"]]
[17:41:20.369]                           if (is.null(version)) 
[17:41:20.369]                             version <- utils::packageVersion("future")
[17:41:20.369]                         }
[17:41:20.369]                         else {
[17:41:20.369]                           version <- NULL
[17:41:20.369]                         }
[17:41:20.369]                         if (!has_future || version < "1.8.0") {
[17:41:20.369]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:20.369]                             "", base::R.version$version.string), 
[17:41:20.369]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:20.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:20.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:20.369]                               "release", "version")], collapse = " "), 
[17:41:20.369]                             hostname = base::Sys.info()[["nodename"]])
[17:41:20.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:20.369]                             info)
[17:41:20.369]                           info <- base::paste(info, collapse = "; ")
[17:41:20.369]                           if (!has_future) {
[17:41:20.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:20.369]                               info)
[17:41:20.369]                           }
[17:41:20.369]                           else {
[17:41:20.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:20.369]                               info, version)
[17:41:20.369]                           }
[17:41:20.369]                           base::stop(msg)
[17:41:20.369]                         }
[17:41:20.369]                       })
[17:41:20.369]                     }
[17:41:20.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:20.369]                     base::options(mc.cores = 1L)
[17:41:20.369]                   }
[17:41:20.369]                   options(future.plan = NULL)
[17:41:20.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:20.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:20.369]                 }
[17:41:20.369]                 ...future.workdir <- getwd()
[17:41:20.369]             }
[17:41:20.369]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:20.369]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:20.369]         }
[17:41:20.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:20.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:20.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:20.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:20.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:20.369]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:20.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:20.369]             base::names(...future.oldOptions))
[17:41:20.369]     }
[17:41:20.369]     if (FALSE) {
[17:41:20.369]     }
[17:41:20.369]     else {
[17:41:20.369]         if (TRUE) {
[17:41:20.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:20.369]                 open = "w")
[17:41:20.369]         }
[17:41:20.369]         else {
[17:41:20.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:20.369]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:20.369]         }
[17:41:20.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:20.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:20.369]             base::sink(type = "output", split = FALSE)
[17:41:20.369]             base::close(...future.stdout)
[17:41:20.369]         }, add = TRUE)
[17:41:20.369]     }
[17:41:20.369]     ...future.frame <- base::sys.nframe()
[17:41:20.369]     ...future.conditions <- base::list()
[17:41:20.369]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:20.369]     if (FALSE) {
[17:41:20.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:20.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:20.369]     }
[17:41:20.369]     ...future.result <- base::tryCatch({
[17:41:20.369]         base::withCallingHandlers({
[17:41:20.369]             ...future.value <- base::withVisible(base::local({
[17:41:20.369]                 ...future.makeSendCondition <- local({
[17:41:20.369]                   sendCondition <- NULL
[17:41:20.369]                   function(frame = 1L) {
[17:41:20.369]                     if (is.function(sendCondition)) 
[17:41:20.369]                       return(sendCondition)
[17:41:20.369]                     ns <- getNamespace("parallel")
[17:41:20.369]                     if (exists("sendData", mode = "function", 
[17:41:20.369]                       envir = ns)) {
[17:41:20.369]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:20.369]                         envir = ns)
[17:41:20.369]                       envir <- sys.frame(frame)
[17:41:20.369]                       master <- NULL
[17:41:20.369]                       while (!identical(envir, .GlobalEnv) && 
[17:41:20.369]                         !identical(envir, emptyenv())) {
[17:41:20.369]                         if (exists("master", mode = "list", envir = envir, 
[17:41:20.369]                           inherits = FALSE)) {
[17:41:20.369]                           master <- get("master", mode = "list", 
[17:41:20.369]                             envir = envir, inherits = FALSE)
[17:41:20.369]                           if (inherits(master, c("SOCKnode", 
[17:41:20.369]                             "SOCK0node"))) {
[17:41:20.369]                             sendCondition <<- function(cond) {
[17:41:20.369]                               data <- list(type = "VALUE", value = cond, 
[17:41:20.369]                                 success = TRUE)
[17:41:20.369]                               parallel_sendData(master, data)
[17:41:20.369]                             }
[17:41:20.369]                             return(sendCondition)
[17:41:20.369]                           }
[17:41:20.369]                         }
[17:41:20.369]                         frame <- frame + 1L
[17:41:20.369]                         envir <- sys.frame(frame)
[17:41:20.369]                       }
[17:41:20.369]                     }
[17:41:20.369]                     sendCondition <<- function(cond) NULL
[17:41:20.369]                   }
[17:41:20.369]                 })
[17:41:20.369]                 withCallingHandlers({
[17:41:20.369]                   {
[17:41:20.369]                     do.call(function(...) {
[17:41:20.369]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.369]                       if (!identical(...future.globals.maxSize.org, 
[17:41:20.369]                         ...future.globals.maxSize)) {
[17:41:20.369]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.369]                         on.exit(options(oopts), add = TRUE)
[17:41:20.369]                       }
[17:41:20.369]                       {
[17:41:20.369]                         lapply(seq_along(...future.elements_ii), 
[17:41:20.369]                           FUN = function(jj) {
[17:41:20.369]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.369]                             ...future.FUN(...future.X_jj, ...)
[17:41:20.369]                           })
[17:41:20.369]                       }
[17:41:20.369]                     }, args = future.call.arguments)
[17:41:20.369]                   }
[17:41:20.369]                 }, immediateCondition = function(cond) {
[17:41:20.369]                   sendCondition <- ...future.makeSendCondition()
[17:41:20.369]                   sendCondition(cond)
[17:41:20.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.369]                   {
[17:41:20.369]                     inherits <- base::inherits
[17:41:20.369]                     invokeRestart <- base::invokeRestart
[17:41:20.369]                     is.null <- base::is.null
[17:41:20.369]                     muffled <- FALSE
[17:41:20.369]                     if (inherits(cond, "message")) {
[17:41:20.369]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:20.369]                       if (muffled) 
[17:41:20.369]                         invokeRestart("muffleMessage")
[17:41:20.369]                     }
[17:41:20.369]                     else if (inherits(cond, "warning")) {
[17:41:20.369]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:20.369]                       if (muffled) 
[17:41:20.369]                         invokeRestart("muffleWarning")
[17:41:20.369]                     }
[17:41:20.369]                     else if (inherits(cond, "condition")) {
[17:41:20.369]                       if (!is.null(pattern)) {
[17:41:20.369]                         computeRestarts <- base::computeRestarts
[17:41:20.369]                         grepl <- base::grepl
[17:41:20.369]                         restarts <- computeRestarts(cond)
[17:41:20.369]                         for (restart in restarts) {
[17:41:20.369]                           name <- restart$name
[17:41:20.369]                           if (is.null(name)) 
[17:41:20.369]                             next
[17:41:20.369]                           if (!grepl(pattern, name)) 
[17:41:20.369]                             next
[17:41:20.369]                           invokeRestart(restart)
[17:41:20.369]                           muffled <- TRUE
[17:41:20.369]                           break
[17:41:20.369]                         }
[17:41:20.369]                       }
[17:41:20.369]                     }
[17:41:20.369]                     invisible(muffled)
[17:41:20.369]                   }
[17:41:20.369]                   muffleCondition(cond)
[17:41:20.369]                 })
[17:41:20.369]             }))
[17:41:20.369]             future::FutureResult(value = ...future.value$value, 
[17:41:20.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:20.369]                   ...future.rng), globalenv = if (FALSE) 
[17:41:20.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:20.369]                     ...future.globalenv.names))
[17:41:20.369]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:20.369]         }, condition = base::local({
[17:41:20.369]             c <- base::c
[17:41:20.369]             inherits <- base::inherits
[17:41:20.369]             invokeRestart <- base::invokeRestart
[17:41:20.369]             length <- base::length
[17:41:20.369]             list <- base::list
[17:41:20.369]             seq.int <- base::seq.int
[17:41:20.369]             signalCondition <- base::signalCondition
[17:41:20.369]             sys.calls <- base::sys.calls
[17:41:20.369]             `[[` <- base::`[[`
[17:41:20.369]             `+` <- base::`+`
[17:41:20.369]             `<<-` <- base::`<<-`
[17:41:20.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:20.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:20.369]                   3L)]
[17:41:20.369]             }
[17:41:20.369]             function(cond) {
[17:41:20.369]                 is_error <- inherits(cond, "error")
[17:41:20.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:20.369]                   NULL)
[17:41:20.369]                 if (is_error) {
[17:41:20.369]                   sessionInformation <- function() {
[17:41:20.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:20.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:20.369]                       search = base::search(), system = base::Sys.info())
[17:41:20.369]                   }
[17:41:20.369]                   ...future.conditions[[length(...future.conditions) + 
[17:41:20.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:20.369]                     cond$call), session = sessionInformation(), 
[17:41:20.369]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:20.369]                   signalCondition(cond)
[17:41:20.369]                 }
[17:41:20.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:20.369]                 "immediateCondition"))) {
[17:41:20.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:20.369]                   ...future.conditions[[length(...future.conditions) + 
[17:41:20.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:20.369]                   if (TRUE && !signal) {
[17:41:20.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.369]                     {
[17:41:20.369]                       inherits <- base::inherits
[17:41:20.369]                       invokeRestart <- base::invokeRestart
[17:41:20.369]                       is.null <- base::is.null
[17:41:20.369]                       muffled <- FALSE
[17:41:20.369]                       if (inherits(cond, "message")) {
[17:41:20.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:20.369]                         if (muffled) 
[17:41:20.369]                           invokeRestart("muffleMessage")
[17:41:20.369]                       }
[17:41:20.369]                       else if (inherits(cond, "warning")) {
[17:41:20.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:20.369]                         if (muffled) 
[17:41:20.369]                           invokeRestart("muffleWarning")
[17:41:20.369]                       }
[17:41:20.369]                       else if (inherits(cond, "condition")) {
[17:41:20.369]                         if (!is.null(pattern)) {
[17:41:20.369]                           computeRestarts <- base::computeRestarts
[17:41:20.369]                           grepl <- base::grepl
[17:41:20.369]                           restarts <- computeRestarts(cond)
[17:41:20.369]                           for (restart in restarts) {
[17:41:20.369]                             name <- restart$name
[17:41:20.369]                             if (is.null(name)) 
[17:41:20.369]                               next
[17:41:20.369]                             if (!grepl(pattern, name)) 
[17:41:20.369]                               next
[17:41:20.369]                             invokeRestart(restart)
[17:41:20.369]                             muffled <- TRUE
[17:41:20.369]                             break
[17:41:20.369]                           }
[17:41:20.369]                         }
[17:41:20.369]                       }
[17:41:20.369]                       invisible(muffled)
[17:41:20.369]                     }
[17:41:20.369]                     muffleCondition(cond, pattern = "^muffle")
[17:41:20.369]                   }
[17:41:20.369]                 }
[17:41:20.369]                 else {
[17:41:20.369]                   if (TRUE) {
[17:41:20.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.369]                     {
[17:41:20.369]                       inherits <- base::inherits
[17:41:20.369]                       invokeRestart <- base::invokeRestart
[17:41:20.369]                       is.null <- base::is.null
[17:41:20.369]                       muffled <- FALSE
[17:41:20.369]                       if (inherits(cond, "message")) {
[17:41:20.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:20.369]                         if (muffled) 
[17:41:20.369]                           invokeRestart("muffleMessage")
[17:41:20.369]                       }
[17:41:20.369]                       else if (inherits(cond, "warning")) {
[17:41:20.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:20.369]                         if (muffled) 
[17:41:20.369]                           invokeRestart("muffleWarning")
[17:41:20.369]                       }
[17:41:20.369]                       else if (inherits(cond, "condition")) {
[17:41:20.369]                         if (!is.null(pattern)) {
[17:41:20.369]                           computeRestarts <- base::computeRestarts
[17:41:20.369]                           grepl <- base::grepl
[17:41:20.369]                           restarts <- computeRestarts(cond)
[17:41:20.369]                           for (restart in restarts) {
[17:41:20.369]                             name <- restart$name
[17:41:20.369]                             if (is.null(name)) 
[17:41:20.369]                               next
[17:41:20.369]                             if (!grepl(pattern, name)) 
[17:41:20.369]                               next
[17:41:20.369]                             invokeRestart(restart)
[17:41:20.369]                             muffled <- TRUE
[17:41:20.369]                             break
[17:41:20.369]                           }
[17:41:20.369]                         }
[17:41:20.369]                       }
[17:41:20.369]                       invisible(muffled)
[17:41:20.369]                     }
[17:41:20.369]                     muffleCondition(cond, pattern = "^muffle")
[17:41:20.369]                   }
[17:41:20.369]                 }
[17:41:20.369]             }
[17:41:20.369]         }))
[17:41:20.369]     }, error = function(ex) {
[17:41:20.369]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:20.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:20.369]                 ...future.rng), started = ...future.startTime, 
[17:41:20.369]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:20.369]             version = "1.8"), class = "FutureResult")
[17:41:20.369]     }, finally = {
[17:41:20.369]         if (!identical(...future.workdir, getwd())) 
[17:41:20.369]             setwd(...future.workdir)
[17:41:20.369]         {
[17:41:20.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:20.369]                 ...future.oldOptions$nwarnings <- NULL
[17:41:20.369]             }
[17:41:20.369]             base::options(...future.oldOptions)
[17:41:20.369]             if (.Platform$OS.type == "windows") {
[17:41:20.369]                 old_names <- names(...future.oldEnvVars)
[17:41:20.369]                 envs <- base::Sys.getenv()
[17:41:20.369]                 names <- names(envs)
[17:41:20.369]                 common <- intersect(names, old_names)
[17:41:20.369]                 added <- setdiff(names, old_names)
[17:41:20.369]                 removed <- setdiff(old_names, names)
[17:41:20.369]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:20.369]                   envs[common]]
[17:41:20.369]                 NAMES <- toupper(changed)
[17:41:20.369]                 args <- list()
[17:41:20.369]                 for (kk in seq_along(NAMES)) {
[17:41:20.369]                   name <- changed[[kk]]
[17:41:20.369]                   NAME <- NAMES[[kk]]
[17:41:20.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.369]                     next
[17:41:20.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:20.369]                 }
[17:41:20.369]                 NAMES <- toupper(added)
[17:41:20.369]                 for (kk in seq_along(NAMES)) {
[17:41:20.369]                   name <- added[[kk]]
[17:41:20.369]                   NAME <- NAMES[[kk]]
[17:41:20.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.369]                     next
[17:41:20.369]                   args[[name]] <- ""
[17:41:20.369]                 }
[17:41:20.369]                 NAMES <- toupper(removed)
[17:41:20.369]                 for (kk in seq_along(NAMES)) {
[17:41:20.369]                   name <- removed[[kk]]
[17:41:20.369]                   NAME <- NAMES[[kk]]
[17:41:20.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.369]                     next
[17:41:20.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:20.369]                 }
[17:41:20.369]                 if (length(args) > 0) 
[17:41:20.369]                   base::do.call(base::Sys.setenv, args = args)
[17:41:20.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:20.369]             }
[17:41:20.369]             else {
[17:41:20.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:20.369]             }
[17:41:20.369]             {
[17:41:20.369]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:20.369]                   0L) {
[17:41:20.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:20.369]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:20.369]                   base::options(opts)
[17:41:20.369]                 }
[17:41:20.369]                 {
[17:41:20.369]                   {
[17:41:20.369]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:20.369]                     NULL
[17:41:20.369]                   }
[17:41:20.369]                   options(future.plan = NULL)
[17:41:20.369]                   if (is.na(NA_character_)) 
[17:41:20.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:20.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:20.369]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:20.369]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:20.369]                     envir = parent.frame()) 
[17:41:20.369]                   {
[17:41:20.369]                     if (is.function(workers)) 
[17:41:20.369]                       workers <- workers()
[17:41:20.369]                     workers <- structure(as.integer(workers), 
[17:41:20.369]                       class = class(workers))
[17:41:20.369]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:20.369]                       workers >= 1)
[17:41:20.369]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:20.369]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:20.369]                     }
[17:41:20.369]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:20.369]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:20.369]                       envir = envir)
[17:41:20.369]                     if (!future$lazy) 
[17:41:20.369]                       future <- run(future)
[17:41:20.369]                     invisible(future)
[17:41:20.369]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:20.369]                 }
[17:41:20.369]             }
[17:41:20.369]         }
[17:41:20.369]     })
[17:41:20.369]     if (TRUE) {
[17:41:20.369]         base::sink(type = "output", split = FALSE)
[17:41:20.369]         if (TRUE) {
[17:41:20.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:20.369]         }
[17:41:20.369]         else {
[17:41:20.369]             ...future.result["stdout"] <- base::list(NULL)
[17:41:20.369]         }
[17:41:20.369]         base::close(...future.stdout)
[17:41:20.369]         ...future.stdout <- NULL
[17:41:20.369]     }
[17:41:20.369]     ...future.result$conditions <- ...future.conditions
[17:41:20.369]     ...future.result$finished <- base::Sys.time()
[17:41:20.369]     ...future.result
[17:41:20.369] }
[17:41:20.372] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:41:20.372] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:41:20.373] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:41:20.373] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:20.373] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:20.373] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:41:20.374] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:41:20.374] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:20.374] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:20.374] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:20.375] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:20.375] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:41:20.375] MultisessionFuture started
[17:41:20.376] - Launch lazy future ... done
[17:41:20.376] run() for ‘MultisessionFuture’ ... done
[17:41:20.376] Created future:
[17:41:20.376] MultisessionFuture:
[17:41:20.376] Label: ‘future_lapply-1’
[17:41:20.376] Expression:
[17:41:20.376] {
[17:41:20.376]     do.call(function(...) {
[17:41:20.376]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.376]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:20.376]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.376]             on.exit(options(oopts), add = TRUE)
[17:41:20.376]         }
[17:41:20.376]         {
[17:41:20.376]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:20.376]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.376]                 ...future.FUN(...future.X_jj, ...)
[17:41:20.376]             })
[17:41:20.376]         }
[17:41:20.376]     }, args = future.call.arguments)
[17:41:20.376] }
[17:41:20.376] Lazy evaluation: FALSE
[17:41:20.376] Asynchronous evaluation: TRUE
[17:41:20.376] Local evaluation: TRUE
[17:41:20.376] Environment: R_GlobalEnv
[17:41:20.376] Capture standard output: TRUE
[17:41:20.376] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:20.376] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:20.376] Packages: <none>
[17:41:20.376] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:20.376] Resolved: FALSE
[17:41:20.376] Value: <not collected>
[17:41:20.376] Conditions captured: <none>
[17:41:20.376] Early signaling: FALSE
[17:41:20.376] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:20.376] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:20.388] Chunk #1 of 2 ... DONE
[17:41:20.388] Chunk #2 of 2 ...
[17:41:20.388]  - Finding globals in 'X' for chunk #2 ...
[17:41:20.388] getGlobalsAndPackages() ...
[17:41:20.388] Searching for globals...
[17:41:20.388] 
[17:41:20.388] Searching for globals ... DONE
[17:41:20.389] - globals: [0] <none>
[17:41:20.389] getGlobalsAndPackages() ... DONE
[17:41:20.389]    + additional globals found: [n=0] 
[17:41:20.389]    + additional namespaces needed: [n=0] 
[17:41:20.389]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:20.389]  - seeds: <none>
[17:41:20.389] getGlobalsAndPackages() ...
[17:41:20.389] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:20.389] Resolving globals: FALSE
[17:41:20.389] Tweak future expression to call with '...' arguments ...
[17:41:20.389] {
[17:41:20.389]     do.call(function(...) {
[17:41:20.389]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.389]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:20.389]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.389]             on.exit(options(oopts), add = TRUE)
[17:41:20.389]         }
[17:41:20.389]         {
[17:41:20.389]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:20.389]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.389]                 ...future.FUN(...future.X_jj, ...)
[17:41:20.389]             })
[17:41:20.389]         }
[17:41:20.389]     }, args = future.call.arguments)
[17:41:20.389] }
[17:41:20.390] Tweak future expression to call with '...' arguments ... DONE
[17:41:20.390] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:20.390] 
[17:41:20.390] getGlobalsAndPackages() ... DONE
[17:41:20.391] run() for ‘Future’ ...
[17:41:20.391] - state: ‘created’
[17:41:20.391] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:20.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:20.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:20.406]   - Field: ‘node’
[17:41:20.406]   - Field: ‘label’
[17:41:20.406]   - Field: ‘local’
[17:41:20.406]   - Field: ‘owner’
[17:41:20.406]   - Field: ‘envir’
[17:41:20.406]   - Field: ‘workers’
[17:41:20.406]   - Field: ‘packages’
[17:41:20.406]   - Field: ‘gc’
[17:41:20.406]   - Field: ‘conditions’
[17:41:20.406]   - Field: ‘persistent’
[17:41:20.407]   - Field: ‘expr’
[17:41:20.407]   - Field: ‘uuid’
[17:41:20.407]   - Field: ‘seed’
[17:41:20.407]   - Field: ‘version’
[17:41:20.407]   - Field: ‘result’
[17:41:20.407]   - Field: ‘asynchronous’
[17:41:20.407]   - Field: ‘calls’
[17:41:20.407]   - Field: ‘globals’
[17:41:20.407]   - Field: ‘stdout’
[17:41:20.407]   - Field: ‘earlySignal’
[17:41:20.407]   - Field: ‘lazy’
[17:41:20.408]   - Field: ‘state’
[17:41:20.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:20.408] - Launch lazy future ...
[17:41:20.408] Packages needed by the future expression (n = 0): <none>
[17:41:20.408] Packages needed by future strategies (n = 0): <none>
[17:41:20.409] {
[17:41:20.409]     {
[17:41:20.409]         {
[17:41:20.409]             ...future.startTime <- base::Sys.time()
[17:41:20.409]             {
[17:41:20.409]                 {
[17:41:20.409]                   {
[17:41:20.409]                     {
[17:41:20.409]                       base::local({
[17:41:20.409]                         has_future <- base::requireNamespace("future", 
[17:41:20.409]                           quietly = TRUE)
[17:41:20.409]                         if (has_future) {
[17:41:20.409]                           ns <- base::getNamespace("future")
[17:41:20.409]                           version <- ns[[".package"]][["version"]]
[17:41:20.409]                           if (is.null(version)) 
[17:41:20.409]                             version <- utils::packageVersion("future")
[17:41:20.409]                         }
[17:41:20.409]                         else {
[17:41:20.409]                           version <- NULL
[17:41:20.409]                         }
[17:41:20.409]                         if (!has_future || version < "1.8.0") {
[17:41:20.409]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:20.409]                             "", base::R.version$version.string), 
[17:41:20.409]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:20.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:20.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:20.409]                               "release", "version")], collapse = " "), 
[17:41:20.409]                             hostname = base::Sys.info()[["nodename"]])
[17:41:20.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:20.409]                             info)
[17:41:20.409]                           info <- base::paste(info, collapse = "; ")
[17:41:20.409]                           if (!has_future) {
[17:41:20.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:20.409]                               info)
[17:41:20.409]                           }
[17:41:20.409]                           else {
[17:41:20.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:20.409]                               info, version)
[17:41:20.409]                           }
[17:41:20.409]                           base::stop(msg)
[17:41:20.409]                         }
[17:41:20.409]                       })
[17:41:20.409]                     }
[17:41:20.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:20.409]                     base::options(mc.cores = 1L)
[17:41:20.409]                   }
[17:41:20.409]                   options(future.plan = NULL)
[17:41:20.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:20.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:20.409]                 }
[17:41:20.409]                 ...future.workdir <- getwd()
[17:41:20.409]             }
[17:41:20.409]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:20.409]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:20.409]         }
[17:41:20.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:20.409]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:20.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:20.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:20.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:20.409]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:20.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:20.409]             base::names(...future.oldOptions))
[17:41:20.409]     }
[17:41:20.409]     if (FALSE) {
[17:41:20.409]     }
[17:41:20.409]     else {
[17:41:20.409]         if (TRUE) {
[17:41:20.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:20.409]                 open = "w")
[17:41:20.409]         }
[17:41:20.409]         else {
[17:41:20.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:20.409]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:20.409]         }
[17:41:20.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:20.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:20.409]             base::sink(type = "output", split = FALSE)
[17:41:20.409]             base::close(...future.stdout)
[17:41:20.409]         }, add = TRUE)
[17:41:20.409]     }
[17:41:20.409]     ...future.frame <- base::sys.nframe()
[17:41:20.409]     ...future.conditions <- base::list()
[17:41:20.409]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:20.409]     if (FALSE) {
[17:41:20.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:20.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:20.409]     }
[17:41:20.409]     ...future.result <- base::tryCatch({
[17:41:20.409]         base::withCallingHandlers({
[17:41:20.409]             ...future.value <- base::withVisible(base::local({
[17:41:20.409]                 ...future.makeSendCondition <- local({
[17:41:20.409]                   sendCondition <- NULL
[17:41:20.409]                   function(frame = 1L) {
[17:41:20.409]                     if (is.function(sendCondition)) 
[17:41:20.409]                       return(sendCondition)
[17:41:20.409]                     ns <- getNamespace("parallel")
[17:41:20.409]                     if (exists("sendData", mode = "function", 
[17:41:20.409]                       envir = ns)) {
[17:41:20.409]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:20.409]                         envir = ns)
[17:41:20.409]                       envir <- sys.frame(frame)
[17:41:20.409]                       master <- NULL
[17:41:20.409]                       while (!identical(envir, .GlobalEnv) && 
[17:41:20.409]                         !identical(envir, emptyenv())) {
[17:41:20.409]                         if (exists("master", mode = "list", envir = envir, 
[17:41:20.409]                           inherits = FALSE)) {
[17:41:20.409]                           master <- get("master", mode = "list", 
[17:41:20.409]                             envir = envir, inherits = FALSE)
[17:41:20.409]                           if (inherits(master, c("SOCKnode", 
[17:41:20.409]                             "SOCK0node"))) {
[17:41:20.409]                             sendCondition <<- function(cond) {
[17:41:20.409]                               data <- list(type = "VALUE", value = cond, 
[17:41:20.409]                                 success = TRUE)
[17:41:20.409]                               parallel_sendData(master, data)
[17:41:20.409]                             }
[17:41:20.409]                             return(sendCondition)
[17:41:20.409]                           }
[17:41:20.409]                         }
[17:41:20.409]                         frame <- frame + 1L
[17:41:20.409]                         envir <- sys.frame(frame)
[17:41:20.409]                       }
[17:41:20.409]                     }
[17:41:20.409]                     sendCondition <<- function(cond) NULL
[17:41:20.409]                   }
[17:41:20.409]                 })
[17:41:20.409]                 withCallingHandlers({
[17:41:20.409]                   {
[17:41:20.409]                     do.call(function(...) {
[17:41:20.409]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.409]                       if (!identical(...future.globals.maxSize.org, 
[17:41:20.409]                         ...future.globals.maxSize)) {
[17:41:20.409]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.409]                         on.exit(options(oopts), add = TRUE)
[17:41:20.409]                       }
[17:41:20.409]                       {
[17:41:20.409]                         lapply(seq_along(...future.elements_ii), 
[17:41:20.409]                           FUN = function(jj) {
[17:41:20.409]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.409]                             ...future.FUN(...future.X_jj, ...)
[17:41:20.409]                           })
[17:41:20.409]                       }
[17:41:20.409]                     }, args = future.call.arguments)
[17:41:20.409]                   }
[17:41:20.409]                 }, immediateCondition = function(cond) {
[17:41:20.409]                   sendCondition <- ...future.makeSendCondition()
[17:41:20.409]                   sendCondition(cond)
[17:41:20.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.409]                   {
[17:41:20.409]                     inherits <- base::inherits
[17:41:20.409]                     invokeRestart <- base::invokeRestart
[17:41:20.409]                     is.null <- base::is.null
[17:41:20.409]                     muffled <- FALSE
[17:41:20.409]                     if (inherits(cond, "message")) {
[17:41:20.409]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:20.409]                       if (muffled) 
[17:41:20.409]                         invokeRestart("muffleMessage")
[17:41:20.409]                     }
[17:41:20.409]                     else if (inherits(cond, "warning")) {
[17:41:20.409]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:20.409]                       if (muffled) 
[17:41:20.409]                         invokeRestart("muffleWarning")
[17:41:20.409]                     }
[17:41:20.409]                     else if (inherits(cond, "condition")) {
[17:41:20.409]                       if (!is.null(pattern)) {
[17:41:20.409]                         computeRestarts <- base::computeRestarts
[17:41:20.409]                         grepl <- base::grepl
[17:41:20.409]                         restarts <- computeRestarts(cond)
[17:41:20.409]                         for (restart in restarts) {
[17:41:20.409]                           name <- restart$name
[17:41:20.409]                           if (is.null(name)) 
[17:41:20.409]                             next
[17:41:20.409]                           if (!grepl(pattern, name)) 
[17:41:20.409]                             next
[17:41:20.409]                           invokeRestart(restart)
[17:41:20.409]                           muffled <- TRUE
[17:41:20.409]                           break
[17:41:20.409]                         }
[17:41:20.409]                       }
[17:41:20.409]                     }
[17:41:20.409]                     invisible(muffled)
[17:41:20.409]                   }
[17:41:20.409]                   muffleCondition(cond)
[17:41:20.409]                 })
[17:41:20.409]             }))
[17:41:20.409]             future::FutureResult(value = ...future.value$value, 
[17:41:20.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:20.409]                   ...future.rng), globalenv = if (FALSE) 
[17:41:20.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:20.409]                     ...future.globalenv.names))
[17:41:20.409]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:20.409]         }, condition = base::local({
[17:41:20.409]             c <- base::c
[17:41:20.409]             inherits <- base::inherits
[17:41:20.409]             invokeRestart <- base::invokeRestart
[17:41:20.409]             length <- base::length
[17:41:20.409]             list <- base::list
[17:41:20.409]             seq.int <- base::seq.int
[17:41:20.409]             signalCondition <- base::signalCondition
[17:41:20.409]             sys.calls <- base::sys.calls
[17:41:20.409]             `[[` <- base::`[[`
[17:41:20.409]             `+` <- base::`+`
[17:41:20.409]             `<<-` <- base::`<<-`
[17:41:20.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:20.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:20.409]                   3L)]
[17:41:20.409]             }
[17:41:20.409]             function(cond) {
[17:41:20.409]                 is_error <- inherits(cond, "error")
[17:41:20.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:20.409]                   NULL)
[17:41:20.409]                 if (is_error) {
[17:41:20.409]                   sessionInformation <- function() {
[17:41:20.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:20.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:20.409]                       search = base::search(), system = base::Sys.info())
[17:41:20.409]                   }
[17:41:20.409]                   ...future.conditions[[length(...future.conditions) + 
[17:41:20.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:20.409]                     cond$call), session = sessionInformation(), 
[17:41:20.409]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:20.409]                   signalCondition(cond)
[17:41:20.409]                 }
[17:41:20.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:20.409]                 "immediateCondition"))) {
[17:41:20.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:20.409]                   ...future.conditions[[length(...future.conditions) + 
[17:41:20.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:20.409]                   if (TRUE && !signal) {
[17:41:20.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.409]                     {
[17:41:20.409]                       inherits <- base::inherits
[17:41:20.409]                       invokeRestart <- base::invokeRestart
[17:41:20.409]                       is.null <- base::is.null
[17:41:20.409]                       muffled <- FALSE
[17:41:20.409]                       if (inherits(cond, "message")) {
[17:41:20.409]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:20.409]                         if (muffled) 
[17:41:20.409]                           invokeRestart("muffleMessage")
[17:41:20.409]                       }
[17:41:20.409]                       else if (inherits(cond, "warning")) {
[17:41:20.409]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:20.409]                         if (muffled) 
[17:41:20.409]                           invokeRestart("muffleWarning")
[17:41:20.409]                       }
[17:41:20.409]                       else if (inherits(cond, "condition")) {
[17:41:20.409]                         if (!is.null(pattern)) {
[17:41:20.409]                           computeRestarts <- base::computeRestarts
[17:41:20.409]                           grepl <- base::grepl
[17:41:20.409]                           restarts <- computeRestarts(cond)
[17:41:20.409]                           for (restart in restarts) {
[17:41:20.409]                             name <- restart$name
[17:41:20.409]                             if (is.null(name)) 
[17:41:20.409]                               next
[17:41:20.409]                             if (!grepl(pattern, name)) 
[17:41:20.409]                               next
[17:41:20.409]                             invokeRestart(restart)
[17:41:20.409]                             muffled <- TRUE
[17:41:20.409]                             break
[17:41:20.409]                           }
[17:41:20.409]                         }
[17:41:20.409]                       }
[17:41:20.409]                       invisible(muffled)
[17:41:20.409]                     }
[17:41:20.409]                     muffleCondition(cond, pattern = "^muffle")
[17:41:20.409]                   }
[17:41:20.409]                 }
[17:41:20.409]                 else {
[17:41:20.409]                   if (TRUE) {
[17:41:20.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.409]                     {
[17:41:20.409]                       inherits <- base::inherits
[17:41:20.409]                       invokeRestart <- base::invokeRestart
[17:41:20.409]                       is.null <- base::is.null
[17:41:20.409]                       muffled <- FALSE
[17:41:20.409]                       if (inherits(cond, "message")) {
[17:41:20.409]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:20.409]                         if (muffled) 
[17:41:20.409]                           invokeRestart("muffleMessage")
[17:41:20.409]                       }
[17:41:20.409]                       else if (inherits(cond, "warning")) {
[17:41:20.409]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:20.409]                         if (muffled) 
[17:41:20.409]                           invokeRestart("muffleWarning")
[17:41:20.409]                       }
[17:41:20.409]                       else if (inherits(cond, "condition")) {
[17:41:20.409]                         if (!is.null(pattern)) {
[17:41:20.409]                           computeRestarts <- base::computeRestarts
[17:41:20.409]                           grepl <- base::grepl
[17:41:20.409]                           restarts <- computeRestarts(cond)
[17:41:20.409]                           for (restart in restarts) {
[17:41:20.409]                             name <- restart$name
[17:41:20.409]                             if (is.null(name)) 
[17:41:20.409]                               next
[17:41:20.409]                             if (!grepl(pattern, name)) 
[17:41:20.409]                               next
[17:41:20.409]                             invokeRestart(restart)
[17:41:20.409]                             muffled <- TRUE
[17:41:20.409]                             break
[17:41:20.409]                           }
[17:41:20.409]                         }
[17:41:20.409]                       }
[17:41:20.409]                       invisible(muffled)
[17:41:20.409]                     }
[17:41:20.409]                     muffleCondition(cond, pattern = "^muffle")
[17:41:20.409]                   }
[17:41:20.409]                 }
[17:41:20.409]             }
[17:41:20.409]         }))
[17:41:20.409]     }, error = function(ex) {
[17:41:20.409]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:20.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:20.409]                 ...future.rng), started = ...future.startTime, 
[17:41:20.409]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:20.409]             version = "1.8"), class = "FutureResult")
[17:41:20.409]     }, finally = {
[17:41:20.409]         if (!identical(...future.workdir, getwd())) 
[17:41:20.409]             setwd(...future.workdir)
[17:41:20.409]         {
[17:41:20.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:20.409]                 ...future.oldOptions$nwarnings <- NULL
[17:41:20.409]             }
[17:41:20.409]             base::options(...future.oldOptions)
[17:41:20.409]             if (.Platform$OS.type == "windows") {
[17:41:20.409]                 old_names <- names(...future.oldEnvVars)
[17:41:20.409]                 envs <- base::Sys.getenv()
[17:41:20.409]                 names <- names(envs)
[17:41:20.409]                 common <- intersect(names, old_names)
[17:41:20.409]                 added <- setdiff(names, old_names)
[17:41:20.409]                 removed <- setdiff(old_names, names)
[17:41:20.409]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:20.409]                   envs[common]]
[17:41:20.409]                 NAMES <- toupper(changed)
[17:41:20.409]                 args <- list()
[17:41:20.409]                 for (kk in seq_along(NAMES)) {
[17:41:20.409]                   name <- changed[[kk]]
[17:41:20.409]                   NAME <- NAMES[[kk]]
[17:41:20.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.409]                     next
[17:41:20.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:20.409]                 }
[17:41:20.409]                 NAMES <- toupper(added)
[17:41:20.409]                 for (kk in seq_along(NAMES)) {
[17:41:20.409]                   name <- added[[kk]]
[17:41:20.409]                   NAME <- NAMES[[kk]]
[17:41:20.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.409]                     next
[17:41:20.409]                   args[[name]] <- ""
[17:41:20.409]                 }
[17:41:20.409]                 NAMES <- toupper(removed)
[17:41:20.409]                 for (kk in seq_along(NAMES)) {
[17:41:20.409]                   name <- removed[[kk]]
[17:41:20.409]                   NAME <- NAMES[[kk]]
[17:41:20.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.409]                     next
[17:41:20.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:20.409]                 }
[17:41:20.409]                 if (length(args) > 0) 
[17:41:20.409]                   base::do.call(base::Sys.setenv, args = args)
[17:41:20.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:20.409]             }
[17:41:20.409]             else {
[17:41:20.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:20.409]             }
[17:41:20.409]             {
[17:41:20.409]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:20.409]                   0L) {
[17:41:20.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:20.409]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:20.409]                   base::options(opts)
[17:41:20.409]                 }
[17:41:20.409]                 {
[17:41:20.409]                   {
[17:41:20.409]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:20.409]                     NULL
[17:41:20.409]                   }
[17:41:20.409]                   options(future.plan = NULL)
[17:41:20.409]                   if (is.na(NA_character_)) 
[17:41:20.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:20.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:20.409]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:20.409]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:20.409]                     envir = parent.frame()) 
[17:41:20.409]                   {
[17:41:20.409]                     if (is.function(workers)) 
[17:41:20.409]                       workers <- workers()
[17:41:20.409]                     workers <- structure(as.integer(workers), 
[17:41:20.409]                       class = class(workers))
[17:41:20.409]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:20.409]                       workers >= 1)
[17:41:20.409]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:20.409]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:20.409]                     }
[17:41:20.409]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:20.409]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:20.409]                       envir = envir)
[17:41:20.409]                     if (!future$lazy) 
[17:41:20.409]                       future <- run(future)
[17:41:20.409]                     invisible(future)
[17:41:20.409]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:20.409]                 }
[17:41:20.409]             }
[17:41:20.409]         }
[17:41:20.409]     })
[17:41:20.409]     if (TRUE) {
[17:41:20.409]         base::sink(type = "output", split = FALSE)
[17:41:20.409]         if (TRUE) {
[17:41:20.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:20.409]         }
[17:41:20.409]         else {
[17:41:20.409]             ...future.result["stdout"] <- base::list(NULL)
[17:41:20.409]         }
[17:41:20.409]         base::close(...future.stdout)
[17:41:20.409]         ...future.stdout <- NULL
[17:41:20.409]     }
[17:41:20.409]     ...future.result$conditions <- ...future.conditions
[17:41:20.409]     ...future.result$finished <- base::Sys.time()
[17:41:20.409]     ...future.result
[17:41:20.409] }
[17:41:20.412] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:41:20.412] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:41:20.412] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:41:20.412] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:20.413] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:20.413] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:41:20.413] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:41:20.413] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:20.413] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:20.414] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:20.414] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:20.414] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:41:20.415] MultisessionFuture started
[17:41:20.415] - Launch lazy future ... done
[17:41:20.415] run() for ‘MultisessionFuture’ ... done
[17:41:20.415] Created future:
[17:41:20.415] MultisessionFuture:
[17:41:20.415] Label: ‘future_lapply-2’
[17:41:20.415] Expression:
[17:41:20.415] {
[17:41:20.415]     do.call(function(...) {
[17:41:20.415]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.415]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:20.415]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.415]             on.exit(options(oopts), add = TRUE)
[17:41:20.415]         }
[17:41:20.415]         {
[17:41:20.415]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:20.415]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.415]                 ...future.FUN(...future.X_jj, ...)
[17:41:20.415]             })
[17:41:20.415]         }
[17:41:20.415]     }, args = future.call.arguments)
[17:41:20.415] }
[17:41:20.415] Lazy evaluation: FALSE
[17:41:20.415] Asynchronous evaluation: TRUE
[17:41:20.415] Local evaluation: TRUE
[17:41:20.415] Environment: R_GlobalEnv
[17:41:20.415] Capture standard output: TRUE
[17:41:20.415] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:20.415] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:20.415] Packages: <none>
[17:41:20.415] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:20.415] Resolved: FALSE
[17:41:20.415] Value: <not collected>
[17:41:20.415] Conditions captured: <none>
[17:41:20.415] Early signaling: FALSE
[17:41:20.415] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:20.415] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:20.427] Chunk #2 of 2 ... DONE
[17:41:20.427] Launching 2 futures (chunks) ... DONE
[17:41:20.427] Resolving 2 futures (chunks) ...
[17:41:20.427] resolve() on list ...
[17:41:20.427]  recursive: 0
[17:41:20.427]  length: 2
[17:41:20.427] 
[17:41:20.470] receiveMessageFromWorker() for ClusterFuture ...
[17:41:20.470] - Validating connection of MultisessionFuture
[17:41:20.470] - received message: FutureResult
[17:41:20.470] - Received FutureResult
[17:41:20.470] - Erased future from FutureRegistry
[17:41:20.471] result() for ClusterFuture ...
[17:41:20.471] - result already collected: FutureResult
[17:41:20.471] result() for ClusterFuture ... done
[17:41:20.471] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:20.471] Future #2
[17:41:20.471] result() for ClusterFuture ...
[17:41:20.471] - result already collected: FutureResult
[17:41:20.471] result() for ClusterFuture ... done
[17:41:20.471] result() for ClusterFuture ...
[17:41:20.471] - result already collected: FutureResult
[17:41:20.472] result() for ClusterFuture ... done
[17:41:20.472] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:20.472] - nx: 2
[17:41:20.472] - relay: TRUE
[17:41:20.472] - stdout: TRUE
[17:41:20.472] - signal: TRUE
[17:41:20.472] - resignal: FALSE
[17:41:20.472] - force: TRUE
[17:41:20.472] - relayed: [n=2] FALSE, FALSE
[17:41:20.472] - queued futures: [n=2] FALSE, FALSE
[17:41:20.472]  - until=1
[17:41:20.472]  - relaying element #1
[17:41:20.473] - relayed: [n=2] FALSE, FALSE
[17:41:20.473] - queued futures: [n=2] FALSE, TRUE
[17:41:20.473] signalConditionsASAP(NULL, pos=2) ... done
[17:41:20.473]  length: 1 (resolved future 2)
[17:41:20.925] receiveMessageFromWorker() for ClusterFuture ...
[17:41:20.925] - Validating connection of MultisessionFuture
[17:41:20.926] - received message: FutureResult
[17:41:20.926] - Received FutureResult
[17:41:20.926] - Erased future from FutureRegistry
[17:41:20.926] result() for ClusterFuture ...
[17:41:20.926] - result already collected: FutureResult
[17:41:20.926] result() for ClusterFuture ... done
[17:41:20.926] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:20.926] Future #1
[17:41:20.927] result() for ClusterFuture ...
[17:41:20.927] - result already collected: FutureResult
[17:41:20.927] result() for ClusterFuture ... done
[17:41:20.927] result() for ClusterFuture ...
[17:41:20.927] - result already collected: FutureResult
[17:41:20.927] result() for ClusterFuture ... done
[17:41:20.927] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:20.927] - nx: 2
[17:41:20.927] - relay: TRUE
[17:41:20.927] - stdout: TRUE
[17:41:20.927] - signal: TRUE
[17:41:20.928] - resignal: FALSE
[17:41:20.928] - force: TRUE
[17:41:20.928] - relayed: [n=2] FALSE, FALSE
[17:41:20.928] - queued futures: [n=2] FALSE, TRUE
[17:41:20.928]  - until=1
[17:41:20.928]  - relaying element #1
[17:41:20.928] result() for ClusterFuture ...
[17:41:20.928] - result already collected: FutureResult
[17:41:20.928] result() for ClusterFuture ... done
[17:41:20.928] result() for ClusterFuture ...
[17:41:20.928] - result already collected: FutureResult
[17:41:20.928] result() for ClusterFuture ... done
[17:41:20.929] result() for ClusterFuture ...
[17:41:20.929] - result already collected: FutureResult
[17:41:20.929] result() for ClusterFuture ... done
[17:41:20.929] result() for ClusterFuture ...
[17:41:20.929] - result already collected: FutureResult
[17:41:20.929] result() for ClusterFuture ... done
[17:41:20.929] - relayed: [n=2] TRUE, FALSE
[17:41:20.929] - queued futures: [n=2] TRUE, TRUE
[17:41:20.929] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:20.929]  length: 0 (resolved future 1)
[17:41:20.929] Relaying remaining futures
[17:41:20.930] signalConditionsASAP(NULL, pos=0) ...
[17:41:20.930] - nx: 2
[17:41:20.930] - relay: TRUE
[17:41:20.930] - stdout: TRUE
[17:41:20.930] - signal: TRUE
[17:41:20.930] - resignal: FALSE
[17:41:20.930] - force: TRUE
[17:41:20.930] - relayed: [n=2] TRUE, FALSE
[17:41:20.930] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:20.930]  - relaying element #2
[17:41:20.930] result() for ClusterFuture ...
[17:41:20.931] - result already collected: FutureResult
[17:41:20.933] result() for ClusterFuture ... done
[17:41:20.933] result() for ClusterFuture ...
[17:41:20.933] - result already collected: FutureResult
[17:41:20.933] result() for ClusterFuture ... done
[17:41:20.933] result() for ClusterFuture ...
[17:41:20.933] - result already collected: FutureResult
[17:41:20.933] result() for ClusterFuture ... done
[17:41:20.933] result() for ClusterFuture ...
[17:41:20.933] - result already collected: FutureResult
[17:41:20.933] result() for ClusterFuture ... done
[17:41:20.933] - relayed: [n=2] TRUE, TRUE
[17:41:20.934] - queued futures: [n=2] TRUE, TRUE
[17:41:20.934] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:41:20.934] resolve() on list ... DONE
[17:41:20.934] result() for ClusterFuture ...
[17:41:20.934] - result already collected: FutureResult
[17:41:20.934] result() for ClusterFuture ... done
[17:41:20.934] result() for ClusterFuture ...
[17:41:20.934] - result already collected: FutureResult
[17:41:20.934] result() for ClusterFuture ... done
[17:41:20.934] result() for ClusterFuture ...
[17:41:20.934] - result already collected: FutureResult
[17:41:20.934] result() for ClusterFuture ... done
[17:41:20.935] result() for ClusterFuture ...
[17:41:20.935] - result already collected: FutureResult
[17:41:20.935] result() for ClusterFuture ... done
[17:41:20.935]  - Number of value chunks collected: 2
[17:41:20.935] Resolving 2 futures (chunks) ... DONE
[17:41:20.935] Reducing values from 2 chunks ...
[17:41:20.935]  - Number of values collected after concatenation: 2
[17:41:20.935]  - Number of values expected: 2
[17:41:20.935] Reducing values from 2 chunks ... DONE
[17:41:20.935] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:41:20.936] future_lapply() ...
[17:41:20.940] Number of chunks: 2
[17:41:20.940] getGlobalsAndPackagesXApply() ...
[17:41:20.940]  - future.globals: TRUE
[17:41:20.940] getGlobalsAndPackages() ...
[17:41:20.941] Searching for globals...
[17:41:20.942] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:41:20.942] Searching for globals ... DONE
[17:41:20.942] Resolving globals: FALSE
[17:41:20.943] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:41:20.943] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:41:20.943] - globals: [1] ‘FUN’
[17:41:20.943] 
[17:41:20.943] getGlobalsAndPackages() ... DONE
[17:41:20.943]  - globals found/used: [n=1] ‘FUN’
[17:41:20.943]  - needed namespaces: [n=0] 
[17:41:20.944] Finding globals ... DONE
[17:41:20.944]  - use_args: TRUE
[17:41:20.944]  - Getting '...' globals ...
[17:41:20.944] resolve() on list ...
[17:41:20.944]  recursive: 0
[17:41:20.944]  length: 1
[17:41:20.944]  elements: ‘...’
[17:41:20.944]  length: 0 (resolved future 1)
[17:41:20.944] resolve() on list ... DONE
[17:41:20.945]    - '...' content: [n=0] 
[17:41:20.945] List of 1
[17:41:20.945]  $ ...: list()
[17:41:20.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:20.945]  - attr(*, "where")=List of 1
[17:41:20.945]   ..$ ...:<environment: 0x55c988fbf1d0> 
[17:41:20.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:20.945]  - attr(*, "resolved")= logi TRUE
[17:41:20.945]  - attr(*, "total_size")= num NA
[17:41:20.947]  - Getting '...' globals ... DONE
[17:41:20.947] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:41:20.947] List of 2
[17:41:20.947]  $ ...future.FUN:function (x)  
[17:41:20.947]  $ ...          : list()
[17:41:20.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:41:20.947]  - attr(*, "where")=List of 2
[17:41:20.947]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:20.947]   ..$ ...          :<environment: 0x55c988fbf1d0> 
[17:41:20.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:20.947]  - attr(*, "resolved")= logi FALSE
[17:41:20.947]  - attr(*, "total_size")= num 4720
[17:41:20.950] Packages to be attached in all futures: [n=0] 
[17:41:20.950] getGlobalsAndPackagesXApply() ... DONE
[17:41:20.950] Number of futures (= number of chunks): 2
[17:41:20.950] Launching 2 futures (chunks) ...
[17:41:20.951] Chunk #1 of 2 ...
[17:41:20.951]  - Finding globals in 'X' for chunk #1 ...
[17:41:20.951] getGlobalsAndPackages() ...
[17:41:20.951] Searching for globals...
[17:41:20.951] 
[17:41:20.951] Searching for globals ... DONE
[17:41:20.951] - globals: [0] <none>
[17:41:20.951] getGlobalsAndPackages() ... DONE
[17:41:20.952]    + additional globals found: [n=0] 
[17:41:20.952]    + additional namespaces needed: [n=0] 
[17:41:20.952]  - Finding globals in 'X' for chunk #1 ... DONE
[17:41:20.952]  - seeds: <none>
[17:41:20.952] getGlobalsAndPackages() ...
[17:41:20.952] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:20.952] Resolving globals: FALSE
[17:41:20.952] Tweak future expression to call with '...' arguments ...
[17:41:20.952] {
[17:41:20.952]     do.call(function(...) {
[17:41:20.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:20.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.952]             on.exit(options(oopts), add = TRUE)
[17:41:20.952]         }
[17:41:20.952]         {
[17:41:20.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:20.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.952]                 ...future.FUN(...future.X_jj, ...)
[17:41:20.952]             })
[17:41:20.952]         }
[17:41:20.952]     }, args = future.call.arguments)
[17:41:20.952] }
[17:41:20.953] Tweak future expression to call with '...' arguments ... DONE
[17:41:20.953] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:20.953] 
[17:41:20.953] getGlobalsAndPackages() ... DONE
[17:41:20.953] run() for ‘Future’ ...
[17:41:20.954] - state: ‘created’
[17:41:20.954] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:20.970] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:20.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:20.970]   - Field: ‘node’
[17:41:20.970]   - Field: ‘label’
[17:41:20.970]   - Field: ‘local’
[17:41:20.970]   - Field: ‘owner’
[17:41:20.971]   - Field: ‘envir’
[17:41:20.971]   - Field: ‘workers’
[17:41:20.971]   - Field: ‘packages’
[17:41:20.971]   - Field: ‘gc’
[17:41:20.971]   - Field: ‘conditions’
[17:41:20.971]   - Field: ‘persistent’
[17:41:20.971]   - Field: ‘expr’
[17:41:20.971]   - Field: ‘uuid’
[17:41:20.971]   - Field: ‘seed’
[17:41:20.971]   - Field: ‘version’
[17:41:20.971]   - Field: ‘result’
[17:41:20.972]   - Field: ‘asynchronous’
[17:41:20.972]   - Field: ‘calls’
[17:41:20.972]   - Field: ‘globals’
[17:41:20.972]   - Field: ‘stdout’
[17:41:20.972]   - Field: ‘earlySignal’
[17:41:20.972]   - Field: ‘lazy’
[17:41:20.972]   - Field: ‘state’
[17:41:20.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:20.972] - Launch lazy future ...
[17:41:20.973] Packages needed by the future expression (n = 0): <none>
[17:41:20.973] Packages needed by future strategies (n = 0): <none>
[17:41:20.973] {
[17:41:20.973]     {
[17:41:20.973]         {
[17:41:20.973]             ...future.startTime <- base::Sys.time()
[17:41:20.973]             {
[17:41:20.973]                 {
[17:41:20.973]                   {
[17:41:20.973]                     {
[17:41:20.973]                       base::local({
[17:41:20.973]                         has_future <- base::requireNamespace("future", 
[17:41:20.973]                           quietly = TRUE)
[17:41:20.973]                         if (has_future) {
[17:41:20.973]                           ns <- base::getNamespace("future")
[17:41:20.973]                           version <- ns[[".package"]][["version"]]
[17:41:20.973]                           if (is.null(version)) 
[17:41:20.973]                             version <- utils::packageVersion("future")
[17:41:20.973]                         }
[17:41:20.973]                         else {
[17:41:20.973]                           version <- NULL
[17:41:20.973]                         }
[17:41:20.973]                         if (!has_future || version < "1.8.0") {
[17:41:20.973]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:20.973]                             "", base::R.version$version.string), 
[17:41:20.973]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:20.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:20.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:20.973]                               "release", "version")], collapse = " "), 
[17:41:20.973]                             hostname = base::Sys.info()[["nodename"]])
[17:41:20.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:20.973]                             info)
[17:41:20.973]                           info <- base::paste(info, collapse = "; ")
[17:41:20.973]                           if (!has_future) {
[17:41:20.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:20.973]                               info)
[17:41:20.973]                           }
[17:41:20.973]                           else {
[17:41:20.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:20.973]                               info, version)
[17:41:20.973]                           }
[17:41:20.973]                           base::stop(msg)
[17:41:20.973]                         }
[17:41:20.973]                       })
[17:41:20.973]                     }
[17:41:20.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:20.973]                     base::options(mc.cores = 1L)
[17:41:20.973]                   }
[17:41:20.973]                   options(future.plan = NULL)
[17:41:20.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:20.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:20.973]                 }
[17:41:20.973]                 ...future.workdir <- getwd()
[17:41:20.973]             }
[17:41:20.973]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:20.973]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:20.973]         }
[17:41:20.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:20.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:20.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:20.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:20.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:20.973]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:20.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:20.973]             base::names(...future.oldOptions))
[17:41:20.973]     }
[17:41:20.973]     if (TRUE) {
[17:41:20.973]     }
[17:41:20.973]     else {
[17:41:20.973]         if (NA) {
[17:41:20.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:20.973]                 open = "w")
[17:41:20.973]         }
[17:41:20.973]         else {
[17:41:20.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:20.973]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:20.973]         }
[17:41:20.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:20.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:20.973]             base::sink(type = "output", split = FALSE)
[17:41:20.973]             base::close(...future.stdout)
[17:41:20.973]         }, add = TRUE)
[17:41:20.973]     }
[17:41:20.973]     ...future.frame <- base::sys.nframe()
[17:41:20.973]     ...future.conditions <- base::list()
[17:41:20.973]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:20.973]     if (FALSE) {
[17:41:20.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:20.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:20.973]     }
[17:41:20.973]     ...future.result <- base::tryCatch({
[17:41:20.973]         base::withCallingHandlers({
[17:41:20.973]             ...future.value <- base::withVisible(base::local({
[17:41:20.973]                 ...future.makeSendCondition <- local({
[17:41:20.973]                   sendCondition <- NULL
[17:41:20.973]                   function(frame = 1L) {
[17:41:20.973]                     if (is.function(sendCondition)) 
[17:41:20.973]                       return(sendCondition)
[17:41:20.973]                     ns <- getNamespace("parallel")
[17:41:20.973]                     if (exists("sendData", mode = "function", 
[17:41:20.973]                       envir = ns)) {
[17:41:20.973]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:20.973]                         envir = ns)
[17:41:20.973]                       envir <- sys.frame(frame)
[17:41:20.973]                       master <- NULL
[17:41:20.973]                       while (!identical(envir, .GlobalEnv) && 
[17:41:20.973]                         !identical(envir, emptyenv())) {
[17:41:20.973]                         if (exists("master", mode = "list", envir = envir, 
[17:41:20.973]                           inherits = FALSE)) {
[17:41:20.973]                           master <- get("master", mode = "list", 
[17:41:20.973]                             envir = envir, inherits = FALSE)
[17:41:20.973]                           if (inherits(master, c("SOCKnode", 
[17:41:20.973]                             "SOCK0node"))) {
[17:41:20.973]                             sendCondition <<- function(cond) {
[17:41:20.973]                               data <- list(type = "VALUE", value = cond, 
[17:41:20.973]                                 success = TRUE)
[17:41:20.973]                               parallel_sendData(master, data)
[17:41:20.973]                             }
[17:41:20.973]                             return(sendCondition)
[17:41:20.973]                           }
[17:41:20.973]                         }
[17:41:20.973]                         frame <- frame + 1L
[17:41:20.973]                         envir <- sys.frame(frame)
[17:41:20.973]                       }
[17:41:20.973]                     }
[17:41:20.973]                     sendCondition <<- function(cond) NULL
[17:41:20.973]                   }
[17:41:20.973]                 })
[17:41:20.973]                 withCallingHandlers({
[17:41:20.973]                   {
[17:41:20.973]                     do.call(function(...) {
[17:41:20.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.973]                       if (!identical(...future.globals.maxSize.org, 
[17:41:20.973]                         ...future.globals.maxSize)) {
[17:41:20.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.973]                         on.exit(options(oopts), add = TRUE)
[17:41:20.973]                       }
[17:41:20.973]                       {
[17:41:20.973]                         lapply(seq_along(...future.elements_ii), 
[17:41:20.973]                           FUN = function(jj) {
[17:41:20.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.973]                             ...future.FUN(...future.X_jj, ...)
[17:41:20.973]                           })
[17:41:20.973]                       }
[17:41:20.973]                     }, args = future.call.arguments)
[17:41:20.973]                   }
[17:41:20.973]                 }, immediateCondition = function(cond) {
[17:41:20.973]                   sendCondition <- ...future.makeSendCondition()
[17:41:20.973]                   sendCondition(cond)
[17:41:20.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.973]                   {
[17:41:20.973]                     inherits <- base::inherits
[17:41:20.973]                     invokeRestart <- base::invokeRestart
[17:41:20.973]                     is.null <- base::is.null
[17:41:20.973]                     muffled <- FALSE
[17:41:20.973]                     if (inherits(cond, "message")) {
[17:41:20.973]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:20.973]                       if (muffled) 
[17:41:20.973]                         invokeRestart("muffleMessage")
[17:41:20.973]                     }
[17:41:20.973]                     else if (inherits(cond, "warning")) {
[17:41:20.973]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:20.973]                       if (muffled) 
[17:41:20.973]                         invokeRestart("muffleWarning")
[17:41:20.973]                     }
[17:41:20.973]                     else if (inherits(cond, "condition")) {
[17:41:20.973]                       if (!is.null(pattern)) {
[17:41:20.973]                         computeRestarts <- base::computeRestarts
[17:41:20.973]                         grepl <- base::grepl
[17:41:20.973]                         restarts <- computeRestarts(cond)
[17:41:20.973]                         for (restart in restarts) {
[17:41:20.973]                           name <- restart$name
[17:41:20.973]                           if (is.null(name)) 
[17:41:20.973]                             next
[17:41:20.973]                           if (!grepl(pattern, name)) 
[17:41:20.973]                             next
[17:41:20.973]                           invokeRestart(restart)
[17:41:20.973]                           muffled <- TRUE
[17:41:20.973]                           break
[17:41:20.973]                         }
[17:41:20.973]                       }
[17:41:20.973]                     }
[17:41:20.973]                     invisible(muffled)
[17:41:20.973]                   }
[17:41:20.973]                   muffleCondition(cond)
[17:41:20.973]                 })
[17:41:20.973]             }))
[17:41:20.973]             future::FutureResult(value = ...future.value$value, 
[17:41:20.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:20.973]                   ...future.rng), globalenv = if (FALSE) 
[17:41:20.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:20.973]                     ...future.globalenv.names))
[17:41:20.973]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:20.973]         }, condition = base::local({
[17:41:20.973]             c <- base::c
[17:41:20.973]             inherits <- base::inherits
[17:41:20.973]             invokeRestart <- base::invokeRestart
[17:41:20.973]             length <- base::length
[17:41:20.973]             list <- base::list
[17:41:20.973]             seq.int <- base::seq.int
[17:41:20.973]             signalCondition <- base::signalCondition
[17:41:20.973]             sys.calls <- base::sys.calls
[17:41:20.973]             `[[` <- base::`[[`
[17:41:20.973]             `+` <- base::`+`
[17:41:20.973]             `<<-` <- base::`<<-`
[17:41:20.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:20.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:20.973]                   3L)]
[17:41:20.973]             }
[17:41:20.973]             function(cond) {
[17:41:20.973]                 is_error <- inherits(cond, "error")
[17:41:20.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:20.973]                   NULL)
[17:41:20.973]                 if (is_error) {
[17:41:20.973]                   sessionInformation <- function() {
[17:41:20.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:20.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:20.973]                       search = base::search(), system = base::Sys.info())
[17:41:20.973]                   }
[17:41:20.973]                   ...future.conditions[[length(...future.conditions) + 
[17:41:20.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:20.973]                     cond$call), session = sessionInformation(), 
[17:41:20.973]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:20.973]                   signalCondition(cond)
[17:41:20.973]                 }
[17:41:20.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:20.973]                 "immediateCondition"))) {
[17:41:20.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:20.973]                   ...future.conditions[[length(...future.conditions) + 
[17:41:20.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:20.973]                   if (TRUE && !signal) {
[17:41:20.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.973]                     {
[17:41:20.973]                       inherits <- base::inherits
[17:41:20.973]                       invokeRestart <- base::invokeRestart
[17:41:20.973]                       is.null <- base::is.null
[17:41:20.973]                       muffled <- FALSE
[17:41:20.973]                       if (inherits(cond, "message")) {
[17:41:20.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:20.973]                         if (muffled) 
[17:41:20.973]                           invokeRestart("muffleMessage")
[17:41:20.973]                       }
[17:41:20.973]                       else if (inherits(cond, "warning")) {
[17:41:20.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:20.973]                         if (muffled) 
[17:41:20.973]                           invokeRestart("muffleWarning")
[17:41:20.973]                       }
[17:41:20.973]                       else if (inherits(cond, "condition")) {
[17:41:20.973]                         if (!is.null(pattern)) {
[17:41:20.973]                           computeRestarts <- base::computeRestarts
[17:41:20.973]                           grepl <- base::grepl
[17:41:20.973]                           restarts <- computeRestarts(cond)
[17:41:20.973]                           for (restart in restarts) {
[17:41:20.973]                             name <- restart$name
[17:41:20.973]                             if (is.null(name)) 
[17:41:20.973]                               next
[17:41:20.973]                             if (!grepl(pattern, name)) 
[17:41:20.973]                               next
[17:41:20.973]                             invokeRestart(restart)
[17:41:20.973]                             muffled <- TRUE
[17:41:20.973]                             break
[17:41:20.973]                           }
[17:41:20.973]                         }
[17:41:20.973]                       }
[17:41:20.973]                       invisible(muffled)
[17:41:20.973]                     }
[17:41:20.973]                     muffleCondition(cond, pattern = "^muffle")
[17:41:20.973]                   }
[17:41:20.973]                 }
[17:41:20.973]                 else {
[17:41:20.973]                   if (TRUE) {
[17:41:20.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:20.973]                     {
[17:41:20.973]                       inherits <- base::inherits
[17:41:20.973]                       invokeRestart <- base::invokeRestart
[17:41:20.973]                       is.null <- base::is.null
[17:41:20.973]                       muffled <- FALSE
[17:41:20.973]                       if (inherits(cond, "message")) {
[17:41:20.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:20.973]                         if (muffled) 
[17:41:20.973]                           invokeRestart("muffleMessage")
[17:41:20.973]                       }
[17:41:20.973]                       else if (inherits(cond, "warning")) {
[17:41:20.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:20.973]                         if (muffled) 
[17:41:20.973]                           invokeRestart("muffleWarning")
[17:41:20.973]                       }
[17:41:20.973]                       else if (inherits(cond, "condition")) {
[17:41:20.973]                         if (!is.null(pattern)) {
[17:41:20.973]                           computeRestarts <- base::computeRestarts
[17:41:20.973]                           grepl <- base::grepl
[17:41:20.973]                           restarts <- computeRestarts(cond)
[17:41:20.973]                           for (restart in restarts) {
[17:41:20.973]                             name <- restart$name
[17:41:20.973]                             if (is.null(name)) 
[17:41:20.973]                               next
[17:41:20.973]                             if (!grepl(pattern, name)) 
[17:41:20.973]                               next
[17:41:20.973]                             invokeRestart(restart)
[17:41:20.973]                             muffled <- TRUE
[17:41:20.973]                             break
[17:41:20.973]                           }
[17:41:20.973]                         }
[17:41:20.973]                       }
[17:41:20.973]                       invisible(muffled)
[17:41:20.973]                     }
[17:41:20.973]                     muffleCondition(cond, pattern = "^muffle")
[17:41:20.973]                   }
[17:41:20.973]                 }
[17:41:20.973]             }
[17:41:20.973]         }))
[17:41:20.973]     }, error = function(ex) {
[17:41:20.973]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:20.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:20.973]                 ...future.rng), started = ...future.startTime, 
[17:41:20.973]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:20.973]             version = "1.8"), class = "FutureResult")
[17:41:20.973]     }, finally = {
[17:41:20.973]         if (!identical(...future.workdir, getwd())) 
[17:41:20.973]             setwd(...future.workdir)
[17:41:20.973]         {
[17:41:20.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:20.973]                 ...future.oldOptions$nwarnings <- NULL
[17:41:20.973]             }
[17:41:20.973]             base::options(...future.oldOptions)
[17:41:20.973]             if (.Platform$OS.type == "windows") {
[17:41:20.973]                 old_names <- names(...future.oldEnvVars)
[17:41:20.973]                 envs <- base::Sys.getenv()
[17:41:20.973]                 names <- names(envs)
[17:41:20.973]                 common <- intersect(names, old_names)
[17:41:20.973]                 added <- setdiff(names, old_names)
[17:41:20.973]                 removed <- setdiff(old_names, names)
[17:41:20.973]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:20.973]                   envs[common]]
[17:41:20.973]                 NAMES <- toupper(changed)
[17:41:20.973]                 args <- list()
[17:41:20.973]                 for (kk in seq_along(NAMES)) {
[17:41:20.973]                   name <- changed[[kk]]
[17:41:20.973]                   NAME <- NAMES[[kk]]
[17:41:20.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.973]                     next
[17:41:20.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:20.973]                 }
[17:41:20.973]                 NAMES <- toupper(added)
[17:41:20.973]                 for (kk in seq_along(NAMES)) {
[17:41:20.973]                   name <- added[[kk]]
[17:41:20.973]                   NAME <- NAMES[[kk]]
[17:41:20.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.973]                     next
[17:41:20.973]                   args[[name]] <- ""
[17:41:20.973]                 }
[17:41:20.973]                 NAMES <- toupper(removed)
[17:41:20.973]                 for (kk in seq_along(NAMES)) {
[17:41:20.973]                   name <- removed[[kk]]
[17:41:20.973]                   NAME <- NAMES[[kk]]
[17:41:20.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:20.973]                     next
[17:41:20.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:20.973]                 }
[17:41:20.973]                 if (length(args) > 0) 
[17:41:20.973]                   base::do.call(base::Sys.setenv, args = args)
[17:41:20.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:20.973]             }
[17:41:20.973]             else {
[17:41:20.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:20.973]             }
[17:41:20.973]             {
[17:41:20.973]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:20.973]                   0L) {
[17:41:20.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:20.973]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:20.973]                   base::options(opts)
[17:41:20.973]                 }
[17:41:20.973]                 {
[17:41:20.973]                   {
[17:41:20.973]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:20.973]                     NULL
[17:41:20.973]                   }
[17:41:20.973]                   options(future.plan = NULL)
[17:41:20.973]                   if (is.na(NA_character_)) 
[17:41:20.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:20.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:20.973]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:20.973]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:20.973]                     envir = parent.frame()) 
[17:41:20.973]                   {
[17:41:20.973]                     if (is.function(workers)) 
[17:41:20.973]                       workers <- workers()
[17:41:20.973]                     workers <- structure(as.integer(workers), 
[17:41:20.973]                       class = class(workers))
[17:41:20.973]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:20.973]                       workers >= 1)
[17:41:20.973]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:20.973]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:20.973]                     }
[17:41:20.973]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:20.973]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:20.973]                       envir = envir)
[17:41:20.973]                     if (!future$lazy) 
[17:41:20.973]                       future <- run(future)
[17:41:20.973]                     invisible(future)
[17:41:20.973]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:20.973]                 }
[17:41:20.973]             }
[17:41:20.973]         }
[17:41:20.973]     })
[17:41:20.973]     if (FALSE) {
[17:41:20.973]         base::sink(type = "output", split = FALSE)
[17:41:20.973]         if (NA) {
[17:41:20.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:20.973]         }
[17:41:20.973]         else {
[17:41:20.973]             ...future.result["stdout"] <- base::list(NULL)
[17:41:20.973]         }
[17:41:20.973]         base::close(...future.stdout)
[17:41:20.973]         ...future.stdout <- NULL
[17:41:20.973]     }
[17:41:20.973]     ...future.result$conditions <- ...future.conditions
[17:41:20.973]     ...future.result$finished <- base::Sys.time()
[17:41:20.973]     ...future.result
[17:41:20.973] }
[17:41:20.976] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:41:20.976] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:41:20.977] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:41:20.977] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:41:20.977] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:41:20.978] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:41:20.978] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:41:20.978] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:20.978] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:20.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:20.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:20.979] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:41:20.980] MultisessionFuture started
[17:41:20.980] - Launch lazy future ... done
[17:41:20.980] run() for ‘MultisessionFuture’ ... done
[17:41:20.980] Created future:
[17:41:20.980] MultisessionFuture:
[17:41:20.980] Label: ‘future_lapply-1’
[17:41:20.980] Expression:
[17:41:20.980] {
[17:41:20.980]     do.call(function(...) {
[17:41:20.980]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.980]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:20.980]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.980]             on.exit(options(oopts), add = TRUE)
[17:41:20.980]         }
[17:41:20.980]         {
[17:41:20.980]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:20.980]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.980]                 ...future.FUN(...future.X_jj, ...)
[17:41:20.980]             })
[17:41:20.980]         }
[17:41:20.980]     }, args = future.call.arguments)
[17:41:20.980] }
[17:41:20.980] Lazy evaluation: FALSE
[17:41:20.980] Asynchronous evaluation: TRUE
[17:41:20.980] Local evaluation: TRUE
[17:41:20.980] Environment: R_GlobalEnv
[17:41:20.980] Capture standard output: NA
[17:41:20.980] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:20.980] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:20.980] Packages: <none>
[17:41:20.980] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:20.980] Resolved: FALSE
[17:41:20.980] Value: <not collected>
[17:41:20.980] Conditions captured: <none>
[17:41:20.980] Early signaling: FALSE
[17:41:20.980] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:20.980] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:20.992] Chunk #1 of 2 ... DONE
[17:41:20.992] Chunk #2 of 2 ...
[17:41:20.992]  - Finding globals in 'X' for chunk #2 ...
[17:41:20.992] getGlobalsAndPackages() ...
[17:41:20.992] Searching for globals...
[17:41:20.993] 
[17:41:20.993] Searching for globals ... DONE
[17:41:20.993] - globals: [0] <none>
[17:41:20.993] getGlobalsAndPackages() ... DONE
[17:41:20.993]    + additional globals found: [n=0] 
[17:41:20.993]    + additional namespaces needed: [n=0] 
[17:41:20.993]  - Finding globals in 'X' for chunk #2 ... DONE
[17:41:20.993]  - seeds: <none>
[17:41:20.994] getGlobalsAndPackages() ...
[17:41:20.994] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:20.994] Resolving globals: FALSE
[17:41:20.994] Tweak future expression to call with '...' arguments ...
[17:41:20.994] {
[17:41:20.994]     do.call(function(...) {
[17:41:20.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:20.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:20.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:20.994]             on.exit(options(oopts), add = TRUE)
[17:41:20.994]         }
[17:41:20.994]         {
[17:41:20.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:20.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:20.994]                 ...future.FUN(...future.X_jj, ...)
[17:41:20.994]             })
[17:41:20.994]         }
[17:41:20.994]     }, args = future.call.arguments)
[17:41:20.994] }
[17:41:20.994] Tweak future expression to call with '...' arguments ... DONE
[17:41:20.995] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:20.995] 
[17:41:20.995] getGlobalsAndPackages() ... DONE
[17:41:20.995] run() for ‘Future’ ...
[17:41:20.995] - state: ‘created’
[17:41:20.996] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:21.010] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:21.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:21.011]   - Field: ‘node’
[17:41:21.011]   - Field: ‘label’
[17:41:21.011]   - Field: ‘local’
[17:41:21.011]   - Field: ‘owner’
[17:41:21.011]   - Field: ‘envir’
[17:41:21.011]   - Field: ‘workers’
[17:41:21.011]   - Field: ‘packages’
[17:41:21.011]   - Field: ‘gc’
[17:41:21.011]   - Field: ‘conditions’
[17:41:21.012]   - Field: ‘persistent’
[17:41:21.012]   - Field: ‘expr’
[17:41:21.012]   - Field: ‘uuid’
[17:41:21.012]   - Field: ‘seed’
[17:41:21.012]   - Field: ‘version’
[17:41:21.012]   - Field: ‘result’
[17:41:21.012]   - Field: ‘asynchronous’
[17:41:21.012]   - Field: ‘calls’
[17:41:21.012]   - Field: ‘globals’
[17:41:21.012]   - Field: ‘stdout’
[17:41:21.012]   - Field: ‘earlySignal’
[17:41:21.013]   - Field: ‘lazy’
[17:41:21.013]   - Field: ‘state’
[17:41:21.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:21.013] - Launch lazy future ...
[17:41:21.013] Packages needed by the future expression (n = 0): <none>
[17:41:21.013] Packages needed by future strategies (n = 0): <none>
[17:41:21.014] {
[17:41:21.014]     {
[17:41:21.014]         {
[17:41:21.014]             ...future.startTime <- base::Sys.time()
[17:41:21.014]             {
[17:41:21.014]                 {
[17:41:21.014]                   {
[17:41:21.014]                     {
[17:41:21.014]                       base::local({
[17:41:21.014]                         has_future <- base::requireNamespace("future", 
[17:41:21.014]                           quietly = TRUE)
[17:41:21.014]                         if (has_future) {
[17:41:21.014]                           ns <- base::getNamespace("future")
[17:41:21.014]                           version <- ns[[".package"]][["version"]]
[17:41:21.014]                           if (is.null(version)) 
[17:41:21.014]                             version <- utils::packageVersion("future")
[17:41:21.014]                         }
[17:41:21.014]                         else {
[17:41:21.014]                           version <- NULL
[17:41:21.014]                         }
[17:41:21.014]                         if (!has_future || version < "1.8.0") {
[17:41:21.014]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:21.014]                             "", base::R.version$version.string), 
[17:41:21.014]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:21.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:21.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:21.014]                               "release", "version")], collapse = " "), 
[17:41:21.014]                             hostname = base::Sys.info()[["nodename"]])
[17:41:21.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:21.014]                             info)
[17:41:21.014]                           info <- base::paste(info, collapse = "; ")
[17:41:21.014]                           if (!has_future) {
[17:41:21.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:21.014]                               info)
[17:41:21.014]                           }
[17:41:21.014]                           else {
[17:41:21.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:21.014]                               info, version)
[17:41:21.014]                           }
[17:41:21.014]                           base::stop(msg)
[17:41:21.014]                         }
[17:41:21.014]                       })
[17:41:21.014]                     }
[17:41:21.014]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:21.014]                     base::options(mc.cores = 1L)
[17:41:21.014]                   }
[17:41:21.014]                   options(future.plan = NULL)
[17:41:21.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:21.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:21.014]                 }
[17:41:21.014]                 ...future.workdir <- getwd()
[17:41:21.014]             }
[17:41:21.014]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:21.014]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:21.014]         }
[17:41:21.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:21.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:21.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:21.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:21.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:21.014]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:21.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:21.014]             base::names(...future.oldOptions))
[17:41:21.014]     }
[17:41:21.014]     if (TRUE) {
[17:41:21.014]     }
[17:41:21.014]     else {
[17:41:21.014]         if (NA) {
[17:41:21.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:21.014]                 open = "w")
[17:41:21.014]         }
[17:41:21.014]         else {
[17:41:21.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:21.014]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:21.014]         }
[17:41:21.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:21.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:21.014]             base::sink(type = "output", split = FALSE)
[17:41:21.014]             base::close(...future.stdout)
[17:41:21.014]         }, add = TRUE)
[17:41:21.014]     }
[17:41:21.014]     ...future.frame <- base::sys.nframe()
[17:41:21.014]     ...future.conditions <- base::list()
[17:41:21.014]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:21.014]     if (FALSE) {
[17:41:21.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:21.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:21.014]     }
[17:41:21.014]     ...future.result <- base::tryCatch({
[17:41:21.014]         base::withCallingHandlers({
[17:41:21.014]             ...future.value <- base::withVisible(base::local({
[17:41:21.014]                 ...future.makeSendCondition <- local({
[17:41:21.014]                   sendCondition <- NULL
[17:41:21.014]                   function(frame = 1L) {
[17:41:21.014]                     if (is.function(sendCondition)) 
[17:41:21.014]                       return(sendCondition)
[17:41:21.014]                     ns <- getNamespace("parallel")
[17:41:21.014]                     if (exists("sendData", mode = "function", 
[17:41:21.014]                       envir = ns)) {
[17:41:21.014]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:21.014]                         envir = ns)
[17:41:21.014]                       envir <- sys.frame(frame)
[17:41:21.014]                       master <- NULL
[17:41:21.014]                       while (!identical(envir, .GlobalEnv) && 
[17:41:21.014]                         !identical(envir, emptyenv())) {
[17:41:21.014]                         if (exists("master", mode = "list", envir = envir, 
[17:41:21.014]                           inherits = FALSE)) {
[17:41:21.014]                           master <- get("master", mode = "list", 
[17:41:21.014]                             envir = envir, inherits = FALSE)
[17:41:21.014]                           if (inherits(master, c("SOCKnode", 
[17:41:21.014]                             "SOCK0node"))) {
[17:41:21.014]                             sendCondition <<- function(cond) {
[17:41:21.014]                               data <- list(type = "VALUE", value = cond, 
[17:41:21.014]                                 success = TRUE)
[17:41:21.014]                               parallel_sendData(master, data)
[17:41:21.014]                             }
[17:41:21.014]                             return(sendCondition)
[17:41:21.014]                           }
[17:41:21.014]                         }
[17:41:21.014]                         frame <- frame + 1L
[17:41:21.014]                         envir <- sys.frame(frame)
[17:41:21.014]                       }
[17:41:21.014]                     }
[17:41:21.014]                     sendCondition <<- function(cond) NULL
[17:41:21.014]                   }
[17:41:21.014]                 })
[17:41:21.014]                 withCallingHandlers({
[17:41:21.014]                   {
[17:41:21.014]                     do.call(function(...) {
[17:41:21.014]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:21.014]                       if (!identical(...future.globals.maxSize.org, 
[17:41:21.014]                         ...future.globals.maxSize)) {
[17:41:21.014]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:21.014]                         on.exit(options(oopts), add = TRUE)
[17:41:21.014]                       }
[17:41:21.014]                       {
[17:41:21.014]                         lapply(seq_along(...future.elements_ii), 
[17:41:21.014]                           FUN = function(jj) {
[17:41:21.014]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:21.014]                             ...future.FUN(...future.X_jj, ...)
[17:41:21.014]                           })
[17:41:21.014]                       }
[17:41:21.014]                     }, args = future.call.arguments)
[17:41:21.014]                   }
[17:41:21.014]                 }, immediateCondition = function(cond) {
[17:41:21.014]                   sendCondition <- ...future.makeSendCondition()
[17:41:21.014]                   sendCondition(cond)
[17:41:21.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.014]                   {
[17:41:21.014]                     inherits <- base::inherits
[17:41:21.014]                     invokeRestart <- base::invokeRestart
[17:41:21.014]                     is.null <- base::is.null
[17:41:21.014]                     muffled <- FALSE
[17:41:21.014]                     if (inherits(cond, "message")) {
[17:41:21.014]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:21.014]                       if (muffled) 
[17:41:21.014]                         invokeRestart("muffleMessage")
[17:41:21.014]                     }
[17:41:21.014]                     else if (inherits(cond, "warning")) {
[17:41:21.014]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:21.014]                       if (muffled) 
[17:41:21.014]                         invokeRestart("muffleWarning")
[17:41:21.014]                     }
[17:41:21.014]                     else if (inherits(cond, "condition")) {
[17:41:21.014]                       if (!is.null(pattern)) {
[17:41:21.014]                         computeRestarts <- base::computeRestarts
[17:41:21.014]                         grepl <- base::grepl
[17:41:21.014]                         restarts <- computeRestarts(cond)
[17:41:21.014]                         for (restart in restarts) {
[17:41:21.014]                           name <- restart$name
[17:41:21.014]                           if (is.null(name)) 
[17:41:21.014]                             next
[17:41:21.014]                           if (!grepl(pattern, name)) 
[17:41:21.014]                             next
[17:41:21.014]                           invokeRestart(restart)
[17:41:21.014]                           muffled <- TRUE
[17:41:21.014]                           break
[17:41:21.014]                         }
[17:41:21.014]                       }
[17:41:21.014]                     }
[17:41:21.014]                     invisible(muffled)
[17:41:21.014]                   }
[17:41:21.014]                   muffleCondition(cond)
[17:41:21.014]                 })
[17:41:21.014]             }))
[17:41:21.014]             future::FutureResult(value = ...future.value$value, 
[17:41:21.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:21.014]                   ...future.rng), globalenv = if (FALSE) 
[17:41:21.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:21.014]                     ...future.globalenv.names))
[17:41:21.014]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:21.014]         }, condition = base::local({
[17:41:21.014]             c <- base::c
[17:41:21.014]             inherits <- base::inherits
[17:41:21.014]             invokeRestart <- base::invokeRestart
[17:41:21.014]             length <- base::length
[17:41:21.014]             list <- base::list
[17:41:21.014]             seq.int <- base::seq.int
[17:41:21.014]             signalCondition <- base::signalCondition
[17:41:21.014]             sys.calls <- base::sys.calls
[17:41:21.014]             `[[` <- base::`[[`
[17:41:21.014]             `+` <- base::`+`
[17:41:21.014]             `<<-` <- base::`<<-`
[17:41:21.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:21.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:21.014]                   3L)]
[17:41:21.014]             }
[17:41:21.014]             function(cond) {
[17:41:21.014]                 is_error <- inherits(cond, "error")
[17:41:21.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:21.014]                   NULL)
[17:41:21.014]                 if (is_error) {
[17:41:21.014]                   sessionInformation <- function() {
[17:41:21.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:21.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:21.014]                       search = base::search(), system = base::Sys.info())
[17:41:21.014]                   }
[17:41:21.014]                   ...future.conditions[[length(...future.conditions) + 
[17:41:21.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:21.014]                     cond$call), session = sessionInformation(), 
[17:41:21.014]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:21.014]                   signalCondition(cond)
[17:41:21.014]                 }
[17:41:21.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:21.014]                 "immediateCondition"))) {
[17:41:21.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:21.014]                   ...future.conditions[[length(...future.conditions) + 
[17:41:21.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:21.014]                   if (TRUE && !signal) {
[17:41:21.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.014]                     {
[17:41:21.014]                       inherits <- base::inherits
[17:41:21.014]                       invokeRestart <- base::invokeRestart
[17:41:21.014]                       is.null <- base::is.null
[17:41:21.014]                       muffled <- FALSE
[17:41:21.014]                       if (inherits(cond, "message")) {
[17:41:21.014]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:21.014]                         if (muffled) 
[17:41:21.014]                           invokeRestart("muffleMessage")
[17:41:21.014]                       }
[17:41:21.014]                       else if (inherits(cond, "warning")) {
[17:41:21.014]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:21.014]                         if (muffled) 
[17:41:21.014]                           invokeRestart("muffleWarning")
[17:41:21.014]                       }
[17:41:21.014]                       else if (inherits(cond, "condition")) {
[17:41:21.014]                         if (!is.null(pattern)) {
[17:41:21.014]                           computeRestarts <- base::computeRestarts
[17:41:21.014]                           grepl <- base::grepl
[17:41:21.014]                           restarts <- computeRestarts(cond)
[17:41:21.014]                           for (restart in restarts) {
[17:41:21.014]                             name <- restart$name
[17:41:21.014]                             if (is.null(name)) 
[17:41:21.014]                               next
[17:41:21.014]                             if (!grepl(pattern, name)) 
[17:41:21.014]                               next
[17:41:21.014]                             invokeRestart(restart)
[17:41:21.014]                             muffled <- TRUE
[17:41:21.014]                             break
[17:41:21.014]                           }
[17:41:21.014]                         }
[17:41:21.014]                       }
[17:41:21.014]                       invisible(muffled)
[17:41:21.014]                     }
[17:41:21.014]                     muffleCondition(cond, pattern = "^muffle")
[17:41:21.014]                   }
[17:41:21.014]                 }
[17:41:21.014]                 else {
[17:41:21.014]                   if (TRUE) {
[17:41:21.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.014]                     {
[17:41:21.014]                       inherits <- base::inherits
[17:41:21.014]                       invokeRestart <- base::invokeRestart
[17:41:21.014]                       is.null <- base::is.null
[17:41:21.014]                       muffled <- FALSE
[17:41:21.014]                       if (inherits(cond, "message")) {
[17:41:21.014]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:21.014]                         if (muffled) 
[17:41:21.014]                           invokeRestart("muffleMessage")
[17:41:21.014]                       }
[17:41:21.014]                       else if (inherits(cond, "warning")) {
[17:41:21.014]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:21.014]                         if (muffled) 
[17:41:21.014]                           invokeRestart("muffleWarning")
[17:41:21.014]                       }
[17:41:21.014]                       else if (inherits(cond, "condition")) {
[17:41:21.014]                         if (!is.null(pattern)) {
[17:41:21.014]                           computeRestarts <- base::computeRestarts
[17:41:21.014]                           grepl <- base::grepl
[17:41:21.014]                           restarts <- computeRestarts(cond)
[17:41:21.014]                           for (restart in restarts) {
[17:41:21.014]                             name <- restart$name
[17:41:21.014]                             if (is.null(name)) 
[17:41:21.014]                               next
[17:41:21.014]                             if (!grepl(pattern, name)) 
[17:41:21.014]                               next
[17:41:21.014]                             invokeRestart(restart)
[17:41:21.014]                             muffled <- TRUE
[17:41:21.014]                             break
[17:41:21.014]                           }
[17:41:21.014]                         }
[17:41:21.014]                       }
[17:41:21.014]                       invisible(muffled)
[17:41:21.014]                     }
[17:41:21.014]                     muffleCondition(cond, pattern = "^muffle")
[17:41:21.014]                   }
[17:41:21.014]                 }
[17:41:21.014]             }
[17:41:21.014]         }))
[17:41:21.014]     }, error = function(ex) {
[17:41:21.014]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:21.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:21.014]                 ...future.rng), started = ...future.startTime, 
[17:41:21.014]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:21.014]             version = "1.8"), class = "FutureResult")
[17:41:21.014]     }, finally = {
[17:41:21.014]         if (!identical(...future.workdir, getwd())) 
[17:41:21.014]             setwd(...future.workdir)
[17:41:21.014]         {
[17:41:21.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:21.014]                 ...future.oldOptions$nwarnings <- NULL
[17:41:21.014]             }
[17:41:21.014]             base::options(...future.oldOptions)
[17:41:21.014]             if (.Platform$OS.type == "windows") {
[17:41:21.014]                 old_names <- names(...future.oldEnvVars)
[17:41:21.014]                 envs <- base::Sys.getenv()
[17:41:21.014]                 names <- names(envs)
[17:41:21.014]                 common <- intersect(names, old_names)
[17:41:21.014]                 added <- setdiff(names, old_names)
[17:41:21.014]                 removed <- setdiff(old_names, names)
[17:41:21.014]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:21.014]                   envs[common]]
[17:41:21.014]                 NAMES <- toupper(changed)
[17:41:21.014]                 args <- list()
[17:41:21.014]                 for (kk in seq_along(NAMES)) {
[17:41:21.014]                   name <- changed[[kk]]
[17:41:21.014]                   NAME <- NAMES[[kk]]
[17:41:21.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.014]                     next
[17:41:21.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:21.014]                 }
[17:41:21.014]                 NAMES <- toupper(added)
[17:41:21.014]                 for (kk in seq_along(NAMES)) {
[17:41:21.014]                   name <- added[[kk]]
[17:41:21.014]                   NAME <- NAMES[[kk]]
[17:41:21.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.014]                     next
[17:41:21.014]                   args[[name]] <- ""
[17:41:21.014]                 }
[17:41:21.014]                 NAMES <- toupper(removed)
[17:41:21.014]                 for (kk in seq_along(NAMES)) {
[17:41:21.014]                   name <- removed[[kk]]
[17:41:21.014]                   NAME <- NAMES[[kk]]
[17:41:21.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.014]                     next
[17:41:21.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:21.014]                 }
[17:41:21.014]                 if (length(args) > 0) 
[17:41:21.014]                   base::do.call(base::Sys.setenv, args = args)
[17:41:21.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:21.014]             }
[17:41:21.014]             else {
[17:41:21.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:21.014]             }
[17:41:21.014]             {
[17:41:21.014]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:21.014]                   0L) {
[17:41:21.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:21.014]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:21.014]                   base::options(opts)
[17:41:21.014]                 }
[17:41:21.014]                 {
[17:41:21.014]                   {
[17:41:21.014]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:21.014]                     NULL
[17:41:21.014]                   }
[17:41:21.014]                   options(future.plan = NULL)
[17:41:21.014]                   if (is.na(NA_character_)) 
[17:41:21.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:21.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:21.014]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:21.014]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:21.014]                     envir = parent.frame()) 
[17:41:21.014]                   {
[17:41:21.014]                     if (is.function(workers)) 
[17:41:21.014]                       workers <- workers()
[17:41:21.014]                     workers <- structure(as.integer(workers), 
[17:41:21.014]                       class = class(workers))
[17:41:21.014]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:21.014]                       workers >= 1)
[17:41:21.014]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:21.014]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:21.014]                     }
[17:41:21.014]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:21.014]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:21.014]                       envir = envir)
[17:41:21.014]                     if (!future$lazy) 
[17:41:21.014]                       future <- run(future)
[17:41:21.014]                     invisible(future)
[17:41:21.014]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:21.014]                 }
[17:41:21.014]             }
[17:41:21.014]         }
[17:41:21.014]     })
[17:41:21.014]     if (FALSE) {
[17:41:21.014]         base::sink(type = "output", split = FALSE)
[17:41:21.014]         if (NA) {
[17:41:21.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:21.014]         }
[17:41:21.014]         else {
[17:41:21.014]             ...future.result["stdout"] <- base::list(NULL)
[17:41:21.014]         }
[17:41:21.014]         base::close(...future.stdout)
[17:41:21.014]         ...future.stdout <- NULL
[17:41:21.014]     }
[17:41:21.014]     ...future.result$conditions <- ...future.conditions
[17:41:21.014]     ...future.result$finished <- base::Sys.time()
[17:41:21.014]     ...future.result
[17:41:21.014] }
[17:41:21.017] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:41:21.017] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:41:21.017] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:41:21.018] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:41:21.018] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:41:21.018] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:41:21.018] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:41:21.018] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:21.019] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:21.019] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:21.019] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:21.019] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:41:21.020] MultisessionFuture started
[17:41:21.020] - Launch lazy future ... done
[17:41:21.020] run() for ‘MultisessionFuture’ ... done
[17:41:21.020] Created future:
[17:41:21.020] MultisessionFuture:
[17:41:21.020] Label: ‘future_lapply-2’
[17:41:21.020] Expression:
[17:41:21.020] {
[17:41:21.020]     do.call(function(...) {
[17:41:21.020]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:21.020]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:21.020]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:21.020]             on.exit(options(oopts), add = TRUE)
[17:41:21.020]         }
[17:41:21.020]         {
[17:41:21.020]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:41:21.020]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:41:21.020]                 ...future.FUN(...future.X_jj, ...)
[17:41:21.020]             })
[17:41:21.020]         }
[17:41:21.020]     }, args = future.call.arguments)
[17:41:21.020] }
[17:41:21.020] Lazy evaluation: FALSE
[17:41:21.020] Asynchronous evaluation: TRUE
[17:41:21.020] Local evaluation: TRUE
[17:41:21.020] Environment: R_GlobalEnv
[17:41:21.020] Capture standard output: NA
[17:41:21.020] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:21.020] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:21.020] Packages: <none>
[17:41:21.020] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:21.020] Resolved: FALSE
[17:41:21.020] Value: <not collected>
[17:41:21.020] Conditions captured: <none>
[17:41:21.020] Early signaling: FALSE
[17:41:21.020] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:21.020] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:21.032] Chunk #2 of 2 ... DONE
[17:41:21.032] Launching 2 futures (chunks) ... DONE
[17:41:21.032] Resolving 2 futures (chunks) ...
[17:41:21.032] resolve() on list ...
[17:41:21.032]  recursive: 0
[17:41:21.032]  length: 2
[17:41:21.033] 
[17:41:21.075] receiveMessageFromWorker() for ClusterFuture ...
[17:41:21.075] - Validating connection of MultisessionFuture
[17:41:21.075] - received message: FutureResult
[17:41:21.076] - Received FutureResult
[17:41:21.076] - Erased future from FutureRegistry
[17:41:21.076] result() for ClusterFuture ...
[17:41:21.076] - result already collected: FutureResult
[17:41:21.076] result() for ClusterFuture ... done
[17:41:21.076] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:21.076] Future #2
[17:41:21.076] result() for ClusterFuture ...
[17:41:21.076] - result already collected: FutureResult
[17:41:21.077] result() for ClusterFuture ... done
[17:41:21.077] result() for ClusterFuture ...
[17:41:21.077] - result already collected: FutureResult
[17:41:21.077] result() for ClusterFuture ... done
[17:41:21.077] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:21.077] - nx: 2
[17:41:21.077] - relay: TRUE
[17:41:21.077] - stdout: TRUE
[17:41:21.077] - signal: TRUE
[17:41:21.077] - resignal: FALSE
[17:41:21.077] - force: TRUE
[17:41:21.078] - relayed: [n=2] FALSE, FALSE
[17:41:21.078] - queued futures: [n=2] FALSE, FALSE
[17:41:21.078]  - until=1
[17:41:21.078]  - relaying element #1
[17:41:21.078] - relayed: [n=2] FALSE, FALSE
[17:41:21.078] - queued futures: [n=2] FALSE, TRUE
[17:41:21.078] signalConditionsASAP(NULL, pos=2) ... done
[17:41:21.078]  length: 1 (resolved future 2)
[17:41:21.528] receiveMessageFromWorker() for ClusterFuture ...
[17:41:21.528] - Validating connection of MultisessionFuture
[17:41:21.529] - received message: FutureResult
[17:41:21.529] - Received FutureResult
[17:41:21.529] - Erased future from FutureRegistry
[17:41:21.529] result() for ClusterFuture ...
[17:41:21.529] - result already collected: FutureResult
[17:41:21.529] result() for ClusterFuture ... done
[17:41:21.529] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:21.529] Future #1
[17:41:21.529] result() for ClusterFuture ...
[17:41:21.530] - result already collected: FutureResult
[17:41:21.530] result() for ClusterFuture ... done
[17:41:21.530] result() for ClusterFuture ...
[17:41:21.530] - result already collected: FutureResult
[17:41:21.530] result() for ClusterFuture ... done
[17:41:21.530] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:21.530] - nx: 2
[17:41:21.530] - relay: TRUE
[17:41:21.530] - stdout: TRUE
[17:41:21.530] - signal: TRUE
[17:41:21.530] - resignal: FALSE
[17:41:21.531] - force: TRUE
[17:41:21.531] - relayed: [n=2] FALSE, FALSE
[17:41:21.531] - queued futures: [n=2] FALSE, TRUE
[17:41:21.531]  - until=1
[17:41:21.531]  - relaying element #1
[17:41:21.531] result() for ClusterFuture ...
[17:41:21.531] - result already collected: FutureResult
[17:41:21.531] result() for ClusterFuture ... done
[17:41:21.531] result() for ClusterFuture ...
[17:41:21.531] - result already collected: FutureResult
[17:41:21.531] result() for ClusterFuture ... done
[17:41:21.532] result() for ClusterFuture ...
[17:41:21.532] - result already collected: FutureResult
[17:41:21.532] result() for ClusterFuture ... done
[17:41:21.532] result() for ClusterFuture ...
[17:41:21.532] - result already collected: FutureResult
[17:41:21.532] result() for ClusterFuture ... done
[17:41:21.532] - relayed: [n=2] TRUE, FALSE
[17:41:21.532] - queued futures: [n=2] TRUE, TRUE
[17:41:21.532] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:21.532]  length: 0 (resolved future 1)
[17:41:21.532] Relaying remaining futures
[17:41:21.533] signalConditionsASAP(NULL, pos=0) ...
[17:41:21.533] - nx: 2
[17:41:21.533] - relay: TRUE
[17:41:21.533] - stdout: TRUE
[17:41:21.533] - signal: TRUE
[17:41:21.533] - resignal: FALSE
[17:41:21.533] - force: TRUE
[17:41:21.533] - relayed: [n=2] TRUE, FALSE
[17:41:21.533] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:21.533]  - relaying element #2
[17:41:21.533] result() for ClusterFuture ...
[17:41:21.534] - result already collected: FutureResult
[17:41:21.534] result() for ClusterFuture ... done
[17:41:21.534] result() for ClusterFuture ...
[17:41:21.534] - result already collected: FutureResult
[17:41:21.534] result() for ClusterFuture ... done
[17:41:21.534] result() for ClusterFuture ...
[17:41:21.534] - result already collected: FutureResult
[17:41:21.534] result() for ClusterFuture ... done
[17:41:21.534] result() for ClusterFuture ...
[17:41:21.534] - result already collected: FutureResult
[17:41:21.534] result() for ClusterFuture ... done
[17:41:21.534] - relayed: [n=2] TRUE, TRUE
[17:41:21.535] - queued futures: [n=2] TRUE, TRUE
[17:41:21.535] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:41:21.535] resolve() on list ... DONE
[17:41:21.535] result() for ClusterFuture ...
[17:41:21.535] - result already collected: FutureResult
[17:41:21.535] result() for ClusterFuture ... done
[17:41:21.535] result() for ClusterFuture ...
[17:41:21.535] - result already collected: FutureResult
[17:41:21.535] result() for ClusterFuture ... done
[17:41:21.535] result() for ClusterFuture ...
[17:41:21.536] - result already collected: FutureResult
[17:41:21.536] result() for ClusterFuture ... done
[17:41:21.536] result() for ClusterFuture ...
[17:41:21.536] - result already collected: FutureResult
[17:41:21.536] result() for ClusterFuture ... done
[17:41:21.536]  - Number of value chunks collected: 2
[17:41:21.536] Resolving 2 futures (chunks) ... DONE
[17:41:21.536] Reducing values from 2 chunks ...
[17:41:21.536]  - Number of values collected after concatenation: 2
[17:41:21.536]  - Number of values expected: 2
[17:41:21.536] Reducing values from 2 chunks ... DONE
[17:41:21.537] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:41:21.537] future_mapply() ...
[17:41:21.541] Number of chunks: 2
[17:41:21.541] getGlobalsAndPackagesXApply() ...
[17:41:21.541]  - future.globals: TRUE
[17:41:21.541] getGlobalsAndPackages() ...
[17:41:21.541] Searching for globals...
[17:41:21.542] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:21.543] Searching for globals ... DONE
[17:41:21.543] Resolving globals: FALSE
[17:41:21.543] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:21.544] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:21.544] - globals: [1] ‘FUN’
[17:41:21.544] 
[17:41:21.544] getGlobalsAndPackages() ... DONE
[17:41:21.544]  - globals found/used: [n=1] ‘FUN’
[17:41:21.544]  - needed namespaces: [n=0] 
[17:41:21.544] Finding globals ... DONE
[17:41:21.544] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:21.545] List of 2
[17:41:21.545]  $ ...future.FUN:function (x, y)  
[17:41:21.545]  $ MoreArgs     : NULL
[17:41:21.545]  - attr(*, "where")=List of 2
[17:41:21.545]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:21.545]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:21.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:21.545]  - attr(*, "resolved")= logi FALSE
[17:41:21.545]  - attr(*, "total_size")= num NA
[17:41:21.547] Packages to be attached in all futures: [n=0] 
[17:41:21.547] getGlobalsAndPackagesXApply() ... DONE
[17:41:21.547] Number of futures (= number of chunks): 2
[17:41:21.547] Launching 2 futures (chunks) ...
[17:41:21.548] Chunk #1 of 2 ...
[17:41:21.548]  - Finding globals in '...' for chunk #1 ...
[17:41:21.548] getGlobalsAndPackages() ...
[17:41:21.548] Searching for globals...
[17:41:21.548] 
[17:41:21.548] Searching for globals ... DONE
[17:41:21.548] - globals: [0] <none>
[17:41:21.548] getGlobalsAndPackages() ... DONE
[17:41:21.548]    + additional globals found: [n=0] 
[17:41:21.549]    + additional namespaces needed: [n=0] 
[17:41:21.549]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:21.549]  - seeds: <none>
[17:41:21.549] getGlobalsAndPackages() ...
[17:41:21.549] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:21.549] Resolving globals: FALSE
[17:41:21.549] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:21.552] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:21.552] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:21.552] 
[17:41:21.552] getGlobalsAndPackages() ... DONE
[17:41:21.552] run() for ‘Future’ ...
[17:41:21.552] - state: ‘created’
[17:41:21.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:21.568] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:21.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:21.568]   - Field: ‘node’
[17:41:21.568]   - Field: ‘label’
[17:41:21.568]   - Field: ‘local’
[17:41:21.568]   - Field: ‘owner’
[17:41:21.569]   - Field: ‘envir’
[17:41:21.569]   - Field: ‘workers’
[17:41:21.569]   - Field: ‘packages’
[17:41:21.569]   - Field: ‘gc’
[17:41:21.569]   - Field: ‘conditions’
[17:41:21.569]   - Field: ‘persistent’
[17:41:21.569]   - Field: ‘expr’
[17:41:21.569]   - Field: ‘uuid’
[17:41:21.569]   - Field: ‘seed’
[17:41:21.569]   - Field: ‘version’
[17:41:21.570]   - Field: ‘result’
[17:41:21.570]   - Field: ‘asynchronous’
[17:41:21.570]   - Field: ‘calls’
[17:41:21.570]   - Field: ‘globals’
[17:41:21.570]   - Field: ‘stdout’
[17:41:21.570]   - Field: ‘earlySignal’
[17:41:21.570]   - Field: ‘lazy’
[17:41:21.570]   - Field: ‘state’
[17:41:21.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:21.570] - Launch lazy future ...
[17:41:21.571] Packages needed by the future expression (n = 0): <none>
[17:41:21.571] Packages needed by future strategies (n = 0): <none>
[17:41:21.571] {
[17:41:21.571]     {
[17:41:21.571]         {
[17:41:21.571]             ...future.startTime <- base::Sys.time()
[17:41:21.571]             {
[17:41:21.571]                 {
[17:41:21.571]                   {
[17:41:21.571]                     {
[17:41:21.571]                       base::local({
[17:41:21.571]                         has_future <- base::requireNamespace("future", 
[17:41:21.571]                           quietly = TRUE)
[17:41:21.571]                         if (has_future) {
[17:41:21.571]                           ns <- base::getNamespace("future")
[17:41:21.571]                           version <- ns[[".package"]][["version"]]
[17:41:21.571]                           if (is.null(version)) 
[17:41:21.571]                             version <- utils::packageVersion("future")
[17:41:21.571]                         }
[17:41:21.571]                         else {
[17:41:21.571]                           version <- NULL
[17:41:21.571]                         }
[17:41:21.571]                         if (!has_future || version < "1.8.0") {
[17:41:21.571]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:21.571]                             "", base::R.version$version.string), 
[17:41:21.571]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:21.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:21.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:21.571]                               "release", "version")], collapse = " "), 
[17:41:21.571]                             hostname = base::Sys.info()[["nodename"]])
[17:41:21.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:21.571]                             info)
[17:41:21.571]                           info <- base::paste(info, collapse = "; ")
[17:41:21.571]                           if (!has_future) {
[17:41:21.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:21.571]                               info)
[17:41:21.571]                           }
[17:41:21.571]                           else {
[17:41:21.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:21.571]                               info, version)
[17:41:21.571]                           }
[17:41:21.571]                           base::stop(msg)
[17:41:21.571]                         }
[17:41:21.571]                       })
[17:41:21.571]                     }
[17:41:21.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:21.571]                     base::options(mc.cores = 1L)
[17:41:21.571]                   }
[17:41:21.571]                   options(future.plan = NULL)
[17:41:21.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:21.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:21.571]                 }
[17:41:21.571]                 ...future.workdir <- getwd()
[17:41:21.571]             }
[17:41:21.571]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:21.571]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:21.571]         }
[17:41:21.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:21.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:21.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:21.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:21.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:21.571]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:21.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:21.571]             base::names(...future.oldOptions))
[17:41:21.571]     }
[17:41:21.571]     if (FALSE) {
[17:41:21.571]     }
[17:41:21.571]     else {
[17:41:21.571]         if (FALSE) {
[17:41:21.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:21.571]                 open = "w")
[17:41:21.571]         }
[17:41:21.571]         else {
[17:41:21.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:21.571]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:21.571]         }
[17:41:21.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:21.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:21.571]             base::sink(type = "output", split = FALSE)
[17:41:21.571]             base::close(...future.stdout)
[17:41:21.571]         }, add = TRUE)
[17:41:21.571]     }
[17:41:21.571]     ...future.frame <- base::sys.nframe()
[17:41:21.571]     ...future.conditions <- base::list()
[17:41:21.571]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:21.571]     if (FALSE) {
[17:41:21.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:21.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:21.571]     }
[17:41:21.571]     ...future.result <- base::tryCatch({
[17:41:21.571]         base::withCallingHandlers({
[17:41:21.571]             ...future.value <- base::withVisible(base::local({
[17:41:21.571]                 ...future.makeSendCondition <- local({
[17:41:21.571]                   sendCondition <- NULL
[17:41:21.571]                   function(frame = 1L) {
[17:41:21.571]                     if (is.function(sendCondition)) 
[17:41:21.571]                       return(sendCondition)
[17:41:21.571]                     ns <- getNamespace("parallel")
[17:41:21.571]                     if (exists("sendData", mode = "function", 
[17:41:21.571]                       envir = ns)) {
[17:41:21.571]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:21.571]                         envir = ns)
[17:41:21.571]                       envir <- sys.frame(frame)
[17:41:21.571]                       master <- NULL
[17:41:21.571]                       while (!identical(envir, .GlobalEnv) && 
[17:41:21.571]                         !identical(envir, emptyenv())) {
[17:41:21.571]                         if (exists("master", mode = "list", envir = envir, 
[17:41:21.571]                           inherits = FALSE)) {
[17:41:21.571]                           master <- get("master", mode = "list", 
[17:41:21.571]                             envir = envir, inherits = FALSE)
[17:41:21.571]                           if (inherits(master, c("SOCKnode", 
[17:41:21.571]                             "SOCK0node"))) {
[17:41:21.571]                             sendCondition <<- function(cond) {
[17:41:21.571]                               data <- list(type = "VALUE", value = cond, 
[17:41:21.571]                                 success = TRUE)
[17:41:21.571]                               parallel_sendData(master, data)
[17:41:21.571]                             }
[17:41:21.571]                             return(sendCondition)
[17:41:21.571]                           }
[17:41:21.571]                         }
[17:41:21.571]                         frame <- frame + 1L
[17:41:21.571]                         envir <- sys.frame(frame)
[17:41:21.571]                       }
[17:41:21.571]                     }
[17:41:21.571]                     sendCondition <<- function(cond) NULL
[17:41:21.571]                   }
[17:41:21.571]                 })
[17:41:21.571]                 withCallingHandlers({
[17:41:21.571]                   {
[17:41:21.571]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:21.571]                     if (!identical(...future.globals.maxSize.org, 
[17:41:21.571]                       ...future.globals.maxSize)) {
[17:41:21.571]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:21.571]                       on.exit(options(oopts), add = TRUE)
[17:41:21.571]                     }
[17:41:21.571]                     {
[17:41:21.571]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:21.571]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:21.571]                         USE.NAMES = FALSE)
[17:41:21.571]                       do.call(mapply, args = args)
[17:41:21.571]                     }
[17:41:21.571]                   }
[17:41:21.571]                 }, immediateCondition = function(cond) {
[17:41:21.571]                   sendCondition <- ...future.makeSendCondition()
[17:41:21.571]                   sendCondition(cond)
[17:41:21.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.571]                   {
[17:41:21.571]                     inherits <- base::inherits
[17:41:21.571]                     invokeRestart <- base::invokeRestart
[17:41:21.571]                     is.null <- base::is.null
[17:41:21.571]                     muffled <- FALSE
[17:41:21.571]                     if (inherits(cond, "message")) {
[17:41:21.571]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:21.571]                       if (muffled) 
[17:41:21.571]                         invokeRestart("muffleMessage")
[17:41:21.571]                     }
[17:41:21.571]                     else if (inherits(cond, "warning")) {
[17:41:21.571]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:21.571]                       if (muffled) 
[17:41:21.571]                         invokeRestart("muffleWarning")
[17:41:21.571]                     }
[17:41:21.571]                     else if (inherits(cond, "condition")) {
[17:41:21.571]                       if (!is.null(pattern)) {
[17:41:21.571]                         computeRestarts <- base::computeRestarts
[17:41:21.571]                         grepl <- base::grepl
[17:41:21.571]                         restarts <- computeRestarts(cond)
[17:41:21.571]                         for (restart in restarts) {
[17:41:21.571]                           name <- restart$name
[17:41:21.571]                           if (is.null(name)) 
[17:41:21.571]                             next
[17:41:21.571]                           if (!grepl(pattern, name)) 
[17:41:21.571]                             next
[17:41:21.571]                           invokeRestart(restart)
[17:41:21.571]                           muffled <- TRUE
[17:41:21.571]                           break
[17:41:21.571]                         }
[17:41:21.571]                       }
[17:41:21.571]                     }
[17:41:21.571]                     invisible(muffled)
[17:41:21.571]                   }
[17:41:21.571]                   muffleCondition(cond)
[17:41:21.571]                 })
[17:41:21.571]             }))
[17:41:21.571]             future::FutureResult(value = ...future.value$value, 
[17:41:21.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:21.571]                   ...future.rng), globalenv = if (FALSE) 
[17:41:21.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:21.571]                     ...future.globalenv.names))
[17:41:21.571]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:21.571]         }, condition = base::local({
[17:41:21.571]             c <- base::c
[17:41:21.571]             inherits <- base::inherits
[17:41:21.571]             invokeRestart <- base::invokeRestart
[17:41:21.571]             length <- base::length
[17:41:21.571]             list <- base::list
[17:41:21.571]             seq.int <- base::seq.int
[17:41:21.571]             signalCondition <- base::signalCondition
[17:41:21.571]             sys.calls <- base::sys.calls
[17:41:21.571]             `[[` <- base::`[[`
[17:41:21.571]             `+` <- base::`+`
[17:41:21.571]             `<<-` <- base::`<<-`
[17:41:21.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:21.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:21.571]                   3L)]
[17:41:21.571]             }
[17:41:21.571]             function(cond) {
[17:41:21.571]                 is_error <- inherits(cond, "error")
[17:41:21.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:21.571]                   NULL)
[17:41:21.571]                 if (is_error) {
[17:41:21.571]                   sessionInformation <- function() {
[17:41:21.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:21.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:21.571]                       search = base::search(), system = base::Sys.info())
[17:41:21.571]                   }
[17:41:21.571]                   ...future.conditions[[length(...future.conditions) + 
[17:41:21.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:21.571]                     cond$call), session = sessionInformation(), 
[17:41:21.571]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:21.571]                   signalCondition(cond)
[17:41:21.571]                 }
[17:41:21.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:21.571]                 "immediateCondition"))) {
[17:41:21.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:21.571]                   ...future.conditions[[length(...future.conditions) + 
[17:41:21.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:21.571]                   if (TRUE && !signal) {
[17:41:21.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.571]                     {
[17:41:21.571]                       inherits <- base::inherits
[17:41:21.571]                       invokeRestart <- base::invokeRestart
[17:41:21.571]                       is.null <- base::is.null
[17:41:21.571]                       muffled <- FALSE
[17:41:21.571]                       if (inherits(cond, "message")) {
[17:41:21.571]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:21.571]                         if (muffled) 
[17:41:21.571]                           invokeRestart("muffleMessage")
[17:41:21.571]                       }
[17:41:21.571]                       else if (inherits(cond, "warning")) {
[17:41:21.571]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:21.571]                         if (muffled) 
[17:41:21.571]                           invokeRestart("muffleWarning")
[17:41:21.571]                       }
[17:41:21.571]                       else if (inherits(cond, "condition")) {
[17:41:21.571]                         if (!is.null(pattern)) {
[17:41:21.571]                           computeRestarts <- base::computeRestarts
[17:41:21.571]                           grepl <- base::grepl
[17:41:21.571]                           restarts <- computeRestarts(cond)
[17:41:21.571]                           for (restart in restarts) {
[17:41:21.571]                             name <- restart$name
[17:41:21.571]                             if (is.null(name)) 
[17:41:21.571]                               next
[17:41:21.571]                             if (!grepl(pattern, name)) 
[17:41:21.571]                               next
[17:41:21.571]                             invokeRestart(restart)
[17:41:21.571]                             muffled <- TRUE
[17:41:21.571]                             break
[17:41:21.571]                           }
[17:41:21.571]                         }
[17:41:21.571]                       }
[17:41:21.571]                       invisible(muffled)
[17:41:21.571]                     }
[17:41:21.571]                     muffleCondition(cond, pattern = "^muffle")
[17:41:21.571]                   }
[17:41:21.571]                 }
[17:41:21.571]                 else {
[17:41:21.571]                   if (TRUE) {
[17:41:21.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.571]                     {
[17:41:21.571]                       inherits <- base::inherits
[17:41:21.571]                       invokeRestart <- base::invokeRestart
[17:41:21.571]                       is.null <- base::is.null
[17:41:21.571]                       muffled <- FALSE
[17:41:21.571]                       if (inherits(cond, "message")) {
[17:41:21.571]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:21.571]                         if (muffled) 
[17:41:21.571]                           invokeRestart("muffleMessage")
[17:41:21.571]                       }
[17:41:21.571]                       else if (inherits(cond, "warning")) {
[17:41:21.571]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:21.571]                         if (muffled) 
[17:41:21.571]                           invokeRestart("muffleWarning")
[17:41:21.571]                       }
[17:41:21.571]                       else if (inherits(cond, "condition")) {
[17:41:21.571]                         if (!is.null(pattern)) {
[17:41:21.571]                           computeRestarts <- base::computeRestarts
[17:41:21.571]                           grepl <- base::grepl
[17:41:21.571]                           restarts <- computeRestarts(cond)
[17:41:21.571]                           for (restart in restarts) {
[17:41:21.571]                             name <- restart$name
[17:41:21.571]                             if (is.null(name)) 
[17:41:21.571]                               next
[17:41:21.571]                             if (!grepl(pattern, name)) 
[17:41:21.571]                               next
[17:41:21.571]                             invokeRestart(restart)
[17:41:21.571]                             muffled <- TRUE
[17:41:21.571]                             break
[17:41:21.571]                           }
[17:41:21.571]                         }
[17:41:21.571]                       }
[17:41:21.571]                       invisible(muffled)
[17:41:21.571]                     }
[17:41:21.571]                     muffleCondition(cond, pattern = "^muffle")
[17:41:21.571]                   }
[17:41:21.571]                 }
[17:41:21.571]             }
[17:41:21.571]         }))
[17:41:21.571]     }, error = function(ex) {
[17:41:21.571]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:21.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:21.571]                 ...future.rng), started = ...future.startTime, 
[17:41:21.571]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:21.571]             version = "1.8"), class = "FutureResult")
[17:41:21.571]     }, finally = {
[17:41:21.571]         if (!identical(...future.workdir, getwd())) 
[17:41:21.571]             setwd(...future.workdir)
[17:41:21.571]         {
[17:41:21.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:21.571]                 ...future.oldOptions$nwarnings <- NULL
[17:41:21.571]             }
[17:41:21.571]             base::options(...future.oldOptions)
[17:41:21.571]             if (.Platform$OS.type == "windows") {
[17:41:21.571]                 old_names <- names(...future.oldEnvVars)
[17:41:21.571]                 envs <- base::Sys.getenv()
[17:41:21.571]                 names <- names(envs)
[17:41:21.571]                 common <- intersect(names, old_names)
[17:41:21.571]                 added <- setdiff(names, old_names)
[17:41:21.571]                 removed <- setdiff(old_names, names)
[17:41:21.571]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:21.571]                   envs[common]]
[17:41:21.571]                 NAMES <- toupper(changed)
[17:41:21.571]                 args <- list()
[17:41:21.571]                 for (kk in seq_along(NAMES)) {
[17:41:21.571]                   name <- changed[[kk]]
[17:41:21.571]                   NAME <- NAMES[[kk]]
[17:41:21.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.571]                     next
[17:41:21.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:21.571]                 }
[17:41:21.571]                 NAMES <- toupper(added)
[17:41:21.571]                 for (kk in seq_along(NAMES)) {
[17:41:21.571]                   name <- added[[kk]]
[17:41:21.571]                   NAME <- NAMES[[kk]]
[17:41:21.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.571]                     next
[17:41:21.571]                   args[[name]] <- ""
[17:41:21.571]                 }
[17:41:21.571]                 NAMES <- toupper(removed)
[17:41:21.571]                 for (kk in seq_along(NAMES)) {
[17:41:21.571]                   name <- removed[[kk]]
[17:41:21.571]                   NAME <- NAMES[[kk]]
[17:41:21.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.571]                     next
[17:41:21.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:21.571]                 }
[17:41:21.571]                 if (length(args) > 0) 
[17:41:21.571]                   base::do.call(base::Sys.setenv, args = args)
[17:41:21.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:21.571]             }
[17:41:21.571]             else {
[17:41:21.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:21.571]             }
[17:41:21.571]             {
[17:41:21.571]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:21.571]                   0L) {
[17:41:21.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:21.571]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:21.571]                   base::options(opts)
[17:41:21.571]                 }
[17:41:21.571]                 {
[17:41:21.571]                   {
[17:41:21.571]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:21.571]                     NULL
[17:41:21.571]                   }
[17:41:21.571]                   options(future.plan = NULL)
[17:41:21.571]                   if (is.na(NA_character_)) 
[17:41:21.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:21.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:21.571]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:21.571]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:21.571]                     envir = parent.frame()) 
[17:41:21.571]                   {
[17:41:21.571]                     if (is.function(workers)) 
[17:41:21.571]                       workers <- workers()
[17:41:21.571]                     workers <- structure(as.integer(workers), 
[17:41:21.571]                       class = class(workers))
[17:41:21.571]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:21.571]                       workers >= 1)
[17:41:21.571]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:21.571]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:21.571]                     }
[17:41:21.571]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:21.571]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:21.571]                       envir = envir)
[17:41:21.571]                     if (!future$lazy) 
[17:41:21.571]                       future <- run(future)
[17:41:21.571]                     invisible(future)
[17:41:21.571]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:21.571]                 }
[17:41:21.571]             }
[17:41:21.571]         }
[17:41:21.571]     })
[17:41:21.571]     if (TRUE) {
[17:41:21.571]         base::sink(type = "output", split = FALSE)
[17:41:21.571]         if (FALSE) {
[17:41:21.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:21.571]         }
[17:41:21.571]         else {
[17:41:21.571]             ...future.result["stdout"] <- base::list(NULL)
[17:41:21.571]         }
[17:41:21.571]         base::close(...future.stdout)
[17:41:21.571]         ...future.stdout <- NULL
[17:41:21.571]     }
[17:41:21.571]     ...future.result$conditions <- ...future.conditions
[17:41:21.571]     ...future.result$finished <- base::Sys.time()
[17:41:21.571]     ...future.result
[17:41:21.571] }
[17:41:21.574] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:41:21.574] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:41:21.575] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:41:21.575] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:41:21.575] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:41:21.576] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:41:21.576] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:41:21.576] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:21.576] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:21.577] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:21.577] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:21.577] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:41:21.578] MultisessionFuture started
[17:41:21.578] - Launch lazy future ... done
[17:41:21.578] run() for ‘MultisessionFuture’ ... done
[17:41:21.578] Created future:
[17:41:21.578] MultisessionFuture:
[17:41:21.578] Label: ‘future_mapply-1’
[17:41:21.578] Expression:
[17:41:21.578] {
[17:41:21.578]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:21.578]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:21.578]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:21.578]         on.exit(options(oopts), add = TRUE)
[17:41:21.578]     }
[17:41:21.578]     {
[17:41:21.578]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:21.578]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:21.578]         do.call(mapply, args = args)
[17:41:21.578]     }
[17:41:21.578] }
[17:41:21.578] Lazy evaluation: FALSE
[17:41:21.578] Asynchronous evaluation: TRUE
[17:41:21.578] Local evaluation: TRUE
[17:41:21.578] Environment: R_GlobalEnv
[17:41:21.578] Capture standard output: FALSE
[17:41:21.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:21.578] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:21.578] Packages: <none>
[17:41:21.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:21.578] Resolved: FALSE
[17:41:21.578] Value: <not collected>
[17:41:21.578] Conditions captured: <none>
[17:41:21.578] Early signaling: FALSE
[17:41:21.578] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:21.578] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:21.590] Chunk #1 of 2 ... DONE
[17:41:21.590] Chunk #2 of 2 ...
[17:41:21.590]  - Finding globals in '...' for chunk #2 ...
[17:41:21.590] getGlobalsAndPackages() ...
[17:41:21.590] Searching for globals...
[17:41:21.591] 
[17:41:21.591] Searching for globals ... DONE
[17:41:21.591] - globals: [0] <none>
[17:41:21.591] getGlobalsAndPackages() ... DONE
[17:41:21.591]    + additional globals found: [n=0] 
[17:41:21.591]    + additional namespaces needed: [n=0] 
[17:41:21.591]  - Finding globals in '...' for chunk #2 ... DONE
[17:41:21.591]  - seeds: <none>
[17:41:21.591] getGlobalsAndPackages() ...
[17:41:21.591] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:21.592] Resolving globals: FALSE
[17:41:21.592] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:21.593] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:21.593] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:21.593] 
[17:41:21.593] getGlobalsAndPackages() ... DONE
[17:41:21.593] run() for ‘Future’ ...
[17:41:21.593] - state: ‘created’
[17:41:21.593] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:21.608] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:21.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:21.608]   - Field: ‘node’
[17:41:21.608]   - Field: ‘label’
[17:41:21.609]   - Field: ‘local’
[17:41:21.609]   - Field: ‘owner’
[17:41:21.609]   - Field: ‘envir’
[17:41:21.609]   - Field: ‘workers’
[17:41:21.609]   - Field: ‘packages’
[17:41:21.609]   - Field: ‘gc’
[17:41:21.609]   - Field: ‘conditions’
[17:41:21.609]   - Field: ‘persistent’
[17:41:21.609]   - Field: ‘expr’
[17:41:21.609]   - Field: ‘uuid’
[17:41:21.610]   - Field: ‘seed’
[17:41:21.610]   - Field: ‘version’
[17:41:21.610]   - Field: ‘result’
[17:41:21.610]   - Field: ‘asynchronous’
[17:41:21.610]   - Field: ‘calls’
[17:41:21.610]   - Field: ‘globals’
[17:41:21.610]   - Field: ‘stdout’
[17:41:21.610]   - Field: ‘earlySignal’
[17:41:21.610]   - Field: ‘lazy’
[17:41:21.610]   - Field: ‘state’
[17:41:21.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:21.611] - Launch lazy future ...
[17:41:21.611] Packages needed by the future expression (n = 0): <none>
[17:41:21.611] Packages needed by future strategies (n = 0): <none>
[17:41:21.611] {
[17:41:21.611]     {
[17:41:21.611]         {
[17:41:21.611]             ...future.startTime <- base::Sys.time()
[17:41:21.611]             {
[17:41:21.611]                 {
[17:41:21.611]                   {
[17:41:21.611]                     {
[17:41:21.611]                       base::local({
[17:41:21.611]                         has_future <- base::requireNamespace("future", 
[17:41:21.611]                           quietly = TRUE)
[17:41:21.611]                         if (has_future) {
[17:41:21.611]                           ns <- base::getNamespace("future")
[17:41:21.611]                           version <- ns[[".package"]][["version"]]
[17:41:21.611]                           if (is.null(version)) 
[17:41:21.611]                             version <- utils::packageVersion("future")
[17:41:21.611]                         }
[17:41:21.611]                         else {
[17:41:21.611]                           version <- NULL
[17:41:21.611]                         }
[17:41:21.611]                         if (!has_future || version < "1.8.0") {
[17:41:21.611]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:21.611]                             "", base::R.version$version.string), 
[17:41:21.611]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:21.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:21.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:21.611]                               "release", "version")], collapse = " "), 
[17:41:21.611]                             hostname = base::Sys.info()[["nodename"]])
[17:41:21.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:21.611]                             info)
[17:41:21.611]                           info <- base::paste(info, collapse = "; ")
[17:41:21.611]                           if (!has_future) {
[17:41:21.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:21.611]                               info)
[17:41:21.611]                           }
[17:41:21.611]                           else {
[17:41:21.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:21.611]                               info, version)
[17:41:21.611]                           }
[17:41:21.611]                           base::stop(msg)
[17:41:21.611]                         }
[17:41:21.611]                       })
[17:41:21.611]                     }
[17:41:21.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:21.611]                     base::options(mc.cores = 1L)
[17:41:21.611]                   }
[17:41:21.611]                   options(future.plan = NULL)
[17:41:21.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:21.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:21.611]                 }
[17:41:21.611]                 ...future.workdir <- getwd()
[17:41:21.611]             }
[17:41:21.611]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:21.611]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:21.611]         }
[17:41:21.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:21.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:21.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:21.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:21.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:21.611]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:21.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:21.611]             base::names(...future.oldOptions))
[17:41:21.611]     }
[17:41:21.611]     if (FALSE) {
[17:41:21.611]     }
[17:41:21.611]     else {
[17:41:21.611]         if (FALSE) {
[17:41:21.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:21.611]                 open = "w")
[17:41:21.611]         }
[17:41:21.611]         else {
[17:41:21.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:21.611]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:21.611]         }
[17:41:21.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:21.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:21.611]             base::sink(type = "output", split = FALSE)
[17:41:21.611]             base::close(...future.stdout)
[17:41:21.611]         }, add = TRUE)
[17:41:21.611]     }
[17:41:21.611]     ...future.frame <- base::sys.nframe()
[17:41:21.611]     ...future.conditions <- base::list()
[17:41:21.611]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:21.611]     if (FALSE) {
[17:41:21.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:21.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:21.611]     }
[17:41:21.611]     ...future.result <- base::tryCatch({
[17:41:21.611]         base::withCallingHandlers({
[17:41:21.611]             ...future.value <- base::withVisible(base::local({
[17:41:21.611]                 ...future.makeSendCondition <- local({
[17:41:21.611]                   sendCondition <- NULL
[17:41:21.611]                   function(frame = 1L) {
[17:41:21.611]                     if (is.function(sendCondition)) 
[17:41:21.611]                       return(sendCondition)
[17:41:21.611]                     ns <- getNamespace("parallel")
[17:41:21.611]                     if (exists("sendData", mode = "function", 
[17:41:21.611]                       envir = ns)) {
[17:41:21.611]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:21.611]                         envir = ns)
[17:41:21.611]                       envir <- sys.frame(frame)
[17:41:21.611]                       master <- NULL
[17:41:21.611]                       while (!identical(envir, .GlobalEnv) && 
[17:41:21.611]                         !identical(envir, emptyenv())) {
[17:41:21.611]                         if (exists("master", mode = "list", envir = envir, 
[17:41:21.611]                           inherits = FALSE)) {
[17:41:21.611]                           master <- get("master", mode = "list", 
[17:41:21.611]                             envir = envir, inherits = FALSE)
[17:41:21.611]                           if (inherits(master, c("SOCKnode", 
[17:41:21.611]                             "SOCK0node"))) {
[17:41:21.611]                             sendCondition <<- function(cond) {
[17:41:21.611]                               data <- list(type = "VALUE", value = cond, 
[17:41:21.611]                                 success = TRUE)
[17:41:21.611]                               parallel_sendData(master, data)
[17:41:21.611]                             }
[17:41:21.611]                             return(sendCondition)
[17:41:21.611]                           }
[17:41:21.611]                         }
[17:41:21.611]                         frame <- frame + 1L
[17:41:21.611]                         envir <- sys.frame(frame)
[17:41:21.611]                       }
[17:41:21.611]                     }
[17:41:21.611]                     sendCondition <<- function(cond) NULL
[17:41:21.611]                   }
[17:41:21.611]                 })
[17:41:21.611]                 withCallingHandlers({
[17:41:21.611]                   {
[17:41:21.611]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:21.611]                     if (!identical(...future.globals.maxSize.org, 
[17:41:21.611]                       ...future.globals.maxSize)) {
[17:41:21.611]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:21.611]                       on.exit(options(oopts), add = TRUE)
[17:41:21.611]                     }
[17:41:21.611]                     {
[17:41:21.611]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:21.611]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:21.611]                         USE.NAMES = FALSE)
[17:41:21.611]                       do.call(mapply, args = args)
[17:41:21.611]                     }
[17:41:21.611]                   }
[17:41:21.611]                 }, immediateCondition = function(cond) {
[17:41:21.611]                   sendCondition <- ...future.makeSendCondition()
[17:41:21.611]                   sendCondition(cond)
[17:41:21.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.611]                   {
[17:41:21.611]                     inherits <- base::inherits
[17:41:21.611]                     invokeRestart <- base::invokeRestart
[17:41:21.611]                     is.null <- base::is.null
[17:41:21.611]                     muffled <- FALSE
[17:41:21.611]                     if (inherits(cond, "message")) {
[17:41:21.611]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:21.611]                       if (muffled) 
[17:41:21.611]                         invokeRestart("muffleMessage")
[17:41:21.611]                     }
[17:41:21.611]                     else if (inherits(cond, "warning")) {
[17:41:21.611]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:21.611]                       if (muffled) 
[17:41:21.611]                         invokeRestart("muffleWarning")
[17:41:21.611]                     }
[17:41:21.611]                     else if (inherits(cond, "condition")) {
[17:41:21.611]                       if (!is.null(pattern)) {
[17:41:21.611]                         computeRestarts <- base::computeRestarts
[17:41:21.611]                         grepl <- base::grepl
[17:41:21.611]                         restarts <- computeRestarts(cond)
[17:41:21.611]                         for (restart in restarts) {
[17:41:21.611]                           name <- restart$name
[17:41:21.611]                           if (is.null(name)) 
[17:41:21.611]                             next
[17:41:21.611]                           if (!grepl(pattern, name)) 
[17:41:21.611]                             next
[17:41:21.611]                           invokeRestart(restart)
[17:41:21.611]                           muffled <- TRUE
[17:41:21.611]                           break
[17:41:21.611]                         }
[17:41:21.611]                       }
[17:41:21.611]                     }
[17:41:21.611]                     invisible(muffled)
[17:41:21.611]                   }
[17:41:21.611]                   muffleCondition(cond)
[17:41:21.611]                 })
[17:41:21.611]             }))
[17:41:21.611]             future::FutureResult(value = ...future.value$value, 
[17:41:21.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:21.611]                   ...future.rng), globalenv = if (FALSE) 
[17:41:21.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:21.611]                     ...future.globalenv.names))
[17:41:21.611]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:21.611]         }, condition = base::local({
[17:41:21.611]             c <- base::c
[17:41:21.611]             inherits <- base::inherits
[17:41:21.611]             invokeRestart <- base::invokeRestart
[17:41:21.611]             length <- base::length
[17:41:21.611]             list <- base::list
[17:41:21.611]             seq.int <- base::seq.int
[17:41:21.611]             signalCondition <- base::signalCondition
[17:41:21.611]             sys.calls <- base::sys.calls
[17:41:21.611]             `[[` <- base::`[[`
[17:41:21.611]             `+` <- base::`+`
[17:41:21.611]             `<<-` <- base::`<<-`
[17:41:21.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:21.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:21.611]                   3L)]
[17:41:21.611]             }
[17:41:21.611]             function(cond) {
[17:41:21.611]                 is_error <- inherits(cond, "error")
[17:41:21.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:21.611]                   NULL)
[17:41:21.611]                 if (is_error) {
[17:41:21.611]                   sessionInformation <- function() {
[17:41:21.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:21.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:21.611]                       search = base::search(), system = base::Sys.info())
[17:41:21.611]                   }
[17:41:21.611]                   ...future.conditions[[length(...future.conditions) + 
[17:41:21.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:21.611]                     cond$call), session = sessionInformation(), 
[17:41:21.611]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:21.611]                   signalCondition(cond)
[17:41:21.611]                 }
[17:41:21.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:21.611]                 "immediateCondition"))) {
[17:41:21.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:21.611]                   ...future.conditions[[length(...future.conditions) + 
[17:41:21.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:21.611]                   if (TRUE && !signal) {
[17:41:21.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.611]                     {
[17:41:21.611]                       inherits <- base::inherits
[17:41:21.611]                       invokeRestart <- base::invokeRestart
[17:41:21.611]                       is.null <- base::is.null
[17:41:21.611]                       muffled <- FALSE
[17:41:21.611]                       if (inherits(cond, "message")) {
[17:41:21.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:21.611]                         if (muffled) 
[17:41:21.611]                           invokeRestart("muffleMessage")
[17:41:21.611]                       }
[17:41:21.611]                       else if (inherits(cond, "warning")) {
[17:41:21.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:21.611]                         if (muffled) 
[17:41:21.611]                           invokeRestart("muffleWarning")
[17:41:21.611]                       }
[17:41:21.611]                       else if (inherits(cond, "condition")) {
[17:41:21.611]                         if (!is.null(pattern)) {
[17:41:21.611]                           computeRestarts <- base::computeRestarts
[17:41:21.611]                           grepl <- base::grepl
[17:41:21.611]                           restarts <- computeRestarts(cond)
[17:41:21.611]                           for (restart in restarts) {
[17:41:21.611]                             name <- restart$name
[17:41:21.611]                             if (is.null(name)) 
[17:41:21.611]                               next
[17:41:21.611]                             if (!grepl(pattern, name)) 
[17:41:21.611]                               next
[17:41:21.611]                             invokeRestart(restart)
[17:41:21.611]                             muffled <- TRUE
[17:41:21.611]                             break
[17:41:21.611]                           }
[17:41:21.611]                         }
[17:41:21.611]                       }
[17:41:21.611]                       invisible(muffled)
[17:41:21.611]                     }
[17:41:21.611]                     muffleCondition(cond, pattern = "^muffle")
[17:41:21.611]                   }
[17:41:21.611]                 }
[17:41:21.611]                 else {
[17:41:21.611]                   if (TRUE) {
[17:41:21.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:21.611]                     {
[17:41:21.611]                       inherits <- base::inherits
[17:41:21.611]                       invokeRestart <- base::invokeRestart
[17:41:21.611]                       is.null <- base::is.null
[17:41:21.611]                       muffled <- FALSE
[17:41:21.611]                       if (inherits(cond, "message")) {
[17:41:21.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:21.611]                         if (muffled) 
[17:41:21.611]                           invokeRestart("muffleMessage")
[17:41:21.611]                       }
[17:41:21.611]                       else if (inherits(cond, "warning")) {
[17:41:21.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:21.611]                         if (muffled) 
[17:41:21.611]                           invokeRestart("muffleWarning")
[17:41:21.611]                       }
[17:41:21.611]                       else if (inherits(cond, "condition")) {
[17:41:21.611]                         if (!is.null(pattern)) {
[17:41:21.611]                           computeRestarts <- base::computeRestarts
[17:41:21.611]                           grepl <- base::grepl
[17:41:21.611]                           restarts <- computeRestarts(cond)
[17:41:21.611]                           for (restart in restarts) {
[17:41:21.611]                             name <- restart$name
[17:41:21.611]                             if (is.null(name)) 
[17:41:21.611]                               next
[17:41:21.611]                             if (!grepl(pattern, name)) 
[17:41:21.611]                               next
[17:41:21.611]                             invokeRestart(restart)
[17:41:21.611]                             muffled <- TRUE
[17:41:21.611]                             break
[17:41:21.611]                           }
[17:41:21.611]                         }
[17:41:21.611]                       }
[17:41:21.611]                       invisible(muffled)
[17:41:21.611]                     }
[17:41:21.611]                     muffleCondition(cond, pattern = "^muffle")
[17:41:21.611]                   }
[17:41:21.611]                 }
[17:41:21.611]             }
[17:41:21.611]         }))
[17:41:21.611]     }, error = function(ex) {
[17:41:21.611]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:21.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:21.611]                 ...future.rng), started = ...future.startTime, 
[17:41:21.611]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:21.611]             version = "1.8"), class = "FutureResult")
[17:41:21.611]     }, finally = {
[17:41:21.611]         if (!identical(...future.workdir, getwd())) 
[17:41:21.611]             setwd(...future.workdir)
[17:41:21.611]         {
[17:41:21.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:21.611]                 ...future.oldOptions$nwarnings <- NULL
[17:41:21.611]             }
[17:41:21.611]             base::options(...future.oldOptions)
[17:41:21.611]             if (.Platform$OS.type == "windows") {
[17:41:21.611]                 old_names <- names(...future.oldEnvVars)
[17:41:21.611]                 envs <- base::Sys.getenv()
[17:41:21.611]                 names <- names(envs)
[17:41:21.611]                 common <- intersect(names, old_names)
[17:41:21.611]                 added <- setdiff(names, old_names)
[17:41:21.611]                 removed <- setdiff(old_names, names)
[17:41:21.611]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:21.611]                   envs[common]]
[17:41:21.611]                 NAMES <- toupper(changed)
[17:41:21.611]                 args <- list()
[17:41:21.611]                 for (kk in seq_along(NAMES)) {
[17:41:21.611]                   name <- changed[[kk]]
[17:41:21.611]                   NAME <- NAMES[[kk]]
[17:41:21.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.611]                     next
[17:41:21.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:21.611]                 }
[17:41:21.611]                 NAMES <- toupper(added)
[17:41:21.611]                 for (kk in seq_along(NAMES)) {
[17:41:21.611]                   name <- added[[kk]]
[17:41:21.611]                   NAME <- NAMES[[kk]]
[17:41:21.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.611]                     next
[17:41:21.611]                   args[[name]] <- ""
[17:41:21.611]                 }
[17:41:21.611]                 NAMES <- toupper(removed)
[17:41:21.611]                 for (kk in seq_along(NAMES)) {
[17:41:21.611]                   name <- removed[[kk]]
[17:41:21.611]                   NAME <- NAMES[[kk]]
[17:41:21.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:21.611]                     next
[17:41:21.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:21.611]                 }
[17:41:21.611]                 if (length(args) > 0) 
[17:41:21.611]                   base::do.call(base::Sys.setenv, args = args)
[17:41:21.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:21.611]             }
[17:41:21.611]             else {
[17:41:21.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:21.611]             }
[17:41:21.611]             {
[17:41:21.611]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:21.611]                   0L) {
[17:41:21.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:21.611]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:21.611]                   base::options(opts)
[17:41:21.611]                 }
[17:41:21.611]                 {
[17:41:21.611]                   {
[17:41:21.611]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:21.611]                     NULL
[17:41:21.611]                   }
[17:41:21.611]                   options(future.plan = NULL)
[17:41:21.611]                   if (is.na(NA_character_)) 
[17:41:21.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:21.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:21.611]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:21.611]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:21.611]                     envir = parent.frame()) 
[17:41:21.611]                   {
[17:41:21.611]                     if (is.function(workers)) 
[17:41:21.611]                       workers <- workers()
[17:41:21.611]                     workers <- structure(as.integer(workers), 
[17:41:21.611]                       class = class(workers))
[17:41:21.611]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:21.611]                       workers >= 1)
[17:41:21.611]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:21.611]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:21.611]                     }
[17:41:21.611]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:21.611]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:21.611]                       envir = envir)
[17:41:21.611]                     if (!future$lazy) 
[17:41:21.611]                       future <- run(future)
[17:41:21.611]                     invisible(future)
[17:41:21.611]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:21.611]                 }
[17:41:21.611]             }
[17:41:21.611]         }
[17:41:21.611]     })
[17:41:21.611]     if (TRUE) {
[17:41:21.611]         base::sink(type = "output", split = FALSE)
[17:41:21.611]         if (FALSE) {
[17:41:21.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:21.611]         }
[17:41:21.611]         else {
[17:41:21.611]             ...future.result["stdout"] <- base::list(NULL)
[17:41:21.611]         }
[17:41:21.611]         base::close(...future.stdout)
[17:41:21.611]         ...future.stdout <- NULL
[17:41:21.611]     }
[17:41:21.611]     ...future.result$conditions <- ...future.conditions
[17:41:21.611]     ...future.result$finished <- base::Sys.time()
[17:41:21.611]     ...future.result
[17:41:21.611] }
[17:41:21.614] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:41:21.614] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:41:21.615] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:41:21.615] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:41:21.615] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:41:21.615] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:41:21.616] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:41:21.616] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:21.616] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:21.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:21.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:21.617] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:41:21.617] MultisessionFuture started
[17:41:21.617] - Launch lazy future ... done
[17:41:21.617] run() for ‘MultisessionFuture’ ... done
[17:41:21.617] Created future:
[17:41:21.618] MultisessionFuture:
[17:41:21.618] Label: ‘future_mapply-2’
[17:41:21.618] Expression:
[17:41:21.618] {
[17:41:21.618]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:21.618]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:21.618]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:21.618]         on.exit(options(oopts), add = TRUE)
[17:41:21.618]     }
[17:41:21.618]     {
[17:41:21.618]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:21.618]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:21.618]         do.call(mapply, args = args)
[17:41:21.618]     }
[17:41:21.618] }
[17:41:21.618] Lazy evaluation: FALSE
[17:41:21.618] Asynchronous evaluation: TRUE
[17:41:21.618] Local evaluation: TRUE
[17:41:21.618] Environment: R_GlobalEnv
[17:41:21.618] Capture standard output: FALSE
[17:41:21.618] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:21.618] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:21.618] Packages: <none>
[17:41:21.618] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:21.618] Resolved: FALSE
[17:41:21.618] Value: <not collected>
[17:41:21.618] Conditions captured: <none>
[17:41:21.618] Early signaling: FALSE
[17:41:21.618] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:21.618] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:21.629] Chunk #2 of 2 ... DONE
[17:41:21.629] Launching 2 futures (chunks) ... DONE
[17:41:21.629] Resolving 2 futures (chunks) ...
[17:41:21.629] resolve() on list ...
[17:41:21.630]  recursive: 0
[17:41:21.630]  length: 2
[17:41:21.630] 
[17:41:21.672] receiveMessageFromWorker() for ClusterFuture ...
[17:41:21.673] - Validating connection of MultisessionFuture
[17:41:21.673] - received message: FutureResult
[17:41:21.673] - Received FutureResult
[17:41:21.673] - Erased future from FutureRegistry
[17:41:21.673] result() for ClusterFuture ...
[17:41:21.673] - result already collected: FutureResult
[17:41:21.673] result() for ClusterFuture ... done
[17:41:21.673] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:21.674] Future #2
[17:41:21.674] result() for ClusterFuture ...
[17:41:21.674] - result already collected: FutureResult
[17:41:21.674] result() for ClusterFuture ... done
[17:41:21.674] result() for ClusterFuture ...
[17:41:21.674] - result already collected: FutureResult
[17:41:21.674] result() for ClusterFuture ... done
[17:41:21.674] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:21.674] - nx: 2
[17:41:21.674] - relay: TRUE
[17:41:21.674] - stdout: TRUE
[17:41:21.675] - signal: TRUE
[17:41:21.675] - resignal: FALSE
[17:41:21.675] - force: TRUE
[17:41:21.675] - relayed: [n=2] FALSE, FALSE
[17:41:21.675] - queued futures: [n=2] FALSE, FALSE
[17:41:21.675]  - until=1
[17:41:21.675]  - relaying element #1
[17:41:21.675] - relayed: [n=2] FALSE, FALSE
[17:41:21.675] - queued futures: [n=2] FALSE, TRUE
[17:41:21.675] signalConditionsASAP(NULL, pos=2) ... done
[17:41:21.676]  length: 1 (resolved future 2)
[17:41:22.125] receiveMessageFromWorker() for ClusterFuture ...
[17:41:22.125] - Validating connection of MultisessionFuture
[17:41:22.125] - received message: FutureResult
[17:41:22.125] - Received FutureResult
[17:41:22.126] - Erased future from FutureRegistry
[17:41:22.126] result() for ClusterFuture ...
[17:41:22.126] - result already collected: FutureResult
[17:41:22.126] result() for ClusterFuture ... done
[17:41:22.126] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:22.126] Future #1
[17:41:22.126] result() for ClusterFuture ...
[17:41:22.126] - result already collected: FutureResult
[17:41:22.126] result() for ClusterFuture ... done
[17:41:22.126] result() for ClusterFuture ...
[17:41:22.126] - result already collected: FutureResult
[17:41:22.127] result() for ClusterFuture ... done
[17:41:22.127] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:22.127] - nx: 2
[17:41:22.127] - relay: TRUE
[17:41:22.127] - stdout: TRUE
[17:41:22.127] - signal: TRUE
[17:41:22.127] - resignal: FALSE
[17:41:22.127] - force: TRUE
[17:41:22.127] - relayed: [n=2] FALSE, FALSE
[17:41:22.127] - queued futures: [n=2] FALSE, TRUE
[17:41:22.127]  - until=1
[17:41:22.128]  - relaying element #1
[17:41:22.128] result() for ClusterFuture ...
[17:41:22.128] - result already collected: FutureResult
[17:41:22.128] result() for ClusterFuture ... done
[17:41:22.128] result() for ClusterFuture ...
[17:41:22.128] - result already collected: FutureResult
[17:41:22.128] result() for ClusterFuture ... done
[17:41:22.128] result() for ClusterFuture ...
[17:41:22.128] - result already collected: FutureResult
[17:41:22.128] result() for ClusterFuture ... done
[17:41:22.128] result() for ClusterFuture ...
[17:41:22.128] - result already collected: FutureResult
[17:41:22.129] result() for ClusterFuture ... done
[17:41:22.129] - relayed: [n=2] TRUE, FALSE
[17:41:22.129] - queued futures: [n=2] TRUE, TRUE
[17:41:22.129] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:22.129]  length: 0 (resolved future 1)
[17:41:22.129] Relaying remaining futures
[17:41:22.129] signalConditionsASAP(NULL, pos=0) ...
[17:41:22.129] - nx: 2
[17:41:22.129] - relay: TRUE
[17:41:22.129] - stdout: TRUE
[17:41:22.129] - signal: TRUE
[17:41:22.130] - resignal: FALSE
[17:41:22.130] - force: TRUE
[17:41:22.130] - relayed: [n=2] TRUE, FALSE
[17:41:22.130] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:22.130]  - relaying element #2
[17:41:22.130] result() for ClusterFuture ...
[17:41:22.130] - result already collected: FutureResult
[17:41:22.130] result() for ClusterFuture ... done
[17:41:22.130] result() for ClusterFuture ...
[17:41:22.130] - result already collected: FutureResult
[17:41:22.130] result() for ClusterFuture ... done
[17:41:22.131] result() for ClusterFuture ...
[17:41:22.131] - result already collected: FutureResult
[17:41:22.131] result() for ClusterFuture ... done
[17:41:22.131] result() for ClusterFuture ...
[17:41:22.131] - result already collected: FutureResult
[17:41:22.131] result() for ClusterFuture ... done
[17:41:22.131] - relayed: [n=2] TRUE, TRUE
[17:41:22.131] - queued futures: [n=2] TRUE, TRUE
[17:41:22.131] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:41:22.131] resolve() on list ... DONE
[17:41:22.131] result() for ClusterFuture ...
[17:41:22.132] - result already collected: FutureResult
[17:41:22.132] result() for ClusterFuture ... done
[17:41:22.132] result() for ClusterFuture ...
[17:41:22.132] - result already collected: FutureResult
[17:41:22.132] result() for ClusterFuture ... done
[17:41:22.132] result() for ClusterFuture ...
[17:41:22.132] - result already collected: FutureResult
[17:41:22.132] result() for ClusterFuture ... done
[17:41:22.132] result() for ClusterFuture ...
[17:41:22.132] - result already collected: FutureResult
[17:41:22.132] result() for ClusterFuture ... done
[17:41:22.133]  - Number of value chunks collected: 2
[17:41:22.133] Resolving 2 futures (chunks) ... DONE
[17:41:22.133] Reducing values from 2 chunks ...
[17:41:22.133]  - Number of values collected after concatenation: 2
[17:41:22.133]  - Number of values expected: 2
[17:41:22.133] Reducing values from 2 chunks ... DONE
[17:41:22.133] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:41:22.133] future_mapply() ...
[17:41:22.137] Number of chunks: 2
[17:41:22.137] getGlobalsAndPackagesXApply() ...
[17:41:22.137]  - future.globals: TRUE
[17:41:22.137] getGlobalsAndPackages() ...
[17:41:22.138] Searching for globals...
[17:41:22.139] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:22.139] Searching for globals ... DONE
[17:41:22.139] Resolving globals: FALSE
[17:41:22.140] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:22.140] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:22.140] - globals: [1] ‘FUN’
[17:41:22.140] 
[17:41:22.140] getGlobalsAndPackages() ... DONE
[17:41:22.140]  - globals found/used: [n=1] ‘FUN’
[17:41:22.141]  - needed namespaces: [n=0] 
[17:41:22.141] Finding globals ... DONE
[17:41:22.141] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:22.141] List of 2
[17:41:22.141]  $ ...future.FUN:function (x, y)  
[17:41:22.141]  $ MoreArgs     : NULL
[17:41:22.141]  - attr(*, "where")=List of 2
[17:41:22.141]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:22.141]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:22.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:22.141]  - attr(*, "resolved")= logi FALSE
[17:41:22.141]  - attr(*, "total_size")= num NA
[17:41:22.143] Packages to be attached in all futures: [n=0] 
[17:41:22.144] getGlobalsAndPackagesXApply() ... DONE
[17:41:22.144] Number of futures (= number of chunks): 2
[17:41:22.144] Launching 2 futures (chunks) ...
[17:41:22.144] Chunk #1 of 2 ...
[17:41:22.144]  - Finding globals in '...' for chunk #1 ...
[17:41:22.144] getGlobalsAndPackages() ...
[17:41:22.144] Searching for globals...
[17:41:22.145] 
[17:41:22.145] Searching for globals ... DONE
[17:41:22.145] - globals: [0] <none>
[17:41:22.145] getGlobalsAndPackages() ... DONE
[17:41:22.145]    + additional globals found: [n=0] 
[17:41:22.145]    + additional namespaces needed: [n=0] 
[17:41:22.145]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:22.145]  - seeds: <none>
[17:41:22.145] getGlobalsAndPackages() ...
[17:41:22.145] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:22.146] Resolving globals: FALSE
[17:41:22.146] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:22.146] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:22.146] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:22.147] 
[17:41:22.147] getGlobalsAndPackages() ... DONE
[17:41:22.147] run() for ‘Future’ ...
[17:41:22.147] - state: ‘created’
[17:41:22.147] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:22.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:22.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:22.162]   - Field: ‘node’
[17:41:22.162]   - Field: ‘label’
[17:41:22.162]   - Field: ‘local’
[17:41:22.162]   - Field: ‘owner’
[17:41:22.162]   - Field: ‘envir’
[17:41:22.162]   - Field: ‘workers’
[17:41:22.162]   - Field: ‘packages’
[17:41:22.162]   - Field: ‘gc’
[17:41:22.162]   - Field: ‘conditions’
[17:41:22.162]   - Field: ‘persistent’
[17:41:22.163]   - Field: ‘expr’
[17:41:22.163]   - Field: ‘uuid’
[17:41:22.163]   - Field: ‘seed’
[17:41:22.163]   - Field: ‘version’
[17:41:22.163]   - Field: ‘result’
[17:41:22.163]   - Field: ‘asynchronous’
[17:41:22.163]   - Field: ‘calls’
[17:41:22.163]   - Field: ‘globals’
[17:41:22.163]   - Field: ‘stdout’
[17:41:22.163]   - Field: ‘earlySignal’
[17:41:22.164]   - Field: ‘lazy’
[17:41:22.164]   - Field: ‘state’
[17:41:22.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:22.164] - Launch lazy future ...
[17:41:22.164] Packages needed by the future expression (n = 0): <none>
[17:41:22.164] Packages needed by future strategies (n = 0): <none>
[17:41:22.165] {
[17:41:22.165]     {
[17:41:22.165]         {
[17:41:22.165]             ...future.startTime <- base::Sys.time()
[17:41:22.165]             {
[17:41:22.165]                 {
[17:41:22.165]                   {
[17:41:22.165]                     {
[17:41:22.165]                       base::local({
[17:41:22.165]                         has_future <- base::requireNamespace("future", 
[17:41:22.165]                           quietly = TRUE)
[17:41:22.165]                         if (has_future) {
[17:41:22.165]                           ns <- base::getNamespace("future")
[17:41:22.165]                           version <- ns[[".package"]][["version"]]
[17:41:22.165]                           if (is.null(version)) 
[17:41:22.165]                             version <- utils::packageVersion("future")
[17:41:22.165]                         }
[17:41:22.165]                         else {
[17:41:22.165]                           version <- NULL
[17:41:22.165]                         }
[17:41:22.165]                         if (!has_future || version < "1.8.0") {
[17:41:22.165]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:22.165]                             "", base::R.version$version.string), 
[17:41:22.165]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:22.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:22.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:22.165]                               "release", "version")], collapse = " "), 
[17:41:22.165]                             hostname = base::Sys.info()[["nodename"]])
[17:41:22.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:22.165]                             info)
[17:41:22.165]                           info <- base::paste(info, collapse = "; ")
[17:41:22.165]                           if (!has_future) {
[17:41:22.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:22.165]                               info)
[17:41:22.165]                           }
[17:41:22.165]                           else {
[17:41:22.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:22.165]                               info, version)
[17:41:22.165]                           }
[17:41:22.165]                           base::stop(msg)
[17:41:22.165]                         }
[17:41:22.165]                       })
[17:41:22.165]                     }
[17:41:22.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:22.165]                     base::options(mc.cores = 1L)
[17:41:22.165]                   }
[17:41:22.165]                   options(future.plan = NULL)
[17:41:22.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:22.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:22.165]                 }
[17:41:22.165]                 ...future.workdir <- getwd()
[17:41:22.165]             }
[17:41:22.165]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:22.165]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:22.165]         }
[17:41:22.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:22.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:22.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:22.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:22.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:22.165]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:22.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:22.165]             base::names(...future.oldOptions))
[17:41:22.165]     }
[17:41:22.165]     if (FALSE) {
[17:41:22.165]     }
[17:41:22.165]     else {
[17:41:22.165]         if (TRUE) {
[17:41:22.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:22.165]                 open = "w")
[17:41:22.165]         }
[17:41:22.165]         else {
[17:41:22.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:22.165]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:22.165]         }
[17:41:22.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:22.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:22.165]             base::sink(type = "output", split = FALSE)
[17:41:22.165]             base::close(...future.stdout)
[17:41:22.165]         }, add = TRUE)
[17:41:22.165]     }
[17:41:22.165]     ...future.frame <- base::sys.nframe()
[17:41:22.165]     ...future.conditions <- base::list()
[17:41:22.165]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:22.165]     if (FALSE) {
[17:41:22.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:22.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:22.165]     }
[17:41:22.165]     ...future.result <- base::tryCatch({
[17:41:22.165]         base::withCallingHandlers({
[17:41:22.165]             ...future.value <- base::withVisible(base::local({
[17:41:22.165]                 ...future.makeSendCondition <- local({
[17:41:22.165]                   sendCondition <- NULL
[17:41:22.165]                   function(frame = 1L) {
[17:41:22.165]                     if (is.function(sendCondition)) 
[17:41:22.165]                       return(sendCondition)
[17:41:22.165]                     ns <- getNamespace("parallel")
[17:41:22.165]                     if (exists("sendData", mode = "function", 
[17:41:22.165]                       envir = ns)) {
[17:41:22.165]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:22.165]                         envir = ns)
[17:41:22.165]                       envir <- sys.frame(frame)
[17:41:22.165]                       master <- NULL
[17:41:22.165]                       while (!identical(envir, .GlobalEnv) && 
[17:41:22.165]                         !identical(envir, emptyenv())) {
[17:41:22.165]                         if (exists("master", mode = "list", envir = envir, 
[17:41:22.165]                           inherits = FALSE)) {
[17:41:22.165]                           master <- get("master", mode = "list", 
[17:41:22.165]                             envir = envir, inherits = FALSE)
[17:41:22.165]                           if (inherits(master, c("SOCKnode", 
[17:41:22.165]                             "SOCK0node"))) {
[17:41:22.165]                             sendCondition <<- function(cond) {
[17:41:22.165]                               data <- list(type = "VALUE", value = cond, 
[17:41:22.165]                                 success = TRUE)
[17:41:22.165]                               parallel_sendData(master, data)
[17:41:22.165]                             }
[17:41:22.165]                             return(sendCondition)
[17:41:22.165]                           }
[17:41:22.165]                         }
[17:41:22.165]                         frame <- frame + 1L
[17:41:22.165]                         envir <- sys.frame(frame)
[17:41:22.165]                       }
[17:41:22.165]                     }
[17:41:22.165]                     sendCondition <<- function(cond) NULL
[17:41:22.165]                   }
[17:41:22.165]                 })
[17:41:22.165]                 withCallingHandlers({
[17:41:22.165]                   {
[17:41:22.165]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:22.165]                     if (!identical(...future.globals.maxSize.org, 
[17:41:22.165]                       ...future.globals.maxSize)) {
[17:41:22.165]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:22.165]                       on.exit(options(oopts), add = TRUE)
[17:41:22.165]                     }
[17:41:22.165]                     {
[17:41:22.165]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:22.165]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:22.165]                         USE.NAMES = FALSE)
[17:41:22.165]                       do.call(mapply, args = args)
[17:41:22.165]                     }
[17:41:22.165]                   }
[17:41:22.165]                 }, immediateCondition = function(cond) {
[17:41:22.165]                   sendCondition <- ...future.makeSendCondition()
[17:41:22.165]                   sendCondition(cond)
[17:41:22.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.165]                   {
[17:41:22.165]                     inherits <- base::inherits
[17:41:22.165]                     invokeRestart <- base::invokeRestart
[17:41:22.165]                     is.null <- base::is.null
[17:41:22.165]                     muffled <- FALSE
[17:41:22.165]                     if (inherits(cond, "message")) {
[17:41:22.165]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:22.165]                       if (muffled) 
[17:41:22.165]                         invokeRestart("muffleMessage")
[17:41:22.165]                     }
[17:41:22.165]                     else if (inherits(cond, "warning")) {
[17:41:22.165]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:22.165]                       if (muffled) 
[17:41:22.165]                         invokeRestart("muffleWarning")
[17:41:22.165]                     }
[17:41:22.165]                     else if (inherits(cond, "condition")) {
[17:41:22.165]                       if (!is.null(pattern)) {
[17:41:22.165]                         computeRestarts <- base::computeRestarts
[17:41:22.165]                         grepl <- base::grepl
[17:41:22.165]                         restarts <- computeRestarts(cond)
[17:41:22.165]                         for (restart in restarts) {
[17:41:22.165]                           name <- restart$name
[17:41:22.165]                           if (is.null(name)) 
[17:41:22.165]                             next
[17:41:22.165]                           if (!grepl(pattern, name)) 
[17:41:22.165]                             next
[17:41:22.165]                           invokeRestart(restart)
[17:41:22.165]                           muffled <- TRUE
[17:41:22.165]                           break
[17:41:22.165]                         }
[17:41:22.165]                       }
[17:41:22.165]                     }
[17:41:22.165]                     invisible(muffled)
[17:41:22.165]                   }
[17:41:22.165]                   muffleCondition(cond)
[17:41:22.165]                 })
[17:41:22.165]             }))
[17:41:22.165]             future::FutureResult(value = ...future.value$value, 
[17:41:22.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:22.165]                   ...future.rng), globalenv = if (FALSE) 
[17:41:22.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:22.165]                     ...future.globalenv.names))
[17:41:22.165]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:22.165]         }, condition = base::local({
[17:41:22.165]             c <- base::c
[17:41:22.165]             inherits <- base::inherits
[17:41:22.165]             invokeRestart <- base::invokeRestart
[17:41:22.165]             length <- base::length
[17:41:22.165]             list <- base::list
[17:41:22.165]             seq.int <- base::seq.int
[17:41:22.165]             signalCondition <- base::signalCondition
[17:41:22.165]             sys.calls <- base::sys.calls
[17:41:22.165]             `[[` <- base::`[[`
[17:41:22.165]             `+` <- base::`+`
[17:41:22.165]             `<<-` <- base::`<<-`
[17:41:22.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:22.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:22.165]                   3L)]
[17:41:22.165]             }
[17:41:22.165]             function(cond) {
[17:41:22.165]                 is_error <- inherits(cond, "error")
[17:41:22.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:22.165]                   NULL)
[17:41:22.165]                 if (is_error) {
[17:41:22.165]                   sessionInformation <- function() {
[17:41:22.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:22.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:22.165]                       search = base::search(), system = base::Sys.info())
[17:41:22.165]                   }
[17:41:22.165]                   ...future.conditions[[length(...future.conditions) + 
[17:41:22.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:22.165]                     cond$call), session = sessionInformation(), 
[17:41:22.165]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:22.165]                   signalCondition(cond)
[17:41:22.165]                 }
[17:41:22.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:22.165]                 "immediateCondition"))) {
[17:41:22.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:22.165]                   ...future.conditions[[length(...future.conditions) + 
[17:41:22.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:22.165]                   if (TRUE && !signal) {
[17:41:22.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.165]                     {
[17:41:22.165]                       inherits <- base::inherits
[17:41:22.165]                       invokeRestart <- base::invokeRestart
[17:41:22.165]                       is.null <- base::is.null
[17:41:22.165]                       muffled <- FALSE
[17:41:22.165]                       if (inherits(cond, "message")) {
[17:41:22.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:22.165]                         if (muffled) 
[17:41:22.165]                           invokeRestart("muffleMessage")
[17:41:22.165]                       }
[17:41:22.165]                       else if (inherits(cond, "warning")) {
[17:41:22.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:22.165]                         if (muffled) 
[17:41:22.165]                           invokeRestart("muffleWarning")
[17:41:22.165]                       }
[17:41:22.165]                       else if (inherits(cond, "condition")) {
[17:41:22.165]                         if (!is.null(pattern)) {
[17:41:22.165]                           computeRestarts <- base::computeRestarts
[17:41:22.165]                           grepl <- base::grepl
[17:41:22.165]                           restarts <- computeRestarts(cond)
[17:41:22.165]                           for (restart in restarts) {
[17:41:22.165]                             name <- restart$name
[17:41:22.165]                             if (is.null(name)) 
[17:41:22.165]                               next
[17:41:22.165]                             if (!grepl(pattern, name)) 
[17:41:22.165]                               next
[17:41:22.165]                             invokeRestart(restart)
[17:41:22.165]                             muffled <- TRUE
[17:41:22.165]                             break
[17:41:22.165]                           }
[17:41:22.165]                         }
[17:41:22.165]                       }
[17:41:22.165]                       invisible(muffled)
[17:41:22.165]                     }
[17:41:22.165]                     muffleCondition(cond, pattern = "^muffle")
[17:41:22.165]                   }
[17:41:22.165]                 }
[17:41:22.165]                 else {
[17:41:22.165]                   if (TRUE) {
[17:41:22.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.165]                     {
[17:41:22.165]                       inherits <- base::inherits
[17:41:22.165]                       invokeRestart <- base::invokeRestart
[17:41:22.165]                       is.null <- base::is.null
[17:41:22.165]                       muffled <- FALSE
[17:41:22.165]                       if (inherits(cond, "message")) {
[17:41:22.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:22.165]                         if (muffled) 
[17:41:22.165]                           invokeRestart("muffleMessage")
[17:41:22.165]                       }
[17:41:22.165]                       else if (inherits(cond, "warning")) {
[17:41:22.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:22.165]                         if (muffled) 
[17:41:22.165]                           invokeRestart("muffleWarning")
[17:41:22.165]                       }
[17:41:22.165]                       else if (inherits(cond, "condition")) {
[17:41:22.165]                         if (!is.null(pattern)) {
[17:41:22.165]                           computeRestarts <- base::computeRestarts
[17:41:22.165]                           grepl <- base::grepl
[17:41:22.165]                           restarts <- computeRestarts(cond)
[17:41:22.165]                           for (restart in restarts) {
[17:41:22.165]                             name <- restart$name
[17:41:22.165]                             if (is.null(name)) 
[17:41:22.165]                               next
[17:41:22.165]                             if (!grepl(pattern, name)) 
[17:41:22.165]                               next
[17:41:22.165]                             invokeRestart(restart)
[17:41:22.165]                             muffled <- TRUE
[17:41:22.165]                             break
[17:41:22.165]                           }
[17:41:22.165]                         }
[17:41:22.165]                       }
[17:41:22.165]                       invisible(muffled)
[17:41:22.165]                     }
[17:41:22.165]                     muffleCondition(cond, pattern = "^muffle")
[17:41:22.165]                   }
[17:41:22.165]                 }
[17:41:22.165]             }
[17:41:22.165]         }))
[17:41:22.165]     }, error = function(ex) {
[17:41:22.165]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:22.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:22.165]                 ...future.rng), started = ...future.startTime, 
[17:41:22.165]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:22.165]             version = "1.8"), class = "FutureResult")
[17:41:22.165]     }, finally = {
[17:41:22.165]         if (!identical(...future.workdir, getwd())) 
[17:41:22.165]             setwd(...future.workdir)
[17:41:22.165]         {
[17:41:22.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:22.165]                 ...future.oldOptions$nwarnings <- NULL
[17:41:22.165]             }
[17:41:22.165]             base::options(...future.oldOptions)
[17:41:22.165]             if (.Platform$OS.type == "windows") {
[17:41:22.165]                 old_names <- names(...future.oldEnvVars)
[17:41:22.165]                 envs <- base::Sys.getenv()
[17:41:22.165]                 names <- names(envs)
[17:41:22.165]                 common <- intersect(names, old_names)
[17:41:22.165]                 added <- setdiff(names, old_names)
[17:41:22.165]                 removed <- setdiff(old_names, names)
[17:41:22.165]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:22.165]                   envs[common]]
[17:41:22.165]                 NAMES <- toupper(changed)
[17:41:22.165]                 args <- list()
[17:41:22.165]                 for (kk in seq_along(NAMES)) {
[17:41:22.165]                   name <- changed[[kk]]
[17:41:22.165]                   NAME <- NAMES[[kk]]
[17:41:22.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.165]                     next
[17:41:22.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:22.165]                 }
[17:41:22.165]                 NAMES <- toupper(added)
[17:41:22.165]                 for (kk in seq_along(NAMES)) {
[17:41:22.165]                   name <- added[[kk]]
[17:41:22.165]                   NAME <- NAMES[[kk]]
[17:41:22.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.165]                     next
[17:41:22.165]                   args[[name]] <- ""
[17:41:22.165]                 }
[17:41:22.165]                 NAMES <- toupper(removed)
[17:41:22.165]                 for (kk in seq_along(NAMES)) {
[17:41:22.165]                   name <- removed[[kk]]
[17:41:22.165]                   NAME <- NAMES[[kk]]
[17:41:22.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.165]                     next
[17:41:22.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:22.165]                 }
[17:41:22.165]                 if (length(args) > 0) 
[17:41:22.165]                   base::do.call(base::Sys.setenv, args = args)
[17:41:22.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:22.165]             }
[17:41:22.165]             else {
[17:41:22.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:22.165]             }
[17:41:22.165]             {
[17:41:22.165]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:22.165]                   0L) {
[17:41:22.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:22.165]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:22.165]                   base::options(opts)
[17:41:22.165]                 }
[17:41:22.165]                 {
[17:41:22.165]                   {
[17:41:22.165]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:22.165]                     NULL
[17:41:22.165]                   }
[17:41:22.165]                   options(future.plan = NULL)
[17:41:22.165]                   if (is.na(NA_character_)) 
[17:41:22.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:22.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:22.165]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:22.165]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:22.165]                     envir = parent.frame()) 
[17:41:22.165]                   {
[17:41:22.165]                     if (is.function(workers)) 
[17:41:22.165]                       workers <- workers()
[17:41:22.165]                     workers <- structure(as.integer(workers), 
[17:41:22.165]                       class = class(workers))
[17:41:22.165]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:22.165]                       workers >= 1)
[17:41:22.165]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:22.165]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:22.165]                     }
[17:41:22.165]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:22.165]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:22.165]                       envir = envir)
[17:41:22.165]                     if (!future$lazy) 
[17:41:22.165]                       future <- run(future)
[17:41:22.165]                     invisible(future)
[17:41:22.165]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:22.165]                 }
[17:41:22.165]             }
[17:41:22.165]         }
[17:41:22.165]     })
[17:41:22.165]     if (TRUE) {
[17:41:22.165]         base::sink(type = "output", split = FALSE)
[17:41:22.165]         if (TRUE) {
[17:41:22.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:22.165]         }
[17:41:22.165]         else {
[17:41:22.165]             ...future.result["stdout"] <- base::list(NULL)
[17:41:22.165]         }
[17:41:22.165]         base::close(...future.stdout)
[17:41:22.165]         ...future.stdout <- NULL
[17:41:22.165]     }
[17:41:22.165]     ...future.result$conditions <- ...future.conditions
[17:41:22.165]     ...future.result$finished <- base::Sys.time()
[17:41:22.165]     ...future.result
[17:41:22.165] }
[17:41:22.167] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:41:22.168] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:41:22.168] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:41:22.168] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:41:22.168] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:41:22.169] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:41:22.169] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:41:22.169] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:22.169] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:22.170] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:22.170] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:22.170] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:41:22.171] MultisessionFuture started
[17:41:22.171] - Launch lazy future ... done
[17:41:22.171] run() for ‘MultisessionFuture’ ... done
[17:41:22.171] Created future:
[17:41:22.171] MultisessionFuture:
[17:41:22.171] Label: ‘future_mapply-1’
[17:41:22.171] Expression:
[17:41:22.171] {
[17:41:22.171]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:22.171]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:22.171]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:22.171]         on.exit(options(oopts), add = TRUE)
[17:41:22.171]     }
[17:41:22.171]     {
[17:41:22.171]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:22.171]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:22.171]         do.call(mapply, args = args)
[17:41:22.171]     }
[17:41:22.171] }
[17:41:22.171] Lazy evaluation: FALSE
[17:41:22.171] Asynchronous evaluation: TRUE
[17:41:22.171] Local evaluation: TRUE
[17:41:22.171] Environment: R_GlobalEnv
[17:41:22.171] Capture standard output: TRUE
[17:41:22.171] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:22.171] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:22.171] Packages: <none>
[17:41:22.171] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:22.171] Resolved: FALSE
[17:41:22.171] Value: <not collected>
[17:41:22.171] Conditions captured: <none>
[17:41:22.171] Early signaling: FALSE
[17:41:22.171] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:22.171] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:22.183] Chunk #1 of 2 ... DONE
[17:41:22.183] Chunk #2 of 2 ...
[17:41:22.183]  - Finding globals in '...' for chunk #2 ...
[17:41:22.183] getGlobalsAndPackages() ...
[17:41:22.183] Searching for globals...
[17:41:22.183] 
[17:41:22.184] Searching for globals ... DONE
[17:41:22.184] - globals: [0] <none>
[17:41:22.184] getGlobalsAndPackages() ... DONE
[17:41:22.184]    + additional globals found: [n=0] 
[17:41:22.184]    + additional namespaces needed: [n=0] 
[17:41:22.184]  - Finding globals in '...' for chunk #2 ... DONE
[17:41:22.184]  - seeds: <none>
[17:41:22.184] getGlobalsAndPackages() ...
[17:41:22.184] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:22.184] Resolving globals: FALSE
[17:41:22.185] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:22.185] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:22.185] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:22.186] 
[17:41:22.186] getGlobalsAndPackages() ... DONE
[17:41:22.186] run() for ‘Future’ ...
[17:41:22.186] - state: ‘created’
[17:41:22.186] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:22.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:22.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:22.201]   - Field: ‘node’
[17:41:22.201]   - Field: ‘label’
[17:41:22.201]   - Field: ‘local’
[17:41:22.201]   - Field: ‘owner’
[17:41:22.201]   - Field: ‘envir’
[17:41:22.201]   - Field: ‘workers’
[17:41:22.201]   - Field: ‘packages’
[17:41:22.202]   - Field: ‘gc’
[17:41:22.202]   - Field: ‘conditions’
[17:41:22.202]   - Field: ‘persistent’
[17:41:22.202]   - Field: ‘expr’
[17:41:22.202]   - Field: ‘uuid’
[17:41:22.202]   - Field: ‘seed’
[17:41:22.204]   - Field: ‘version’
[17:41:22.204]   - Field: ‘result’
[17:41:22.204]   - Field: ‘asynchronous’
[17:41:22.204]   - Field: ‘calls’
[17:41:22.204]   - Field: ‘globals’
[17:41:22.205]   - Field: ‘stdout’
[17:41:22.205]   - Field: ‘earlySignal’
[17:41:22.205]   - Field: ‘lazy’
[17:41:22.205]   - Field: ‘state’
[17:41:22.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:22.205] - Launch lazy future ...
[17:41:22.205] Packages needed by the future expression (n = 0): <none>
[17:41:22.205] Packages needed by future strategies (n = 0): <none>
[17:41:22.206] {
[17:41:22.206]     {
[17:41:22.206]         {
[17:41:22.206]             ...future.startTime <- base::Sys.time()
[17:41:22.206]             {
[17:41:22.206]                 {
[17:41:22.206]                   {
[17:41:22.206]                     {
[17:41:22.206]                       base::local({
[17:41:22.206]                         has_future <- base::requireNamespace("future", 
[17:41:22.206]                           quietly = TRUE)
[17:41:22.206]                         if (has_future) {
[17:41:22.206]                           ns <- base::getNamespace("future")
[17:41:22.206]                           version <- ns[[".package"]][["version"]]
[17:41:22.206]                           if (is.null(version)) 
[17:41:22.206]                             version <- utils::packageVersion("future")
[17:41:22.206]                         }
[17:41:22.206]                         else {
[17:41:22.206]                           version <- NULL
[17:41:22.206]                         }
[17:41:22.206]                         if (!has_future || version < "1.8.0") {
[17:41:22.206]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:22.206]                             "", base::R.version$version.string), 
[17:41:22.206]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:22.206]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:22.206]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:22.206]                               "release", "version")], collapse = " "), 
[17:41:22.206]                             hostname = base::Sys.info()[["nodename"]])
[17:41:22.206]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:22.206]                             info)
[17:41:22.206]                           info <- base::paste(info, collapse = "; ")
[17:41:22.206]                           if (!has_future) {
[17:41:22.206]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:22.206]                               info)
[17:41:22.206]                           }
[17:41:22.206]                           else {
[17:41:22.206]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:22.206]                               info, version)
[17:41:22.206]                           }
[17:41:22.206]                           base::stop(msg)
[17:41:22.206]                         }
[17:41:22.206]                       })
[17:41:22.206]                     }
[17:41:22.206]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:22.206]                     base::options(mc.cores = 1L)
[17:41:22.206]                   }
[17:41:22.206]                   options(future.plan = NULL)
[17:41:22.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:22.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:22.206]                 }
[17:41:22.206]                 ...future.workdir <- getwd()
[17:41:22.206]             }
[17:41:22.206]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:22.206]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:22.206]         }
[17:41:22.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:22.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:22.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:22.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:22.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:22.206]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:22.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:22.206]             base::names(...future.oldOptions))
[17:41:22.206]     }
[17:41:22.206]     if (FALSE) {
[17:41:22.206]     }
[17:41:22.206]     else {
[17:41:22.206]         if (TRUE) {
[17:41:22.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:22.206]                 open = "w")
[17:41:22.206]         }
[17:41:22.206]         else {
[17:41:22.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:22.206]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:22.206]         }
[17:41:22.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:22.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:22.206]             base::sink(type = "output", split = FALSE)
[17:41:22.206]             base::close(...future.stdout)
[17:41:22.206]         }, add = TRUE)
[17:41:22.206]     }
[17:41:22.206]     ...future.frame <- base::sys.nframe()
[17:41:22.206]     ...future.conditions <- base::list()
[17:41:22.206]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:22.206]     if (FALSE) {
[17:41:22.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:22.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:22.206]     }
[17:41:22.206]     ...future.result <- base::tryCatch({
[17:41:22.206]         base::withCallingHandlers({
[17:41:22.206]             ...future.value <- base::withVisible(base::local({
[17:41:22.206]                 ...future.makeSendCondition <- local({
[17:41:22.206]                   sendCondition <- NULL
[17:41:22.206]                   function(frame = 1L) {
[17:41:22.206]                     if (is.function(sendCondition)) 
[17:41:22.206]                       return(sendCondition)
[17:41:22.206]                     ns <- getNamespace("parallel")
[17:41:22.206]                     if (exists("sendData", mode = "function", 
[17:41:22.206]                       envir = ns)) {
[17:41:22.206]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:22.206]                         envir = ns)
[17:41:22.206]                       envir <- sys.frame(frame)
[17:41:22.206]                       master <- NULL
[17:41:22.206]                       while (!identical(envir, .GlobalEnv) && 
[17:41:22.206]                         !identical(envir, emptyenv())) {
[17:41:22.206]                         if (exists("master", mode = "list", envir = envir, 
[17:41:22.206]                           inherits = FALSE)) {
[17:41:22.206]                           master <- get("master", mode = "list", 
[17:41:22.206]                             envir = envir, inherits = FALSE)
[17:41:22.206]                           if (inherits(master, c("SOCKnode", 
[17:41:22.206]                             "SOCK0node"))) {
[17:41:22.206]                             sendCondition <<- function(cond) {
[17:41:22.206]                               data <- list(type = "VALUE", value = cond, 
[17:41:22.206]                                 success = TRUE)
[17:41:22.206]                               parallel_sendData(master, data)
[17:41:22.206]                             }
[17:41:22.206]                             return(sendCondition)
[17:41:22.206]                           }
[17:41:22.206]                         }
[17:41:22.206]                         frame <- frame + 1L
[17:41:22.206]                         envir <- sys.frame(frame)
[17:41:22.206]                       }
[17:41:22.206]                     }
[17:41:22.206]                     sendCondition <<- function(cond) NULL
[17:41:22.206]                   }
[17:41:22.206]                 })
[17:41:22.206]                 withCallingHandlers({
[17:41:22.206]                   {
[17:41:22.206]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:22.206]                     if (!identical(...future.globals.maxSize.org, 
[17:41:22.206]                       ...future.globals.maxSize)) {
[17:41:22.206]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:22.206]                       on.exit(options(oopts), add = TRUE)
[17:41:22.206]                     }
[17:41:22.206]                     {
[17:41:22.206]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:22.206]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:22.206]                         USE.NAMES = FALSE)
[17:41:22.206]                       do.call(mapply, args = args)
[17:41:22.206]                     }
[17:41:22.206]                   }
[17:41:22.206]                 }, immediateCondition = function(cond) {
[17:41:22.206]                   sendCondition <- ...future.makeSendCondition()
[17:41:22.206]                   sendCondition(cond)
[17:41:22.206]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.206]                   {
[17:41:22.206]                     inherits <- base::inherits
[17:41:22.206]                     invokeRestart <- base::invokeRestart
[17:41:22.206]                     is.null <- base::is.null
[17:41:22.206]                     muffled <- FALSE
[17:41:22.206]                     if (inherits(cond, "message")) {
[17:41:22.206]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:22.206]                       if (muffled) 
[17:41:22.206]                         invokeRestart("muffleMessage")
[17:41:22.206]                     }
[17:41:22.206]                     else if (inherits(cond, "warning")) {
[17:41:22.206]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:22.206]                       if (muffled) 
[17:41:22.206]                         invokeRestart("muffleWarning")
[17:41:22.206]                     }
[17:41:22.206]                     else if (inherits(cond, "condition")) {
[17:41:22.206]                       if (!is.null(pattern)) {
[17:41:22.206]                         computeRestarts <- base::computeRestarts
[17:41:22.206]                         grepl <- base::grepl
[17:41:22.206]                         restarts <- computeRestarts(cond)
[17:41:22.206]                         for (restart in restarts) {
[17:41:22.206]                           name <- restart$name
[17:41:22.206]                           if (is.null(name)) 
[17:41:22.206]                             next
[17:41:22.206]                           if (!grepl(pattern, name)) 
[17:41:22.206]                             next
[17:41:22.206]                           invokeRestart(restart)
[17:41:22.206]                           muffled <- TRUE
[17:41:22.206]                           break
[17:41:22.206]                         }
[17:41:22.206]                       }
[17:41:22.206]                     }
[17:41:22.206]                     invisible(muffled)
[17:41:22.206]                   }
[17:41:22.206]                   muffleCondition(cond)
[17:41:22.206]                 })
[17:41:22.206]             }))
[17:41:22.206]             future::FutureResult(value = ...future.value$value, 
[17:41:22.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:22.206]                   ...future.rng), globalenv = if (FALSE) 
[17:41:22.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:22.206]                     ...future.globalenv.names))
[17:41:22.206]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:22.206]         }, condition = base::local({
[17:41:22.206]             c <- base::c
[17:41:22.206]             inherits <- base::inherits
[17:41:22.206]             invokeRestart <- base::invokeRestart
[17:41:22.206]             length <- base::length
[17:41:22.206]             list <- base::list
[17:41:22.206]             seq.int <- base::seq.int
[17:41:22.206]             signalCondition <- base::signalCondition
[17:41:22.206]             sys.calls <- base::sys.calls
[17:41:22.206]             `[[` <- base::`[[`
[17:41:22.206]             `+` <- base::`+`
[17:41:22.206]             `<<-` <- base::`<<-`
[17:41:22.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:22.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:22.206]                   3L)]
[17:41:22.206]             }
[17:41:22.206]             function(cond) {
[17:41:22.206]                 is_error <- inherits(cond, "error")
[17:41:22.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:22.206]                   NULL)
[17:41:22.206]                 if (is_error) {
[17:41:22.206]                   sessionInformation <- function() {
[17:41:22.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:22.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:22.206]                       search = base::search(), system = base::Sys.info())
[17:41:22.206]                   }
[17:41:22.206]                   ...future.conditions[[length(...future.conditions) + 
[17:41:22.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:22.206]                     cond$call), session = sessionInformation(), 
[17:41:22.206]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:22.206]                   signalCondition(cond)
[17:41:22.206]                 }
[17:41:22.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:22.206]                 "immediateCondition"))) {
[17:41:22.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:22.206]                   ...future.conditions[[length(...future.conditions) + 
[17:41:22.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:22.206]                   if (TRUE && !signal) {
[17:41:22.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.206]                     {
[17:41:22.206]                       inherits <- base::inherits
[17:41:22.206]                       invokeRestart <- base::invokeRestart
[17:41:22.206]                       is.null <- base::is.null
[17:41:22.206]                       muffled <- FALSE
[17:41:22.206]                       if (inherits(cond, "message")) {
[17:41:22.206]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:22.206]                         if (muffled) 
[17:41:22.206]                           invokeRestart("muffleMessage")
[17:41:22.206]                       }
[17:41:22.206]                       else if (inherits(cond, "warning")) {
[17:41:22.206]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:22.206]                         if (muffled) 
[17:41:22.206]                           invokeRestart("muffleWarning")
[17:41:22.206]                       }
[17:41:22.206]                       else if (inherits(cond, "condition")) {
[17:41:22.206]                         if (!is.null(pattern)) {
[17:41:22.206]                           computeRestarts <- base::computeRestarts
[17:41:22.206]                           grepl <- base::grepl
[17:41:22.206]                           restarts <- computeRestarts(cond)
[17:41:22.206]                           for (restart in restarts) {
[17:41:22.206]                             name <- restart$name
[17:41:22.206]                             if (is.null(name)) 
[17:41:22.206]                               next
[17:41:22.206]                             if (!grepl(pattern, name)) 
[17:41:22.206]                               next
[17:41:22.206]                             invokeRestart(restart)
[17:41:22.206]                             muffled <- TRUE
[17:41:22.206]                             break
[17:41:22.206]                           }
[17:41:22.206]                         }
[17:41:22.206]                       }
[17:41:22.206]                       invisible(muffled)
[17:41:22.206]                     }
[17:41:22.206]                     muffleCondition(cond, pattern = "^muffle")
[17:41:22.206]                   }
[17:41:22.206]                 }
[17:41:22.206]                 else {
[17:41:22.206]                   if (TRUE) {
[17:41:22.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.206]                     {
[17:41:22.206]                       inherits <- base::inherits
[17:41:22.206]                       invokeRestart <- base::invokeRestart
[17:41:22.206]                       is.null <- base::is.null
[17:41:22.206]                       muffled <- FALSE
[17:41:22.206]                       if (inherits(cond, "message")) {
[17:41:22.206]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:22.206]                         if (muffled) 
[17:41:22.206]                           invokeRestart("muffleMessage")
[17:41:22.206]                       }
[17:41:22.206]                       else if (inherits(cond, "warning")) {
[17:41:22.206]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:22.206]                         if (muffled) 
[17:41:22.206]                           invokeRestart("muffleWarning")
[17:41:22.206]                       }
[17:41:22.206]                       else if (inherits(cond, "condition")) {
[17:41:22.206]                         if (!is.null(pattern)) {
[17:41:22.206]                           computeRestarts <- base::computeRestarts
[17:41:22.206]                           grepl <- base::grepl
[17:41:22.206]                           restarts <- computeRestarts(cond)
[17:41:22.206]                           for (restart in restarts) {
[17:41:22.206]                             name <- restart$name
[17:41:22.206]                             if (is.null(name)) 
[17:41:22.206]                               next
[17:41:22.206]                             if (!grepl(pattern, name)) 
[17:41:22.206]                               next
[17:41:22.206]                             invokeRestart(restart)
[17:41:22.206]                             muffled <- TRUE
[17:41:22.206]                             break
[17:41:22.206]                           }
[17:41:22.206]                         }
[17:41:22.206]                       }
[17:41:22.206]                       invisible(muffled)
[17:41:22.206]                     }
[17:41:22.206]                     muffleCondition(cond, pattern = "^muffle")
[17:41:22.206]                   }
[17:41:22.206]                 }
[17:41:22.206]             }
[17:41:22.206]         }))
[17:41:22.206]     }, error = function(ex) {
[17:41:22.206]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:22.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:22.206]                 ...future.rng), started = ...future.startTime, 
[17:41:22.206]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:22.206]             version = "1.8"), class = "FutureResult")
[17:41:22.206]     }, finally = {
[17:41:22.206]         if (!identical(...future.workdir, getwd())) 
[17:41:22.206]             setwd(...future.workdir)
[17:41:22.206]         {
[17:41:22.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:22.206]                 ...future.oldOptions$nwarnings <- NULL
[17:41:22.206]             }
[17:41:22.206]             base::options(...future.oldOptions)
[17:41:22.206]             if (.Platform$OS.type == "windows") {
[17:41:22.206]                 old_names <- names(...future.oldEnvVars)
[17:41:22.206]                 envs <- base::Sys.getenv()
[17:41:22.206]                 names <- names(envs)
[17:41:22.206]                 common <- intersect(names, old_names)
[17:41:22.206]                 added <- setdiff(names, old_names)
[17:41:22.206]                 removed <- setdiff(old_names, names)
[17:41:22.206]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:22.206]                   envs[common]]
[17:41:22.206]                 NAMES <- toupper(changed)
[17:41:22.206]                 args <- list()
[17:41:22.206]                 for (kk in seq_along(NAMES)) {
[17:41:22.206]                   name <- changed[[kk]]
[17:41:22.206]                   NAME <- NAMES[[kk]]
[17:41:22.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.206]                     next
[17:41:22.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:22.206]                 }
[17:41:22.206]                 NAMES <- toupper(added)
[17:41:22.206]                 for (kk in seq_along(NAMES)) {
[17:41:22.206]                   name <- added[[kk]]
[17:41:22.206]                   NAME <- NAMES[[kk]]
[17:41:22.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.206]                     next
[17:41:22.206]                   args[[name]] <- ""
[17:41:22.206]                 }
[17:41:22.206]                 NAMES <- toupper(removed)
[17:41:22.206]                 for (kk in seq_along(NAMES)) {
[17:41:22.206]                   name <- removed[[kk]]
[17:41:22.206]                   NAME <- NAMES[[kk]]
[17:41:22.206]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.206]                     next
[17:41:22.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:22.206]                 }
[17:41:22.206]                 if (length(args) > 0) 
[17:41:22.206]                   base::do.call(base::Sys.setenv, args = args)
[17:41:22.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:22.206]             }
[17:41:22.206]             else {
[17:41:22.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:22.206]             }
[17:41:22.206]             {
[17:41:22.206]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:22.206]                   0L) {
[17:41:22.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:22.206]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:22.206]                   base::options(opts)
[17:41:22.206]                 }
[17:41:22.206]                 {
[17:41:22.206]                   {
[17:41:22.206]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:22.206]                     NULL
[17:41:22.206]                   }
[17:41:22.206]                   options(future.plan = NULL)
[17:41:22.206]                   if (is.na(NA_character_)) 
[17:41:22.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:22.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:22.206]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:22.206]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:22.206]                     envir = parent.frame()) 
[17:41:22.206]                   {
[17:41:22.206]                     if (is.function(workers)) 
[17:41:22.206]                       workers <- workers()
[17:41:22.206]                     workers <- structure(as.integer(workers), 
[17:41:22.206]                       class = class(workers))
[17:41:22.206]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:22.206]                       workers >= 1)
[17:41:22.206]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:22.206]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:22.206]                     }
[17:41:22.206]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:22.206]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:22.206]                       envir = envir)
[17:41:22.206]                     if (!future$lazy) 
[17:41:22.206]                       future <- run(future)
[17:41:22.206]                     invisible(future)
[17:41:22.206]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:22.206]                 }
[17:41:22.206]             }
[17:41:22.206]         }
[17:41:22.206]     })
[17:41:22.206]     if (TRUE) {
[17:41:22.206]         base::sink(type = "output", split = FALSE)
[17:41:22.206]         if (TRUE) {
[17:41:22.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:22.206]         }
[17:41:22.206]         else {
[17:41:22.206]             ...future.result["stdout"] <- base::list(NULL)
[17:41:22.206]         }
[17:41:22.206]         base::close(...future.stdout)
[17:41:22.206]         ...future.stdout <- NULL
[17:41:22.206]     }
[17:41:22.206]     ...future.result$conditions <- ...future.conditions
[17:41:22.206]     ...future.result$finished <- base::Sys.time()
[17:41:22.206]     ...future.result
[17:41:22.206] }
[17:41:22.209] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:41:22.209] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:41:22.209] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:41:22.209] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:41:22.209] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:41:22.210] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:41:22.210] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:41:22.210] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:22.210] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:22.210] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:22.211] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:22.211] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:41:22.211] MultisessionFuture started
[17:41:22.211] - Launch lazy future ... done
[17:41:22.212] run() for ‘MultisessionFuture’ ... done
[17:41:22.212] Created future:
[17:41:22.212] MultisessionFuture:
[17:41:22.212] Label: ‘future_mapply-2’
[17:41:22.212] Expression:
[17:41:22.212] {
[17:41:22.212]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:22.212]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:22.212]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:22.212]         on.exit(options(oopts), add = TRUE)
[17:41:22.212]     }
[17:41:22.212]     {
[17:41:22.212]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:22.212]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:22.212]         do.call(mapply, args = args)
[17:41:22.212]     }
[17:41:22.212] }
[17:41:22.212] Lazy evaluation: FALSE
[17:41:22.212] Asynchronous evaluation: TRUE
[17:41:22.212] Local evaluation: TRUE
[17:41:22.212] Environment: R_GlobalEnv
[17:41:22.212] Capture standard output: TRUE
[17:41:22.212] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:22.212] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:22.212] Packages: <none>
[17:41:22.212] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:22.212] Resolved: FALSE
[17:41:22.212] Value: <not collected>
[17:41:22.212] Conditions captured: <none>
[17:41:22.212] Early signaling: FALSE
[17:41:22.212] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:22.212] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:22.223] Chunk #2 of 2 ... DONE
[17:41:22.223] Launching 2 futures (chunks) ... DONE
[17:41:22.223] Resolving 2 futures (chunks) ...
[17:41:22.223] resolve() on list ...
[17:41:22.224]  recursive: 0
[17:41:22.224]  length: 2
[17:41:22.224] 
[17:41:22.266] receiveMessageFromWorker() for ClusterFuture ...
[17:41:22.266] - Validating connection of MultisessionFuture
[17:41:22.266] - received message: FutureResult
[17:41:22.266] - Received FutureResult
[17:41:22.266] - Erased future from FutureRegistry
[17:41:22.267] result() for ClusterFuture ...
[17:41:22.267] - result already collected: FutureResult
[17:41:22.267] result() for ClusterFuture ... done
[17:41:22.267] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:22.267] Future #2
[17:41:22.267] result() for ClusterFuture ...
[17:41:22.267] - result already collected: FutureResult
[17:41:22.267] result() for ClusterFuture ... done
[17:41:22.267] result() for ClusterFuture ...
[17:41:22.267] - result already collected: FutureResult
[17:41:22.267] result() for ClusterFuture ... done
[17:41:22.268] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:22.268] - nx: 2
[17:41:22.268] - relay: TRUE
[17:41:22.268] - stdout: TRUE
[17:41:22.268] - signal: TRUE
[17:41:22.268] - resignal: FALSE
[17:41:22.268] - force: TRUE
[17:41:22.268] - relayed: [n=2] FALSE, FALSE
[17:41:22.268] - queued futures: [n=2] FALSE, FALSE
[17:41:22.268]  - until=1
[17:41:22.268]  - relaying element #1
[17:41:22.269] - relayed: [n=2] FALSE, FALSE
[17:41:22.269] - queued futures: [n=2] FALSE, TRUE
[17:41:22.269] signalConditionsASAP(NULL, pos=2) ... done
[17:41:22.269]  length: 1 (resolved future 2)
[17:41:22.717] receiveMessageFromWorker() for ClusterFuture ...
[17:41:22.717] - Validating connection of MultisessionFuture
[17:41:22.718] - received message: FutureResult
[17:41:22.718] - Received FutureResult
[17:41:22.718] - Erased future from FutureRegistry
[17:41:22.718] result() for ClusterFuture ...
[17:41:22.718] - result already collected: FutureResult
[17:41:22.718] result() for ClusterFuture ... done
[17:41:22.718] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:22.718] Future #1
[17:41:22.718] result() for ClusterFuture ...
[17:41:22.719] - result already collected: FutureResult
[17:41:22.719] result() for ClusterFuture ... done
[17:41:22.719] result() for ClusterFuture ...
[17:41:22.719] - result already collected: FutureResult
[17:41:22.719] result() for ClusterFuture ... done
[17:41:22.719] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:22.719] - nx: 2
[17:41:22.719] - relay: TRUE
[17:41:22.719] - stdout: TRUE
[17:41:22.719] - signal: TRUE
[17:41:22.720] - resignal: FALSE
[17:41:22.720] - force: TRUE
[17:41:22.720] - relayed: [n=2] FALSE, FALSE
[17:41:22.720] - queued futures: [n=2] FALSE, TRUE
[17:41:22.720]  - until=1
[17:41:22.720]  - relaying element #1
[17:41:22.720] result() for ClusterFuture ...
[17:41:22.720] - result already collected: FutureResult
[17:41:22.720] result() for ClusterFuture ... done
[17:41:22.720] result() for ClusterFuture ...
[17:41:22.720] - result already collected: FutureResult
[17:41:22.720] result() for ClusterFuture ... done
[17:41:22.721] result() for ClusterFuture ...
[17:41:22.721] - result already collected: FutureResult
[17:41:22.721] result() for ClusterFuture ... done
[17:41:22.721] result() for ClusterFuture ...
[17:41:22.721] - result already collected: FutureResult
[17:41:22.721] result() for ClusterFuture ... done
[17:41:22.721] - relayed: [n=2] TRUE, FALSE
[17:41:22.721] - queued futures: [n=2] TRUE, TRUE
[17:41:22.721] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:22.721]  length: 0 (resolved future 1)
[17:41:22.722] Relaying remaining futures
[17:41:22.722] signalConditionsASAP(NULL, pos=0) ...
[17:41:22.722] - nx: 2
[17:41:22.722] - relay: TRUE
[17:41:22.722] - stdout: TRUE
[17:41:22.722] - signal: TRUE
[17:41:22.722] - resignal: FALSE
[17:41:22.722] - force: TRUE
[17:41:22.722] - relayed: [n=2] TRUE, FALSE
[17:41:22.722] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:22.722]  - relaying element #2
[17:41:22.723] result() for ClusterFuture ...
[17:41:22.723] - result already collected: FutureResult
[17:41:22.723] result() for ClusterFuture ... done
[17:41:22.723] result() for ClusterFuture ...
[17:41:22.723] - result already collected: FutureResult
[17:41:22.723] result() for ClusterFuture ... done
[17:41:22.723] result() for ClusterFuture ...
[17:41:22.723] - result already collected: FutureResult
[17:41:22.723] result() for ClusterFuture ... done
[17:41:22.723] result() for ClusterFuture ...
[17:41:22.724] - result already collected: FutureResult
[17:41:22.724] result() for ClusterFuture ... done
[17:41:22.724] - relayed: [n=2] TRUE, TRUE
[17:41:22.724] - queued futures: [n=2] TRUE, TRUE
[17:41:22.724] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:41:22.724] resolve() on list ... DONE
[17:41:22.724] result() for ClusterFuture ...
[17:41:22.724] - result already collected: FutureResult
[17:41:22.724] result() for ClusterFuture ... done
[17:41:22.724] result() for ClusterFuture ...
[17:41:22.724] - result already collected: FutureResult
[17:41:22.724] result() for ClusterFuture ... done
[17:41:22.725] result() for ClusterFuture ...
[17:41:22.725] - result already collected: FutureResult
[17:41:22.725] result() for ClusterFuture ... done
[17:41:22.725] result() for ClusterFuture ...
[17:41:22.725] - result already collected: FutureResult
[17:41:22.725] result() for ClusterFuture ... done
[17:41:22.725]  - Number of value chunks collected: 2
[17:41:22.725] Resolving 2 futures (chunks) ... DONE
[17:41:22.725] Reducing values from 2 chunks ...
[17:41:22.725]  - Number of values collected after concatenation: 2
[17:41:22.725]  - Number of values expected: 2
[17:41:22.726] Reducing values from 2 chunks ... DONE
[17:41:22.726] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:41:22.726] future_mapply() ...
[17:41:22.730] Number of chunks: 2
[17:41:22.730] getGlobalsAndPackagesXApply() ...
[17:41:22.730]  - future.globals: TRUE
[17:41:22.730] getGlobalsAndPackages() ...
[17:41:22.730] Searching for globals...
[17:41:22.732] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:41:22.732] Searching for globals ... DONE
[17:41:22.732] Resolving globals: FALSE
[17:41:22.732] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:41:22.733] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:41:22.733] - globals: [1] ‘FUN’
[17:41:22.733] 
[17:41:22.733] getGlobalsAndPackages() ... DONE
[17:41:22.733]  - globals found/used: [n=1] ‘FUN’
[17:41:22.733]  - needed namespaces: [n=0] 
[17:41:22.733] Finding globals ... DONE
[17:41:22.733] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:41:22.733] List of 2
[17:41:22.733]  $ ...future.FUN:function (x, y)  
[17:41:22.733]  $ MoreArgs     : NULL
[17:41:22.733]  - attr(*, "where")=List of 2
[17:41:22.733]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:41:22.733]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:41:22.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:41:22.733]  - attr(*, "resolved")= logi FALSE
[17:41:22.733]  - attr(*, "total_size")= num NA
[17:41:22.736] Packages to be attached in all futures: [n=0] 
[17:41:22.736] getGlobalsAndPackagesXApply() ... DONE
[17:41:22.736] Number of futures (= number of chunks): 2
[17:41:22.736] Launching 2 futures (chunks) ...
[17:41:22.736] Chunk #1 of 2 ...
[17:41:22.737]  - Finding globals in '...' for chunk #1 ...
[17:41:22.737] getGlobalsAndPackages() ...
[17:41:22.737] Searching for globals...
[17:41:22.737] 
[17:41:22.737] Searching for globals ... DONE
[17:41:22.737] - globals: [0] <none>
[17:41:22.737] getGlobalsAndPackages() ... DONE
[17:41:22.737]    + additional globals found: [n=0] 
[17:41:22.738]    + additional namespaces needed: [n=0] 
[17:41:22.738]  - Finding globals in '...' for chunk #1 ... DONE
[17:41:22.738]  - seeds: <none>
[17:41:22.738] getGlobalsAndPackages() ...
[17:41:22.738] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:22.738] Resolving globals: FALSE
[17:41:22.738] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:22.739] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:22.739] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:22.739] 
[17:41:22.739] getGlobalsAndPackages() ... DONE
[17:41:22.739] run() for ‘Future’ ...
[17:41:22.740] - state: ‘created’
[17:41:22.740] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:22.754] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:22.754] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:22.754]   - Field: ‘node’
[17:41:22.754]   - Field: ‘label’
[17:41:22.754]   - Field: ‘local’
[17:41:22.755]   - Field: ‘owner’
[17:41:22.755]   - Field: ‘envir’
[17:41:22.755]   - Field: ‘workers’
[17:41:22.755]   - Field: ‘packages’
[17:41:22.755]   - Field: ‘gc’
[17:41:22.755]   - Field: ‘conditions’
[17:41:22.755]   - Field: ‘persistent’
[17:41:22.755]   - Field: ‘expr’
[17:41:22.755]   - Field: ‘uuid’
[17:41:22.755]   - Field: ‘seed’
[17:41:22.755]   - Field: ‘version’
[17:41:22.756]   - Field: ‘result’
[17:41:22.756]   - Field: ‘asynchronous’
[17:41:22.756]   - Field: ‘calls’
[17:41:22.756]   - Field: ‘globals’
[17:41:22.756]   - Field: ‘stdout’
[17:41:22.756]   - Field: ‘earlySignal’
[17:41:22.756]   - Field: ‘lazy’
[17:41:22.756]   - Field: ‘state’
[17:41:22.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:22.756] - Launch lazy future ...
[17:41:22.757] Packages needed by the future expression (n = 0): <none>
[17:41:22.757] Packages needed by future strategies (n = 0): <none>
[17:41:22.757] {
[17:41:22.757]     {
[17:41:22.757]         {
[17:41:22.757]             ...future.startTime <- base::Sys.time()
[17:41:22.757]             {
[17:41:22.757]                 {
[17:41:22.757]                   {
[17:41:22.757]                     {
[17:41:22.757]                       base::local({
[17:41:22.757]                         has_future <- base::requireNamespace("future", 
[17:41:22.757]                           quietly = TRUE)
[17:41:22.757]                         if (has_future) {
[17:41:22.757]                           ns <- base::getNamespace("future")
[17:41:22.757]                           version <- ns[[".package"]][["version"]]
[17:41:22.757]                           if (is.null(version)) 
[17:41:22.757]                             version <- utils::packageVersion("future")
[17:41:22.757]                         }
[17:41:22.757]                         else {
[17:41:22.757]                           version <- NULL
[17:41:22.757]                         }
[17:41:22.757]                         if (!has_future || version < "1.8.0") {
[17:41:22.757]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:22.757]                             "", base::R.version$version.string), 
[17:41:22.757]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:22.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:22.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:22.757]                               "release", "version")], collapse = " "), 
[17:41:22.757]                             hostname = base::Sys.info()[["nodename"]])
[17:41:22.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:22.757]                             info)
[17:41:22.757]                           info <- base::paste(info, collapse = "; ")
[17:41:22.757]                           if (!has_future) {
[17:41:22.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:22.757]                               info)
[17:41:22.757]                           }
[17:41:22.757]                           else {
[17:41:22.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:22.757]                               info, version)
[17:41:22.757]                           }
[17:41:22.757]                           base::stop(msg)
[17:41:22.757]                         }
[17:41:22.757]                       })
[17:41:22.757]                     }
[17:41:22.757]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:22.757]                     base::options(mc.cores = 1L)
[17:41:22.757]                   }
[17:41:22.757]                   options(future.plan = NULL)
[17:41:22.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:22.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:22.757]                 }
[17:41:22.757]                 ...future.workdir <- getwd()
[17:41:22.757]             }
[17:41:22.757]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:22.757]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:22.757]         }
[17:41:22.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:22.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:22.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:22.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:22.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:22.757]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:22.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:22.757]             base::names(...future.oldOptions))
[17:41:22.757]     }
[17:41:22.757]     if (TRUE) {
[17:41:22.757]     }
[17:41:22.757]     else {
[17:41:22.757]         if (NA) {
[17:41:22.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:22.757]                 open = "w")
[17:41:22.757]         }
[17:41:22.757]         else {
[17:41:22.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:22.757]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:22.757]         }
[17:41:22.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:22.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:22.757]             base::sink(type = "output", split = FALSE)
[17:41:22.757]             base::close(...future.stdout)
[17:41:22.757]         }, add = TRUE)
[17:41:22.757]     }
[17:41:22.757]     ...future.frame <- base::sys.nframe()
[17:41:22.757]     ...future.conditions <- base::list()
[17:41:22.757]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:22.757]     if (FALSE) {
[17:41:22.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:22.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:22.757]     }
[17:41:22.757]     ...future.result <- base::tryCatch({
[17:41:22.757]         base::withCallingHandlers({
[17:41:22.757]             ...future.value <- base::withVisible(base::local({
[17:41:22.757]                 ...future.makeSendCondition <- local({
[17:41:22.757]                   sendCondition <- NULL
[17:41:22.757]                   function(frame = 1L) {
[17:41:22.757]                     if (is.function(sendCondition)) 
[17:41:22.757]                       return(sendCondition)
[17:41:22.757]                     ns <- getNamespace("parallel")
[17:41:22.757]                     if (exists("sendData", mode = "function", 
[17:41:22.757]                       envir = ns)) {
[17:41:22.757]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:22.757]                         envir = ns)
[17:41:22.757]                       envir <- sys.frame(frame)
[17:41:22.757]                       master <- NULL
[17:41:22.757]                       while (!identical(envir, .GlobalEnv) && 
[17:41:22.757]                         !identical(envir, emptyenv())) {
[17:41:22.757]                         if (exists("master", mode = "list", envir = envir, 
[17:41:22.757]                           inherits = FALSE)) {
[17:41:22.757]                           master <- get("master", mode = "list", 
[17:41:22.757]                             envir = envir, inherits = FALSE)
[17:41:22.757]                           if (inherits(master, c("SOCKnode", 
[17:41:22.757]                             "SOCK0node"))) {
[17:41:22.757]                             sendCondition <<- function(cond) {
[17:41:22.757]                               data <- list(type = "VALUE", value = cond, 
[17:41:22.757]                                 success = TRUE)
[17:41:22.757]                               parallel_sendData(master, data)
[17:41:22.757]                             }
[17:41:22.757]                             return(sendCondition)
[17:41:22.757]                           }
[17:41:22.757]                         }
[17:41:22.757]                         frame <- frame + 1L
[17:41:22.757]                         envir <- sys.frame(frame)
[17:41:22.757]                       }
[17:41:22.757]                     }
[17:41:22.757]                     sendCondition <<- function(cond) NULL
[17:41:22.757]                   }
[17:41:22.757]                 })
[17:41:22.757]                 withCallingHandlers({
[17:41:22.757]                   {
[17:41:22.757]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:22.757]                     if (!identical(...future.globals.maxSize.org, 
[17:41:22.757]                       ...future.globals.maxSize)) {
[17:41:22.757]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:22.757]                       on.exit(options(oopts), add = TRUE)
[17:41:22.757]                     }
[17:41:22.757]                     {
[17:41:22.757]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:22.757]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:22.757]                         USE.NAMES = FALSE)
[17:41:22.757]                       do.call(mapply, args = args)
[17:41:22.757]                     }
[17:41:22.757]                   }
[17:41:22.757]                 }, immediateCondition = function(cond) {
[17:41:22.757]                   sendCondition <- ...future.makeSendCondition()
[17:41:22.757]                   sendCondition(cond)
[17:41:22.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.757]                   {
[17:41:22.757]                     inherits <- base::inherits
[17:41:22.757]                     invokeRestart <- base::invokeRestart
[17:41:22.757]                     is.null <- base::is.null
[17:41:22.757]                     muffled <- FALSE
[17:41:22.757]                     if (inherits(cond, "message")) {
[17:41:22.757]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:22.757]                       if (muffled) 
[17:41:22.757]                         invokeRestart("muffleMessage")
[17:41:22.757]                     }
[17:41:22.757]                     else if (inherits(cond, "warning")) {
[17:41:22.757]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:22.757]                       if (muffled) 
[17:41:22.757]                         invokeRestart("muffleWarning")
[17:41:22.757]                     }
[17:41:22.757]                     else if (inherits(cond, "condition")) {
[17:41:22.757]                       if (!is.null(pattern)) {
[17:41:22.757]                         computeRestarts <- base::computeRestarts
[17:41:22.757]                         grepl <- base::grepl
[17:41:22.757]                         restarts <- computeRestarts(cond)
[17:41:22.757]                         for (restart in restarts) {
[17:41:22.757]                           name <- restart$name
[17:41:22.757]                           if (is.null(name)) 
[17:41:22.757]                             next
[17:41:22.757]                           if (!grepl(pattern, name)) 
[17:41:22.757]                             next
[17:41:22.757]                           invokeRestart(restart)
[17:41:22.757]                           muffled <- TRUE
[17:41:22.757]                           break
[17:41:22.757]                         }
[17:41:22.757]                       }
[17:41:22.757]                     }
[17:41:22.757]                     invisible(muffled)
[17:41:22.757]                   }
[17:41:22.757]                   muffleCondition(cond)
[17:41:22.757]                 })
[17:41:22.757]             }))
[17:41:22.757]             future::FutureResult(value = ...future.value$value, 
[17:41:22.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:22.757]                   ...future.rng), globalenv = if (FALSE) 
[17:41:22.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:22.757]                     ...future.globalenv.names))
[17:41:22.757]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:22.757]         }, condition = base::local({
[17:41:22.757]             c <- base::c
[17:41:22.757]             inherits <- base::inherits
[17:41:22.757]             invokeRestart <- base::invokeRestart
[17:41:22.757]             length <- base::length
[17:41:22.757]             list <- base::list
[17:41:22.757]             seq.int <- base::seq.int
[17:41:22.757]             signalCondition <- base::signalCondition
[17:41:22.757]             sys.calls <- base::sys.calls
[17:41:22.757]             `[[` <- base::`[[`
[17:41:22.757]             `+` <- base::`+`
[17:41:22.757]             `<<-` <- base::`<<-`
[17:41:22.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:22.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:22.757]                   3L)]
[17:41:22.757]             }
[17:41:22.757]             function(cond) {
[17:41:22.757]                 is_error <- inherits(cond, "error")
[17:41:22.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:22.757]                   NULL)
[17:41:22.757]                 if (is_error) {
[17:41:22.757]                   sessionInformation <- function() {
[17:41:22.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:22.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:22.757]                       search = base::search(), system = base::Sys.info())
[17:41:22.757]                   }
[17:41:22.757]                   ...future.conditions[[length(...future.conditions) + 
[17:41:22.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:22.757]                     cond$call), session = sessionInformation(), 
[17:41:22.757]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:22.757]                   signalCondition(cond)
[17:41:22.757]                 }
[17:41:22.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:22.757]                 "immediateCondition"))) {
[17:41:22.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:22.757]                   ...future.conditions[[length(...future.conditions) + 
[17:41:22.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:22.757]                   if (TRUE && !signal) {
[17:41:22.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.757]                     {
[17:41:22.757]                       inherits <- base::inherits
[17:41:22.757]                       invokeRestart <- base::invokeRestart
[17:41:22.757]                       is.null <- base::is.null
[17:41:22.757]                       muffled <- FALSE
[17:41:22.757]                       if (inherits(cond, "message")) {
[17:41:22.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:22.757]                         if (muffled) 
[17:41:22.757]                           invokeRestart("muffleMessage")
[17:41:22.757]                       }
[17:41:22.757]                       else if (inherits(cond, "warning")) {
[17:41:22.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:22.757]                         if (muffled) 
[17:41:22.757]                           invokeRestart("muffleWarning")
[17:41:22.757]                       }
[17:41:22.757]                       else if (inherits(cond, "condition")) {
[17:41:22.757]                         if (!is.null(pattern)) {
[17:41:22.757]                           computeRestarts <- base::computeRestarts
[17:41:22.757]                           grepl <- base::grepl
[17:41:22.757]                           restarts <- computeRestarts(cond)
[17:41:22.757]                           for (restart in restarts) {
[17:41:22.757]                             name <- restart$name
[17:41:22.757]                             if (is.null(name)) 
[17:41:22.757]                               next
[17:41:22.757]                             if (!grepl(pattern, name)) 
[17:41:22.757]                               next
[17:41:22.757]                             invokeRestart(restart)
[17:41:22.757]                             muffled <- TRUE
[17:41:22.757]                             break
[17:41:22.757]                           }
[17:41:22.757]                         }
[17:41:22.757]                       }
[17:41:22.757]                       invisible(muffled)
[17:41:22.757]                     }
[17:41:22.757]                     muffleCondition(cond, pattern = "^muffle")
[17:41:22.757]                   }
[17:41:22.757]                 }
[17:41:22.757]                 else {
[17:41:22.757]                   if (TRUE) {
[17:41:22.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.757]                     {
[17:41:22.757]                       inherits <- base::inherits
[17:41:22.757]                       invokeRestart <- base::invokeRestart
[17:41:22.757]                       is.null <- base::is.null
[17:41:22.757]                       muffled <- FALSE
[17:41:22.757]                       if (inherits(cond, "message")) {
[17:41:22.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:22.757]                         if (muffled) 
[17:41:22.757]                           invokeRestart("muffleMessage")
[17:41:22.757]                       }
[17:41:22.757]                       else if (inherits(cond, "warning")) {
[17:41:22.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:22.757]                         if (muffled) 
[17:41:22.757]                           invokeRestart("muffleWarning")
[17:41:22.757]                       }
[17:41:22.757]                       else if (inherits(cond, "condition")) {
[17:41:22.757]                         if (!is.null(pattern)) {
[17:41:22.757]                           computeRestarts <- base::computeRestarts
[17:41:22.757]                           grepl <- base::grepl
[17:41:22.757]                           restarts <- computeRestarts(cond)
[17:41:22.757]                           for (restart in restarts) {
[17:41:22.757]                             name <- restart$name
[17:41:22.757]                             if (is.null(name)) 
[17:41:22.757]                               next
[17:41:22.757]                             if (!grepl(pattern, name)) 
[17:41:22.757]                               next
[17:41:22.757]                             invokeRestart(restart)
[17:41:22.757]                             muffled <- TRUE
[17:41:22.757]                             break
[17:41:22.757]                           }
[17:41:22.757]                         }
[17:41:22.757]                       }
[17:41:22.757]                       invisible(muffled)
[17:41:22.757]                     }
[17:41:22.757]                     muffleCondition(cond, pattern = "^muffle")
[17:41:22.757]                   }
[17:41:22.757]                 }
[17:41:22.757]             }
[17:41:22.757]         }))
[17:41:22.757]     }, error = function(ex) {
[17:41:22.757]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:22.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:22.757]                 ...future.rng), started = ...future.startTime, 
[17:41:22.757]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:22.757]             version = "1.8"), class = "FutureResult")
[17:41:22.757]     }, finally = {
[17:41:22.757]         if (!identical(...future.workdir, getwd())) 
[17:41:22.757]             setwd(...future.workdir)
[17:41:22.757]         {
[17:41:22.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:22.757]                 ...future.oldOptions$nwarnings <- NULL
[17:41:22.757]             }
[17:41:22.757]             base::options(...future.oldOptions)
[17:41:22.757]             if (.Platform$OS.type == "windows") {
[17:41:22.757]                 old_names <- names(...future.oldEnvVars)
[17:41:22.757]                 envs <- base::Sys.getenv()
[17:41:22.757]                 names <- names(envs)
[17:41:22.757]                 common <- intersect(names, old_names)
[17:41:22.757]                 added <- setdiff(names, old_names)
[17:41:22.757]                 removed <- setdiff(old_names, names)
[17:41:22.757]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:22.757]                   envs[common]]
[17:41:22.757]                 NAMES <- toupper(changed)
[17:41:22.757]                 args <- list()
[17:41:22.757]                 for (kk in seq_along(NAMES)) {
[17:41:22.757]                   name <- changed[[kk]]
[17:41:22.757]                   NAME <- NAMES[[kk]]
[17:41:22.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.757]                     next
[17:41:22.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:22.757]                 }
[17:41:22.757]                 NAMES <- toupper(added)
[17:41:22.757]                 for (kk in seq_along(NAMES)) {
[17:41:22.757]                   name <- added[[kk]]
[17:41:22.757]                   NAME <- NAMES[[kk]]
[17:41:22.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.757]                     next
[17:41:22.757]                   args[[name]] <- ""
[17:41:22.757]                 }
[17:41:22.757]                 NAMES <- toupper(removed)
[17:41:22.757]                 for (kk in seq_along(NAMES)) {
[17:41:22.757]                   name <- removed[[kk]]
[17:41:22.757]                   NAME <- NAMES[[kk]]
[17:41:22.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.757]                     next
[17:41:22.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:22.757]                 }
[17:41:22.757]                 if (length(args) > 0) 
[17:41:22.757]                   base::do.call(base::Sys.setenv, args = args)
[17:41:22.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:22.757]             }
[17:41:22.757]             else {
[17:41:22.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:22.757]             }
[17:41:22.757]             {
[17:41:22.757]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:22.757]                   0L) {
[17:41:22.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:22.757]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:22.757]                   base::options(opts)
[17:41:22.757]                 }
[17:41:22.757]                 {
[17:41:22.757]                   {
[17:41:22.757]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:22.757]                     NULL
[17:41:22.757]                   }
[17:41:22.757]                   options(future.plan = NULL)
[17:41:22.757]                   if (is.na(NA_character_)) 
[17:41:22.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:22.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:22.757]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:22.757]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:22.757]                     envir = parent.frame()) 
[17:41:22.757]                   {
[17:41:22.757]                     if (is.function(workers)) 
[17:41:22.757]                       workers <- workers()
[17:41:22.757]                     workers <- structure(as.integer(workers), 
[17:41:22.757]                       class = class(workers))
[17:41:22.757]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:22.757]                       workers >= 1)
[17:41:22.757]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:22.757]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:22.757]                     }
[17:41:22.757]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:22.757]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:22.757]                       envir = envir)
[17:41:22.757]                     if (!future$lazy) 
[17:41:22.757]                       future <- run(future)
[17:41:22.757]                     invisible(future)
[17:41:22.757]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:22.757]                 }
[17:41:22.757]             }
[17:41:22.757]         }
[17:41:22.757]     })
[17:41:22.757]     if (FALSE) {
[17:41:22.757]         base::sink(type = "output", split = FALSE)
[17:41:22.757]         if (NA) {
[17:41:22.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:22.757]         }
[17:41:22.757]         else {
[17:41:22.757]             ...future.result["stdout"] <- base::list(NULL)
[17:41:22.757]         }
[17:41:22.757]         base::close(...future.stdout)
[17:41:22.757]         ...future.stdout <- NULL
[17:41:22.757]     }
[17:41:22.757]     ...future.result$conditions <- ...future.conditions
[17:41:22.757]     ...future.result$finished <- base::Sys.time()
[17:41:22.757]     ...future.result
[17:41:22.757] }
[17:41:22.760] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:41:22.760] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:41:22.760] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:41:22.761] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:41:22.761] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:41:22.761] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:41:22.761] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:41:22.762] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:41:22.762] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:41:22.762] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:41:22.762] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:41:22.762] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:41:22.763] MultisessionFuture started
[17:41:22.763] - Launch lazy future ... done
[17:41:22.763] run() for ‘MultisessionFuture’ ... done
[17:41:22.763] Created future:
[17:41:22.763] MultisessionFuture:
[17:41:22.763] Label: ‘future_mapply-1’
[17:41:22.763] Expression:
[17:41:22.763] {
[17:41:22.763]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:22.763]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:22.763]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:22.763]         on.exit(options(oopts), add = TRUE)
[17:41:22.763]     }
[17:41:22.763]     {
[17:41:22.763]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:22.763]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:22.763]         do.call(mapply, args = args)
[17:41:22.763]     }
[17:41:22.763] }
[17:41:22.763] Lazy evaluation: FALSE
[17:41:22.763] Asynchronous evaluation: TRUE
[17:41:22.763] Local evaluation: TRUE
[17:41:22.763] Environment: R_GlobalEnv
[17:41:22.763] Capture standard output: NA
[17:41:22.763] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:22.763] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:22.763] Packages: <none>
[17:41:22.763] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:22.763] Resolved: FALSE
[17:41:22.763] Value: <not collected>
[17:41:22.763] Conditions captured: <none>
[17:41:22.763] Early signaling: FALSE
[17:41:22.763] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:22.763] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:22.775] Chunk #1 of 2 ... DONE
[17:41:22.775] Chunk #2 of 2 ...
[17:41:22.775]  - Finding globals in '...' for chunk #2 ...
[17:41:22.775] getGlobalsAndPackages() ...
[17:41:22.775] Searching for globals...
[17:41:22.776] 
[17:41:22.776] Searching for globals ... DONE
[17:41:22.776] - globals: [0] <none>
[17:41:22.776] getGlobalsAndPackages() ... DONE
[17:41:22.776]    + additional globals found: [n=0] 
[17:41:22.776]    + additional namespaces needed: [n=0] 
[17:41:22.776]  - Finding globals in '...' for chunk #2 ... DONE
[17:41:22.776]  - seeds: <none>
[17:41:22.776] getGlobalsAndPackages() ...
[17:41:22.776] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:22.777] Resolving globals: FALSE
[17:41:22.777] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:41:22.778] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:41:22.778] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:41:22.778] 
[17:41:22.778] getGlobalsAndPackages() ... DONE
[17:41:22.778] run() for ‘Future’ ...
[17:41:22.778] - state: ‘created’
[17:41:22.778] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:22.793] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:22.793] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:22.793]   - Field: ‘node’
[17:41:22.793]   - Field: ‘label’
[17:41:22.793]   - Field: ‘local’
[17:41:22.793]   - Field: ‘owner’
[17:41:22.793]   - Field: ‘envir’
[17:41:22.793]   - Field: ‘workers’
[17:41:22.794]   - Field: ‘packages’
[17:41:22.794]   - Field: ‘gc’
[17:41:22.794]   - Field: ‘conditions’
[17:41:22.794]   - Field: ‘persistent’
[17:41:22.794]   - Field: ‘expr’
[17:41:22.794]   - Field: ‘uuid’
[17:41:22.794]   - Field: ‘seed’
[17:41:22.794]   - Field: ‘version’
[17:41:22.794]   - Field: ‘result’
[17:41:22.794]   - Field: ‘asynchronous’
[17:41:22.795]   - Field: ‘calls’
[17:41:22.795]   - Field: ‘globals’
[17:41:22.795]   - Field: ‘stdout’
[17:41:22.795]   - Field: ‘earlySignal’
[17:41:22.795]   - Field: ‘lazy’
[17:41:22.795]   - Field: ‘state’
[17:41:22.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:22.795] - Launch lazy future ...
[17:41:22.796] Packages needed by the future expression (n = 0): <none>
[17:41:22.796] Packages needed by future strategies (n = 0): <none>
[17:41:22.796] {
[17:41:22.796]     {
[17:41:22.796]         {
[17:41:22.796]             ...future.startTime <- base::Sys.time()
[17:41:22.796]             {
[17:41:22.796]                 {
[17:41:22.796]                   {
[17:41:22.796]                     {
[17:41:22.796]                       base::local({
[17:41:22.796]                         has_future <- base::requireNamespace("future", 
[17:41:22.796]                           quietly = TRUE)
[17:41:22.796]                         if (has_future) {
[17:41:22.796]                           ns <- base::getNamespace("future")
[17:41:22.796]                           version <- ns[[".package"]][["version"]]
[17:41:22.796]                           if (is.null(version)) 
[17:41:22.796]                             version <- utils::packageVersion("future")
[17:41:22.796]                         }
[17:41:22.796]                         else {
[17:41:22.796]                           version <- NULL
[17:41:22.796]                         }
[17:41:22.796]                         if (!has_future || version < "1.8.0") {
[17:41:22.796]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:22.796]                             "", base::R.version$version.string), 
[17:41:22.796]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:22.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:22.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:22.796]                               "release", "version")], collapse = " "), 
[17:41:22.796]                             hostname = base::Sys.info()[["nodename"]])
[17:41:22.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:22.796]                             info)
[17:41:22.796]                           info <- base::paste(info, collapse = "; ")
[17:41:22.796]                           if (!has_future) {
[17:41:22.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:22.796]                               info)
[17:41:22.796]                           }
[17:41:22.796]                           else {
[17:41:22.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:22.796]                               info, version)
[17:41:22.796]                           }
[17:41:22.796]                           base::stop(msg)
[17:41:22.796]                         }
[17:41:22.796]                       })
[17:41:22.796]                     }
[17:41:22.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:22.796]                     base::options(mc.cores = 1L)
[17:41:22.796]                   }
[17:41:22.796]                   options(future.plan = NULL)
[17:41:22.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:22.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:22.796]                 }
[17:41:22.796]                 ...future.workdir <- getwd()
[17:41:22.796]             }
[17:41:22.796]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:22.796]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:22.796]         }
[17:41:22.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:22.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:22.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:22.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:22.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:22.796]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:22.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:22.796]             base::names(...future.oldOptions))
[17:41:22.796]     }
[17:41:22.796]     if (TRUE) {
[17:41:22.796]     }
[17:41:22.796]     else {
[17:41:22.796]         if (NA) {
[17:41:22.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:22.796]                 open = "w")
[17:41:22.796]         }
[17:41:22.796]         else {
[17:41:22.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:22.796]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:22.796]         }
[17:41:22.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:22.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:22.796]             base::sink(type = "output", split = FALSE)
[17:41:22.796]             base::close(...future.stdout)
[17:41:22.796]         }, add = TRUE)
[17:41:22.796]     }
[17:41:22.796]     ...future.frame <- base::sys.nframe()
[17:41:22.796]     ...future.conditions <- base::list()
[17:41:22.796]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:22.796]     if (FALSE) {
[17:41:22.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:22.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:22.796]     }
[17:41:22.796]     ...future.result <- base::tryCatch({
[17:41:22.796]         base::withCallingHandlers({
[17:41:22.796]             ...future.value <- base::withVisible(base::local({
[17:41:22.796]                 ...future.makeSendCondition <- local({
[17:41:22.796]                   sendCondition <- NULL
[17:41:22.796]                   function(frame = 1L) {
[17:41:22.796]                     if (is.function(sendCondition)) 
[17:41:22.796]                       return(sendCondition)
[17:41:22.796]                     ns <- getNamespace("parallel")
[17:41:22.796]                     if (exists("sendData", mode = "function", 
[17:41:22.796]                       envir = ns)) {
[17:41:22.796]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:22.796]                         envir = ns)
[17:41:22.796]                       envir <- sys.frame(frame)
[17:41:22.796]                       master <- NULL
[17:41:22.796]                       while (!identical(envir, .GlobalEnv) && 
[17:41:22.796]                         !identical(envir, emptyenv())) {
[17:41:22.796]                         if (exists("master", mode = "list", envir = envir, 
[17:41:22.796]                           inherits = FALSE)) {
[17:41:22.796]                           master <- get("master", mode = "list", 
[17:41:22.796]                             envir = envir, inherits = FALSE)
[17:41:22.796]                           if (inherits(master, c("SOCKnode", 
[17:41:22.796]                             "SOCK0node"))) {
[17:41:22.796]                             sendCondition <<- function(cond) {
[17:41:22.796]                               data <- list(type = "VALUE", value = cond, 
[17:41:22.796]                                 success = TRUE)
[17:41:22.796]                               parallel_sendData(master, data)
[17:41:22.796]                             }
[17:41:22.796]                             return(sendCondition)
[17:41:22.796]                           }
[17:41:22.796]                         }
[17:41:22.796]                         frame <- frame + 1L
[17:41:22.796]                         envir <- sys.frame(frame)
[17:41:22.796]                       }
[17:41:22.796]                     }
[17:41:22.796]                     sendCondition <<- function(cond) NULL
[17:41:22.796]                   }
[17:41:22.796]                 })
[17:41:22.796]                 withCallingHandlers({
[17:41:22.796]                   {
[17:41:22.796]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:22.796]                     if (!identical(...future.globals.maxSize.org, 
[17:41:22.796]                       ...future.globals.maxSize)) {
[17:41:22.796]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:22.796]                       on.exit(options(oopts), add = TRUE)
[17:41:22.796]                     }
[17:41:22.796]                     {
[17:41:22.796]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:22.796]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:41:22.796]                         USE.NAMES = FALSE)
[17:41:22.796]                       do.call(mapply, args = args)
[17:41:22.796]                     }
[17:41:22.796]                   }
[17:41:22.796]                 }, immediateCondition = function(cond) {
[17:41:22.796]                   sendCondition <- ...future.makeSendCondition()
[17:41:22.796]                   sendCondition(cond)
[17:41:22.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.796]                   {
[17:41:22.796]                     inherits <- base::inherits
[17:41:22.796]                     invokeRestart <- base::invokeRestart
[17:41:22.796]                     is.null <- base::is.null
[17:41:22.796]                     muffled <- FALSE
[17:41:22.796]                     if (inherits(cond, "message")) {
[17:41:22.796]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:22.796]                       if (muffled) 
[17:41:22.796]                         invokeRestart("muffleMessage")
[17:41:22.796]                     }
[17:41:22.796]                     else if (inherits(cond, "warning")) {
[17:41:22.796]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:22.796]                       if (muffled) 
[17:41:22.796]                         invokeRestart("muffleWarning")
[17:41:22.796]                     }
[17:41:22.796]                     else if (inherits(cond, "condition")) {
[17:41:22.796]                       if (!is.null(pattern)) {
[17:41:22.796]                         computeRestarts <- base::computeRestarts
[17:41:22.796]                         grepl <- base::grepl
[17:41:22.796]                         restarts <- computeRestarts(cond)
[17:41:22.796]                         for (restart in restarts) {
[17:41:22.796]                           name <- restart$name
[17:41:22.796]                           if (is.null(name)) 
[17:41:22.796]                             next
[17:41:22.796]                           if (!grepl(pattern, name)) 
[17:41:22.796]                             next
[17:41:22.796]                           invokeRestart(restart)
[17:41:22.796]                           muffled <- TRUE
[17:41:22.796]                           break
[17:41:22.796]                         }
[17:41:22.796]                       }
[17:41:22.796]                     }
[17:41:22.796]                     invisible(muffled)
[17:41:22.796]                   }
[17:41:22.796]                   muffleCondition(cond)
[17:41:22.796]                 })
[17:41:22.796]             }))
[17:41:22.796]             future::FutureResult(value = ...future.value$value, 
[17:41:22.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:22.796]                   ...future.rng), globalenv = if (FALSE) 
[17:41:22.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:22.796]                     ...future.globalenv.names))
[17:41:22.796]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:22.796]         }, condition = base::local({
[17:41:22.796]             c <- base::c
[17:41:22.796]             inherits <- base::inherits
[17:41:22.796]             invokeRestart <- base::invokeRestart
[17:41:22.796]             length <- base::length
[17:41:22.796]             list <- base::list
[17:41:22.796]             seq.int <- base::seq.int
[17:41:22.796]             signalCondition <- base::signalCondition
[17:41:22.796]             sys.calls <- base::sys.calls
[17:41:22.796]             `[[` <- base::`[[`
[17:41:22.796]             `+` <- base::`+`
[17:41:22.796]             `<<-` <- base::`<<-`
[17:41:22.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:22.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:22.796]                   3L)]
[17:41:22.796]             }
[17:41:22.796]             function(cond) {
[17:41:22.796]                 is_error <- inherits(cond, "error")
[17:41:22.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:22.796]                   NULL)
[17:41:22.796]                 if (is_error) {
[17:41:22.796]                   sessionInformation <- function() {
[17:41:22.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:22.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:22.796]                       search = base::search(), system = base::Sys.info())
[17:41:22.796]                   }
[17:41:22.796]                   ...future.conditions[[length(...future.conditions) + 
[17:41:22.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:22.796]                     cond$call), session = sessionInformation(), 
[17:41:22.796]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:22.796]                   signalCondition(cond)
[17:41:22.796]                 }
[17:41:22.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:22.796]                 "immediateCondition"))) {
[17:41:22.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:22.796]                   ...future.conditions[[length(...future.conditions) + 
[17:41:22.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:22.796]                   if (TRUE && !signal) {
[17:41:22.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.796]                     {
[17:41:22.796]                       inherits <- base::inherits
[17:41:22.796]                       invokeRestart <- base::invokeRestart
[17:41:22.796]                       is.null <- base::is.null
[17:41:22.796]                       muffled <- FALSE
[17:41:22.796]                       if (inherits(cond, "message")) {
[17:41:22.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:22.796]                         if (muffled) 
[17:41:22.796]                           invokeRestart("muffleMessage")
[17:41:22.796]                       }
[17:41:22.796]                       else if (inherits(cond, "warning")) {
[17:41:22.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:22.796]                         if (muffled) 
[17:41:22.796]                           invokeRestart("muffleWarning")
[17:41:22.796]                       }
[17:41:22.796]                       else if (inherits(cond, "condition")) {
[17:41:22.796]                         if (!is.null(pattern)) {
[17:41:22.796]                           computeRestarts <- base::computeRestarts
[17:41:22.796]                           grepl <- base::grepl
[17:41:22.796]                           restarts <- computeRestarts(cond)
[17:41:22.796]                           for (restart in restarts) {
[17:41:22.796]                             name <- restart$name
[17:41:22.796]                             if (is.null(name)) 
[17:41:22.796]                               next
[17:41:22.796]                             if (!grepl(pattern, name)) 
[17:41:22.796]                               next
[17:41:22.796]                             invokeRestart(restart)
[17:41:22.796]                             muffled <- TRUE
[17:41:22.796]                             break
[17:41:22.796]                           }
[17:41:22.796]                         }
[17:41:22.796]                       }
[17:41:22.796]                       invisible(muffled)
[17:41:22.796]                     }
[17:41:22.796]                     muffleCondition(cond, pattern = "^muffle")
[17:41:22.796]                   }
[17:41:22.796]                 }
[17:41:22.796]                 else {
[17:41:22.796]                   if (TRUE) {
[17:41:22.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:22.796]                     {
[17:41:22.796]                       inherits <- base::inherits
[17:41:22.796]                       invokeRestart <- base::invokeRestart
[17:41:22.796]                       is.null <- base::is.null
[17:41:22.796]                       muffled <- FALSE
[17:41:22.796]                       if (inherits(cond, "message")) {
[17:41:22.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:22.796]                         if (muffled) 
[17:41:22.796]                           invokeRestart("muffleMessage")
[17:41:22.796]                       }
[17:41:22.796]                       else if (inherits(cond, "warning")) {
[17:41:22.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:22.796]                         if (muffled) 
[17:41:22.796]                           invokeRestart("muffleWarning")
[17:41:22.796]                       }
[17:41:22.796]                       else if (inherits(cond, "condition")) {
[17:41:22.796]                         if (!is.null(pattern)) {
[17:41:22.796]                           computeRestarts <- base::computeRestarts
[17:41:22.796]                           grepl <- base::grepl
[17:41:22.796]                           restarts <- computeRestarts(cond)
[17:41:22.796]                           for (restart in restarts) {
[17:41:22.796]                             name <- restart$name
[17:41:22.796]                             if (is.null(name)) 
[17:41:22.796]                               next
[17:41:22.796]                             if (!grepl(pattern, name)) 
[17:41:22.796]                               next
[17:41:22.796]                             invokeRestart(restart)
[17:41:22.796]                             muffled <- TRUE
[17:41:22.796]                             break
[17:41:22.796]                           }
[17:41:22.796]                         }
[17:41:22.796]                       }
[17:41:22.796]                       invisible(muffled)
[17:41:22.796]                     }
[17:41:22.796]                     muffleCondition(cond, pattern = "^muffle")
[17:41:22.796]                   }
[17:41:22.796]                 }
[17:41:22.796]             }
[17:41:22.796]         }))
[17:41:22.796]     }, error = function(ex) {
[17:41:22.796]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:22.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:22.796]                 ...future.rng), started = ...future.startTime, 
[17:41:22.796]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:22.796]             version = "1.8"), class = "FutureResult")
[17:41:22.796]     }, finally = {
[17:41:22.796]         if (!identical(...future.workdir, getwd())) 
[17:41:22.796]             setwd(...future.workdir)
[17:41:22.796]         {
[17:41:22.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:22.796]                 ...future.oldOptions$nwarnings <- NULL
[17:41:22.796]             }
[17:41:22.796]             base::options(...future.oldOptions)
[17:41:22.796]             if (.Platform$OS.type == "windows") {
[17:41:22.796]                 old_names <- names(...future.oldEnvVars)
[17:41:22.796]                 envs <- base::Sys.getenv()
[17:41:22.796]                 names <- names(envs)
[17:41:22.796]                 common <- intersect(names, old_names)
[17:41:22.796]                 added <- setdiff(names, old_names)
[17:41:22.796]                 removed <- setdiff(old_names, names)
[17:41:22.796]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:22.796]                   envs[common]]
[17:41:22.796]                 NAMES <- toupper(changed)
[17:41:22.796]                 args <- list()
[17:41:22.796]                 for (kk in seq_along(NAMES)) {
[17:41:22.796]                   name <- changed[[kk]]
[17:41:22.796]                   NAME <- NAMES[[kk]]
[17:41:22.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.796]                     next
[17:41:22.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:22.796]                 }
[17:41:22.796]                 NAMES <- toupper(added)
[17:41:22.796]                 for (kk in seq_along(NAMES)) {
[17:41:22.796]                   name <- added[[kk]]
[17:41:22.796]                   NAME <- NAMES[[kk]]
[17:41:22.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.796]                     next
[17:41:22.796]                   args[[name]] <- ""
[17:41:22.796]                 }
[17:41:22.796]                 NAMES <- toupper(removed)
[17:41:22.796]                 for (kk in seq_along(NAMES)) {
[17:41:22.796]                   name <- removed[[kk]]
[17:41:22.796]                   NAME <- NAMES[[kk]]
[17:41:22.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:22.796]                     next
[17:41:22.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:22.796]                 }
[17:41:22.796]                 if (length(args) > 0) 
[17:41:22.796]                   base::do.call(base::Sys.setenv, args = args)
[17:41:22.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:22.796]             }
[17:41:22.796]             else {
[17:41:22.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:22.796]             }
[17:41:22.796]             {
[17:41:22.796]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:22.796]                   0L) {
[17:41:22.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:22.796]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:22.796]                   base::options(opts)
[17:41:22.796]                 }
[17:41:22.796]                 {
[17:41:22.796]                   {
[17:41:22.796]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:22.796]                     NULL
[17:41:22.796]                   }
[17:41:22.796]                   options(future.plan = NULL)
[17:41:22.796]                   if (is.na(NA_character_)) 
[17:41:22.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:22.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:22.796]                   future::plan(list(function (..., workers = availableCores(), 
[17:41:22.796]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:41:22.796]                     envir = parent.frame()) 
[17:41:22.796]                   {
[17:41:22.796]                     if (is.function(workers)) 
[17:41:22.796]                       workers <- workers()
[17:41:22.796]                     workers <- structure(as.integer(workers), 
[17:41:22.796]                       class = class(workers))
[17:41:22.796]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:41:22.796]                       workers >= 1)
[17:41:22.796]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:41:22.796]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:41:22.796]                     }
[17:41:22.796]                     future <- MultisessionFuture(..., workers = workers, 
[17:41:22.796]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:41:22.796]                       envir = envir)
[17:41:22.796]                     if (!future$lazy) 
[17:41:22.796]                       future <- run(future)
[17:41:22.796]                     invisible(future)
[17:41:22.796]                   }), .cleanup = FALSE, .init = FALSE)
[17:41:22.796]                 }
[17:41:22.796]             }
[17:41:22.796]         }
[17:41:22.796]     })
[17:41:22.796]     if (FALSE) {
[17:41:22.796]         base::sink(type = "output", split = FALSE)
[17:41:22.796]         if (NA) {
[17:41:22.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:22.796]         }
[17:41:22.796]         else {
[17:41:22.796]             ...future.result["stdout"] <- base::list(NULL)
[17:41:22.796]         }
[17:41:22.796]         base::close(...future.stdout)
[17:41:22.796]         ...future.stdout <- NULL
[17:41:22.796]     }
[17:41:22.796]     ...future.result$conditions <- ...future.conditions
[17:41:22.796]     ...future.result$finished <- base::Sys.time()
[17:41:22.796]     ...future.result
[17:41:22.796] }
[17:41:22.799] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:41:22.799] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:41:22.799] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:41:22.800] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:41:22.800] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:41:22.800] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:41:22.800] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:41:22.801] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:41:22.801] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:41:22.801] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:41:22.801] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:41:22.801] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:41:22.802] MultisessionFuture started
[17:41:22.802] - Launch lazy future ... done
[17:41:22.802] run() for ‘MultisessionFuture’ ... done
[17:41:22.802] Created future:
[17:41:22.802] MultisessionFuture:
[17:41:22.802] Label: ‘future_mapply-2’
[17:41:22.802] Expression:
[17:41:22.802] {
[17:41:22.802]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:41:22.802]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:41:22.802]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:41:22.802]         on.exit(options(oopts), add = TRUE)
[17:41:22.802]     }
[17:41:22.802]     {
[17:41:22.802]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:41:22.802]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:41:22.802]         do.call(mapply, args = args)
[17:41:22.802]     }
[17:41:22.802] }
[17:41:22.802] Lazy evaluation: FALSE
[17:41:22.802] Asynchronous evaluation: TRUE
[17:41:22.802] Local evaluation: TRUE
[17:41:22.802] Environment: R_GlobalEnv
[17:41:22.802] Capture standard output: NA
[17:41:22.802] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:41:22.802] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:41:22.802] Packages: <none>
[17:41:22.802] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:41:22.802] Resolved: FALSE
[17:41:22.802] Value: <not collected>
[17:41:22.802] Conditions captured: <none>
[17:41:22.802] Early signaling: FALSE
[17:41:22.802] Owner process: 08b7a519-2bef-7374-90b7-b91b95d1e918
[17:41:22.802] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:22.814] Chunk #2 of 2 ... DONE
[17:41:22.814] Launching 2 futures (chunks) ... DONE
[17:41:22.814] Resolving 2 futures (chunks) ...
[17:41:22.814] resolve() on list ...
[17:41:22.814]  recursive: 0
[17:41:22.814]  length: 2
[17:41:22.815] 
[17:41:22.857] receiveMessageFromWorker() for ClusterFuture ...
[17:41:22.857] - Validating connection of MultisessionFuture
[17:41:22.857] - received message: FutureResult
[17:41:22.857] - Received FutureResult
[17:41:22.857] - Erased future from FutureRegistry
[17:41:22.857] result() for ClusterFuture ...
[17:41:22.857] - result already collected: FutureResult
[17:41:22.857] result() for ClusterFuture ... done
[17:41:22.858] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:22.858] Future #2
[17:41:22.858] result() for ClusterFuture ...
[17:41:22.858] - result already collected: FutureResult
[17:41:22.858] result() for ClusterFuture ... done
[17:41:22.858] result() for ClusterFuture ...
[17:41:22.858] - result already collected: FutureResult
[17:41:22.858] result() for ClusterFuture ... done
[17:41:22.858] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:41:22.858] - nx: 2
[17:41:22.858] - relay: TRUE
[17:41:22.859] - stdout: TRUE
[17:41:22.859] - signal: TRUE
[17:41:22.859] - resignal: FALSE
[17:41:22.859] - force: TRUE
[17:41:22.859] - relayed: [n=2] FALSE, FALSE
[17:41:22.859] - queued futures: [n=2] FALSE, FALSE
[17:41:22.859]  - until=1
[17:41:22.859]  - relaying element #1
[17:41:22.859] - relayed: [n=2] FALSE, FALSE
[17:41:22.859] - queued futures: [n=2] FALSE, TRUE
[17:41:22.860] signalConditionsASAP(NULL, pos=2) ... done
[17:41:22.860]  length: 1 (resolved future 2)
[17:41:23.313] receiveMessageFromWorker() for ClusterFuture ...
[17:41:23.313] - Validating connection of MultisessionFuture
[17:41:23.313] - received message: FutureResult
[17:41:23.313] - Received FutureResult
[17:41:23.313] - Erased future from FutureRegistry
[17:41:23.313] result() for ClusterFuture ...
[17:41:23.314] - result already collected: FutureResult
[17:41:23.314] result() for ClusterFuture ... done
[17:41:23.314] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:23.314] Future #1
[17:41:23.314] result() for ClusterFuture ...
[17:41:23.314] - result already collected: FutureResult
[17:41:23.314] result() for ClusterFuture ... done
[17:41:23.314] result() for ClusterFuture ...
[17:41:23.314] - result already collected: FutureResult
[17:41:23.314] result() for ClusterFuture ... done
[17:41:23.317] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:41:23.317] - nx: 2
[17:41:23.317] - relay: TRUE
[17:41:23.317] - stdout: TRUE
[17:41:23.317] - signal: TRUE
[17:41:23.317] - resignal: FALSE
[17:41:23.317] - force: TRUE
[17:41:23.317] - relayed: [n=2] FALSE, FALSE
[17:41:23.317] - queued futures: [n=2] FALSE, TRUE
[17:41:23.317]  - until=1
[17:41:23.317]  - relaying element #1
[17:41:23.318] result() for ClusterFuture ...
[17:41:23.318] - result already collected: FutureResult
[17:41:23.318] result() for ClusterFuture ... done
[17:41:23.318] result() for ClusterFuture ...
[17:41:23.318] - result already collected: FutureResult
[17:41:23.318] result() for ClusterFuture ... done
[17:41:23.318] result() for ClusterFuture ...
[17:41:23.318] - result already collected: FutureResult
[17:41:23.318] result() for ClusterFuture ... done
[17:41:23.318] result() for ClusterFuture ...
[17:41:23.318] - result already collected: FutureResult
[17:41:23.318] result() for ClusterFuture ... done
[17:41:23.319] - relayed: [n=2] TRUE, FALSE
[17:41:23.319] - queued futures: [n=2] TRUE, TRUE
[17:41:23.319] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:41:23.319]  length: 0 (resolved future 1)
[17:41:23.319] Relaying remaining futures
[17:41:23.319] signalConditionsASAP(NULL, pos=0) ...
[17:41:23.319] - nx: 2
[17:41:23.319] - relay: TRUE
[17:41:23.319] - stdout: TRUE
[17:41:23.319] - signal: TRUE
[17:41:23.319] - resignal: FALSE
[17:41:23.320] - force: TRUE
[17:41:23.320] - relayed: [n=2] TRUE, FALSE
[17:41:23.320] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:41:23.320]  - relaying element #2
[17:41:23.320] result() for ClusterFuture ...
[17:41:23.320] - result already collected: FutureResult
[17:41:23.320] result() for ClusterFuture ... done
[17:41:23.320] result() for ClusterFuture ...
[17:41:23.320] - result already collected: FutureResult
[17:41:23.320] result() for ClusterFuture ... done
[17:41:23.320] result() for ClusterFuture ...
[17:41:23.321] - result already collected: FutureResult
[17:41:23.321] result() for ClusterFuture ... done
[17:41:23.321] result() for ClusterFuture ...
[17:41:23.321] - result already collected: FutureResult
[17:41:23.321] result() for ClusterFuture ... done
[17:41:23.321] - relayed: [n=2] TRUE, TRUE
[17:41:23.321] - queued futures: [n=2] TRUE, TRUE
[17:41:23.321] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:41:23.321] resolve() on list ... DONE
[17:41:23.321] result() for ClusterFuture ...
[17:41:23.321] - result already collected: FutureResult
[17:41:23.321] result() for ClusterFuture ... done
[17:41:23.322] result() for ClusterFuture ...
[17:41:23.322] - result already collected: FutureResult
[17:41:23.322] result() for ClusterFuture ... done
[17:41:23.322] result() for ClusterFuture ...
[17:41:23.322] - result already collected: FutureResult
[17:41:23.322] result() for ClusterFuture ... done
[17:41:23.322] result() for ClusterFuture ...
[17:41:23.322] - result already collected: FutureResult
[17:41:23.322] result() for ClusterFuture ... done
[17:41:23.322]  - Number of value chunks collected: 2
[17:41:23.322] Resolving 2 futures (chunks) ... DONE
[17:41:23.322] Reducing values from 2 chunks ...
[17:41:23.323]  - Number of values collected after concatenation: 2
[17:41:23.323]  - Number of values expected: 2
[17:41:23.323] Reducing values from 2 chunks ... DONE
[17:41:23.323] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[17:41:23.324] plan(): Setting new future strategy stack:
[17:41:23.324] List of future strategies:
[17:41:23.324] 1. FutureStrategy:
[17:41:23.324]    - args: function (..., envir = parent.frame())
[17:41:23.324]    - tweaked: FALSE
[17:41:23.324]    - call: future::plan(oplan)
[17:41:23.325] plan(): nbrOfWorkers() = 1
> 
