
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:19:09.588] plan(): Setting new future strategy stack:
[13:19:09.588] List of future strategies:
[13:19:09.588] 1. sequential:
[13:19:09.588]    - args: function (..., envir = parent.frame())
[13:19:09.588]    - tweaked: FALSE
[13:19:09.588]    - call: future::plan("sequential")
[13:19:09.598] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[13:19:09.632] plan(): Setting new future strategy stack:
[13:19:09.632] List of future strategies:
[13:19:09.632] 1. sequential:
[13:19:09.632]    - args: function (..., envir = parent.frame())
[13:19:09.632]    - tweaked: FALSE
[13:19:09.632]    - call: plan(strategy)
[13:19:09.644] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:19:09.644] future_lapply() ...
[13:19:09.649] Number of chunks: 1
[13:19:09.649] getGlobalsAndPackagesXApply() ...
[13:19:09.649]  - future.globals: TRUE
[13:19:09.650] getGlobalsAndPackages() ...
[13:19:09.652] Searching for globals...
[13:19:09.655] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:09.655] Searching for globals ... DONE
[13:19:09.655] Resolving globals: FALSE
[13:19:09.656] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:09.657] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:09.657] - globals: [1] ‘FUN’
[13:19:09.657] 
[13:19:09.657] getGlobalsAndPackages() ... DONE
[13:19:09.657]  - globals found/used: [n=1] ‘FUN’
[13:19:09.657]  - needed namespaces: [n=0] 
[13:19:09.657] Finding globals ... DONE
[13:19:09.658]  - use_args: TRUE
[13:19:09.658]  - Getting '...' globals ...
[13:19:09.658] resolve() on list ...
[13:19:09.659]  recursive: 0
[13:19:09.659]  length: 1
[13:19:09.659]  elements: ‘...’
[13:19:09.659]  length: 0 (resolved future 1)
[13:19:09.659] resolve() on list ... DONE
[13:19:09.659]    - '...' content: [n=0] 
[13:19:09.659] List of 1
[13:19:09.659]  $ ...: list()
[13:19:09.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:09.659]  - attr(*, "where")=List of 1
[13:19:09.659]   ..$ ...:<environment: 0x5620065364d0> 
[13:19:09.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:09.659]  - attr(*, "resolved")= logi TRUE
[13:19:09.659]  - attr(*, "total_size")= num NA
[13:19:09.665]  - Getting '...' globals ... DONE
[13:19:09.665] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:09.665] List of 2
[13:19:09.665]  $ ...future.FUN:function (x)  
[13:19:09.665]  $ ...          : list()
[13:19:09.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:09.665]  - attr(*, "where")=List of 2
[13:19:09.665]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:09.665]   ..$ ...          :<environment: 0x5620065364d0> 
[13:19:09.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:09.665]  - attr(*, "resolved")= logi FALSE
[13:19:09.665]  - attr(*, "total_size")= num 4720
[13:19:09.668] Packages to be attached in all futures: [n=0] 
[13:19:09.668] getGlobalsAndPackagesXApply() ... DONE
[13:19:09.668] Number of futures (= number of chunks): 1
[13:19:09.668] Launching 1 futures (chunks) ...
[13:19:09.668] Chunk #1 of 1 ...
[13:19:09.669]  - Finding globals in 'X' for chunk #1 ...
[13:19:09.669] getGlobalsAndPackages() ...
[13:19:09.669] Searching for globals...
[13:19:09.669] 
[13:19:09.669] Searching for globals ... DONE
[13:19:09.669] - globals: [0] <none>
[13:19:09.669] getGlobalsAndPackages() ... DONE
[13:19:09.670]    + additional globals found: [n=0] 
[13:19:09.670]    + additional namespaces needed: [n=0] 
[13:19:09.670]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:09.670]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:09.670]  - seeds: <none>
[13:19:09.670] getGlobalsAndPackages() ...
[13:19:09.670] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:09.671] Resolving globals: FALSE
[13:19:09.671] Tweak future expression to call with '...' arguments ...
[13:19:09.671] {
[13:19:09.671]     do.call(function(...) {
[13:19:09.671]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:09.671]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:09.671]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:09.671]             on.exit(options(oopts), add = TRUE)
[13:19:09.671]         }
[13:19:09.671]         {
[13:19:09.671]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:09.671]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:09.671]                 ...future.FUN(...future.X_jj, ...)
[13:19:09.671]             })
[13:19:09.671]         }
[13:19:09.671]     }, args = future.call.arguments)
[13:19:09.671] }
[13:19:09.671] Tweak future expression to call with '...' arguments ... DONE
[13:19:09.671] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:09.671] 
[13:19:09.672] getGlobalsAndPackages() ... DONE
[13:19:09.672] run() for ‘Future’ ...
[13:19:09.673] - state: ‘created’
[13:19:09.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:09.673] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:09.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:09.673]   - Field: ‘label’
[13:19:09.673]   - Field: ‘local’
[13:19:09.674]   - Field: ‘owner’
[13:19:09.674]   - Field: ‘envir’
[13:19:09.674]   - Field: ‘packages’
[13:19:09.674]   - Field: ‘gc’
[13:19:09.674]   - Field: ‘conditions’
[13:19:09.674]   - Field: ‘expr’
[13:19:09.674]   - Field: ‘uuid’
[13:19:09.674]   - Field: ‘seed’
[13:19:09.674]   - Field: ‘version’
[13:19:09.674]   - Field: ‘result’
[13:19:09.674]   - Field: ‘asynchronous’
[13:19:09.675]   - Field: ‘calls’
[13:19:09.675]   - Field: ‘globals’
[13:19:09.675]   - Field: ‘stdout’
[13:19:09.675]   - Field: ‘earlySignal’
[13:19:09.675]   - Field: ‘lazy’
[13:19:09.675]   - Field: ‘state’
[13:19:09.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:09.675] - Launch lazy future ...
[13:19:09.676] Packages needed by the future expression (n = 0): <none>
[13:19:09.676] Packages needed by future strategies (n = 0): <none>
[13:19:09.677] {
[13:19:09.677]     {
[13:19:09.677]         {
[13:19:09.677]             ...future.startTime <- base::Sys.time()
[13:19:09.677]             {
[13:19:09.677]                 {
[13:19:09.677]                   {
[13:19:09.677]                     base::local({
[13:19:09.677]                       has_future <- base::requireNamespace("future", 
[13:19:09.677]                         quietly = TRUE)
[13:19:09.677]                       if (has_future) {
[13:19:09.677]                         ns <- base::getNamespace("future")
[13:19:09.677]                         version <- ns[[".package"]][["version"]]
[13:19:09.677]                         if (is.null(version)) 
[13:19:09.677]                           version <- utils::packageVersion("future")
[13:19:09.677]                       }
[13:19:09.677]                       else {
[13:19:09.677]                         version <- NULL
[13:19:09.677]                       }
[13:19:09.677]                       if (!has_future || version < "1.8.0") {
[13:19:09.677]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:09.677]                           "", base::R.version$version.string), 
[13:19:09.677]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:09.677]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:09.677]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:09.677]                             "release", "version")], collapse = " "), 
[13:19:09.677]                           hostname = base::Sys.info()[["nodename"]])
[13:19:09.677]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:09.677]                           info)
[13:19:09.677]                         info <- base::paste(info, collapse = "; ")
[13:19:09.677]                         if (!has_future) {
[13:19:09.677]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:09.677]                             info)
[13:19:09.677]                         }
[13:19:09.677]                         else {
[13:19:09.677]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:09.677]                             info, version)
[13:19:09.677]                         }
[13:19:09.677]                         base::stop(msg)
[13:19:09.677]                       }
[13:19:09.677]                     })
[13:19:09.677]                   }
[13:19:09.677]                   options(future.plan = NULL)
[13:19:09.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:09.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:09.677]                 }
[13:19:09.677]                 ...future.workdir <- getwd()
[13:19:09.677]             }
[13:19:09.677]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:09.677]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:09.677]         }
[13:19:09.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:09.677]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:09.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:09.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:09.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:09.677]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:09.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:09.677]             base::names(...future.oldOptions))
[13:19:09.677]     }
[13:19:09.677]     if (FALSE) {
[13:19:09.677]     }
[13:19:09.677]     else {
[13:19:09.677]         if (FALSE) {
[13:19:09.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:09.677]                 open = "w")
[13:19:09.677]         }
[13:19:09.677]         else {
[13:19:09.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:09.677]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:09.677]         }
[13:19:09.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:09.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:09.677]             base::sink(type = "output", split = FALSE)
[13:19:09.677]             base::close(...future.stdout)
[13:19:09.677]         }, add = TRUE)
[13:19:09.677]     }
[13:19:09.677]     ...future.frame <- base::sys.nframe()
[13:19:09.677]     ...future.conditions <- base::list()
[13:19:09.677]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:09.677]     if (FALSE) {
[13:19:09.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:09.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:09.677]     }
[13:19:09.677]     ...future.result <- base::tryCatch({
[13:19:09.677]         base::withCallingHandlers({
[13:19:09.677]             ...future.value <- base::withVisible(base::local({
[13:19:09.677]                 do.call(function(...) {
[13:19:09.677]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:09.677]                   if (!identical(...future.globals.maxSize.org, 
[13:19:09.677]                     ...future.globals.maxSize)) {
[13:19:09.677]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:09.677]                     on.exit(options(oopts), add = TRUE)
[13:19:09.677]                   }
[13:19:09.677]                   {
[13:19:09.677]                     lapply(seq_along(...future.elements_ii), 
[13:19:09.677]                       FUN = function(jj) {
[13:19:09.677]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:09.677]                         ...future.FUN(...future.X_jj, ...)
[13:19:09.677]                       })
[13:19:09.677]                   }
[13:19:09.677]                 }, args = future.call.arguments)
[13:19:09.677]             }))
[13:19:09.677]             future::FutureResult(value = ...future.value$value, 
[13:19:09.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:09.677]                   ...future.rng), globalenv = if (FALSE) 
[13:19:09.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:09.677]                     ...future.globalenv.names))
[13:19:09.677]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:09.677]         }, condition = base::local({
[13:19:09.677]             c <- base::c
[13:19:09.677]             inherits <- base::inherits
[13:19:09.677]             invokeRestart <- base::invokeRestart
[13:19:09.677]             length <- base::length
[13:19:09.677]             list <- base::list
[13:19:09.677]             seq.int <- base::seq.int
[13:19:09.677]             signalCondition <- base::signalCondition
[13:19:09.677]             sys.calls <- base::sys.calls
[13:19:09.677]             `[[` <- base::`[[`
[13:19:09.677]             `+` <- base::`+`
[13:19:09.677]             `<<-` <- base::`<<-`
[13:19:09.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:09.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:09.677]                   3L)]
[13:19:09.677]             }
[13:19:09.677]             function(cond) {
[13:19:09.677]                 is_error <- inherits(cond, "error")
[13:19:09.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:09.677]                   NULL)
[13:19:09.677]                 if (is_error) {
[13:19:09.677]                   sessionInformation <- function() {
[13:19:09.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:09.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:09.677]                       search = base::search(), system = base::Sys.info())
[13:19:09.677]                   }
[13:19:09.677]                   ...future.conditions[[length(...future.conditions) + 
[13:19:09.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:09.677]                     cond$call), session = sessionInformation(), 
[13:19:09.677]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:09.677]                   signalCondition(cond)
[13:19:09.677]                 }
[13:19:09.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:09.677]                 "immediateCondition"))) {
[13:19:09.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:09.677]                   ...future.conditions[[length(...future.conditions) + 
[13:19:09.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:09.677]                   if (TRUE && !signal) {
[13:19:09.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:09.677]                     {
[13:19:09.677]                       inherits <- base::inherits
[13:19:09.677]                       invokeRestart <- base::invokeRestart
[13:19:09.677]                       is.null <- base::is.null
[13:19:09.677]                       muffled <- FALSE
[13:19:09.677]                       if (inherits(cond, "message")) {
[13:19:09.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:09.677]                         if (muffled) 
[13:19:09.677]                           invokeRestart("muffleMessage")
[13:19:09.677]                       }
[13:19:09.677]                       else if (inherits(cond, "warning")) {
[13:19:09.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:09.677]                         if (muffled) 
[13:19:09.677]                           invokeRestart("muffleWarning")
[13:19:09.677]                       }
[13:19:09.677]                       else if (inherits(cond, "condition")) {
[13:19:09.677]                         if (!is.null(pattern)) {
[13:19:09.677]                           computeRestarts <- base::computeRestarts
[13:19:09.677]                           grepl <- base::grepl
[13:19:09.677]                           restarts <- computeRestarts(cond)
[13:19:09.677]                           for (restart in restarts) {
[13:19:09.677]                             name <- restart$name
[13:19:09.677]                             if (is.null(name)) 
[13:19:09.677]                               next
[13:19:09.677]                             if (!grepl(pattern, name)) 
[13:19:09.677]                               next
[13:19:09.677]                             invokeRestart(restart)
[13:19:09.677]                             muffled <- TRUE
[13:19:09.677]                             break
[13:19:09.677]                           }
[13:19:09.677]                         }
[13:19:09.677]                       }
[13:19:09.677]                       invisible(muffled)
[13:19:09.677]                     }
[13:19:09.677]                     muffleCondition(cond, pattern = "^muffle")
[13:19:09.677]                   }
[13:19:09.677]                 }
[13:19:09.677]                 else {
[13:19:09.677]                   if (TRUE) {
[13:19:09.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:09.677]                     {
[13:19:09.677]                       inherits <- base::inherits
[13:19:09.677]                       invokeRestart <- base::invokeRestart
[13:19:09.677]                       is.null <- base::is.null
[13:19:09.677]                       muffled <- FALSE
[13:19:09.677]                       if (inherits(cond, "message")) {
[13:19:09.677]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:09.677]                         if (muffled) 
[13:19:09.677]                           invokeRestart("muffleMessage")
[13:19:09.677]                       }
[13:19:09.677]                       else if (inherits(cond, "warning")) {
[13:19:09.677]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:09.677]                         if (muffled) 
[13:19:09.677]                           invokeRestart("muffleWarning")
[13:19:09.677]                       }
[13:19:09.677]                       else if (inherits(cond, "condition")) {
[13:19:09.677]                         if (!is.null(pattern)) {
[13:19:09.677]                           computeRestarts <- base::computeRestarts
[13:19:09.677]                           grepl <- base::grepl
[13:19:09.677]                           restarts <- computeRestarts(cond)
[13:19:09.677]                           for (restart in restarts) {
[13:19:09.677]                             name <- restart$name
[13:19:09.677]                             if (is.null(name)) 
[13:19:09.677]                               next
[13:19:09.677]                             if (!grepl(pattern, name)) 
[13:19:09.677]                               next
[13:19:09.677]                             invokeRestart(restart)
[13:19:09.677]                             muffled <- TRUE
[13:19:09.677]                             break
[13:19:09.677]                           }
[13:19:09.677]                         }
[13:19:09.677]                       }
[13:19:09.677]                       invisible(muffled)
[13:19:09.677]                     }
[13:19:09.677]                     muffleCondition(cond, pattern = "^muffle")
[13:19:09.677]                   }
[13:19:09.677]                 }
[13:19:09.677]             }
[13:19:09.677]         }))
[13:19:09.677]     }, error = function(ex) {
[13:19:09.677]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:09.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:09.677]                 ...future.rng), started = ...future.startTime, 
[13:19:09.677]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:09.677]             version = "1.8"), class = "FutureResult")
[13:19:09.677]     }, finally = {
[13:19:09.677]         if (!identical(...future.workdir, getwd())) 
[13:19:09.677]             setwd(...future.workdir)
[13:19:09.677]         {
[13:19:09.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:09.677]                 ...future.oldOptions$nwarnings <- NULL
[13:19:09.677]             }
[13:19:09.677]             base::options(...future.oldOptions)
[13:19:09.677]             if (.Platform$OS.type == "windows") {
[13:19:09.677]                 old_names <- names(...future.oldEnvVars)
[13:19:09.677]                 envs <- base::Sys.getenv()
[13:19:09.677]                 names <- names(envs)
[13:19:09.677]                 common <- intersect(names, old_names)
[13:19:09.677]                 added <- setdiff(names, old_names)
[13:19:09.677]                 removed <- setdiff(old_names, names)
[13:19:09.677]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:09.677]                   envs[common]]
[13:19:09.677]                 NAMES <- toupper(changed)
[13:19:09.677]                 args <- list()
[13:19:09.677]                 for (kk in seq_along(NAMES)) {
[13:19:09.677]                   name <- changed[[kk]]
[13:19:09.677]                   NAME <- NAMES[[kk]]
[13:19:09.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:09.677]                     next
[13:19:09.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:09.677]                 }
[13:19:09.677]                 NAMES <- toupper(added)
[13:19:09.677]                 for (kk in seq_along(NAMES)) {
[13:19:09.677]                   name <- added[[kk]]
[13:19:09.677]                   NAME <- NAMES[[kk]]
[13:19:09.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:09.677]                     next
[13:19:09.677]                   args[[name]] <- ""
[13:19:09.677]                 }
[13:19:09.677]                 NAMES <- toupper(removed)
[13:19:09.677]                 for (kk in seq_along(NAMES)) {
[13:19:09.677]                   name <- removed[[kk]]
[13:19:09.677]                   NAME <- NAMES[[kk]]
[13:19:09.677]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:09.677]                     next
[13:19:09.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:09.677]                 }
[13:19:09.677]                 if (length(args) > 0) 
[13:19:09.677]                   base::do.call(base::Sys.setenv, args = args)
[13:19:09.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:09.677]             }
[13:19:09.677]             else {
[13:19:09.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:09.677]             }
[13:19:09.677]             {
[13:19:09.677]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:09.677]                   0L) {
[13:19:09.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:09.677]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:09.677]                   base::options(opts)
[13:19:09.677]                 }
[13:19:09.677]                 {
[13:19:09.677]                   {
[13:19:09.677]                     NULL
[13:19:09.677]                     RNGkind("Mersenne-Twister")
[13:19:09.677]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:09.677]                       inherits = FALSE)
[13:19:09.677]                   }
[13:19:09.677]                   options(future.plan = NULL)
[13:19:09.677]                   if (is.na(NA_character_)) 
[13:19:09.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:09.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:09.677]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:09.677]                   {
[13:19:09.677]                     future <- SequentialFuture(..., envir = envir)
[13:19:09.677]                     if (!future$lazy) 
[13:19:09.677]                       future <- run(future)
[13:19:09.677]                     invisible(future)
[13:19:09.677]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:09.677]                 }
[13:19:09.677]             }
[13:19:09.677]         }
[13:19:09.677]     })
[13:19:09.677]     if (TRUE) {
[13:19:09.677]         base::sink(type = "output", split = FALSE)
[13:19:09.677]         if (FALSE) {
[13:19:09.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:09.677]         }
[13:19:09.677]         else {
[13:19:09.677]             ...future.result["stdout"] <- base::list(NULL)
[13:19:09.677]         }
[13:19:09.677]         base::close(...future.stdout)
[13:19:09.677]         ...future.stdout <- NULL
[13:19:09.677]     }
[13:19:09.677]     ...future.result$conditions <- ...future.conditions
[13:19:09.677]     ...future.result$finished <- base::Sys.time()
[13:19:09.677]     ...future.result
[13:19:09.677] }
[13:19:09.679] assign_globals() ...
[13:19:09.679] List of 5
[13:19:09.679]  $ ...future.FUN            :function (x)  
[13:19:09.679]  $ future.call.arguments    : list()
[13:19:09.679]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:09.679]  $ ...future.elements_ii    :List of 2
[13:19:09.679]   ..$ : int 1
[13:19:09.679]   ..$ : int 0
[13:19:09.679]  $ ...future.seeds_ii       : NULL
[13:19:09.679]  $ ...future.globals.maxSize: NULL
[13:19:09.679]  - attr(*, "resolved")= logi FALSE
[13:19:09.679]  - attr(*, "total_size")= num 4720
[13:19:09.679]  - attr(*, "where")=List of 5
[13:19:09.679]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:09.679]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:09.679]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:09.679]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:09.679]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:09.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:09.679]  - attr(*, "already-done")= logi TRUE
[13:19:09.684] - reassign environment for ‘...future.FUN’
[13:19:09.684] - copied ‘...future.FUN’ to environment
[13:19:09.684] - copied ‘future.call.arguments’ to environment
[13:19:09.684] - copied ‘...future.elements_ii’ to environment
[13:19:09.684] - copied ‘...future.seeds_ii’ to environment
[13:19:09.684] - copied ‘...future.globals.maxSize’ to environment
[13:19:09.685] assign_globals() ... done
[13:19:09.685] plan(): Setting new future strategy stack:
[13:19:09.685] List of future strategies:
[13:19:09.685] 1. sequential:
[13:19:09.685]    - args: function (..., envir = parent.frame())
[13:19:09.685]    - tweaked: FALSE
[13:19:09.685]    - call: NULL
[13:19:09.685] plan(): nbrOfWorkers() = 1
[13:19:10.190] plan(): Setting new future strategy stack:
[13:19:10.190] List of future strategies:
[13:19:10.190] 1. sequential:
[13:19:10.190]    - args: function (..., envir = parent.frame())
[13:19:10.190]    - tweaked: FALSE
[13:19:10.190]    - call: plan(strategy)
[13:19:10.191] plan(): nbrOfWorkers() = 1
[13:19:10.191] SequentialFuture started (and completed)
[13:19:10.192] - Launch lazy future ... done
[13:19:10.192] run() for ‘SequentialFuture’ ... done
[13:19:10.192] Created future:
[13:19:10.192] SequentialFuture:
[13:19:10.192] Label: ‘future_lapply-1’
[13:19:10.192] Expression:
[13:19:10.192] {
[13:19:10.192]     do.call(function(...) {
[13:19:10.192]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:10.192]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:10.192]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:10.192]             on.exit(options(oopts), add = TRUE)
[13:19:10.192]         }
[13:19:10.192]         {
[13:19:10.192]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:10.192]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:10.192]                 ...future.FUN(...future.X_jj, ...)
[13:19:10.192]             })
[13:19:10.192]         }
[13:19:10.192]     }, args = future.call.arguments)
[13:19:10.192] }
[13:19:10.192] Lazy evaluation: FALSE
[13:19:10.192] Asynchronous evaluation: FALSE
[13:19:10.192] Local evaluation: TRUE
[13:19:10.192] Environment: R_GlobalEnv
[13:19:10.192] Capture standard output: FALSE
[13:19:10.192] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:10.192] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:10.192] Packages: <none>
[13:19:10.192] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:10.192] Resolved: TRUE
[13:19:10.192] Value: 112 bytes of class ‘list’
[13:19:10.192] Early signaling: FALSE
[13:19:10.192] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:10.192] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:10.194] Chunk #1 of 1 ... DONE
[13:19:10.194] Launching 1 futures (chunks) ... DONE
[13:19:10.194] Resolving 1 futures (chunks) ...
[13:19:10.194] resolve() on list ...
[13:19:10.194]  recursive: 0
[13:19:10.194]  length: 1
[13:19:10.194] 
[13:19:10.194] resolved() for ‘SequentialFuture’ ...
[13:19:10.194] - state: ‘finished’
[13:19:10.195] - run: TRUE
[13:19:10.195] - result: ‘FutureResult’
[13:19:10.195] resolved() for ‘SequentialFuture’ ... done
[13:19:10.195] Future #1
[13:19:10.195] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:10.195] - nx: 1
[13:19:10.195] - relay: TRUE
[13:19:10.196] - stdout: TRUE
[13:19:10.196] - signal: TRUE
[13:19:10.196] - resignal: FALSE
[13:19:10.196] - force: TRUE
[13:19:10.196] - relayed: [n=1] FALSE
[13:19:10.196] - queued futures: [n=1] FALSE
[13:19:10.196]  - until=1
[13:19:10.196]  - relaying element #1
[13:19:10.196] - relayed: [n=1] TRUE
[13:19:10.196] - queued futures: [n=1] TRUE
[13:19:10.197] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:10.197]  length: 0 (resolved future 1)
[13:19:10.197] Relaying remaining futures
[13:19:10.197] signalConditionsASAP(NULL, pos=0) ...
[13:19:10.197] - nx: 1
[13:19:10.197] - relay: TRUE
[13:19:10.197] - stdout: TRUE
[13:19:10.197] - signal: TRUE
[13:19:10.197] - resignal: FALSE
[13:19:10.197] - force: TRUE
[13:19:10.198] - relayed: [n=1] TRUE
[13:19:10.198] - queued futures: [n=1] TRUE
 - flush all
[13:19:10.198] - relayed: [n=1] TRUE
[13:19:10.198] - queued futures: [n=1] TRUE
[13:19:10.198] signalConditionsASAP(NULL, pos=0) ... done
[13:19:10.198] resolve() on list ... DONE
[13:19:10.198]  - Number of value chunks collected: 1
[13:19:10.198] Resolving 1 futures (chunks) ... DONE
[13:19:10.198] Reducing values from 1 chunks ...
[13:19:10.198]  - Number of values collected after concatenation: 2
[13:19:10.199]  - Number of values expected: 2
[13:19:10.199] Reducing values from 1 chunks ... DONE
[13:19:10.199] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:19:10.199] future_lapply() ...
[13:19:10.200] Number of chunks: 1
[13:19:10.200] getGlobalsAndPackagesXApply() ...
[13:19:10.200]  - future.globals: TRUE
[13:19:10.200] getGlobalsAndPackages() ...
[13:19:10.200] Searching for globals...
[13:19:10.202] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:10.202] Searching for globals ... DONE
[13:19:10.202] Resolving globals: FALSE
[13:19:10.202] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:10.203] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:10.203] - globals: [1] ‘FUN’
[13:19:10.203] 
[13:19:10.203] getGlobalsAndPackages() ... DONE
[13:19:10.203]  - globals found/used: [n=1] ‘FUN’
[13:19:10.203]  - needed namespaces: [n=0] 
[13:19:10.203] Finding globals ... DONE
[13:19:10.203]  - use_args: TRUE
[13:19:10.203]  - Getting '...' globals ...
[13:19:10.204] resolve() on list ...
[13:19:10.204]  recursive: 0
[13:19:10.204]  length: 1
[13:19:10.204]  elements: ‘...’
[13:19:10.204]  length: 0 (resolved future 1)
[13:19:10.204] resolve() on list ... DONE
[13:19:10.204]    - '...' content: [n=0] 
[13:19:10.204] List of 1
[13:19:10.204]  $ ...: list()
[13:19:10.204]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:10.204]  - attr(*, "where")=List of 1
[13:19:10.204]   ..$ ...:<environment: 0x562005900050> 
[13:19:10.204]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:10.204]  - attr(*, "resolved")= logi TRUE
[13:19:10.204]  - attr(*, "total_size")= num NA
[13:19:10.207]  - Getting '...' globals ... DONE
[13:19:10.207] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:10.207] List of 2
[13:19:10.207]  $ ...future.FUN:function (x)  
[13:19:10.207]  $ ...          : list()
[13:19:10.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:10.207]  - attr(*, "where")=List of 2
[13:19:10.207]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:10.207]   ..$ ...          :<environment: 0x562005900050> 
[13:19:10.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:10.207]  - attr(*, "resolved")= logi FALSE
[13:19:10.207]  - attr(*, "total_size")= num 4720
[13:19:10.210] Packages to be attached in all futures: [n=0] 
[13:19:10.210] getGlobalsAndPackagesXApply() ... DONE
[13:19:10.210] Number of futures (= number of chunks): 1
[13:19:10.210] Launching 1 futures (chunks) ...
[13:19:10.210] Chunk #1 of 1 ...
[13:19:10.210]  - Finding globals in 'X' for chunk #1 ...
[13:19:10.210] getGlobalsAndPackages() ...
[13:19:10.211] Searching for globals...
[13:19:10.211] 
[13:19:10.211] Searching for globals ... DONE
[13:19:10.211] - globals: [0] <none>
[13:19:10.211] getGlobalsAndPackages() ... DONE
[13:19:10.211]    + additional globals found: [n=0] 
[13:19:10.211]    + additional namespaces needed: [n=0] 
[13:19:10.211]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:10.211]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:10.212]  - seeds: <none>
[13:19:10.212] getGlobalsAndPackages() ...
[13:19:10.212] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:10.212] Resolving globals: FALSE
[13:19:10.212] Tweak future expression to call with '...' arguments ...
[13:19:10.212] {
[13:19:10.212]     do.call(function(...) {
[13:19:10.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:10.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:10.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:10.212]             on.exit(options(oopts), add = TRUE)
[13:19:10.212]         }
[13:19:10.212]         {
[13:19:10.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:10.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:10.212]                 ...future.FUN(...future.X_jj, ...)
[13:19:10.212]             })
[13:19:10.212]         }
[13:19:10.212]     }, args = future.call.arguments)
[13:19:10.212] }
[13:19:10.212] Tweak future expression to call with '...' arguments ... DONE
[13:19:10.213] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:10.213] 
[13:19:10.213] getGlobalsAndPackages() ... DONE
[13:19:10.213] run() for ‘Future’ ...
[13:19:10.213] - state: ‘created’
[13:19:10.213] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:10.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:10.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:10.214]   - Field: ‘label’
[13:19:10.214]   - Field: ‘local’
[13:19:10.214]   - Field: ‘owner’
[13:19:10.214]   - Field: ‘envir’
[13:19:10.214]   - Field: ‘packages’
[13:19:10.214]   - Field: ‘gc’
[13:19:10.214]   - Field: ‘conditions’
[13:19:10.215]   - Field: ‘expr’
[13:19:10.215]   - Field: ‘uuid’
[13:19:10.217]   - Field: ‘seed’
[13:19:10.217]   - Field: ‘version’
[13:19:10.217]   - Field: ‘result’
[13:19:10.217]   - Field: ‘asynchronous’
[13:19:10.217]   - Field: ‘calls’
[13:19:10.217]   - Field: ‘globals’
[13:19:10.217]   - Field: ‘stdout’
[13:19:10.217]   - Field: ‘earlySignal’
[13:19:10.217]   - Field: ‘lazy’
[13:19:10.217]   - Field: ‘state’
[13:19:10.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:10.218] - Launch lazy future ...
[13:19:10.218] Packages needed by the future expression (n = 0): <none>
[13:19:10.218] Packages needed by future strategies (n = 0): <none>
[13:19:10.218] {
[13:19:10.218]     {
[13:19:10.218]         {
[13:19:10.218]             ...future.startTime <- base::Sys.time()
[13:19:10.218]             {
[13:19:10.218]                 {
[13:19:10.218]                   {
[13:19:10.218]                     base::local({
[13:19:10.218]                       has_future <- base::requireNamespace("future", 
[13:19:10.218]                         quietly = TRUE)
[13:19:10.218]                       if (has_future) {
[13:19:10.218]                         ns <- base::getNamespace("future")
[13:19:10.218]                         version <- ns[[".package"]][["version"]]
[13:19:10.218]                         if (is.null(version)) 
[13:19:10.218]                           version <- utils::packageVersion("future")
[13:19:10.218]                       }
[13:19:10.218]                       else {
[13:19:10.218]                         version <- NULL
[13:19:10.218]                       }
[13:19:10.218]                       if (!has_future || version < "1.8.0") {
[13:19:10.218]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:10.218]                           "", base::R.version$version.string), 
[13:19:10.218]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:10.218]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:10.218]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:10.218]                             "release", "version")], collapse = " "), 
[13:19:10.218]                           hostname = base::Sys.info()[["nodename"]])
[13:19:10.218]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:10.218]                           info)
[13:19:10.218]                         info <- base::paste(info, collapse = "; ")
[13:19:10.218]                         if (!has_future) {
[13:19:10.218]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:10.218]                             info)
[13:19:10.218]                         }
[13:19:10.218]                         else {
[13:19:10.218]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:10.218]                             info, version)
[13:19:10.218]                         }
[13:19:10.218]                         base::stop(msg)
[13:19:10.218]                       }
[13:19:10.218]                     })
[13:19:10.218]                   }
[13:19:10.218]                   options(future.plan = NULL)
[13:19:10.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:10.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:10.218]                 }
[13:19:10.218]                 ...future.workdir <- getwd()
[13:19:10.218]             }
[13:19:10.218]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:10.218]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:10.218]         }
[13:19:10.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:10.218]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:10.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:10.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:10.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:10.218]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:10.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:10.218]             base::names(...future.oldOptions))
[13:19:10.218]     }
[13:19:10.218]     if (FALSE) {
[13:19:10.218]     }
[13:19:10.218]     else {
[13:19:10.218]         if (TRUE) {
[13:19:10.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:10.218]                 open = "w")
[13:19:10.218]         }
[13:19:10.218]         else {
[13:19:10.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:10.218]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:10.218]         }
[13:19:10.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:10.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:10.218]             base::sink(type = "output", split = FALSE)
[13:19:10.218]             base::close(...future.stdout)
[13:19:10.218]         }, add = TRUE)
[13:19:10.218]     }
[13:19:10.218]     ...future.frame <- base::sys.nframe()
[13:19:10.218]     ...future.conditions <- base::list()
[13:19:10.218]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:10.218]     if (FALSE) {
[13:19:10.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:10.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:10.218]     }
[13:19:10.218]     ...future.result <- base::tryCatch({
[13:19:10.218]         base::withCallingHandlers({
[13:19:10.218]             ...future.value <- base::withVisible(base::local({
[13:19:10.218]                 do.call(function(...) {
[13:19:10.218]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:10.218]                   if (!identical(...future.globals.maxSize.org, 
[13:19:10.218]                     ...future.globals.maxSize)) {
[13:19:10.218]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:10.218]                     on.exit(options(oopts), add = TRUE)
[13:19:10.218]                   }
[13:19:10.218]                   {
[13:19:10.218]                     lapply(seq_along(...future.elements_ii), 
[13:19:10.218]                       FUN = function(jj) {
[13:19:10.218]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:10.218]                         ...future.FUN(...future.X_jj, ...)
[13:19:10.218]                       })
[13:19:10.218]                   }
[13:19:10.218]                 }, args = future.call.arguments)
[13:19:10.218]             }))
[13:19:10.218]             future::FutureResult(value = ...future.value$value, 
[13:19:10.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:10.218]                   ...future.rng), globalenv = if (FALSE) 
[13:19:10.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:10.218]                     ...future.globalenv.names))
[13:19:10.218]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:10.218]         }, condition = base::local({
[13:19:10.218]             c <- base::c
[13:19:10.218]             inherits <- base::inherits
[13:19:10.218]             invokeRestart <- base::invokeRestart
[13:19:10.218]             length <- base::length
[13:19:10.218]             list <- base::list
[13:19:10.218]             seq.int <- base::seq.int
[13:19:10.218]             signalCondition <- base::signalCondition
[13:19:10.218]             sys.calls <- base::sys.calls
[13:19:10.218]             `[[` <- base::`[[`
[13:19:10.218]             `+` <- base::`+`
[13:19:10.218]             `<<-` <- base::`<<-`
[13:19:10.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:10.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:10.218]                   3L)]
[13:19:10.218]             }
[13:19:10.218]             function(cond) {
[13:19:10.218]                 is_error <- inherits(cond, "error")
[13:19:10.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:10.218]                   NULL)
[13:19:10.218]                 if (is_error) {
[13:19:10.218]                   sessionInformation <- function() {
[13:19:10.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:10.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:10.218]                       search = base::search(), system = base::Sys.info())
[13:19:10.218]                   }
[13:19:10.218]                   ...future.conditions[[length(...future.conditions) + 
[13:19:10.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:10.218]                     cond$call), session = sessionInformation(), 
[13:19:10.218]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:10.218]                   signalCondition(cond)
[13:19:10.218]                 }
[13:19:10.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:10.218]                 "immediateCondition"))) {
[13:19:10.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:10.218]                   ...future.conditions[[length(...future.conditions) + 
[13:19:10.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:10.218]                   if (TRUE && !signal) {
[13:19:10.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:10.218]                     {
[13:19:10.218]                       inherits <- base::inherits
[13:19:10.218]                       invokeRestart <- base::invokeRestart
[13:19:10.218]                       is.null <- base::is.null
[13:19:10.218]                       muffled <- FALSE
[13:19:10.218]                       if (inherits(cond, "message")) {
[13:19:10.218]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:10.218]                         if (muffled) 
[13:19:10.218]                           invokeRestart("muffleMessage")
[13:19:10.218]                       }
[13:19:10.218]                       else if (inherits(cond, "warning")) {
[13:19:10.218]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:10.218]                         if (muffled) 
[13:19:10.218]                           invokeRestart("muffleWarning")
[13:19:10.218]                       }
[13:19:10.218]                       else if (inherits(cond, "condition")) {
[13:19:10.218]                         if (!is.null(pattern)) {
[13:19:10.218]                           computeRestarts <- base::computeRestarts
[13:19:10.218]                           grepl <- base::grepl
[13:19:10.218]                           restarts <- computeRestarts(cond)
[13:19:10.218]                           for (restart in restarts) {
[13:19:10.218]                             name <- restart$name
[13:19:10.218]                             if (is.null(name)) 
[13:19:10.218]                               next
[13:19:10.218]                             if (!grepl(pattern, name)) 
[13:19:10.218]                               next
[13:19:10.218]                             invokeRestart(restart)
[13:19:10.218]                             muffled <- TRUE
[13:19:10.218]                             break
[13:19:10.218]                           }
[13:19:10.218]                         }
[13:19:10.218]                       }
[13:19:10.218]                       invisible(muffled)
[13:19:10.218]                     }
[13:19:10.218]                     muffleCondition(cond, pattern = "^muffle")
[13:19:10.218]                   }
[13:19:10.218]                 }
[13:19:10.218]                 else {
[13:19:10.218]                   if (TRUE) {
[13:19:10.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:10.218]                     {
[13:19:10.218]                       inherits <- base::inherits
[13:19:10.218]                       invokeRestart <- base::invokeRestart
[13:19:10.218]                       is.null <- base::is.null
[13:19:10.218]                       muffled <- FALSE
[13:19:10.218]                       if (inherits(cond, "message")) {
[13:19:10.218]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:10.218]                         if (muffled) 
[13:19:10.218]                           invokeRestart("muffleMessage")
[13:19:10.218]                       }
[13:19:10.218]                       else if (inherits(cond, "warning")) {
[13:19:10.218]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:10.218]                         if (muffled) 
[13:19:10.218]                           invokeRestart("muffleWarning")
[13:19:10.218]                       }
[13:19:10.218]                       else if (inherits(cond, "condition")) {
[13:19:10.218]                         if (!is.null(pattern)) {
[13:19:10.218]                           computeRestarts <- base::computeRestarts
[13:19:10.218]                           grepl <- base::grepl
[13:19:10.218]                           restarts <- computeRestarts(cond)
[13:19:10.218]                           for (restart in restarts) {
[13:19:10.218]                             name <- restart$name
[13:19:10.218]                             if (is.null(name)) 
[13:19:10.218]                               next
[13:19:10.218]                             if (!grepl(pattern, name)) 
[13:19:10.218]                               next
[13:19:10.218]                             invokeRestart(restart)
[13:19:10.218]                             muffled <- TRUE
[13:19:10.218]                             break
[13:19:10.218]                           }
[13:19:10.218]                         }
[13:19:10.218]                       }
[13:19:10.218]                       invisible(muffled)
[13:19:10.218]                     }
[13:19:10.218]                     muffleCondition(cond, pattern = "^muffle")
[13:19:10.218]                   }
[13:19:10.218]                 }
[13:19:10.218]             }
[13:19:10.218]         }))
[13:19:10.218]     }, error = function(ex) {
[13:19:10.218]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:10.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:10.218]                 ...future.rng), started = ...future.startTime, 
[13:19:10.218]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:10.218]             version = "1.8"), class = "FutureResult")
[13:19:10.218]     }, finally = {
[13:19:10.218]         if (!identical(...future.workdir, getwd())) 
[13:19:10.218]             setwd(...future.workdir)
[13:19:10.218]         {
[13:19:10.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:10.218]                 ...future.oldOptions$nwarnings <- NULL
[13:19:10.218]             }
[13:19:10.218]             base::options(...future.oldOptions)
[13:19:10.218]             if (.Platform$OS.type == "windows") {
[13:19:10.218]                 old_names <- names(...future.oldEnvVars)
[13:19:10.218]                 envs <- base::Sys.getenv()
[13:19:10.218]                 names <- names(envs)
[13:19:10.218]                 common <- intersect(names, old_names)
[13:19:10.218]                 added <- setdiff(names, old_names)
[13:19:10.218]                 removed <- setdiff(old_names, names)
[13:19:10.218]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:10.218]                   envs[common]]
[13:19:10.218]                 NAMES <- toupper(changed)
[13:19:10.218]                 args <- list()
[13:19:10.218]                 for (kk in seq_along(NAMES)) {
[13:19:10.218]                   name <- changed[[kk]]
[13:19:10.218]                   NAME <- NAMES[[kk]]
[13:19:10.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:10.218]                     next
[13:19:10.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:10.218]                 }
[13:19:10.218]                 NAMES <- toupper(added)
[13:19:10.218]                 for (kk in seq_along(NAMES)) {
[13:19:10.218]                   name <- added[[kk]]
[13:19:10.218]                   NAME <- NAMES[[kk]]
[13:19:10.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:10.218]                     next
[13:19:10.218]                   args[[name]] <- ""
[13:19:10.218]                 }
[13:19:10.218]                 NAMES <- toupper(removed)
[13:19:10.218]                 for (kk in seq_along(NAMES)) {
[13:19:10.218]                   name <- removed[[kk]]
[13:19:10.218]                   NAME <- NAMES[[kk]]
[13:19:10.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:10.218]                     next
[13:19:10.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:10.218]                 }
[13:19:10.218]                 if (length(args) > 0) 
[13:19:10.218]                   base::do.call(base::Sys.setenv, args = args)
[13:19:10.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:10.218]             }
[13:19:10.218]             else {
[13:19:10.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:10.218]             }
[13:19:10.218]             {
[13:19:10.218]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:10.218]                   0L) {
[13:19:10.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:10.218]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:10.218]                   base::options(opts)
[13:19:10.218]                 }
[13:19:10.218]                 {
[13:19:10.218]                   {
[13:19:10.218]                     NULL
[13:19:10.218]                     RNGkind("Mersenne-Twister")
[13:19:10.218]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:10.218]                       inherits = FALSE)
[13:19:10.218]                   }
[13:19:10.218]                   options(future.plan = NULL)
[13:19:10.218]                   if (is.na(NA_character_)) 
[13:19:10.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:10.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:10.218]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:10.218]                   {
[13:19:10.218]                     future <- SequentialFuture(..., envir = envir)
[13:19:10.218]                     if (!future$lazy) 
[13:19:10.218]                       future <- run(future)
[13:19:10.218]                     invisible(future)
[13:19:10.218]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:10.218]                 }
[13:19:10.218]             }
[13:19:10.218]         }
[13:19:10.218]     })
[13:19:10.218]     if (TRUE) {
[13:19:10.218]         base::sink(type = "output", split = FALSE)
[13:19:10.218]         if (TRUE) {
[13:19:10.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:10.218]         }
[13:19:10.218]         else {
[13:19:10.218]             ...future.result["stdout"] <- base::list(NULL)
[13:19:10.218]         }
[13:19:10.218]         base::close(...future.stdout)
[13:19:10.218]         ...future.stdout <- NULL
[13:19:10.218]     }
[13:19:10.218]     ...future.result$conditions <- ...future.conditions
[13:19:10.218]     ...future.result$finished <- base::Sys.time()
[13:19:10.218]     ...future.result
[13:19:10.218] }
[13:19:10.220] assign_globals() ...
[13:19:10.220] List of 5
[13:19:10.220]  $ ...future.FUN            :function (x)  
[13:19:10.220]  $ future.call.arguments    : list()
[13:19:10.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:10.220]  $ ...future.elements_ii    :List of 2
[13:19:10.220]   ..$ : int 1
[13:19:10.220]   ..$ : int 0
[13:19:10.220]  $ ...future.seeds_ii       : NULL
[13:19:10.220]  $ ...future.globals.maxSize: NULL
[13:19:10.220]  - attr(*, "resolved")= logi FALSE
[13:19:10.220]  - attr(*, "total_size")= num 4720
[13:19:10.220]  - attr(*, "where")=List of 5
[13:19:10.220]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:10.220]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:10.220]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:10.220]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:10.220]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:10.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:10.220]  - attr(*, "already-done")= logi TRUE
[13:19:10.225] - reassign environment for ‘...future.FUN’
[13:19:10.225] - copied ‘...future.FUN’ to environment
[13:19:10.225] - copied ‘future.call.arguments’ to environment
[13:19:10.225] - copied ‘...future.elements_ii’ to environment
[13:19:10.225] - copied ‘...future.seeds_ii’ to environment
[13:19:10.226] - copied ‘...future.globals.maxSize’ to environment
[13:19:10.226] assign_globals() ... done
[13:19:10.226] plan(): Setting new future strategy stack:
[13:19:10.226] List of future strategies:
[13:19:10.226] 1. sequential:
[13:19:10.226]    - args: function (..., envir = parent.frame())
[13:19:10.226]    - tweaked: FALSE
[13:19:10.226]    - call: NULL
[13:19:10.226] plan(): nbrOfWorkers() = 1
[13:19:10.728] plan(): Setting new future strategy stack:
[13:19:10.728] List of future strategies:
[13:19:10.728] 1. sequential:
[13:19:10.728]    - args: function (..., envir = parent.frame())
[13:19:10.728]    - tweaked: FALSE
[13:19:10.728]    - call: plan(strategy)
[13:19:10.729] plan(): nbrOfWorkers() = 1
[13:19:10.729] SequentialFuture started (and completed)
[13:19:10.729] - Launch lazy future ... done
[13:19:10.729] run() for ‘SequentialFuture’ ... done
[13:19:10.729] Created future:
[13:19:10.730] SequentialFuture:
[13:19:10.730] Label: ‘future_lapply-1’
[13:19:10.730] Expression:
[13:19:10.730] {
[13:19:10.730]     do.call(function(...) {
[13:19:10.730]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:10.730]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:10.730]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:10.730]             on.exit(options(oopts), add = TRUE)
[13:19:10.730]         }
[13:19:10.730]         {
[13:19:10.730]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:10.730]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:10.730]                 ...future.FUN(...future.X_jj, ...)
[13:19:10.730]             })
[13:19:10.730]         }
[13:19:10.730]     }, args = future.call.arguments)
[13:19:10.730] }
[13:19:10.730] Lazy evaluation: FALSE
[13:19:10.730] Asynchronous evaluation: FALSE
[13:19:10.730] Local evaluation: TRUE
[13:19:10.730] Environment: R_GlobalEnv
[13:19:10.730] Capture standard output: TRUE
[13:19:10.730] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:10.730] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:10.730] Packages: <none>
[13:19:10.730] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:10.730] Resolved: TRUE
[13:19:10.730] Value: 112 bytes of class ‘list’
[13:19:10.730] Early signaling: FALSE
[13:19:10.730] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:10.730] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:10.731] Chunk #1 of 1 ... DONE
[13:19:10.731] Launching 1 futures (chunks) ... DONE
[13:19:10.731] Resolving 1 futures (chunks) ...
[13:19:10.731] resolve() on list ...
[13:19:10.731]  recursive: 0
[13:19:10.731]  length: 1
[13:19:10.731] 
[13:19:10.731] resolved() for ‘SequentialFuture’ ...
[13:19:10.731] - state: ‘finished’
[13:19:10.732] - run: TRUE
[13:19:10.732] - result: ‘FutureResult’
[13:19:10.732] resolved() for ‘SequentialFuture’ ... done
[13:19:10.732] Future #1
[13:19:10.732] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:10.732] - nx: 1
[13:19:10.732] - relay: TRUE
[13:19:10.732] - stdout: TRUE
[13:19:10.732] - signal: TRUE
[13:19:10.732] - resignal: FALSE
[13:19:10.733] - force: TRUE
[13:19:10.733] - relayed: [n=1] FALSE
[13:19:10.733] - queued futures: [n=1] FALSE
[13:19:10.733]  - until=1
[13:19:10.733]  - relaying element #1
[13:19:10.733] - relayed: [n=1] TRUE
[13:19:10.733] - queued futures: [n=1] TRUE
[13:19:10.733] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:10.733]  length: 0 (resolved future 1)
[13:19:10.733] Relaying remaining futures
[13:19:10.734] signalConditionsASAP(NULL, pos=0) ...
[13:19:10.734] - nx: 1
[13:19:10.734] - relay: TRUE
[13:19:10.734] - stdout: TRUE
[13:19:10.734] - signal: TRUE
[13:19:10.734] - resignal: FALSE
[13:19:10.734] - force: TRUE
[13:19:10.734] - relayed: [n=1] TRUE
[13:19:10.734] - queued futures: [n=1] TRUE
 - flush all
[13:19:10.734] - relayed: [n=1] TRUE
[13:19:10.734] - queued futures: [n=1] TRUE
[13:19:10.735] signalConditionsASAP(NULL, pos=0) ... done
[13:19:10.735] resolve() on list ... DONE
[13:19:10.735]  - Number of value chunks collected: 1
[13:19:10.735] Resolving 1 futures (chunks) ... DONE
[13:19:10.735] Reducing values from 1 chunks ...
[13:19:10.735]  - Number of values collected after concatenation: 2
[13:19:10.735]  - Number of values expected: 2
[13:19:10.735] Reducing values from 1 chunks ... DONE
[13:19:10.735] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:19:10.736] future_lapply() ...
[13:19:10.736] Number of chunks: 1
[13:19:10.737] getGlobalsAndPackagesXApply() ...
[13:19:10.737]  - future.globals: TRUE
[13:19:10.737] getGlobalsAndPackages() ...
[13:19:10.737] Searching for globals...
[13:19:10.738] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:10.738] Searching for globals ... DONE
[13:19:10.738] Resolving globals: FALSE
[13:19:10.739] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:10.739] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:10.739] - globals: [1] ‘FUN’
[13:19:10.739] 
[13:19:10.740] getGlobalsAndPackages() ... DONE
[13:19:10.740]  - globals found/used: [n=1] ‘FUN’
[13:19:10.740]  - needed namespaces: [n=0] 
[13:19:10.740] Finding globals ... DONE
[13:19:10.740]  - use_args: TRUE
[13:19:10.740]  - Getting '...' globals ...
[13:19:10.740] resolve() on list ...
[13:19:10.740]  recursive: 0
[13:19:10.741]  length: 1
[13:19:10.741]  elements: ‘...’
[13:19:10.741]  length: 0 (resolved future 1)
[13:19:10.741] resolve() on list ... DONE
[13:19:10.741]    - '...' content: [n=0] 
[13:19:10.741] List of 1
[13:19:10.741]  $ ...: list()
[13:19:10.741]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:10.741]  - attr(*, "where")=List of 1
[13:19:10.741]   ..$ ...:<environment: 0x5620060e8998> 
[13:19:10.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:10.741]  - attr(*, "resolved")= logi TRUE
[13:19:10.741]  - attr(*, "total_size")= num NA
[13:19:10.745]  - Getting '...' globals ... DONE
[13:19:10.746] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:10.746] List of 2
[13:19:10.746]  $ ...future.FUN:function (x)  
[13:19:10.746]  $ ...          : list()
[13:19:10.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:10.746]  - attr(*, "where")=List of 2
[13:19:10.746]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:10.746]   ..$ ...          :<environment: 0x5620060e8998> 
[13:19:10.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:10.746]  - attr(*, "resolved")= logi FALSE
[13:19:10.746]  - attr(*, "total_size")= num 4720
[13:19:10.748] Packages to be attached in all futures: [n=0] 
[13:19:10.749] getGlobalsAndPackagesXApply() ... DONE
[13:19:10.749] Number of futures (= number of chunks): 1
[13:19:10.749] Launching 1 futures (chunks) ...
[13:19:10.749] Chunk #1 of 1 ...
[13:19:10.749]  - Finding globals in 'X' for chunk #1 ...
[13:19:10.749] getGlobalsAndPackages() ...
[13:19:10.749] Searching for globals...
[13:19:10.750] 
[13:19:10.750] Searching for globals ... DONE
[13:19:10.750] - globals: [0] <none>
[13:19:10.750] getGlobalsAndPackages() ... DONE
[13:19:10.750]    + additional globals found: [n=0] 
[13:19:10.750]    + additional namespaces needed: [n=0] 
[13:19:10.750]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:10.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:10.750]  - seeds: <none>
[13:19:10.750] getGlobalsAndPackages() ...
[13:19:10.751] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:10.751] Resolving globals: FALSE
[13:19:10.751] Tweak future expression to call with '...' arguments ...
[13:19:10.751] {
[13:19:10.751]     do.call(function(...) {
[13:19:10.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:10.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:10.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:10.751]             on.exit(options(oopts), add = TRUE)
[13:19:10.751]         }
[13:19:10.751]         {
[13:19:10.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:10.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:10.751]                 ...future.FUN(...future.X_jj, ...)
[13:19:10.751]             })
[13:19:10.751]         }
[13:19:10.751]     }, args = future.call.arguments)
[13:19:10.751] }
[13:19:10.751] Tweak future expression to call with '...' arguments ... DONE
[13:19:10.751] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:10.752] 
[13:19:10.752] getGlobalsAndPackages() ... DONE
[13:19:10.752] run() for ‘Future’ ...
[13:19:10.752] - state: ‘created’
[13:19:10.752] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:10.753] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:10.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:10.753]   - Field: ‘label’
[13:19:10.753]   - Field: ‘local’
[13:19:10.753]   - Field: ‘owner’
[13:19:10.753]   - Field: ‘envir’
[13:19:10.753]   - Field: ‘packages’
[13:19:10.753]   - Field: ‘gc’
[13:19:10.753]   - Field: ‘conditions’
[13:19:10.753]   - Field: ‘expr’
[13:19:10.754]   - Field: ‘uuid’
[13:19:10.754]   - Field: ‘seed’
[13:19:10.754]   - Field: ‘version’
[13:19:10.754]   - Field: ‘result’
[13:19:10.754]   - Field: ‘asynchronous’
[13:19:10.754]   - Field: ‘calls’
[13:19:10.754]   - Field: ‘globals’
[13:19:10.754]   - Field: ‘stdout’
[13:19:10.754]   - Field: ‘earlySignal’
[13:19:10.754]   - Field: ‘lazy’
[13:19:10.754]   - Field: ‘state’
[13:19:10.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:10.755] - Launch lazy future ...
[13:19:10.755] Packages needed by the future expression (n = 0): <none>
[13:19:10.755] Packages needed by future strategies (n = 0): <none>
[13:19:10.755] {
[13:19:10.755]     {
[13:19:10.755]         {
[13:19:10.755]             ...future.startTime <- base::Sys.time()
[13:19:10.755]             {
[13:19:10.755]                 {
[13:19:10.755]                   {
[13:19:10.755]                     base::local({
[13:19:10.755]                       has_future <- base::requireNamespace("future", 
[13:19:10.755]                         quietly = TRUE)
[13:19:10.755]                       if (has_future) {
[13:19:10.755]                         ns <- base::getNamespace("future")
[13:19:10.755]                         version <- ns[[".package"]][["version"]]
[13:19:10.755]                         if (is.null(version)) 
[13:19:10.755]                           version <- utils::packageVersion("future")
[13:19:10.755]                       }
[13:19:10.755]                       else {
[13:19:10.755]                         version <- NULL
[13:19:10.755]                       }
[13:19:10.755]                       if (!has_future || version < "1.8.0") {
[13:19:10.755]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:10.755]                           "", base::R.version$version.string), 
[13:19:10.755]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:10.755]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:10.755]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:10.755]                             "release", "version")], collapse = " "), 
[13:19:10.755]                           hostname = base::Sys.info()[["nodename"]])
[13:19:10.755]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:10.755]                           info)
[13:19:10.755]                         info <- base::paste(info, collapse = "; ")
[13:19:10.755]                         if (!has_future) {
[13:19:10.755]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:10.755]                             info)
[13:19:10.755]                         }
[13:19:10.755]                         else {
[13:19:10.755]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:10.755]                             info, version)
[13:19:10.755]                         }
[13:19:10.755]                         base::stop(msg)
[13:19:10.755]                       }
[13:19:10.755]                     })
[13:19:10.755]                   }
[13:19:10.755]                   options(future.plan = NULL)
[13:19:10.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:10.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:10.755]                 }
[13:19:10.755]                 ...future.workdir <- getwd()
[13:19:10.755]             }
[13:19:10.755]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:10.755]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:10.755]         }
[13:19:10.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:10.755]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:10.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:10.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:10.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:10.755]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:10.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:10.755]             base::names(...future.oldOptions))
[13:19:10.755]     }
[13:19:10.755]     if (TRUE) {
[13:19:10.755]     }
[13:19:10.755]     else {
[13:19:10.755]         if (NA) {
[13:19:10.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:10.755]                 open = "w")
[13:19:10.755]         }
[13:19:10.755]         else {
[13:19:10.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:10.755]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:10.755]         }
[13:19:10.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:10.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:10.755]             base::sink(type = "output", split = FALSE)
[13:19:10.755]             base::close(...future.stdout)
[13:19:10.755]         }, add = TRUE)
[13:19:10.755]     }
[13:19:10.755]     ...future.frame <- base::sys.nframe()
[13:19:10.755]     ...future.conditions <- base::list()
[13:19:10.755]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:10.755]     if (FALSE) {
[13:19:10.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:10.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:10.755]     }
[13:19:10.755]     ...future.result <- base::tryCatch({
[13:19:10.755]         base::withCallingHandlers({
[13:19:10.755]             ...future.value <- base::withVisible(base::local({
[13:19:10.755]                 do.call(function(...) {
[13:19:10.755]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:10.755]                   if (!identical(...future.globals.maxSize.org, 
[13:19:10.755]                     ...future.globals.maxSize)) {
[13:19:10.755]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:10.755]                     on.exit(options(oopts), add = TRUE)
[13:19:10.755]                   }
[13:19:10.755]                   {
[13:19:10.755]                     lapply(seq_along(...future.elements_ii), 
[13:19:10.755]                       FUN = function(jj) {
[13:19:10.755]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:10.755]                         ...future.FUN(...future.X_jj, ...)
[13:19:10.755]                       })
[13:19:10.755]                   }
[13:19:10.755]                 }, args = future.call.arguments)
[13:19:10.755]             }))
[13:19:10.755]             future::FutureResult(value = ...future.value$value, 
[13:19:10.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:10.755]                   ...future.rng), globalenv = if (FALSE) 
[13:19:10.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:10.755]                     ...future.globalenv.names))
[13:19:10.755]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:10.755]         }, condition = base::local({
[13:19:10.755]             c <- base::c
[13:19:10.755]             inherits <- base::inherits
[13:19:10.755]             invokeRestart <- base::invokeRestart
[13:19:10.755]             length <- base::length
[13:19:10.755]             list <- base::list
[13:19:10.755]             seq.int <- base::seq.int
[13:19:10.755]             signalCondition <- base::signalCondition
[13:19:10.755]             sys.calls <- base::sys.calls
[13:19:10.755]             `[[` <- base::`[[`
[13:19:10.755]             `+` <- base::`+`
[13:19:10.755]             `<<-` <- base::`<<-`
[13:19:10.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:10.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:10.755]                   3L)]
[13:19:10.755]             }
[13:19:10.755]             function(cond) {
[13:19:10.755]                 is_error <- inherits(cond, "error")
[13:19:10.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:10.755]                   NULL)
[13:19:10.755]                 if (is_error) {
[13:19:10.755]                   sessionInformation <- function() {
[13:19:10.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:10.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:10.755]                       search = base::search(), system = base::Sys.info())
[13:19:10.755]                   }
[13:19:10.755]                   ...future.conditions[[length(...future.conditions) + 
[13:19:10.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:10.755]                     cond$call), session = sessionInformation(), 
[13:19:10.755]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:10.755]                   signalCondition(cond)
[13:19:10.755]                 }
[13:19:10.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:10.755]                 "immediateCondition"))) {
[13:19:10.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:10.755]                   ...future.conditions[[length(...future.conditions) + 
[13:19:10.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:10.755]                   if (TRUE && !signal) {
[13:19:10.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:10.755]                     {
[13:19:10.755]                       inherits <- base::inherits
[13:19:10.755]                       invokeRestart <- base::invokeRestart
[13:19:10.755]                       is.null <- base::is.null
[13:19:10.755]                       muffled <- FALSE
[13:19:10.755]                       if (inherits(cond, "message")) {
[13:19:10.755]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:10.755]                         if (muffled) 
[13:19:10.755]                           invokeRestart("muffleMessage")
[13:19:10.755]                       }
[13:19:10.755]                       else if (inherits(cond, "warning")) {
[13:19:10.755]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:10.755]                         if (muffled) 
[13:19:10.755]                           invokeRestart("muffleWarning")
[13:19:10.755]                       }
[13:19:10.755]                       else if (inherits(cond, "condition")) {
[13:19:10.755]                         if (!is.null(pattern)) {
[13:19:10.755]                           computeRestarts <- base::computeRestarts
[13:19:10.755]                           grepl <- base::grepl
[13:19:10.755]                           restarts <- computeRestarts(cond)
[13:19:10.755]                           for (restart in restarts) {
[13:19:10.755]                             name <- restart$name
[13:19:10.755]                             if (is.null(name)) 
[13:19:10.755]                               next
[13:19:10.755]                             if (!grepl(pattern, name)) 
[13:19:10.755]                               next
[13:19:10.755]                             invokeRestart(restart)
[13:19:10.755]                             muffled <- TRUE
[13:19:10.755]                             break
[13:19:10.755]                           }
[13:19:10.755]                         }
[13:19:10.755]                       }
[13:19:10.755]                       invisible(muffled)
[13:19:10.755]                     }
[13:19:10.755]                     muffleCondition(cond, pattern = "^muffle")
[13:19:10.755]                   }
[13:19:10.755]                 }
[13:19:10.755]                 else {
[13:19:10.755]                   if (TRUE) {
[13:19:10.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:10.755]                     {
[13:19:10.755]                       inherits <- base::inherits
[13:19:10.755]                       invokeRestart <- base::invokeRestart
[13:19:10.755]                       is.null <- base::is.null
[13:19:10.755]                       muffled <- FALSE
[13:19:10.755]                       if (inherits(cond, "message")) {
[13:19:10.755]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:10.755]                         if (muffled) 
[13:19:10.755]                           invokeRestart("muffleMessage")
[13:19:10.755]                       }
[13:19:10.755]                       else if (inherits(cond, "warning")) {
[13:19:10.755]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:10.755]                         if (muffled) 
[13:19:10.755]                           invokeRestart("muffleWarning")
[13:19:10.755]                       }
[13:19:10.755]                       else if (inherits(cond, "condition")) {
[13:19:10.755]                         if (!is.null(pattern)) {
[13:19:10.755]                           computeRestarts <- base::computeRestarts
[13:19:10.755]                           grepl <- base::grepl
[13:19:10.755]                           restarts <- computeRestarts(cond)
[13:19:10.755]                           for (restart in restarts) {
[13:19:10.755]                             name <- restart$name
[13:19:10.755]                             if (is.null(name)) 
[13:19:10.755]                               next
[13:19:10.755]                             if (!grepl(pattern, name)) 
[13:19:10.755]                               next
[13:19:10.755]                             invokeRestart(restart)
[13:19:10.755]                             muffled <- TRUE
[13:19:10.755]                             break
[13:19:10.755]                           }
[13:19:10.755]                         }
[13:19:10.755]                       }
[13:19:10.755]                       invisible(muffled)
[13:19:10.755]                     }
[13:19:10.755]                     muffleCondition(cond, pattern = "^muffle")
[13:19:10.755]                   }
[13:19:10.755]                 }
[13:19:10.755]             }
[13:19:10.755]         }))
[13:19:10.755]     }, error = function(ex) {
[13:19:10.755]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:10.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:10.755]                 ...future.rng), started = ...future.startTime, 
[13:19:10.755]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:10.755]             version = "1.8"), class = "FutureResult")
[13:19:10.755]     }, finally = {
[13:19:10.755]         if (!identical(...future.workdir, getwd())) 
[13:19:10.755]             setwd(...future.workdir)
[13:19:10.755]         {
[13:19:10.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:10.755]                 ...future.oldOptions$nwarnings <- NULL
[13:19:10.755]             }
[13:19:10.755]             base::options(...future.oldOptions)
[13:19:10.755]             if (.Platform$OS.type == "windows") {
[13:19:10.755]                 old_names <- names(...future.oldEnvVars)
[13:19:10.755]                 envs <- base::Sys.getenv()
[13:19:10.755]                 names <- names(envs)
[13:19:10.755]                 common <- intersect(names, old_names)
[13:19:10.755]                 added <- setdiff(names, old_names)
[13:19:10.755]                 removed <- setdiff(old_names, names)
[13:19:10.755]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:10.755]                   envs[common]]
[13:19:10.755]                 NAMES <- toupper(changed)
[13:19:10.755]                 args <- list()
[13:19:10.755]                 for (kk in seq_along(NAMES)) {
[13:19:10.755]                   name <- changed[[kk]]
[13:19:10.755]                   NAME <- NAMES[[kk]]
[13:19:10.755]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:10.755]                     next
[13:19:10.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:10.755]                 }
[13:19:10.755]                 NAMES <- toupper(added)
[13:19:10.755]                 for (kk in seq_along(NAMES)) {
[13:19:10.755]                   name <- added[[kk]]
[13:19:10.755]                   NAME <- NAMES[[kk]]
[13:19:10.755]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:10.755]                     next
[13:19:10.755]                   args[[name]] <- ""
[13:19:10.755]                 }
[13:19:10.755]                 NAMES <- toupper(removed)
[13:19:10.755]                 for (kk in seq_along(NAMES)) {
[13:19:10.755]                   name <- removed[[kk]]
[13:19:10.755]                   NAME <- NAMES[[kk]]
[13:19:10.755]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:10.755]                     next
[13:19:10.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:10.755]                 }
[13:19:10.755]                 if (length(args) > 0) 
[13:19:10.755]                   base::do.call(base::Sys.setenv, args = args)
[13:19:10.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:10.755]             }
[13:19:10.755]             else {
[13:19:10.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:10.755]             }
[13:19:10.755]             {
[13:19:10.755]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:10.755]                   0L) {
[13:19:10.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:10.755]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:10.755]                   base::options(opts)
[13:19:10.755]                 }
[13:19:10.755]                 {
[13:19:10.755]                   {
[13:19:10.755]                     NULL
[13:19:10.755]                     RNGkind("Mersenne-Twister")
[13:19:10.755]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:10.755]                       inherits = FALSE)
[13:19:10.755]                   }
[13:19:10.755]                   options(future.plan = NULL)
[13:19:10.755]                   if (is.na(NA_character_)) 
[13:19:10.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:10.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:10.755]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:10.755]                   {
[13:19:10.755]                     future <- SequentialFuture(..., envir = envir)
[13:19:10.755]                     if (!future$lazy) 
[13:19:10.755]                       future <- run(future)
[13:19:10.755]                     invisible(future)
[13:19:10.755]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:10.755]                 }
[13:19:10.755]             }
[13:19:10.755]         }
[13:19:10.755]     })
[13:19:10.755]     if (FALSE) {
[13:19:10.755]         base::sink(type = "output", split = FALSE)
[13:19:10.755]         if (NA) {
[13:19:10.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:10.755]         }
[13:19:10.755]         else {
[13:19:10.755]             ...future.result["stdout"] <- base::list(NULL)
[13:19:10.755]         }
[13:19:10.755]         base::close(...future.stdout)
[13:19:10.755]         ...future.stdout <- NULL
[13:19:10.755]     }
[13:19:10.755]     ...future.result$conditions <- ...future.conditions
[13:19:10.755]     ...future.result$finished <- base::Sys.time()
[13:19:10.755]     ...future.result
[13:19:10.755] }
[13:19:10.757] assign_globals() ...
[13:19:10.757] List of 5
[13:19:10.757]  $ ...future.FUN            :function (x)  
[13:19:10.757]  $ future.call.arguments    : list()
[13:19:10.757]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:10.757]  $ ...future.elements_ii    :List of 2
[13:19:10.757]   ..$ : int 1
[13:19:10.757]   ..$ : int 0
[13:19:10.757]  $ ...future.seeds_ii       : NULL
[13:19:10.757]  $ ...future.globals.maxSize: NULL
[13:19:10.757]  - attr(*, "resolved")= logi FALSE
[13:19:10.757]  - attr(*, "total_size")= num 4720
[13:19:10.757]  - attr(*, "where")=List of 5
[13:19:10.757]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:10.757]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:10.757]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:10.757]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:10.757]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:10.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:10.757]  - attr(*, "already-done")= logi TRUE
[13:19:10.762] - reassign environment for ‘...future.FUN’
[13:19:10.762] - copied ‘...future.FUN’ to environment
[13:19:10.763] - copied ‘future.call.arguments’ to environment
[13:19:10.763] - copied ‘...future.elements_ii’ to environment
[13:19:10.763] - copied ‘...future.seeds_ii’ to environment
[13:19:10.763] - copied ‘...future.globals.maxSize’ to environment
[13:19:10.763] assign_globals() ... done
[13:19:10.763] plan(): Setting new future strategy stack:
[13:19:10.763] List of future strategies:
[13:19:10.763] 1. sequential:
[13:19:10.763]    - args: function (..., envir = parent.frame())
[13:19:10.763]    - tweaked: FALSE
[13:19:10.763]    - call: NULL
[13:19:10.764] plan(): nbrOfWorkers() = 1
[13:19:11.265] plan(): Setting new future strategy stack:
[13:19:11.266] List of future strategies:
[13:19:11.266] 1. sequential:
[13:19:11.266]    - args: function (..., envir = parent.frame())
[13:19:11.266]    - tweaked: FALSE
[13:19:11.266]    - call: plan(strategy)
[13:19:11.266] plan(): nbrOfWorkers() = 1
[13:19:11.266] SequentialFuture started (and completed)
[13:19:11.266] - Launch lazy future ... done
[13:19:11.266] run() for ‘SequentialFuture’ ... done
[13:19:11.267] Created future:
[13:19:11.267] SequentialFuture:
[13:19:11.267] Label: ‘future_lapply-1’
[13:19:11.267] Expression:
[13:19:11.267] {
[13:19:11.267]     do.call(function(...) {
[13:19:11.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:11.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:11.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:11.267]             on.exit(options(oopts), add = TRUE)
[13:19:11.267]         }
[13:19:11.267]         {
[13:19:11.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:11.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:11.267]                 ...future.FUN(...future.X_jj, ...)
[13:19:11.267]             })
[13:19:11.267]         }
[13:19:11.267]     }, args = future.call.arguments)
[13:19:11.267] }
[13:19:11.267] Lazy evaluation: FALSE
[13:19:11.267] Asynchronous evaluation: FALSE
[13:19:11.267] Local evaluation: TRUE
[13:19:11.267] Environment: R_GlobalEnv
[13:19:11.267] Capture standard output: NA
[13:19:11.267] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:11.267] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:11.267] Packages: <none>
[13:19:11.267] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:11.267] Resolved: TRUE
[13:19:11.267] Value: 112 bytes of class ‘list’
[13:19:11.267] Early signaling: FALSE
[13:19:11.267] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:11.267] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:11.268] Chunk #1 of 1 ... DONE
[13:19:11.268] Launching 1 futures (chunks) ... DONE
[13:19:11.268] Resolving 1 futures (chunks) ...
[13:19:11.268] resolve() on list ...
[13:19:11.268]  recursive: 0
[13:19:11.268]  length: 1
[13:19:11.268] 
[13:19:11.268] resolved() for ‘SequentialFuture’ ...
[13:19:11.269] - state: ‘finished’
[13:19:11.269] - run: TRUE
[13:19:11.269] - result: ‘FutureResult’
[13:19:11.269] resolved() for ‘SequentialFuture’ ... done
[13:19:11.269] Future #1
[13:19:11.269] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:11.269] - nx: 1
[13:19:11.269] - relay: TRUE
[13:19:11.269] - stdout: TRUE
[13:19:11.269] - signal: TRUE
[13:19:11.270] - resignal: FALSE
[13:19:11.270] - force: TRUE
[13:19:11.270] - relayed: [n=1] FALSE
[13:19:11.270] - queued futures: [n=1] FALSE
[13:19:11.270]  - until=1
[13:19:11.270]  - relaying element #1
[13:19:11.270] - relayed: [n=1] TRUE
[13:19:11.270] - queued futures: [n=1] TRUE
[13:19:11.270] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:11.270]  length: 0 (resolved future 1)
[13:19:11.272] Relaying remaining futures
[13:19:11.272] signalConditionsASAP(NULL, pos=0) ...
[13:19:11.272] - nx: 1
[13:19:11.273] - relay: TRUE
[13:19:11.273] - stdout: TRUE
[13:19:11.273] - signal: TRUE
[13:19:11.273] - resignal: FALSE
[13:19:11.273] - force: TRUE
[13:19:11.273] - relayed: [n=1] TRUE
[13:19:11.273] - queued futures: [n=1] TRUE
 - flush all
[13:19:11.273] - relayed: [n=1] TRUE
[13:19:11.273] - queued futures: [n=1] TRUE
[13:19:11.273] signalConditionsASAP(NULL, pos=0) ... done
[13:19:11.274] resolve() on list ... DONE
[13:19:11.274]  - Number of value chunks collected: 1
[13:19:11.274] Resolving 1 futures (chunks) ... DONE
[13:19:11.274] Reducing values from 1 chunks ...
[13:19:11.274]  - Number of values collected after concatenation: 2
[13:19:11.274]  - Number of values expected: 2
[13:19:11.274] Reducing values from 1 chunks ... DONE
[13:19:11.274] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:19:11.275] future_mapply() ...
[13:19:11.275] Number of chunks: 1
[13:19:11.275] getGlobalsAndPackagesXApply() ...
[13:19:11.275]  - future.globals: TRUE
[13:19:11.275] getGlobalsAndPackages() ...
[13:19:11.275] Searching for globals...
[13:19:11.277] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:11.277] Searching for globals ... DONE
[13:19:11.277] Resolving globals: FALSE
[13:19:11.277] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:11.278] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:11.278] - globals: [1] ‘FUN’
[13:19:11.278] 
[13:19:11.278] getGlobalsAndPackages() ... DONE
[13:19:11.278]  - globals found/used: [n=1] ‘FUN’
[13:19:11.278]  - needed namespaces: [n=0] 
[13:19:11.278] Finding globals ... DONE
[13:19:11.279] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:11.279] List of 2
[13:19:11.279]  $ ...future.FUN:function (x, y)  
[13:19:11.279]  $ MoreArgs     : NULL
[13:19:11.279]  - attr(*, "where")=List of 2
[13:19:11.279]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:11.279]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:11.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:11.279]  - attr(*, "resolved")= logi FALSE
[13:19:11.279]  - attr(*, "total_size")= num NA
[13:19:11.281] Packages to be attached in all futures: [n=0] 
[13:19:11.281] getGlobalsAndPackagesXApply() ... DONE
[13:19:11.282] Number of futures (= number of chunks): 1
[13:19:11.282] Launching 1 futures (chunks) ...
[13:19:11.282] Chunk #1 of 1 ...
[13:19:11.282]  - Finding globals in '...' for chunk #1 ...
[13:19:11.282] getGlobalsAndPackages() ...
[13:19:11.282] Searching for globals...
[13:19:11.282] 
[13:19:11.282] Searching for globals ... DONE
[13:19:11.283] - globals: [0] <none>
[13:19:11.283] getGlobalsAndPackages() ... DONE
[13:19:11.283]    + additional globals found: [n=0] 
[13:19:11.283]    + additional namespaces needed: [n=0] 
[13:19:11.283]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:11.283]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:11.283]  - seeds: <none>
[13:19:11.283] getGlobalsAndPackages() ...
[13:19:11.283] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:11.283] Resolving globals: FALSE
[13:19:11.284] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:11.284] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:11.285] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:11.285] 
[13:19:11.285] getGlobalsAndPackages() ... DONE
[13:19:11.285] run() for ‘Future’ ...
[13:19:11.285] - state: ‘created’
[13:19:11.285] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:11.286] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:11.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:11.286]   - Field: ‘label’
[13:19:11.286]   - Field: ‘local’
[13:19:11.286]   - Field: ‘owner’
[13:19:11.286]   - Field: ‘envir’
[13:19:11.286]   - Field: ‘packages’
[13:19:11.286]   - Field: ‘gc’
[13:19:11.286]   - Field: ‘conditions’
[13:19:11.286]   - Field: ‘expr’
[13:19:11.287]   - Field: ‘uuid’
[13:19:11.287]   - Field: ‘seed’
[13:19:11.287]   - Field: ‘version’
[13:19:11.287]   - Field: ‘result’
[13:19:11.287]   - Field: ‘asynchronous’
[13:19:11.287]   - Field: ‘calls’
[13:19:11.287]   - Field: ‘globals’
[13:19:11.287]   - Field: ‘stdout’
[13:19:11.287]   - Field: ‘earlySignal’
[13:19:11.287]   - Field: ‘lazy’
[13:19:11.287]   - Field: ‘state’
[13:19:11.288] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:11.288] - Launch lazy future ...
[13:19:11.288] Packages needed by the future expression (n = 0): <none>
[13:19:11.288] Packages needed by future strategies (n = 0): <none>
[13:19:11.288] {
[13:19:11.288]     {
[13:19:11.288]         {
[13:19:11.288]             ...future.startTime <- base::Sys.time()
[13:19:11.288]             {
[13:19:11.288]                 {
[13:19:11.288]                   {
[13:19:11.288]                     base::local({
[13:19:11.288]                       has_future <- base::requireNamespace("future", 
[13:19:11.288]                         quietly = TRUE)
[13:19:11.288]                       if (has_future) {
[13:19:11.288]                         ns <- base::getNamespace("future")
[13:19:11.288]                         version <- ns[[".package"]][["version"]]
[13:19:11.288]                         if (is.null(version)) 
[13:19:11.288]                           version <- utils::packageVersion("future")
[13:19:11.288]                       }
[13:19:11.288]                       else {
[13:19:11.288]                         version <- NULL
[13:19:11.288]                       }
[13:19:11.288]                       if (!has_future || version < "1.8.0") {
[13:19:11.288]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:11.288]                           "", base::R.version$version.string), 
[13:19:11.288]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:11.288]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:11.288]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:11.288]                             "release", "version")], collapse = " "), 
[13:19:11.288]                           hostname = base::Sys.info()[["nodename"]])
[13:19:11.288]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:11.288]                           info)
[13:19:11.288]                         info <- base::paste(info, collapse = "; ")
[13:19:11.288]                         if (!has_future) {
[13:19:11.288]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:11.288]                             info)
[13:19:11.288]                         }
[13:19:11.288]                         else {
[13:19:11.288]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:11.288]                             info, version)
[13:19:11.288]                         }
[13:19:11.288]                         base::stop(msg)
[13:19:11.288]                       }
[13:19:11.288]                     })
[13:19:11.288]                   }
[13:19:11.288]                   options(future.plan = NULL)
[13:19:11.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:11.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:11.288]                 }
[13:19:11.288]                 ...future.workdir <- getwd()
[13:19:11.288]             }
[13:19:11.288]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:11.288]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:11.288]         }
[13:19:11.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:11.288]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:11.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:11.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:11.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:11.288]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:11.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:11.288]             base::names(...future.oldOptions))
[13:19:11.288]     }
[13:19:11.288]     if (FALSE) {
[13:19:11.288]     }
[13:19:11.288]     else {
[13:19:11.288]         if (FALSE) {
[13:19:11.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:11.288]                 open = "w")
[13:19:11.288]         }
[13:19:11.288]         else {
[13:19:11.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:11.288]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:11.288]         }
[13:19:11.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:11.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:11.288]             base::sink(type = "output", split = FALSE)
[13:19:11.288]             base::close(...future.stdout)
[13:19:11.288]         }, add = TRUE)
[13:19:11.288]     }
[13:19:11.288]     ...future.frame <- base::sys.nframe()
[13:19:11.288]     ...future.conditions <- base::list()
[13:19:11.288]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:11.288]     if (FALSE) {
[13:19:11.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:11.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:11.288]     }
[13:19:11.288]     ...future.result <- base::tryCatch({
[13:19:11.288]         base::withCallingHandlers({
[13:19:11.288]             ...future.value <- base::withVisible(base::local({
[13:19:11.288]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:11.288]                 if (!identical(...future.globals.maxSize.org, 
[13:19:11.288]                   ...future.globals.maxSize)) {
[13:19:11.288]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:11.288]                   on.exit(options(oopts), add = TRUE)
[13:19:11.288]                 }
[13:19:11.288]                 {
[13:19:11.288]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:11.288]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:11.288]                     USE.NAMES = FALSE)
[13:19:11.288]                   do.call(mapply, args = args)
[13:19:11.288]                 }
[13:19:11.288]             }))
[13:19:11.288]             future::FutureResult(value = ...future.value$value, 
[13:19:11.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:11.288]                   ...future.rng), globalenv = if (FALSE) 
[13:19:11.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:11.288]                     ...future.globalenv.names))
[13:19:11.288]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:11.288]         }, condition = base::local({
[13:19:11.288]             c <- base::c
[13:19:11.288]             inherits <- base::inherits
[13:19:11.288]             invokeRestart <- base::invokeRestart
[13:19:11.288]             length <- base::length
[13:19:11.288]             list <- base::list
[13:19:11.288]             seq.int <- base::seq.int
[13:19:11.288]             signalCondition <- base::signalCondition
[13:19:11.288]             sys.calls <- base::sys.calls
[13:19:11.288]             `[[` <- base::`[[`
[13:19:11.288]             `+` <- base::`+`
[13:19:11.288]             `<<-` <- base::`<<-`
[13:19:11.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:11.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:11.288]                   3L)]
[13:19:11.288]             }
[13:19:11.288]             function(cond) {
[13:19:11.288]                 is_error <- inherits(cond, "error")
[13:19:11.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:11.288]                   NULL)
[13:19:11.288]                 if (is_error) {
[13:19:11.288]                   sessionInformation <- function() {
[13:19:11.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:11.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:11.288]                       search = base::search(), system = base::Sys.info())
[13:19:11.288]                   }
[13:19:11.288]                   ...future.conditions[[length(...future.conditions) + 
[13:19:11.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:11.288]                     cond$call), session = sessionInformation(), 
[13:19:11.288]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:11.288]                   signalCondition(cond)
[13:19:11.288]                 }
[13:19:11.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:11.288]                 "immediateCondition"))) {
[13:19:11.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:11.288]                   ...future.conditions[[length(...future.conditions) + 
[13:19:11.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:11.288]                   if (TRUE && !signal) {
[13:19:11.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:11.288]                     {
[13:19:11.288]                       inherits <- base::inherits
[13:19:11.288]                       invokeRestart <- base::invokeRestart
[13:19:11.288]                       is.null <- base::is.null
[13:19:11.288]                       muffled <- FALSE
[13:19:11.288]                       if (inherits(cond, "message")) {
[13:19:11.288]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:11.288]                         if (muffled) 
[13:19:11.288]                           invokeRestart("muffleMessage")
[13:19:11.288]                       }
[13:19:11.288]                       else if (inherits(cond, "warning")) {
[13:19:11.288]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:11.288]                         if (muffled) 
[13:19:11.288]                           invokeRestart("muffleWarning")
[13:19:11.288]                       }
[13:19:11.288]                       else if (inherits(cond, "condition")) {
[13:19:11.288]                         if (!is.null(pattern)) {
[13:19:11.288]                           computeRestarts <- base::computeRestarts
[13:19:11.288]                           grepl <- base::grepl
[13:19:11.288]                           restarts <- computeRestarts(cond)
[13:19:11.288]                           for (restart in restarts) {
[13:19:11.288]                             name <- restart$name
[13:19:11.288]                             if (is.null(name)) 
[13:19:11.288]                               next
[13:19:11.288]                             if (!grepl(pattern, name)) 
[13:19:11.288]                               next
[13:19:11.288]                             invokeRestart(restart)
[13:19:11.288]                             muffled <- TRUE
[13:19:11.288]                             break
[13:19:11.288]                           }
[13:19:11.288]                         }
[13:19:11.288]                       }
[13:19:11.288]                       invisible(muffled)
[13:19:11.288]                     }
[13:19:11.288]                     muffleCondition(cond, pattern = "^muffle")
[13:19:11.288]                   }
[13:19:11.288]                 }
[13:19:11.288]                 else {
[13:19:11.288]                   if (TRUE) {
[13:19:11.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:11.288]                     {
[13:19:11.288]                       inherits <- base::inherits
[13:19:11.288]                       invokeRestart <- base::invokeRestart
[13:19:11.288]                       is.null <- base::is.null
[13:19:11.288]                       muffled <- FALSE
[13:19:11.288]                       if (inherits(cond, "message")) {
[13:19:11.288]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:11.288]                         if (muffled) 
[13:19:11.288]                           invokeRestart("muffleMessage")
[13:19:11.288]                       }
[13:19:11.288]                       else if (inherits(cond, "warning")) {
[13:19:11.288]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:11.288]                         if (muffled) 
[13:19:11.288]                           invokeRestart("muffleWarning")
[13:19:11.288]                       }
[13:19:11.288]                       else if (inherits(cond, "condition")) {
[13:19:11.288]                         if (!is.null(pattern)) {
[13:19:11.288]                           computeRestarts <- base::computeRestarts
[13:19:11.288]                           grepl <- base::grepl
[13:19:11.288]                           restarts <- computeRestarts(cond)
[13:19:11.288]                           for (restart in restarts) {
[13:19:11.288]                             name <- restart$name
[13:19:11.288]                             if (is.null(name)) 
[13:19:11.288]                               next
[13:19:11.288]                             if (!grepl(pattern, name)) 
[13:19:11.288]                               next
[13:19:11.288]                             invokeRestart(restart)
[13:19:11.288]                             muffled <- TRUE
[13:19:11.288]                             break
[13:19:11.288]                           }
[13:19:11.288]                         }
[13:19:11.288]                       }
[13:19:11.288]                       invisible(muffled)
[13:19:11.288]                     }
[13:19:11.288]                     muffleCondition(cond, pattern = "^muffle")
[13:19:11.288]                   }
[13:19:11.288]                 }
[13:19:11.288]             }
[13:19:11.288]         }))
[13:19:11.288]     }, error = function(ex) {
[13:19:11.288]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:11.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:11.288]                 ...future.rng), started = ...future.startTime, 
[13:19:11.288]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:11.288]             version = "1.8"), class = "FutureResult")
[13:19:11.288]     }, finally = {
[13:19:11.288]         if (!identical(...future.workdir, getwd())) 
[13:19:11.288]             setwd(...future.workdir)
[13:19:11.288]         {
[13:19:11.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:11.288]                 ...future.oldOptions$nwarnings <- NULL
[13:19:11.288]             }
[13:19:11.288]             base::options(...future.oldOptions)
[13:19:11.288]             if (.Platform$OS.type == "windows") {
[13:19:11.288]                 old_names <- names(...future.oldEnvVars)
[13:19:11.288]                 envs <- base::Sys.getenv()
[13:19:11.288]                 names <- names(envs)
[13:19:11.288]                 common <- intersect(names, old_names)
[13:19:11.288]                 added <- setdiff(names, old_names)
[13:19:11.288]                 removed <- setdiff(old_names, names)
[13:19:11.288]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:11.288]                   envs[common]]
[13:19:11.288]                 NAMES <- toupper(changed)
[13:19:11.288]                 args <- list()
[13:19:11.288]                 for (kk in seq_along(NAMES)) {
[13:19:11.288]                   name <- changed[[kk]]
[13:19:11.288]                   NAME <- NAMES[[kk]]
[13:19:11.288]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:11.288]                     next
[13:19:11.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:11.288]                 }
[13:19:11.288]                 NAMES <- toupper(added)
[13:19:11.288]                 for (kk in seq_along(NAMES)) {
[13:19:11.288]                   name <- added[[kk]]
[13:19:11.288]                   NAME <- NAMES[[kk]]
[13:19:11.288]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:11.288]                     next
[13:19:11.288]                   args[[name]] <- ""
[13:19:11.288]                 }
[13:19:11.288]                 NAMES <- toupper(removed)
[13:19:11.288]                 for (kk in seq_along(NAMES)) {
[13:19:11.288]                   name <- removed[[kk]]
[13:19:11.288]                   NAME <- NAMES[[kk]]
[13:19:11.288]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:11.288]                     next
[13:19:11.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:11.288]                 }
[13:19:11.288]                 if (length(args) > 0) 
[13:19:11.288]                   base::do.call(base::Sys.setenv, args = args)
[13:19:11.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:11.288]             }
[13:19:11.288]             else {
[13:19:11.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:11.288]             }
[13:19:11.288]             {
[13:19:11.288]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:11.288]                   0L) {
[13:19:11.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:11.288]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:11.288]                   base::options(opts)
[13:19:11.288]                 }
[13:19:11.288]                 {
[13:19:11.288]                   {
[13:19:11.288]                     NULL
[13:19:11.288]                     RNGkind("Mersenne-Twister")
[13:19:11.288]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:11.288]                       inherits = FALSE)
[13:19:11.288]                   }
[13:19:11.288]                   options(future.plan = NULL)
[13:19:11.288]                   if (is.na(NA_character_)) 
[13:19:11.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:11.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:11.288]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:11.288]                   {
[13:19:11.288]                     future <- SequentialFuture(..., envir = envir)
[13:19:11.288]                     if (!future$lazy) 
[13:19:11.288]                       future <- run(future)
[13:19:11.288]                     invisible(future)
[13:19:11.288]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:11.288]                 }
[13:19:11.288]             }
[13:19:11.288]         }
[13:19:11.288]     })
[13:19:11.288]     if (TRUE) {
[13:19:11.288]         base::sink(type = "output", split = FALSE)
[13:19:11.288]         if (FALSE) {
[13:19:11.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:11.288]         }
[13:19:11.288]         else {
[13:19:11.288]             ...future.result["stdout"] <- base::list(NULL)
[13:19:11.288]         }
[13:19:11.288]         base::close(...future.stdout)
[13:19:11.288]         ...future.stdout <- NULL
[13:19:11.288]     }
[13:19:11.288]     ...future.result$conditions <- ...future.conditions
[13:19:11.288]     ...future.result$finished <- base::Sys.time()
[13:19:11.288]     ...future.result
[13:19:11.288] }
[13:19:11.290] assign_globals() ...
[13:19:11.290] List of 5
[13:19:11.290]  $ ...future.FUN            :function (x, y)  
[13:19:11.290]  $ MoreArgs                 : NULL
[13:19:11.290]  $ ...future.elements_ii    :List of 2
[13:19:11.290]   ..$ :List of 2
[13:19:11.290]   .. ..$ : int 1
[13:19:11.290]   .. ..$ : int 0
[13:19:11.290]   ..$ :List of 2
[13:19:11.290]   .. ..$ : int 0
[13:19:11.290]   .. ..$ : int 1
[13:19:11.290]  $ ...future.seeds_ii       : NULL
[13:19:11.290]  $ ...future.globals.maxSize: NULL
[13:19:11.290]  - attr(*, "resolved")= logi FALSE
[13:19:11.290]  - attr(*, "total_size")= num 6480
[13:19:11.290]  - attr(*, "where")=List of 5
[13:19:11.290]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:11.290]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:11.290]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:11.290]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:11.290]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:11.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:11.290]  - attr(*, "already-done")= logi TRUE
[13:19:11.296] - reassign environment for ‘...future.FUN’
[13:19:11.296] - copied ‘...future.FUN’ to environment
[13:19:11.296] - copied ‘MoreArgs’ to environment
[13:19:11.296] - copied ‘...future.elements_ii’ to environment
[13:19:11.298] - copied ‘...future.seeds_ii’ to environment
[13:19:11.298] - copied ‘...future.globals.maxSize’ to environment
[13:19:11.298] assign_globals() ... done
[13:19:11.298] plan(): Setting new future strategy stack:
[13:19:11.298] List of future strategies:
[13:19:11.298] 1. sequential:
[13:19:11.298]    - args: function (..., envir = parent.frame())
[13:19:11.298]    - tweaked: FALSE
[13:19:11.298]    - call: NULL
[13:19:11.299] plan(): nbrOfWorkers() = 1
[13:19:11.801] plan(): Setting new future strategy stack:
[13:19:11.801] List of future strategies:
[13:19:11.801] 1. sequential:
[13:19:11.801]    - args: function (..., envir = parent.frame())
[13:19:11.801]    - tweaked: FALSE
[13:19:11.801]    - call: plan(strategy)
[13:19:11.801] plan(): nbrOfWorkers() = 1
[13:19:11.801] SequentialFuture started (and completed)
[13:19:11.802] - Launch lazy future ... done
[13:19:11.802] run() for ‘SequentialFuture’ ... done
[13:19:11.802] Created future:
[13:19:11.802] SequentialFuture:
[13:19:11.802] Label: ‘future_mapply-1’
[13:19:11.802] Expression:
[13:19:11.802] {
[13:19:11.802]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:11.802]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:11.802]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:11.802]         on.exit(options(oopts), add = TRUE)
[13:19:11.802]     }
[13:19:11.802]     {
[13:19:11.802]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:11.802]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:11.802]         do.call(mapply, args = args)
[13:19:11.802]     }
[13:19:11.802] }
[13:19:11.802] Lazy evaluation: FALSE
[13:19:11.802] Asynchronous evaluation: FALSE
[13:19:11.802] Local evaluation: TRUE
[13:19:11.802] Environment: R_GlobalEnv
[13:19:11.802] Capture standard output: FALSE
[13:19:11.802] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:11.802] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:11.802] Packages: <none>
[13:19:11.802] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:11.802] Resolved: TRUE
[13:19:11.802] Value: 224 bytes of class ‘list’
[13:19:11.802] Early signaling: FALSE
[13:19:11.802] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:11.802] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:11.803] Chunk #1 of 1 ... DONE
[13:19:11.803] Launching 1 futures (chunks) ... DONE
[13:19:11.803] Resolving 1 futures (chunks) ...
[13:19:11.803] resolve() on list ...
[13:19:11.803]  recursive: 0
[13:19:11.803]  length: 1
[13:19:11.804] 
[13:19:11.804] resolved() for ‘SequentialFuture’ ...
[13:19:11.804] - state: ‘finished’
[13:19:11.804] - run: TRUE
[13:19:11.804] - result: ‘FutureResult’
[13:19:11.804] resolved() for ‘SequentialFuture’ ... done
[13:19:11.804] Future #1
[13:19:11.804] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:11.804] - nx: 1
[13:19:11.804] - relay: TRUE
[13:19:11.805] - stdout: TRUE
[13:19:11.805] - signal: TRUE
[13:19:11.805] - resignal: FALSE
[13:19:11.805] - force: TRUE
[13:19:11.805] - relayed: [n=1] FALSE
[13:19:11.805] - queued futures: [n=1] FALSE
[13:19:11.805]  - until=1
[13:19:11.805]  - relaying element #1
[13:19:11.805] - relayed: [n=1] TRUE
[13:19:11.805] - queued futures: [n=1] TRUE
[13:19:11.806] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:11.806]  length: 0 (resolved future 1)
[13:19:11.806] Relaying remaining futures
[13:19:11.806] signalConditionsASAP(NULL, pos=0) ...
[13:19:11.806] - nx: 1
[13:19:11.806] - relay: TRUE
[13:19:11.806] - stdout: TRUE
[13:19:11.806] - signal: TRUE
[13:19:11.806] - resignal: FALSE
[13:19:11.806] - force: TRUE
[13:19:11.806] - relayed: [n=1] TRUE
[13:19:11.806] - queued futures: [n=1] TRUE
 - flush all
[13:19:11.807] - relayed: [n=1] TRUE
[13:19:11.807] - queued futures: [n=1] TRUE
[13:19:11.807] signalConditionsASAP(NULL, pos=0) ... done
[13:19:11.807] resolve() on list ... DONE
[13:19:11.807]  - Number of value chunks collected: 1
[13:19:11.807] Resolving 1 futures (chunks) ... DONE
[13:19:11.807] Reducing values from 1 chunks ...
[13:19:11.807]  - Number of values collected after concatenation: 2
[13:19:11.807]  - Number of values expected: 2
[13:19:11.807] Reducing values from 1 chunks ... DONE
[13:19:11.808] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:19:11.808] future_mapply() ...
[13:19:11.808] Number of chunks: 1
[13:19:11.808] getGlobalsAndPackagesXApply() ...
[13:19:11.808]  - future.globals: TRUE
[13:19:11.808] getGlobalsAndPackages() ...
[13:19:11.809] Searching for globals...
[13:19:11.810] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:11.810] Searching for globals ... DONE
[13:19:11.810] Resolving globals: FALSE
[13:19:11.811] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:11.811] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:11.811] - globals: [1] ‘FUN’
[13:19:11.811] 
[13:19:11.811] getGlobalsAndPackages() ... DONE
[13:19:11.811]  - globals found/used: [n=1] ‘FUN’
[13:19:11.812]  - needed namespaces: [n=0] 
[13:19:11.812] Finding globals ... DONE
[13:19:11.812] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:11.812] List of 2
[13:19:11.812]  $ ...future.FUN:function (x, y)  
[13:19:11.812]  $ MoreArgs     : NULL
[13:19:11.812]  - attr(*, "where")=List of 2
[13:19:11.812]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:11.812]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:11.812]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:11.812]  - attr(*, "resolved")= logi FALSE
[13:19:11.812]  - attr(*, "total_size")= num NA
[13:19:11.814] Packages to be attached in all futures: [n=0] 
[13:19:11.815] getGlobalsAndPackagesXApply() ... DONE
[13:19:11.815] Number of futures (= number of chunks): 1
[13:19:11.815] Launching 1 futures (chunks) ...
[13:19:11.815] Chunk #1 of 1 ...
[13:19:11.815]  - Finding globals in '...' for chunk #1 ...
[13:19:11.815] getGlobalsAndPackages() ...
[13:19:11.815] Searching for globals...
[13:19:11.816] 
[13:19:11.816] Searching for globals ... DONE
[13:19:11.816] - globals: [0] <none>
[13:19:11.816] getGlobalsAndPackages() ... DONE
[13:19:11.816]    + additional globals found: [n=0] 
[13:19:11.816]    + additional namespaces needed: [n=0] 
[13:19:11.816]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:11.816]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:11.816]  - seeds: <none>
[13:19:11.816] getGlobalsAndPackages() ...
[13:19:11.817] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:11.817] Resolving globals: FALSE
[13:19:11.817] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:11.818] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:11.818] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:11.818] 
[13:19:11.818] getGlobalsAndPackages() ... DONE
[13:19:11.818] run() for ‘Future’ ...
[13:19:11.818] - state: ‘created’
[13:19:11.818] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:11.819] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:11.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:11.819]   - Field: ‘label’
[13:19:11.819]   - Field: ‘local’
[13:19:11.819]   - Field: ‘owner’
[13:19:11.819]   - Field: ‘envir’
[13:19:11.819]   - Field: ‘packages’
[13:19:11.819]   - Field: ‘gc’
[13:19:11.819]   - Field: ‘conditions’
[13:19:11.820]   - Field: ‘expr’
[13:19:11.820]   - Field: ‘uuid’
[13:19:11.820]   - Field: ‘seed’
[13:19:11.820]   - Field: ‘version’
[13:19:11.820]   - Field: ‘result’
[13:19:11.820]   - Field: ‘asynchronous’
[13:19:11.820]   - Field: ‘calls’
[13:19:11.820]   - Field: ‘globals’
[13:19:11.820]   - Field: ‘stdout’
[13:19:11.820]   - Field: ‘earlySignal’
[13:19:11.820]   - Field: ‘lazy’
[13:19:11.821]   - Field: ‘state’
[13:19:11.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:11.821] - Launch lazy future ...
[13:19:11.821] Packages needed by the future expression (n = 0): <none>
[13:19:11.821] Packages needed by future strategies (n = 0): <none>
[13:19:11.821] {
[13:19:11.821]     {
[13:19:11.821]         {
[13:19:11.821]             ...future.startTime <- base::Sys.time()
[13:19:11.821]             {
[13:19:11.821]                 {
[13:19:11.821]                   {
[13:19:11.821]                     base::local({
[13:19:11.821]                       has_future <- base::requireNamespace("future", 
[13:19:11.821]                         quietly = TRUE)
[13:19:11.821]                       if (has_future) {
[13:19:11.821]                         ns <- base::getNamespace("future")
[13:19:11.821]                         version <- ns[[".package"]][["version"]]
[13:19:11.821]                         if (is.null(version)) 
[13:19:11.821]                           version <- utils::packageVersion("future")
[13:19:11.821]                       }
[13:19:11.821]                       else {
[13:19:11.821]                         version <- NULL
[13:19:11.821]                       }
[13:19:11.821]                       if (!has_future || version < "1.8.0") {
[13:19:11.821]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:11.821]                           "", base::R.version$version.string), 
[13:19:11.821]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:11.821]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:11.821]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:11.821]                             "release", "version")], collapse = " "), 
[13:19:11.821]                           hostname = base::Sys.info()[["nodename"]])
[13:19:11.821]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:11.821]                           info)
[13:19:11.821]                         info <- base::paste(info, collapse = "; ")
[13:19:11.821]                         if (!has_future) {
[13:19:11.821]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:11.821]                             info)
[13:19:11.821]                         }
[13:19:11.821]                         else {
[13:19:11.821]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:11.821]                             info, version)
[13:19:11.821]                         }
[13:19:11.821]                         base::stop(msg)
[13:19:11.821]                       }
[13:19:11.821]                     })
[13:19:11.821]                   }
[13:19:11.821]                   options(future.plan = NULL)
[13:19:11.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:11.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:11.821]                 }
[13:19:11.821]                 ...future.workdir <- getwd()
[13:19:11.821]             }
[13:19:11.821]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:11.821]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:11.821]         }
[13:19:11.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:11.821]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:11.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:11.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:11.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:11.821]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:11.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:11.821]             base::names(...future.oldOptions))
[13:19:11.821]     }
[13:19:11.821]     if (FALSE) {
[13:19:11.821]     }
[13:19:11.821]     else {
[13:19:11.821]         if (TRUE) {
[13:19:11.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:11.821]                 open = "w")
[13:19:11.821]         }
[13:19:11.821]         else {
[13:19:11.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:11.821]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:11.821]         }
[13:19:11.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:11.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:11.821]             base::sink(type = "output", split = FALSE)
[13:19:11.821]             base::close(...future.stdout)
[13:19:11.821]         }, add = TRUE)
[13:19:11.821]     }
[13:19:11.821]     ...future.frame <- base::sys.nframe()
[13:19:11.821]     ...future.conditions <- base::list()
[13:19:11.821]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:11.821]     if (FALSE) {
[13:19:11.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:11.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:11.821]     }
[13:19:11.821]     ...future.result <- base::tryCatch({
[13:19:11.821]         base::withCallingHandlers({
[13:19:11.821]             ...future.value <- base::withVisible(base::local({
[13:19:11.821]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:11.821]                 if (!identical(...future.globals.maxSize.org, 
[13:19:11.821]                   ...future.globals.maxSize)) {
[13:19:11.821]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:11.821]                   on.exit(options(oopts), add = TRUE)
[13:19:11.821]                 }
[13:19:11.821]                 {
[13:19:11.821]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:11.821]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:11.821]                     USE.NAMES = FALSE)
[13:19:11.821]                   do.call(mapply, args = args)
[13:19:11.821]                 }
[13:19:11.821]             }))
[13:19:11.821]             future::FutureResult(value = ...future.value$value, 
[13:19:11.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:11.821]                   ...future.rng), globalenv = if (FALSE) 
[13:19:11.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:11.821]                     ...future.globalenv.names))
[13:19:11.821]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:11.821]         }, condition = base::local({
[13:19:11.821]             c <- base::c
[13:19:11.821]             inherits <- base::inherits
[13:19:11.821]             invokeRestart <- base::invokeRestart
[13:19:11.821]             length <- base::length
[13:19:11.821]             list <- base::list
[13:19:11.821]             seq.int <- base::seq.int
[13:19:11.821]             signalCondition <- base::signalCondition
[13:19:11.821]             sys.calls <- base::sys.calls
[13:19:11.821]             `[[` <- base::`[[`
[13:19:11.821]             `+` <- base::`+`
[13:19:11.821]             `<<-` <- base::`<<-`
[13:19:11.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:11.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:11.821]                   3L)]
[13:19:11.821]             }
[13:19:11.821]             function(cond) {
[13:19:11.821]                 is_error <- inherits(cond, "error")
[13:19:11.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:11.821]                   NULL)
[13:19:11.821]                 if (is_error) {
[13:19:11.821]                   sessionInformation <- function() {
[13:19:11.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:11.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:11.821]                       search = base::search(), system = base::Sys.info())
[13:19:11.821]                   }
[13:19:11.821]                   ...future.conditions[[length(...future.conditions) + 
[13:19:11.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:11.821]                     cond$call), session = sessionInformation(), 
[13:19:11.821]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:11.821]                   signalCondition(cond)
[13:19:11.821]                 }
[13:19:11.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:11.821]                 "immediateCondition"))) {
[13:19:11.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:11.821]                   ...future.conditions[[length(...future.conditions) + 
[13:19:11.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:11.821]                   if (TRUE && !signal) {
[13:19:11.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:11.821]                     {
[13:19:11.821]                       inherits <- base::inherits
[13:19:11.821]                       invokeRestart <- base::invokeRestart
[13:19:11.821]                       is.null <- base::is.null
[13:19:11.821]                       muffled <- FALSE
[13:19:11.821]                       if (inherits(cond, "message")) {
[13:19:11.821]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:11.821]                         if (muffled) 
[13:19:11.821]                           invokeRestart("muffleMessage")
[13:19:11.821]                       }
[13:19:11.821]                       else if (inherits(cond, "warning")) {
[13:19:11.821]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:11.821]                         if (muffled) 
[13:19:11.821]                           invokeRestart("muffleWarning")
[13:19:11.821]                       }
[13:19:11.821]                       else if (inherits(cond, "condition")) {
[13:19:11.821]                         if (!is.null(pattern)) {
[13:19:11.821]                           computeRestarts <- base::computeRestarts
[13:19:11.821]                           grepl <- base::grepl
[13:19:11.821]                           restarts <- computeRestarts(cond)
[13:19:11.821]                           for (restart in restarts) {
[13:19:11.821]                             name <- restart$name
[13:19:11.821]                             if (is.null(name)) 
[13:19:11.821]                               next
[13:19:11.821]                             if (!grepl(pattern, name)) 
[13:19:11.821]                               next
[13:19:11.821]                             invokeRestart(restart)
[13:19:11.821]                             muffled <- TRUE
[13:19:11.821]                             break
[13:19:11.821]                           }
[13:19:11.821]                         }
[13:19:11.821]                       }
[13:19:11.821]                       invisible(muffled)
[13:19:11.821]                     }
[13:19:11.821]                     muffleCondition(cond, pattern = "^muffle")
[13:19:11.821]                   }
[13:19:11.821]                 }
[13:19:11.821]                 else {
[13:19:11.821]                   if (TRUE) {
[13:19:11.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:11.821]                     {
[13:19:11.821]                       inherits <- base::inherits
[13:19:11.821]                       invokeRestart <- base::invokeRestart
[13:19:11.821]                       is.null <- base::is.null
[13:19:11.821]                       muffled <- FALSE
[13:19:11.821]                       if (inherits(cond, "message")) {
[13:19:11.821]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:11.821]                         if (muffled) 
[13:19:11.821]                           invokeRestart("muffleMessage")
[13:19:11.821]                       }
[13:19:11.821]                       else if (inherits(cond, "warning")) {
[13:19:11.821]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:11.821]                         if (muffled) 
[13:19:11.821]                           invokeRestart("muffleWarning")
[13:19:11.821]                       }
[13:19:11.821]                       else if (inherits(cond, "condition")) {
[13:19:11.821]                         if (!is.null(pattern)) {
[13:19:11.821]                           computeRestarts <- base::computeRestarts
[13:19:11.821]                           grepl <- base::grepl
[13:19:11.821]                           restarts <- computeRestarts(cond)
[13:19:11.821]                           for (restart in restarts) {
[13:19:11.821]                             name <- restart$name
[13:19:11.821]                             if (is.null(name)) 
[13:19:11.821]                               next
[13:19:11.821]                             if (!grepl(pattern, name)) 
[13:19:11.821]                               next
[13:19:11.821]                             invokeRestart(restart)
[13:19:11.821]                             muffled <- TRUE
[13:19:11.821]                             break
[13:19:11.821]                           }
[13:19:11.821]                         }
[13:19:11.821]                       }
[13:19:11.821]                       invisible(muffled)
[13:19:11.821]                     }
[13:19:11.821]                     muffleCondition(cond, pattern = "^muffle")
[13:19:11.821]                   }
[13:19:11.821]                 }
[13:19:11.821]             }
[13:19:11.821]         }))
[13:19:11.821]     }, error = function(ex) {
[13:19:11.821]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:11.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:11.821]                 ...future.rng), started = ...future.startTime, 
[13:19:11.821]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:11.821]             version = "1.8"), class = "FutureResult")
[13:19:11.821]     }, finally = {
[13:19:11.821]         if (!identical(...future.workdir, getwd())) 
[13:19:11.821]             setwd(...future.workdir)
[13:19:11.821]         {
[13:19:11.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:11.821]                 ...future.oldOptions$nwarnings <- NULL
[13:19:11.821]             }
[13:19:11.821]             base::options(...future.oldOptions)
[13:19:11.821]             if (.Platform$OS.type == "windows") {
[13:19:11.821]                 old_names <- names(...future.oldEnvVars)
[13:19:11.821]                 envs <- base::Sys.getenv()
[13:19:11.821]                 names <- names(envs)
[13:19:11.821]                 common <- intersect(names, old_names)
[13:19:11.821]                 added <- setdiff(names, old_names)
[13:19:11.821]                 removed <- setdiff(old_names, names)
[13:19:11.821]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:11.821]                   envs[common]]
[13:19:11.821]                 NAMES <- toupper(changed)
[13:19:11.821]                 args <- list()
[13:19:11.821]                 for (kk in seq_along(NAMES)) {
[13:19:11.821]                   name <- changed[[kk]]
[13:19:11.821]                   NAME <- NAMES[[kk]]
[13:19:11.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:11.821]                     next
[13:19:11.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:11.821]                 }
[13:19:11.821]                 NAMES <- toupper(added)
[13:19:11.821]                 for (kk in seq_along(NAMES)) {
[13:19:11.821]                   name <- added[[kk]]
[13:19:11.821]                   NAME <- NAMES[[kk]]
[13:19:11.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:11.821]                     next
[13:19:11.821]                   args[[name]] <- ""
[13:19:11.821]                 }
[13:19:11.821]                 NAMES <- toupper(removed)
[13:19:11.821]                 for (kk in seq_along(NAMES)) {
[13:19:11.821]                   name <- removed[[kk]]
[13:19:11.821]                   NAME <- NAMES[[kk]]
[13:19:11.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:11.821]                     next
[13:19:11.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:11.821]                 }
[13:19:11.821]                 if (length(args) > 0) 
[13:19:11.821]                   base::do.call(base::Sys.setenv, args = args)
[13:19:11.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:11.821]             }
[13:19:11.821]             else {
[13:19:11.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:11.821]             }
[13:19:11.821]             {
[13:19:11.821]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:11.821]                   0L) {
[13:19:11.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:11.821]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:11.821]                   base::options(opts)
[13:19:11.821]                 }
[13:19:11.821]                 {
[13:19:11.821]                   {
[13:19:11.821]                     NULL
[13:19:11.821]                     RNGkind("Mersenne-Twister")
[13:19:11.821]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:11.821]                       inherits = FALSE)
[13:19:11.821]                   }
[13:19:11.821]                   options(future.plan = NULL)
[13:19:11.821]                   if (is.na(NA_character_)) 
[13:19:11.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:11.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:11.821]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:11.821]                   {
[13:19:11.821]                     future <- SequentialFuture(..., envir = envir)
[13:19:11.821]                     if (!future$lazy) 
[13:19:11.821]                       future <- run(future)
[13:19:11.821]                     invisible(future)
[13:19:11.821]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:11.821]                 }
[13:19:11.821]             }
[13:19:11.821]         }
[13:19:11.821]     })
[13:19:11.821]     if (TRUE) {
[13:19:11.821]         base::sink(type = "output", split = FALSE)
[13:19:11.821]         if (TRUE) {
[13:19:11.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:11.821]         }
[13:19:11.821]         else {
[13:19:11.821]             ...future.result["stdout"] <- base::list(NULL)
[13:19:11.821]         }
[13:19:11.821]         base::close(...future.stdout)
[13:19:11.821]         ...future.stdout <- NULL
[13:19:11.821]     }
[13:19:11.821]     ...future.result$conditions <- ...future.conditions
[13:19:11.821]     ...future.result$finished <- base::Sys.time()
[13:19:11.821]     ...future.result
[13:19:11.821] }
[13:19:11.823] assign_globals() ...
[13:19:11.823] List of 5
[13:19:11.823]  $ ...future.FUN            :function (x, y)  
[13:19:11.823]  $ MoreArgs                 : NULL
[13:19:11.823]  $ ...future.elements_ii    :List of 2
[13:19:11.823]   ..$ :List of 2
[13:19:11.823]   .. ..$ : int 1
[13:19:11.823]   .. ..$ : int 0
[13:19:11.823]   ..$ :List of 2
[13:19:11.823]   .. ..$ : int 0
[13:19:11.823]   .. ..$ : int 1
[13:19:11.823]  $ ...future.seeds_ii       : NULL
[13:19:11.823]  $ ...future.globals.maxSize: NULL
[13:19:11.823]  - attr(*, "resolved")= logi FALSE
[13:19:11.823]  - attr(*, "total_size")= num 6480
[13:19:11.823]  - attr(*, "where")=List of 5
[13:19:11.823]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:11.823]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:11.823]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:11.823]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:11.823]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:11.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:11.823]  - attr(*, "already-done")= logi TRUE
[13:19:11.831] - reassign environment for ‘...future.FUN’
[13:19:11.831] - copied ‘...future.FUN’ to environment
[13:19:11.831] - copied ‘MoreArgs’ to environment
[13:19:11.831] - copied ‘...future.elements_ii’ to environment
[13:19:11.831] - copied ‘...future.seeds_ii’ to environment
[13:19:11.831] - copied ‘...future.globals.maxSize’ to environment
[13:19:11.831] assign_globals() ... done
[13:19:11.831] plan(): Setting new future strategy stack:
[13:19:11.832] List of future strategies:
[13:19:11.832] 1. sequential:
[13:19:11.832]    - args: function (..., envir = parent.frame())
[13:19:11.832]    - tweaked: FALSE
[13:19:11.832]    - call: NULL
[13:19:11.832] plan(): nbrOfWorkers() = 1
[13:19:12.334] plan(): Setting new future strategy stack:
[13:19:12.334] List of future strategies:
[13:19:12.334] 1. sequential:
[13:19:12.334]    - args: function (..., envir = parent.frame())
[13:19:12.334]    - tweaked: FALSE
[13:19:12.334]    - call: plan(strategy)
[13:19:12.334] plan(): nbrOfWorkers() = 1
[13:19:12.335] SequentialFuture started (and completed)
[13:19:12.335] - Launch lazy future ... done
[13:19:12.335] run() for ‘SequentialFuture’ ... done
[13:19:12.335] Created future:
[13:19:12.335] SequentialFuture:
[13:19:12.335] Label: ‘future_mapply-1’
[13:19:12.335] Expression:
[13:19:12.335] {
[13:19:12.335]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:12.335]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:12.335]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:12.335]         on.exit(options(oopts), add = TRUE)
[13:19:12.335]     }
[13:19:12.335]     {
[13:19:12.335]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:12.335]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:12.335]         do.call(mapply, args = args)
[13:19:12.335]     }
[13:19:12.335] }
[13:19:12.335] Lazy evaluation: FALSE
[13:19:12.335] Asynchronous evaluation: FALSE
[13:19:12.335] Local evaluation: TRUE
[13:19:12.335] Environment: R_GlobalEnv
[13:19:12.335] Capture standard output: TRUE
[13:19:12.335] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:12.335] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:12.335] Packages: <none>
[13:19:12.335] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:12.335] Resolved: TRUE
[13:19:12.335] Value: 224 bytes of class ‘list’
[13:19:12.335] Early signaling: FALSE
[13:19:12.335] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:12.335] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:12.336] Chunk #1 of 1 ... DONE
[13:19:12.336] Launching 1 futures (chunks) ... DONE
[13:19:12.336] Resolving 1 futures (chunks) ...
[13:19:12.336] resolve() on list ...
[13:19:12.336]  recursive: 0
[13:19:12.336]  length: 1
[13:19:12.337] 
[13:19:12.337] resolved() for ‘SequentialFuture’ ...
[13:19:12.337] - state: ‘finished’
[13:19:12.337] - run: TRUE
[13:19:12.337] - result: ‘FutureResult’
[13:19:12.337] resolved() for ‘SequentialFuture’ ... done
[13:19:12.337] Future #1
[13:19:12.337] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:12.337] - nx: 1
[13:19:12.338] - relay: TRUE
[13:19:12.338] - stdout: TRUE
[13:19:12.338] - signal: TRUE
[13:19:12.338] - resignal: FALSE
[13:19:12.338] - force: TRUE
[13:19:12.338] - relayed: [n=1] FALSE
[13:19:12.338] - queued futures: [n=1] FALSE
[13:19:12.338]  - until=1
[13:19:12.338]  - relaying element #1
[13:19:12.338] - relayed: [n=1] TRUE
[13:19:12.339] - queued futures: [n=1] TRUE
[13:19:12.339] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:12.339]  length: 0 (resolved future 1)
[13:19:12.339] Relaying remaining futures
[13:19:12.339] signalConditionsASAP(NULL, pos=0) ...
[13:19:12.339] - nx: 1
[13:19:12.339] - relay: TRUE
[13:19:12.339] - stdout: TRUE
[13:19:12.339] - signal: TRUE
[13:19:12.339] - resignal: FALSE
[13:19:12.339] - force: TRUE
[13:19:12.340] - relayed: [n=1] TRUE
[13:19:12.340] - queued futures: [n=1] TRUE
 - flush all
[13:19:12.340] - relayed: [n=1] TRUE
[13:19:12.340] - queued futures: [n=1] TRUE
[13:19:12.340] signalConditionsASAP(NULL, pos=0) ... done
[13:19:12.340] resolve() on list ... DONE
[13:19:12.340]  - Number of value chunks collected: 1
[13:19:12.340] Resolving 1 futures (chunks) ... DONE
[13:19:12.340] Reducing values from 1 chunks ...
[13:19:12.340]  - Number of values collected after concatenation: 2
[13:19:12.340]  - Number of values expected: 2
[13:19:12.341] Reducing values from 1 chunks ... DONE
[13:19:12.341] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:19:12.341] future_mapply() ...
[13:19:12.341] Number of chunks: 1
[13:19:12.341] getGlobalsAndPackagesXApply() ...
[13:19:12.341]  - future.globals: TRUE
[13:19:12.342] getGlobalsAndPackages() ...
[13:19:12.342] Searching for globals...
[13:19:12.343] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:12.343] Searching for globals ... DONE
[13:19:12.343] Resolving globals: FALSE
[13:19:12.344] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:12.344] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:12.344] - globals: [1] ‘FUN’
[13:19:12.344] 
[13:19:12.344] getGlobalsAndPackages() ... DONE
[13:19:12.345]  - globals found/used: [n=1] ‘FUN’
[13:19:12.345]  - needed namespaces: [n=0] 
[13:19:12.345] Finding globals ... DONE
[13:19:12.345] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:12.345] List of 2
[13:19:12.345]  $ ...future.FUN:function (x, y)  
[13:19:12.345]  $ MoreArgs     : NULL
[13:19:12.345]  - attr(*, "where")=List of 2
[13:19:12.345]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:12.345]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:12.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:12.345]  - attr(*, "resolved")= logi FALSE
[13:19:12.345]  - attr(*, "total_size")= num NA
[13:19:12.348] Packages to be attached in all futures: [n=0] 
[13:19:12.348] getGlobalsAndPackagesXApply() ... DONE
[13:19:12.348] Number of futures (= number of chunks): 1
[13:19:12.348] Launching 1 futures (chunks) ...
[13:19:12.348] Chunk #1 of 1 ...
[13:19:12.348]  - Finding globals in '...' for chunk #1 ...
[13:19:12.348] getGlobalsAndPackages() ...
[13:19:12.348] Searching for globals...
[13:19:12.349] 
[13:19:12.349] Searching for globals ... DONE
[13:19:12.349] - globals: [0] <none>
[13:19:12.349] getGlobalsAndPackages() ... DONE
[13:19:12.351]    + additional globals found: [n=0] 
[13:19:12.351]    + additional namespaces needed: [n=0] 
[13:19:12.351]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:12.351]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:12.351]  - seeds: <none>
[13:19:12.351] getGlobalsAndPackages() ...
[13:19:12.351] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:12.351] Resolving globals: FALSE
[13:19:12.352] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:12.352] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:12.352] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:12.353] 
[13:19:12.353] getGlobalsAndPackages() ... DONE
[13:19:12.353] run() for ‘Future’ ...
[13:19:12.353] - state: ‘created’
[13:19:12.353] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:19:12.353] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:12.354] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:12.354]   - Field: ‘label’
[13:19:12.354]   - Field: ‘local’
[13:19:12.354]   - Field: ‘owner’
[13:19:12.354]   - Field: ‘envir’
[13:19:12.354]   - Field: ‘packages’
[13:19:12.354]   - Field: ‘gc’
[13:19:12.354]   - Field: ‘conditions’
[13:19:12.354]   - Field: ‘expr’
[13:19:12.354]   - Field: ‘uuid’
[13:19:12.355]   - Field: ‘seed’
[13:19:12.355]   - Field: ‘version’
[13:19:12.355]   - Field: ‘result’
[13:19:12.355]   - Field: ‘asynchronous’
[13:19:12.355]   - Field: ‘calls’
[13:19:12.355]   - Field: ‘globals’
[13:19:12.355]   - Field: ‘stdout’
[13:19:12.355]   - Field: ‘earlySignal’
[13:19:12.355]   - Field: ‘lazy’
[13:19:12.355]   - Field: ‘state’
[13:19:12.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:12.356] - Launch lazy future ...
[13:19:12.356] Packages needed by the future expression (n = 0): <none>
[13:19:12.356] Packages needed by future strategies (n = 0): <none>
[13:19:12.356] {
[13:19:12.356]     {
[13:19:12.356]         {
[13:19:12.356]             ...future.startTime <- base::Sys.time()
[13:19:12.356]             {
[13:19:12.356]                 {
[13:19:12.356]                   {
[13:19:12.356]                     base::local({
[13:19:12.356]                       has_future <- base::requireNamespace("future", 
[13:19:12.356]                         quietly = TRUE)
[13:19:12.356]                       if (has_future) {
[13:19:12.356]                         ns <- base::getNamespace("future")
[13:19:12.356]                         version <- ns[[".package"]][["version"]]
[13:19:12.356]                         if (is.null(version)) 
[13:19:12.356]                           version <- utils::packageVersion("future")
[13:19:12.356]                       }
[13:19:12.356]                       else {
[13:19:12.356]                         version <- NULL
[13:19:12.356]                       }
[13:19:12.356]                       if (!has_future || version < "1.8.0") {
[13:19:12.356]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:12.356]                           "", base::R.version$version.string), 
[13:19:12.356]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:12.356]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:12.356]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:12.356]                             "release", "version")], collapse = " "), 
[13:19:12.356]                           hostname = base::Sys.info()[["nodename"]])
[13:19:12.356]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:12.356]                           info)
[13:19:12.356]                         info <- base::paste(info, collapse = "; ")
[13:19:12.356]                         if (!has_future) {
[13:19:12.356]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:12.356]                             info)
[13:19:12.356]                         }
[13:19:12.356]                         else {
[13:19:12.356]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:12.356]                             info, version)
[13:19:12.356]                         }
[13:19:12.356]                         base::stop(msg)
[13:19:12.356]                       }
[13:19:12.356]                     })
[13:19:12.356]                   }
[13:19:12.356]                   options(future.plan = NULL)
[13:19:12.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:12.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:12.356]                 }
[13:19:12.356]                 ...future.workdir <- getwd()
[13:19:12.356]             }
[13:19:12.356]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:12.356]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:12.356]         }
[13:19:12.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:12.356]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:12.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:12.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:12.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:12.356]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:12.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:12.356]             base::names(...future.oldOptions))
[13:19:12.356]     }
[13:19:12.356]     if (TRUE) {
[13:19:12.356]     }
[13:19:12.356]     else {
[13:19:12.356]         if (NA) {
[13:19:12.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:12.356]                 open = "w")
[13:19:12.356]         }
[13:19:12.356]         else {
[13:19:12.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:12.356]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:12.356]         }
[13:19:12.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:12.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:12.356]             base::sink(type = "output", split = FALSE)
[13:19:12.356]             base::close(...future.stdout)
[13:19:12.356]         }, add = TRUE)
[13:19:12.356]     }
[13:19:12.356]     ...future.frame <- base::sys.nframe()
[13:19:12.356]     ...future.conditions <- base::list()
[13:19:12.356]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:12.356]     if (FALSE) {
[13:19:12.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:12.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:12.356]     }
[13:19:12.356]     ...future.result <- base::tryCatch({
[13:19:12.356]         base::withCallingHandlers({
[13:19:12.356]             ...future.value <- base::withVisible(base::local({
[13:19:12.356]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:12.356]                 if (!identical(...future.globals.maxSize.org, 
[13:19:12.356]                   ...future.globals.maxSize)) {
[13:19:12.356]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:12.356]                   on.exit(options(oopts), add = TRUE)
[13:19:12.356]                 }
[13:19:12.356]                 {
[13:19:12.356]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:12.356]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:12.356]                     USE.NAMES = FALSE)
[13:19:12.356]                   do.call(mapply, args = args)
[13:19:12.356]                 }
[13:19:12.356]             }))
[13:19:12.356]             future::FutureResult(value = ...future.value$value, 
[13:19:12.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:12.356]                   ...future.rng), globalenv = if (FALSE) 
[13:19:12.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:12.356]                     ...future.globalenv.names))
[13:19:12.356]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:12.356]         }, condition = base::local({
[13:19:12.356]             c <- base::c
[13:19:12.356]             inherits <- base::inherits
[13:19:12.356]             invokeRestart <- base::invokeRestart
[13:19:12.356]             length <- base::length
[13:19:12.356]             list <- base::list
[13:19:12.356]             seq.int <- base::seq.int
[13:19:12.356]             signalCondition <- base::signalCondition
[13:19:12.356]             sys.calls <- base::sys.calls
[13:19:12.356]             `[[` <- base::`[[`
[13:19:12.356]             `+` <- base::`+`
[13:19:12.356]             `<<-` <- base::`<<-`
[13:19:12.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:12.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:12.356]                   3L)]
[13:19:12.356]             }
[13:19:12.356]             function(cond) {
[13:19:12.356]                 is_error <- inherits(cond, "error")
[13:19:12.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:12.356]                   NULL)
[13:19:12.356]                 if (is_error) {
[13:19:12.356]                   sessionInformation <- function() {
[13:19:12.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:12.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:12.356]                       search = base::search(), system = base::Sys.info())
[13:19:12.356]                   }
[13:19:12.356]                   ...future.conditions[[length(...future.conditions) + 
[13:19:12.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:12.356]                     cond$call), session = sessionInformation(), 
[13:19:12.356]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:12.356]                   signalCondition(cond)
[13:19:12.356]                 }
[13:19:12.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:12.356]                 "immediateCondition"))) {
[13:19:12.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:12.356]                   ...future.conditions[[length(...future.conditions) + 
[13:19:12.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:12.356]                   if (TRUE && !signal) {
[13:19:12.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:12.356]                     {
[13:19:12.356]                       inherits <- base::inherits
[13:19:12.356]                       invokeRestart <- base::invokeRestart
[13:19:12.356]                       is.null <- base::is.null
[13:19:12.356]                       muffled <- FALSE
[13:19:12.356]                       if (inherits(cond, "message")) {
[13:19:12.356]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:12.356]                         if (muffled) 
[13:19:12.356]                           invokeRestart("muffleMessage")
[13:19:12.356]                       }
[13:19:12.356]                       else if (inherits(cond, "warning")) {
[13:19:12.356]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:12.356]                         if (muffled) 
[13:19:12.356]                           invokeRestart("muffleWarning")
[13:19:12.356]                       }
[13:19:12.356]                       else if (inherits(cond, "condition")) {
[13:19:12.356]                         if (!is.null(pattern)) {
[13:19:12.356]                           computeRestarts <- base::computeRestarts
[13:19:12.356]                           grepl <- base::grepl
[13:19:12.356]                           restarts <- computeRestarts(cond)
[13:19:12.356]                           for (restart in restarts) {
[13:19:12.356]                             name <- restart$name
[13:19:12.356]                             if (is.null(name)) 
[13:19:12.356]                               next
[13:19:12.356]                             if (!grepl(pattern, name)) 
[13:19:12.356]                               next
[13:19:12.356]                             invokeRestart(restart)
[13:19:12.356]                             muffled <- TRUE
[13:19:12.356]                             break
[13:19:12.356]                           }
[13:19:12.356]                         }
[13:19:12.356]                       }
[13:19:12.356]                       invisible(muffled)
[13:19:12.356]                     }
[13:19:12.356]                     muffleCondition(cond, pattern = "^muffle")
[13:19:12.356]                   }
[13:19:12.356]                 }
[13:19:12.356]                 else {
[13:19:12.356]                   if (TRUE) {
[13:19:12.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:12.356]                     {
[13:19:12.356]                       inherits <- base::inherits
[13:19:12.356]                       invokeRestart <- base::invokeRestart
[13:19:12.356]                       is.null <- base::is.null
[13:19:12.356]                       muffled <- FALSE
[13:19:12.356]                       if (inherits(cond, "message")) {
[13:19:12.356]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:12.356]                         if (muffled) 
[13:19:12.356]                           invokeRestart("muffleMessage")
[13:19:12.356]                       }
[13:19:12.356]                       else if (inherits(cond, "warning")) {
[13:19:12.356]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:12.356]                         if (muffled) 
[13:19:12.356]                           invokeRestart("muffleWarning")
[13:19:12.356]                       }
[13:19:12.356]                       else if (inherits(cond, "condition")) {
[13:19:12.356]                         if (!is.null(pattern)) {
[13:19:12.356]                           computeRestarts <- base::computeRestarts
[13:19:12.356]                           grepl <- base::grepl
[13:19:12.356]                           restarts <- computeRestarts(cond)
[13:19:12.356]                           for (restart in restarts) {
[13:19:12.356]                             name <- restart$name
[13:19:12.356]                             if (is.null(name)) 
[13:19:12.356]                               next
[13:19:12.356]                             if (!grepl(pattern, name)) 
[13:19:12.356]                               next
[13:19:12.356]                             invokeRestart(restart)
[13:19:12.356]                             muffled <- TRUE
[13:19:12.356]                             break
[13:19:12.356]                           }
[13:19:12.356]                         }
[13:19:12.356]                       }
[13:19:12.356]                       invisible(muffled)
[13:19:12.356]                     }
[13:19:12.356]                     muffleCondition(cond, pattern = "^muffle")
[13:19:12.356]                   }
[13:19:12.356]                 }
[13:19:12.356]             }
[13:19:12.356]         }))
[13:19:12.356]     }, error = function(ex) {
[13:19:12.356]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:12.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:12.356]                 ...future.rng), started = ...future.startTime, 
[13:19:12.356]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:12.356]             version = "1.8"), class = "FutureResult")
[13:19:12.356]     }, finally = {
[13:19:12.356]         if (!identical(...future.workdir, getwd())) 
[13:19:12.356]             setwd(...future.workdir)
[13:19:12.356]         {
[13:19:12.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:12.356]                 ...future.oldOptions$nwarnings <- NULL
[13:19:12.356]             }
[13:19:12.356]             base::options(...future.oldOptions)
[13:19:12.356]             if (.Platform$OS.type == "windows") {
[13:19:12.356]                 old_names <- names(...future.oldEnvVars)
[13:19:12.356]                 envs <- base::Sys.getenv()
[13:19:12.356]                 names <- names(envs)
[13:19:12.356]                 common <- intersect(names, old_names)
[13:19:12.356]                 added <- setdiff(names, old_names)
[13:19:12.356]                 removed <- setdiff(old_names, names)
[13:19:12.356]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:12.356]                   envs[common]]
[13:19:12.356]                 NAMES <- toupper(changed)
[13:19:12.356]                 args <- list()
[13:19:12.356]                 for (kk in seq_along(NAMES)) {
[13:19:12.356]                   name <- changed[[kk]]
[13:19:12.356]                   NAME <- NAMES[[kk]]
[13:19:12.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:12.356]                     next
[13:19:12.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:12.356]                 }
[13:19:12.356]                 NAMES <- toupper(added)
[13:19:12.356]                 for (kk in seq_along(NAMES)) {
[13:19:12.356]                   name <- added[[kk]]
[13:19:12.356]                   NAME <- NAMES[[kk]]
[13:19:12.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:12.356]                     next
[13:19:12.356]                   args[[name]] <- ""
[13:19:12.356]                 }
[13:19:12.356]                 NAMES <- toupper(removed)
[13:19:12.356]                 for (kk in seq_along(NAMES)) {
[13:19:12.356]                   name <- removed[[kk]]
[13:19:12.356]                   NAME <- NAMES[[kk]]
[13:19:12.356]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:12.356]                     next
[13:19:12.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:12.356]                 }
[13:19:12.356]                 if (length(args) > 0) 
[13:19:12.356]                   base::do.call(base::Sys.setenv, args = args)
[13:19:12.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:12.356]             }
[13:19:12.356]             else {
[13:19:12.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:12.356]             }
[13:19:12.356]             {
[13:19:12.356]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:12.356]                   0L) {
[13:19:12.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:12.356]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:12.356]                   base::options(opts)
[13:19:12.356]                 }
[13:19:12.356]                 {
[13:19:12.356]                   {
[13:19:12.356]                     NULL
[13:19:12.356]                     RNGkind("Mersenne-Twister")
[13:19:12.356]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:12.356]                       inherits = FALSE)
[13:19:12.356]                   }
[13:19:12.356]                   options(future.plan = NULL)
[13:19:12.356]                   if (is.na(NA_character_)) 
[13:19:12.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:12.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:12.356]                   future::plan(list(function (..., envir = parent.frame()) 
[13:19:12.356]                   {
[13:19:12.356]                     future <- SequentialFuture(..., envir = envir)
[13:19:12.356]                     if (!future$lazy) 
[13:19:12.356]                       future <- run(future)
[13:19:12.356]                     invisible(future)
[13:19:12.356]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:12.356]                 }
[13:19:12.356]             }
[13:19:12.356]         }
[13:19:12.356]     })
[13:19:12.356]     if (FALSE) {
[13:19:12.356]         base::sink(type = "output", split = FALSE)
[13:19:12.356]         if (NA) {
[13:19:12.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:12.356]         }
[13:19:12.356]         else {
[13:19:12.356]             ...future.result["stdout"] <- base::list(NULL)
[13:19:12.356]         }
[13:19:12.356]         base::close(...future.stdout)
[13:19:12.356]         ...future.stdout <- NULL
[13:19:12.356]     }
[13:19:12.356]     ...future.result$conditions <- ...future.conditions
[13:19:12.356]     ...future.result$finished <- base::Sys.time()
[13:19:12.356]     ...future.result
[13:19:12.356] }
[13:19:12.358] assign_globals() ...
[13:19:12.358] List of 5
[13:19:12.358]  $ ...future.FUN            :function (x, y)  
[13:19:12.358]  $ MoreArgs                 : NULL
[13:19:12.358]  $ ...future.elements_ii    :List of 2
[13:19:12.358]   ..$ :List of 2
[13:19:12.358]   .. ..$ : int 1
[13:19:12.358]   .. ..$ : int 0
[13:19:12.358]   ..$ :List of 2
[13:19:12.358]   .. ..$ : int 0
[13:19:12.358]   .. ..$ : int 1
[13:19:12.358]  $ ...future.seeds_ii       : NULL
[13:19:12.358]  $ ...future.globals.maxSize: NULL
[13:19:12.358]  - attr(*, "resolved")= logi FALSE
[13:19:12.358]  - attr(*, "total_size")= num 6480
[13:19:12.358]  - attr(*, "where")=List of 5
[13:19:12.358]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:12.358]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:12.358]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:12.358]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:12.358]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:12.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:12.358]  - attr(*, "already-done")= logi TRUE
[13:19:12.364] - reassign environment for ‘...future.FUN’
[13:19:12.364] - copied ‘...future.FUN’ to environment
[13:19:12.364] - copied ‘MoreArgs’ to environment
[13:19:12.364] - copied ‘...future.elements_ii’ to environment
[13:19:12.364] - copied ‘...future.seeds_ii’ to environment
[13:19:12.364] - copied ‘...future.globals.maxSize’ to environment
[13:19:12.364] assign_globals() ... done
[13:19:12.365] plan(): Setting new future strategy stack:
[13:19:12.365] List of future strategies:
[13:19:12.365] 1. sequential:
[13:19:12.365]    - args: function (..., envir = parent.frame())
[13:19:12.365]    - tweaked: FALSE
[13:19:12.365]    - call: NULL
[13:19:12.365] plan(): nbrOfWorkers() = 1
[13:19:12.867] plan(): Setting new future strategy stack:
[13:19:12.867] List of future strategies:
[13:19:12.867] 1. sequential:
[13:19:12.867]    - args: function (..., envir = parent.frame())
[13:19:12.867]    - tweaked: FALSE
[13:19:12.867]    - call: plan(strategy)
[13:19:12.867] plan(): nbrOfWorkers() = 1
[13:19:12.868] SequentialFuture started (and completed)
[13:19:12.868] - Launch lazy future ... done
[13:19:12.868] run() for ‘SequentialFuture’ ... done
[13:19:12.868] Created future:
[13:19:12.868] SequentialFuture:
[13:19:12.868] Label: ‘future_mapply-1’
[13:19:12.868] Expression:
[13:19:12.868] {
[13:19:12.868]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:12.868]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:12.868]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:12.868]         on.exit(options(oopts), add = TRUE)
[13:19:12.868]     }
[13:19:12.868]     {
[13:19:12.868]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:12.868]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:12.868]         do.call(mapply, args = args)
[13:19:12.868]     }
[13:19:12.868] }
[13:19:12.868] Lazy evaluation: FALSE
[13:19:12.868] Asynchronous evaluation: FALSE
[13:19:12.868] Local evaluation: TRUE
[13:19:12.868] Environment: R_GlobalEnv
[13:19:12.868] Capture standard output: NA
[13:19:12.868] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:12.868] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:12.868] Packages: <none>
[13:19:12.868] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:12.868] Resolved: TRUE
[13:19:12.868] Value: 224 bytes of class ‘list’
[13:19:12.868] Early signaling: FALSE
[13:19:12.868] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:12.868] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:12.869] Chunk #1 of 1 ... DONE
[13:19:12.869] Launching 1 futures (chunks) ... DONE
[13:19:12.869] Resolving 1 futures (chunks) ...
[13:19:12.869] resolve() on list ...
[13:19:12.869]  recursive: 0
[13:19:12.870]  length: 1
[13:19:12.870] 
[13:19:12.870] resolved() for ‘SequentialFuture’ ...
[13:19:12.870] - state: ‘finished’
[13:19:12.870] - run: TRUE
[13:19:12.870] - result: ‘FutureResult’
[13:19:12.870] resolved() for ‘SequentialFuture’ ... done
[13:19:12.870] Future #1
[13:19:12.870] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:12.870] - nx: 1
[13:19:12.871] - relay: TRUE
[13:19:12.871] - stdout: TRUE
[13:19:12.871] - signal: TRUE
[13:19:12.871] - resignal: FALSE
[13:19:12.871] - force: TRUE
[13:19:12.871] - relayed: [n=1] FALSE
[13:19:12.871] - queued futures: [n=1] FALSE
[13:19:12.871]  - until=1
[13:19:12.871]  - relaying element #1
[13:19:12.871] - relayed: [n=1] TRUE
[13:19:12.871] - queued futures: [n=1] TRUE
[13:19:12.872] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:12.872]  length: 0 (resolved future 1)
[13:19:12.872] Relaying remaining futures
[13:19:12.872] signalConditionsASAP(NULL, pos=0) ...
[13:19:12.872] - nx: 1
[13:19:12.872] - relay: TRUE
[13:19:12.872] - stdout: TRUE
[13:19:12.872] - signal: TRUE
[13:19:12.872] - resignal: FALSE
[13:19:12.872] - force: TRUE
[13:19:12.872] - relayed: [n=1] TRUE
[13:19:12.872] - queued futures: [n=1] TRUE
 - flush all
[13:19:12.873] - relayed: [n=1] TRUE
[13:19:12.873] - queued futures: [n=1] TRUE
[13:19:12.873] signalConditionsASAP(NULL, pos=0) ... done
[13:19:12.873] resolve() on list ... DONE
[13:19:12.873]  - Number of value chunks collected: 1
[13:19:12.873] Resolving 1 futures (chunks) ... DONE
[13:19:12.873] Reducing values from 1 chunks ...
[13:19:12.873]  - Number of values collected after concatenation: 2
[13:19:12.873]  - Number of values expected: 2
[13:19:12.874] Reducing values from 1 chunks ... DONE
[13:19:12.874] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[13:19:12.874] plan(): Setting new future strategy stack:
[13:19:12.874] List of future strategies:
[13:19:12.874] 1. multicore:
[13:19:12.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:12.874]    - tweaked: FALSE
[13:19:12.874]    - call: plan(strategy)
[13:19:12.878] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:19:12.880] future_lapply() ...
[13:19:12.884] Number of chunks: 1
[13:19:12.884] getGlobalsAndPackagesXApply() ...
[13:19:12.884]  - future.globals: TRUE
[13:19:12.884] getGlobalsAndPackages() ...
[13:19:12.884] Searching for globals...
[13:19:12.886] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:12.886] Searching for globals ... DONE
[13:19:12.886] Resolving globals: FALSE
[13:19:12.886] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:12.887] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:12.887] - globals: [1] ‘FUN’
[13:19:12.887] 
[13:19:12.887] getGlobalsAndPackages() ... DONE
[13:19:12.887]  - globals found/used: [n=1] ‘FUN’
[13:19:12.887]  - needed namespaces: [n=0] 
[13:19:12.887] Finding globals ... DONE
[13:19:12.887]  - use_args: TRUE
[13:19:12.887]  - Getting '...' globals ...
[13:19:12.888] resolve() on list ...
[13:19:12.888]  recursive: 0
[13:19:12.888]  length: 1
[13:19:12.888]  elements: ‘...’
[13:19:12.888]  length: 0 (resolved future 1)
[13:19:12.888] resolve() on list ... DONE
[13:19:12.888]    - '...' content: [n=0] 
[13:19:12.888] List of 1
[13:19:12.888]  $ ...: list()
[13:19:12.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:12.888]  - attr(*, "where")=List of 1
[13:19:12.888]   ..$ ...:<environment: 0x56200559ece8> 
[13:19:12.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:12.888]  - attr(*, "resolved")= logi TRUE
[13:19:12.888]  - attr(*, "total_size")= num NA
[13:19:12.891]  - Getting '...' globals ... DONE
[13:19:12.891] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:12.891] List of 2
[13:19:12.891]  $ ...future.FUN:function (x)  
[13:19:12.891]  $ ...          : list()
[13:19:12.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:12.891]  - attr(*, "where")=List of 2
[13:19:12.891]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:12.891]   ..$ ...          :<environment: 0x56200559ece8> 
[13:19:12.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:12.891]  - attr(*, "resolved")= logi FALSE
[13:19:12.891]  - attr(*, "total_size")= num 4720
[13:19:12.894] Packages to be attached in all futures: [n=0] 
[13:19:12.894] getGlobalsAndPackagesXApply() ... DONE
[13:19:12.894] Number of futures (= number of chunks): 1
[13:19:12.894] Launching 1 futures (chunks) ...
[13:19:12.894] Chunk #1 of 1 ...
[13:19:12.895]  - Finding globals in 'X' for chunk #1 ...
[13:19:12.895] getGlobalsAndPackages() ...
[13:19:12.895] Searching for globals...
[13:19:12.895] 
[13:19:12.895] Searching for globals ... DONE
[13:19:12.895] - globals: [0] <none>
[13:19:12.895] getGlobalsAndPackages() ... DONE
[13:19:12.895]    + additional globals found: [n=0] 
[13:19:12.895]    + additional namespaces needed: [n=0] 
[13:19:12.895]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:12.896]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:12.896]  - seeds: <none>
[13:19:12.896] getGlobalsAndPackages() ...
[13:19:12.896] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:12.896] Resolving globals: FALSE
[13:19:12.896] Tweak future expression to call with '...' arguments ...
[13:19:12.896] {
[13:19:12.896]     do.call(function(...) {
[13:19:12.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:12.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:12.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:12.896]             on.exit(options(oopts), add = TRUE)
[13:19:12.896]         }
[13:19:12.896]         {
[13:19:12.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:12.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:12.896]                 ...future.FUN(...future.X_jj, ...)
[13:19:12.896]             })
[13:19:12.896]         }
[13:19:12.896]     }, args = future.call.arguments)
[13:19:12.896] }
[13:19:12.896] Tweak future expression to call with '...' arguments ... DONE
[13:19:12.897] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:12.897] 
[13:19:12.897] getGlobalsAndPackages() ... DONE
[13:19:12.897] run() for ‘Future’ ...
[13:19:12.898] - state: ‘created’
[13:19:12.898] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:12.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:12.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:12.901]   - Field: ‘label’
[13:19:12.902]   - Field: ‘local’
[13:19:12.902]   - Field: ‘owner’
[13:19:12.902]   - Field: ‘envir’
[13:19:12.902]   - Field: ‘packages’
[13:19:12.902]   - Field: ‘gc’
[13:19:12.902]   - Field: ‘conditions’
[13:19:12.902]   - Field: ‘expr’
[13:19:12.902]   - Field: ‘uuid’
[13:19:12.902]   - Field: ‘seed’
[13:19:12.902]   - Field: ‘version’
[13:19:12.903]   - Field: ‘result’
[13:19:12.903]   - Field: ‘asynchronous’
[13:19:12.903]   - Field: ‘calls’
[13:19:12.903]   - Field: ‘globals’
[13:19:12.903]   - Field: ‘stdout’
[13:19:12.903]   - Field: ‘earlySignal’
[13:19:12.903]   - Field: ‘lazy’
[13:19:12.903]   - Field: ‘state’
[13:19:12.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:12.903] - Launch lazy future ...
[13:19:12.904] Packages needed by the future expression (n = 0): <none>
[13:19:12.904] Packages needed by future strategies (n = 0): <none>
[13:19:12.904] {
[13:19:12.904]     {
[13:19:12.904]         {
[13:19:12.904]             ...future.startTime <- base::Sys.time()
[13:19:12.904]             {
[13:19:12.904]                 {
[13:19:12.904]                   {
[13:19:12.904]                     base::local({
[13:19:12.904]                       has_future <- base::requireNamespace("future", 
[13:19:12.904]                         quietly = TRUE)
[13:19:12.904]                       if (has_future) {
[13:19:12.904]                         ns <- base::getNamespace("future")
[13:19:12.904]                         version <- ns[[".package"]][["version"]]
[13:19:12.904]                         if (is.null(version)) 
[13:19:12.904]                           version <- utils::packageVersion("future")
[13:19:12.904]                       }
[13:19:12.904]                       else {
[13:19:12.904]                         version <- NULL
[13:19:12.904]                       }
[13:19:12.904]                       if (!has_future || version < "1.8.0") {
[13:19:12.904]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:12.904]                           "", base::R.version$version.string), 
[13:19:12.904]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:12.904]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:12.904]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:12.904]                             "release", "version")], collapse = " "), 
[13:19:12.904]                           hostname = base::Sys.info()[["nodename"]])
[13:19:12.904]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:12.904]                           info)
[13:19:12.904]                         info <- base::paste(info, collapse = "; ")
[13:19:12.904]                         if (!has_future) {
[13:19:12.904]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:12.904]                             info)
[13:19:12.904]                         }
[13:19:12.904]                         else {
[13:19:12.904]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:12.904]                             info, version)
[13:19:12.904]                         }
[13:19:12.904]                         base::stop(msg)
[13:19:12.904]                       }
[13:19:12.904]                     })
[13:19:12.904]                   }
[13:19:12.904]                   options(future.plan = NULL)
[13:19:12.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:12.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:12.904]                 }
[13:19:12.904]                 ...future.workdir <- getwd()
[13:19:12.904]             }
[13:19:12.904]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:12.904]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:12.904]         }
[13:19:12.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:12.904]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:12.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:12.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:12.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:12.904]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:12.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:12.904]             base::names(...future.oldOptions))
[13:19:12.904]     }
[13:19:12.904]     if (FALSE) {
[13:19:12.904]     }
[13:19:12.904]     else {
[13:19:12.904]         if (FALSE) {
[13:19:12.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:12.904]                 open = "w")
[13:19:12.904]         }
[13:19:12.904]         else {
[13:19:12.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:12.904]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:12.904]         }
[13:19:12.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:12.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:12.904]             base::sink(type = "output", split = FALSE)
[13:19:12.904]             base::close(...future.stdout)
[13:19:12.904]         }, add = TRUE)
[13:19:12.904]     }
[13:19:12.904]     ...future.frame <- base::sys.nframe()
[13:19:12.904]     ...future.conditions <- base::list()
[13:19:12.904]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:12.904]     if (FALSE) {
[13:19:12.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:12.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:12.904]     }
[13:19:12.904]     ...future.result <- base::tryCatch({
[13:19:12.904]         base::withCallingHandlers({
[13:19:12.904]             ...future.value <- base::withVisible(base::local({
[13:19:12.904]                 do.call(function(...) {
[13:19:12.904]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:12.904]                   if (!identical(...future.globals.maxSize.org, 
[13:19:12.904]                     ...future.globals.maxSize)) {
[13:19:12.904]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:12.904]                     on.exit(options(oopts), add = TRUE)
[13:19:12.904]                   }
[13:19:12.904]                   {
[13:19:12.904]                     lapply(seq_along(...future.elements_ii), 
[13:19:12.904]                       FUN = function(jj) {
[13:19:12.904]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:12.904]                         ...future.FUN(...future.X_jj, ...)
[13:19:12.904]                       })
[13:19:12.904]                   }
[13:19:12.904]                 }, args = future.call.arguments)
[13:19:12.904]             }))
[13:19:12.904]             future::FutureResult(value = ...future.value$value, 
[13:19:12.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:12.904]                   ...future.rng), globalenv = if (FALSE) 
[13:19:12.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:12.904]                     ...future.globalenv.names))
[13:19:12.904]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:12.904]         }, condition = base::local({
[13:19:12.904]             c <- base::c
[13:19:12.904]             inherits <- base::inherits
[13:19:12.904]             invokeRestart <- base::invokeRestart
[13:19:12.904]             length <- base::length
[13:19:12.904]             list <- base::list
[13:19:12.904]             seq.int <- base::seq.int
[13:19:12.904]             signalCondition <- base::signalCondition
[13:19:12.904]             sys.calls <- base::sys.calls
[13:19:12.904]             `[[` <- base::`[[`
[13:19:12.904]             `+` <- base::`+`
[13:19:12.904]             `<<-` <- base::`<<-`
[13:19:12.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:12.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:12.904]                   3L)]
[13:19:12.904]             }
[13:19:12.904]             function(cond) {
[13:19:12.904]                 is_error <- inherits(cond, "error")
[13:19:12.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:12.904]                   NULL)
[13:19:12.904]                 if (is_error) {
[13:19:12.904]                   sessionInformation <- function() {
[13:19:12.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:12.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:12.904]                       search = base::search(), system = base::Sys.info())
[13:19:12.904]                   }
[13:19:12.904]                   ...future.conditions[[length(...future.conditions) + 
[13:19:12.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:12.904]                     cond$call), session = sessionInformation(), 
[13:19:12.904]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:12.904]                   signalCondition(cond)
[13:19:12.904]                 }
[13:19:12.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:12.904]                 "immediateCondition"))) {
[13:19:12.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:12.904]                   ...future.conditions[[length(...future.conditions) + 
[13:19:12.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:12.904]                   if (TRUE && !signal) {
[13:19:12.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:12.904]                     {
[13:19:12.904]                       inherits <- base::inherits
[13:19:12.904]                       invokeRestart <- base::invokeRestart
[13:19:12.904]                       is.null <- base::is.null
[13:19:12.904]                       muffled <- FALSE
[13:19:12.904]                       if (inherits(cond, "message")) {
[13:19:12.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:12.904]                         if (muffled) 
[13:19:12.904]                           invokeRestart("muffleMessage")
[13:19:12.904]                       }
[13:19:12.904]                       else if (inherits(cond, "warning")) {
[13:19:12.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:12.904]                         if (muffled) 
[13:19:12.904]                           invokeRestart("muffleWarning")
[13:19:12.904]                       }
[13:19:12.904]                       else if (inherits(cond, "condition")) {
[13:19:12.904]                         if (!is.null(pattern)) {
[13:19:12.904]                           computeRestarts <- base::computeRestarts
[13:19:12.904]                           grepl <- base::grepl
[13:19:12.904]                           restarts <- computeRestarts(cond)
[13:19:12.904]                           for (restart in restarts) {
[13:19:12.904]                             name <- restart$name
[13:19:12.904]                             if (is.null(name)) 
[13:19:12.904]                               next
[13:19:12.904]                             if (!grepl(pattern, name)) 
[13:19:12.904]                               next
[13:19:12.904]                             invokeRestart(restart)
[13:19:12.904]                             muffled <- TRUE
[13:19:12.904]                             break
[13:19:12.904]                           }
[13:19:12.904]                         }
[13:19:12.904]                       }
[13:19:12.904]                       invisible(muffled)
[13:19:12.904]                     }
[13:19:12.904]                     muffleCondition(cond, pattern = "^muffle")
[13:19:12.904]                   }
[13:19:12.904]                 }
[13:19:12.904]                 else {
[13:19:12.904]                   if (TRUE) {
[13:19:12.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:12.904]                     {
[13:19:12.904]                       inherits <- base::inherits
[13:19:12.904]                       invokeRestart <- base::invokeRestart
[13:19:12.904]                       is.null <- base::is.null
[13:19:12.904]                       muffled <- FALSE
[13:19:12.904]                       if (inherits(cond, "message")) {
[13:19:12.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:12.904]                         if (muffled) 
[13:19:12.904]                           invokeRestart("muffleMessage")
[13:19:12.904]                       }
[13:19:12.904]                       else if (inherits(cond, "warning")) {
[13:19:12.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:12.904]                         if (muffled) 
[13:19:12.904]                           invokeRestart("muffleWarning")
[13:19:12.904]                       }
[13:19:12.904]                       else if (inherits(cond, "condition")) {
[13:19:12.904]                         if (!is.null(pattern)) {
[13:19:12.904]                           computeRestarts <- base::computeRestarts
[13:19:12.904]                           grepl <- base::grepl
[13:19:12.904]                           restarts <- computeRestarts(cond)
[13:19:12.904]                           for (restart in restarts) {
[13:19:12.904]                             name <- restart$name
[13:19:12.904]                             if (is.null(name)) 
[13:19:12.904]                               next
[13:19:12.904]                             if (!grepl(pattern, name)) 
[13:19:12.904]                               next
[13:19:12.904]                             invokeRestart(restart)
[13:19:12.904]                             muffled <- TRUE
[13:19:12.904]                             break
[13:19:12.904]                           }
[13:19:12.904]                         }
[13:19:12.904]                       }
[13:19:12.904]                       invisible(muffled)
[13:19:12.904]                     }
[13:19:12.904]                     muffleCondition(cond, pattern = "^muffle")
[13:19:12.904]                   }
[13:19:12.904]                 }
[13:19:12.904]             }
[13:19:12.904]         }))
[13:19:12.904]     }, error = function(ex) {
[13:19:12.904]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:12.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:12.904]                 ...future.rng), started = ...future.startTime, 
[13:19:12.904]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:12.904]             version = "1.8"), class = "FutureResult")
[13:19:12.904]     }, finally = {
[13:19:12.904]         if (!identical(...future.workdir, getwd())) 
[13:19:12.904]             setwd(...future.workdir)
[13:19:12.904]         {
[13:19:12.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:12.904]                 ...future.oldOptions$nwarnings <- NULL
[13:19:12.904]             }
[13:19:12.904]             base::options(...future.oldOptions)
[13:19:12.904]             if (.Platform$OS.type == "windows") {
[13:19:12.904]                 old_names <- names(...future.oldEnvVars)
[13:19:12.904]                 envs <- base::Sys.getenv()
[13:19:12.904]                 names <- names(envs)
[13:19:12.904]                 common <- intersect(names, old_names)
[13:19:12.904]                 added <- setdiff(names, old_names)
[13:19:12.904]                 removed <- setdiff(old_names, names)
[13:19:12.904]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:12.904]                   envs[common]]
[13:19:12.904]                 NAMES <- toupper(changed)
[13:19:12.904]                 args <- list()
[13:19:12.904]                 for (kk in seq_along(NAMES)) {
[13:19:12.904]                   name <- changed[[kk]]
[13:19:12.904]                   NAME <- NAMES[[kk]]
[13:19:12.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:12.904]                     next
[13:19:12.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:12.904]                 }
[13:19:12.904]                 NAMES <- toupper(added)
[13:19:12.904]                 for (kk in seq_along(NAMES)) {
[13:19:12.904]                   name <- added[[kk]]
[13:19:12.904]                   NAME <- NAMES[[kk]]
[13:19:12.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:12.904]                     next
[13:19:12.904]                   args[[name]] <- ""
[13:19:12.904]                 }
[13:19:12.904]                 NAMES <- toupper(removed)
[13:19:12.904]                 for (kk in seq_along(NAMES)) {
[13:19:12.904]                   name <- removed[[kk]]
[13:19:12.904]                   NAME <- NAMES[[kk]]
[13:19:12.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:12.904]                     next
[13:19:12.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:12.904]                 }
[13:19:12.904]                 if (length(args) > 0) 
[13:19:12.904]                   base::do.call(base::Sys.setenv, args = args)
[13:19:12.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:12.904]             }
[13:19:12.904]             else {
[13:19:12.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:12.904]             }
[13:19:12.904]             {
[13:19:12.904]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:12.904]                   0L) {
[13:19:12.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:12.904]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:12.904]                   base::options(opts)
[13:19:12.904]                 }
[13:19:12.904]                 {
[13:19:12.904]                   {
[13:19:12.904]                     NULL
[13:19:12.904]                     RNGkind("Mersenne-Twister")
[13:19:12.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:12.904]                       inherits = FALSE)
[13:19:12.904]                   }
[13:19:12.904]                   options(future.plan = NULL)
[13:19:12.904]                   if (is.na(NA_character_)) 
[13:19:12.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:12.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:12.904]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:12.904]                     envir = parent.frame()) 
[13:19:12.904]                   {
[13:19:12.904]                     default_workers <- missing(workers)
[13:19:12.904]                     if (is.function(workers)) 
[13:19:12.904]                       workers <- workers()
[13:19:12.904]                     workers <- structure(as.integer(workers), 
[13:19:12.904]                       class = class(workers))
[13:19:12.904]                     stop_if_not(is.finite(workers), workers >= 
[13:19:12.904]                       1L)
[13:19:12.904]                     if ((workers == 1L && !inherits(workers, 
[13:19:12.904]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:12.904]                       if (default_workers) 
[13:19:12.904]                         supportsMulticore(warn = TRUE)
[13:19:12.904]                       return(sequential(..., envir = envir))
[13:19:12.904]                     }
[13:19:12.904]                     oopts <- options(mc.cores = workers)
[13:19:12.904]                     on.exit(options(oopts))
[13:19:12.904]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:12.904]                       envir = envir)
[13:19:12.904]                     if (!future$lazy) 
[13:19:12.904]                       future <- run(future)
[13:19:12.904]                     invisible(future)
[13:19:12.904]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:12.904]                 }
[13:19:12.904]             }
[13:19:12.904]         }
[13:19:12.904]     })
[13:19:12.904]     if (TRUE) {
[13:19:12.904]         base::sink(type = "output", split = FALSE)
[13:19:12.904]         if (FALSE) {
[13:19:12.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:12.904]         }
[13:19:12.904]         else {
[13:19:12.904]             ...future.result["stdout"] <- base::list(NULL)
[13:19:12.904]         }
[13:19:12.904]         base::close(...future.stdout)
[13:19:12.904]         ...future.stdout <- NULL
[13:19:12.904]     }
[13:19:12.904]     ...future.result$conditions <- ...future.conditions
[13:19:12.904]     ...future.result$finished <- base::Sys.time()
[13:19:12.904]     ...future.result
[13:19:12.904] }
[13:19:12.906] assign_globals() ...
[13:19:12.906] List of 5
[13:19:12.906]  $ ...future.FUN            :function (x)  
[13:19:12.906]  $ future.call.arguments    : list()
[13:19:12.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:12.906]  $ ...future.elements_ii    :List of 2
[13:19:12.906]   ..$ : int 1
[13:19:12.906]   ..$ : int 0
[13:19:12.906]  $ ...future.seeds_ii       : NULL
[13:19:12.906]  $ ...future.globals.maxSize: NULL
[13:19:12.906]  - attr(*, "resolved")= logi FALSE
[13:19:12.906]  - attr(*, "total_size")= num 4720
[13:19:12.906]  - attr(*, "where")=List of 5
[13:19:12.906]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:12.906]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:12.906]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:12.906]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:12.906]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:12.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:12.906]  - attr(*, "already-done")= logi TRUE
[13:19:12.913] - reassign environment for ‘...future.FUN’
[13:19:12.913] - copied ‘...future.FUN’ to environment
[13:19:12.913] - copied ‘future.call.arguments’ to environment
[13:19:12.913] - copied ‘...future.elements_ii’ to environment
[13:19:12.913] - copied ‘...future.seeds_ii’ to environment
[13:19:12.913] - copied ‘...future.globals.maxSize’ to environment
[13:19:12.913] assign_globals() ... done
[13:19:12.914] plan(): Setting new future strategy stack:
[13:19:12.914] List of future strategies:
[13:19:12.914] 1. sequential:
[13:19:12.914]    - args: function (..., envir = parent.frame())
[13:19:12.914]    - tweaked: FALSE
[13:19:12.914]    - call: NULL
[13:19:12.914] plan(): nbrOfWorkers() = 1
[13:19:13.416] plan(): Setting new future strategy stack:
[13:19:13.416] List of future strategies:
[13:19:13.416] 1. multicore:
[13:19:13.416]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:13.416]    - tweaked: FALSE
[13:19:13.416]    - call: plan(strategy)
[13:19:13.420] plan(): nbrOfWorkers() = 1
[13:19:13.420] SequentialFuture started (and completed)
[13:19:13.420] - Launch lazy future ... done
[13:19:13.420] run() for ‘SequentialFuture’ ... done
[13:19:13.420] Created future:
[13:19:13.421] SequentialFuture:
[13:19:13.421] Label: ‘future_lapply-1’
[13:19:13.421] Expression:
[13:19:13.421] {
[13:19:13.421]     do.call(function(...) {
[13:19:13.421]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:13.421]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:13.421]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:13.421]             on.exit(options(oopts), add = TRUE)
[13:19:13.421]         }
[13:19:13.421]         {
[13:19:13.421]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:13.421]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:13.421]                 ...future.FUN(...future.X_jj, ...)
[13:19:13.421]             })
[13:19:13.421]         }
[13:19:13.421]     }, args = future.call.arguments)
[13:19:13.421] }
[13:19:13.421] Lazy evaluation: FALSE
[13:19:13.421] Asynchronous evaluation: FALSE
[13:19:13.421] Local evaluation: TRUE
[13:19:13.421] Environment: R_GlobalEnv
[13:19:13.421] Capture standard output: FALSE
[13:19:13.421] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:13.421] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:13.421] Packages: <none>
[13:19:13.421] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:13.421] Resolved: TRUE
[13:19:13.421] Value: 112 bytes of class ‘list’
[13:19:13.421] Early signaling: FALSE
[13:19:13.421] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:13.421] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:13.422] Chunk #1 of 1 ... DONE
[13:19:13.422] Launching 1 futures (chunks) ... DONE
[13:19:13.422] Resolving 1 futures (chunks) ...
[13:19:13.422] resolve() on list ...
[13:19:13.422]  recursive: 0
[13:19:13.422]  length: 1
[13:19:13.422] 
[13:19:13.422] resolved() for ‘SequentialFuture’ ...
[13:19:13.422] - state: ‘finished’
[13:19:13.423] - run: TRUE
[13:19:13.423] - result: ‘FutureResult’
[13:19:13.423] resolved() for ‘SequentialFuture’ ... done
[13:19:13.423] Future #1
[13:19:13.423] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:13.423] - nx: 1
[13:19:13.423] - relay: TRUE
[13:19:13.423] - stdout: TRUE
[13:19:13.423] - signal: TRUE
[13:19:13.423] - resignal: FALSE
[13:19:13.423] - force: TRUE
[13:19:13.424] - relayed: [n=1] FALSE
[13:19:13.424] - queued futures: [n=1] FALSE
[13:19:13.424]  - until=1
[13:19:13.424]  - relaying element #1
[13:19:13.424] - relayed: [n=1] TRUE
[13:19:13.424] - queued futures: [n=1] TRUE
[13:19:13.424] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:13.424]  length: 0 (resolved future 1)
[13:19:13.424] Relaying remaining futures
[13:19:13.424] signalConditionsASAP(NULL, pos=0) ...
[13:19:13.425] - nx: 1
[13:19:13.425] - relay: TRUE
[13:19:13.425] - stdout: TRUE
[13:19:13.425] - signal: TRUE
[13:19:13.425] - resignal: FALSE
[13:19:13.425] - force: TRUE
[13:19:13.425] - relayed: [n=1] TRUE
[13:19:13.425] - queued futures: [n=1] TRUE
 - flush all
[13:19:13.425] - relayed: [n=1] TRUE
[13:19:13.425] - queued futures: [n=1] TRUE
[13:19:13.425] signalConditionsASAP(NULL, pos=0) ... done
[13:19:13.426] resolve() on list ... DONE
[13:19:13.426]  - Number of value chunks collected: 1
[13:19:13.426] Resolving 1 futures (chunks) ... DONE
[13:19:13.426] Reducing values from 1 chunks ...
[13:19:13.426]  - Number of values collected after concatenation: 2
[13:19:13.426]  - Number of values expected: 2
[13:19:13.426] Reducing values from 1 chunks ... DONE
[13:19:13.426] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:19:13.427] future_lapply() ...
[13:19:13.430] Number of chunks: 1
[13:19:13.430] getGlobalsAndPackagesXApply() ...
[13:19:13.430]  - future.globals: TRUE
[13:19:13.431] getGlobalsAndPackages() ...
[13:19:13.431] Searching for globals...
[13:19:13.432] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:13.432] Searching for globals ... DONE
[13:19:13.432] Resolving globals: FALSE
[13:19:13.433] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:13.433] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:13.433] - globals: [1] ‘FUN’
[13:19:13.433] 
[13:19:13.433] getGlobalsAndPackages() ... DONE
[13:19:13.433]  - globals found/used: [n=1] ‘FUN’
[13:19:13.434]  - needed namespaces: [n=0] 
[13:19:13.434] Finding globals ... DONE
[13:19:13.434]  - use_args: TRUE
[13:19:13.434]  - Getting '...' globals ...
[13:19:13.434] resolve() on list ...
[13:19:13.434]  recursive: 0
[13:19:13.434]  length: 1
[13:19:13.434]  elements: ‘...’
[13:19:13.434]  length: 0 (resolved future 1)
[13:19:13.435] resolve() on list ... DONE
[13:19:13.435]    - '...' content: [n=0] 
[13:19:13.435] List of 1
[13:19:13.435]  $ ...: list()
[13:19:13.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:13.435]  - attr(*, "where")=List of 1
[13:19:13.435]   ..$ ...:<environment: 0x562005e7d778> 
[13:19:13.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:13.435]  - attr(*, "resolved")= logi TRUE
[13:19:13.435]  - attr(*, "total_size")= num NA
[13:19:13.437]  - Getting '...' globals ... DONE
[13:19:13.437] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:13.438] List of 2
[13:19:13.438]  $ ...future.FUN:function (x)  
[13:19:13.438]  $ ...          : list()
[13:19:13.438]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:13.438]  - attr(*, "where")=List of 2
[13:19:13.438]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:13.438]   ..$ ...          :<environment: 0x562005e7d778> 
[13:19:13.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:13.438]  - attr(*, "resolved")= logi FALSE
[13:19:13.438]  - attr(*, "total_size")= num 4720
[13:19:13.442] Packages to be attached in all futures: [n=0] 
[13:19:13.442] getGlobalsAndPackagesXApply() ... DONE
[13:19:13.442] Number of futures (= number of chunks): 1
[13:19:13.442] Launching 1 futures (chunks) ...
[13:19:13.442] Chunk #1 of 1 ...
[13:19:13.443]  - Finding globals in 'X' for chunk #1 ...
[13:19:13.443] getGlobalsAndPackages() ...
[13:19:13.443] Searching for globals...
[13:19:13.443] 
[13:19:13.443] Searching for globals ... DONE
[13:19:13.443] - globals: [0] <none>
[13:19:13.443] getGlobalsAndPackages() ... DONE
[13:19:13.443]    + additional globals found: [n=0] 
[13:19:13.443]    + additional namespaces needed: [n=0] 
[13:19:13.444]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:13.444]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:13.444]  - seeds: <none>
[13:19:13.444] getGlobalsAndPackages() ...
[13:19:13.444] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:13.444] Resolving globals: FALSE
[13:19:13.444] Tweak future expression to call with '...' arguments ...
[13:19:13.444] {
[13:19:13.444]     do.call(function(...) {
[13:19:13.444]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:13.444]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:13.444]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:13.444]             on.exit(options(oopts), add = TRUE)
[13:19:13.444]         }
[13:19:13.444]         {
[13:19:13.444]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:13.444]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:13.444]                 ...future.FUN(...future.X_jj, ...)
[13:19:13.444]             })
[13:19:13.444]         }
[13:19:13.444]     }, args = future.call.arguments)
[13:19:13.444] }
[13:19:13.445] Tweak future expression to call with '...' arguments ... DONE
[13:19:13.445] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:13.445] 
[13:19:13.445] getGlobalsAndPackages() ... DONE
[13:19:13.445] run() for ‘Future’ ...
[13:19:13.446] - state: ‘created’
[13:19:13.446] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:13.449] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:13.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:13.449]   - Field: ‘label’
[13:19:13.450]   - Field: ‘local’
[13:19:13.450]   - Field: ‘owner’
[13:19:13.450]   - Field: ‘envir’
[13:19:13.450]   - Field: ‘packages’
[13:19:13.450]   - Field: ‘gc’
[13:19:13.450]   - Field: ‘conditions’
[13:19:13.450]   - Field: ‘expr’
[13:19:13.450]   - Field: ‘uuid’
[13:19:13.450]   - Field: ‘seed’
[13:19:13.450]   - Field: ‘version’
[13:19:13.450]   - Field: ‘result’
[13:19:13.451]   - Field: ‘asynchronous’
[13:19:13.451]   - Field: ‘calls’
[13:19:13.451]   - Field: ‘globals’
[13:19:13.451]   - Field: ‘stdout’
[13:19:13.451]   - Field: ‘earlySignal’
[13:19:13.451]   - Field: ‘lazy’
[13:19:13.451]   - Field: ‘state’
[13:19:13.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:13.451] - Launch lazy future ...
[13:19:13.451] Packages needed by the future expression (n = 0): <none>
[13:19:13.452] Packages needed by future strategies (n = 0): <none>
[13:19:13.452] {
[13:19:13.452]     {
[13:19:13.452]         {
[13:19:13.452]             ...future.startTime <- base::Sys.time()
[13:19:13.452]             {
[13:19:13.452]                 {
[13:19:13.452]                   {
[13:19:13.452]                     base::local({
[13:19:13.452]                       has_future <- base::requireNamespace("future", 
[13:19:13.452]                         quietly = TRUE)
[13:19:13.452]                       if (has_future) {
[13:19:13.452]                         ns <- base::getNamespace("future")
[13:19:13.452]                         version <- ns[[".package"]][["version"]]
[13:19:13.452]                         if (is.null(version)) 
[13:19:13.452]                           version <- utils::packageVersion("future")
[13:19:13.452]                       }
[13:19:13.452]                       else {
[13:19:13.452]                         version <- NULL
[13:19:13.452]                       }
[13:19:13.452]                       if (!has_future || version < "1.8.0") {
[13:19:13.452]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:13.452]                           "", base::R.version$version.string), 
[13:19:13.452]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:13.452]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:13.452]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:13.452]                             "release", "version")], collapse = " "), 
[13:19:13.452]                           hostname = base::Sys.info()[["nodename"]])
[13:19:13.452]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:13.452]                           info)
[13:19:13.452]                         info <- base::paste(info, collapse = "; ")
[13:19:13.452]                         if (!has_future) {
[13:19:13.452]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:13.452]                             info)
[13:19:13.452]                         }
[13:19:13.452]                         else {
[13:19:13.452]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:13.452]                             info, version)
[13:19:13.452]                         }
[13:19:13.452]                         base::stop(msg)
[13:19:13.452]                       }
[13:19:13.452]                     })
[13:19:13.452]                   }
[13:19:13.452]                   options(future.plan = NULL)
[13:19:13.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:13.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:13.452]                 }
[13:19:13.452]                 ...future.workdir <- getwd()
[13:19:13.452]             }
[13:19:13.452]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:13.452]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:13.452]         }
[13:19:13.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:13.452]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:13.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:13.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:13.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:13.452]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:13.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:13.452]             base::names(...future.oldOptions))
[13:19:13.452]     }
[13:19:13.452]     if (FALSE) {
[13:19:13.452]     }
[13:19:13.452]     else {
[13:19:13.452]         if (TRUE) {
[13:19:13.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:13.452]                 open = "w")
[13:19:13.452]         }
[13:19:13.452]         else {
[13:19:13.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:13.452]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:13.452]         }
[13:19:13.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:13.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:13.452]             base::sink(type = "output", split = FALSE)
[13:19:13.452]             base::close(...future.stdout)
[13:19:13.452]         }, add = TRUE)
[13:19:13.452]     }
[13:19:13.452]     ...future.frame <- base::sys.nframe()
[13:19:13.452]     ...future.conditions <- base::list()
[13:19:13.452]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:13.452]     if (FALSE) {
[13:19:13.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:13.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:13.452]     }
[13:19:13.452]     ...future.result <- base::tryCatch({
[13:19:13.452]         base::withCallingHandlers({
[13:19:13.452]             ...future.value <- base::withVisible(base::local({
[13:19:13.452]                 do.call(function(...) {
[13:19:13.452]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:13.452]                   if (!identical(...future.globals.maxSize.org, 
[13:19:13.452]                     ...future.globals.maxSize)) {
[13:19:13.452]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:13.452]                     on.exit(options(oopts), add = TRUE)
[13:19:13.452]                   }
[13:19:13.452]                   {
[13:19:13.452]                     lapply(seq_along(...future.elements_ii), 
[13:19:13.452]                       FUN = function(jj) {
[13:19:13.452]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:13.452]                         ...future.FUN(...future.X_jj, ...)
[13:19:13.452]                       })
[13:19:13.452]                   }
[13:19:13.452]                 }, args = future.call.arguments)
[13:19:13.452]             }))
[13:19:13.452]             future::FutureResult(value = ...future.value$value, 
[13:19:13.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:13.452]                   ...future.rng), globalenv = if (FALSE) 
[13:19:13.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:13.452]                     ...future.globalenv.names))
[13:19:13.452]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:13.452]         }, condition = base::local({
[13:19:13.452]             c <- base::c
[13:19:13.452]             inherits <- base::inherits
[13:19:13.452]             invokeRestart <- base::invokeRestart
[13:19:13.452]             length <- base::length
[13:19:13.452]             list <- base::list
[13:19:13.452]             seq.int <- base::seq.int
[13:19:13.452]             signalCondition <- base::signalCondition
[13:19:13.452]             sys.calls <- base::sys.calls
[13:19:13.452]             `[[` <- base::`[[`
[13:19:13.452]             `+` <- base::`+`
[13:19:13.452]             `<<-` <- base::`<<-`
[13:19:13.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:13.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:13.452]                   3L)]
[13:19:13.452]             }
[13:19:13.452]             function(cond) {
[13:19:13.452]                 is_error <- inherits(cond, "error")
[13:19:13.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:13.452]                   NULL)
[13:19:13.452]                 if (is_error) {
[13:19:13.452]                   sessionInformation <- function() {
[13:19:13.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:13.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:13.452]                       search = base::search(), system = base::Sys.info())
[13:19:13.452]                   }
[13:19:13.452]                   ...future.conditions[[length(...future.conditions) + 
[13:19:13.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:13.452]                     cond$call), session = sessionInformation(), 
[13:19:13.452]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:13.452]                   signalCondition(cond)
[13:19:13.452]                 }
[13:19:13.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:13.452]                 "immediateCondition"))) {
[13:19:13.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:13.452]                   ...future.conditions[[length(...future.conditions) + 
[13:19:13.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:13.452]                   if (TRUE && !signal) {
[13:19:13.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:13.452]                     {
[13:19:13.452]                       inherits <- base::inherits
[13:19:13.452]                       invokeRestart <- base::invokeRestart
[13:19:13.452]                       is.null <- base::is.null
[13:19:13.452]                       muffled <- FALSE
[13:19:13.452]                       if (inherits(cond, "message")) {
[13:19:13.452]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:13.452]                         if (muffled) 
[13:19:13.452]                           invokeRestart("muffleMessage")
[13:19:13.452]                       }
[13:19:13.452]                       else if (inherits(cond, "warning")) {
[13:19:13.452]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:13.452]                         if (muffled) 
[13:19:13.452]                           invokeRestart("muffleWarning")
[13:19:13.452]                       }
[13:19:13.452]                       else if (inherits(cond, "condition")) {
[13:19:13.452]                         if (!is.null(pattern)) {
[13:19:13.452]                           computeRestarts <- base::computeRestarts
[13:19:13.452]                           grepl <- base::grepl
[13:19:13.452]                           restarts <- computeRestarts(cond)
[13:19:13.452]                           for (restart in restarts) {
[13:19:13.452]                             name <- restart$name
[13:19:13.452]                             if (is.null(name)) 
[13:19:13.452]                               next
[13:19:13.452]                             if (!grepl(pattern, name)) 
[13:19:13.452]                               next
[13:19:13.452]                             invokeRestart(restart)
[13:19:13.452]                             muffled <- TRUE
[13:19:13.452]                             break
[13:19:13.452]                           }
[13:19:13.452]                         }
[13:19:13.452]                       }
[13:19:13.452]                       invisible(muffled)
[13:19:13.452]                     }
[13:19:13.452]                     muffleCondition(cond, pattern = "^muffle")
[13:19:13.452]                   }
[13:19:13.452]                 }
[13:19:13.452]                 else {
[13:19:13.452]                   if (TRUE) {
[13:19:13.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:13.452]                     {
[13:19:13.452]                       inherits <- base::inherits
[13:19:13.452]                       invokeRestart <- base::invokeRestart
[13:19:13.452]                       is.null <- base::is.null
[13:19:13.452]                       muffled <- FALSE
[13:19:13.452]                       if (inherits(cond, "message")) {
[13:19:13.452]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:13.452]                         if (muffled) 
[13:19:13.452]                           invokeRestart("muffleMessage")
[13:19:13.452]                       }
[13:19:13.452]                       else if (inherits(cond, "warning")) {
[13:19:13.452]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:13.452]                         if (muffled) 
[13:19:13.452]                           invokeRestart("muffleWarning")
[13:19:13.452]                       }
[13:19:13.452]                       else if (inherits(cond, "condition")) {
[13:19:13.452]                         if (!is.null(pattern)) {
[13:19:13.452]                           computeRestarts <- base::computeRestarts
[13:19:13.452]                           grepl <- base::grepl
[13:19:13.452]                           restarts <- computeRestarts(cond)
[13:19:13.452]                           for (restart in restarts) {
[13:19:13.452]                             name <- restart$name
[13:19:13.452]                             if (is.null(name)) 
[13:19:13.452]                               next
[13:19:13.452]                             if (!grepl(pattern, name)) 
[13:19:13.452]                               next
[13:19:13.452]                             invokeRestart(restart)
[13:19:13.452]                             muffled <- TRUE
[13:19:13.452]                             break
[13:19:13.452]                           }
[13:19:13.452]                         }
[13:19:13.452]                       }
[13:19:13.452]                       invisible(muffled)
[13:19:13.452]                     }
[13:19:13.452]                     muffleCondition(cond, pattern = "^muffle")
[13:19:13.452]                   }
[13:19:13.452]                 }
[13:19:13.452]             }
[13:19:13.452]         }))
[13:19:13.452]     }, error = function(ex) {
[13:19:13.452]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:13.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:13.452]                 ...future.rng), started = ...future.startTime, 
[13:19:13.452]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:13.452]             version = "1.8"), class = "FutureResult")
[13:19:13.452]     }, finally = {
[13:19:13.452]         if (!identical(...future.workdir, getwd())) 
[13:19:13.452]             setwd(...future.workdir)
[13:19:13.452]         {
[13:19:13.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:13.452]                 ...future.oldOptions$nwarnings <- NULL
[13:19:13.452]             }
[13:19:13.452]             base::options(...future.oldOptions)
[13:19:13.452]             if (.Platform$OS.type == "windows") {
[13:19:13.452]                 old_names <- names(...future.oldEnvVars)
[13:19:13.452]                 envs <- base::Sys.getenv()
[13:19:13.452]                 names <- names(envs)
[13:19:13.452]                 common <- intersect(names, old_names)
[13:19:13.452]                 added <- setdiff(names, old_names)
[13:19:13.452]                 removed <- setdiff(old_names, names)
[13:19:13.452]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:13.452]                   envs[common]]
[13:19:13.452]                 NAMES <- toupper(changed)
[13:19:13.452]                 args <- list()
[13:19:13.452]                 for (kk in seq_along(NAMES)) {
[13:19:13.452]                   name <- changed[[kk]]
[13:19:13.452]                   NAME <- NAMES[[kk]]
[13:19:13.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:13.452]                     next
[13:19:13.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:13.452]                 }
[13:19:13.452]                 NAMES <- toupper(added)
[13:19:13.452]                 for (kk in seq_along(NAMES)) {
[13:19:13.452]                   name <- added[[kk]]
[13:19:13.452]                   NAME <- NAMES[[kk]]
[13:19:13.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:13.452]                     next
[13:19:13.452]                   args[[name]] <- ""
[13:19:13.452]                 }
[13:19:13.452]                 NAMES <- toupper(removed)
[13:19:13.452]                 for (kk in seq_along(NAMES)) {
[13:19:13.452]                   name <- removed[[kk]]
[13:19:13.452]                   NAME <- NAMES[[kk]]
[13:19:13.452]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:13.452]                     next
[13:19:13.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:13.452]                 }
[13:19:13.452]                 if (length(args) > 0) 
[13:19:13.452]                   base::do.call(base::Sys.setenv, args = args)
[13:19:13.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:13.452]             }
[13:19:13.452]             else {
[13:19:13.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:13.452]             }
[13:19:13.452]             {
[13:19:13.452]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:13.452]                   0L) {
[13:19:13.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:13.452]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:13.452]                   base::options(opts)
[13:19:13.452]                 }
[13:19:13.452]                 {
[13:19:13.452]                   {
[13:19:13.452]                     NULL
[13:19:13.452]                     RNGkind("Mersenne-Twister")
[13:19:13.452]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:13.452]                       inherits = FALSE)
[13:19:13.452]                   }
[13:19:13.452]                   options(future.plan = NULL)
[13:19:13.452]                   if (is.na(NA_character_)) 
[13:19:13.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:13.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:13.452]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:13.452]                     envir = parent.frame()) 
[13:19:13.452]                   {
[13:19:13.452]                     default_workers <- missing(workers)
[13:19:13.452]                     if (is.function(workers)) 
[13:19:13.452]                       workers <- workers()
[13:19:13.452]                     workers <- structure(as.integer(workers), 
[13:19:13.452]                       class = class(workers))
[13:19:13.452]                     stop_if_not(is.finite(workers), workers >= 
[13:19:13.452]                       1L)
[13:19:13.452]                     if ((workers == 1L && !inherits(workers, 
[13:19:13.452]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:13.452]                       if (default_workers) 
[13:19:13.452]                         supportsMulticore(warn = TRUE)
[13:19:13.452]                       return(sequential(..., envir = envir))
[13:19:13.452]                     }
[13:19:13.452]                     oopts <- options(mc.cores = workers)
[13:19:13.452]                     on.exit(options(oopts))
[13:19:13.452]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:13.452]                       envir = envir)
[13:19:13.452]                     if (!future$lazy) 
[13:19:13.452]                       future <- run(future)
[13:19:13.452]                     invisible(future)
[13:19:13.452]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:13.452]                 }
[13:19:13.452]             }
[13:19:13.452]         }
[13:19:13.452]     })
[13:19:13.452]     if (TRUE) {
[13:19:13.452]         base::sink(type = "output", split = FALSE)
[13:19:13.452]         if (TRUE) {
[13:19:13.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:13.452]         }
[13:19:13.452]         else {
[13:19:13.452]             ...future.result["stdout"] <- base::list(NULL)
[13:19:13.452]         }
[13:19:13.452]         base::close(...future.stdout)
[13:19:13.452]         ...future.stdout <- NULL
[13:19:13.452]     }
[13:19:13.452]     ...future.result$conditions <- ...future.conditions
[13:19:13.452]     ...future.result$finished <- base::Sys.time()
[13:19:13.452]     ...future.result
[13:19:13.452] }
[13:19:13.454] assign_globals() ...
[13:19:13.454] List of 5
[13:19:13.454]  $ ...future.FUN            :function (x)  
[13:19:13.454]  $ future.call.arguments    : list()
[13:19:13.454]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:13.454]  $ ...future.elements_ii    :List of 2
[13:19:13.454]   ..$ : int 1
[13:19:13.454]   ..$ : int 0
[13:19:13.454]  $ ...future.seeds_ii       : NULL
[13:19:13.454]  $ ...future.globals.maxSize: NULL
[13:19:13.454]  - attr(*, "resolved")= logi FALSE
[13:19:13.454]  - attr(*, "total_size")= num 4720
[13:19:13.454]  - attr(*, "where")=List of 5
[13:19:13.454]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:13.454]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:13.454]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:13.454]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:13.454]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:13.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:13.454]  - attr(*, "already-done")= logi TRUE
[13:19:13.459] - reassign environment for ‘...future.FUN’
[13:19:13.459] - copied ‘...future.FUN’ to environment
[13:19:13.459] - copied ‘future.call.arguments’ to environment
[13:19:13.459] - copied ‘...future.elements_ii’ to environment
[13:19:13.459] - copied ‘...future.seeds_ii’ to environment
[13:19:13.459] - copied ‘...future.globals.maxSize’ to environment
[13:19:13.459] assign_globals() ... done
[13:19:13.460] plan(): Setting new future strategy stack:
[13:19:13.460] List of future strategies:
[13:19:13.460] 1. sequential:
[13:19:13.460]    - args: function (..., envir = parent.frame())
[13:19:13.460]    - tweaked: FALSE
[13:19:13.460]    - call: NULL
[13:19:13.460] plan(): nbrOfWorkers() = 1
[13:19:13.962] plan(): Setting new future strategy stack:
[13:19:13.962] List of future strategies:
[13:19:13.962] 1. multicore:
[13:19:13.962]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:13.962]    - tweaked: FALSE
[13:19:13.962]    - call: plan(strategy)
[13:19:13.966] plan(): nbrOfWorkers() = 1
[13:19:13.966] SequentialFuture started (and completed)
[13:19:13.966] - Launch lazy future ... done
[13:19:13.966] run() for ‘SequentialFuture’ ... done
[13:19:13.967] Created future:
[13:19:13.967] SequentialFuture:
[13:19:13.967] Label: ‘future_lapply-1’
[13:19:13.967] Expression:
[13:19:13.967] {
[13:19:13.967]     do.call(function(...) {
[13:19:13.967]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:13.967]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:13.967]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:13.967]             on.exit(options(oopts), add = TRUE)
[13:19:13.967]         }
[13:19:13.967]         {
[13:19:13.967]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:13.967]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:13.967]                 ...future.FUN(...future.X_jj, ...)
[13:19:13.967]             })
[13:19:13.967]         }
[13:19:13.967]     }, args = future.call.arguments)
[13:19:13.967] }
[13:19:13.967] Lazy evaluation: FALSE
[13:19:13.967] Asynchronous evaluation: FALSE
[13:19:13.967] Local evaluation: TRUE
[13:19:13.967] Environment: R_GlobalEnv
[13:19:13.967] Capture standard output: TRUE
[13:19:13.967] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:13.967] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:13.967] Packages: <none>
[13:19:13.967] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:13.967] Resolved: TRUE
[13:19:13.967] Value: 112 bytes of class ‘list’
[13:19:13.967] Early signaling: FALSE
[13:19:13.967] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:13.967] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:13.968] Chunk #1 of 1 ... DONE
[13:19:13.968] Launching 1 futures (chunks) ... DONE
[13:19:13.968] Resolving 1 futures (chunks) ...
[13:19:13.968] resolve() on list ...
[13:19:13.968]  recursive: 0
[13:19:13.968]  length: 1
[13:19:13.968] 
[13:19:13.968] resolved() for ‘SequentialFuture’ ...
[13:19:13.969] - state: ‘finished’
[13:19:13.969] - run: TRUE
[13:19:13.969] - result: ‘FutureResult’
[13:19:13.969] resolved() for ‘SequentialFuture’ ... done
[13:19:13.969] Future #1
[13:19:13.971] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:13.971] - nx: 1
[13:19:13.971] - relay: TRUE
[13:19:13.971] - stdout: TRUE
[13:19:13.971] - signal: TRUE
[13:19:13.971] - resignal: FALSE
[13:19:13.971] - force: TRUE
[13:19:13.971] - relayed: [n=1] FALSE
[13:19:13.972] - queued futures: [n=1] FALSE
[13:19:13.972]  - until=1
[13:19:13.972]  - relaying element #1
[13:19:13.972] - relayed: [n=1] TRUE
[13:19:13.972] - queued futures: [n=1] TRUE
[13:19:13.972] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:13.972]  length: 0 (resolved future 1)
[13:19:13.972] Relaying remaining futures
[13:19:13.972] signalConditionsASAP(NULL, pos=0) ...
[13:19:13.973] - nx: 1
[13:19:13.973] - relay: TRUE
[13:19:13.973] - stdout: TRUE
[13:19:13.973] - signal: TRUE
[13:19:13.973] - resignal: FALSE
[13:19:13.973] - force: TRUE
[13:19:13.973] - relayed: [n=1] TRUE
[13:19:13.973] - queued futures: [n=1] TRUE
 - flush all
[13:19:13.973] - relayed: [n=1] TRUE
[13:19:13.973] - queued futures: [n=1] TRUE
[13:19:13.973] signalConditionsASAP(NULL, pos=0) ... done
[13:19:13.974] resolve() on list ... DONE
[13:19:13.974]  - Number of value chunks collected: 1
[13:19:13.974] Resolving 1 futures (chunks) ... DONE
[13:19:13.974] Reducing values from 1 chunks ...
[13:19:13.974]  - Number of values collected after concatenation: 2
[13:19:13.974]  - Number of values expected: 2
[13:19:13.974] Reducing values from 1 chunks ... DONE
[13:19:13.974] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:19:13.975] future_lapply() ...
[13:19:13.979] Number of chunks: 1
[13:19:13.979] getGlobalsAndPackagesXApply() ...
[13:19:13.979]  - future.globals: TRUE
[13:19:13.979] getGlobalsAndPackages() ...
[13:19:13.979] Searching for globals...
[13:19:13.981] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:13.981] Searching for globals ... DONE
[13:19:13.981] Resolving globals: FALSE
[13:19:13.982] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:13.982] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:13.982] - globals: [1] ‘FUN’
[13:19:13.982] 
[13:19:13.982] getGlobalsAndPackages() ... DONE
[13:19:13.982]  - globals found/used: [n=1] ‘FUN’
[13:19:13.982]  - needed namespaces: [n=0] 
[13:19:13.982] Finding globals ... DONE
[13:19:13.983]  - use_args: TRUE
[13:19:13.983]  - Getting '...' globals ...
[13:19:13.983] resolve() on list ...
[13:19:13.983]  recursive: 0
[13:19:13.983]  length: 1
[13:19:13.983]  elements: ‘...’
[13:19:13.983]  length: 0 (resolved future 1)
[13:19:13.983] resolve() on list ... DONE
[13:19:13.984]    - '...' content: [n=0] 
[13:19:13.984] List of 1
[13:19:13.984]  $ ...: list()
[13:19:13.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:13.984]  - attr(*, "where")=List of 1
[13:19:13.984]   ..$ ...:<environment: 0x562003daa0e0> 
[13:19:13.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:13.984]  - attr(*, "resolved")= logi TRUE
[13:19:13.984]  - attr(*, "total_size")= num NA
[13:19:13.986]  - Getting '...' globals ... DONE
[13:19:13.986] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:13.987] List of 2
[13:19:13.987]  $ ...future.FUN:function (x)  
[13:19:13.987]  $ ...          : list()
[13:19:13.987]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:13.987]  - attr(*, "where")=List of 2
[13:19:13.987]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:13.987]   ..$ ...          :<environment: 0x562003daa0e0> 
[13:19:13.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:13.987]  - attr(*, "resolved")= logi FALSE
[13:19:13.987]  - attr(*, "total_size")= num 4720
[13:19:13.989] Packages to be attached in all futures: [n=0] 
[13:19:13.989] getGlobalsAndPackagesXApply() ... DONE
[13:19:13.989] Number of futures (= number of chunks): 1
[13:19:13.990] Launching 1 futures (chunks) ...
[13:19:13.990] Chunk #1 of 1 ...
[13:19:13.990]  - Finding globals in 'X' for chunk #1 ...
[13:19:13.990] getGlobalsAndPackages() ...
[13:19:13.990] Searching for globals...
[13:19:13.990] 
[13:19:13.990] Searching for globals ... DONE
[13:19:13.990] - globals: [0] <none>
[13:19:13.991] getGlobalsAndPackages() ... DONE
[13:19:13.991]    + additional globals found: [n=0] 
[13:19:13.991]    + additional namespaces needed: [n=0] 
[13:19:13.991]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:13.991]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:13.991]  - seeds: <none>
[13:19:13.991] getGlobalsAndPackages() ...
[13:19:13.991] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:13.991] Resolving globals: FALSE
[13:19:13.991] Tweak future expression to call with '...' arguments ...
[13:19:13.992] {
[13:19:13.992]     do.call(function(...) {
[13:19:13.992]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:13.992]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:13.992]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:13.992]             on.exit(options(oopts), add = TRUE)
[13:19:13.992]         }
[13:19:13.992]         {
[13:19:13.992]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:13.992]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:13.992]                 ...future.FUN(...future.X_jj, ...)
[13:19:13.992]             })
[13:19:13.992]         }
[13:19:13.992]     }, args = future.call.arguments)
[13:19:13.992] }
[13:19:13.992] Tweak future expression to call with '...' arguments ... DONE
[13:19:13.992] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:13.992] 
[13:19:13.992] getGlobalsAndPackages() ... DONE
[13:19:13.993] run() for ‘Future’ ...
[13:19:13.993] - state: ‘created’
[13:19:13.993] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:13.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:13.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:13.996]   - Field: ‘label’
[13:19:13.997]   - Field: ‘local’
[13:19:13.997]   - Field: ‘owner’
[13:19:13.997]   - Field: ‘envir’
[13:19:13.997]   - Field: ‘packages’
[13:19:13.997]   - Field: ‘gc’
[13:19:13.997]   - Field: ‘conditions’
[13:19:13.997]   - Field: ‘expr’
[13:19:13.997]   - Field: ‘uuid’
[13:19:13.997]   - Field: ‘seed’
[13:19:13.999]   - Field: ‘version’
[13:19:13.999]   - Field: ‘result’
[13:19:13.999]   - Field: ‘asynchronous’
[13:19:13.999]   - Field: ‘calls’
[13:19:13.999]   - Field: ‘globals’
[13:19:13.999]   - Field: ‘stdout’
[13:19:13.999]   - Field: ‘earlySignal’
[13:19:14.000]   - Field: ‘lazy’
[13:19:14.000]   - Field: ‘state’
[13:19:14.000] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:14.000] - Launch lazy future ...
[13:19:14.000] Packages needed by the future expression (n = 0): <none>
[13:19:14.000] Packages needed by future strategies (n = 0): <none>
[13:19:14.001] {
[13:19:14.001]     {
[13:19:14.001]         {
[13:19:14.001]             ...future.startTime <- base::Sys.time()
[13:19:14.001]             {
[13:19:14.001]                 {
[13:19:14.001]                   {
[13:19:14.001]                     base::local({
[13:19:14.001]                       has_future <- base::requireNamespace("future", 
[13:19:14.001]                         quietly = TRUE)
[13:19:14.001]                       if (has_future) {
[13:19:14.001]                         ns <- base::getNamespace("future")
[13:19:14.001]                         version <- ns[[".package"]][["version"]]
[13:19:14.001]                         if (is.null(version)) 
[13:19:14.001]                           version <- utils::packageVersion("future")
[13:19:14.001]                       }
[13:19:14.001]                       else {
[13:19:14.001]                         version <- NULL
[13:19:14.001]                       }
[13:19:14.001]                       if (!has_future || version < "1.8.0") {
[13:19:14.001]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:14.001]                           "", base::R.version$version.string), 
[13:19:14.001]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:14.001]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:14.001]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:14.001]                             "release", "version")], collapse = " "), 
[13:19:14.001]                           hostname = base::Sys.info()[["nodename"]])
[13:19:14.001]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:14.001]                           info)
[13:19:14.001]                         info <- base::paste(info, collapse = "; ")
[13:19:14.001]                         if (!has_future) {
[13:19:14.001]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:14.001]                             info)
[13:19:14.001]                         }
[13:19:14.001]                         else {
[13:19:14.001]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:14.001]                             info, version)
[13:19:14.001]                         }
[13:19:14.001]                         base::stop(msg)
[13:19:14.001]                       }
[13:19:14.001]                     })
[13:19:14.001]                   }
[13:19:14.001]                   options(future.plan = NULL)
[13:19:14.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:14.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:14.001]                 }
[13:19:14.001]                 ...future.workdir <- getwd()
[13:19:14.001]             }
[13:19:14.001]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:14.001]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:14.001]         }
[13:19:14.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:14.001]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:14.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:14.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:14.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:14.001]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:14.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:14.001]             base::names(...future.oldOptions))
[13:19:14.001]     }
[13:19:14.001]     if (TRUE) {
[13:19:14.001]     }
[13:19:14.001]     else {
[13:19:14.001]         if (NA) {
[13:19:14.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:14.001]                 open = "w")
[13:19:14.001]         }
[13:19:14.001]         else {
[13:19:14.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:14.001]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:14.001]         }
[13:19:14.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:14.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:14.001]             base::sink(type = "output", split = FALSE)
[13:19:14.001]             base::close(...future.stdout)
[13:19:14.001]         }, add = TRUE)
[13:19:14.001]     }
[13:19:14.001]     ...future.frame <- base::sys.nframe()
[13:19:14.001]     ...future.conditions <- base::list()
[13:19:14.001]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:14.001]     if (FALSE) {
[13:19:14.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:14.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:14.001]     }
[13:19:14.001]     ...future.result <- base::tryCatch({
[13:19:14.001]         base::withCallingHandlers({
[13:19:14.001]             ...future.value <- base::withVisible(base::local({
[13:19:14.001]                 do.call(function(...) {
[13:19:14.001]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:14.001]                   if (!identical(...future.globals.maxSize.org, 
[13:19:14.001]                     ...future.globals.maxSize)) {
[13:19:14.001]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:14.001]                     on.exit(options(oopts), add = TRUE)
[13:19:14.001]                   }
[13:19:14.001]                   {
[13:19:14.001]                     lapply(seq_along(...future.elements_ii), 
[13:19:14.001]                       FUN = function(jj) {
[13:19:14.001]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:14.001]                         ...future.FUN(...future.X_jj, ...)
[13:19:14.001]                       })
[13:19:14.001]                   }
[13:19:14.001]                 }, args = future.call.arguments)
[13:19:14.001]             }))
[13:19:14.001]             future::FutureResult(value = ...future.value$value, 
[13:19:14.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:14.001]                   ...future.rng), globalenv = if (FALSE) 
[13:19:14.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:14.001]                     ...future.globalenv.names))
[13:19:14.001]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:14.001]         }, condition = base::local({
[13:19:14.001]             c <- base::c
[13:19:14.001]             inherits <- base::inherits
[13:19:14.001]             invokeRestart <- base::invokeRestart
[13:19:14.001]             length <- base::length
[13:19:14.001]             list <- base::list
[13:19:14.001]             seq.int <- base::seq.int
[13:19:14.001]             signalCondition <- base::signalCondition
[13:19:14.001]             sys.calls <- base::sys.calls
[13:19:14.001]             `[[` <- base::`[[`
[13:19:14.001]             `+` <- base::`+`
[13:19:14.001]             `<<-` <- base::`<<-`
[13:19:14.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:14.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:14.001]                   3L)]
[13:19:14.001]             }
[13:19:14.001]             function(cond) {
[13:19:14.001]                 is_error <- inherits(cond, "error")
[13:19:14.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:14.001]                   NULL)
[13:19:14.001]                 if (is_error) {
[13:19:14.001]                   sessionInformation <- function() {
[13:19:14.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:14.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:14.001]                       search = base::search(), system = base::Sys.info())
[13:19:14.001]                   }
[13:19:14.001]                   ...future.conditions[[length(...future.conditions) + 
[13:19:14.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:14.001]                     cond$call), session = sessionInformation(), 
[13:19:14.001]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:14.001]                   signalCondition(cond)
[13:19:14.001]                 }
[13:19:14.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:14.001]                 "immediateCondition"))) {
[13:19:14.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:14.001]                   ...future.conditions[[length(...future.conditions) + 
[13:19:14.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:14.001]                   if (TRUE && !signal) {
[13:19:14.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:14.001]                     {
[13:19:14.001]                       inherits <- base::inherits
[13:19:14.001]                       invokeRestart <- base::invokeRestart
[13:19:14.001]                       is.null <- base::is.null
[13:19:14.001]                       muffled <- FALSE
[13:19:14.001]                       if (inherits(cond, "message")) {
[13:19:14.001]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:14.001]                         if (muffled) 
[13:19:14.001]                           invokeRestart("muffleMessage")
[13:19:14.001]                       }
[13:19:14.001]                       else if (inherits(cond, "warning")) {
[13:19:14.001]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:14.001]                         if (muffled) 
[13:19:14.001]                           invokeRestart("muffleWarning")
[13:19:14.001]                       }
[13:19:14.001]                       else if (inherits(cond, "condition")) {
[13:19:14.001]                         if (!is.null(pattern)) {
[13:19:14.001]                           computeRestarts <- base::computeRestarts
[13:19:14.001]                           grepl <- base::grepl
[13:19:14.001]                           restarts <- computeRestarts(cond)
[13:19:14.001]                           for (restart in restarts) {
[13:19:14.001]                             name <- restart$name
[13:19:14.001]                             if (is.null(name)) 
[13:19:14.001]                               next
[13:19:14.001]                             if (!grepl(pattern, name)) 
[13:19:14.001]                               next
[13:19:14.001]                             invokeRestart(restart)
[13:19:14.001]                             muffled <- TRUE
[13:19:14.001]                             break
[13:19:14.001]                           }
[13:19:14.001]                         }
[13:19:14.001]                       }
[13:19:14.001]                       invisible(muffled)
[13:19:14.001]                     }
[13:19:14.001]                     muffleCondition(cond, pattern = "^muffle")
[13:19:14.001]                   }
[13:19:14.001]                 }
[13:19:14.001]                 else {
[13:19:14.001]                   if (TRUE) {
[13:19:14.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:14.001]                     {
[13:19:14.001]                       inherits <- base::inherits
[13:19:14.001]                       invokeRestart <- base::invokeRestart
[13:19:14.001]                       is.null <- base::is.null
[13:19:14.001]                       muffled <- FALSE
[13:19:14.001]                       if (inherits(cond, "message")) {
[13:19:14.001]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:14.001]                         if (muffled) 
[13:19:14.001]                           invokeRestart("muffleMessage")
[13:19:14.001]                       }
[13:19:14.001]                       else if (inherits(cond, "warning")) {
[13:19:14.001]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:14.001]                         if (muffled) 
[13:19:14.001]                           invokeRestart("muffleWarning")
[13:19:14.001]                       }
[13:19:14.001]                       else if (inherits(cond, "condition")) {
[13:19:14.001]                         if (!is.null(pattern)) {
[13:19:14.001]                           computeRestarts <- base::computeRestarts
[13:19:14.001]                           grepl <- base::grepl
[13:19:14.001]                           restarts <- computeRestarts(cond)
[13:19:14.001]                           for (restart in restarts) {
[13:19:14.001]                             name <- restart$name
[13:19:14.001]                             if (is.null(name)) 
[13:19:14.001]                               next
[13:19:14.001]                             if (!grepl(pattern, name)) 
[13:19:14.001]                               next
[13:19:14.001]                             invokeRestart(restart)
[13:19:14.001]                             muffled <- TRUE
[13:19:14.001]                             break
[13:19:14.001]                           }
[13:19:14.001]                         }
[13:19:14.001]                       }
[13:19:14.001]                       invisible(muffled)
[13:19:14.001]                     }
[13:19:14.001]                     muffleCondition(cond, pattern = "^muffle")
[13:19:14.001]                   }
[13:19:14.001]                 }
[13:19:14.001]             }
[13:19:14.001]         }))
[13:19:14.001]     }, error = function(ex) {
[13:19:14.001]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:14.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:14.001]                 ...future.rng), started = ...future.startTime, 
[13:19:14.001]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:14.001]             version = "1.8"), class = "FutureResult")
[13:19:14.001]     }, finally = {
[13:19:14.001]         if (!identical(...future.workdir, getwd())) 
[13:19:14.001]             setwd(...future.workdir)
[13:19:14.001]         {
[13:19:14.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:14.001]                 ...future.oldOptions$nwarnings <- NULL
[13:19:14.001]             }
[13:19:14.001]             base::options(...future.oldOptions)
[13:19:14.001]             if (.Platform$OS.type == "windows") {
[13:19:14.001]                 old_names <- names(...future.oldEnvVars)
[13:19:14.001]                 envs <- base::Sys.getenv()
[13:19:14.001]                 names <- names(envs)
[13:19:14.001]                 common <- intersect(names, old_names)
[13:19:14.001]                 added <- setdiff(names, old_names)
[13:19:14.001]                 removed <- setdiff(old_names, names)
[13:19:14.001]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:14.001]                   envs[common]]
[13:19:14.001]                 NAMES <- toupper(changed)
[13:19:14.001]                 args <- list()
[13:19:14.001]                 for (kk in seq_along(NAMES)) {
[13:19:14.001]                   name <- changed[[kk]]
[13:19:14.001]                   NAME <- NAMES[[kk]]
[13:19:14.001]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:14.001]                     next
[13:19:14.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:14.001]                 }
[13:19:14.001]                 NAMES <- toupper(added)
[13:19:14.001]                 for (kk in seq_along(NAMES)) {
[13:19:14.001]                   name <- added[[kk]]
[13:19:14.001]                   NAME <- NAMES[[kk]]
[13:19:14.001]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:14.001]                     next
[13:19:14.001]                   args[[name]] <- ""
[13:19:14.001]                 }
[13:19:14.001]                 NAMES <- toupper(removed)
[13:19:14.001]                 for (kk in seq_along(NAMES)) {
[13:19:14.001]                   name <- removed[[kk]]
[13:19:14.001]                   NAME <- NAMES[[kk]]
[13:19:14.001]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:14.001]                     next
[13:19:14.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:14.001]                 }
[13:19:14.001]                 if (length(args) > 0) 
[13:19:14.001]                   base::do.call(base::Sys.setenv, args = args)
[13:19:14.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:14.001]             }
[13:19:14.001]             else {
[13:19:14.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:14.001]             }
[13:19:14.001]             {
[13:19:14.001]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:14.001]                   0L) {
[13:19:14.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:14.001]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:14.001]                   base::options(opts)
[13:19:14.001]                 }
[13:19:14.001]                 {
[13:19:14.001]                   {
[13:19:14.001]                     NULL
[13:19:14.001]                     RNGkind("Mersenne-Twister")
[13:19:14.001]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:14.001]                       inherits = FALSE)
[13:19:14.001]                   }
[13:19:14.001]                   options(future.plan = NULL)
[13:19:14.001]                   if (is.na(NA_character_)) 
[13:19:14.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:14.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:14.001]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:14.001]                     envir = parent.frame()) 
[13:19:14.001]                   {
[13:19:14.001]                     default_workers <- missing(workers)
[13:19:14.001]                     if (is.function(workers)) 
[13:19:14.001]                       workers <- workers()
[13:19:14.001]                     workers <- structure(as.integer(workers), 
[13:19:14.001]                       class = class(workers))
[13:19:14.001]                     stop_if_not(is.finite(workers), workers >= 
[13:19:14.001]                       1L)
[13:19:14.001]                     if ((workers == 1L && !inherits(workers, 
[13:19:14.001]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:14.001]                       if (default_workers) 
[13:19:14.001]                         supportsMulticore(warn = TRUE)
[13:19:14.001]                       return(sequential(..., envir = envir))
[13:19:14.001]                     }
[13:19:14.001]                     oopts <- options(mc.cores = workers)
[13:19:14.001]                     on.exit(options(oopts))
[13:19:14.001]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:14.001]                       envir = envir)
[13:19:14.001]                     if (!future$lazy) 
[13:19:14.001]                       future <- run(future)
[13:19:14.001]                     invisible(future)
[13:19:14.001]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:14.001]                 }
[13:19:14.001]             }
[13:19:14.001]         }
[13:19:14.001]     })
[13:19:14.001]     if (FALSE) {
[13:19:14.001]         base::sink(type = "output", split = FALSE)
[13:19:14.001]         if (NA) {
[13:19:14.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:14.001]         }
[13:19:14.001]         else {
[13:19:14.001]             ...future.result["stdout"] <- base::list(NULL)
[13:19:14.001]         }
[13:19:14.001]         base::close(...future.stdout)
[13:19:14.001]         ...future.stdout <- NULL
[13:19:14.001]     }
[13:19:14.001]     ...future.result$conditions <- ...future.conditions
[13:19:14.001]     ...future.result$finished <- base::Sys.time()
[13:19:14.001]     ...future.result
[13:19:14.001] }
[13:19:14.002] assign_globals() ...
[13:19:14.003] List of 5
[13:19:14.003]  $ ...future.FUN            :function (x)  
[13:19:14.003]  $ future.call.arguments    : list()
[13:19:14.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:14.003]  $ ...future.elements_ii    :List of 2
[13:19:14.003]   ..$ : int 1
[13:19:14.003]   ..$ : int 0
[13:19:14.003]  $ ...future.seeds_ii       : NULL
[13:19:14.003]  $ ...future.globals.maxSize: NULL
[13:19:14.003]  - attr(*, "resolved")= logi FALSE
[13:19:14.003]  - attr(*, "total_size")= num 4720
[13:19:14.003]  - attr(*, "where")=List of 5
[13:19:14.003]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:14.003]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:14.003]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:14.003]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:14.003]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:14.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:14.003]  - attr(*, "already-done")= logi TRUE
[13:19:14.007] - reassign environment for ‘...future.FUN’
[13:19:14.007] - copied ‘...future.FUN’ to environment
[13:19:14.008] - copied ‘future.call.arguments’ to environment
[13:19:14.008] - copied ‘...future.elements_ii’ to environment
[13:19:14.008] - copied ‘...future.seeds_ii’ to environment
[13:19:14.008] - copied ‘...future.globals.maxSize’ to environment
[13:19:14.008] assign_globals() ... done
[13:19:14.008] plan(): Setting new future strategy stack:
[13:19:14.008] List of future strategies:
[13:19:14.008] 1. sequential:
[13:19:14.008]    - args: function (..., envir = parent.frame())
[13:19:14.008]    - tweaked: FALSE
[13:19:14.008]    - call: NULL
[13:19:14.009] plan(): nbrOfWorkers() = 1
[13:19:14.510] plan(): Setting new future strategy stack:
[13:19:14.510] List of future strategies:
[13:19:14.510] 1. multicore:
[13:19:14.510]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:14.510]    - tweaked: FALSE
[13:19:14.510]    - call: plan(strategy)
[13:19:14.515] plan(): nbrOfWorkers() = 1
[13:19:14.515] SequentialFuture started (and completed)
[13:19:14.515] - Launch lazy future ... done
[13:19:14.515] run() for ‘SequentialFuture’ ... done
[13:19:14.515] Created future:
[13:19:14.516] SequentialFuture:
[13:19:14.516] Label: ‘future_lapply-1’
[13:19:14.516] Expression:
[13:19:14.516] {
[13:19:14.516]     do.call(function(...) {
[13:19:14.516]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:14.516]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:14.516]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:14.516]             on.exit(options(oopts), add = TRUE)
[13:19:14.516]         }
[13:19:14.516]         {
[13:19:14.516]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:14.516]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:14.516]                 ...future.FUN(...future.X_jj, ...)
[13:19:14.516]             })
[13:19:14.516]         }
[13:19:14.516]     }, args = future.call.arguments)
[13:19:14.516] }
[13:19:14.516] Lazy evaluation: FALSE
[13:19:14.516] Asynchronous evaluation: FALSE
[13:19:14.516] Local evaluation: TRUE
[13:19:14.516] Environment: R_GlobalEnv
[13:19:14.516] Capture standard output: NA
[13:19:14.516] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:14.516] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:14.516] Packages: <none>
[13:19:14.516] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:14.516] Resolved: TRUE
[13:19:14.516] Value: 112 bytes of class ‘list’
[13:19:14.516] Early signaling: FALSE
[13:19:14.516] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:14.516] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:14.517] Chunk #1 of 1 ... DONE
[13:19:14.517] Launching 1 futures (chunks) ... DONE
[13:19:14.517] Resolving 1 futures (chunks) ...
[13:19:14.517] resolve() on list ...
[13:19:14.517]  recursive: 0
[13:19:14.517]  length: 1
[13:19:14.517] 
[13:19:14.517] resolved() for ‘SequentialFuture’ ...
[13:19:14.518] - state: ‘finished’
[13:19:14.518] - run: TRUE
[13:19:14.518] - result: ‘FutureResult’
[13:19:14.518] resolved() for ‘SequentialFuture’ ... done
[13:19:14.518] Future #1
[13:19:14.518] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:14.518] - nx: 1
[13:19:14.518] - relay: TRUE
[13:19:14.518] - stdout: TRUE
[13:19:14.518] - signal: TRUE
[13:19:14.519] - resignal: FALSE
[13:19:14.519] - force: TRUE
[13:19:14.519] - relayed: [n=1] FALSE
[13:19:14.519] - queued futures: [n=1] FALSE
[13:19:14.519]  - until=1
[13:19:14.519]  - relaying element #1
[13:19:14.519] - relayed: [n=1] TRUE
[13:19:14.519] - queued futures: [n=1] TRUE
[13:19:14.519] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:14.519]  length: 0 (resolved future 1)
[13:19:14.520] Relaying remaining futures
[13:19:14.520] signalConditionsASAP(NULL, pos=0) ...
[13:19:14.520] - nx: 1
[13:19:14.520] - relay: TRUE
[13:19:14.520] - stdout: TRUE
[13:19:14.520] - signal: TRUE
[13:19:14.520] - resignal: FALSE
[13:19:14.520] - force: TRUE
[13:19:14.520] - relayed: [n=1] TRUE
[13:19:14.520] - queued futures: [n=1] TRUE
 - flush all
[13:19:14.520] - relayed: [n=1] TRUE
[13:19:14.521] - queued futures: [n=1] TRUE
[13:19:14.521] signalConditionsASAP(NULL, pos=0) ... done
[13:19:14.521] resolve() on list ... DONE
[13:19:14.521]  - Number of value chunks collected: 1
[13:19:14.521] Resolving 1 futures (chunks) ... DONE
[13:19:14.521] Reducing values from 1 chunks ...
[13:19:14.521]  - Number of values collected after concatenation: 2
[13:19:14.521]  - Number of values expected: 2
[13:19:14.521] Reducing values from 1 chunks ... DONE
[13:19:14.521] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:19:14.522] future_mapply() ...
[13:19:14.525] Number of chunks: 1
[13:19:14.525] getGlobalsAndPackagesXApply() ...
[13:19:14.525]  - future.globals: TRUE
[13:19:14.525] getGlobalsAndPackages() ...
[13:19:14.525] Searching for globals...
[13:19:14.527] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:14.527] Searching for globals ... DONE
[13:19:14.527] Resolving globals: FALSE
[13:19:14.528] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:14.528] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:14.528] - globals: [1] ‘FUN’
[13:19:14.528] 
[13:19:14.528] getGlobalsAndPackages() ... DONE
[13:19:14.528]  - globals found/used: [n=1] ‘FUN’
[13:19:14.529]  - needed namespaces: [n=0] 
[13:19:14.529] Finding globals ... DONE
[13:19:14.531] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:14.531] List of 2
[13:19:14.531]  $ ...future.FUN:function (x, y)  
[13:19:14.531]  $ MoreArgs     : NULL
[13:19:14.531]  - attr(*, "where")=List of 2
[13:19:14.531]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:14.531]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:14.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:14.531]  - attr(*, "resolved")= logi FALSE
[13:19:14.531]  - attr(*, "total_size")= num NA
[13:19:14.533] Packages to be attached in all futures: [n=0] 
[13:19:14.533] getGlobalsAndPackagesXApply() ... DONE
[13:19:14.534] Number of futures (= number of chunks): 1
[13:19:14.534] Launching 1 futures (chunks) ...
[13:19:14.534] Chunk #1 of 1 ...
[13:19:14.534]  - Finding globals in '...' for chunk #1 ...
[13:19:14.534] getGlobalsAndPackages() ...
[13:19:14.534] Searching for globals...
[13:19:14.534] 
[13:19:14.535] Searching for globals ... DONE
[13:19:14.535] - globals: [0] <none>
[13:19:14.535] getGlobalsAndPackages() ... DONE
[13:19:14.535]    + additional globals found: [n=0] 
[13:19:14.535]    + additional namespaces needed: [n=0] 
[13:19:14.535]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:14.535]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:14.535]  - seeds: <none>
[13:19:14.535] getGlobalsAndPackages() ...
[13:19:14.535] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:14.536] Resolving globals: FALSE
[13:19:14.536] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:14.536] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:14.537] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:14.537] 
[13:19:14.537] getGlobalsAndPackages() ... DONE
[13:19:14.537] run() for ‘Future’ ...
[13:19:14.537] - state: ‘created’
[13:19:14.537] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:14.541] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:14.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:14.541]   - Field: ‘label’
[13:19:14.542]   - Field: ‘local’
[13:19:14.542]   - Field: ‘owner’
[13:19:14.542]   - Field: ‘envir’
[13:19:14.542]   - Field: ‘packages’
[13:19:14.542]   - Field: ‘gc’
[13:19:14.542]   - Field: ‘conditions’
[13:19:14.542]   - Field: ‘expr’
[13:19:14.542]   - Field: ‘uuid’
[13:19:14.542]   - Field: ‘seed’
[13:19:14.543]   - Field: ‘version’
[13:19:14.543]   - Field: ‘result’
[13:19:14.543]   - Field: ‘asynchronous’
[13:19:14.543]   - Field: ‘calls’
[13:19:14.543]   - Field: ‘globals’
[13:19:14.543]   - Field: ‘stdout’
[13:19:14.543]   - Field: ‘earlySignal’
[13:19:14.543]   - Field: ‘lazy’
[13:19:14.543]   - Field: ‘state’
[13:19:14.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:14.544] - Launch lazy future ...
[13:19:14.544] Packages needed by the future expression (n = 0): <none>
[13:19:14.544] Packages needed by future strategies (n = 0): <none>
[13:19:14.544] {
[13:19:14.544]     {
[13:19:14.544]         {
[13:19:14.544]             ...future.startTime <- base::Sys.time()
[13:19:14.544]             {
[13:19:14.544]                 {
[13:19:14.544]                   {
[13:19:14.544]                     base::local({
[13:19:14.544]                       has_future <- base::requireNamespace("future", 
[13:19:14.544]                         quietly = TRUE)
[13:19:14.544]                       if (has_future) {
[13:19:14.544]                         ns <- base::getNamespace("future")
[13:19:14.544]                         version <- ns[[".package"]][["version"]]
[13:19:14.544]                         if (is.null(version)) 
[13:19:14.544]                           version <- utils::packageVersion("future")
[13:19:14.544]                       }
[13:19:14.544]                       else {
[13:19:14.544]                         version <- NULL
[13:19:14.544]                       }
[13:19:14.544]                       if (!has_future || version < "1.8.0") {
[13:19:14.544]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:14.544]                           "", base::R.version$version.string), 
[13:19:14.544]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:14.544]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:14.544]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:14.544]                             "release", "version")], collapse = " "), 
[13:19:14.544]                           hostname = base::Sys.info()[["nodename"]])
[13:19:14.544]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:14.544]                           info)
[13:19:14.544]                         info <- base::paste(info, collapse = "; ")
[13:19:14.544]                         if (!has_future) {
[13:19:14.544]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:14.544]                             info)
[13:19:14.544]                         }
[13:19:14.544]                         else {
[13:19:14.544]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:14.544]                             info, version)
[13:19:14.544]                         }
[13:19:14.544]                         base::stop(msg)
[13:19:14.544]                       }
[13:19:14.544]                     })
[13:19:14.544]                   }
[13:19:14.544]                   options(future.plan = NULL)
[13:19:14.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:14.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:14.544]                 }
[13:19:14.544]                 ...future.workdir <- getwd()
[13:19:14.544]             }
[13:19:14.544]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:14.544]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:14.544]         }
[13:19:14.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:14.544]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:14.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:14.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:14.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:14.544]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:14.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:14.544]             base::names(...future.oldOptions))
[13:19:14.544]     }
[13:19:14.544]     if (FALSE) {
[13:19:14.544]     }
[13:19:14.544]     else {
[13:19:14.544]         if (FALSE) {
[13:19:14.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:14.544]                 open = "w")
[13:19:14.544]         }
[13:19:14.544]         else {
[13:19:14.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:14.544]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:14.544]         }
[13:19:14.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:14.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:14.544]             base::sink(type = "output", split = FALSE)
[13:19:14.544]             base::close(...future.stdout)
[13:19:14.544]         }, add = TRUE)
[13:19:14.544]     }
[13:19:14.544]     ...future.frame <- base::sys.nframe()
[13:19:14.544]     ...future.conditions <- base::list()
[13:19:14.544]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:14.544]     if (FALSE) {
[13:19:14.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:14.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:14.544]     }
[13:19:14.544]     ...future.result <- base::tryCatch({
[13:19:14.544]         base::withCallingHandlers({
[13:19:14.544]             ...future.value <- base::withVisible(base::local({
[13:19:14.544]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:14.544]                 if (!identical(...future.globals.maxSize.org, 
[13:19:14.544]                   ...future.globals.maxSize)) {
[13:19:14.544]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:14.544]                   on.exit(options(oopts), add = TRUE)
[13:19:14.544]                 }
[13:19:14.544]                 {
[13:19:14.544]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:14.544]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:14.544]                     USE.NAMES = FALSE)
[13:19:14.544]                   do.call(mapply, args = args)
[13:19:14.544]                 }
[13:19:14.544]             }))
[13:19:14.544]             future::FutureResult(value = ...future.value$value, 
[13:19:14.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:14.544]                   ...future.rng), globalenv = if (FALSE) 
[13:19:14.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:14.544]                     ...future.globalenv.names))
[13:19:14.544]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:14.544]         }, condition = base::local({
[13:19:14.544]             c <- base::c
[13:19:14.544]             inherits <- base::inherits
[13:19:14.544]             invokeRestart <- base::invokeRestart
[13:19:14.544]             length <- base::length
[13:19:14.544]             list <- base::list
[13:19:14.544]             seq.int <- base::seq.int
[13:19:14.544]             signalCondition <- base::signalCondition
[13:19:14.544]             sys.calls <- base::sys.calls
[13:19:14.544]             `[[` <- base::`[[`
[13:19:14.544]             `+` <- base::`+`
[13:19:14.544]             `<<-` <- base::`<<-`
[13:19:14.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:14.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:14.544]                   3L)]
[13:19:14.544]             }
[13:19:14.544]             function(cond) {
[13:19:14.544]                 is_error <- inherits(cond, "error")
[13:19:14.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:14.544]                   NULL)
[13:19:14.544]                 if (is_error) {
[13:19:14.544]                   sessionInformation <- function() {
[13:19:14.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:14.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:14.544]                       search = base::search(), system = base::Sys.info())
[13:19:14.544]                   }
[13:19:14.544]                   ...future.conditions[[length(...future.conditions) + 
[13:19:14.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:14.544]                     cond$call), session = sessionInformation(), 
[13:19:14.544]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:14.544]                   signalCondition(cond)
[13:19:14.544]                 }
[13:19:14.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:14.544]                 "immediateCondition"))) {
[13:19:14.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:14.544]                   ...future.conditions[[length(...future.conditions) + 
[13:19:14.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:14.544]                   if (TRUE && !signal) {
[13:19:14.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:14.544]                     {
[13:19:14.544]                       inherits <- base::inherits
[13:19:14.544]                       invokeRestart <- base::invokeRestart
[13:19:14.544]                       is.null <- base::is.null
[13:19:14.544]                       muffled <- FALSE
[13:19:14.544]                       if (inherits(cond, "message")) {
[13:19:14.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:14.544]                         if (muffled) 
[13:19:14.544]                           invokeRestart("muffleMessage")
[13:19:14.544]                       }
[13:19:14.544]                       else if (inherits(cond, "warning")) {
[13:19:14.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:14.544]                         if (muffled) 
[13:19:14.544]                           invokeRestart("muffleWarning")
[13:19:14.544]                       }
[13:19:14.544]                       else if (inherits(cond, "condition")) {
[13:19:14.544]                         if (!is.null(pattern)) {
[13:19:14.544]                           computeRestarts <- base::computeRestarts
[13:19:14.544]                           grepl <- base::grepl
[13:19:14.544]                           restarts <- computeRestarts(cond)
[13:19:14.544]                           for (restart in restarts) {
[13:19:14.544]                             name <- restart$name
[13:19:14.544]                             if (is.null(name)) 
[13:19:14.544]                               next
[13:19:14.544]                             if (!grepl(pattern, name)) 
[13:19:14.544]                               next
[13:19:14.544]                             invokeRestart(restart)
[13:19:14.544]                             muffled <- TRUE
[13:19:14.544]                             break
[13:19:14.544]                           }
[13:19:14.544]                         }
[13:19:14.544]                       }
[13:19:14.544]                       invisible(muffled)
[13:19:14.544]                     }
[13:19:14.544]                     muffleCondition(cond, pattern = "^muffle")
[13:19:14.544]                   }
[13:19:14.544]                 }
[13:19:14.544]                 else {
[13:19:14.544]                   if (TRUE) {
[13:19:14.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:14.544]                     {
[13:19:14.544]                       inherits <- base::inherits
[13:19:14.544]                       invokeRestart <- base::invokeRestart
[13:19:14.544]                       is.null <- base::is.null
[13:19:14.544]                       muffled <- FALSE
[13:19:14.544]                       if (inherits(cond, "message")) {
[13:19:14.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:14.544]                         if (muffled) 
[13:19:14.544]                           invokeRestart("muffleMessage")
[13:19:14.544]                       }
[13:19:14.544]                       else if (inherits(cond, "warning")) {
[13:19:14.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:14.544]                         if (muffled) 
[13:19:14.544]                           invokeRestart("muffleWarning")
[13:19:14.544]                       }
[13:19:14.544]                       else if (inherits(cond, "condition")) {
[13:19:14.544]                         if (!is.null(pattern)) {
[13:19:14.544]                           computeRestarts <- base::computeRestarts
[13:19:14.544]                           grepl <- base::grepl
[13:19:14.544]                           restarts <- computeRestarts(cond)
[13:19:14.544]                           for (restart in restarts) {
[13:19:14.544]                             name <- restart$name
[13:19:14.544]                             if (is.null(name)) 
[13:19:14.544]                               next
[13:19:14.544]                             if (!grepl(pattern, name)) 
[13:19:14.544]                               next
[13:19:14.544]                             invokeRestart(restart)
[13:19:14.544]                             muffled <- TRUE
[13:19:14.544]                             break
[13:19:14.544]                           }
[13:19:14.544]                         }
[13:19:14.544]                       }
[13:19:14.544]                       invisible(muffled)
[13:19:14.544]                     }
[13:19:14.544]                     muffleCondition(cond, pattern = "^muffle")
[13:19:14.544]                   }
[13:19:14.544]                 }
[13:19:14.544]             }
[13:19:14.544]         }))
[13:19:14.544]     }, error = function(ex) {
[13:19:14.544]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:14.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:14.544]                 ...future.rng), started = ...future.startTime, 
[13:19:14.544]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:14.544]             version = "1.8"), class = "FutureResult")
[13:19:14.544]     }, finally = {
[13:19:14.544]         if (!identical(...future.workdir, getwd())) 
[13:19:14.544]             setwd(...future.workdir)
[13:19:14.544]         {
[13:19:14.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:14.544]                 ...future.oldOptions$nwarnings <- NULL
[13:19:14.544]             }
[13:19:14.544]             base::options(...future.oldOptions)
[13:19:14.544]             if (.Platform$OS.type == "windows") {
[13:19:14.544]                 old_names <- names(...future.oldEnvVars)
[13:19:14.544]                 envs <- base::Sys.getenv()
[13:19:14.544]                 names <- names(envs)
[13:19:14.544]                 common <- intersect(names, old_names)
[13:19:14.544]                 added <- setdiff(names, old_names)
[13:19:14.544]                 removed <- setdiff(old_names, names)
[13:19:14.544]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:14.544]                   envs[common]]
[13:19:14.544]                 NAMES <- toupper(changed)
[13:19:14.544]                 args <- list()
[13:19:14.544]                 for (kk in seq_along(NAMES)) {
[13:19:14.544]                   name <- changed[[kk]]
[13:19:14.544]                   NAME <- NAMES[[kk]]
[13:19:14.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:14.544]                     next
[13:19:14.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:14.544]                 }
[13:19:14.544]                 NAMES <- toupper(added)
[13:19:14.544]                 for (kk in seq_along(NAMES)) {
[13:19:14.544]                   name <- added[[kk]]
[13:19:14.544]                   NAME <- NAMES[[kk]]
[13:19:14.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:14.544]                     next
[13:19:14.544]                   args[[name]] <- ""
[13:19:14.544]                 }
[13:19:14.544]                 NAMES <- toupper(removed)
[13:19:14.544]                 for (kk in seq_along(NAMES)) {
[13:19:14.544]                   name <- removed[[kk]]
[13:19:14.544]                   NAME <- NAMES[[kk]]
[13:19:14.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:14.544]                     next
[13:19:14.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:14.544]                 }
[13:19:14.544]                 if (length(args) > 0) 
[13:19:14.544]                   base::do.call(base::Sys.setenv, args = args)
[13:19:14.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:14.544]             }
[13:19:14.544]             else {
[13:19:14.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:14.544]             }
[13:19:14.544]             {
[13:19:14.544]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:14.544]                   0L) {
[13:19:14.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:14.544]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:14.544]                   base::options(opts)
[13:19:14.544]                 }
[13:19:14.544]                 {
[13:19:14.544]                   {
[13:19:14.544]                     NULL
[13:19:14.544]                     RNGkind("Mersenne-Twister")
[13:19:14.544]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:14.544]                       inherits = FALSE)
[13:19:14.544]                   }
[13:19:14.544]                   options(future.plan = NULL)
[13:19:14.544]                   if (is.na(NA_character_)) 
[13:19:14.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:14.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:14.544]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:14.544]                     envir = parent.frame()) 
[13:19:14.544]                   {
[13:19:14.544]                     default_workers <- missing(workers)
[13:19:14.544]                     if (is.function(workers)) 
[13:19:14.544]                       workers <- workers()
[13:19:14.544]                     workers <- structure(as.integer(workers), 
[13:19:14.544]                       class = class(workers))
[13:19:14.544]                     stop_if_not(is.finite(workers), workers >= 
[13:19:14.544]                       1L)
[13:19:14.544]                     if ((workers == 1L && !inherits(workers, 
[13:19:14.544]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:14.544]                       if (default_workers) 
[13:19:14.544]                         supportsMulticore(warn = TRUE)
[13:19:14.544]                       return(sequential(..., envir = envir))
[13:19:14.544]                     }
[13:19:14.544]                     oopts <- options(mc.cores = workers)
[13:19:14.544]                     on.exit(options(oopts))
[13:19:14.544]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:14.544]                       envir = envir)
[13:19:14.544]                     if (!future$lazy) 
[13:19:14.544]                       future <- run(future)
[13:19:14.544]                     invisible(future)
[13:19:14.544]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:14.544]                 }
[13:19:14.544]             }
[13:19:14.544]         }
[13:19:14.544]     })
[13:19:14.544]     if (TRUE) {
[13:19:14.544]         base::sink(type = "output", split = FALSE)
[13:19:14.544]         if (FALSE) {
[13:19:14.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:14.544]         }
[13:19:14.544]         else {
[13:19:14.544]             ...future.result["stdout"] <- base::list(NULL)
[13:19:14.544]         }
[13:19:14.544]         base::close(...future.stdout)
[13:19:14.544]         ...future.stdout <- NULL
[13:19:14.544]     }
[13:19:14.544]     ...future.result$conditions <- ...future.conditions
[13:19:14.544]     ...future.result$finished <- base::Sys.time()
[13:19:14.544]     ...future.result
[13:19:14.544] }
[13:19:14.546] assign_globals() ...
[13:19:14.546] List of 5
[13:19:14.546]  $ ...future.FUN            :function (x, y)  
[13:19:14.546]  $ MoreArgs                 : NULL
[13:19:14.546]  $ ...future.elements_ii    :List of 2
[13:19:14.546]   ..$ :List of 2
[13:19:14.546]   .. ..$ : int 1
[13:19:14.546]   .. ..$ : int 0
[13:19:14.546]   ..$ :List of 2
[13:19:14.546]   .. ..$ : int 0
[13:19:14.546]   .. ..$ : int 1
[13:19:14.546]  $ ...future.seeds_ii       : NULL
[13:19:14.546]  $ ...future.globals.maxSize: NULL
[13:19:14.546]  - attr(*, "resolved")= logi FALSE
[13:19:14.546]  - attr(*, "total_size")= num 6480
[13:19:14.546]  - attr(*, "where")=List of 5
[13:19:14.546]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:14.546]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:14.546]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:14.546]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:14.546]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:14.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:14.546]  - attr(*, "already-done")= logi TRUE
[13:19:14.552] - reassign environment for ‘...future.FUN’
[13:19:14.552] - copied ‘...future.FUN’ to environment
[13:19:14.552] - copied ‘MoreArgs’ to environment
[13:19:14.552] - copied ‘...future.elements_ii’ to environment
[13:19:14.552] - copied ‘...future.seeds_ii’ to environment
[13:19:14.552] - copied ‘...future.globals.maxSize’ to environment
[13:19:14.552] assign_globals() ... done
[13:19:14.553] plan(): Setting new future strategy stack:
[13:19:14.553] List of future strategies:
[13:19:14.553] 1. sequential:
[13:19:14.553]    - args: function (..., envir = parent.frame())
[13:19:14.553]    - tweaked: FALSE
[13:19:14.553]    - call: NULL
[13:19:14.553] plan(): nbrOfWorkers() = 1
[13:19:15.055] plan(): Setting new future strategy stack:
[13:19:15.055] List of future strategies:
[13:19:15.055] 1. multicore:
[13:19:15.055]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:15.055]    - tweaked: FALSE
[13:19:15.055]    - call: plan(strategy)
[13:19:15.059] plan(): nbrOfWorkers() = 1
[13:19:15.060] SequentialFuture started (and completed)
[13:19:15.060] - Launch lazy future ... done
[13:19:15.060] run() for ‘SequentialFuture’ ... done
[13:19:15.060] Created future:
[13:19:15.060] SequentialFuture:
[13:19:15.060] Label: ‘future_mapply-1’
[13:19:15.060] Expression:
[13:19:15.060] {
[13:19:15.060]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:15.060]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:15.060]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:15.060]         on.exit(options(oopts), add = TRUE)
[13:19:15.060]     }
[13:19:15.060]     {
[13:19:15.060]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:15.060]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:15.060]         do.call(mapply, args = args)
[13:19:15.060]     }
[13:19:15.060] }
[13:19:15.060] Lazy evaluation: FALSE
[13:19:15.060] Asynchronous evaluation: FALSE
[13:19:15.060] Local evaluation: TRUE
[13:19:15.060] Environment: R_GlobalEnv
[13:19:15.060] Capture standard output: FALSE
[13:19:15.060] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:15.060] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:15.060] Packages: <none>
[13:19:15.060] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:15.060] Resolved: TRUE
[13:19:15.060] Value: 224 bytes of class ‘list’
[13:19:15.060] Early signaling: FALSE
[13:19:15.060] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:15.060] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:15.063] Chunk #1 of 1 ... DONE
[13:19:15.063] Launching 1 futures (chunks) ... DONE
[13:19:15.063] Resolving 1 futures (chunks) ...
[13:19:15.064] resolve() on list ...
[13:19:15.064]  recursive: 0
[13:19:15.064]  length: 1
[13:19:15.064] 
[13:19:15.064] resolved() for ‘SequentialFuture’ ...
[13:19:15.064] - state: ‘finished’
[13:19:15.064] - run: TRUE
[13:19:15.064] - result: ‘FutureResult’
[13:19:15.064] resolved() for ‘SequentialFuture’ ... done
[13:19:15.064] Future #1
[13:19:15.065] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:15.065] - nx: 1
[13:19:15.065] - relay: TRUE
[13:19:15.065] - stdout: TRUE
[13:19:15.065] - signal: TRUE
[13:19:15.065] - resignal: FALSE
[13:19:15.065] - force: TRUE
[13:19:15.065] - relayed: [n=1] FALSE
[13:19:15.065] - queued futures: [n=1] FALSE
[13:19:15.065]  - until=1
[13:19:15.065]  - relaying element #1
[13:19:15.066] - relayed: [n=1] TRUE
[13:19:15.066] - queued futures: [n=1] TRUE
[13:19:15.066] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:15.066]  length: 0 (resolved future 1)
[13:19:15.066] Relaying remaining futures
[13:19:15.066] signalConditionsASAP(NULL, pos=0) ...
[13:19:15.066] - nx: 1
[13:19:15.066] - relay: TRUE
[13:19:15.066] - stdout: TRUE
[13:19:15.067] - signal: TRUE
[13:19:15.067] - resignal: FALSE
[13:19:15.067] - force: TRUE
[13:19:15.067] - relayed: [n=1] TRUE
[13:19:15.067] - queued futures: [n=1] TRUE
 - flush all
[13:19:15.067] - relayed: [n=1] TRUE
[13:19:15.067] - queued futures: [n=1] TRUE
[13:19:15.067] signalConditionsASAP(NULL, pos=0) ... done
[13:19:15.067] resolve() on list ... DONE
[13:19:15.067]  - Number of value chunks collected: 1
[13:19:15.067] Resolving 1 futures (chunks) ... DONE
[13:19:15.068] Reducing values from 1 chunks ...
[13:19:15.068]  - Number of values collected after concatenation: 2
[13:19:15.068]  - Number of values expected: 2
[13:19:15.068] Reducing values from 1 chunks ... DONE
[13:19:15.068] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:19:15.068] future_mapply() ...
[13:19:15.072] Number of chunks: 1
[13:19:15.072] getGlobalsAndPackagesXApply() ...
[13:19:15.072]  - future.globals: TRUE
[13:19:15.072] getGlobalsAndPackages() ...
[13:19:15.072] Searching for globals...
[13:19:15.074] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:15.074] Searching for globals ... DONE
[13:19:15.074] Resolving globals: FALSE
[13:19:15.074] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:15.075] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:15.075] - globals: [1] ‘FUN’
[13:19:15.075] 
[13:19:15.075] getGlobalsAndPackages() ... DONE
[13:19:15.075]  - globals found/used: [n=1] ‘FUN’
[13:19:15.075]  - needed namespaces: [n=0] 
[13:19:15.075] Finding globals ... DONE
[13:19:15.076] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:15.076] List of 2
[13:19:15.076]  $ ...future.FUN:function (x, y)  
[13:19:15.076]  $ MoreArgs     : NULL
[13:19:15.076]  - attr(*, "where")=List of 2
[13:19:15.076]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:15.076]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:15.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:15.076]  - attr(*, "resolved")= logi FALSE
[13:19:15.076]  - attr(*, "total_size")= num NA
[13:19:15.078] Packages to be attached in all futures: [n=0] 
[13:19:15.078] getGlobalsAndPackagesXApply() ... DONE
[13:19:15.079] Number of futures (= number of chunks): 1
[13:19:15.079] Launching 1 futures (chunks) ...
[13:19:15.079] Chunk #1 of 1 ...
[13:19:15.079]  - Finding globals in '...' for chunk #1 ...
[13:19:15.079] getGlobalsAndPackages() ...
[13:19:15.079] Searching for globals...
[13:19:15.079] 
[13:19:15.079] Searching for globals ... DONE
[13:19:15.080] - globals: [0] <none>
[13:19:15.080] getGlobalsAndPackages() ... DONE
[13:19:15.080]    + additional globals found: [n=0] 
[13:19:15.080]    + additional namespaces needed: [n=0] 
[13:19:15.080]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:15.080]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:15.080]  - seeds: <none>
[13:19:15.080] getGlobalsAndPackages() ...
[13:19:15.080] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:15.080] Resolving globals: FALSE
[13:19:15.081] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:15.081] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:15.082] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:15.082] 
[13:19:15.082] getGlobalsAndPackages() ... DONE
[13:19:15.082] run() for ‘Future’ ...
[13:19:15.082] - state: ‘created’
[13:19:15.082] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:15.086] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:15.086] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:15.086]   - Field: ‘label’
[13:19:15.086]   - Field: ‘local’
[13:19:15.086]   - Field: ‘owner’
[13:19:15.086]   - Field: ‘envir’
[13:19:15.086]   - Field: ‘packages’
[13:19:15.087]   - Field: ‘gc’
[13:19:15.087]   - Field: ‘conditions’
[13:19:15.087]   - Field: ‘expr’
[13:19:15.087]   - Field: ‘uuid’
[13:19:15.087]   - Field: ‘seed’
[13:19:15.087]   - Field: ‘version’
[13:19:15.087]   - Field: ‘result’
[13:19:15.087]   - Field: ‘asynchronous’
[13:19:15.087]   - Field: ‘calls’
[13:19:15.087]   - Field: ‘globals’
[13:19:15.087]   - Field: ‘stdout’
[13:19:15.088]   - Field: ‘earlySignal’
[13:19:15.088]   - Field: ‘lazy’
[13:19:15.088]   - Field: ‘state’
[13:19:15.088] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:15.088] - Launch lazy future ...
[13:19:15.088] Packages needed by the future expression (n = 0): <none>
[13:19:15.088] Packages needed by future strategies (n = 0): <none>
[13:19:15.089] {
[13:19:15.089]     {
[13:19:15.089]         {
[13:19:15.089]             ...future.startTime <- base::Sys.time()
[13:19:15.089]             {
[13:19:15.089]                 {
[13:19:15.089]                   {
[13:19:15.089]                     base::local({
[13:19:15.089]                       has_future <- base::requireNamespace("future", 
[13:19:15.089]                         quietly = TRUE)
[13:19:15.089]                       if (has_future) {
[13:19:15.089]                         ns <- base::getNamespace("future")
[13:19:15.089]                         version <- ns[[".package"]][["version"]]
[13:19:15.089]                         if (is.null(version)) 
[13:19:15.089]                           version <- utils::packageVersion("future")
[13:19:15.089]                       }
[13:19:15.089]                       else {
[13:19:15.089]                         version <- NULL
[13:19:15.089]                       }
[13:19:15.089]                       if (!has_future || version < "1.8.0") {
[13:19:15.089]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:15.089]                           "", base::R.version$version.string), 
[13:19:15.089]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:15.089]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:15.089]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:15.089]                             "release", "version")], collapse = " "), 
[13:19:15.089]                           hostname = base::Sys.info()[["nodename"]])
[13:19:15.089]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:15.089]                           info)
[13:19:15.089]                         info <- base::paste(info, collapse = "; ")
[13:19:15.089]                         if (!has_future) {
[13:19:15.089]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:15.089]                             info)
[13:19:15.089]                         }
[13:19:15.089]                         else {
[13:19:15.089]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:15.089]                             info, version)
[13:19:15.089]                         }
[13:19:15.089]                         base::stop(msg)
[13:19:15.089]                       }
[13:19:15.089]                     })
[13:19:15.089]                   }
[13:19:15.089]                   options(future.plan = NULL)
[13:19:15.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:15.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:15.089]                 }
[13:19:15.089]                 ...future.workdir <- getwd()
[13:19:15.089]             }
[13:19:15.089]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:15.089]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:15.089]         }
[13:19:15.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:15.089]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:15.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:15.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:15.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:15.089]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:15.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:15.089]             base::names(...future.oldOptions))
[13:19:15.089]     }
[13:19:15.089]     if (FALSE) {
[13:19:15.089]     }
[13:19:15.089]     else {
[13:19:15.089]         if (TRUE) {
[13:19:15.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:15.089]                 open = "w")
[13:19:15.089]         }
[13:19:15.089]         else {
[13:19:15.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:15.089]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:15.089]         }
[13:19:15.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:15.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:15.089]             base::sink(type = "output", split = FALSE)
[13:19:15.089]             base::close(...future.stdout)
[13:19:15.089]         }, add = TRUE)
[13:19:15.089]     }
[13:19:15.089]     ...future.frame <- base::sys.nframe()
[13:19:15.089]     ...future.conditions <- base::list()
[13:19:15.089]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:15.089]     if (FALSE) {
[13:19:15.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:15.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:15.089]     }
[13:19:15.089]     ...future.result <- base::tryCatch({
[13:19:15.089]         base::withCallingHandlers({
[13:19:15.089]             ...future.value <- base::withVisible(base::local({
[13:19:15.089]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:15.089]                 if (!identical(...future.globals.maxSize.org, 
[13:19:15.089]                   ...future.globals.maxSize)) {
[13:19:15.089]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:15.089]                   on.exit(options(oopts), add = TRUE)
[13:19:15.089]                 }
[13:19:15.089]                 {
[13:19:15.089]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:15.089]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:15.089]                     USE.NAMES = FALSE)
[13:19:15.089]                   do.call(mapply, args = args)
[13:19:15.089]                 }
[13:19:15.089]             }))
[13:19:15.089]             future::FutureResult(value = ...future.value$value, 
[13:19:15.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:15.089]                   ...future.rng), globalenv = if (FALSE) 
[13:19:15.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:15.089]                     ...future.globalenv.names))
[13:19:15.089]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:15.089]         }, condition = base::local({
[13:19:15.089]             c <- base::c
[13:19:15.089]             inherits <- base::inherits
[13:19:15.089]             invokeRestart <- base::invokeRestart
[13:19:15.089]             length <- base::length
[13:19:15.089]             list <- base::list
[13:19:15.089]             seq.int <- base::seq.int
[13:19:15.089]             signalCondition <- base::signalCondition
[13:19:15.089]             sys.calls <- base::sys.calls
[13:19:15.089]             `[[` <- base::`[[`
[13:19:15.089]             `+` <- base::`+`
[13:19:15.089]             `<<-` <- base::`<<-`
[13:19:15.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:15.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:15.089]                   3L)]
[13:19:15.089]             }
[13:19:15.089]             function(cond) {
[13:19:15.089]                 is_error <- inherits(cond, "error")
[13:19:15.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:15.089]                   NULL)
[13:19:15.089]                 if (is_error) {
[13:19:15.089]                   sessionInformation <- function() {
[13:19:15.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:15.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:15.089]                       search = base::search(), system = base::Sys.info())
[13:19:15.089]                   }
[13:19:15.089]                   ...future.conditions[[length(...future.conditions) + 
[13:19:15.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:15.089]                     cond$call), session = sessionInformation(), 
[13:19:15.089]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:15.089]                   signalCondition(cond)
[13:19:15.089]                 }
[13:19:15.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:15.089]                 "immediateCondition"))) {
[13:19:15.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:15.089]                   ...future.conditions[[length(...future.conditions) + 
[13:19:15.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:15.089]                   if (TRUE && !signal) {
[13:19:15.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:15.089]                     {
[13:19:15.089]                       inherits <- base::inherits
[13:19:15.089]                       invokeRestart <- base::invokeRestart
[13:19:15.089]                       is.null <- base::is.null
[13:19:15.089]                       muffled <- FALSE
[13:19:15.089]                       if (inherits(cond, "message")) {
[13:19:15.089]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:15.089]                         if (muffled) 
[13:19:15.089]                           invokeRestart("muffleMessage")
[13:19:15.089]                       }
[13:19:15.089]                       else if (inherits(cond, "warning")) {
[13:19:15.089]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:15.089]                         if (muffled) 
[13:19:15.089]                           invokeRestart("muffleWarning")
[13:19:15.089]                       }
[13:19:15.089]                       else if (inherits(cond, "condition")) {
[13:19:15.089]                         if (!is.null(pattern)) {
[13:19:15.089]                           computeRestarts <- base::computeRestarts
[13:19:15.089]                           grepl <- base::grepl
[13:19:15.089]                           restarts <- computeRestarts(cond)
[13:19:15.089]                           for (restart in restarts) {
[13:19:15.089]                             name <- restart$name
[13:19:15.089]                             if (is.null(name)) 
[13:19:15.089]                               next
[13:19:15.089]                             if (!grepl(pattern, name)) 
[13:19:15.089]                               next
[13:19:15.089]                             invokeRestart(restart)
[13:19:15.089]                             muffled <- TRUE
[13:19:15.089]                             break
[13:19:15.089]                           }
[13:19:15.089]                         }
[13:19:15.089]                       }
[13:19:15.089]                       invisible(muffled)
[13:19:15.089]                     }
[13:19:15.089]                     muffleCondition(cond, pattern = "^muffle")
[13:19:15.089]                   }
[13:19:15.089]                 }
[13:19:15.089]                 else {
[13:19:15.089]                   if (TRUE) {
[13:19:15.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:15.089]                     {
[13:19:15.089]                       inherits <- base::inherits
[13:19:15.089]                       invokeRestart <- base::invokeRestart
[13:19:15.089]                       is.null <- base::is.null
[13:19:15.089]                       muffled <- FALSE
[13:19:15.089]                       if (inherits(cond, "message")) {
[13:19:15.089]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:15.089]                         if (muffled) 
[13:19:15.089]                           invokeRestart("muffleMessage")
[13:19:15.089]                       }
[13:19:15.089]                       else if (inherits(cond, "warning")) {
[13:19:15.089]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:15.089]                         if (muffled) 
[13:19:15.089]                           invokeRestart("muffleWarning")
[13:19:15.089]                       }
[13:19:15.089]                       else if (inherits(cond, "condition")) {
[13:19:15.089]                         if (!is.null(pattern)) {
[13:19:15.089]                           computeRestarts <- base::computeRestarts
[13:19:15.089]                           grepl <- base::grepl
[13:19:15.089]                           restarts <- computeRestarts(cond)
[13:19:15.089]                           for (restart in restarts) {
[13:19:15.089]                             name <- restart$name
[13:19:15.089]                             if (is.null(name)) 
[13:19:15.089]                               next
[13:19:15.089]                             if (!grepl(pattern, name)) 
[13:19:15.089]                               next
[13:19:15.089]                             invokeRestart(restart)
[13:19:15.089]                             muffled <- TRUE
[13:19:15.089]                             break
[13:19:15.089]                           }
[13:19:15.089]                         }
[13:19:15.089]                       }
[13:19:15.089]                       invisible(muffled)
[13:19:15.089]                     }
[13:19:15.089]                     muffleCondition(cond, pattern = "^muffle")
[13:19:15.089]                   }
[13:19:15.089]                 }
[13:19:15.089]             }
[13:19:15.089]         }))
[13:19:15.089]     }, error = function(ex) {
[13:19:15.089]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:15.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:15.089]                 ...future.rng), started = ...future.startTime, 
[13:19:15.089]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:15.089]             version = "1.8"), class = "FutureResult")
[13:19:15.089]     }, finally = {
[13:19:15.089]         if (!identical(...future.workdir, getwd())) 
[13:19:15.089]             setwd(...future.workdir)
[13:19:15.089]         {
[13:19:15.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:15.089]                 ...future.oldOptions$nwarnings <- NULL
[13:19:15.089]             }
[13:19:15.089]             base::options(...future.oldOptions)
[13:19:15.089]             if (.Platform$OS.type == "windows") {
[13:19:15.089]                 old_names <- names(...future.oldEnvVars)
[13:19:15.089]                 envs <- base::Sys.getenv()
[13:19:15.089]                 names <- names(envs)
[13:19:15.089]                 common <- intersect(names, old_names)
[13:19:15.089]                 added <- setdiff(names, old_names)
[13:19:15.089]                 removed <- setdiff(old_names, names)
[13:19:15.089]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:15.089]                   envs[common]]
[13:19:15.089]                 NAMES <- toupper(changed)
[13:19:15.089]                 args <- list()
[13:19:15.089]                 for (kk in seq_along(NAMES)) {
[13:19:15.089]                   name <- changed[[kk]]
[13:19:15.089]                   NAME <- NAMES[[kk]]
[13:19:15.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:15.089]                     next
[13:19:15.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:15.089]                 }
[13:19:15.089]                 NAMES <- toupper(added)
[13:19:15.089]                 for (kk in seq_along(NAMES)) {
[13:19:15.089]                   name <- added[[kk]]
[13:19:15.089]                   NAME <- NAMES[[kk]]
[13:19:15.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:15.089]                     next
[13:19:15.089]                   args[[name]] <- ""
[13:19:15.089]                 }
[13:19:15.089]                 NAMES <- toupper(removed)
[13:19:15.089]                 for (kk in seq_along(NAMES)) {
[13:19:15.089]                   name <- removed[[kk]]
[13:19:15.089]                   NAME <- NAMES[[kk]]
[13:19:15.089]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:15.089]                     next
[13:19:15.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:15.089]                 }
[13:19:15.089]                 if (length(args) > 0) 
[13:19:15.089]                   base::do.call(base::Sys.setenv, args = args)
[13:19:15.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:15.089]             }
[13:19:15.089]             else {
[13:19:15.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:15.089]             }
[13:19:15.089]             {
[13:19:15.089]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:15.089]                   0L) {
[13:19:15.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:15.089]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:15.089]                   base::options(opts)
[13:19:15.089]                 }
[13:19:15.089]                 {
[13:19:15.089]                   {
[13:19:15.089]                     NULL
[13:19:15.089]                     RNGkind("Mersenne-Twister")
[13:19:15.089]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:15.089]                       inherits = FALSE)
[13:19:15.089]                   }
[13:19:15.089]                   options(future.plan = NULL)
[13:19:15.089]                   if (is.na(NA_character_)) 
[13:19:15.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:15.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:15.089]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:15.089]                     envir = parent.frame()) 
[13:19:15.089]                   {
[13:19:15.089]                     default_workers <- missing(workers)
[13:19:15.089]                     if (is.function(workers)) 
[13:19:15.089]                       workers <- workers()
[13:19:15.089]                     workers <- structure(as.integer(workers), 
[13:19:15.089]                       class = class(workers))
[13:19:15.089]                     stop_if_not(is.finite(workers), workers >= 
[13:19:15.089]                       1L)
[13:19:15.089]                     if ((workers == 1L && !inherits(workers, 
[13:19:15.089]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:15.089]                       if (default_workers) 
[13:19:15.089]                         supportsMulticore(warn = TRUE)
[13:19:15.089]                       return(sequential(..., envir = envir))
[13:19:15.089]                     }
[13:19:15.089]                     oopts <- options(mc.cores = workers)
[13:19:15.089]                     on.exit(options(oopts))
[13:19:15.089]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:15.089]                       envir = envir)
[13:19:15.089]                     if (!future$lazy) 
[13:19:15.089]                       future <- run(future)
[13:19:15.089]                     invisible(future)
[13:19:15.089]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:15.089]                 }
[13:19:15.089]             }
[13:19:15.089]         }
[13:19:15.089]     })
[13:19:15.089]     if (TRUE) {
[13:19:15.089]         base::sink(type = "output", split = FALSE)
[13:19:15.089]         if (TRUE) {
[13:19:15.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:15.089]         }
[13:19:15.089]         else {
[13:19:15.089]             ...future.result["stdout"] <- base::list(NULL)
[13:19:15.089]         }
[13:19:15.089]         base::close(...future.stdout)
[13:19:15.089]         ...future.stdout <- NULL
[13:19:15.089]     }
[13:19:15.089]     ...future.result$conditions <- ...future.conditions
[13:19:15.089]     ...future.result$finished <- base::Sys.time()
[13:19:15.089]     ...future.result
[13:19:15.089] }
[13:19:15.090] assign_globals() ...
[13:19:15.091] List of 5
[13:19:15.091]  $ ...future.FUN            :function (x, y)  
[13:19:15.091]  $ MoreArgs                 : NULL
[13:19:15.091]  $ ...future.elements_ii    :List of 2
[13:19:15.091]   ..$ :List of 2
[13:19:15.091]   .. ..$ : int 1
[13:19:15.091]   .. ..$ : int 0
[13:19:15.091]   ..$ :List of 2
[13:19:15.091]   .. ..$ : int 0
[13:19:15.091]   .. ..$ : int 1
[13:19:15.091]  $ ...future.seeds_ii       : NULL
[13:19:15.091]  $ ...future.globals.maxSize: NULL
[13:19:15.091]  - attr(*, "resolved")= logi FALSE
[13:19:15.091]  - attr(*, "total_size")= num 6480
[13:19:15.091]  - attr(*, "where")=List of 5
[13:19:15.091]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:15.091]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:15.091]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:15.091]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:15.091]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:15.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:15.091]  - attr(*, "already-done")= logi TRUE
[13:19:15.098] - reassign environment for ‘...future.FUN’
[13:19:15.098] - copied ‘...future.FUN’ to environment
[13:19:15.098] - copied ‘MoreArgs’ to environment
[13:19:15.098] - copied ‘...future.elements_ii’ to environment
[13:19:15.098] - copied ‘...future.seeds_ii’ to environment
[13:19:15.098] - copied ‘...future.globals.maxSize’ to environment
[13:19:15.099] assign_globals() ... done
[13:19:15.099] plan(): Setting new future strategy stack:
[13:19:15.099] List of future strategies:
[13:19:15.099] 1. sequential:
[13:19:15.099]    - args: function (..., envir = parent.frame())
[13:19:15.099]    - tweaked: FALSE
[13:19:15.099]    - call: NULL
[13:19:15.099] plan(): nbrOfWorkers() = 1
[13:19:15.601] plan(): Setting new future strategy stack:
[13:19:15.601] List of future strategies:
[13:19:15.601] 1. multicore:
[13:19:15.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:15.601]    - tweaked: FALSE
[13:19:15.601]    - call: plan(strategy)
[13:19:15.605] plan(): nbrOfWorkers() = 1
[13:19:15.606] SequentialFuture started (and completed)
[13:19:15.606] - Launch lazy future ... done
[13:19:15.606] run() for ‘SequentialFuture’ ... done
[13:19:15.606] Created future:
[13:19:15.606] SequentialFuture:
[13:19:15.606] Label: ‘future_mapply-1’
[13:19:15.606] Expression:
[13:19:15.606] {
[13:19:15.606]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:15.606]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:15.606]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:15.606]         on.exit(options(oopts), add = TRUE)
[13:19:15.606]     }
[13:19:15.606]     {
[13:19:15.606]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:15.606]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:15.606]         do.call(mapply, args = args)
[13:19:15.606]     }
[13:19:15.606] }
[13:19:15.606] Lazy evaluation: FALSE
[13:19:15.606] Asynchronous evaluation: FALSE
[13:19:15.606] Local evaluation: TRUE
[13:19:15.606] Environment: R_GlobalEnv
[13:19:15.606] Capture standard output: TRUE
[13:19:15.606] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:15.606] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:15.606] Packages: <none>
[13:19:15.606] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:15.606] Resolved: TRUE
[13:19:15.606] Value: 224 bytes of class ‘list’
[13:19:15.606] Early signaling: FALSE
[13:19:15.606] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:15.606] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:15.607] Chunk #1 of 1 ... DONE
[13:19:15.608] Launching 1 futures (chunks) ... DONE
[13:19:15.608] Resolving 1 futures (chunks) ...
[13:19:15.608] resolve() on list ...
[13:19:15.608]  recursive: 0
[13:19:15.608]  length: 1
[13:19:15.608] 
[13:19:15.608] resolved() for ‘SequentialFuture’ ...
[13:19:15.608] - state: ‘finished’
[13:19:15.608] - run: TRUE
[13:19:15.608] - result: ‘FutureResult’
[13:19:15.609] resolved() for ‘SequentialFuture’ ... done
[13:19:15.609] Future #1
[13:19:15.609] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:15.609] - nx: 1
[13:19:15.609] - relay: TRUE
[13:19:15.609] - stdout: TRUE
[13:19:15.609] - signal: TRUE
[13:19:15.609] - resignal: FALSE
[13:19:15.609] - force: TRUE
[13:19:15.609] - relayed: [n=1] FALSE
[13:19:15.609] - queued futures: [n=1] FALSE
[13:19:15.610]  - until=1
[13:19:15.610]  - relaying element #1
[13:19:15.610] - relayed: [n=1] TRUE
[13:19:15.610] - queued futures: [n=1] TRUE
[13:19:15.610] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:15.610]  length: 0 (resolved future 1)
[13:19:15.610] Relaying remaining futures
[13:19:15.610] signalConditionsASAP(NULL, pos=0) ...
[13:19:15.610] - nx: 1
[13:19:15.611] - relay: TRUE
[13:19:15.611] - stdout: TRUE
[13:19:15.611] - signal: TRUE
[13:19:15.611] - resignal: FALSE
[13:19:15.611] - force: TRUE
[13:19:15.611] - relayed: [n=1] TRUE
[13:19:15.611] - queued futures: [n=1] TRUE
 - flush all
[13:19:15.611] - relayed: [n=1] TRUE
[13:19:15.611] - queued futures: [n=1] TRUE
[13:19:15.611] signalConditionsASAP(NULL, pos=0) ... done
[13:19:15.611] resolve() on list ... DONE
[13:19:15.612]  - Number of value chunks collected: 1
[13:19:15.612] Resolving 1 futures (chunks) ... DONE
[13:19:15.612] Reducing values from 1 chunks ...
[13:19:15.612]  - Number of values collected after concatenation: 2
[13:19:15.612]  - Number of values expected: 2
[13:19:15.612] Reducing values from 1 chunks ... DONE
[13:19:15.612] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:19:15.613] future_mapply() ...
[13:19:15.616] Number of chunks: 1
[13:19:15.616] getGlobalsAndPackagesXApply() ...
[13:19:15.616]  - future.globals: TRUE
[13:19:15.616] getGlobalsAndPackages() ...
[13:19:15.616] Searching for globals...
[13:19:15.618] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:15.618] Searching for globals ... DONE
[13:19:15.618] Resolving globals: FALSE
[13:19:15.619] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:15.619] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:15.619] - globals: [1] ‘FUN’
[13:19:15.619] 
[13:19:15.619] getGlobalsAndPackages() ... DONE
[13:19:15.619]  - globals found/used: [n=1] ‘FUN’
[13:19:15.620]  - needed namespaces: [n=0] 
[13:19:15.620] Finding globals ... DONE
[13:19:15.620] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:15.620] List of 2
[13:19:15.620]  $ ...future.FUN:function (x, y)  
[13:19:15.620]  $ MoreArgs     : NULL
[13:19:15.620]  - attr(*, "where")=List of 2
[13:19:15.620]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:15.620]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:15.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:15.620]  - attr(*, "resolved")= logi FALSE
[13:19:15.620]  - attr(*, "total_size")= num NA
[13:19:15.624] Packages to be attached in all futures: [n=0] 
[13:19:15.624] getGlobalsAndPackagesXApply() ... DONE
[13:19:15.625] Number of futures (= number of chunks): 1
[13:19:15.625] Launching 1 futures (chunks) ...
[13:19:15.625] Chunk #1 of 1 ...
[13:19:15.625]  - Finding globals in '...' for chunk #1 ...
[13:19:15.625] getGlobalsAndPackages() ...
[13:19:15.625] Searching for globals...
[13:19:15.626] 
[13:19:15.626] Searching for globals ... DONE
[13:19:15.626] - globals: [0] <none>
[13:19:15.626] getGlobalsAndPackages() ... DONE
[13:19:15.626]    + additional globals found: [n=0] 
[13:19:15.626]    + additional namespaces needed: [n=0] 
[13:19:15.626]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:15.626]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:15.626]  - seeds: <none>
[13:19:15.626] getGlobalsAndPackages() ...
[13:19:15.627] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:15.627] Resolving globals: FALSE
[13:19:15.627] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:15.628] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:15.628] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:15.628] 
[13:19:15.628] getGlobalsAndPackages() ... DONE
[13:19:15.628] run() for ‘Future’ ...
[13:19:15.628] - state: ‘created’
[13:19:15.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:15.632] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:15.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:15.632]   - Field: ‘label’
[13:19:15.633]   - Field: ‘local’
[13:19:15.633]   - Field: ‘owner’
[13:19:15.633]   - Field: ‘envir’
[13:19:15.633]   - Field: ‘packages’
[13:19:15.633]   - Field: ‘gc’
[13:19:15.633]   - Field: ‘conditions’
[13:19:15.633]   - Field: ‘expr’
[13:19:15.634]   - Field: ‘uuid’
[13:19:15.634]   - Field: ‘seed’
[13:19:15.634]   - Field: ‘version’
[13:19:15.634]   - Field: ‘result’
[13:19:15.634]   - Field: ‘asynchronous’
[13:19:15.634]   - Field: ‘calls’
[13:19:15.634]   - Field: ‘globals’
[13:19:15.634]   - Field: ‘stdout’
[13:19:15.634]   - Field: ‘earlySignal’
[13:19:15.634]   - Field: ‘lazy’
[13:19:15.635]   - Field: ‘state’
[13:19:15.635] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:15.635] - Launch lazy future ...
[13:19:15.635] Packages needed by the future expression (n = 0): <none>
[13:19:15.635] Packages needed by future strategies (n = 0): <none>
[13:19:15.636] {
[13:19:15.636]     {
[13:19:15.636]         {
[13:19:15.636]             ...future.startTime <- base::Sys.time()
[13:19:15.636]             {
[13:19:15.636]                 {
[13:19:15.636]                   {
[13:19:15.636]                     base::local({
[13:19:15.636]                       has_future <- base::requireNamespace("future", 
[13:19:15.636]                         quietly = TRUE)
[13:19:15.636]                       if (has_future) {
[13:19:15.636]                         ns <- base::getNamespace("future")
[13:19:15.636]                         version <- ns[[".package"]][["version"]]
[13:19:15.636]                         if (is.null(version)) 
[13:19:15.636]                           version <- utils::packageVersion("future")
[13:19:15.636]                       }
[13:19:15.636]                       else {
[13:19:15.636]                         version <- NULL
[13:19:15.636]                       }
[13:19:15.636]                       if (!has_future || version < "1.8.0") {
[13:19:15.636]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:15.636]                           "", base::R.version$version.string), 
[13:19:15.636]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:15.636]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:15.636]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:15.636]                             "release", "version")], collapse = " "), 
[13:19:15.636]                           hostname = base::Sys.info()[["nodename"]])
[13:19:15.636]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:15.636]                           info)
[13:19:15.636]                         info <- base::paste(info, collapse = "; ")
[13:19:15.636]                         if (!has_future) {
[13:19:15.636]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:15.636]                             info)
[13:19:15.636]                         }
[13:19:15.636]                         else {
[13:19:15.636]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:15.636]                             info, version)
[13:19:15.636]                         }
[13:19:15.636]                         base::stop(msg)
[13:19:15.636]                       }
[13:19:15.636]                     })
[13:19:15.636]                   }
[13:19:15.636]                   options(future.plan = NULL)
[13:19:15.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:15.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:15.636]                 }
[13:19:15.636]                 ...future.workdir <- getwd()
[13:19:15.636]             }
[13:19:15.636]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:15.636]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:15.636]         }
[13:19:15.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:15.636]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:15.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:15.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:15.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:15.636]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:15.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:15.636]             base::names(...future.oldOptions))
[13:19:15.636]     }
[13:19:15.636]     if (TRUE) {
[13:19:15.636]     }
[13:19:15.636]     else {
[13:19:15.636]         if (NA) {
[13:19:15.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:15.636]                 open = "w")
[13:19:15.636]         }
[13:19:15.636]         else {
[13:19:15.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:15.636]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:15.636]         }
[13:19:15.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:15.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:15.636]             base::sink(type = "output", split = FALSE)
[13:19:15.636]             base::close(...future.stdout)
[13:19:15.636]         }, add = TRUE)
[13:19:15.636]     }
[13:19:15.636]     ...future.frame <- base::sys.nframe()
[13:19:15.636]     ...future.conditions <- base::list()
[13:19:15.636]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:15.636]     if (FALSE) {
[13:19:15.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:15.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:15.636]     }
[13:19:15.636]     ...future.result <- base::tryCatch({
[13:19:15.636]         base::withCallingHandlers({
[13:19:15.636]             ...future.value <- base::withVisible(base::local({
[13:19:15.636]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:15.636]                 if (!identical(...future.globals.maxSize.org, 
[13:19:15.636]                   ...future.globals.maxSize)) {
[13:19:15.636]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:15.636]                   on.exit(options(oopts), add = TRUE)
[13:19:15.636]                 }
[13:19:15.636]                 {
[13:19:15.636]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:15.636]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:15.636]                     USE.NAMES = FALSE)
[13:19:15.636]                   do.call(mapply, args = args)
[13:19:15.636]                 }
[13:19:15.636]             }))
[13:19:15.636]             future::FutureResult(value = ...future.value$value, 
[13:19:15.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:15.636]                   ...future.rng), globalenv = if (FALSE) 
[13:19:15.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:15.636]                     ...future.globalenv.names))
[13:19:15.636]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:15.636]         }, condition = base::local({
[13:19:15.636]             c <- base::c
[13:19:15.636]             inherits <- base::inherits
[13:19:15.636]             invokeRestart <- base::invokeRestart
[13:19:15.636]             length <- base::length
[13:19:15.636]             list <- base::list
[13:19:15.636]             seq.int <- base::seq.int
[13:19:15.636]             signalCondition <- base::signalCondition
[13:19:15.636]             sys.calls <- base::sys.calls
[13:19:15.636]             `[[` <- base::`[[`
[13:19:15.636]             `+` <- base::`+`
[13:19:15.636]             `<<-` <- base::`<<-`
[13:19:15.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:15.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:15.636]                   3L)]
[13:19:15.636]             }
[13:19:15.636]             function(cond) {
[13:19:15.636]                 is_error <- inherits(cond, "error")
[13:19:15.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:15.636]                   NULL)
[13:19:15.636]                 if (is_error) {
[13:19:15.636]                   sessionInformation <- function() {
[13:19:15.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:15.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:15.636]                       search = base::search(), system = base::Sys.info())
[13:19:15.636]                   }
[13:19:15.636]                   ...future.conditions[[length(...future.conditions) + 
[13:19:15.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:15.636]                     cond$call), session = sessionInformation(), 
[13:19:15.636]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:15.636]                   signalCondition(cond)
[13:19:15.636]                 }
[13:19:15.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:15.636]                 "immediateCondition"))) {
[13:19:15.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:15.636]                   ...future.conditions[[length(...future.conditions) + 
[13:19:15.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:15.636]                   if (TRUE && !signal) {
[13:19:15.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:15.636]                     {
[13:19:15.636]                       inherits <- base::inherits
[13:19:15.636]                       invokeRestart <- base::invokeRestart
[13:19:15.636]                       is.null <- base::is.null
[13:19:15.636]                       muffled <- FALSE
[13:19:15.636]                       if (inherits(cond, "message")) {
[13:19:15.636]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:15.636]                         if (muffled) 
[13:19:15.636]                           invokeRestart("muffleMessage")
[13:19:15.636]                       }
[13:19:15.636]                       else if (inherits(cond, "warning")) {
[13:19:15.636]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:15.636]                         if (muffled) 
[13:19:15.636]                           invokeRestart("muffleWarning")
[13:19:15.636]                       }
[13:19:15.636]                       else if (inherits(cond, "condition")) {
[13:19:15.636]                         if (!is.null(pattern)) {
[13:19:15.636]                           computeRestarts <- base::computeRestarts
[13:19:15.636]                           grepl <- base::grepl
[13:19:15.636]                           restarts <- computeRestarts(cond)
[13:19:15.636]                           for (restart in restarts) {
[13:19:15.636]                             name <- restart$name
[13:19:15.636]                             if (is.null(name)) 
[13:19:15.636]                               next
[13:19:15.636]                             if (!grepl(pattern, name)) 
[13:19:15.636]                               next
[13:19:15.636]                             invokeRestart(restart)
[13:19:15.636]                             muffled <- TRUE
[13:19:15.636]                             break
[13:19:15.636]                           }
[13:19:15.636]                         }
[13:19:15.636]                       }
[13:19:15.636]                       invisible(muffled)
[13:19:15.636]                     }
[13:19:15.636]                     muffleCondition(cond, pattern = "^muffle")
[13:19:15.636]                   }
[13:19:15.636]                 }
[13:19:15.636]                 else {
[13:19:15.636]                   if (TRUE) {
[13:19:15.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:15.636]                     {
[13:19:15.636]                       inherits <- base::inherits
[13:19:15.636]                       invokeRestart <- base::invokeRestart
[13:19:15.636]                       is.null <- base::is.null
[13:19:15.636]                       muffled <- FALSE
[13:19:15.636]                       if (inherits(cond, "message")) {
[13:19:15.636]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:15.636]                         if (muffled) 
[13:19:15.636]                           invokeRestart("muffleMessage")
[13:19:15.636]                       }
[13:19:15.636]                       else if (inherits(cond, "warning")) {
[13:19:15.636]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:15.636]                         if (muffled) 
[13:19:15.636]                           invokeRestart("muffleWarning")
[13:19:15.636]                       }
[13:19:15.636]                       else if (inherits(cond, "condition")) {
[13:19:15.636]                         if (!is.null(pattern)) {
[13:19:15.636]                           computeRestarts <- base::computeRestarts
[13:19:15.636]                           grepl <- base::grepl
[13:19:15.636]                           restarts <- computeRestarts(cond)
[13:19:15.636]                           for (restart in restarts) {
[13:19:15.636]                             name <- restart$name
[13:19:15.636]                             if (is.null(name)) 
[13:19:15.636]                               next
[13:19:15.636]                             if (!grepl(pattern, name)) 
[13:19:15.636]                               next
[13:19:15.636]                             invokeRestart(restart)
[13:19:15.636]                             muffled <- TRUE
[13:19:15.636]                             break
[13:19:15.636]                           }
[13:19:15.636]                         }
[13:19:15.636]                       }
[13:19:15.636]                       invisible(muffled)
[13:19:15.636]                     }
[13:19:15.636]                     muffleCondition(cond, pattern = "^muffle")
[13:19:15.636]                   }
[13:19:15.636]                 }
[13:19:15.636]             }
[13:19:15.636]         }))
[13:19:15.636]     }, error = function(ex) {
[13:19:15.636]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:15.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:15.636]                 ...future.rng), started = ...future.startTime, 
[13:19:15.636]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:15.636]             version = "1.8"), class = "FutureResult")
[13:19:15.636]     }, finally = {
[13:19:15.636]         if (!identical(...future.workdir, getwd())) 
[13:19:15.636]             setwd(...future.workdir)
[13:19:15.636]         {
[13:19:15.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:15.636]                 ...future.oldOptions$nwarnings <- NULL
[13:19:15.636]             }
[13:19:15.636]             base::options(...future.oldOptions)
[13:19:15.636]             if (.Platform$OS.type == "windows") {
[13:19:15.636]                 old_names <- names(...future.oldEnvVars)
[13:19:15.636]                 envs <- base::Sys.getenv()
[13:19:15.636]                 names <- names(envs)
[13:19:15.636]                 common <- intersect(names, old_names)
[13:19:15.636]                 added <- setdiff(names, old_names)
[13:19:15.636]                 removed <- setdiff(old_names, names)
[13:19:15.636]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:15.636]                   envs[common]]
[13:19:15.636]                 NAMES <- toupper(changed)
[13:19:15.636]                 args <- list()
[13:19:15.636]                 for (kk in seq_along(NAMES)) {
[13:19:15.636]                   name <- changed[[kk]]
[13:19:15.636]                   NAME <- NAMES[[kk]]
[13:19:15.636]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:15.636]                     next
[13:19:15.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:15.636]                 }
[13:19:15.636]                 NAMES <- toupper(added)
[13:19:15.636]                 for (kk in seq_along(NAMES)) {
[13:19:15.636]                   name <- added[[kk]]
[13:19:15.636]                   NAME <- NAMES[[kk]]
[13:19:15.636]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:15.636]                     next
[13:19:15.636]                   args[[name]] <- ""
[13:19:15.636]                 }
[13:19:15.636]                 NAMES <- toupper(removed)
[13:19:15.636]                 for (kk in seq_along(NAMES)) {
[13:19:15.636]                   name <- removed[[kk]]
[13:19:15.636]                   NAME <- NAMES[[kk]]
[13:19:15.636]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:15.636]                     next
[13:19:15.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:15.636]                 }
[13:19:15.636]                 if (length(args) > 0) 
[13:19:15.636]                   base::do.call(base::Sys.setenv, args = args)
[13:19:15.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:15.636]             }
[13:19:15.636]             else {
[13:19:15.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:15.636]             }
[13:19:15.636]             {
[13:19:15.636]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:15.636]                   0L) {
[13:19:15.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:15.636]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:15.636]                   base::options(opts)
[13:19:15.636]                 }
[13:19:15.636]                 {
[13:19:15.636]                   {
[13:19:15.636]                     NULL
[13:19:15.636]                     RNGkind("Mersenne-Twister")
[13:19:15.636]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:15.636]                       inherits = FALSE)
[13:19:15.636]                   }
[13:19:15.636]                   options(future.plan = NULL)
[13:19:15.636]                   if (is.na(NA_character_)) 
[13:19:15.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:15.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:15.636]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:15.636]                     envir = parent.frame()) 
[13:19:15.636]                   {
[13:19:15.636]                     default_workers <- missing(workers)
[13:19:15.636]                     if (is.function(workers)) 
[13:19:15.636]                       workers <- workers()
[13:19:15.636]                     workers <- structure(as.integer(workers), 
[13:19:15.636]                       class = class(workers))
[13:19:15.636]                     stop_if_not(is.finite(workers), workers >= 
[13:19:15.636]                       1L)
[13:19:15.636]                     if ((workers == 1L && !inherits(workers, 
[13:19:15.636]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:15.636]                       if (default_workers) 
[13:19:15.636]                         supportsMulticore(warn = TRUE)
[13:19:15.636]                       return(sequential(..., envir = envir))
[13:19:15.636]                     }
[13:19:15.636]                     oopts <- options(mc.cores = workers)
[13:19:15.636]                     on.exit(options(oopts))
[13:19:15.636]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:15.636]                       envir = envir)
[13:19:15.636]                     if (!future$lazy) 
[13:19:15.636]                       future <- run(future)
[13:19:15.636]                     invisible(future)
[13:19:15.636]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:15.636]                 }
[13:19:15.636]             }
[13:19:15.636]         }
[13:19:15.636]     })
[13:19:15.636]     if (FALSE) {
[13:19:15.636]         base::sink(type = "output", split = FALSE)
[13:19:15.636]         if (NA) {
[13:19:15.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:15.636]         }
[13:19:15.636]         else {
[13:19:15.636]             ...future.result["stdout"] <- base::list(NULL)
[13:19:15.636]         }
[13:19:15.636]         base::close(...future.stdout)
[13:19:15.636]         ...future.stdout <- NULL
[13:19:15.636]     }
[13:19:15.636]     ...future.result$conditions <- ...future.conditions
[13:19:15.636]     ...future.result$finished <- base::Sys.time()
[13:19:15.636]     ...future.result
[13:19:15.636] }
[13:19:15.637] assign_globals() ...
[13:19:15.637] List of 5
[13:19:15.637]  $ ...future.FUN            :function (x, y)  
[13:19:15.637]  $ MoreArgs                 : NULL
[13:19:15.637]  $ ...future.elements_ii    :List of 2
[13:19:15.637]   ..$ :List of 2
[13:19:15.637]   .. ..$ : int 1
[13:19:15.637]   .. ..$ : int 0
[13:19:15.637]   ..$ :List of 2
[13:19:15.637]   .. ..$ : int 0
[13:19:15.637]   .. ..$ : int 1
[13:19:15.637]  $ ...future.seeds_ii       : NULL
[13:19:15.637]  $ ...future.globals.maxSize: NULL
[13:19:15.637]  - attr(*, "resolved")= logi FALSE
[13:19:15.637]  - attr(*, "total_size")= num 6480
[13:19:15.637]  - attr(*, "where")=List of 5
[13:19:15.637]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:15.637]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:15.637]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:15.637]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:15.637]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:15.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:15.637]  - attr(*, "already-done")= logi TRUE
[13:19:15.643] - reassign environment for ‘...future.FUN’
[13:19:15.643] - copied ‘...future.FUN’ to environment
[13:19:15.643] - copied ‘MoreArgs’ to environment
[13:19:15.643] - copied ‘...future.elements_ii’ to environment
[13:19:15.643] - copied ‘...future.seeds_ii’ to environment
[13:19:15.644] - copied ‘...future.globals.maxSize’ to environment
[13:19:15.644] assign_globals() ... done
[13:19:15.644] plan(): Setting new future strategy stack:
[13:19:15.644] List of future strategies:
[13:19:15.644] 1. sequential:
[13:19:15.644]    - args: function (..., envir = parent.frame())
[13:19:15.644]    - tweaked: FALSE
[13:19:15.644]    - call: NULL
[13:19:15.644] plan(): nbrOfWorkers() = 1
[13:19:16.146] plan(): Setting new future strategy stack:
[13:19:16.146] List of future strategies:
[13:19:16.146] 1. multicore:
[13:19:16.146]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:16.146]    - tweaked: FALSE
[13:19:16.146]    - call: plan(strategy)
[13:19:16.150] plan(): nbrOfWorkers() = 1
[13:19:16.150] SequentialFuture started (and completed)
[13:19:16.151] - Launch lazy future ... done
[13:19:16.151] run() for ‘SequentialFuture’ ... done
[13:19:16.151] Created future:
[13:19:16.151] SequentialFuture:
[13:19:16.151] Label: ‘future_mapply-1’
[13:19:16.151] Expression:
[13:19:16.151] {
[13:19:16.151]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:16.151]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:16.151]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:16.151]         on.exit(options(oopts), add = TRUE)
[13:19:16.151]     }
[13:19:16.151]     {
[13:19:16.151]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:16.151]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:16.151]         do.call(mapply, args = args)
[13:19:16.151]     }
[13:19:16.151] }
[13:19:16.151] Lazy evaluation: FALSE
[13:19:16.151] Asynchronous evaluation: FALSE
[13:19:16.151] Local evaluation: TRUE
[13:19:16.151] Environment: R_GlobalEnv
[13:19:16.151] Capture standard output: NA
[13:19:16.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:16.151] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:16.151] Packages: <none>
[13:19:16.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:16.151] Resolved: TRUE
[13:19:16.151] Value: 224 bytes of class ‘list’
[13:19:16.151] Early signaling: FALSE
[13:19:16.151] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:16.151] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:16.152] Chunk #1 of 1 ... DONE
[13:19:16.152] Launching 1 futures (chunks) ... DONE
[13:19:16.152] Resolving 1 futures (chunks) ...
[13:19:16.181] resolve() on list ...
[13:19:16.181]  recursive: 0
[13:19:16.181]  length: 1
[13:19:16.181] 
[13:19:16.181] resolved() for ‘SequentialFuture’ ...
[13:19:16.181] - state: ‘finished’
[13:19:16.181] - run: TRUE
[13:19:16.182] - result: ‘FutureResult’
[13:19:16.182] resolved() for ‘SequentialFuture’ ... done
[13:19:16.182] Future #1
[13:19:16.182] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:16.182] - nx: 1
[13:19:16.182] - relay: TRUE
[13:19:16.182] - stdout: TRUE
[13:19:16.182] - signal: TRUE
[13:19:16.183] - resignal: FALSE
[13:19:16.183] - force: TRUE
[13:19:16.183] - relayed: [n=1] FALSE
[13:19:16.183] - queued futures: [n=1] FALSE
[13:19:16.183]  - until=1
[13:19:16.183]  - relaying element #1
[13:19:16.183] - relayed: [n=1] TRUE
[13:19:16.183] - queued futures: [n=1] TRUE
[13:19:16.184] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:16.184]  length: 0 (resolved future 1)
[13:19:16.184] Relaying remaining futures
[13:19:16.184] signalConditionsASAP(NULL, pos=0) ...
[13:19:16.184] - nx: 1
[13:19:16.184] - relay: TRUE
[13:19:16.184] - stdout: TRUE
[13:19:16.184] - signal: TRUE
[13:19:16.184] - resignal: FALSE
[13:19:16.184] - force: TRUE
[13:19:16.184] - relayed: [n=1] TRUE
[13:19:16.184] - queued futures: [n=1] TRUE
 - flush all
[13:19:16.185] - relayed: [n=1] TRUE
[13:19:16.185] - queued futures: [n=1] TRUE
[13:19:16.185] signalConditionsASAP(NULL, pos=0) ... done
[13:19:16.185] resolve() on list ... DONE
[13:19:16.185]  - Number of value chunks collected: 1
[13:19:16.185] Resolving 1 futures (chunks) ... DONE
[13:19:16.185] Reducing values from 1 chunks ...
[13:19:16.185]  - Number of values collected after concatenation: 2
[13:19:16.185]  - Number of values expected: 2
[13:19:16.186] Reducing values from 1 chunks ... DONE
[13:19:16.186] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[13:19:16.186] plan(): Setting new future strategy stack:
[13:19:16.186] List of future strategies:
[13:19:16.186] 1. multisession:
[13:19:16.186]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:16.186]    - tweaked: FALSE
[13:19:16.186]    - call: plan(strategy)
[13:19:16.187] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:19:16.187] multisession:
[13:19:16.187] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:16.187] - tweaked: FALSE
[13:19:16.187] - call: plan(strategy)
[13:19:16.191] getGlobalsAndPackages() ...
[13:19:16.191] Not searching for globals
[13:19:16.191] - globals: [0] <none>
[13:19:16.192] getGlobalsAndPackages() ... DONE
[13:19:16.192] Packages needed by the future expression (n = 0): <none>
[13:19:16.192] Packages needed by future strategies (n = 0): <none>
[13:19:16.193] {
[13:19:16.193]     {
[13:19:16.193]         {
[13:19:16.193]             ...future.startTime <- base::Sys.time()
[13:19:16.193]             {
[13:19:16.193]                 {
[13:19:16.193]                   {
[13:19:16.193]                     base::local({
[13:19:16.193]                       has_future <- base::requireNamespace("future", 
[13:19:16.193]                         quietly = TRUE)
[13:19:16.193]                       if (has_future) {
[13:19:16.193]                         ns <- base::getNamespace("future")
[13:19:16.193]                         version <- ns[[".package"]][["version"]]
[13:19:16.193]                         if (is.null(version)) 
[13:19:16.193]                           version <- utils::packageVersion("future")
[13:19:16.193]                       }
[13:19:16.193]                       else {
[13:19:16.193]                         version <- NULL
[13:19:16.193]                       }
[13:19:16.193]                       if (!has_future || version < "1.8.0") {
[13:19:16.193]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:16.193]                           "", base::R.version$version.string), 
[13:19:16.193]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:16.193]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:16.193]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:16.193]                             "release", "version")], collapse = " "), 
[13:19:16.193]                           hostname = base::Sys.info()[["nodename"]])
[13:19:16.193]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:16.193]                           info)
[13:19:16.193]                         info <- base::paste(info, collapse = "; ")
[13:19:16.193]                         if (!has_future) {
[13:19:16.193]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:16.193]                             info)
[13:19:16.193]                         }
[13:19:16.193]                         else {
[13:19:16.193]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:16.193]                             info, version)
[13:19:16.193]                         }
[13:19:16.193]                         base::stop(msg)
[13:19:16.193]                       }
[13:19:16.193]                     })
[13:19:16.193]                   }
[13:19:16.193]                   options(future.plan = NULL)
[13:19:16.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:16.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:16.193]                 }
[13:19:16.193]                 ...future.workdir <- getwd()
[13:19:16.193]             }
[13:19:16.193]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:16.193]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:16.193]         }
[13:19:16.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:16.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:16.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:16.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:16.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:16.193]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:16.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:16.193]             base::names(...future.oldOptions))
[13:19:16.193]     }
[13:19:16.193]     if (FALSE) {
[13:19:16.193]     }
[13:19:16.193]     else {
[13:19:16.193]         if (TRUE) {
[13:19:16.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:16.193]                 open = "w")
[13:19:16.193]         }
[13:19:16.193]         else {
[13:19:16.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:16.193]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:16.193]         }
[13:19:16.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:16.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:16.193]             base::sink(type = "output", split = FALSE)
[13:19:16.193]             base::close(...future.stdout)
[13:19:16.193]         }, add = TRUE)
[13:19:16.193]     }
[13:19:16.193]     ...future.frame <- base::sys.nframe()
[13:19:16.193]     ...future.conditions <- base::list()
[13:19:16.193]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:16.193]     if (FALSE) {
[13:19:16.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:16.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:16.193]     }
[13:19:16.193]     ...future.result <- base::tryCatch({
[13:19:16.193]         base::withCallingHandlers({
[13:19:16.193]             ...future.value <- base::withVisible(base::local(NA))
[13:19:16.193]             future::FutureResult(value = ...future.value$value, 
[13:19:16.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:16.193]                   ...future.rng), globalenv = if (FALSE) 
[13:19:16.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:16.193]                     ...future.globalenv.names))
[13:19:16.193]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:16.193]         }, condition = base::local({
[13:19:16.193]             c <- base::c
[13:19:16.193]             inherits <- base::inherits
[13:19:16.193]             invokeRestart <- base::invokeRestart
[13:19:16.193]             length <- base::length
[13:19:16.193]             list <- base::list
[13:19:16.193]             seq.int <- base::seq.int
[13:19:16.193]             signalCondition <- base::signalCondition
[13:19:16.193]             sys.calls <- base::sys.calls
[13:19:16.193]             `[[` <- base::`[[`
[13:19:16.193]             `+` <- base::`+`
[13:19:16.193]             `<<-` <- base::`<<-`
[13:19:16.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:16.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:16.193]                   3L)]
[13:19:16.193]             }
[13:19:16.193]             function(cond) {
[13:19:16.193]                 is_error <- inherits(cond, "error")
[13:19:16.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:16.193]                   NULL)
[13:19:16.193]                 if (is_error) {
[13:19:16.193]                   sessionInformation <- function() {
[13:19:16.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:16.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:16.193]                       search = base::search(), system = base::Sys.info())
[13:19:16.193]                   }
[13:19:16.193]                   ...future.conditions[[length(...future.conditions) + 
[13:19:16.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:16.193]                     cond$call), session = sessionInformation(), 
[13:19:16.193]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:16.193]                   signalCondition(cond)
[13:19:16.193]                 }
[13:19:16.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:16.193]                 "immediateCondition"))) {
[13:19:16.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:16.193]                   ...future.conditions[[length(...future.conditions) + 
[13:19:16.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:16.193]                   if (TRUE && !signal) {
[13:19:16.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:16.193]                     {
[13:19:16.193]                       inherits <- base::inherits
[13:19:16.193]                       invokeRestart <- base::invokeRestart
[13:19:16.193]                       is.null <- base::is.null
[13:19:16.193]                       muffled <- FALSE
[13:19:16.193]                       if (inherits(cond, "message")) {
[13:19:16.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:16.193]                         if (muffled) 
[13:19:16.193]                           invokeRestart("muffleMessage")
[13:19:16.193]                       }
[13:19:16.193]                       else if (inherits(cond, "warning")) {
[13:19:16.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:16.193]                         if (muffled) 
[13:19:16.193]                           invokeRestart("muffleWarning")
[13:19:16.193]                       }
[13:19:16.193]                       else if (inherits(cond, "condition")) {
[13:19:16.193]                         if (!is.null(pattern)) {
[13:19:16.193]                           computeRestarts <- base::computeRestarts
[13:19:16.193]                           grepl <- base::grepl
[13:19:16.193]                           restarts <- computeRestarts(cond)
[13:19:16.193]                           for (restart in restarts) {
[13:19:16.193]                             name <- restart$name
[13:19:16.193]                             if (is.null(name)) 
[13:19:16.193]                               next
[13:19:16.193]                             if (!grepl(pattern, name)) 
[13:19:16.193]                               next
[13:19:16.193]                             invokeRestart(restart)
[13:19:16.193]                             muffled <- TRUE
[13:19:16.193]                             break
[13:19:16.193]                           }
[13:19:16.193]                         }
[13:19:16.193]                       }
[13:19:16.193]                       invisible(muffled)
[13:19:16.193]                     }
[13:19:16.193]                     muffleCondition(cond, pattern = "^muffle")
[13:19:16.193]                   }
[13:19:16.193]                 }
[13:19:16.193]                 else {
[13:19:16.193]                   if (TRUE) {
[13:19:16.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:16.193]                     {
[13:19:16.193]                       inherits <- base::inherits
[13:19:16.193]                       invokeRestart <- base::invokeRestart
[13:19:16.193]                       is.null <- base::is.null
[13:19:16.193]                       muffled <- FALSE
[13:19:16.193]                       if (inherits(cond, "message")) {
[13:19:16.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:16.193]                         if (muffled) 
[13:19:16.193]                           invokeRestart("muffleMessage")
[13:19:16.193]                       }
[13:19:16.193]                       else if (inherits(cond, "warning")) {
[13:19:16.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:16.193]                         if (muffled) 
[13:19:16.193]                           invokeRestart("muffleWarning")
[13:19:16.193]                       }
[13:19:16.193]                       else if (inherits(cond, "condition")) {
[13:19:16.193]                         if (!is.null(pattern)) {
[13:19:16.193]                           computeRestarts <- base::computeRestarts
[13:19:16.193]                           grepl <- base::grepl
[13:19:16.193]                           restarts <- computeRestarts(cond)
[13:19:16.193]                           for (restart in restarts) {
[13:19:16.193]                             name <- restart$name
[13:19:16.193]                             if (is.null(name)) 
[13:19:16.193]                               next
[13:19:16.193]                             if (!grepl(pattern, name)) 
[13:19:16.193]                               next
[13:19:16.193]                             invokeRestart(restart)
[13:19:16.193]                             muffled <- TRUE
[13:19:16.193]                             break
[13:19:16.193]                           }
[13:19:16.193]                         }
[13:19:16.193]                       }
[13:19:16.193]                       invisible(muffled)
[13:19:16.193]                     }
[13:19:16.193]                     muffleCondition(cond, pattern = "^muffle")
[13:19:16.193]                   }
[13:19:16.193]                 }
[13:19:16.193]             }
[13:19:16.193]         }))
[13:19:16.193]     }, error = function(ex) {
[13:19:16.193]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:16.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:16.193]                 ...future.rng), started = ...future.startTime, 
[13:19:16.193]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:16.193]             version = "1.8"), class = "FutureResult")
[13:19:16.193]     }, finally = {
[13:19:16.193]         if (!identical(...future.workdir, getwd())) 
[13:19:16.193]             setwd(...future.workdir)
[13:19:16.193]         {
[13:19:16.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:16.193]                 ...future.oldOptions$nwarnings <- NULL
[13:19:16.193]             }
[13:19:16.193]             base::options(...future.oldOptions)
[13:19:16.193]             if (.Platform$OS.type == "windows") {
[13:19:16.193]                 old_names <- names(...future.oldEnvVars)
[13:19:16.193]                 envs <- base::Sys.getenv()
[13:19:16.193]                 names <- names(envs)
[13:19:16.193]                 common <- intersect(names, old_names)
[13:19:16.193]                 added <- setdiff(names, old_names)
[13:19:16.193]                 removed <- setdiff(old_names, names)
[13:19:16.193]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:16.193]                   envs[common]]
[13:19:16.193]                 NAMES <- toupper(changed)
[13:19:16.193]                 args <- list()
[13:19:16.193]                 for (kk in seq_along(NAMES)) {
[13:19:16.193]                   name <- changed[[kk]]
[13:19:16.193]                   NAME <- NAMES[[kk]]
[13:19:16.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.193]                     next
[13:19:16.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:16.193]                 }
[13:19:16.193]                 NAMES <- toupper(added)
[13:19:16.193]                 for (kk in seq_along(NAMES)) {
[13:19:16.193]                   name <- added[[kk]]
[13:19:16.193]                   NAME <- NAMES[[kk]]
[13:19:16.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.193]                     next
[13:19:16.193]                   args[[name]] <- ""
[13:19:16.193]                 }
[13:19:16.193]                 NAMES <- toupper(removed)
[13:19:16.193]                 for (kk in seq_along(NAMES)) {
[13:19:16.193]                   name <- removed[[kk]]
[13:19:16.193]                   NAME <- NAMES[[kk]]
[13:19:16.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.193]                     next
[13:19:16.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:16.193]                 }
[13:19:16.193]                 if (length(args) > 0) 
[13:19:16.193]                   base::do.call(base::Sys.setenv, args = args)
[13:19:16.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:16.193]             }
[13:19:16.193]             else {
[13:19:16.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:16.193]             }
[13:19:16.193]             {
[13:19:16.193]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:16.193]                   0L) {
[13:19:16.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:16.193]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:16.193]                   base::options(opts)
[13:19:16.193]                 }
[13:19:16.193]                 {
[13:19:16.193]                   {
[13:19:16.193]                     NULL
[13:19:16.193]                     RNGkind("Mersenne-Twister")
[13:19:16.193]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:16.193]                       inherits = FALSE)
[13:19:16.193]                   }
[13:19:16.193]                   options(future.plan = NULL)
[13:19:16.193]                   if (is.na(NA_character_)) 
[13:19:16.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:16.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:16.193]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:16.193]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:16.193]                     envir = parent.frame()) 
[13:19:16.193]                   {
[13:19:16.193]                     if (is.function(workers)) 
[13:19:16.193]                       workers <- workers()
[13:19:16.193]                     workers <- structure(as.integer(workers), 
[13:19:16.193]                       class = class(workers))
[13:19:16.193]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:16.193]                       workers >= 1)
[13:19:16.193]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:16.193]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:16.193]                     }
[13:19:16.193]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:16.193]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:16.193]                       envir = envir)
[13:19:16.193]                     if (!future$lazy) 
[13:19:16.193]                       future <- run(future)
[13:19:16.193]                     invisible(future)
[13:19:16.193]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:16.193]                 }
[13:19:16.193]             }
[13:19:16.193]         }
[13:19:16.193]     })
[13:19:16.193]     if (TRUE) {
[13:19:16.193]         base::sink(type = "output", split = FALSE)
[13:19:16.193]         if (TRUE) {
[13:19:16.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:16.193]         }
[13:19:16.193]         else {
[13:19:16.193]             ...future.result["stdout"] <- base::list(NULL)
[13:19:16.193]         }
[13:19:16.193]         base::close(...future.stdout)
[13:19:16.193]         ...future.stdout <- NULL
[13:19:16.193]     }
[13:19:16.193]     ...future.result$conditions <- ...future.conditions
[13:19:16.193]     ...future.result$finished <- base::Sys.time()
[13:19:16.193]     ...future.result
[13:19:16.193] }
[13:19:16.195] plan(): Setting new future strategy stack:
[13:19:16.195] List of future strategies:
[13:19:16.195] 1. sequential:
[13:19:16.195]    - args: function (..., envir = parent.frame())
[13:19:16.195]    - tweaked: FALSE
[13:19:16.195]    - call: NULL
[13:19:16.195] plan(): nbrOfWorkers() = 1
[13:19:16.196] plan(): Setting new future strategy stack:
[13:19:16.196] List of future strategies:
[13:19:16.196] 1. multisession:
[13:19:16.196]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:16.196]    - tweaked: FALSE
[13:19:16.196]    - call: plan(strategy)
[13:19:16.199] plan(): nbrOfWorkers() = 1
[13:19:16.200] SequentialFuture started (and completed)
[13:19:16.200] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:19:16.203] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:19:16.203] future_lapply() ...
[13:19:16.207] Number of chunks: 1
[13:19:16.207] getGlobalsAndPackagesXApply() ...
[13:19:16.207]  - future.globals: TRUE
[13:19:16.207] getGlobalsAndPackages() ...
[13:19:16.207] Searching for globals...
[13:19:16.209] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:16.209] Searching for globals ... DONE
[13:19:16.209] Resolving globals: FALSE
[13:19:16.209] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:16.210] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:16.210] - globals: [1] ‘FUN’
[13:19:16.210] 
[13:19:16.210] getGlobalsAndPackages() ... DONE
[13:19:16.210]  - globals found/used: [n=1] ‘FUN’
[13:19:16.210]  - needed namespaces: [n=0] 
[13:19:16.210] Finding globals ... DONE
[13:19:16.210]  - use_args: TRUE
[13:19:16.211]  - Getting '...' globals ...
[13:19:16.211] resolve() on list ...
[13:19:16.211]  recursive: 0
[13:19:16.211]  length: 1
[13:19:16.211]  elements: ‘...’
[13:19:16.211]  length: 0 (resolved future 1)
[13:19:16.211] resolve() on list ... DONE
[13:19:16.211]    - '...' content: [n=0] 
[13:19:16.212] List of 1
[13:19:16.212]  $ ...: list()
[13:19:16.212]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:16.212]  - attr(*, "where")=List of 1
[13:19:16.212]   ..$ ...:<environment: 0x562005aaa3b8> 
[13:19:16.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:16.212]  - attr(*, "resolved")= logi TRUE
[13:19:16.212]  - attr(*, "total_size")= num NA
[13:19:16.214]  - Getting '...' globals ... DONE
[13:19:16.214] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:16.215] List of 2
[13:19:16.215]  $ ...future.FUN:function (x)  
[13:19:16.215]  $ ...          : list()
[13:19:16.215]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:16.215]  - attr(*, "where")=List of 2
[13:19:16.215]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:16.215]   ..$ ...          :<environment: 0x562005aaa3b8> 
[13:19:16.215]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:16.215]  - attr(*, "resolved")= logi FALSE
[13:19:16.215]  - attr(*, "total_size")= num 4720
[13:19:16.217] Packages to be attached in all futures: [n=0] 
[13:19:16.217] getGlobalsAndPackagesXApply() ... DONE
[13:19:16.219] Number of futures (= number of chunks): 1
[13:19:16.219] Launching 1 futures (chunks) ...
[13:19:16.219] Chunk #1 of 1 ...
[13:19:16.219]  - Finding globals in 'X' for chunk #1 ...
[13:19:16.219] getGlobalsAndPackages() ...
[13:19:16.220] Searching for globals...
[13:19:16.220] 
[13:19:16.220] Searching for globals ... DONE
[13:19:16.220] - globals: [0] <none>
[13:19:16.220] getGlobalsAndPackages() ... DONE
[13:19:16.220]    + additional globals found: [n=0] 
[13:19:16.220]    + additional namespaces needed: [n=0] 
[13:19:16.220]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:16.221]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:16.221]  - seeds: <none>
[13:19:16.221] getGlobalsAndPackages() ...
[13:19:16.221] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:16.221] Resolving globals: FALSE
[13:19:16.221] Tweak future expression to call with '...' arguments ...
[13:19:16.221] {
[13:19:16.221]     do.call(function(...) {
[13:19:16.221]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:16.221]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:16.221]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:16.221]             on.exit(options(oopts), add = TRUE)
[13:19:16.221]         }
[13:19:16.221]         {
[13:19:16.221]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:16.221]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:16.221]                 ...future.FUN(...future.X_jj, ...)
[13:19:16.221]             })
[13:19:16.221]         }
[13:19:16.221]     }, args = future.call.arguments)
[13:19:16.221] }
[13:19:16.222] Tweak future expression to call with '...' arguments ... DONE
[13:19:16.222] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:16.222] 
[13:19:16.222] getGlobalsAndPackages() ... DONE
[13:19:16.223] run() for ‘Future’ ...
[13:19:16.223] - state: ‘created’
[13:19:16.223] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:16.227] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:16.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:16.227]   - Field: ‘label’
[13:19:16.227]   - Field: ‘local’
[13:19:16.227]   - Field: ‘owner’
[13:19:16.227]   - Field: ‘envir’
[13:19:16.227]   - Field: ‘packages’
[13:19:16.227]   - Field: ‘gc’
[13:19:16.228]   - Field: ‘conditions’
[13:19:16.228]   - Field: ‘expr’
[13:19:16.228]   - Field: ‘uuid’
[13:19:16.228]   - Field: ‘seed’
[13:19:16.228]   - Field: ‘version’
[13:19:16.228]   - Field: ‘result’
[13:19:16.228]   - Field: ‘asynchronous’
[13:19:16.228]   - Field: ‘calls’
[13:19:16.228]   - Field: ‘globals’
[13:19:16.229]   - Field: ‘stdout’
[13:19:16.229]   - Field: ‘earlySignal’
[13:19:16.229]   - Field: ‘lazy’
[13:19:16.229]   - Field: ‘state’
[13:19:16.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:16.229] - Launch lazy future ...
[13:19:16.229] Packages needed by the future expression (n = 0): <none>
[13:19:16.229] Packages needed by future strategies (n = 0): <none>
[13:19:16.230] {
[13:19:16.230]     {
[13:19:16.230]         {
[13:19:16.230]             ...future.startTime <- base::Sys.time()
[13:19:16.230]             {
[13:19:16.230]                 {
[13:19:16.230]                   {
[13:19:16.230]                     base::local({
[13:19:16.230]                       has_future <- base::requireNamespace("future", 
[13:19:16.230]                         quietly = TRUE)
[13:19:16.230]                       if (has_future) {
[13:19:16.230]                         ns <- base::getNamespace("future")
[13:19:16.230]                         version <- ns[[".package"]][["version"]]
[13:19:16.230]                         if (is.null(version)) 
[13:19:16.230]                           version <- utils::packageVersion("future")
[13:19:16.230]                       }
[13:19:16.230]                       else {
[13:19:16.230]                         version <- NULL
[13:19:16.230]                       }
[13:19:16.230]                       if (!has_future || version < "1.8.0") {
[13:19:16.230]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:16.230]                           "", base::R.version$version.string), 
[13:19:16.230]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:16.230]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:16.230]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:16.230]                             "release", "version")], collapse = " "), 
[13:19:16.230]                           hostname = base::Sys.info()[["nodename"]])
[13:19:16.230]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:16.230]                           info)
[13:19:16.230]                         info <- base::paste(info, collapse = "; ")
[13:19:16.230]                         if (!has_future) {
[13:19:16.230]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:16.230]                             info)
[13:19:16.230]                         }
[13:19:16.230]                         else {
[13:19:16.230]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:16.230]                             info, version)
[13:19:16.230]                         }
[13:19:16.230]                         base::stop(msg)
[13:19:16.230]                       }
[13:19:16.230]                     })
[13:19:16.230]                   }
[13:19:16.230]                   options(future.plan = NULL)
[13:19:16.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:16.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:16.230]                 }
[13:19:16.230]                 ...future.workdir <- getwd()
[13:19:16.230]             }
[13:19:16.230]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:16.230]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:16.230]         }
[13:19:16.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:16.230]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:16.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:16.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:16.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:16.230]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:16.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:16.230]             base::names(...future.oldOptions))
[13:19:16.230]     }
[13:19:16.230]     if (FALSE) {
[13:19:16.230]     }
[13:19:16.230]     else {
[13:19:16.230]         if (FALSE) {
[13:19:16.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:16.230]                 open = "w")
[13:19:16.230]         }
[13:19:16.230]         else {
[13:19:16.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:16.230]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:16.230]         }
[13:19:16.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:16.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:16.230]             base::sink(type = "output", split = FALSE)
[13:19:16.230]             base::close(...future.stdout)
[13:19:16.230]         }, add = TRUE)
[13:19:16.230]     }
[13:19:16.230]     ...future.frame <- base::sys.nframe()
[13:19:16.230]     ...future.conditions <- base::list()
[13:19:16.230]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:16.230]     if (FALSE) {
[13:19:16.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:16.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:16.230]     }
[13:19:16.230]     ...future.result <- base::tryCatch({
[13:19:16.230]         base::withCallingHandlers({
[13:19:16.230]             ...future.value <- base::withVisible(base::local({
[13:19:16.230]                 do.call(function(...) {
[13:19:16.230]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:16.230]                   if (!identical(...future.globals.maxSize.org, 
[13:19:16.230]                     ...future.globals.maxSize)) {
[13:19:16.230]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:16.230]                     on.exit(options(oopts), add = TRUE)
[13:19:16.230]                   }
[13:19:16.230]                   {
[13:19:16.230]                     lapply(seq_along(...future.elements_ii), 
[13:19:16.230]                       FUN = function(jj) {
[13:19:16.230]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:16.230]                         ...future.FUN(...future.X_jj, ...)
[13:19:16.230]                       })
[13:19:16.230]                   }
[13:19:16.230]                 }, args = future.call.arguments)
[13:19:16.230]             }))
[13:19:16.230]             future::FutureResult(value = ...future.value$value, 
[13:19:16.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:16.230]                   ...future.rng), globalenv = if (FALSE) 
[13:19:16.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:16.230]                     ...future.globalenv.names))
[13:19:16.230]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:16.230]         }, condition = base::local({
[13:19:16.230]             c <- base::c
[13:19:16.230]             inherits <- base::inherits
[13:19:16.230]             invokeRestart <- base::invokeRestart
[13:19:16.230]             length <- base::length
[13:19:16.230]             list <- base::list
[13:19:16.230]             seq.int <- base::seq.int
[13:19:16.230]             signalCondition <- base::signalCondition
[13:19:16.230]             sys.calls <- base::sys.calls
[13:19:16.230]             `[[` <- base::`[[`
[13:19:16.230]             `+` <- base::`+`
[13:19:16.230]             `<<-` <- base::`<<-`
[13:19:16.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:16.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:16.230]                   3L)]
[13:19:16.230]             }
[13:19:16.230]             function(cond) {
[13:19:16.230]                 is_error <- inherits(cond, "error")
[13:19:16.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:16.230]                   NULL)
[13:19:16.230]                 if (is_error) {
[13:19:16.230]                   sessionInformation <- function() {
[13:19:16.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:16.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:16.230]                       search = base::search(), system = base::Sys.info())
[13:19:16.230]                   }
[13:19:16.230]                   ...future.conditions[[length(...future.conditions) + 
[13:19:16.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:16.230]                     cond$call), session = sessionInformation(), 
[13:19:16.230]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:16.230]                   signalCondition(cond)
[13:19:16.230]                 }
[13:19:16.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:16.230]                 "immediateCondition"))) {
[13:19:16.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:16.230]                   ...future.conditions[[length(...future.conditions) + 
[13:19:16.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:16.230]                   if (TRUE && !signal) {
[13:19:16.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:16.230]                     {
[13:19:16.230]                       inherits <- base::inherits
[13:19:16.230]                       invokeRestart <- base::invokeRestart
[13:19:16.230]                       is.null <- base::is.null
[13:19:16.230]                       muffled <- FALSE
[13:19:16.230]                       if (inherits(cond, "message")) {
[13:19:16.230]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:16.230]                         if (muffled) 
[13:19:16.230]                           invokeRestart("muffleMessage")
[13:19:16.230]                       }
[13:19:16.230]                       else if (inherits(cond, "warning")) {
[13:19:16.230]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:16.230]                         if (muffled) 
[13:19:16.230]                           invokeRestart("muffleWarning")
[13:19:16.230]                       }
[13:19:16.230]                       else if (inherits(cond, "condition")) {
[13:19:16.230]                         if (!is.null(pattern)) {
[13:19:16.230]                           computeRestarts <- base::computeRestarts
[13:19:16.230]                           grepl <- base::grepl
[13:19:16.230]                           restarts <- computeRestarts(cond)
[13:19:16.230]                           for (restart in restarts) {
[13:19:16.230]                             name <- restart$name
[13:19:16.230]                             if (is.null(name)) 
[13:19:16.230]                               next
[13:19:16.230]                             if (!grepl(pattern, name)) 
[13:19:16.230]                               next
[13:19:16.230]                             invokeRestart(restart)
[13:19:16.230]                             muffled <- TRUE
[13:19:16.230]                             break
[13:19:16.230]                           }
[13:19:16.230]                         }
[13:19:16.230]                       }
[13:19:16.230]                       invisible(muffled)
[13:19:16.230]                     }
[13:19:16.230]                     muffleCondition(cond, pattern = "^muffle")
[13:19:16.230]                   }
[13:19:16.230]                 }
[13:19:16.230]                 else {
[13:19:16.230]                   if (TRUE) {
[13:19:16.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:16.230]                     {
[13:19:16.230]                       inherits <- base::inherits
[13:19:16.230]                       invokeRestart <- base::invokeRestart
[13:19:16.230]                       is.null <- base::is.null
[13:19:16.230]                       muffled <- FALSE
[13:19:16.230]                       if (inherits(cond, "message")) {
[13:19:16.230]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:16.230]                         if (muffled) 
[13:19:16.230]                           invokeRestart("muffleMessage")
[13:19:16.230]                       }
[13:19:16.230]                       else if (inherits(cond, "warning")) {
[13:19:16.230]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:16.230]                         if (muffled) 
[13:19:16.230]                           invokeRestart("muffleWarning")
[13:19:16.230]                       }
[13:19:16.230]                       else if (inherits(cond, "condition")) {
[13:19:16.230]                         if (!is.null(pattern)) {
[13:19:16.230]                           computeRestarts <- base::computeRestarts
[13:19:16.230]                           grepl <- base::grepl
[13:19:16.230]                           restarts <- computeRestarts(cond)
[13:19:16.230]                           for (restart in restarts) {
[13:19:16.230]                             name <- restart$name
[13:19:16.230]                             if (is.null(name)) 
[13:19:16.230]                               next
[13:19:16.230]                             if (!grepl(pattern, name)) 
[13:19:16.230]                               next
[13:19:16.230]                             invokeRestart(restart)
[13:19:16.230]                             muffled <- TRUE
[13:19:16.230]                             break
[13:19:16.230]                           }
[13:19:16.230]                         }
[13:19:16.230]                       }
[13:19:16.230]                       invisible(muffled)
[13:19:16.230]                     }
[13:19:16.230]                     muffleCondition(cond, pattern = "^muffle")
[13:19:16.230]                   }
[13:19:16.230]                 }
[13:19:16.230]             }
[13:19:16.230]         }))
[13:19:16.230]     }, error = function(ex) {
[13:19:16.230]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:16.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:16.230]                 ...future.rng), started = ...future.startTime, 
[13:19:16.230]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:16.230]             version = "1.8"), class = "FutureResult")
[13:19:16.230]     }, finally = {
[13:19:16.230]         if (!identical(...future.workdir, getwd())) 
[13:19:16.230]             setwd(...future.workdir)
[13:19:16.230]         {
[13:19:16.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:16.230]                 ...future.oldOptions$nwarnings <- NULL
[13:19:16.230]             }
[13:19:16.230]             base::options(...future.oldOptions)
[13:19:16.230]             if (.Platform$OS.type == "windows") {
[13:19:16.230]                 old_names <- names(...future.oldEnvVars)
[13:19:16.230]                 envs <- base::Sys.getenv()
[13:19:16.230]                 names <- names(envs)
[13:19:16.230]                 common <- intersect(names, old_names)
[13:19:16.230]                 added <- setdiff(names, old_names)
[13:19:16.230]                 removed <- setdiff(old_names, names)
[13:19:16.230]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:16.230]                   envs[common]]
[13:19:16.230]                 NAMES <- toupper(changed)
[13:19:16.230]                 args <- list()
[13:19:16.230]                 for (kk in seq_along(NAMES)) {
[13:19:16.230]                   name <- changed[[kk]]
[13:19:16.230]                   NAME <- NAMES[[kk]]
[13:19:16.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.230]                     next
[13:19:16.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:16.230]                 }
[13:19:16.230]                 NAMES <- toupper(added)
[13:19:16.230]                 for (kk in seq_along(NAMES)) {
[13:19:16.230]                   name <- added[[kk]]
[13:19:16.230]                   NAME <- NAMES[[kk]]
[13:19:16.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.230]                     next
[13:19:16.230]                   args[[name]] <- ""
[13:19:16.230]                 }
[13:19:16.230]                 NAMES <- toupper(removed)
[13:19:16.230]                 for (kk in seq_along(NAMES)) {
[13:19:16.230]                   name <- removed[[kk]]
[13:19:16.230]                   NAME <- NAMES[[kk]]
[13:19:16.230]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.230]                     next
[13:19:16.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:16.230]                 }
[13:19:16.230]                 if (length(args) > 0) 
[13:19:16.230]                   base::do.call(base::Sys.setenv, args = args)
[13:19:16.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:16.230]             }
[13:19:16.230]             else {
[13:19:16.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:16.230]             }
[13:19:16.230]             {
[13:19:16.230]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:16.230]                   0L) {
[13:19:16.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:16.230]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:16.230]                   base::options(opts)
[13:19:16.230]                 }
[13:19:16.230]                 {
[13:19:16.230]                   {
[13:19:16.230]                     NULL
[13:19:16.230]                     RNGkind("Mersenne-Twister")
[13:19:16.230]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:16.230]                       inherits = FALSE)
[13:19:16.230]                   }
[13:19:16.230]                   options(future.plan = NULL)
[13:19:16.230]                   if (is.na(NA_character_)) 
[13:19:16.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:16.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:16.230]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:16.230]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:16.230]                     envir = parent.frame()) 
[13:19:16.230]                   {
[13:19:16.230]                     if (is.function(workers)) 
[13:19:16.230]                       workers <- workers()
[13:19:16.230]                     workers <- structure(as.integer(workers), 
[13:19:16.230]                       class = class(workers))
[13:19:16.230]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:16.230]                       workers >= 1)
[13:19:16.230]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:16.230]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:16.230]                     }
[13:19:16.230]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:16.230]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:16.230]                       envir = envir)
[13:19:16.230]                     if (!future$lazy) 
[13:19:16.230]                       future <- run(future)
[13:19:16.230]                     invisible(future)
[13:19:16.230]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:16.230]                 }
[13:19:16.230]             }
[13:19:16.230]         }
[13:19:16.230]     })
[13:19:16.230]     if (TRUE) {
[13:19:16.230]         base::sink(type = "output", split = FALSE)
[13:19:16.230]         if (FALSE) {
[13:19:16.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:16.230]         }
[13:19:16.230]         else {
[13:19:16.230]             ...future.result["stdout"] <- base::list(NULL)
[13:19:16.230]         }
[13:19:16.230]         base::close(...future.stdout)
[13:19:16.230]         ...future.stdout <- NULL
[13:19:16.230]     }
[13:19:16.230]     ...future.result$conditions <- ...future.conditions
[13:19:16.230]     ...future.result$finished <- base::Sys.time()
[13:19:16.230]     ...future.result
[13:19:16.230] }
[13:19:16.232] assign_globals() ...
[13:19:16.232] List of 5
[13:19:16.232]  $ ...future.FUN            :function (x)  
[13:19:16.232]  $ future.call.arguments    : list()
[13:19:16.232]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:16.232]  $ ...future.elements_ii    :List of 2
[13:19:16.232]   ..$ : int 1
[13:19:16.232]   ..$ : int 0
[13:19:16.232]  $ ...future.seeds_ii       : NULL
[13:19:16.232]  $ ...future.globals.maxSize: NULL
[13:19:16.232]  - attr(*, "resolved")= logi FALSE
[13:19:16.232]  - attr(*, "total_size")= num 4720
[13:19:16.232]  - attr(*, "where")=List of 5
[13:19:16.232]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:16.232]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:16.232]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:16.232]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:16.232]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:16.232]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:16.232]  - attr(*, "already-done")= logi TRUE
[13:19:16.237] - reassign environment for ‘...future.FUN’
[13:19:16.237] - copied ‘...future.FUN’ to environment
[13:19:16.237] - copied ‘future.call.arguments’ to environment
[13:19:16.237] - copied ‘...future.elements_ii’ to environment
[13:19:16.237] - copied ‘...future.seeds_ii’ to environment
[13:19:16.237] - copied ‘...future.globals.maxSize’ to environment
[13:19:16.237] assign_globals() ... done
[13:19:16.237] plan(): Setting new future strategy stack:
[13:19:16.238] List of future strategies:
[13:19:16.238] 1. sequential:
[13:19:16.238]    - args: function (..., envir = parent.frame())
[13:19:16.238]    - tweaked: FALSE
[13:19:16.238]    - call: NULL
[13:19:16.238] plan(): nbrOfWorkers() = 1
[13:19:16.740] plan(): Setting new future strategy stack:
[13:19:16.740] List of future strategies:
[13:19:16.740] 1. multisession:
[13:19:16.740]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:16.740]    - tweaked: FALSE
[13:19:16.740]    - call: plan(strategy)
[13:19:16.744] plan(): nbrOfWorkers() = 1
[13:19:16.744] SequentialFuture started (and completed)
[13:19:16.744] - Launch lazy future ... done
[13:19:16.745] run() for ‘SequentialFuture’ ... done
[13:19:16.745] Created future:
[13:19:16.745] SequentialFuture:
[13:19:16.745] Label: ‘future_lapply-1’
[13:19:16.745] Expression:
[13:19:16.745] {
[13:19:16.745]     do.call(function(...) {
[13:19:16.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:16.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:16.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:16.745]             on.exit(options(oopts), add = TRUE)
[13:19:16.745]         }
[13:19:16.745]         {
[13:19:16.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:16.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:16.745]                 ...future.FUN(...future.X_jj, ...)
[13:19:16.745]             })
[13:19:16.745]         }
[13:19:16.745]     }, args = future.call.arguments)
[13:19:16.745] }
[13:19:16.745] Lazy evaluation: FALSE
[13:19:16.745] Asynchronous evaluation: FALSE
[13:19:16.745] Local evaluation: TRUE
[13:19:16.745] Environment: R_GlobalEnv
[13:19:16.745] Capture standard output: FALSE
[13:19:16.745] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:16.745] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:16.745] Packages: <none>
[13:19:16.745] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:16.745] Resolved: TRUE
[13:19:16.745] Value: 112 bytes of class ‘list’
[13:19:16.745] Early signaling: FALSE
[13:19:16.745] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:16.745] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:16.746] Chunk #1 of 1 ... DONE
[13:19:16.746] Launching 1 futures (chunks) ... DONE
[13:19:16.746] Resolving 1 futures (chunks) ...
[13:19:16.746] resolve() on list ...
[13:19:16.747]  recursive: 0
[13:19:16.747]  length: 1
[13:19:16.747] 
[13:19:16.747] resolved() for ‘SequentialFuture’ ...
[13:19:16.747] - state: ‘finished’
[13:19:16.747] - run: TRUE
[13:19:16.747] - result: ‘FutureResult’
[13:19:16.747] resolved() for ‘SequentialFuture’ ... done
[13:19:16.747] Future #1
[13:19:16.747] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:16.748] - nx: 1
[13:19:16.748] - relay: TRUE
[13:19:16.748] - stdout: TRUE
[13:19:16.748] - signal: TRUE
[13:19:16.748] - resignal: FALSE
[13:19:16.748] - force: TRUE
[13:19:16.748] - relayed: [n=1] FALSE
[13:19:16.748] - queued futures: [n=1] FALSE
[13:19:16.748]  - until=1
[13:19:16.748]  - relaying element #1
[13:19:16.749] - relayed: [n=1] TRUE
[13:19:16.749] - queued futures: [n=1] TRUE
[13:19:16.749] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:16.749]  length: 0 (resolved future 1)
[13:19:16.749] Relaying remaining futures
[13:19:16.749] signalConditionsASAP(NULL, pos=0) ...
[13:19:16.749] - nx: 1
[13:19:16.749] - relay: TRUE
[13:19:16.749] - stdout: TRUE
[13:19:16.749] - signal: TRUE
[13:19:16.749] - resignal: FALSE
[13:19:16.750] - force: TRUE
[13:19:16.750] - relayed: [n=1] TRUE
[13:19:16.750] - queued futures: [n=1] TRUE
 - flush all
[13:19:16.750] - relayed: [n=1] TRUE
[13:19:16.750] - queued futures: [n=1] TRUE
[13:19:16.750] signalConditionsASAP(NULL, pos=0) ... done
[13:19:16.750] resolve() on list ... DONE
[13:19:16.750]  - Number of value chunks collected: 1
[13:19:16.750] Resolving 1 futures (chunks) ... DONE
[13:19:16.750] Reducing values from 1 chunks ...
[13:19:16.751]  - Number of values collected after concatenation: 2
[13:19:16.751]  - Number of values expected: 2
[13:19:16.751] Reducing values from 1 chunks ... DONE
[13:19:16.751] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:19:16.751] future_lapply() ...
[13:19:16.757] Number of chunks: 1
[13:19:16.757] getGlobalsAndPackagesXApply() ...
[13:19:16.757]  - future.globals: TRUE
[13:19:16.757] getGlobalsAndPackages() ...
[13:19:16.757] Searching for globals...
[13:19:16.759] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:16.759] Searching for globals ... DONE
[13:19:16.759] Resolving globals: FALSE
[13:19:16.760] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:16.760] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:16.760] - globals: [1] ‘FUN’
[13:19:16.760] 
[13:19:16.760] getGlobalsAndPackages() ... DONE
[13:19:16.760]  - globals found/used: [n=1] ‘FUN’
[13:19:16.760]  - needed namespaces: [n=0] 
[13:19:16.761] Finding globals ... DONE
[13:19:16.761]  - use_args: TRUE
[13:19:16.761]  - Getting '...' globals ...
[13:19:16.761] resolve() on list ...
[13:19:16.761]  recursive: 0
[13:19:16.761]  length: 1
[13:19:16.761]  elements: ‘...’
[13:19:16.761]  length: 0 (resolved future 1)
[13:19:16.762] resolve() on list ... DONE
[13:19:16.762]    - '...' content: [n=0] 
[13:19:16.762] List of 1
[13:19:16.762]  $ ...: list()
[13:19:16.762]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:16.762]  - attr(*, "where")=List of 1
[13:19:16.762]   ..$ ...:<environment: 0x5620063cc3c0> 
[13:19:16.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:16.762]  - attr(*, "resolved")= logi TRUE
[13:19:16.762]  - attr(*, "total_size")= num NA
[13:19:16.764]  - Getting '...' globals ... DONE
[13:19:16.765] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:16.765] List of 2
[13:19:16.765]  $ ...future.FUN:function (x)  
[13:19:16.765]  $ ...          : list()
[13:19:16.765]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:16.765]  - attr(*, "where")=List of 2
[13:19:16.765]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:16.765]   ..$ ...          :<environment: 0x5620063cc3c0> 
[13:19:16.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:16.765]  - attr(*, "resolved")= logi FALSE
[13:19:16.765]  - attr(*, "total_size")= num 4720
[13:19:16.767] Packages to be attached in all futures: [n=0] 
[13:19:16.767] getGlobalsAndPackagesXApply() ... DONE
[13:19:16.768] Number of futures (= number of chunks): 1
[13:19:16.768] Launching 1 futures (chunks) ...
[13:19:16.768] Chunk #1 of 1 ...
[13:19:16.768]  - Finding globals in 'X' for chunk #1 ...
[13:19:16.768] getGlobalsAndPackages() ...
[13:19:16.768] Searching for globals...
[13:19:16.768] 
[13:19:16.768] Searching for globals ... DONE
[13:19:16.769] - globals: [0] <none>
[13:19:16.769] getGlobalsAndPackages() ... DONE
[13:19:16.769]    + additional globals found: [n=0] 
[13:19:16.769]    + additional namespaces needed: [n=0] 
[13:19:16.769]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:16.769]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:16.769]  - seeds: <none>
[13:19:16.769] getGlobalsAndPackages() ...
[13:19:16.769] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:16.770] Resolving globals: FALSE
[13:19:16.770] Tweak future expression to call with '...' arguments ...
[13:19:16.770] {
[13:19:16.770]     do.call(function(...) {
[13:19:16.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:16.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:16.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:16.770]             on.exit(options(oopts), add = TRUE)
[13:19:16.770]         }
[13:19:16.770]         {
[13:19:16.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:16.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:16.770]                 ...future.FUN(...future.X_jj, ...)
[13:19:16.770]             })
[13:19:16.770]         }
[13:19:16.770]     }, args = future.call.arguments)
[13:19:16.770] }
[13:19:16.770] Tweak future expression to call with '...' arguments ... DONE
[13:19:16.770] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:16.770] 
[13:19:16.771] getGlobalsAndPackages() ... DONE
[13:19:16.771] run() for ‘Future’ ...
[13:19:16.771] - state: ‘created’
[13:19:16.771] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:16.775] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:16.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:16.775]   - Field: ‘label’
[13:19:16.775]   - Field: ‘local’
[13:19:16.775]   - Field: ‘owner’
[13:19:16.775]   - Field: ‘envir’
[13:19:16.775]   - Field: ‘packages’
[13:19:16.775]   - Field: ‘gc’
[13:19:16.775]   - Field: ‘conditions’
[13:19:16.776]   - Field: ‘expr’
[13:19:16.776]   - Field: ‘uuid’
[13:19:16.776]   - Field: ‘seed’
[13:19:16.776]   - Field: ‘version’
[13:19:16.776]   - Field: ‘result’
[13:19:16.776]   - Field: ‘asynchronous’
[13:19:16.776]   - Field: ‘calls’
[13:19:16.776]   - Field: ‘globals’
[13:19:16.776]   - Field: ‘stdout’
[13:19:16.776]   - Field: ‘earlySignal’
[13:19:16.776]   - Field: ‘lazy’
[13:19:16.777]   - Field: ‘state’
[13:19:16.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:16.777] - Launch lazy future ...
[13:19:16.777] Packages needed by the future expression (n = 0): <none>
[13:19:16.777] Packages needed by future strategies (n = 0): <none>
[13:19:16.778] {
[13:19:16.778]     {
[13:19:16.778]         {
[13:19:16.778]             ...future.startTime <- base::Sys.time()
[13:19:16.778]             {
[13:19:16.778]                 {
[13:19:16.778]                   {
[13:19:16.778]                     base::local({
[13:19:16.778]                       has_future <- base::requireNamespace("future", 
[13:19:16.778]                         quietly = TRUE)
[13:19:16.778]                       if (has_future) {
[13:19:16.778]                         ns <- base::getNamespace("future")
[13:19:16.778]                         version <- ns[[".package"]][["version"]]
[13:19:16.778]                         if (is.null(version)) 
[13:19:16.778]                           version <- utils::packageVersion("future")
[13:19:16.778]                       }
[13:19:16.778]                       else {
[13:19:16.778]                         version <- NULL
[13:19:16.778]                       }
[13:19:16.778]                       if (!has_future || version < "1.8.0") {
[13:19:16.778]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:16.778]                           "", base::R.version$version.string), 
[13:19:16.778]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:16.778]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:16.778]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:16.778]                             "release", "version")], collapse = " "), 
[13:19:16.778]                           hostname = base::Sys.info()[["nodename"]])
[13:19:16.778]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:16.778]                           info)
[13:19:16.778]                         info <- base::paste(info, collapse = "; ")
[13:19:16.778]                         if (!has_future) {
[13:19:16.778]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:16.778]                             info)
[13:19:16.778]                         }
[13:19:16.778]                         else {
[13:19:16.778]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:16.778]                             info, version)
[13:19:16.778]                         }
[13:19:16.778]                         base::stop(msg)
[13:19:16.778]                       }
[13:19:16.778]                     })
[13:19:16.778]                   }
[13:19:16.778]                   options(future.plan = NULL)
[13:19:16.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:16.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:16.778]                 }
[13:19:16.778]                 ...future.workdir <- getwd()
[13:19:16.778]             }
[13:19:16.778]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:16.778]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:16.778]         }
[13:19:16.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:16.778]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:16.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:16.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:16.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:16.778]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:16.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:16.778]             base::names(...future.oldOptions))
[13:19:16.778]     }
[13:19:16.778]     if (FALSE) {
[13:19:16.778]     }
[13:19:16.778]     else {
[13:19:16.778]         if (TRUE) {
[13:19:16.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:16.778]                 open = "w")
[13:19:16.778]         }
[13:19:16.778]         else {
[13:19:16.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:16.778]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:16.778]         }
[13:19:16.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:16.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:16.778]             base::sink(type = "output", split = FALSE)
[13:19:16.778]             base::close(...future.stdout)
[13:19:16.778]         }, add = TRUE)
[13:19:16.778]     }
[13:19:16.778]     ...future.frame <- base::sys.nframe()
[13:19:16.778]     ...future.conditions <- base::list()
[13:19:16.778]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:16.778]     if (FALSE) {
[13:19:16.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:16.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:16.778]     }
[13:19:16.778]     ...future.result <- base::tryCatch({
[13:19:16.778]         base::withCallingHandlers({
[13:19:16.778]             ...future.value <- base::withVisible(base::local({
[13:19:16.778]                 do.call(function(...) {
[13:19:16.778]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:16.778]                   if (!identical(...future.globals.maxSize.org, 
[13:19:16.778]                     ...future.globals.maxSize)) {
[13:19:16.778]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:16.778]                     on.exit(options(oopts), add = TRUE)
[13:19:16.778]                   }
[13:19:16.778]                   {
[13:19:16.778]                     lapply(seq_along(...future.elements_ii), 
[13:19:16.778]                       FUN = function(jj) {
[13:19:16.778]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:16.778]                         ...future.FUN(...future.X_jj, ...)
[13:19:16.778]                       })
[13:19:16.778]                   }
[13:19:16.778]                 }, args = future.call.arguments)
[13:19:16.778]             }))
[13:19:16.778]             future::FutureResult(value = ...future.value$value, 
[13:19:16.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:16.778]                   ...future.rng), globalenv = if (FALSE) 
[13:19:16.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:16.778]                     ...future.globalenv.names))
[13:19:16.778]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:16.778]         }, condition = base::local({
[13:19:16.778]             c <- base::c
[13:19:16.778]             inherits <- base::inherits
[13:19:16.778]             invokeRestart <- base::invokeRestart
[13:19:16.778]             length <- base::length
[13:19:16.778]             list <- base::list
[13:19:16.778]             seq.int <- base::seq.int
[13:19:16.778]             signalCondition <- base::signalCondition
[13:19:16.778]             sys.calls <- base::sys.calls
[13:19:16.778]             `[[` <- base::`[[`
[13:19:16.778]             `+` <- base::`+`
[13:19:16.778]             `<<-` <- base::`<<-`
[13:19:16.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:16.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:16.778]                   3L)]
[13:19:16.778]             }
[13:19:16.778]             function(cond) {
[13:19:16.778]                 is_error <- inherits(cond, "error")
[13:19:16.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:16.778]                   NULL)
[13:19:16.778]                 if (is_error) {
[13:19:16.778]                   sessionInformation <- function() {
[13:19:16.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:16.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:16.778]                       search = base::search(), system = base::Sys.info())
[13:19:16.778]                   }
[13:19:16.778]                   ...future.conditions[[length(...future.conditions) + 
[13:19:16.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:16.778]                     cond$call), session = sessionInformation(), 
[13:19:16.778]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:16.778]                   signalCondition(cond)
[13:19:16.778]                 }
[13:19:16.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:16.778]                 "immediateCondition"))) {
[13:19:16.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:16.778]                   ...future.conditions[[length(...future.conditions) + 
[13:19:16.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:16.778]                   if (TRUE && !signal) {
[13:19:16.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:16.778]                     {
[13:19:16.778]                       inherits <- base::inherits
[13:19:16.778]                       invokeRestart <- base::invokeRestart
[13:19:16.778]                       is.null <- base::is.null
[13:19:16.778]                       muffled <- FALSE
[13:19:16.778]                       if (inherits(cond, "message")) {
[13:19:16.778]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:16.778]                         if (muffled) 
[13:19:16.778]                           invokeRestart("muffleMessage")
[13:19:16.778]                       }
[13:19:16.778]                       else if (inherits(cond, "warning")) {
[13:19:16.778]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:16.778]                         if (muffled) 
[13:19:16.778]                           invokeRestart("muffleWarning")
[13:19:16.778]                       }
[13:19:16.778]                       else if (inherits(cond, "condition")) {
[13:19:16.778]                         if (!is.null(pattern)) {
[13:19:16.778]                           computeRestarts <- base::computeRestarts
[13:19:16.778]                           grepl <- base::grepl
[13:19:16.778]                           restarts <- computeRestarts(cond)
[13:19:16.778]                           for (restart in restarts) {
[13:19:16.778]                             name <- restart$name
[13:19:16.778]                             if (is.null(name)) 
[13:19:16.778]                               next
[13:19:16.778]                             if (!grepl(pattern, name)) 
[13:19:16.778]                               next
[13:19:16.778]                             invokeRestart(restart)
[13:19:16.778]                             muffled <- TRUE
[13:19:16.778]                             break
[13:19:16.778]                           }
[13:19:16.778]                         }
[13:19:16.778]                       }
[13:19:16.778]                       invisible(muffled)
[13:19:16.778]                     }
[13:19:16.778]                     muffleCondition(cond, pattern = "^muffle")
[13:19:16.778]                   }
[13:19:16.778]                 }
[13:19:16.778]                 else {
[13:19:16.778]                   if (TRUE) {
[13:19:16.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:16.778]                     {
[13:19:16.778]                       inherits <- base::inherits
[13:19:16.778]                       invokeRestart <- base::invokeRestart
[13:19:16.778]                       is.null <- base::is.null
[13:19:16.778]                       muffled <- FALSE
[13:19:16.778]                       if (inherits(cond, "message")) {
[13:19:16.778]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:16.778]                         if (muffled) 
[13:19:16.778]                           invokeRestart("muffleMessage")
[13:19:16.778]                       }
[13:19:16.778]                       else if (inherits(cond, "warning")) {
[13:19:16.778]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:16.778]                         if (muffled) 
[13:19:16.778]                           invokeRestart("muffleWarning")
[13:19:16.778]                       }
[13:19:16.778]                       else if (inherits(cond, "condition")) {
[13:19:16.778]                         if (!is.null(pattern)) {
[13:19:16.778]                           computeRestarts <- base::computeRestarts
[13:19:16.778]                           grepl <- base::grepl
[13:19:16.778]                           restarts <- computeRestarts(cond)
[13:19:16.778]                           for (restart in restarts) {
[13:19:16.778]                             name <- restart$name
[13:19:16.778]                             if (is.null(name)) 
[13:19:16.778]                               next
[13:19:16.778]                             if (!grepl(pattern, name)) 
[13:19:16.778]                               next
[13:19:16.778]                             invokeRestart(restart)
[13:19:16.778]                             muffled <- TRUE
[13:19:16.778]                             break
[13:19:16.778]                           }
[13:19:16.778]                         }
[13:19:16.778]                       }
[13:19:16.778]                       invisible(muffled)
[13:19:16.778]                     }
[13:19:16.778]                     muffleCondition(cond, pattern = "^muffle")
[13:19:16.778]                   }
[13:19:16.778]                 }
[13:19:16.778]             }
[13:19:16.778]         }))
[13:19:16.778]     }, error = function(ex) {
[13:19:16.778]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:16.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:16.778]                 ...future.rng), started = ...future.startTime, 
[13:19:16.778]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:16.778]             version = "1.8"), class = "FutureResult")
[13:19:16.778]     }, finally = {
[13:19:16.778]         if (!identical(...future.workdir, getwd())) 
[13:19:16.778]             setwd(...future.workdir)
[13:19:16.778]         {
[13:19:16.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:16.778]                 ...future.oldOptions$nwarnings <- NULL
[13:19:16.778]             }
[13:19:16.778]             base::options(...future.oldOptions)
[13:19:16.778]             if (.Platform$OS.type == "windows") {
[13:19:16.778]                 old_names <- names(...future.oldEnvVars)
[13:19:16.778]                 envs <- base::Sys.getenv()
[13:19:16.778]                 names <- names(envs)
[13:19:16.778]                 common <- intersect(names, old_names)
[13:19:16.778]                 added <- setdiff(names, old_names)
[13:19:16.778]                 removed <- setdiff(old_names, names)
[13:19:16.778]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:16.778]                   envs[common]]
[13:19:16.778]                 NAMES <- toupper(changed)
[13:19:16.778]                 args <- list()
[13:19:16.778]                 for (kk in seq_along(NAMES)) {
[13:19:16.778]                   name <- changed[[kk]]
[13:19:16.778]                   NAME <- NAMES[[kk]]
[13:19:16.778]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.778]                     next
[13:19:16.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:16.778]                 }
[13:19:16.778]                 NAMES <- toupper(added)
[13:19:16.778]                 for (kk in seq_along(NAMES)) {
[13:19:16.778]                   name <- added[[kk]]
[13:19:16.778]                   NAME <- NAMES[[kk]]
[13:19:16.778]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.778]                     next
[13:19:16.778]                   args[[name]] <- ""
[13:19:16.778]                 }
[13:19:16.778]                 NAMES <- toupper(removed)
[13:19:16.778]                 for (kk in seq_along(NAMES)) {
[13:19:16.778]                   name <- removed[[kk]]
[13:19:16.778]                   NAME <- NAMES[[kk]]
[13:19:16.778]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:16.778]                     next
[13:19:16.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:16.778]                 }
[13:19:16.778]                 if (length(args) > 0) 
[13:19:16.778]                   base::do.call(base::Sys.setenv, args = args)
[13:19:16.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:16.778]             }
[13:19:16.778]             else {
[13:19:16.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:16.778]             }
[13:19:16.778]             {
[13:19:16.778]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:16.778]                   0L) {
[13:19:16.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:16.778]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:16.778]                   base::options(opts)
[13:19:16.778]                 }
[13:19:16.778]                 {
[13:19:16.778]                   {
[13:19:16.778]                     NULL
[13:19:16.778]                     RNGkind("Mersenne-Twister")
[13:19:16.778]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:16.778]                       inherits = FALSE)
[13:19:16.778]                   }
[13:19:16.778]                   options(future.plan = NULL)
[13:19:16.778]                   if (is.na(NA_character_)) 
[13:19:16.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:16.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:16.778]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:16.778]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:16.778]                     envir = parent.frame()) 
[13:19:16.778]                   {
[13:19:16.778]                     if (is.function(workers)) 
[13:19:16.778]                       workers <- workers()
[13:19:16.778]                     workers <- structure(as.integer(workers), 
[13:19:16.778]                       class = class(workers))
[13:19:16.778]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:16.778]                       workers >= 1)
[13:19:16.778]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:16.778]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:16.778]                     }
[13:19:16.778]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:16.778]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:16.778]                       envir = envir)
[13:19:16.778]                     if (!future$lazy) 
[13:19:16.778]                       future <- run(future)
[13:19:16.778]                     invisible(future)
[13:19:16.778]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:16.778]                 }
[13:19:16.778]             }
[13:19:16.778]         }
[13:19:16.778]     })
[13:19:16.778]     if (TRUE) {
[13:19:16.778]         base::sink(type = "output", split = FALSE)
[13:19:16.778]         if (TRUE) {
[13:19:16.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:16.778]         }
[13:19:16.778]         else {
[13:19:16.778]             ...future.result["stdout"] <- base::list(NULL)
[13:19:16.778]         }
[13:19:16.778]         base::close(...future.stdout)
[13:19:16.778]         ...future.stdout <- NULL
[13:19:16.778]     }
[13:19:16.778]     ...future.result$conditions <- ...future.conditions
[13:19:16.778]     ...future.result$finished <- base::Sys.time()
[13:19:16.778]     ...future.result
[13:19:16.778] }
[13:19:16.779] assign_globals() ...
[13:19:16.780] List of 5
[13:19:16.780]  $ ...future.FUN            :function (x)  
[13:19:16.780]  $ future.call.arguments    : list()
[13:19:16.780]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:16.780]  $ ...future.elements_ii    :List of 2
[13:19:16.780]   ..$ : int 1
[13:19:16.780]   ..$ : int 0
[13:19:16.780]  $ ...future.seeds_ii       : NULL
[13:19:16.780]  $ ...future.globals.maxSize: NULL
[13:19:16.780]  - attr(*, "resolved")= logi FALSE
[13:19:16.780]  - attr(*, "total_size")= num 4720
[13:19:16.780]  - attr(*, "where")=List of 5
[13:19:16.780]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:16.780]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:16.780]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:16.780]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:16.780]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:16.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:16.780]  - attr(*, "already-done")= logi TRUE
[13:19:16.785] - reassign environment for ‘...future.FUN’
[13:19:16.786] - copied ‘...future.FUN’ to environment
[13:19:16.786] - copied ‘future.call.arguments’ to environment
[13:19:16.786] - copied ‘...future.elements_ii’ to environment
[13:19:16.787] - copied ‘...future.seeds_ii’ to environment
[13:19:16.787] - copied ‘...future.globals.maxSize’ to environment
[13:19:16.787] assign_globals() ... done
[13:19:16.787] plan(): Setting new future strategy stack:
[13:19:16.787] List of future strategies:
[13:19:16.787] 1. sequential:
[13:19:16.787]    - args: function (..., envir = parent.frame())
[13:19:16.787]    - tweaked: FALSE
[13:19:16.787]    - call: NULL
[13:19:16.788] plan(): nbrOfWorkers() = 1
[13:19:17.289] plan(): Setting new future strategy stack:
[13:19:17.290] List of future strategies:
[13:19:17.290] 1. multisession:
[13:19:17.290]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:17.290]    - tweaked: FALSE
[13:19:17.290]    - call: plan(strategy)
[13:19:17.295] plan(): nbrOfWorkers() = 1
[13:19:17.296] SequentialFuture started (and completed)
[13:19:17.296] - Launch lazy future ... done
[13:19:17.296] run() for ‘SequentialFuture’ ... done
[13:19:17.297] Created future:
[13:19:17.297] SequentialFuture:
[13:19:17.297] Label: ‘future_lapply-1’
[13:19:17.297] Expression:
[13:19:17.297] {
[13:19:17.297]     do.call(function(...) {
[13:19:17.297]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:17.297]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:17.297]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:17.297]             on.exit(options(oopts), add = TRUE)
[13:19:17.297]         }
[13:19:17.297]         {
[13:19:17.297]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:17.297]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:17.297]                 ...future.FUN(...future.X_jj, ...)
[13:19:17.297]             })
[13:19:17.297]         }
[13:19:17.297]     }, args = future.call.arguments)
[13:19:17.297] }
[13:19:17.297] Lazy evaluation: FALSE
[13:19:17.297] Asynchronous evaluation: FALSE
[13:19:17.297] Local evaluation: TRUE
[13:19:17.297] Environment: R_GlobalEnv
[13:19:17.297] Capture standard output: TRUE
[13:19:17.297] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:17.297] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:17.297] Packages: <none>
[13:19:17.297] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:17.297] Resolved: TRUE
[13:19:17.297] Value: 112 bytes of class ‘list’
[13:19:17.297] Early signaling: FALSE
[13:19:17.297] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:17.297] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:17.299] Chunk #1 of 1 ... DONE
[13:19:17.299] Launching 1 futures (chunks) ... DONE
[13:19:17.299] Resolving 1 futures (chunks) ...
[13:19:17.299] resolve() on list ...
[13:19:17.299]  recursive: 0
[13:19:17.300]  length: 1
[13:19:17.300] 
[13:19:17.300] resolved() for ‘SequentialFuture’ ...
[13:19:17.300] - state: ‘finished’
[13:19:17.300] - run: TRUE
[13:19:17.301] - result: ‘FutureResult’
[13:19:17.301] resolved() for ‘SequentialFuture’ ... done
[13:19:17.301] Future #1
[13:19:17.301] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:17.301] - nx: 1
[13:19:17.302] - relay: TRUE
[13:19:17.302] - stdout: TRUE
[13:19:17.302] - signal: TRUE
[13:19:17.302] - resignal: FALSE
[13:19:17.302] - force: TRUE
[13:19:17.302] - relayed: [n=1] FALSE
[13:19:17.303] - queued futures: [n=1] FALSE
[13:19:17.303]  - until=1
[13:19:17.303]  - relaying element #1
[13:19:17.303] - relayed: [n=1] TRUE
[13:19:17.303] - queued futures: [n=1] TRUE
[13:19:17.304] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:17.304]  length: 0 (resolved future 1)
[13:19:17.304] Relaying remaining futures
[13:19:17.304] signalConditionsASAP(NULL, pos=0) ...
[13:19:17.304] - nx: 1
[13:19:17.305] - relay: TRUE
[13:19:17.305] - stdout: TRUE
[13:19:17.305] - signal: TRUE
[13:19:17.305] - resignal: FALSE
[13:19:17.305] - force: TRUE
[13:19:17.305] - relayed: [n=1] TRUE
[13:19:17.306] - queued futures: [n=1] TRUE
 - flush all
[13:19:17.306] - relayed: [n=1] TRUE
[13:19:17.306] - queued futures: [n=1] TRUE
[13:19:17.306] signalConditionsASAP(NULL, pos=0) ... done
[13:19:17.306] resolve() on list ... DONE
[13:19:17.307]  - Number of value chunks collected: 1
[13:19:17.307] Resolving 1 futures (chunks) ... DONE
[13:19:17.307] Reducing values from 1 chunks ...
[13:19:17.307]  - Number of values collected after concatenation: 2
[13:19:17.307]  - Number of values expected: 2
[13:19:17.307] Reducing values from 1 chunks ... DONE
[13:19:17.308] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:19:17.308] future_lapply() ...
[13:19:17.312] Number of chunks: 1
[13:19:17.312] getGlobalsAndPackagesXApply() ...
[13:19:17.312]  - future.globals: TRUE
[13:19:17.312] getGlobalsAndPackages() ...
[13:19:17.313] Searching for globals...
[13:19:17.314] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:17.314] Searching for globals ... DONE
[13:19:17.314] Resolving globals: FALSE
[13:19:17.315] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:17.315] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:17.315] - globals: [1] ‘FUN’
[13:19:17.315] 
[13:19:17.315] getGlobalsAndPackages() ... DONE
[13:19:17.316]  - globals found/used: [n=1] ‘FUN’
[13:19:17.316]  - needed namespaces: [n=0] 
[13:19:17.316] Finding globals ... DONE
[13:19:17.316]  - use_args: TRUE
[13:19:17.316]  - Getting '...' globals ...
[13:19:17.316] resolve() on list ...
[13:19:17.316]  recursive: 0
[13:19:17.316]  length: 1
[13:19:17.316]  elements: ‘...’
[13:19:17.317]  length: 0 (resolved future 1)
[13:19:17.317] resolve() on list ... DONE
[13:19:17.317]    - '...' content: [n=0] 
[13:19:17.317] List of 1
[13:19:17.317]  $ ...: list()
[13:19:17.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:17.317]  - attr(*, "where")=List of 1
[13:19:17.317]   ..$ ...:<environment: 0x56200598df60> 
[13:19:17.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:17.317]  - attr(*, "resolved")= logi TRUE
[13:19:17.317]  - attr(*, "total_size")= num NA
[13:19:17.320]  - Getting '...' globals ... DONE
[13:19:17.320] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:17.320] List of 2
[13:19:17.320]  $ ...future.FUN:function (x)  
[13:19:17.320]  $ ...          : list()
[13:19:17.320]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:17.320]  - attr(*, "where")=List of 2
[13:19:17.320]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:17.320]   ..$ ...          :<environment: 0x56200598df60> 
[13:19:17.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:17.320]  - attr(*, "resolved")= logi FALSE
[13:19:17.320]  - attr(*, "total_size")= num 4720
[13:19:17.323] Packages to be attached in all futures: [n=0] 
[13:19:17.323] getGlobalsAndPackagesXApply() ... DONE
[13:19:17.323] Number of futures (= number of chunks): 1
[13:19:17.323] Launching 1 futures (chunks) ...
[13:19:17.323] Chunk #1 of 1 ...
[13:19:17.324]  - Finding globals in 'X' for chunk #1 ...
[13:19:17.324] getGlobalsAndPackages() ...
[13:19:17.324] Searching for globals...
[13:19:17.324] 
[13:19:17.324] Searching for globals ... DONE
[13:19:17.324] - globals: [0] <none>
[13:19:17.325] getGlobalsAndPackages() ... DONE
[13:19:17.325]    + additional globals found: [n=0] 
[13:19:17.325]    + additional namespaces needed: [n=0] 
[13:19:17.325]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:17.325]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:17.325]  - seeds: <none>
[13:19:17.325] getGlobalsAndPackages() ...
[13:19:17.325] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:17.326] Resolving globals: FALSE
[13:19:17.328] Tweak future expression to call with '...' arguments ...
[13:19:17.328] {
[13:19:17.328]     do.call(function(...) {
[13:19:17.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:17.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:17.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:17.328]             on.exit(options(oopts), add = TRUE)
[13:19:17.328]         }
[13:19:17.328]         {
[13:19:17.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:17.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:17.328]                 ...future.FUN(...future.X_jj, ...)
[13:19:17.328]             })
[13:19:17.328]         }
[13:19:17.328]     }, args = future.call.arguments)
[13:19:17.328] }
[13:19:17.328] Tweak future expression to call with '...' arguments ... DONE
[13:19:17.329] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:17.329] 
[13:19:17.329] getGlobalsAndPackages() ... DONE
[13:19:17.329] run() for ‘Future’ ...
[13:19:17.329] - state: ‘created’
[13:19:17.330] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:17.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:17.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:17.334]   - Field: ‘label’
[13:19:17.334]   - Field: ‘local’
[13:19:17.334]   - Field: ‘owner’
[13:19:17.334]   - Field: ‘envir’
[13:19:17.334]   - Field: ‘packages’
[13:19:17.334]   - Field: ‘gc’
[13:19:17.335]   - Field: ‘conditions’
[13:19:17.335]   - Field: ‘expr’
[13:19:17.335]   - Field: ‘uuid’
[13:19:17.335]   - Field: ‘seed’
[13:19:17.335]   - Field: ‘version’
[13:19:17.335]   - Field: ‘result’
[13:19:17.335]   - Field: ‘asynchronous’
[13:19:17.335]   - Field: ‘calls’
[13:19:17.336]   - Field: ‘globals’
[13:19:17.336]   - Field: ‘stdout’
[13:19:17.336]   - Field: ‘earlySignal’
[13:19:17.336]   - Field: ‘lazy’
[13:19:17.336]   - Field: ‘state’
[13:19:17.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:17.336] - Launch lazy future ...
[13:19:17.337] Packages needed by the future expression (n = 0): <none>
[13:19:17.337] Packages needed by future strategies (n = 0): <none>
[13:19:17.337] {
[13:19:17.337]     {
[13:19:17.337]         {
[13:19:17.337]             ...future.startTime <- base::Sys.time()
[13:19:17.337]             {
[13:19:17.337]                 {
[13:19:17.337]                   {
[13:19:17.337]                     base::local({
[13:19:17.337]                       has_future <- base::requireNamespace("future", 
[13:19:17.337]                         quietly = TRUE)
[13:19:17.337]                       if (has_future) {
[13:19:17.337]                         ns <- base::getNamespace("future")
[13:19:17.337]                         version <- ns[[".package"]][["version"]]
[13:19:17.337]                         if (is.null(version)) 
[13:19:17.337]                           version <- utils::packageVersion("future")
[13:19:17.337]                       }
[13:19:17.337]                       else {
[13:19:17.337]                         version <- NULL
[13:19:17.337]                       }
[13:19:17.337]                       if (!has_future || version < "1.8.0") {
[13:19:17.337]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:17.337]                           "", base::R.version$version.string), 
[13:19:17.337]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:17.337]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:17.337]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:17.337]                             "release", "version")], collapse = " "), 
[13:19:17.337]                           hostname = base::Sys.info()[["nodename"]])
[13:19:17.337]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:17.337]                           info)
[13:19:17.337]                         info <- base::paste(info, collapse = "; ")
[13:19:17.337]                         if (!has_future) {
[13:19:17.337]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:17.337]                             info)
[13:19:17.337]                         }
[13:19:17.337]                         else {
[13:19:17.337]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:17.337]                             info, version)
[13:19:17.337]                         }
[13:19:17.337]                         base::stop(msg)
[13:19:17.337]                       }
[13:19:17.337]                     })
[13:19:17.337]                   }
[13:19:17.337]                   options(future.plan = NULL)
[13:19:17.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:17.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:17.337]                 }
[13:19:17.337]                 ...future.workdir <- getwd()
[13:19:17.337]             }
[13:19:17.337]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:17.337]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:17.337]         }
[13:19:17.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:17.337]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:17.337]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:17.337]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:17.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:17.337]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:17.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:17.337]             base::names(...future.oldOptions))
[13:19:17.337]     }
[13:19:17.337]     if (TRUE) {
[13:19:17.337]     }
[13:19:17.337]     else {
[13:19:17.337]         if (NA) {
[13:19:17.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:17.337]                 open = "w")
[13:19:17.337]         }
[13:19:17.337]         else {
[13:19:17.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:17.337]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:17.337]         }
[13:19:17.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:17.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:17.337]             base::sink(type = "output", split = FALSE)
[13:19:17.337]             base::close(...future.stdout)
[13:19:17.337]         }, add = TRUE)
[13:19:17.337]     }
[13:19:17.337]     ...future.frame <- base::sys.nframe()
[13:19:17.337]     ...future.conditions <- base::list()
[13:19:17.337]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:17.337]     if (FALSE) {
[13:19:17.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:17.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:17.337]     }
[13:19:17.337]     ...future.result <- base::tryCatch({
[13:19:17.337]         base::withCallingHandlers({
[13:19:17.337]             ...future.value <- base::withVisible(base::local({
[13:19:17.337]                 do.call(function(...) {
[13:19:17.337]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:17.337]                   if (!identical(...future.globals.maxSize.org, 
[13:19:17.337]                     ...future.globals.maxSize)) {
[13:19:17.337]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:17.337]                     on.exit(options(oopts), add = TRUE)
[13:19:17.337]                   }
[13:19:17.337]                   {
[13:19:17.337]                     lapply(seq_along(...future.elements_ii), 
[13:19:17.337]                       FUN = function(jj) {
[13:19:17.337]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:17.337]                         ...future.FUN(...future.X_jj, ...)
[13:19:17.337]                       })
[13:19:17.337]                   }
[13:19:17.337]                 }, args = future.call.arguments)
[13:19:17.337]             }))
[13:19:17.337]             future::FutureResult(value = ...future.value$value, 
[13:19:17.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:17.337]                   ...future.rng), globalenv = if (FALSE) 
[13:19:17.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:17.337]                     ...future.globalenv.names))
[13:19:17.337]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:17.337]         }, condition = base::local({
[13:19:17.337]             c <- base::c
[13:19:17.337]             inherits <- base::inherits
[13:19:17.337]             invokeRestart <- base::invokeRestart
[13:19:17.337]             length <- base::length
[13:19:17.337]             list <- base::list
[13:19:17.337]             seq.int <- base::seq.int
[13:19:17.337]             signalCondition <- base::signalCondition
[13:19:17.337]             sys.calls <- base::sys.calls
[13:19:17.337]             `[[` <- base::`[[`
[13:19:17.337]             `+` <- base::`+`
[13:19:17.337]             `<<-` <- base::`<<-`
[13:19:17.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:17.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:17.337]                   3L)]
[13:19:17.337]             }
[13:19:17.337]             function(cond) {
[13:19:17.337]                 is_error <- inherits(cond, "error")
[13:19:17.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:17.337]                   NULL)
[13:19:17.337]                 if (is_error) {
[13:19:17.337]                   sessionInformation <- function() {
[13:19:17.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:17.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:17.337]                       search = base::search(), system = base::Sys.info())
[13:19:17.337]                   }
[13:19:17.337]                   ...future.conditions[[length(...future.conditions) + 
[13:19:17.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:17.337]                     cond$call), session = sessionInformation(), 
[13:19:17.337]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:17.337]                   signalCondition(cond)
[13:19:17.337]                 }
[13:19:17.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:17.337]                 "immediateCondition"))) {
[13:19:17.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:17.337]                   ...future.conditions[[length(...future.conditions) + 
[13:19:17.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:17.337]                   if (TRUE && !signal) {
[13:19:17.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:17.337]                     {
[13:19:17.337]                       inherits <- base::inherits
[13:19:17.337]                       invokeRestart <- base::invokeRestart
[13:19:17.337]                       is.null <- base::is.null
[13:19:17.337]                       muffled <- FALSE
[13:19:17.337]                       if (inherits(cond, "message")) {
[13:19:17.337]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:17.337]                         if (muffled) 
[13:19:17.337]                           invokeRestart("muffleMessage")
[13:19:17.337]                       }
[13:19:17.337]                       else if (inherits(cond, "warning")) {
[13:19:17.337]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:17.337]                         if (muffled) 
[13:19:17.337]                           invokeRestart("muffleWarning")
[13:19:17.337]                       }
[13:19:17.337]                       else if (inherits(cond, "condition")) {
[13:19:17.337]                         if (!is.null(pattern)) {
[13:19:17.337]                           computeRestarts <- base::computeRestarts
[13:19:17.337]                           grepl <- base::grepl
[13:19:17.337]                           restarts <- computeRestarts(cond)
[13:19:17.337]                           for (restart in restarts) {
[13:19:17.337]                             name <- restart$name
[13:19:17.337]                             if (is.null(name)) 
[13:19:17.337]                               next
[13:19:17.337]                             if (!grepl(pattern, name)) 
[13:19:17.337]                               next
[13:19:17.337]                             invokeRestart(restart)
[13:19:17.337]                             muffled <- TRUE
[13:19:17.337]                             break
[13:19:17.337]                           }
[13:19:17.337]                         }
[13:19:17.337]                       }
[13:19:17.337]                       invisible(muffled)
[13:19:17.337]                     }
[13:19:17.337]                     muffleCondition(cond, pattern = "^muffle")
[13:19:17.337]                   }
[13:19:17.337]                 }
[13:19:17.337]                 else {
[13:19:17.337]                   if (TRUE) {
[13:19:17.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:17.337]                     {
[13:19:17.337]                       inherits <- base::inherits
[13:19:17.337]                       invokeRestart <- base::invokeRestart
[13:19:17.337]                       is.null <- base::is.null
[13:19:17.337]                       muffled <- FALSE
[13:19:17.337]                       if (inherits(cond, "message")) {
[13:19:17.337]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:17.337]                         if (muffled) 
[13:19:17.337]                           invokeRestart("muffleMessage")
[13:19:17.337]                       }
[13:19:17.337]                       else if (inherits(cond, "warning")) {
[13:19:17.337]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:17.337]                         if (muffled) 
[13:19:17.337]                           invokeRestart("muffleWarning")
[13:19:17.337]                       }
[13:19:17.337]                       else if (inherits(cond, "condition")) {
[13:19:17.337]                         if (!is.null(pattern)) {
[13:19:17.337]                           computeRestarts <- base::computeRestarts
[13:19:17.337]                           grepl <- base::grepl
[13:19:17.337]                           restarts <- computeRestarts(cond)
[13:19:17.337]                           for (restart in restarts) {
[13:19:17.337]                             name <- restart$name
[13:19:17.337]                             if (is.null(name)) 
[13:19:17.337]                               next
[13:19:17.337]                             if (!grepl(pattern, name)) 
[13:19:17.337]                               next
[13:19:17.337]                             invokeRestart(restart)
[13:19:17.337]                             muffled <- TRUE
[13:19:17.337]                             break
[13:19:17.337]                           }
[13:19:17.337]                         }
[13:19:17.337]                       }
[13:19:17.337]                       invisible(muffled)
[13:19:17.337]                     }
[13:19:17.337]                     muffleCondition(cond, pattern = "^muffle")
[13:19:17.337]                   }
[13:19:17.337]                 }
[13:19:17.337]             }
[13:19:17.337]         }))
[13:19:17.337]     }, error = function(ex) {
[13:19:17.337]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:17.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:17.337]                 ...future.rng), started = ...future.startTime, 
[13:19:17.337]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:17.337]             version = "1.8"), class = "FutureResult")
[13:19:17.337]     }, finally = {
[13:19:17.337]         if (!identical(...future.workdir, getwd())) 
[13:19:17.337]             setwd(...future.workdir)
[13:19:17.337]         {
[13:19:17.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:17.337]                 ...future.oldOptions$nwarnings <- NULL
[13:19:17.337]             }
[13:19:17.337]             base::options(...future.oldOptions)
[13:19:17.337]             if (.Platform$OS.type == "windows") {
[13:19:17.337]                 old_names <- names(...future.oldEnvVars)
[13:19:17.337]                 envs <- base::Sys.getenv()
[13:19:17.337]                 names <- names(envs)
[13:19:17.337]                 common <- intersect(names, old_names)
[13:19:17.337]                 added <- setdiff(names, old_names)
[13:19:17.337]                 removed <- setdiff(old_names, names)
[13:19:17.337]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:17.337]                   envs[common]]
[13:19:17.337]                 NAMES <- toupper(changed)
[13:19:17.337]                 args <- list()
[13:19:17.337]                 for (kk in seq_along(NAMES)) {
[13:19:17.337]                   name <- changed[[kk]]
[13:19:17.337]                   NAME <- NAMES[[kk]]
[13:19:17.337]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:17.337]                     next
[13:19:17.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:17.337]                 }
[13:19:17.337]                 NAMES <- toupper(added)
[13:19:17.337]                 for (kk in seq_along(NAMES)) {
[13:19:17.337]                   name <- added[[kk]]
[13:19:17.337]                   NAME <- NAMES[[kk]]
[13:19:17.337]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:17.337]                     next
[13:19:17.337]                   args[[name]] <- ""
[13:19:17.337]                 }
[13:19:17.337]                 NAMES <- toupper(removed)
[13:19:17.337]                 for (kk in seq_along(NAMES)) {
[13:19:17.337]                   name <- removed[[kk]]
[13:19:17.337]                   NAME <- NAMES[[kk]]
[13:19:17.337]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:17.337]                     next
[13:19:17.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:17.337]                 }
[13:19:17.337]                 if (length(args) > 0) 
[13:19:17.337]                   base::do.call(base::Sys.setenv, args = args)
[13:19:17.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:17.337]             }
[13:19:17.337]             else {
[13:19:17.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:17.337]             }
[13:19:17.337]             {
[13:19:17.337]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:17.337]                   0L) {
[13:19:17.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:17.337]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:17.337]                   base::options(opts)
[13:19:17.337]                 }
[13:19:17.337]                 {
[13:19:17.337]                   {
[13:19:17.337]                     NULL
[13:19:17.337]                     RNGkind("Mersenne-Twister")
[13:19:17.337]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:17.337]                       inherits = FALSE)
[13:19:17.337]                   }
[13:19:17.337]                   options(future.plan = NULL)
[13:19:17.337]                   if (is.na(NA_character_)) 
[13:19:17.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:17.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:17.337]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:17.337]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:17.337]                     envir = parent.frame()) 
[13:19:17.337]                   {
[13:19:17.337]                     if (is.function(workers)) 
[13:19:17.337]                       workers <- workers()
[13:19:17.337]                     workers <- structure(as.integer(workers), 
[13:19:17.337]                       class = class(workers))
[13:19:17.337]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:17.337]                       workers >= 1)
[13:19:17.337]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:17.337]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:17.337]                     }
[13:19:17.337]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:17.337]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:17.337]                       envir = envir)
[13:19:17.337]                     if (!future$lazy) 
[13:19:17.337]                       future <- run(future)
[13:19:17.337]                     invisible(future)
[13:19:17.337]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:17.337]                 }
[13:19:17.337]             }
[13:19:17.337]         }
[13:19:17.337]     })
[13:19:17.337]     if (FALSE) {
[13:19:17.337]         base::sink(type = "output", split = FALSE)
[13:19:17.337]         if (NA) {
[13:19:17.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:17.337]         }
[13:19:17.337]         else {
[13:19:17.337]             ...future.result["stdout"] <- base::list(NULL)
[13:19:17.337]         }
[13:19:17.337]         base::close(...future.stdout)
[13:19:17.337]         ...future.stdout <- NULL
[13:19:17.337]     }
[13:19:17.337]     ...future.result$conditions <- ...future.conditions
[13:19:17.337]     ...future.result$finished <- base::Sys.time()
[13:19:17.337]     ...future.result
[13:19:17.337] }
[13:19:17.340] assign_globals() ...
[13:19:17.340] List of 5
[13:19:17.340]  $ ...future.FUN            :function (x)  
[13:19:17.340]  $ future.call.arguments    : list()
[13:19:17.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:17.340]  $ ...future.elements_ii    :List of 2
[13:19:17.340]   ..$ : int 1
[13:19:17.340]   ..$ : int 0
[13:19:17.340]  $ ...future.seeds_ii       : NULL
[13:19:17.340]  $ ...future.globals.maxSize: NULL
[13:19:17.340]  - attr(*, "resolved")= logi FALSE
[13:19:17.340]  - attr(*, "total_size")= num 4720
[13:19:17.340]  - attr(*, "where")=List of 5
[13:19:17.340]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:17.340]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:17.340]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:17.340]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:17.340]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:17.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:17.340]  - attr(*, "already-done")= logi TRUE
[13:19:17.346] - reassign environment for ‘...future.FUN’
[13:19:17.347] - copied ‘...future.FUN’ to environment
[13:19:17.347] - copied ‘future.call.arguments’ to environment
[13:19:17.347] - copied ‘...future.elements_ii’ to environment
[13:19:17.347] - copied ‘...future.seeds_ii’ to environment
[13:19:17.347] - copied ‘...future.globals.maxSize’ to environment
[13:19:17.347] assign_globals() ... done
[13:19:17.347] plan(): Setting new future strategy stack:
[13:19:17.347] List of future strategies:
[13:19:17.347] 1. sequential:
[13:19:17.347]    - args: function (..., envir = parent.frame())
[13:19:17.347]    - tweaked: FALSE
[13:19:17.347]    - call: NULL
[13:19:17.348] plan(): nbrOfWorkers() = 1
[13:19:17.849] plan(): Setting new future strategy stack:
[13:19:17.850] List of future strategies:
[13:19:17.850] 1. multisession:
[13:19:17.850]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:17.850]    - tweaked: FALSE
[13:19:17.850]    - call: plan(strategy)
[13:19:17.854] plan(): nbrOfWorkers() = 1
[13:19:17.854] SequentialFuture started (and completed)
[13:19:17.854] - Launch lazy future ... done
[13:19:17.854] run() for ‘SequentialFuture’ ... done
[13:19:17.854] Created future:
[13:19:17.854] SequentialFuture:
[13:19:17.854] Label: ‘future_lapply-1’
[13:19:17.854] Expression:
[13:19:17.854] {
[13:19:17.854]     do.call(function(...) {
[13:19:17.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:17.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:17.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:17.854]             on.exit(options(oopts), add = TRUE)
[13:19:17.854]         }
[13:19:17.854]         {
[13:19:17.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:17.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:17.854]                 ...future.FUN(...future.X_jj, ...)
[13:19:17.854]             })
[13:19:17.854]         }
[13:19:17.854]     }, args = future.call.arguments)
[13:19:17.854] }
[13:19:17.854] Lazy evaluation: FALSE
[13:19:17.854] Asynchronous evaluation: FALSE
[13:19:17.854] Local evaluation: TRUE
[13:19:17.854] Environment: R_GlobalEnv
[13:19:17.854] Capture standard output: NA
[13:19:17.854] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:17.854] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:17.854] Packages: <none>
[13:19:17.854] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:17.854] Resolved: TRUE
[13:19:17.854] Value: 112 bytes of class ‘list’
[13:19:17.854] Early signaling: FALSE
[13:19:17.854] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:17.854] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:17.855] Chunk #1 of 1 ... DONE
[13:19:17.855] Launching 1 futures (chunks) ... DONE
[13:19:17.855] Resolving 1 futures (chunks) ...
[13:19:17.856] resolve() on list ...
[13:19:17.856]  recursive: 0
[13:19:17.856]  length: 1
[13:19:17.856] 
[13:19:17.856] resolved() for ‘SequentialFuture’ ...
[13:19:17.856] - state: ‘finished’
[13:19:17.856] - run: TRUE
[13:19:17.856] - result: ‘FutureResult’
[13:19:17.856] resolved() for ‘SequentialFuture’ ... done
[13:19:17.856] Future #1
[13:19:17.857] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:17.857] - nx: 1
[13:19:17.857] - relay: TRUE
[13:19:17.857] - stdout: TRUE
[13:19:17.857] - signal: TRUE
[13:19:17.857] - resignal: FALSE
[13:19:17.857] - force: TRUE
[13:19:17.857] - relayed: [n=1] FALSE
[13:19:17.857] - queued futures: [n=1] FALSE
[13:19:17.858]  - until=1
[13:19:17.858]  - relaying element #1
[13:19:17.858] - relayed: [n=1] TRUE
[13:19:17.858] - queued futures: [n=1] TRUE
[13:19:17.858] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:17.858]  length: 0 (resolved future 1)
[13:19:17.858] Relaying remaining futures
[13:19:17.858] signalConditionsASAP(NULL, pos=0) ...
[13:19:17.858] - nx: 1
[13:19:17.858] - relay: TRUE
[13:19:17.858] - stdout: TRUE
[13:19:17.859] - signal: TRUE
[13:19:17.859] - resignal: FALSE
[13:19:17.859] - force: TRUE
[13:19:17.859] - relayed: [n=1] TRUE
[13:19:17.859] - queued futures: [n=1] TRUE
 - flush all
[13:19:17.859] - relayed: [n=1] TRUE
[13:19:17.859] - queued futures: [n=1] TRUE
[13:19:17.859] signalConditionsASAP(NULL, pos=0) ... done
[13:19:17.859] resolve() on list ... DONE
[13:19:17.859]  - Number of value chunks collected: 1
[13:19:17.860] Resolving 1 futures (chunks) ... DONE
[13:19:17.860] Reducing values from 1 chunks ...
[13:19:17.860]  - Number of values collected after concatenation: 2
[13:19:17.860]  - Number of values expected: 2
[13:19:17.860] Reducing values from 1 chunks ... DONE
[13:19:17.860] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:19:17.860] future_mapply() ...
[13:19:17.864] Number of chunks: 1
[13:19:17.864] getGlobalsAndPackagesXApply() ...
[13:19:17.864]  - future.globals: TRUE
[13:19:17.864] getGlobalsAndPackages() ...
[13:19:17.864] Searching for globals...
[13:19:17.867] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:17.868] Searching for globals ... DONE
[13:19:17.868] Resolving globals: FALSE
[13:19:17.868] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:17.869] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:17.869] - globals: [1] ‘FUN’
[13:19:17.869] 
[13:19:17.869] getGlobalsAndPackages() ... DONE
[13:19:17.869]  - globals found/used: [n=1] ‘FUN’
[13:19:17.869]  - needed namespaces: [n=0] 
[13:19:17.870] Finding globals ... DONE
[13:19:17.870] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:17.870] List of 2
[13:19:17.870]  $ ...future.FUN:function (x, y)  
[13:19:17.870]  $ MoreArgs     : NULL
[13:19:17.870]  - attr(*, "where")=List of 2
[13:19:17.870]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:17.870]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:17.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:17.870]  - attr(*, "resolved")= logi FALSE
[13:19:17.870]  - attr(*, "total_size")= num NA
[13:19:17.873] Packages to be attached in all futures: [n=0] 
[13:19:17.873] getGlobalsAndPackagesXApply() ... DONE
[13:19:17.873] Number of futures (= number of chunks): 1
[13:19:17.873] Launching 1 futures (chunks) ...
[13:19:17.873] Chunk #1 of 1 ...
[13:19:17.873]  - Finding globals in '...' for chunk #1 ...
[13:19:17.873] getGlobalsAndPackages() ...
[13:19:17.873] Searching for globals...
[13:19:17.874] 
[13:19:17.874] Searching for globals ... DONE
[13:19:17.874] - globals: [0] <none>
[13:19:17.874] getGlobalsAndPackages() ... DONE
[13:19:17.874]    + additional globals found: [n=0] 
[13:19:17.874]    + additional namespaces needed: [n=0] 
[13:19:17.874]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:17.874]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:17.875]  - seeds: <none>
[13:19:17.875] getGlobalsAndPackages() ...
[13:19:17.875] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:17.875] Resolving globals: FALSE
[13:19:17.875] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:17.876] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:17.876] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:17.876] 
[13:19:17.876] getGlobalsAndPackages() ... DONE
[13:19:17.876] run() for ‘Future’ ...
[13:19:17.877] - state: ‘created’
[13:19:17.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:17.880] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:17.880] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:17.880]   - Field: ‘label’
[13:19:17.881]   - Field: ‘local’
[13:19:17.881]   - Field: ‘owner’
[13:19:17.881]   - Field: ‘envir’
[13:19:17.881]   - Field: ‘packages’
[13:19:17.881]   - Field: ‘gc’
[13:19:17.881]   - Field: ‘conditions’
[13:19:17.881]   - Field: ‘expr’
[13:19:17.881]   - Field: ‘uuid’
[13:19:17.881]   - Field: ‘seed’
[13:19:17.881]   - Field: ‘version’
[13:19:17.882]   - Field: ‘result’
[13:19:17.882]   - Field: ‘asynchronous’
[13:19:17.882]   - Field: ‘calls’
[13:19:17.882]   - Field: ‘globals’
[13:19:17.882]   - Field: ‘stdout’
[13:19:17.882]   - Field: ‘earlySignal’
[13:19:17.882]   - Field: ‘lazy’
[13:19:17.882]   - Field: ‘state’
[13:19:17.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:17.882] - Launch lazy future ...
[13:19:17.883] Packages needed by the future expression (n = 0): <none>
[13:19:17.883] Packages needed by future strategies (n = 0): <none>
[13:19:17.883] {
[13:19:17.883]     {
[13:19:17.883]         {
[13:19:17.883]             ...future.startTime <- base::Sys.time()
[13:19:17.883]             {
[13:19:17.883]                 {
[13:19:17.883]                   {
[13:19:17.883]                     base::local({
[13:19:17.883]                       has_future <- base::requireNamespace("future", 
[13:19:17.883]                         quietly = TRUE)
[13:19:17.883]                       if (has_future) {
[13:19:17.883]                         ns <- base::getNamespace("future")
[13:19:17.883]                         version <- ns[[".package"]][["version"]]
[13:19:17.883]                         if (is.null(version)) 
[13:19:17.883]                           version <- utils::packageVersion("future")
[13:19:17.883]                       }
[13:19:17.883]                       else {
[13:19:17.883]                         version <- NULL
[13:19:17.883]                       }
[13:19:17.883]                       if (!has_future || version < "1.8.0") {
[13:19:17.883]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:17.883]                           "", base::R.version$version.string), 
[13:19:17.883]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:17.883]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:17.883]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:17.883]                             "release", "version")], collapse = " "), 
[13:19:17.883]                           hostname = base::Sys.info()[["nodename"]])
[13:19:17.883]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:17.883]                           info)
[13:19:17.883]                         info <- base::paste(info, collapse = "; ")
[13:19:17.883]                         if (!has_future) {
[13:19:17.883]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:17.883]                             info)
[13:19:17.883]                         }
[13:19:17.883]                         else {
[13:19:17.883]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:17.883]                             info, version)
[13:19:17.883]                         }
[13:19:17.883]                         base::stop(msg)
[13:19:17.883]                       }
[13:19:17.883]                     })
[13:19:17.883]                   }
[13:19:17.883]                   options(future.plan = NULL)
[13:19:17.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:17.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:17.883]                 }
[13:19:17.883]                 ...future.workdir <- getwd()
[13:19:17.883]             }
[13:19:17.883]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:17.883]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:17.883]         }
[13:19:17.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:17.883]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:17.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:17.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:17.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:17.883]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:17.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:17.883]             base::names(...future.oldOptions))
[13:19:17.883]     }
[13:19:17.883]     if (FALSE) {
[13:19:17.883]     }
[13:19:17.883]     else {
[13:19:17.883]         if (FALSE) {
[13:19:17.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:17.883]                 open = "w")
[13:19:17.883]         }
[13:19:17.883]         else {
[13:19:17.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:17.883]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:17.883]         }
[13:19:17.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:17.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:17.883]             base::sink(type = "output", split = FALSE)
[13:19:17.883]             base::close(...future.stdout)
[13:19:17.883]         }, add = TRUE)
[13:19:17.883]     }
[13:19:17.883]     ...future.frame <- base::sys.nframe()
[13:19:17.883]     ...future.conditions <- base::list()
[13:19:17.883]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:17.883]     if (FALSE) {
[13:19:17.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:17.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:17.883]     }
[13:19:17.883]     ...future.result <- base::tryCatch({
[13:19:17.883]         base::withCallingHandlers({
[13:19:17.883]             ...future.value <- base::withVisible(base::local({
[13:19:17.883]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:17.883]                 if (!identical(...future.globals.maxSize.org, 
[13:19:17.883]                   ...future.globals.maxSize)) {
[13:19:17.883]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:17.883]                   on.exit(options(oopts), add = TRUE)
[13:19:17.883]                 }
[13:19:17.883]                 {
[13:19:17.883]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:17.883]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:17.883]                     USE.NAMES = FALSE)
[13:19:17.883]                   do.call(mapply, args = args)
[13:19:17.883]                 }
[13:19:17.883]             }))
[13:19:17.883]             future::FutureResult(value = ...future.value$value, 
[13:19:17.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:17.883]                   ...future.rng), globalenv = if (FALSE) 
[13:19:17.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:17.883]                     ...future.globalenv.names))
[13:19:17.883]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:17.883]         }, condition = base::local({
[13:19:17.883]             c <- base::c
[13:19:17.883]             inherits <- base::inherits
[13:19:17.883]             invokeRestart <- base::invokeRestart
[13:19:17.883]             length <- base::length
[13:19:17.883]             list <- base::list
[13:19:17.883]             seq.int <- base::seq.int
[13:19:17.883]             signalCondition <- base::signalCondition
[13:19:17.883]             sys.calls <- base::sys.calls
[13:19:17.883]             `[[` <- base::`[[`
[13:19:17.883]             `+` <- base::`+`
[13:19:17.883]             `<<-` <- base::`<<-`
[13:19:17.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:17.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:17.883]                   3L)]
[13:19:17.883]             }
[13:19:17.883]             function(cond) {
[13:19:17.883]                 is_error <- inherits(cond, "error")
[13:19:17.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:17.883]                   NULL)
[13:19:17.883]                 if (is_error) {
[13:19:17.883]                   sessionInformation <- function() {
[13:19:17.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:17.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:17.883]                       search = base::search(), system = base::Sys.info())
[13:19:17.883]                   }
[13:19:17.883]                   ...future.conditions[[length(...future.conditions) + 
[13:19:17.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:17.883]                     cond$call), session = sessionInformation(), 
[13:19:17.883]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:17.883]                   signalCondition(cond)
[13:19:17.883]                 }
[13:19:17.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:17.883]                 "immediateCondition"))) {
[13:19:17.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:17.883]                   ...future.conditions[[length(...future.conditions) + 
[13:19:17.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:17.883]                   if (TRUE && !signal) {
[13:19:17.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:17.883]                     {
[13:19:17.883]                       inherits <- base::inherits
[13:19:17.883]                       invokeRestart <- base::invokeRestart
[13:19:17.883]                       is.null <- base::is.null
[13:19:17.883]                       muffled <- FALSE
[13:19:17.883]                       if (inherits(cond, "message")) {
[13:19:17.883]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:17.883]                         if (muffled) 
[13:19:17.883]                           invokeRestart("muffleMessage")
[13:19:17.883]                       }
[13:19:17.883]                       else if (inherits(cond, "warning")) {
[13:19:17.883]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:17.883]                         if (muffled) 
[13:19:17.883]                           invokeRestart("muffleWarning")
[13:19:17.883]                       }
[13:19:17.883]                       else if (inherits(cond, "condition")) {
[13:19:17.883]                         if (!is.null(pattern)) {
[13:19:17.883]                           computeRestarts <- base::computeRestarts
[13:19:17.883]                           grepl <- base::grepl
[13:19:17.883]                           restarts <- computeRestarts(cond)
[13:19:17.883]                           for (restart in restarts) {
[13:19:17.883]                             name <- restart$name
[13:19:17.883]                             if (is.null(name)) 
[13:19:17.883]                               next
[13:19:17.883]                             if (!grepl(pattern, name)) 
[13:19:17.883]                               next
[13:19:17.883]                             invokeRestart(restart)
[13:19:17.883]                             muffled <- TRUE
[13:19:17.883]                             break
[13:19:17.883]                           }
[13:19:17.883]                         }
[13:19:17.883]                       }
[13:19:17.883]                       invisible(muffled)
[13:19:17.883]                     }
[13:19:17.883]                     muffleCondition(cond, pattern = "^muffle")
[13:19:17.883]                   }
[13:19:17.883]                 }
[13:19:17.883]                 else {
[13:19:17.883]                   if (TRUE) {
[13:19:17.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:17.883]                     {
[13:19:17.883]                       inherits <- base::inherits
[13:19:17.883]                       invokeRestart <- base::invokeRestart
[13:19:17.883]                       is.null <- base::is.null
[13:19:17.883]                       muffled <- FALSE
[13:19:17.883]                       if (inherits(cond, "message")) {
[13:19:17.883]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:17.883]                         if (muffled) 
[13:19:17.883]                           invokeRestart("muffleMessage")
[13:19:17.883]                       }
[13:19:17.883]                       else if (inherits(cond, "warning")) {
[13:19:17.883]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:17.883]                         if (muffled) 
[13:19:17.883]                           invokeRestart("muffleWarning")
[13:19:17.883]                       }
[13:19:17.883]                       else if (inherits(cond, "condition")) {
[13:19:17.883]                         if (!is.null(pattern)) {
[13:19:17.883]                           computeRestarts <- base::computeRestarts
[13:19:17.883]                           grepl <- base::grepl
[13:19:17.883]                           restarts <- computeRestarts(cond)
[13:19:17.883]                           for (restart in restarts) {
[13:19:17.883]                             name <- restart$name
[13:19:17.883]                             if (is.null(name)) 
[13:19:17.883]                               next
[13:19:17.883]                             if (!grepl(pattern, name)) 
[13:19:17.883]                               next
[13:19:17.883]                             invokeRestart(restart)
[13:19:17.883]                             muffled <- TRUE
[13:19:17.883]                             break
[13:19:17.883]                           }
[13:19:17.883]                         }
[13:19:17.883]                       }
[13:19:17.883]                       invisible(muffled)
[13:19:17.883]                     }
[13:19:17.883]                     muffleCondition(cond, pattern = "^muffle")
[13:19:17.883]                   }
[13:19:17.883]                 }
[13:19:17.883]             }
[13:19:17.883]         }))
[13:19:17.883]     }, error = function(ex) {
[13:19:17.883]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:17.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:17.883]                 ...future.rng), started = ...future.startTime, 
[13:19:17.883]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:17.883]             version = "1.8"), class = "FutureResult")
[13:19:17.883]     }, finally = {
[13:19:17.883]         if (!identical(...future.workdir, getwd())) 
[13:19:17.883]             setwd(...future.workdir)
[13:19:17.883]         {
[13:19:17.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:17.883]                 ...future.oldOptions$nwarnings <- NULL
[13:19:17.883]             }
[13:19:17.883]             base::options(...future.oldOptions)
[13:19:17.883]             if (.Platform$OS.type == "windows") {
[13:19:17.883]                 old_names <- names(...future.oldEnvVars)
[13:19:17.883]                 envs <- base::Sys.getenv()
[13:19:17.883]                 names <- names(envs)
[13:19:17.883]                 common <- intersect(names, old_names)
[13:19:17.883]                 added <- setdiff(names, old_names)
[13:19:17.883]                 removed <- setdiff(old_names, names)
[13:19:17.883]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:17.883]                   envs[common]]
[13:19:17.883]                 NAMES <- toupper(changed)
[13:19:17.883]                 args <- list()
[13:19:17.883]                 for (kk in seq_along(NAMES)) {
[13:19:17.883]                   name <- changed[[kk]]
[13:19:17.883]                   NAME <- NAMES[[kk]]
[13:19:17.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:17.883]                     next
[13:19:17.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:17.883]                 }
[13:19:17.883]                 NAMES <- toupper(added)
[13:19:17.883]                 for (kk in seq_along(NAMES)) {
[13:19:17.883]                   name <- added[[kk]]
[13:19:17.883]                   NAME <- NAMES[[kk]]
[13:19:17.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:17.883]                     next
[13:19:17.883]                   args[[name]] <- ""
[13:19:17.883]                 }
[13:19:17.883]                 NAMES <- toupper(removed)
[13:19:17.883]                 for (kk in seq_along(NAMES)) {
[13:19:17.883]                   name <- removed[[kk]]
[13:19:17.883]                   NAME <- NAMES[[kk]]
[13:19:17.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:17.883]                     next
[13:19:17.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:17.883]                 }
[13:19:17.883]                 if (length(args) > 0) 
[13:19:17.883]                   base::do.call(base::Sys.setenv, args = args)
[13:19:17.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:17.883]             }
[13:19:17.883]             else {
[13:19:17.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:17.883]             }
[13:19:17.883]             {
[13:19:17.883]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:17.883]                   0L) {
[13:19:17.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:17.883]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:17.883]                   base::options(opts)
[13:19:17.883]                 }
[13:19:17.883]                 {
[13:19:17.883]                   {
[13:19:17.883]                     NULL
[13:19:17.883]                     RNGkind("Mersenne-Twister")
[13:19:17.883]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:17.883]                       inherits = FALSE)
[13:19:17.883]                   }
[13:19:17.883]                   options(future.plan = NULL)
[13:19:17.883]                   if (is.na(NA_character_)) 
[13:19:17.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:17.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:17.883]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:17.883]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:17.883]                     envir = parent.frame()) 
[13:19:17.883]                   {
[13:19:17.883]                     if (is.function(workers)) 
[13:19:17.883]                       workers <- workers()
[13:19:17.883]                     workers <- structure(as.integer(workers), 
[13:19:17.883]                       class = class(workers))
[13:19:17.883]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:17.883]                       workers >= 1)
[13:19:17.883]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:17.883]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:17.883]                     }
[13:19:17.883]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:17.883]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:17.883]                       envir = envir)
[13:19:17.883]                     if (!future$lazy) 
[13:19:17.883]                       future <- run(future)
[13:19:17.883]                     invisible(future)
[13:19:17.883]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:17.883]                 }
[13:19:17.883]             }
[13:19:17.883]         }
[13:19:17.883]     })
[13:19:17.883]     if (TRUE) {
[13:19:17.883]         base::sink(type = "output", split = FALSE)
[13:19:17.883]         if (FALSE) {
[13:19:17.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:17.883]         }
[13:19:17.883]         else {
[13:19:17.883]             ...future.result["stdout"] <- base::list(NULL)
[13:19:17.883]         }
[13:19:17.883]         base::close(...future.stdout)
[13:19:17.883]         ...future.stdout <- NULL
[13:19:17.883]     }
[13:19:17.883]     ...future.result$conditions <- ...future.conditions
[13:19:17.883]     ...future.result$finished <- base::Sys.time()
[13:19:17.883]     ...future.result
[13:19:17.883] }
[13:19:17.885] assign_globals() ...
[13:19:17.885] List of 5
[13:19:17.885]  $ ...future.FUN            :function (x, y)  
[13:19:17.885]  $ MoreArgs                 : NULL
[13:19:17.885]  $ ...future.elements_ii    :List of 2
[13:19:17.885]   ..$ :List of 2
[13:19:17.885]   .. ..$ : int 1
[13:19:17.885]   .. ..$ : int 0
[13:19:17.885]   ..$ :List of 2
[13:19:17.885]   .. ..$ : int 0
[13:19:17.885]   .. ..$ : int 1
[13:19:17.885]  $ ...future.seeds_ii       : NULL
[13:19:17.885]  $ ...future.globals.maxSize: NULL
[13:19:17.885]  - attr(*, "resolved")= logi FALSE
[13:19:17.885]  - attr(*, "total_size")= num 6480
[13:19:17.885]  - attr(*, "where")=List of 5
[13:19:17.885]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:17.885]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:17.885]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:17.885]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:17.885]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:17.885]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:17.885]  - attr(*, "already-done")= logi TRUE
[13:19:17.891] - reassign environment for ‘...future.FUN’
[13:19:17.891] - copied ‘...future.FUN’ to environment
[13:19:17.891] - copied ‘MoreArgs’ to environment
[13:19:17.891] - copied ‘...future.elements_ii’ to environment
[13:19:17.891] - copied ‘...future.seeds_ii’ to environment
[13:19:17.892] - copied ‘...future.globals.maxSize’ to environment
[13:19:17.892] assign_globals() ... done
[13:19:17.892] plan(): Setting new future strategy stack:
[13:19:17.892] List of future strategies:
[13:19:17.892] 1. sequential:
[13:19:17.892]    - args: function (..., envir = parent.frame())
[13:19:17.892]    - tweaked: FALSE
[13:19:17.892]    - call: NULL
[13:19:17.892] plan(): nbrOfWorkers() = 1
[13:19:18.394] plan(): Setting new future strategy stack:
[13:19:18.394] List of future strategies:
[13:19:18.394] 1. multisession:
[13:19:18.394]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:18.394]    - tweaked: FALSE
[13:19:18.394]    - call: plan(strategy)
[13:19:18.399] plan(): nbrOfWorkers() = 1
[13:19:18.399] SequentialFuture started (and completed)
[13:19:18.399] - Launch lazy future ... done
[13:19:18.399] run() for ‘SequentialFuture’ ... done
[13:19:18.399] Created future:
[13:19:18.400] SequentialFuture:
[13:19:18.400] Label: ‘future_mapply-1’
[13:19:18.400] Expression:
[13:19:18.400] {
[13:19:18.400]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:18.400]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:18.400]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:18.400]         on.exit(options(oopts), add = TRUE)
[13:19:18.400]     }
[13:19:18.400]     {
[13:19:18.400]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:18.400]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:18.400]         do.call(mapply, args = args)
[13:19:18.400]     }
[13:19:18.400] }
[13:19:18.400] Lazy evaluation: FALSE
[13:19:18.400] Asynchronous evaluation: FALSE
[13:19:18.400] Local evaluation: TRUE
[13:19:18.400] Environment: R_GlobalEnv
[13:19:18.400] Capture standard output: FALSE
[13:19:18.400] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:18.400] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:18.400] Packages: <none>
[13:19:18.400] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:18.400] Resolved: TRUE
[13:19:18.400] Value: 224 bytes of class ‘list’
[13:19:18.400] Early signaling: FALSE
[13:19:18.400] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:18.400] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:18.401] Chunk #1 of 1 ... DONE
[13:19:18.401] Launching 1 futures (chunks) ... DONE
[13:19:18.401] Resolving 1 futures (chunks) ...
[13:19:18.403] resolve() on list ...
[13:19:18.403]  recursive: 0
[13:19:18.403]  length: 1
[13:19:18.403] 
[13:19:18.403] resolved() for ‘SequentialFuture’ ...
[13:19:18.403] - state: ‘finished’
[13:19:18.403] - run: TRUE
[13:19:18.403] - result: ‘FutureResult’
[13:19:18.404] resolved() for ‘SequentialFuture’ ... done
[13:19:18.404] Future #1
[13:19:18.404] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:18.404] - nx: 1
[13:19:18.404] - relay: TRUE
[13:19:18.404] - stdout: TRUE
[13:19:18.404] - signal: TRUE
[13:19:18.404] - resignal: FALSE
[13:19:18.405] - force: TRUE
[13:19:18.405] - relayed: [n=1] FALSE
[13:19:18.405] - queued futures: [n=1] FALSE
[13:19:18.405]  - until=1
[13:19:18.405]  - relaying element #1
[13:19:18.405] - relayed: [n=1] TRUE
[13:19:18.405] - queued futures: [n=1] TRUE
[13:19:18.405] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:18.406]  length: 0 (resolved future 1)
[13:19:18.406] Relaying remaining futures
[13:19:18.406] signalConditionsASAP(NULL, pos=0) ...
[13:19:18.406] - nx: 1
[13:19:18.406] - relay: TRUE
[13:19:18.406] - stdout: TRUE
[13:19:18.406] - signal: TRUE
[13:19:18.406] - resignal: FALSE
[13:19:18.406] - force: TRUE
[13:19:18.406] - relayed: [n=1] TRUE
[13:19:18.406] - queued futures: [n=1] TRUE
 - flush all
[13:19:18.407] - relayed: [n=1] TRUE
[13:19:18.407] - queued futures: [n=1] TRUE
[13:19:18.407] signalConditionsASAP(NULL, pos=0) ... done
[13:19:18.407] resolve() on list ... DONE
[13:19:18.407]  - Number of value chunks collected: 1
[13:19:18.407] Resolving 1 futures (chunks) ... DONE
[13:19:18.407] Reducing values from 1 chunks ...
[13:19:18.407]  - Number of values collected after concatenation: 2
[13:19:18.407]  - Number of values expected: 2
[13:19:18.407] Reducing values from 1 chunks ... DONE
[13:19:18.408] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:19:18.408] future_mapply() ...
[13:19:18.411] Number of chunks: 1
[13:19:18.412] getGlobalsAndPackagesXApply() ...
[13:19:18.412]  - future.globals: TRUE
[13:19:18.412] getGlobalsAndPackages() ...
[13:19:18.412] Searching for globals...
[13:19:18.413] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:18.414] Searching for globals ... DONE
[13:19:18.414] Resolving globals: FALSE
[13:19:18.414] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:18.415] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:18.415] - globals: [1] ‘FUN’
[13:19:18.415] 
[13:19:18.415] getGlobalsAndPackages() ... DONE
[13:19:18.415]  - globals found/used: [n=1] ‘FUN’
[13:19:18.415]  - needed namespaces: [n=0] 
[13:19:18.415] Finding globals ... DONE
[13:19:18.416] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:18.416] List of 2
[13:19:18.416]  $ ...future.FUN:function (x, y)  
[13:19:18.416]  $ MoreArgs     : NULL
[13:19:18.416]  - attr(*, "where")=List of 2
[13:19:18.416]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:18.416]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:18.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:18.416]  - attr(*, "resolved")= logi FALSE
[13:19:18.416]  - attr(*, "total_size")= num NA
[13:19:18.418] Packages to be attached in all futures: [n=0] 
[13:19:18.418] getGlobalsAndPackagesXApply() ... DONE
[13:19:18.419] Number of futures (= number of chunks): 1
[13:19:18.419] Launching 1 futures (chunks) ...
[13:19:18.419] Chunk #1 of 1 ...
[13:19:18.419]  - Finding globals in '...' for chunk #1 ...
[13:19:18.419] getGlobalsAndPackages() ...
[13:19:18.419] Searching for globals...
[13:19:18.419] 
[13:19:18.420] Searching for globals ... DONE
[13:19:18.420] - globals: [0] <none>
[13:19:18.420] getGlobalsAndPackages() ... DONE
[13:19:18.420]    + additional globals found: [n=0] 
[13:19:18.420]    + additional namespaces needed: [n=0] 
[13:19:18.420]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:18.420]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:18.420]  - seeds: <none>
[13:19:18.420] getGlobalsAndPackages() ...
[13:19:18.420] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:18.421] Resolving globals: FALSE
[13:19:18.421] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:18.422] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:18.422] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:18.422] 
[13:19:18.422] getGlobalsAndPackages() ... DONE
[13:19:18.422] run() for ‘Future’ ...
[13:19:18.422] - state: ‘created’
[13:19:18.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:18.426] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:18.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:18.426]   - Field: ‘label’
[13:19:18.426]   - Field: ‘local’
[13:19:18.426]   - Field: ‘owner’
[13:19:18.427]   - Field: ‘envir’
[13:19:18.427]   - Field: ‘packages’
[13:19:18.427]   - Field: ‘gc’
[13:19:18.427]   - Field: ‘conditions’
[13:19:18.427]   - Field: ‘expr’
[13:19:18.427]   - Field: ‘uuid’
[13:19:18.427]   - Field: ‘seed’
[13:19:18.427]   - Field: ‘version’
[13:19:18.427]   - Field: ‘result’
[13:19:18.427]   - Field: ‘asynchronous’
[13:19:18.427]   - Field: ‘calls’
[13:19:18.428]   - Field: ‘globals’
[13:19:18.428]   - Field: ‘stdout’
[13:19:18.428]   - Field: ‘earlySignal’
[13:19:18.428]   - Field: ‘lazy’
[13:19:18.428]   - Field: ‘state’
[13:19:18.428] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:18.428] - Launch lazy future ...
[13:19:18.428] Packages needed by the future expression (n = 0): <none>
[13:19:18.428] Packages needed by future strategies (n = 0): <none>
[13:19:18.429] {
[13:19:18.429]     {
[13:19:18.429]         {
[13:19:18.429]             ...future.startTime <- base::Sys.time()
[13:19:18.429]             {
[13:19:18.429]                 {
[13:19:18.429]                   {
[13:19:18.429]                     base::local({
[13:19:18.429]                       has_future <- base::requireNamespace("future", 
[13:19:18.429]                         quietly = TRUE)
[13:19:18.429]                       if (has_future) {
[13:19:18.429]                         ns <- base::getNamespace("future")
[13:19:18.429]                         version <- ns[[".package"]][["version"]]
[13:19:18.429]                         if (is.null(version)) 
[13:19:18.429]                           version <- utils::packageVersion("future")
[13:19:18.429]                       }
[13:19:18.429]                       else {
[13:19:18.429]                         version <- NULL
[13:19:18.429]                       }
[13:19:18.429]                       if (!has_future || version < "1.8.0") {
[13:19:18.429]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:18.429]                           "", base::R.version$version.string), 
[13:19:18.429]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:18.429]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:18.429]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:18.429]                             "release", "version")], collapse = " "), 
[13:19:18.429]                           hostname = base::Sys.info()[["nodename"]])
[13:19:18.429]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:18.429]                           info)
[13:19:18.429]                         info <- base::paste(info, collapse = "; ")
[13:19:18.429]                         if (!has_future) {
[13:19:18.429]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:18.429]                             info)
[13:19:18.429]                         }
[13:19:18.429]                         else {
[13:19:18.429]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:18.429]                             info, version)
[13:19:18.429]                         }
[13:19:18.429]                         base::stop(msg)
[13:19:18.429]                       }
[13:19:18.429]                     })
[13:19:18.429]                   }
[13:19:18.429]                   options(future.plan = NULL)
[13:19:18.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:18.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:18.429]                 }
[13:19:18.429]                 ...future.workdir <- getwd()
[13:19:18.429]             }
[13:19:18.429]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:18.429]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:18.429]         }
[13:19:18.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:18.429]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:18.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:18.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:18.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:18.429]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:18.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:18.429]             base::names(...future.oldOptions))
[13:19:18.429]     }
[13:19:18.429]     if (FALSE) {
[13:19:18.429]     }
[13:19:18.429]     else {
[13:19:18.429]         if (TRUE) {
[13:19:18.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:18.429]                 open = "w")
[13:19:18.429]         }
[13:19:18.429]         else {
[13:19:18.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:18.429]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:18.429]         }
[13:19:18.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:18.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:18.429]             base::sink(type = "output", split = FALSE)
[13:19:18.429]             base::close(...future.stdout)
[13:19:18.429]         }, add = TRUE)
[13:19:18.429]     }
[13:19:18.429]     ...future.frame <- base::sys.nframe()
[13:19:18.429]     ...future.conditions <- base::list()
[13:19:18.429]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:18.429]     if (FALSE) {
[13:19:18.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:18.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:18.429]     }
[13:19:18.429]     ...future.result <- base::tryCatch({
[13:19:18.429]         base::withCallingHandlers({
[13:19:18.429]             ...future.value <- base::withVisible(base::local({
[13:19:18.429]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:18.429]                 if (!identical(...future.globals.maxSize.org, 
[13:19:18.429]                   ...future.globals.maxSize)) {
[13:19:18.429]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:18.429]                   on.exit(options(oopts), add = TRUE)
[13:19:18.429]                 }
[13:19:18.429]                 {
[13:19:18.429]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:18.429]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:18.429]                     USE.NAMES = FALSE)
[13:19:18.429]                   do.call(mapply, args = args)
[13:19:18.429]                 }
[13:19:18.429]             }))
[13:19:18.429]             future::FutureResult(value = ...future.value$value, 
[13:19:18.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:18.429]                   ...future.rng), globalenv = if (FALSE) 
[13:19:18.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:18.429]                     ...future.globalenv.names))
[13:19:18.429]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:18.429]         }, condition = base::local({
[13:19:18.429]             c <- base::c
[13:19:18.429]             inherits <- base::inherits
[13:19:18.429]             invokeRestart <- base::invokeRestart
[13:19:18.429]             length <- base::length
[13:19:18.429]             list <- base::list
[13:19:18.429]             seq.int <- base::seq.int
[13:19:18.429]             signalCondition <- base::signalCondition
[13:19:18.429]             sys.calls <- base::sys.calls
[13:19:18.429]             `[[` <- base::`[[`
[13:19:18.429]             `+` <- base::`+`
[13:19:18.429]             `<<-` <- base::`<<-`
[13:19:18.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:18.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:18.429]                   3L)]
[13:19:18.429]             }
[13:19:18.429]             function(cond) {
[13:19:18.429]                 is_error <- inherits(cond, "error")
[13:19:18.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:18.429]                   NULL)
[13:19:18.429]                 if (is_error) {
[13:19:18.429]                   sessionInformation <- function() {
[13:19:18.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:18.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:18.429]                       search = base::search(), system = base::Sys.info())
[13:19:18.429]                   }
[13:19:18.429]                   ...future.conditions[[length(...future.conditions) + 
[13:19:18.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:18.429]                     cond$call), session = sessionInformation(), 
[13:19:18.429]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:18.429]                   signalCondition(cond)
[13:19:18.429]                 }
[13:19:18.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:18.429]                 "immediateCondition"))) {
[13:19:18.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:18.429]                   ...future.conditions[[length(...future.conditions) + 
[13:19:18.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:18.429]                   if (TRUE && !signal) {
[13:19:18.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:18.429]                     {
[13:19:18.429]                       inherits <- base::inherits
[13:19:18.429]                       invokeRestart <- base::invokeRestart
[13:19:18.429]                       is.null <- base::is.null
[13:19:18.429]                       muffled <- FALSE
[13:19:18.429]                       if (inherits(cond, "message")) {
[13:19:18.429]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:18.429]                         if (muffled) 
[13:19:18.429]                           invokeRestart("muffleMessage")
[13:19:18.429]                       }
[13:19:18.429]                       else if (inherits(cond, "warning")) {
[13:19:18.429]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:18.429]                         if (muffled) 
[13:19:18.429]                           invokeRestart("muffleWarning")
[13:19:18.429]                       }
[13:19:18.429]                       else if (inherits(cond, "condition")) {
[13:19:18.429]                         if (!is.null(pattern)) {
[13:19:18.429]                           computeRestarts <- base::computeRestarts
[13:19:18.429]                           grepl <- base::grepl
[13:19:18.429]                           restarts <- computeRestarts(cond)
[13:19:18.429]                           for (restart in restarts) {
[13:19:18.429]                             name <- restart$name
[13:19:18.429]                             if (is.null(name)) 
[13:19:18.429]                               next
[13:19:18.429]                             if (!grepl(pattern, name)) 
[13:19:18.429]                               next
[13:19:18.429]                             invokeRestart(restart)
[13:19:18.429]                             muffled <- TRUE
[13:19:18.429]                             break
[13:19:18.429]                           }
[13:19:18.429]                         }
[13:19:18.429]                       }
[13:19:18.429]                       invisible(muffled)
[13:19:18.429]                     }
[13:19:18.429]                     muffleCondition(cond, pattern = "^muffle")
[13:19:18.429]                   }
[13:19:18.429]                 }
[13:19:18.429]                 else {
[13:19:18.429]                   if (TRUE) {
[13:19:18.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:18.429]                     {
[13:19:18.429]                       inherits <- base::inherits
[13:19:18.429]                       invokeRestart <- base::invokeRestart
[13:19:18.429]                       is.null <- base::is.null
[13:19:18.429]                       muffled <- FALSE
[13:19:18.429]                       if (inherits(cond, "message")) {
[13:19:18.429]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:18.429]                         if (muffled) 
[13:19:18.429]                           invokeRestart("muffleMessage")
[13:19:18.429]                       }
[13:19:18.429]                       else if (inherits(cond, "warning")) {
[13:19:18.429]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:18.429]                         if (muffled) 
[13:19:18.429]                           invokeRestart("muffleWarning")
[13:19:18.429]                       }
[13:19:18.429]                       else if (inherits(cond, "condition")) {
[13:19:18.429]                         if (!is.null(pattern)) {
[13:19:18.429]                           computeRestarts <- base::computeRestarts
[13:19:18.429]                           grepl <- base::grepl
[13:19:18.429]                           restarts <- computeRestarts(cond)
[13:19:18.429]                           for (restart in restarts) {
[13:19:18.429]                             name <- restart$name
[13:19:18.429]                             if (is.null(name)) 
[13:19:18.429]                               next
[13:19:18.429]                             if (!grepl(pattern, name)) 
[13:19:18.429]                               next
[13:19:18.429]                             invokeRestart(restart)
[13:19:18.429]                             muffled <- TRUE
[13:19:18.429]                             break
[13:19:18.429]                           }
[13:19:18.429]                         }
[13:19:18.429]                       }
[13:19:18.429]                       invisible(muffled)
[13:19:18.429]                     }
[13:19:18.429]                     muffleCondition(cond, pattern = "^muffle")
[13:19:18.429]                   }
[13:19:18.429]                 }
[13:19:18.429]             }
[13:19:18.429]         }))
[13:19:18.429]     }, error = function(ex) {
[13:19:18.429]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:18.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:18.429]                 ...future.rng), started = ...future.startTime, 
[13:19:18.429]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:18.429]             version = "1.8"), class = "FutureResult")
[13:19:18.429]     }, finally = {
[13:19:18.429]         if (!identical(...future.workdir, getwd())) 
[13:19:18.429]             setwd(...future.workdir)
[13:19:18.429]         {
[13:19:18.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:18.429]                 ...future.oldOptions$nwarnings <- NULL
[13:19:18.429]             }
[13:19:18.429]             base::options(...future.oldOptions)
[13:19:18.429]             if (.Platform$OS.type == "windows") {
[13:19:18.429]                 old_names <- names(...future.oldEnvVars)
[13:19:18.429]                 envs <- base::Sys.getenv()
[13:19:18.429]                 names <- names(envs)
[13:19:18.429]                 common <- intersect(names, old_names)
[13:19:18.429]                 added <- setdiff(names, old_names)
[13:19:18.429]                 removed <- setdiff(old_names, names)
[13:19:18.429]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:18.429]                   envs[common]]
[13:19:18.429]                 NAMES <- toupper(changed)
[13:19:18.429]                 args <- list()
[13:19:18.429]                 for (kk in seq_along(NAMES)) {
[13:19:18.429]                   name <- changed[[kk]]
[13:19:18.429]                   NAME <- NAMES[[kk]]
[13:19:18.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:18.429]                     next
[13:19:18.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:18.429]                 }
[13:19:18.429]                 NAMES <- toupper(added)
[13:19:18.429]                 for (kk in seq_along(NAMES)) {
[13:19:18.429]                   name <- added[[kk]]
[13:19:18.429]                   NAME <- NAMES[[kk]]
[13:19:18.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:18.429]                     next
[13:19:18.429]                   args[[name]] <- ""
[13:19:18.429]                 }
[13:19:18.429]                 NAMES <- toupper(removed)
[13:19:18.429]                 for (kk in seq_along(NAMES)) {
[13:19:18.429]                   name <- removed[[kk]]
[13:19:18.429]                   NAME <- NAMES[[kk]]
[13:19:18.429]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:18.429]                     next
[13:19:18.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:18.429]                 }
[13:19:18.429]                 if (length(args) > 0) 
[13:19:18.429]                   base::do.call(base::Sys.setenv, args = args)
[13:19:18.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:18.429]             }
[13:19:18.429]             else {
[13:19:18.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:18.429]             }
[13:19:18.429]             {
[13:19:18.429]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:18.429]                   0L) {
[13:19:18.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:18.429]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:18.429]                   base::options(opts)
[13:19:18.429]                 }
[13:19:18.429]                 {
[13:19:18.429]                   {
[13:19:18.429]                     NULL
[13:19:18.429]                     RNGkind("Mersenne-Twister")
[13:19:18.429]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:18.429]                       inherits = FALSE)
[13:19:18.429]                   }
[13:19:18.429]                   options(future.plan = NULL)
[13:19:18.429]                   if (is.na(NA_character_)) 
[13:19:18.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:18.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:18.429]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:18.429]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:18.429]                     envir = parent.frame()) 
[13:19:18.429]                   {
[13:19:18.429]                     if (is.function(workers)) 
[13:19:18.429]                       workers <- workers()
[13:19:18.429]                     workers <- structure(as.integer(workers), 
[13:19:18.429]                       class = class(workers))
[13:19:18.429]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:18.429]                       workers >= 1)
[13:19:18.429]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:18.429]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:18.429]                     }
[13:19:18.429]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:18.429]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:18.429]                       envir = envir)
[13:19:18.429]                     if (!future$lazy) 
[13:19:18.429]                       future <- run(future)
[13:19:18.429]                     invisible(future)
[13:19:18.429]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:18.429]                 }
[13:19:18.429]             }
[13:19:18.429]         }
[13:19:18.429]     })
[13:19:18.429]     if (TRUE) {
[13:19:18.429]         base::sink(type = "output", split = FALSE)
[13:19:18.429]         if (TRUE) {
[13:19:18.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:18.429]         }
[13:19:18.429]         else {
[13:19:18.429]             ...future.result["stdout"] <- base::list(NULL)
[13:19:18.429]         }
[13:19:18.429]         base::close(...future.stdout)
[13:19:18.429]         ...future.stdout <- NULL
[13:19:18.429]     }
[13:19:18.429]     ...future.result$conditions <- ...future.conditions
[13:19:18.429]     ...future.result$finished <- base::Sys.time()
[13:19:18.429]     ...future.result
[13:19:18.429] }
[13:19:18.431] assign_globals() ...
[13:19:18.431] List of 5
[13:19:18.431]  $ ...future.FUN            :function (x, y)  
[13:19:18.431]  $ MoreArgs                 : NULL
[13:19:18.431]  $ ...future.elements_ii    :List of 2
[13:19:18.431]   ..$ :List of 2
[13:19:18.431]   .. ..$ : int 1
[13:19:18.431]   .. ..$ : int 0
[13:19:18.431]   ..$ :List of 2
[13:19:18.431]   .. ..$ : int 0
[13:19:18.431]   .. ..$ : int 1
[13:19:18.431]  $ ...future.seeds_ii       : NULL
[13:19:18.431]  $ ...future.globals.maxSize: NULL
[13:19:18.431]  - attr(*, "resolved")= logi FALSE
[13:19:18.431]  - attr(*, "total_size")= num 6480
[13:19:18.431]  - attr(*, "where")=List of 5
[13:19:18.431]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:18.431]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:18.431]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:18.431]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:18.431]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:18.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:18.431]  - attr(*, "already-done")= logi TRUE
[13:19:18.439] - reassign environment for ‘...future.FUN’
[13:19:18.439] - copied ‘...future.FUN’ to environment
[13:19:18.439] - copied ‘MoreArgs’ to environment
[13:19:18.439] - copied ‘...future.elements_ii’ to environment
[13:19:18.439] - copied ‘...future.seeds_ii’ to environment
[13:19:18.440] - copied ‘...future.globals.maxSize’ to environment
[13:19:18.440] assign_globals() ... done
[13:19:18.440] plan(): Setting new future strategy stack:
[13:19:18.440] List of future strategies:
[13:19:18.440] 1. sequential:
[13:19:18.440]    - args: function (..., envir = parent.frame())
[13:19:18.440]    - tweaked: FALSE
[13:19:18.440]    - call: NULL
[13:19:18.440] plan(): nbrOfWorkers() = 1
[13:19:18.942] plan(): Setting new future strategy stack:
[13:19:18.942] List of future strategies:
[13:19:18.942] 1. multisession:
[13:19:18.942]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:18.942]    - tweaked: FALSE
[13:19:18.942]    - call: plan(strategy)
[13:19:18.946] plan(): nbrOfWorkers() = 1
[13:19:18.947] SequentialFuture started (and completed)
[13:19:18.947] - Launch lazy future ... done
[13:19:18.947] run() for ‘SequentialFuture’ ... done
[13:19:18.947] Created future:
[13:19:18.947] SequentialFuture:
[13:19:18.947] Label: ‘future_mapply-1’
[13:19:18.947] Expression:
[13:19:18.947] {
[13:19:18.947]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:18.947]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:18.947]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:18.947]         on.exit(options(oopts), add = TRUE)
[13:19:18.947]     }
[13:19:18.947]     {
[13:19:18.947]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:18.947]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:18.947]         do.call(mapply, args = args)
[13:19:18.947]     }
[13:19:18.947] }
[13:19:18.947] Lazy evaluation: FALSE
[13:19:18.947] Asynchronous evaluation: FALSE
[13:19:18.947] Local evaluation: TRUE
[13:19:18.947] Environment: R_GlobalEnv
[13:19:18.947] Capture standard output: TRUE
[13:19:18.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:18.947] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:18.947] Packages: <none>
[13:19:18.947] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:18.947] Resolved: TRUE
[13:19:18.947] Value: 224 bytes of class ‘list’
[13:19:18.947] Early signaling: FALSE
[13:19:18.947] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:18.947] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:18.948] Chunk #1 of 1 ... DONE
[13:19:18.948] Launching 1 futures (chunks) ... DONE
[13:19:18.948] Resolving 1 futures (chunks) ...
[13:19:18.948] resolve() on list ...
[13:19:18.948]  recursive: 0
[13:19:18.949]  length: 1
[13:19:18.949] 
[13:19:18.949] resolved() for ‘SequentialFuture’ ...
[13:19:18.949] - state: ‘finished’
[13:19:18.949] - run: TRUE
[13:19:18.949] - result: ‘FutureResult’
[13:19:18.949] resolved() for ‘SequentialFuture’ ... done
[13:19:18.949] Future #1
[13:19:18.949] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:18.949] - nx: 1
[13:19:18.950] - relay: TRUE
[13:19:18.950] - stdout: TRUE
[13:19:18.950] - signal: TRUE
[13:19:18.950] - resignal: FALSE
[13:19:18.950] - force: TRUE
[13:19:18.950] - relayed: [n=1] FALSE
[13:19:18.950] - queued futures: [n=1] FALSE
[13:19:18.950]  - until=1
[13:19:18.950]  - relaying element #1
[13:19:18.950] - relayed: [n=1] TRUE
[13:19:18.951] - queued futures: [n=1] TRUE
[13:19:18.951] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:18.951]  length: 0 (resolved future 1)
[13:19:18.951] Relaying remaining futures
[13:19:18.951] signalConditionsASAP(NULL, pos=0) ...
[13:19:18.951] - nx: 1
[13:19:18.951] - relay: TRUE
[13:19:18.951] - stdout: TRUE
[13:19:18.951] - signal: TRUE
[13:19:18.951] - resignal: FALSE
[13:19:18.951] - force: TRUE
[13:19:18.951] - relayed: [n=1] TRUE
[13:19:18.952] - queued futures: [n=1] TRUE
 - flush all
[13:19:18.952] - relayed: [n=1] TRUE
[13:19:18.952] - queued futures: [n=1] TRUE
[13:19:18.952] signalConditionsASAP(NULL, pos=0) ... done
[13:19:18.952] resolve() on list ... DONE
[13:19:18.952]  - Number of value chunks collected: 1
[13:19:18.952] Resolving 1 futures (chunks) ... DONE
[13:19:18.952] Reducing values from 1 chunks ...
[13:19:18.952]  - Number of values collected after concatenation: 2
[13:19:18.952]  - Number of values expected: 2
[13:19:18.953] Reducing values from 1 chunks ... DONE
[13:19:18.953] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:19:18.953] future_mapply() ...
[13:19:18.956] Number of chunks: 1
[13:19:18.956] getGlobalsAndPackagesXApply() ...
[13:19:18.956]  - future.globals: TRUE
[13:19:18.957] getGlobalsAndPackages() ...
[13:19:18.957] Searching for globals...
[13:19:18.958] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:18.958] Searching for globals ... DONE
[13:19:18.958] Resolving globals: FALSE
[13:19:18.959] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:18.959] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:18.959] - globals: [1] ‘FUN’
[13:19:18.959] 
[13:19:18.959] getGlobalsAndPackages() ... DONE
[13:19:18.960]  - globals found/used: [n=1] ‘FUN’
[13:19:18.960]  - needed namespaces: [n=0] 
[13:19:18.960] Finding globals ... DONE
[13:19:18.960] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:18.960] List of 2
[13:19:18.960]  $ ...future.FUN:function (x, y)  
[13:19:18.960]  $ MoreArgs     : NULL
[13:19:18.960]  - attr(*, "where")=List of 2
[13:19:18.960]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:18.960]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:18.960]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:18.960]  - attr(*, "resolved")= logi FALSE
[13:19:18.960]  - attr(*, "total_size")= num NA
[13:19:18.963] Packages to be attached in all futures: [n=0] 
[13:19:18.963] getGlobalsAndPackagesXApply() ... DONE
[13:19:18.963] Number of futures (= number of chunks): 1
[13:19:18.963] Launching 1 futures (chunks) ...
[13:19:18.963] Chunk #1 of 1 ...
[13:19:18.963]  - Finding globals in '...' for chunk #1 ...
[13:19:18.963] getGlobalsAndPackages() ...
[13:19:18.963] Searching for globals...
[13:19:18.964] 
[13:19:18.964] Searching for globals ... DONE
[13:19:18.964] - globals: [0] <none>
[13:19:18.964] getGlobalsAndPackages() ... DONE
[13:19:18.964]    + additional globals found: [n=0] 
[13:19:18.964]    + additional namespaces needed: [n=0] 
[13:19:18.964]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:18.964]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:19:18.964]  - seeds: <none>
[13:19:18.965] getGlobalsAndPackages() ...
[13:19:18.965] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:18.965] Resolving globals: FALSE
[13:19:18.967] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:19:18.967] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:18.967] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:18.968] 
[13:19:18.968] getGlobalsAndPackages() ... DONE
[13:19:18.968] run() for ‘Future’ ...
[13:19:18.968] - state: ‘created’
[13:19:18.968] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:18.972] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:18.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:19:18.972]   - Field: ‘label’
[13:19:18.972]   - Field: ‘local’
[13:19:18.972]   - Field: ‘owner’
[13:19:18.972]   - Field: ‘envir’
[13:19:18.972]   - Field: ‘packages’
[13:19:18.973]   - Field: ‘gc’
[13:19:18.973]   - Field: ‘conditions’
[13:19:18.973]   - Field: ‘expr’
[13:19:18.973]   - Field: ‘uuid’
[13:19:18.973]   - Field: ‘seed’
[13:19:18.973]   - Field: ‘version’
[13:19:18.973]   - Field: ‘result’
[13:19:18.973]   - Field: ‘asynchronous’
[13:19:18.973]   - Field: ‘calls’
[13:19:18.973]   - Field: ‘globals’
[13:19:18.974]   - Field: ‘stdout’
[13:19:18.974]   - Field: ‘earlySignal’
[13:19:18.974]   - Field: ‘lazy’
[13:19:18.974]   - Field: ‘state’
[13:19:18.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:19:18.974] - Launch lazy future ...
[13:19:18.974] Packages needed by the future expression (n = 0): <none>
[13:19:18.974] Packages needed by future strategies (n = 0): <none>
[13:19:18.975] {
[13:19:18.975]     {
[13:19:18.975]         {
[13:19:18.975]             ...future.startTime <- base::Sys.time()
[13:19:18.975]             {
[13:19:18.975]                 {
[13:19:18.975]                   {
[13:19:18.975]                     base::local({
[13:19:18.975]                       has_future <- base::requireNamespace("future", 
[13:19:18.975]                         quietly = TRUE)
[13:19:18.975]                       if (has_future) {
[13:19:18.975]                         ns <- base::getNamespace("future")
[13:19:18.975]                         version <- ns[[".package"]][["version"]]
[13:19:18.975]                         if (is.null(version)) 
[13:19:18.975]                           version <- utils::packageVersion("future")
[13:19:18.975]                       }
[13:19:18.975]                       else {
[13:19:18.975]                         version <- NULL
[13:19:18.975]                       }
[13:19:18.975]                       if (!has_future || version < "1.8.0") {
[13:19:18.975]                         info <- base::c(r_version = base::gsub("R version ", 
[13:19:18.975]                           "", base::R.version$version.string), 
[13:19:18.975]                           platform = base::sprintf("%s (%s-bit)", 
[13:19:18.975]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:18.975]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:18.975]                             "release", "version")], collapse = " "), 
[13:19:18.975]                           hostname = base::Sys.info()[["nodename"]])
[13:19:18.975]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:19:18.975]                           info)
[13:19:18.975]                         info <- base::paste(info, collapse = "; ")
[13:19:18.975]                         if (!has_future) {
[13:19:18.975]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:18.975]                             info)
[13:19:18.975]                         }
[13:19:18.975]                         else {
[13:19:18.975]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:18.975]                             info, version)
[13:19:18.975]                         }
[13:19:18.975]                         base::stop(msg)
[13:19:18.975]                       }
[13:19:18.975]                     })
[13:19:18.975]                   }
[13:19:18.975]                   options(future.plan = NULL)
[13:19:18.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:18.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:18.975]                 }
[13:19:18.975]                 ...future.workdir <- getwd()
[13:19:18.975]             }
[13:19:18.975]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:18.975]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:18.975]         }
[13:19:18.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:18.975]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:19:18.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:18.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:18.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:18.975]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:18.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:18.975]             base::names(...future.oldOptions))
[13:19:18.975]     }
[13:19:18.975]     if (TRUE) {
[13:19:18.975]     }
[13:19:18.975]     else {
[13:19:18.975]         if (NA) {
[13:19:18.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:18.975]                 open = "w")
[13:19:18.975]         }
[13:19:18.975]         else {
[13:19:18.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:18.975]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:18.975]         }
[13:19:18.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:18.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:18.975]             base::sink(type = "output", split = FALSE)
[13:19:18.975]             base::close(...future.stdout)
[13:19:18.975]         }, add = TRUE)
[13:19:18.975]     }
[13:19:18.975]     ...future.frame <- base::sys.nframe()
[13:19:18.975]     ...future.conditions <- base::list()
[13:19:18.975]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:18.975]     if (FALSE) {
[13:19:18.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:18.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:18.975]     }
[13:19:18.975]     ...future.result <- base::tryCatch({
[13:19:18.975]         base::withCallingHandlers({
[13:19:18.975]             ...future.value <- base::withVisible(base::local({
[13:19:18.975]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:18.975]                 if (!identical(...future.globals.maxSize.org, 
[13:19:18.975]                   ...future.globals.maxSize)) {
[13:19:18.975]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:18.975]                   on.exit(options(oopts), add = TRUE)
[13:19:18.975]                 }
[13:19:18.975]                 {
[13:19:18.975]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:18.975]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:18.975]                     USE.NAMES = FALSE)
[13:19:18.975]                   do.call(mapply, args = args)
[13:19:18.975]                 }
[13:19:18.975]             }))
[13:19:18.975]             future::FutureResult(value = ...future.value$value, 
[13:19:18.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:18.975]                   ...future.rng), globalenv = if (FALSE) 
[13:19:18.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:18.975]                     ...future.globalenv.names))
[13:19:18.975]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:18.975]         }, condition = base::local({
[13:19:18.975]             c <- base::c
[13:19:18.975]             inherits <- base::inherits
[13:19:18.975]             invokeRestart <- base::invokeRestart
[13:19:18.975]             length <- base::length
[13:19:18.975]             list <- base::list
[13:19:18.975]             seq.int <- base::seq.int
[13:19:18.975]             signalCondition <- base::signalCondition
[13:19:18.975]             sys.calls <- base::sys.calls
[13:19:18.975]             `[[` <- base::`[[`
[13:19:18.975]             `+` <- base::`+`
[13:19:18.975]             `<<-` <- base::`<<-`
[13:19:18.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:18.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:18.975]                   3L)]
[13:19:18.975]             }
[13:19:18.975]             function(cond) {
[13:19:18.975]                 is_error <- inherits(cond, "error")
[13:19:18.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:18.975]                   NULL)
[13:19:18.975]                 if (is_error) {
[13:19:18.975]                   sessionInformation <- function() {
[13:19:18.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:18.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:18.975]                       search = base::search(), system = base::Sys.info())
[13:19:18.975]                   }
[13:19:18.975]                   ...future.conditions[[length(...future.conditions) + 
[13:19:18.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:18.975]                     cond$call), session = sessionInformation(), 
[13:19:18.975]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:18.975]                   signalCondition(cond)
[13:19:18.975]                 }
[13:19:18.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:18.975]                 "immediateCondition"))) {
[13:19:18.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:18.975]                   ...future.conditions[[length(...future.conditions) + 
[13:19:18.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:18.975]                   if (TRUE && !signal) {
[13:19:18.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:18.975]                     {
[13:19:18.975]                       inherits <- base::inherits
[13:19:18.975]                       invokeRestart <- base::invokeRestart
[13:19:18.975]                       is.null <- base::is.null
[13:19:18.975]                       muffled <- FALSE
[13:19:18.975]                       if (inherits(cond, "message")) {
[13:19:18.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:18.975]                         if (muffled) 
[13:19:18.975]                           invokeRestart("muffleMessage")
[13:19:18.975]                       }
[13:19:18.975]                       else if (inherits(cond, "warning")) {
[13:19:18.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:18.975]                         if (muffled) 
[13:19:18.975]                           invokeRestart("muffleWarning")
[13:19:18.975]                       }
[13:19:18.975]                       else if (inherits(cond, "condition")) {
[13:19:18.975]                         if (!is.null(pattern)) {
[13:19:18.975]                           computeRestarts <- base::computeRestarts
[13:19:18.975]                           grepl <- base::grepl
[13:19:18.975]                           restarts <- computeRestarts(cond)
[13:19:18.975]                           for (restart in restarts) {
[13:19:18.975]                             name <- restart$name
[13:19:18.975]                             if (is.null(name)) 
[13:19:18.975]                               next
[13:19:18.975]                             if (!grepl(pattern, name)) 
[13:19:18.975]                               next
[13:19:18.975]                             invokeRestart(restart)
[13:19:18.975]                             muffled <- TRUE
[13:19:18.975]                             break
[13:19:18.975]                           }
[13:19:18.975]                         }
[13:19:18.975]                       }
[13:19:18.975]                       invisible(muffled)
[13:19:18.975]                     }
[13:19:18.975]                     muffleCondition(cond, pattern = "^muffle")
[13:19:18.975]                   }
[13:19:18.975]                 }
[13:19:18.975]                 else {
[13:19:18.975]                   if (TRUE) {
[13:19:18.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:18.975]                     {
[13:19:18.975]                       inherits <- base::inherits
[13:19:18.975]                       invokeRestart <- base::invokeRestart
[13:19:18.975]                       is.null <- base::is.null
[13:19:18.975]                       muffled <- FALSE
[13:19:18.975]                       if (inherits(cond, "message")) {
[13:19:18.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:18.975]                         if (muffled) 
[13:19:18.975]                           invokeRestart("muffleMessage")
[13:19:18.975]                       }
[13:19:18.975]                       else if (inherits(cond, "warning")) {
[13:19:18.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:18.975]                         if (muffled) 
[13:19:18.975]                           invokeRestart("muffleWarning")
[13:19:18.975]                       }
[13:19:18.975]                       else if (inherits(cond, "condition")) {
[13:19:18.975]                         if (!is.null(pattern)) {
[13:19:18.975]                           computeRestarts <- base::computeRestarts
[13:19:18.975]                           grepl <- base::grepl
[13:19:18.975]                           restarts <- computeRestarts(cond)
[13:19:18.975]                           for (restart in restarts) {
[13:19:18.975]                             name <- restart$name
[13:19:18.975]                             if (is.null(name)) 
[13:19:18.975]                               next
[13:19:18.975]                             if (!grepl(pattern, name)) 
[13:19:18.975]                               next
[13:19:18.975]                             invokeRestart(restart)
[13:19:18.975]                             muffled <- TRUE
[13:19:18.975]                             break
[13:19:18.975]                           }
[13:19:18.975]                         }
[13:19:18.975]                       }
[13:19:18.975]                       invisible(muffled)
[13:19:18.975]                     }
[13:19:18.975]                     muffleCondition(cond, pattern = "^muffle")
[13:19:18.975]                   }
[13:19:18.975]                 }
[13:19:18.975]             }
[13:19:18.975]         }))
[13:19:18.975]     }, error = function(ex) {
[13:19:18.975]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:18.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:18.975]                 ...future.rng), started = ...future.startTime, 
[13:19:18.975]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:18.975]             version = "1.8"), class = "FutureResult")
[13:19:18.975]     }, finally = {
[13:19:18.975]         if (!identical(...future.workdir, getwd())) 
[13:19:18.975]             setwd(...future.workdir)
[13:19:18.975]         {
[13:19:18.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:18.975]                 ...future.oldOptions$nwarnings <- NULL
[13:19:18.975]             }
[13:19:18.975]             base::options(...future.oldOptions)
[13:19:18.975]             if (.Platform$OS.type == "windows") {
[13:19:18.975]                 old_names <- names(...future.oldEnvVars)
[13:19:18.975]                 envs <- base::Sys.getenv()
[13:19:18.975]                 names <- names(envs)
[13:19:18.975]                 common <- intersect(names, old_names)
[13:19:18.975]                 added <- setdiff(names, old_names)
[13:19:18.975]                 removed <- setdiff(old_names, names)
[13:19:18.975]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:18.975]                   envs[common]]
[13:19:18.975]                 NAMES <- toupper(changed)
[13:19:18.975]                 args <- list()
[13:19:18.975]                 for (kk in seq_along(NAMES)) {
[13:19:18.975]                   name <- changed[[kk]]
[13:19:18.975]                   NAME <- NAMES[[kk]]
[13:19:18.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:18.975]                     next
[13:19:18.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:18.975]                 }
[13:19:18.975]                 NAMES <- toupper(added)
[13:19:18.975]                 for (kk in seq_along(NAMES)) {
[13:19:18.975]                   name <- added[[kk]]
[13:19:18.975]                   NAME <- NAMES[[kk]]
[13:19:18.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:18.975]                     next
[13:19:18.975]                   args[[name]] <- ""
[13:19:18.975]                 }
[13:19:18.975]                 NAMES <- toupper(removed)
[13:19:18.975]                 for (kk in seq_along(NAMES)) {
[13:19:18.975]                   name <- removed[[kk]]
[13:19:18.975]                   NAME <- NAMES[[kk]]
[13:19:18.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:18.975]                     next
[13:19:18.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:18.975]                 }
[13:19:18.975]                 if (length(args) > 0) 
[13:19:18.975]                   base::do.call(base::Sys.setenv, args = args)
[13:19:18.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:18.975]             }
[13:19:18.975]             else {
[13:19:18.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:18.975]             }
[13:19:18.975]             {
[13:19:18.975]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:18.975]                   0L) {
[13:19:18.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:18.975]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:18.975]                   base::options(opts)
[13:19:18.975]                 }
[13:19:18.975]                 {
[13:19:18.975]                   {
[13:19:18.975]                     NULL
[13:19:18.975]                     RNGkind("Mersenne-Twister")
[13:19:18.975]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:19:18.975]                       inherits = FALSE)
[13:19:18.975]                   }
[13:19:18.975]                   options(future.plan = NULL)
[13:19:18.975]                   if (is.na(NA_character_)) 
[13:19:18.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:18.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:18.975]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:18.975]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:18.975]                     envir = parent.frame()) 
[13:19:18.975]                   {
[13:19:18.975]                     if (is.function(workers)) 
[13:19:18.975]                       workers <- workers()
[13:19:18.975]                     workers <- structure(as.integer(workers), 
[13:19:18.975]                       class = class(workers))
[13:19:18.975]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:18.975]                       workers >= 1)
[13:19:18.975]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:18.975]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:18.975]                     }
[13:19:18.975]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:18.975]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:18.975]                       envir = envir)
[13:19:18.975]                     if (!future$lazy) 
[13:19:18.975]                       future <- run(future)
[13:19:18.975]                     invisible(future)
[13:19:18.975]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:18.975]                 }
[13:19:18.975]             }
[13:19:18.975]         }
[13:19:18.975]     })
[13:19:18.975]     if (FALSE) {
[13:19:18.975]         base::sink(type = "output", split = FALSE)
[13:19:18.975]         if (NA) {
[13:19:18.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:18.975]         }
[13:19:18.975]         else {
[13:19:18.975]             ...future.result["stdout"] <- base::list(NULL)
[13:19:18.975]         }
[13:19:18.975]         base::close(...future.stdout)
[13:19:18.975]         ...future.stdout <- NULL
[13:19:18.975]     }
[13:19:18.975]     ...future.result$conditions <- ...future.conditions
[13:19:18.975]     ...future.result$finished <- base::Sys.time()
[13:19:18.975]     ...future.result
[13:19:18.975] }
[13:19:18.977] assign_globals() ...
[13:19:18.977] List of 5
[13:19:18.977]  $ ...future.FUN            :function (x, y)  
[13:19:18.977]  $ MoreArgs                 : NULL
[13:19:18.977]  $ ...future.elements_ii    :List of 2
[13:19:18.977]   ..$ :List of 2
[13:19:18.977]   .. ..$ : int 1
[13:19:18.977]   .. ..$ : int 0
[13:19:18.977]   ..$ :List of 2
[13:19:18.977]   .. ..$ : int 0
[13:19:18.977]   .. ..$ : int 1
[13:19:18.977]  $ ...future.seeds_ii       : NULL
[13:19:18.977]  $ ...future.globals.maxSize: NULL
[13:19:18.977]  - attr(*, "resolved")= logi FALSE
[13:19:18.977]  - attr(*, "total_size")= num 6480
[13:19:18.977]  - attr(*, "where")=List of 5
[13:19:18.977]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:18.977]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:18.977]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:18.977]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:18.977]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:18.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:18.977]  - attr(*, "already-done")= logi TRUE
[13:19:18.982] - reassign environment for ‘...future.FUN’
[13:19:18.982] - copied ‘...future.FUN’ to environment
[13:19:18.983] - copied ‘MoreArgs’ to environment
[13:19:18.983] - copied ‘...future.elements_ii’ to environment
[13:19:18.983] - copied ‘...future.seeds_ii’ to environment
[13:19:18.983] - copied ‘...future.globals.maxSize’ to environment
[13:19:18.983] assign_globals() ... done
[13:19:18.983] plan(): Setting new future strategy stack:
[13:19:18.983] List of future strategies:
[13:19:18.983] 1. sequential:
[13:19:18.983]    - args: function (..., envir = parent.frame())
[13:19:18.983]    - tweaked: FALSE
[13:19:18.983]    - call: NULL
[13:19:18.984] plan(): nbrOfWorkers() = 1
[13:19:19.485] plan(): Setting new future strategy stack:
[13:19:19.485] List of future strategies:
[13:19:19.485] 1. multisession:
[13:19:19.485]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:19.485]    - tweaked: FALSE
[13:19:19.485]    - call: plan(strategy)
[13:19:19.489] plan(): nbrOfWorkers() = 1
[13:19:19.490] SequentialFuture started (and completed)
[13:19:19.490] - Launch lazy future ... done
[13:19:19.490] run() for ‘SequentialFuture’ ... done
[13:19:19.490] Created future:
[13:19:19.490] SequentialFuture:
[13:19:19.490] Label: ‘future_mapply-1’
[13:19:19.490] Expression:
[13:19:19.490] {
[13:19:19.490]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:19.490]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:19.490]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:19.490]         on.exit(options(oopts), add = TRUE)
[13:19:19.490]     }
[13:19:19.490]     {
[13:19:19.490]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:19.490]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:19.490]         do.call(mapply, args = args)
[13:19:19.490]     }
[13:19:19.490] }
[13:19:19.490] Lazy evaluation: FALSE
[13:19:19.490] Asynchronous evaluation: FALSE
[13:19:19.490] Local evaluation: TRUE
[13:19:19.490] Environment: R_GlobalEnv
[13:19:19.490] Capture standard output: NA
[13:19:19.490] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:19.490] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:19.490] Packages: <none>
[13:19:19.490] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:19.490] Resolved: TRUE
[13:19:19.490] Value: 224 bytes of class ‘list’
[13:19:19.490] Early signaling: FALSE
[13:19:19.490] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:19.490] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:19:19.491] Chunk #1 of 1 ... DONE
[13:19:19.491] Launching 1 futures (chunks) ... DONE
[13:19:19.491] Resolving 1 futures (chunks) ...
[13:19:19.491] resolve() on list ...
[13:19:19.492]  recursive: 0
[13:19:19.492]  length: 1
[13:19:19.492] 
[13:19:19.492] resolved() for ‘SequentialFuture’ ...
[13:19:19.492] - state: ‘finished’
[13:19:19.492] - run: TRUE
[13:19:19.492] - result: ‘FutureResult’
[13:19:19.492] resolved() for ‘SequentialFuture’ ... done
[13:19:19.492] Future #1
[13:19:19.492] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:19:19.493] - nx: 1
[13:19:19.493] - relay: TRUE
[13:19:19.493] - stdout: TRUE
[13:19:19.493] - signal: TRUE
[13:19:19.493] - resignal: FALSE
[13:19:19.493] - force: TRUE
[13:19:19.493] - relayed: [n=1] FALSE
[13:19:19.493] - queued futures: [n=1] FALSE
[13:19:19.493]  - until=1
[13:19:19.493]  - relaying element #1
[13:19:19.494] - relayed: [n=1] TRUE
[13:19:19.494] - queued futures: [n=1] TRUE
[13:19:19.494] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:19:19.494]  length: 0 (resolved future 1)
[13:19:19.494] Relaying remaining futures
[13:19:19.494] signalConditionsASAP(NULL, pos=0) ...
[13:19:19.494] - nx: 1
[13:19:19.494] - relay: TRUE
[13:19:19.494] - stdout: TRUE
[13:19:19.494] - signal: TRUE
[13:19:19.494] - resignal: FALSE
[13:19:19.494] - force: TRUE
[13:19:19.495] - relayed: [n=1] TRUE
[13:19:19.495] - queued futures: [n=1] TRUE
 - flush all
[13:19:19.495] - relayed: [n=1] TRUE
[13:19:19.495] - queued futures: [n=1] TRUE
[13:19:19.495] signalConditionsASAP(NULL, pos=0) ... done
[13:19:19.495] resolve() on list ... DONE
[13:19:19.495]  - Number of value chunks collected: 1
[13:19:19.495] Resolving 1 futures (chunks) ... DONE
[13:19:19.495] Reducing values from 1 chunks ...
[13:19:19.495]  - Number of values collected after concatenation: 2
[13:19:19.496]  - Number of values expected: 2
[13:19:19.496] Reducing values from 1 chunks ... DONE
[13:19:19.496] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[13:19:19.501] plan(): Setting new future strategy stack:
[13:19:19.502] List of future strategies:
[13:19:19.502] 1. multicore:
[13:19:19.502]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:19.502]    - tweaked: FALSE
[13:19:19.502]    - call: plan(strategy)
[13:19:19.505] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:19:19.505] future_lapply() ...
[13:19:19.511] Number of chunks: 2
[13:19:19.511] getGlobalsAndPackagesXApply() ...
[13:19:19.511]  - future.globals: TRUE
[13:19:19.511] getGlobalsAndPackages() ...
[13:19:19.511] Searching for globals...
[13:19:19.513] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:19.513] Searching for globals ... DONE
[13:19:19.513] Resolving globals: FALSE
[13:19:19.513] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:19.514] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:19.514] - globals: [1] ‘FUN’
[13:19:19.514] 
[13:19:19.514] getGlobalsAndPackages() ... DONE
[13:19:19.514]  - globals found/used: [n=1] ‘FUN’
[13:19:19.514]  - needed namespaces: [n=0] 
[13:19:19.514] Finding globals ... DONE
[13:19:19.514]  - use_args: TRUE
[13:19:19.515]  - Getting '...' globals ...
[13:19:19.515] resolve() on list ...
[13:19:19.515]  recursive: 0
[13:19:19.515]  length: 1
[13:19:19.515]  elements: ‘...’
[13:19:19.515]  length: 0 (resolved future 1)
[13:19:19.515] resolve() on list ... DONE
[13:19:19.515]    - '...' content: [n=0] 
[13:19:19.516] List of 1
[13:19:19.516]  $ ...: list()
[13:19:19.516]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:19.516]  - attr(*, "where")=List of 1
[13:19:19.516]   ..$ ...:<environment: 0x5620046f9538> 
[13:19:19.516]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:19.516]  - attr(*, "resolved")= logi TRUE
[13:19:19.516]  - attr(*, "total_size")= num NA
[13:19:19.518]  - Getting '...' globals ... DONE
[13:19:19.518] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:19.519] List of 2
[13:19:19.519]  $ ...future.FUN:function (x)  
[13:19:19.519]  $ ...          : list()
[13:19:19.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:19.519]  - attr(*, "where")=List of 2
[13:19:19.519]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:19.519]   ..$ ...          :<environment: 0x5620046f9538> 
[13:19:19.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:19.519]  - attr(*, "resolved")= logi FALSE
[13:19:19.519]  - attr(*, "total_size")= num 4720
[13:19:19.521] Packages to be attached in all futures: [n=0] 
[13:19:19.521] getGlobalsAndPackagesXApply() ... DONE
[13:19:19.522] Number of futures (= number of chunks): 2
[13:19:19.522] Launching 2 futures (chunks) ...
[13:19:19.522] Chunk #1 of 2 ...
[13:19:19.522]  - Finding globals in 'X' for chunk #1 ...
[13:19:19.522] getGlobalsAndPackages() ...
[13:19:19.522] Searching for globals...
[13:19:19.522] 
[13:19:19.522] Searching for globals ... DONE
[13:19:19.523] - globals: [0] <none>
[13:19:19.523] getGlobalsAndPackages() ... DONE
[13:19:19.523]    + additional globals found: [n=0] 
[13:19:19.523]    + additional namespaces needed: [n=0] 
[13:19:19.523]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:19.523]  - seeds: <none>
[13:19:19.523] getGlobalsAndPackages() ...
[13:19:19.523] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:19.523] Resolving globals: FALSE
[13:19:19.523] Tweak future expression to call with '...' arguments ...
[13:19:19.523] {
[13:19:19.523]     do.call(function(...) {
[13:19:19.523]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:19.523]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:19.523]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:19.523]             on.exit(options(oopts), add = TRUE)
[13:19:19.523]         }
[13:19:19.523]         {
[13:19:19.523]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:19.523]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:19.523]                 ...future.FUN(...future.X_jj, ...)
[13:19:19.523]             })
[13:19:19.523]         }
[13:19:19.523]     }, args = future.call.arguments)
[13:19:19.523] }
[13:19:19.524] Tweak future expression to call with '...' arguments ... DONE
[13:19:19.524] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:19.524] 
[13:19:19.524] getGlobalsAndPackages() ... DONE
[13:19:19.525] run() for ‘Future’ ...
[13:19:19.525] - state: ‘created’
[13:19:19.525] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:19.529] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:19.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:19.529]   - Field: ‘label’
[13:19:19.529]   - Field: ‘local’
[13:19:19.529]   - Field: ‘owner’
[13:19:19.529]   - Field: ‘envir’
[13:19:19.529]   - Field: ‘workers’
[13:19:19.529]   - Field: ‘packages’
[13:19:19.529]   - Field: ‘gc’
[13:19:19.531]   - Field: ‘job’
[13:19:19.531]   - Field: ‘conditions’
[13:19:19.531]   - Field: ‘expr’
[13:19:19.532]   - Field: ‘uuid’
[13:19:19.532]   - Field: ‘seed’
[13:19:19.532]   - Field: ‘version’
[13:19:19.532]   - Field: ‘result’
[13:19:19.532]   - Field: ‘asynchronous’
[13:19:19.532]   - Field: ‘calls’
[13:19:19.532]   - Field: ‘globals’
[13:19:19.532]   - Field: ‘stdout’
[13:19:19.532]   - Field: ‘earlySignal’
[13:19:19.533]   - Field: ‘lazy’
[13:19:19.533]   - Field: ‘state’
[13:19:19.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:19.533] - Launch lazy future ...
[13:19:19.534] Packages needed by the future expression (n = 0): <none>
[13:19:19.534] Packages needed by future strategies (n = 0): <none>
[13:19:19.535] {
[13:19:19.535]     {
[13:19:19.535]         {
[13:19:19.535]             ...future.startTime <- base::Sys.time()
[13:19:19.535]             {
[13:19:19.535]                 {
[13:19:19.535]                   {
[13:19:19.535]                     {
[13:19:19.535]                       base::local({
[13:19:19.535]                         has_future <- base::requireNamespace("future", 
[13:19:19.535]                           quietly = TRUE)
[13:19:19.535]                         if (has_future) {
[13:19:19.535]                           ns <- base::getNamespace("future")
[13:19:19.535]                           version <- ns[[".package"]][["version"]]
[13:19:19.535]                           if (is.null(version)) 
[13:19:19.535]                             version <- utils::packageVersion("future")
[13:19:19.535]                         }
[13:19:19.535]                         else {
[13:19:19.535]                           version <- NULL
[13:19:19.535]                         }
[13:19:19.535]                         if (!has_future || version < "1.8.0") {
[13:19:19.535]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:19.535]                             "", base::R.version$version.string), 
[13:19:19.535]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:19.535]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:19.535]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:19.535]                               "release", "version")], collapse = " "), 
[13:19:19.535]                             hostname = base::Sys.info()[["nodename"]])
[13:19:19.535]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:19.535]                             info)
[13:19:19.535]                           info <- base::paste(info, collapse = "; ")
[13:19:19.535]                           if (!has_future) {
[13:19:19.535]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:19.535]                               info)
[13:19:19.535]                           }
[13:19:19.535]                           else {
[13:19:19.535]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:19.535]                               info, version)
[13:19:19.535]                           }
[13:19:19.535]                           base::stop(msg)
[13:19:19.535]                         }
[13:19:19.535]                       })
[13:19:19.535]                     }
[13:19:19.535]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:19.535]                     base::options(mc.cores = 1L)
[13:19:19.535]                   }
[13:19:19.535]                   options(future.plan = NULL)
[13:19:19.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:19.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:19.535]                 }
[13:19:19.535]                 ...future.workdir <- getwd()
[13:19:19.535]             }
[13:19:19.535]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:19.535]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:19.535]         }
[13:19:19.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:19.535]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:19.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:19.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:19.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:19.535]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:19.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:19.535]             base::names(...future.oldOptions))
[13:19:19.535]     }
[13:19:19.535]     if (FALSE) {
[13:19:19.535]     }
[13:19:19.535]     else {
[13:19:19.535]         if (FALSE) {
[13:19:19.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:19.535]                 open = "w")
[13:19:19.535]         }
[13:19:19.535]         else {
[13:19:19.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:19.535]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:19.535]         }
[13:19:19.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:19.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:19.535]             base::sink(type = "output", split = FALSE)
[13:19:19.535]             base::close(...future.stdout)
[13:19:19.535]         }, add = TRUE)
[13:19:19.535]     }
[13:19:19.535]     ...future.frame <- base::sys.nframe()
[13:19:19.535]     ...future.conditions <- base::list()
[13:19:19.535]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:19.535]     if (FALSE) {
[13:19:19.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:19.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:19.535]     }
[13:19:19.535]     ...future.result <- base::tryCatch({
[13:19:19.535]         base::withCallingHandlers({
[13:19:19.535]             ...future.value <- base::withVisible(base::local({
[13:19:19.535]                 withCallingHandlers({
[13:19:19.535]                   {
[13:19:19.535]                     do.call(function(...) {
[13:19:19.535]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:19.535]                       if (!identical(...future.globals.maxSize.org, 
[13:19:19.535]                         ...future.globals.maxSize)) {
[13:19:19.535]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:19.535]                         on.exit(options(oopts), add = TRUE)
[13:19:19.535]                       }
[13:19:19.535]                       {
[13:19:19.535]                         lapply(seq_along(...future.elements_ii), 
[13:19:19.535]                           FUN = function(jj) {
[13:19:19.535]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:19.535]                             ...future.FUN(...future.X_jj, ...)
[13:19:19.535]                           })
[13:19:19.535]                       }
[13:19:19.535]                     }, args = future.call.arguments)
[13:19:19.535]                   }
[13:19:19.535]                 }, immediateCondition = function(cond) {
[13:19:19.535]                   save_rds <- function (object, pathname, ...) 
[13:19:19.535]                   {
[13:19:19.535]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:19.535]                     if (file_test("-f", pathname_tmp)) {
[13:19:19.535]                       fi_tmp <- file.info(pathname_tmp)
[13:19:19.535]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:19.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:19.535]                         fi_tmp[["mtime"]])
[13:19:19.535]                     }
[13:19:19.535]                     tryCatch({
[13:19:19.535]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:19.535]                     }, error = function(ex) {
[13:19:19.535]                       msg <- conditionMessage(ex)
[13:19:19.535]                       fi_tmp <- file.info(pathname_tmp)
[13:19:19.535]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:19.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:19.535]                         fi_tmp[["mtime"]], msg)
[13:19:19.535]                       ex$message <- msg
[13:19:19.535]                       stop(ex)
[13:19:19.535]                     })
[13:19:19.535]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:19.535]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:19.535]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:19.535]                       fi_tmp <- file.info(pathname_tmp)
[13:19:19.535]                       fi <- file.info(pathname)
[13:19:19.535]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:19.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:19.535]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:19.535]                         fi[["size"]], fi[["mtime"]])
[13:19:19.535]                       stop(msg)
[13:19:19.535]                     }
[13:19:19.535]                     invisible(pathname)
[13:19:19.535]                   }
[13:19:19.535]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:19.535]                     rootPath = tempdir()) 
[13:19:19.535]                   {
[13:19:19.535]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:19.535]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:19.535]                       tmpdir = path, fileext = ".rds")
[13:19:19.535]                     save_rds(obj, file)
[13:19:19.535]                   }
[13:19:19.535]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:19.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:19.535]                   {
[13:19:19.535]                     inherits <- base::inherits
[13:19:19.535]                     invokeRestart <- base::invokeRestart
[13:19:19.535]                     is.null <- base::is.null
[13:19:19.535]                     muffled <- FALSE
[13:19:19.535]                     if (inherits(cond, "message")) {
[13:19:19.535]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:19.535]                       if (muffled) 
[13:19:19.535]                         invokeRestart("muffleMessage")
[13:19:19.535]                     }
[13:19:19.535]                     else if (inherits(cond, "warning")) {
[13:19:19.535]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:19.535]                       if (muffled) 
[13:19:19.535]                         invokeRestart("muffleWarning")
[13:19:19.535]                     }
[13:19:19.535]                     else if (inherits(cond, "condition")) {
[13:19:19.535]                       if (!is.null(pattern)) {
[13:19:19.535]                         computeRestarts <- base::computeRestarts
[13:19:19.535]                         grepl <- base::grepl
[13:19:19.535]                         restarts <- computeRestarts(cond)
[13:19:19.535]                         for (restart in restarts) {
[13:19:19.535]                           name <- restart$name
[13:19:19.535]                           if (is.null(name)) 
[13:19:19.535]                             next
[13:19:19.535]                           if (!grepl(pattern, name)) 
[13:19:19.535]                             next
[13:19:19.535]                           invokeRestart(restart)
[13:19:19.535]                           muffled <- TRUE
[13:19:19.535]                           break
[13:19:19.535]                         }
[13:19:19.535]                       }
[13:19:19.535]                     }
[13:19:19.535]                     invisible(muffled)
[13:19:19.535]                   }
[13:19:19.535]                   muffleCondition(cond)
[13:19:19.535]                 })
[13:19:19.535]             }))
[13:19:19.535]             future::FutureResult(value = ...future.value$value, 
[13:19:19.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:19.535]                   ...future.rng), globalenv = if (FALSE) 
[13:19:19.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:19.535]                     ...future.globalenv.names))
[13:19:19.535]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:19.535]         }, condition = base::local({
[13:19:19.535]             c <- base::c
[13:19:19.535]             inherits <- base::inherits
[13:19:19.535]             invokeRestart <- base::invokeRestart
[13:19:19.535]             length <- base::length
[13:19:19.535]             list <- base::list
[13:19:19.535]             seq.int <- base::seq.int
[13:19:19.535]             signalCondition <- base::signalCondition
[13:19:19.535]             sys.calls <- base::sys.calls
[13:19:19.535]             `[[` <- base::`[[`
[13:19:19.535]             `+` <- base::`+`
[13:19:19.535]             `<<-` <- base::`<<-`
[13:19:19.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:19.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:19.535]                   3L)]
[13:19:19.535]             }
[13:19:19.535]             function(cond) {
[13:19:19.535]                 is_error <- inherits(cond, "error")
[13:19:19.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:19.535]                   NULL)
[13:19:19.535]                 if (is_error) {
[13:19:19.535]                   sessionInformation <- function() {
[13:19:19.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:19.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:19.535]                       search = base::search(), system = base::Sys.info())
[13:19:19.535]                   }
[13:19:19.535]                   ...future.conditions[[length(...future.conditions) + 
[13:19:19.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:19.535]                     cond$call), session = sessionInformation(), 
[13:19:19.535]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:19.535]                   signalCondition(cond)
[13:19:19.535]                 }
[13:19:19.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:19.535]                 "immediateCondition"))) {
[13:19:19.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:19.535]                   ...future.conditions[[length(...future.conditions) + 
[13:19:19.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:19.535]                   if (TRUE && !signal) {
[13:19:19.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:19.535]                     {
[13:19:19.535]                       inherits <- base::inherits
[13:19:19.535]                       invokeRestart <- base::invokeRestart
[13:19:19.535]                       is.null <- base::is.null
[13:19:19.535]                       muffled <- FALSE
[13:19:19.535]                       if (inherits(cond, "message")) {
[13:19:19.535]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:19.535]                         if (muffled) 
[13:19:19.535]                           invokeRestart("muffleMessage")
[13:19:19.535]                       }
[13:19:19.535]                       else if (inherits(cond, "warning")) {
[13:19:19.535]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:19.535]                         if (muffled) 
[13:19:19.535]                           invokeRestart("muffleWarning")
[13:19:19.535]                       }
[13:19:19.535]                       else if (inherits(cond, "condition")) {
[13:19:19.535]                         if (!is.null(pattern)) {
[13:19:19.535]                           computeRestarts <- base::computeRestarts
[13:19:19.535]                           grepl <- base::grepl
[13:19:19.535]                           restarts <- computeRestarts(cond)
[13:19:19.535]                           for (restart in restarts) {
[13:19:19.535]                             name <- restart$name
[13:19:19.535]                             if (is.null(name)) 
[13:19:19.535]                               next
[13:19:19.535]                             if (!grepl(pattern, name)) 
[13:19:19.535]                               next
[13:19:19.535]                             invokeRestart(restart)
[13:19:19.535]                             muffled <- TRUE
[13:19:19.535]                             break
[13:19:19.535]                           }
[13:19:19.535]                         }
[13:19:19.535]                       }
[13:19:19.535]                       invisible(muffled)
[13:19:19.535]                     }
[13:19:19.535]                     muffleCondition(cond, pattern = "^muffle")
[13:19:19.535]                   }
[13:19:19.535]                 }
[13:19:19.535]                 else {
[13:19:19.535]                   if (TRUE) {
[13:19:19.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:19.535]                     {
[13:19:19.535]                       inherits <- base::inherits
[13:19:19.535]                       invokeRestart <- base::invokeRestart
[13:19:19.535]                       is.null <- base::is.null
[13:19:19.535]                       muffled <- FALSE
[13:19:19.535]                       if (inherits(cond, "message")) {
[13:19:19.535]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:19.535]                         if (muffled) 
[13:19:19.535]                           invokeRestart("muffleMessage")
[13:19:19.535]                       }
[13:19:19.535]                       else if (inherits(cond, "warning")) {
[13:19:19.535]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:19.535]                         if (muffled) 
[13:19:19.535]                           invokeRestart("muffleWarning")
[13:19:19.535]                       }
[13:19:19.535]                       else if (inherits(cond, "condition")) {
[13:19:19.535]                         if (!is.null(pattern)) {
[13:19:19.535]                           computeRestarts <- base::computeRestarts
[13:19:19.535]                           grepl <- base::grepl
[13:19:19.535]                           restarts <- computeRestarts(cond)
[13:19:19.535]                           for (restart in restarts) {
[13:19:19.535]                             name <- restart$name
[13:19:19.535]                             if (is.null(name)) 
[13:19:19.535]                               next
[13:19:19.535]                             if (!grepl(pattern, name)) 
[13:19:19.535]                               next
[13:19:19.535]                             invokeRestart(restart)
[13:19:19.535]                             muffled <- TRUE
[13:19:19.535]                             break
[13:19:19.535]                           }
[13:19:19.535]                         }
[13:19:19.535]                       }
[13:19:19.535]                       invisible(muffled)
[13:19:19.535]                     }
[13:19:19.535]                     muffleCondition(cond, pattern = "^muffle")
[13:19:19.535]                   }
[13:19:19.535]                 }
[13:19:19.535]             }
[13:19:19.535]         }))
[13:19:19.535]     }, error = function(ex) {
[13:19:19.535]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:19.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:19.535]                 ...future.rng), started = ...future.startTime, 
[13:19:19.535]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:19.535]             version = "1.8"), class = "FutureResult")
[13:19:19.535]     }, finally = {
[13:19:19.535]         if (!identical(...future.workdir, getwd())) 
[13:19:19.535]             setwd(...future.workdir)
[13:19:19.535]         {
[13:19:19.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:19.535]                 ...future.oldOptions$nwarnings <- NULL
[13:19:19.535]             }
[13:19:19.535]             base::options(...future.oldOptions)
[13:19:19.535]             if (.Platform$OS.type == "windows") {
[13:19:19.535]                 old_names <- names(...future.oldEnvVars)
[13:19:19.535]                 envs <- base::Sys.getenv()
[13:19:19.535]                 names <- names(envs)
[13:19:19.535]                 common <- intersect(names, old_names)
[13:19:19.535]                 added <- setdiff(names, old_names)
[13:19:19.535]                 removed <- setdiff(old_names, names)
[13:19:19.535]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:19.535]                   envs[common]]
[13:19:19.535]                 NAMES <- toupper(changed)
[13:19:19.535]                 args <- list()
[13:19:19.535]                 for (kk in seq_along(NAMES)) {
[13:19:19.535]                   name <- changed[[kk]]
[13:19:19.535]                   NAME <- NAMES[[kk]]
[13:19:19.535]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:19.535]                     next
[13:19:19.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:19.535]                 }
[13:19:19.535]                 NAMES <- toupper(added)
[13:19:19.535]                 for (kk in seq_along(NAMES)) {
[13:19:19.535]                   name <- added[[kk]]
[13:19:19.535]                   NAME <- NAMES[[kk]]
[13:19:19.535]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:19.535]                     next
[13:19:19.535]                   args[[name]] <- ""
[13:19:19.535]                 }
[13:19:19.535]                 NAMES <- toupper(removed)
[13:19:19.535]                 for (kk in seq_along(NAMES)) {
[13:19:19.535]                   name <- removed[[kk]]
[13:19:19.535]                   NAME <- NAMES[[kk]]
[13:19:19.535]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:19.535]                     next
[13:19:19.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:19.535]                 }
[13:19:19.535]                 if (length(args) > 0) 
[13:19:19.535]                   base::do.call(base::Sys.setenv, args = args)
[13:19:19.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:19.535]             }
[13:19:19.535]             else {
[13:19:19.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:19.535]             }
[13:19:19.535]             {
[13:19:19.535]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:19.535]                   0L) {
[13:19:19.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:19.535]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:19.535]                   base::options(opts)
[13:19:19.535]                 }
[13:19:19.535]                 {
[13:19:19.535]                   {
[13:19:19.535]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:19.535]                     NULL
[13:19:19.535]                   }
[13:19:19.535]                   options(future.plan = NULL)
[13:19:19.535]                   if (is.na(NA_character_)) 
[13:19:19.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:19.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:19.535]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:19.535]                     envir = parent.frame()) 
[13:19:19.535]                   {
[13:19:19.535]                     default_workers <- missing(workers)
[13:19:19.535]                     if (is.function(workers)) 
[13:19:19.535]                       workers <- workers()
[13:19:19.535]                     workers <- structure(as.integer(workers), 
[13:19:19.535]                       class = class(workers))
[13:19:19.535]                     stop_if_not(is.finite(workers), workers >= 
[13:19:19.535]                       1L)
[13:19:19.535]                     if ((workers == 1L && !inherits(workers, 
[13:19:19.535]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:19.535]                       if (default_workers) 
[13:19:19.535]                         supportsMulticore(warn = TRUE)
[13:19:19.535]                       return(sequential(..., envir = envir))
[13:19:19.535]                     }
[13:19:19.535]                     oopts <- options(mc.cores = workers)
[13:19:19.535]                     on.exit(options(oopts))
[13:19:19.535]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:19.535]                       envir = envir)
[13:19:19.535]                     if (!future$lazy) 
[13:19:19.535]                       future <- run(future)
[13:19:19.535]                     invisible(future)
[13:19:19.535]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:19.535]                 }
[13:19:19.535]             }
[13:19:19.535]         }
[13:19:19.535]     })
[13:19:19.535]     if (TRUE) {
[13:19:19.535]         base::sink(type = "output", split = FALSE)
[13:19:19.535]         if (FALSE) {
[13:19:19.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:19.535]         }
[13:19:19.535]         else {
[13:19:19.535]             ...future.result["stdout"] <- base::list(NULL)
[13:19:19.535]         }
[13:19:19.535]         base::close(...future.stdout)
[13:19:19.535]         ...future.stdout <- NULL
[13:19:19.535]     }
[13:19:19.535]     ...future.result$conditions <- ...future.conditions
[13:19:19.535]     ...future.result$finished <- base::Sys.time()
[13:19:19.535]     ...future.result
[13:19:19.535] }
[13:19:19.537] assign_globals() ...
[13:19:19.537] List of 5
[13:19:19.537]  $ ...future.FUN            :function (x)  
[13:19:19.537]  $ future.call.arguments    : list()
[13:19:19.537]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:19.537]  $ ...future.elements_ii    :List of 1
[13:19:19.537]   ..$ : int 1
[13:19:19.537]  $ ...future.seeds_ii       : NULL
[13:19:19.537]  $ ...future.globals.maxSize: NULL
[13:19:19.537]  - attr(*, "where")=List of 5
[13:19:19.537]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:19.537]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:19.537]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:19.537]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:19.537]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:19.537]  - attr(*, "resolved")= logi FALSE
[13:19:19.537]  - attr(*, "total_size")= num 4720
[13:19:19.537]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:19.537]  - attr(*, "already-done")= logi TRUE
[13:19:19.542] - reassign environment for ‘...future.FUN’
[13:19:19.542] - copied ‘...future.FUN’ to environment
[13:19:19.542] - copied ‘future.call.arguments’ to environment
[13:19:19.542] - copied ‘...future.elements_ii’ to environment
[13:19:19.542] - copied ‘...future.seeds_ii’ to environment
[13:19:19.542] - copied ‘...future.globals.maxSize’ to environment
[13:19:19.543] assign_globals() ... done
[13:19:19.543] requestCore(): workers = 2
[13:19:19.546] MulticoreFuture started
[13:19:19.546] - Launch lazy future ... done
[13:19:19.546] run() for ‘MulticoreFuture’ ... done
[13:19:19.547] plan(): Setting new future strategy stack:
[13:19:19.547] Created future:
[13:19:19.547] List of future strategies:
[13:19:19.547] 1. sequential:
[13:19:19.547]    - args: function (..., envir = parent.frame())
[13:19:19.547]    - tweaked: FALSE
[13:19:19.547]    - call: NULL
[13:19:19.548] plan(): nbrOfWorkers() = 1
[13:19:19.547] MulticoreFuture:
[13:19:19.547] Label: ‘future_lapply-1’
[13:19:19.547] Expression:
[13:19:19.547] {
[13:19:19.547]     do.call(function(...) {
[13:19:19.547]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:19.547]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:19.547]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:19.547]             on.exit(options(oopts), add = TRUE)
[13:19:19.547]         }
[13:19:19.547]         {
[13:19:19.547]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:19.547]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:19.547]                 ...future.FUN(...future.X_jj, ...)
[13:19:19.547]             })
[13:19:19.547]         }
[13:19:19.547]     }, args = future.call.arguments)
[13:19:19.547] }
[13:19:19.547] Lazy evaluation: FALSE
[13:19:19.547] Asynchronous evaluation: TRUE
[13:19:19.547] Local evaluation: TRUE
[13:19:19.547] Environment: R_GlobalEnv
[13:19:19.547] Capture standard output: FALSE
[13:19:19.547] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:19.547] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:19.547] Packages: <none>
[13:19:19.547] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:19.547] Resolved: FALSE
[13:19:19.547] Value: <not collected>
[13:19:19.547] Conditions captured: <none>
[13:19:19.547] Early signaling: FALSE
[13:19:19.547] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:19.547] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:19.561] Chunk #1 of 2 ... DONE
[13:19:19.561] Chunk #2 of 2 ...
[13:19:19.562]  - Finding globals in 'X' for chunk #2 ...
[13:19:19.562] getGlobalsAndPackages() ...
[13:19:19.562] Searching for globals...
[13:19:19.562] 
[13:19:19.562] Searching for globals ... DONE
[13:19:19.563] - globals: [0] <none>
[13:19:19.563] getGlobalsAndPackages() ... DONE
[13:19:19.563]    + additional globals found: [n=0] 
[13:19:19.563]    + additional namespaces needed: [n=0] 
[13:19:19.563]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:19.563]  - seeds: <none>
[13:19:19.563] getGlobalsAndPackages() ...
[13:19:19.564] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:19.564] Resolving globals: FALSE
[13:19:19.564] Tweak future expression to call with '...' arguments ...
[13:19:19.564] {
[13:19:19.564]     do.call(function(...) {
[13:19:19.564]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:19.564]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:19.564]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:19.564]             on.exit(options(oopts), add = TRUE)
[13:19:19.564]         }
[13:19:19.564]         {
[13:19:19.564]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:19.564]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:19.564]                 ...future.FUN(...future.X_jj, ...)
[13:19:19.564]             })
[13:19:19.564]         }
[13:19:19.564]     }, args = future.call.arguments)
[13:19:19.564] }
[13:19:19.565] Tweak future expression to call with '...' arguments ... DONE
[13:19:19.565] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:19.565] 
[13:19:19.566] getGlobalsAndPackages() ... DONE
[13:19:19.566] run() for ‘Future’ ...
[13:19:19.566] - state: ‘created’
[13:19:19.566] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:19.571] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:19.571] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:19.572]   - Field: ‘label’
[13:19:19.572]   - Field: ‘local’
[13:19:19.572]   - Field: ‘owner’
[13:19:19.572]   - Field: ‘envir’
[13:19:19.572]   - Field: ‘workers’
[13:19:19.572]   - Field: ‘packages’
[13:19:19.572]   - Field: ‘gc’
[13:19:19.573]   - Field: ‘job’
[13:19:19.573]   - Field: ‘conditions’
[13:19:19.573]   - Field: ‘expr’
[13:19:19.573]   - Field: ‘uuid’
[13:19:19.573]   - Field: ‘seed’
[13:19:19.573]   - Field: ‘version’
[13:19:19.573]   - Field: ‘result’
[13:19:19.574]   - Field: ‘asynchronous’
[13:19:19.574]   - Field: ‘calls’
[13:19:19.574]   - Field: ‘globals’
[13:19:19.574]   - Field: ‘stdout’
[13:19:19.574]   - Field: ‘earlySignal’
[13:19:19.574]   - Field: ‘lazy’
[13:19:19.574]   - Field: ‘state’
[13:19:19.575] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:19.575] - Launch lazy future ...
[13:19:19.575] Packages needed by the future expression (n = 0): <none>
[13:19:19.575] Packages needed by future strategies (n = 0): <none>
[13:19:19.576] {
[13:19:19.576]     {
[13:19:19.576]         {
[13:19:19.576]             ...future.startTime <- base::Sys.time()
[13:19:19.576]             {
[13:19:19.576]                 {
[13:19:19.576]                   {
[13:19:19.576]                     {
[13:19:19.576]                       base::local({
[13:19:19.576]                         has_future <- base::requireNamespace("future", 
[13:19:19.576]                           quietly = TRUE)
[13:19:19.576]                         if (has_future) {
[13:19:19.576]                           ns <- base::getNamespace("future")
[13:19:19.576]                           version <- ns[[".package"]][["version"]]
[13:19:19.576]                           if (is.null(version)) 
[13:19:19.576]                             version <- utils::packageVersion("future")
[13:19:19.576]                         }
[13:19:19.576]                         else {
[13:19:19.576]                           version <- NULL
[13:19:19.576]                         }
[13:19:19.576]                         if (!has_future || version < "1.8.0") {
[13:19:19.576]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:19.576]                             "", base::R.version$version.string), 
[13:19:19.576]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:19.576]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:19.576]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:19.576]                               "release", "version")], collapse = " "), 
[13:19:19.576]                             hostname = base::Sys.info()[["nodename"]])
[13:19:19.576]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:19.576]                             info)
[13:19:19.576]                           info <- base::paste(info, collapse = "; ")
[13:19:19.576]                           if (!has_future) {
[13:19:19.576]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:19.576]                               info)
[13:19:19.576]                           }
[13:19:19.576]                           else {
[13:19:19.576]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:19.576]                               info, version)
[13:19:19.576]                           }
[13:19:19.576]                           base::stop(msg)
[13:19:19.576]                         }
[13:19:19.576]                       })
[13:19:19.576]                     }
[13:19:19.576]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:19.576]                     base::options(mc.cores = 1L)
[13:19:19.576]                   }
[13:19:19.576]                   options(future.plan = NULL)
[13:19:19.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:19.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:19.576]                 }
[13:19:19.576]                 ...future.workdir <- getwd()
[13:19:19.576]             }
[13:19:19.576]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:19.576]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:19.576]         }
[13:19:19.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:19.576]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:19.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:19.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:19.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:19.576]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:19.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:19.576]             base::names(...future.oldOptions))
[13:19:19.576]     }
[13:19:19.576]     if (FALSE) {
[13:19:19.576]     }
[13:19:19.576]     else {
[13:19:19.576]         if (FALSE) {
[13:19:19.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:19.576]                 open = "w")
[13:19:19.576]         }
[13:19:19.576]         else {
[13:19:19.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:19.576]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:19.576]         }
[13:19:19.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:19.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:19.576]             base::sink(type = "output", split = FALSE)
[13:19:19.576]             base::close(...future.stdout)
[13:19:19.576]         }, add = TRUE)
[13:19:19.576]     }
[13:19:19.576]     ...future.frame <- base::sys.nframe()
[13:19:19.576]     ...future.conditions <- base::list()
[13:19:19.576]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:19.576]     if (FALSE) {
[13:19:19.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:19.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:19.576]     }
[13:19:19.576]     ...future.result <- base::tryCatch({
[13:19:19.576]         base::withCallingHandlers({
[13:19:19.576]             ...future.value <- base::withVisible(base::local({
[13:19:19.576]                 withCallingHandlers({
[13:19:19.576]                   {
[13:19:19.576]                     do.call(function(...) {
[13:19:19.576]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:19.576]                       if (!identical(...future.globals.maxSize.org, 
[13:19:19.576]                         ...future.globals.maxSize)) {
[13:19:19.576]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:19.576]                         on.exit(options(oopts), add = TRUE)
[13:19:19.576]                       }
[13:19:19.576]                       {
[13:19:19.576]                         lapply(seq_along(...future.elements_ii), 
[13:19:19.576]                           FUN = function(jj) {
[13:19:19.576]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:19.576]                             ...future.FUN(...future.X_jj, ...)
[13:19:19.576]                           })
[13:19:19.576]                       }
[13:19:19.576]                     }, args = future.call.arguments)
[13:19:19.576]                   }
[13:19:19.576]                 }, immediateCondition = function(cond) {
[13:19:19.576]                   save_rds <- function (object, pathname, ...) 
[13:19:19.576]                   {
[13:19:19.576]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:19.576]                     if (file_test("-f", pathname_tmp)) {
[13:19:19.576]                       fi_tmp <- file.info(pathname_tmp)
[13:19:19.576]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:19.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:19.576]                         fi_tmp[["mtime"]])
[13:19:19.576]                     }
[13:19:19.576]                     tryCatch({
[13:19:19.576]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:19.576]                     }, error = function(ex) {
[13:19:19.576]                       msg <- conditionMessage(ex)
[13:19:19.576]                       fi_tmp <- file.info(pathname_tmp)
[13:19:19.576]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:19.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:19.576]                         fi_tmp[["mtime"]], msg)
[13:19:19.576]                       ex$message <- msg
[13:19:19.576]                       stop(ex)
[13:19:19.576]                     })
[13:19:19.576]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:19.576]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:19.576]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:19.576]                       fi_tmp <- file.info(pathname_tmp)
[13:19:19.576]                       fi <- file.info(pathname)
[13:19:19.576]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:19.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:19.576]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:19.576]                         fi[["size"]], fi[["mtime"]])
[13:19:19.576]                       stop(msg)
[13:19:19.576]                     }
[13:19:19.576]                     invisible(pathname)
[13:19:19.576]                   }
[13:19:19.576]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:19.576]                     rootPath = tempdir()) 
[13:19:19.576]                   {
[13:19:19.576]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:19.576]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:19.576]                       tmpdir = path, fileext = ".rds")
[13:19:19.576]                     save_rds(obj, file)
[13:19:19.576]                   }
[13:19:19.576]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:19.576]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:19.576]                   {
[13:19:19.576]                     inherits <- base::inherits
[13:19:19.576]                     invokeRestart <- base::invokeRestart
[13:19:19.576]                     is.null <- base::is.null
[13:19:19.576]                     muffled <- FALSE
[13:19:19.576]                     if (inherits(cond, "message")) {
[13:19:19.576]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:19.576]                       if (muffled) 
[13:19:19.576]                         invokeRestart("muffleMessage")
[13:19:19.576]                     }
[13:19:19.576]                     else if (inherits(cond, "warning")) {
[13:19:19.576]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:19.576]                       if (muffled) 
[13:19:19.576]                         invokeRestart("muffleWarning")
[13:19:19.576]                     }
[13:19:19.576]                     else if (inherits(cond, "condition")) {
[13:19:19.576]                       if (!is.null(pattern)) {
[13:19:19.576]                         computeRestarts <- base::computeRestarts
[13:19:19.576]                         grepl <- base::grepl
[13:19:19.576]                         restarts <- computeRestarts(cond)
[13:19:19.576]                         for (restart in restarts) {
[13:19:19.576]                           name <- restart$name
[13:19:19.576]                           if (is.null(name)) 
[13:19:19.576]                             next
[13:19:19.576]                           if (!grepl(pattern, name)) 
[13:19:19.576]                             next
[13:19:19.576]                           invokeRestart(restart)
[13:19:19.576]                           muffled <- TRUE
[13:19:19.576]                           break
[13:19:19.576]                         }
[13:19:19.576]                       }
[13:19:19.576]                     }
[13:19:19.576]                     invisible(muffled)
[13:19:19.576]                   }
[13:19:19.576]                   muffleCondition(cond)
[13:19:19.576]                 })
[13:19:19.576]             }))
[13:19:19.576]             future::FutureResult(value = ...future.value$value, 
[13:19:19.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:19.576]                   ...future.rng), globalenv = if (FALSE) 
[13:19:19.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:19.576]                     ...future.globalenv.names))
[13:19:19.576]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:19.576]         }, condition = base::local({
[13:19:19.576]             c <- base::c
[13:19:19.576]             inherits <- base::inherits
[13:19:19.576]             invokeRestart <- base::invokeRestart
[13:19:19.576]             length <- base::length
[13:19:19.576]             list <- base::list
[13:19:19.576]             seq.int <- base::seq.int
[13:19:19.576]             signalCondition <- base::signalCondition
[13:19:19.576]             sys.calls <- base::sys.calls
[13:19:19.576]             `[[` <- base::`[[`
[13:19:19.576]             `+` <- base::`+`
[13:19:19.576]             `<<-` <- base::`<<-`
[13:19:19.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:19.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:19.576]                   3L)]
[13:19:19.576]             }
[13:19:19.576]             function(cond) {
[13:19:19.576]                 is_error <- inherits(cond, "error")
[13:19:19.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:19.576]                   NULL)
[13:19:19.576]                 if (is_error) {
[13:19:19.576]                   sessionInformation <- function() {
[13:19:19.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:19.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:19.576]                       search = base::search(), system = base::Sys.info())
[13:19:19.576]                   }
[13:19:19.576]                   ...future.conditions[[length(...future.conditions) + 
[13:19:19.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:19.576]                     cond$call), session = sessionInformation(), 
[13:19:19.576]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:19.576]                   signalCondition(cond)
[13:19:19.576]                 }
[13:19:19.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:19.576]                 "immediateCondition"))) {
[13:19:19.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:19.576]                   ...future.conditions[[length(...future.conditions) + 
[13:19:19.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:19.576]                   if (TRUE && !signal) {
[13:19:19.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:19.576]                     {
[13:19:19.576]                       inherits <- base::inherits
[13:19:19.576]                       invokeRestart <- base::invokeRestart
[13:19:19.576]                       is.null <- base::is.null
[13:19:19.576]                       muffled <- FALSE
[13:19:19.576]                       if (inherits(cond, "message")) {
[13:19:19.576]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:19.576]                         if (muffled) 
[13:19:19.576]                           invokeRestart("muffleMessage")
[13:19:19.576]                       }
[13:19:19.576]                       else if (inherits(cond, "warning")) {
[13:19:19.576]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:19.576]                         if (muffled) 
[13:19:19.576]                           invokeRestart("muffleWarning")
[13:19:19.576]                       }
[13:19:19.576]                       else if (inherits(cond, "condition")) {
[13:19:19.576]                         if (!is.null(pattern)) {
[13:19:19.576]                           computeRestarts <- base::computeRestarts
[13:19:19.576]                           grepl <- base::grepl
[13:19:19.576]                           restarts <- computeRestarts(cond)
[13:19:19.576]                           for (restart in restarts) {
[13:19:19.576]                             name <- restart$name
[13:19:19.576]                             if (is.null(name)) 
[13:19:19.576]                               next
[13:19:19.576]                             if (!grepl(pattern, name)) 
[13:19:19.576]                               next
[13:19:19.576]                             invokeRestart(restart)
[13:19:19.576]                             muffled <- TRUE
[13:19:19.576]                             break
[13:19:19.576]                           }
[13:19:19.576]                         }
[13:19:19.576]                       }
[13:19:19.576]                       invisible(muffled)
[13:19:19.576]                     }
[13:19:19.576]                     muffleCondition(cond, pattern = "^muffle")
[13:19:19.576]                   }
[13:19:19.576]                 }
[13:19:19.576]                 else {
[13:19:19.576]                   if (TRUE) {
[13:19:19.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:19.576]                     {
[13:19:19.576]                       inherits <- base::inherits
[13:19:19.576]                       invokeRestart <- base::invokeRestart
[13:19:19.576]                       is.null <- base::is.null
[13:19:19.576]                       muffled <- FALSE
[13:19:19.576]                       if (inherits(cond, "message")) {
[13:19:19.576]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:19.576]                         if (muffled) 
[13:19:19.576]                           invokeRestart("muffleMessage")
[13:19:19.576]                       }
[13:19:19.576]                       else if (inherits(cond, "warning")) {
[13:19:19.576]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:19.576]                         if (muffled) 
[13:19:19.576]                           invokeRestart("muffleWarning")
[13:19:19.576]                       }
[13:19:19.576]                       else if (inherits(cond, "condition")) {
[13:19:19.576]                         if (!is.null(pattern)) {
[13:19:19.576]                           computeRestarts <- base::computeRestarts
[13:19:19.576]                           grepl <- base::grepl
[13:19:19.576]                           restarts <- computeRestarts(cond)
[13:19:19.576]                           for (restart in restarts) {
[13:19:19.576]                             name <- restart$name
[13:19:19.576]                             if (is.null(name)) 
[13:19:19.576]                               next
[13:19:19.576]                             if (!grepl(pattern, name)) 
[13:19:19.576]                               next
[13:19:19.576]                             invokeRestart(restart)
[13:19:19.576]                             muffled <- TRUE
[13:19:19.576]                             break
[13:19:19.576]                           }
[13:19:19.576]                         }
[13:19:19.576]                       }
[13:19:19.576]                       invisible(muffled)
[13:19:19.576]                     }
[13:19:19.576]                     muffleCondition(cond, pattern = "^muffle")
[13:19:19.576]                   }
[13:19:19.576]                 }
[13:19:19.576]             }
[13:19:19.576]         }))
[13:19:19.576]     }, error = function(ex) {
[13:19:19.576]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:19.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:19.576]                 ...future.rng), started = ...future.startTime, 
[13:19:19.576]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:19.576]             version = "1.8"), class = "FutureResult")
[13:19:19.576]     }, finally = {
[13:19:19.576]         if (!identical(...future.workdir, getwd())) 
[13:19:19.576]             setwd(...future.workdir)
[13:19:19.576]         {
[13:19:19.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:19.576]                 ...future.oldOptions$nwarnings <- NULL
[13:19:19.576]             }
[13:19:19.576]             base::options(...future.oldOptions)
[13:19:19.576]             if (.Platform$OS.type == "windows") {
[13:19:19.576]                 old_names <- names(...future.oldEnvVars)
[13:19:19.576]                 envs <- base::Sys.getenv()
[13:19:19.576]                 names <- names(envs)
[13:19:19.576]                 common <- intersect(names, old_names)
[13:19:19.576]                 added <- setdiff(names, old_names)
[13:19:19.576]                 removed <- setdiff(old_names, names)
[13:19:19.576]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:19.576]                   envs[common]]
[13:19:19.576]                 NAMES <- toupper(changed)
[13:19:19.576]                 args <- list()
[13:19:19.576]                 for (kk in seq_along(NAMES)) {
[13:19:19.576]                   name <- changed[[kk]]
[13:19:19.576]                   NAME <- NAMES[[kk]]
[13:19:19.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:19.576]                     next
[13:19:19.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:19.576]                 }
[13:19:19.576]                 NAMES <- toupper(added)
[13:19:19.576]                 for (kk in seq_along(NAMES)) {
[13:19:19.576]                   name <- added[[kk]]
[13:19:19.576]                   NAME <- NAMES[[kk]]
[13:19:19.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:19.576]                     next
[13:19:19.576]                   args[[name]] <- ""
[13:19:19.576]                 }
[13:19:19.576]                 NAMES <- toupper(removed)
[13:19:19.576]                 for (kk in seq_along(NAMES)) {
[13:19:19.576]                   name <- removed[[kk]]
[13:19:19.576]                   NAME <- NAMES[[kk]]
[13:19:19.576]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:19.576]                     next
[13:19:19.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:19.576]                 }
[13:19:19.576]                 if (length(args) > 0) 
[13:19:19.576]                   base::do.call(base::Sys.setenv, args = args)
[13:19:19.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:19.576]             }
[13:19:19.576]             else {
[13:19:19.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:19.576]             }
[13:19:19.576]             {
[13:19:19.576]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:19.576]                   0L) {
[13:19:19.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:19.576]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:19.576]                   base::options(opts)
[13:19:19.576]                 }
[13:19:19.576]                 {
[13:19:19.576]                   {
[13:19:19.576]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:19.576]                     NULL
[13:19:19.576]                   }
[13:19:19.576]                   options(future.plan = NULL)
[13:19:19.576]                   if (is.na(NA_character_)) 
[13:19:19.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:19.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:19.576]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:19.576]                     envir = parent.frame()) 
[13:19:19.576]                   {
[13:19:19.576]                     default_workers <- missing(workers)
[13:19:19.576]                     if (is.function(workers)) 
[13:19:19.576]                       workers <- workers()
[13:19:19.576]                     workers <- structure(as.integer(workers), 
[13:19:19.576]                       class = class(workers))
[13:19:19.576]                     stop_if_not(is.finite(workers), workers >= 
[13:19:19.576]                       1L)
[13:19:19.576]                     if ((workers == 1L && !inherits(workers, 
[13:19:19.576]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:19.576]                       if (default_workers) 
[13:19:19.576]                         supportsMulticore(warn = TRUE)
[13:19:19.576]                       return(sequential(..., envir = envir))
[13:19:19.576]                     }
[13:19:19.576]                     oopts <- options(mc.cores = workers)
[13:19:19.576]                     on.exit(options(oopts))
[13:19:19.576]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:19.576]                       envir = envir)
[13:19:19.576]                     if (!future$lazy) 
[13:19:19.576]                       future <- run(future)
[13:19:19.576]                     invisible(future)
[13:19:19.576]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:19.576]                 }
[13:19:19.576]             }
[13:19:19.576]         }
[13:19:19.576]     })
[13:19:19.576]     if (TRUE) {
[13:19:19.576]         base::sink(type = "output", split = FALSE)
[13:19:19.576]         if (FALSE) {
[13:19:19.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:19.576]         }
[13:19:19.576]         else {
[13:19:19.576]             ...future.result["stdout"] <- base::list(NULL)
[13:19:19.576]         }
[13:19:19.576]         base::close(...future.stdout)
[13:19:19.576]         ...future.stdout <- NULL
[13:19:19.576]     }
[13:19:19.576]     ...future.result$conditions <- ...future.conditions
[13:19:19.576]     ...future.result$finished <- base::Sys.time()
[13:19:19.576]     ...future.result
[13:19:19.576] }
[13:19:19.579] assign_globals() ...
[13:19:19.579] List of 5
[13:19:19.579]  $ ...future.FUN            :function (x)  
[13:19:19.579]  $ future.call.arguments    : list()
[13:19:19.579]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:19.579]  $ ...future.elements_ii    :List of 1
[13:19:19.579]   ..$ : int 0
[13:19:19.579]  $ ...future.seeds_ii       : NULL
[13:19:19.579]  $ ...future.globals.maxSize: NULL
[13:19:19.579]  - attr(*, "where")=List of 5
[13:19:19.579]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:19.579]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:19.579]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:19.579]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:19.579]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:19.579]  - attr(*, "resolved")= logi FALSE
[13:19:19.579]  - attr(*, "total_size")= num 4720
[13:19:19.579]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:19.579]  - attr(*, "already-done")= logi TRUE
[13:19:19.591] - reassign environment for ‘...future.FUN’
[13:19:19.591] - copied ‘...future.FUN’ to environment
[13:19:19.592] - copied ‘future.call.arguments’ to environment
[13:19:19.592] - copied ‘...future.elements_ii’ to environment
[13:19:19.592] - copied ‘...future.seeds_ii’ to environment
[13:19:19.592] - copied ‘...future.globals.maxSize’ to environment
[13:19:19.592] assign_globals() ... done
[13:19:19.592] requestCore(): workers = 2
[13:19:19.599] MulticoreFuture started
[13:19:19.599] - Launch lazy future ... done
[13:19:19.600] run() for ‘MulticoreFuture’ ... done
[13:19:19.600] Created future:
[13:19:19.600] plan(): Setting new future strategy stack:
[13:19:19.600] List of future strategies:
[13:19:19.600] 1. sequential:
[13:19:19.600]    - args: function (..., envir = parent.frame())
[13:19:19.600]    - tweaked: FALSE
[13:19:19.600]    - call: NULL
[13:19:19.601] plan(): nbrOfWorkers() = 1
[13:19:19.603] plan(): Setting new future strategy stack:
[13:19:19.604] List of future strategies:
[13:19:19.604] 1. multicore:
[13:19:19.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:19.604]    - tweaked: FALSE
[13:19:19.604]    - call: plan(strategy)
[13:19:19.609] plan(): nbrOfWorkers() = 2
[13:19:19.600] MulticoreFuture:
[13:19:19.600] Label: ‘future_lapply-2’
[13:19:19.600] Expression:
[13:19:19.600] {
[13:19:19.600]     do.call(function(...) {
[13:19:19.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:19.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:19.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:19.600]             on.exit(options(oopts), add = TRUE)
[13:19:19.600]         }
[13:19:19.600]         {
[13:19:19.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:19.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:19.600]                 ...future.FUN(...future.X_jj, ...)
[13:19:19.600]             })
[13:19:19.600]         }
[13:19:19.600]     }, args = future.call.arguments)
[13:19:19.600] }
[13:19:19.600] Lazy evaluation: FALSE
[13:19:19.600] Asynchronous evaluation: TRUE
[13:19:19.600] Local evaluation: TRUE
[13:19:19.600] Environment: R_GlobalEnv
[13:19:19.600] Capture standard output: FALSE
[13:19:19.600] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:19.600] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:19.600] Packages: <none>
[13:19:19.600] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:19.600] Resolved: TRUE
[13:19:19.600] Value: <not collected>
[13:19:19.600] Conditions captured: <none>
[13:19:19.600] Early signaling: FALSE
[13:19:19.600] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:19.600] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:19.610] Chunk #2 of 2 ... DONE
[13:19:19.610] Launching 2 futures (chunks) ... DONE
[13:19:19.610] Resolving 2 futures (chunks) ...
[13:19:19.611] resolve() on list ...
[13:19:19.611]  recursive: 0
[13:19:19.611]  length: 2
[13:19:19.611] 
[13:19:19.622] Future #2
[13:19:19.624] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:19.624] - nx: 2
[13:19:19.625] - relay: TRUE
[13:19:19.625] - stdout: TRUE
[13:19:19.625] - signal: TRUE
[13:19:19.625] - resignal: FALSE
[13:19:19.625] - force: TRUE
[13:19:19.625] - relayed: [n=2] FALSE, FALSE
[13:19:19.625] - queued futures: [n=2] FALSE, FALSE
[13:19:19.626]  - until=1
[13:19:19.626]  - relaying element #1
[13:19:19.626] - relayed: [n=2] FALSE, FALSE
[13:19:19.626] - queued futures: [n=2] FALSE, TRUE
[13:19:19.626] signalConditionsASAP(NULL, pos=2) ... done
[13:19:19.626]  length: 1 (resolved future 2)
[13:19:20.051] plan(): Setting new future strategy stack:
[13:19:20.051] List of future strategies:
[13:19:20.051] 1. multicore:
[13:19:20.051]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:20.051]    - tweaked: FALSE
[13:19:20.051]    - call: plan(strategy)
[13:19:20.055] plan(): nbrOfWorkers() = 2
[13:19:20.064] Future #1
[13:19:20.065] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:20.066] - nx: 2
[13:19:20.066] - relay: TRUE
[13:19:20.066] - stdout: TRUE
[13:19:20.066] - signal: TRUE
[13:19:20.066] - resignal: FALSE
[13:19:20.066] - force: TRUE
[13:19:20.066] - relayed: [n=2] FALSE, FALSE
[13:19:20.067] - queued futures: [n=2] FALSE, TRUE
[13:19:20.067]  - until=1
[13:19:20.067]  - relaying element #1
[13:19:20.067] - relayed: [n=2] TRUE, FALSE
[13:19:20.067] - queued futures: [n=2] TRUE, TRUE
[13:19:20.068] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:20.068]  length: 0 (resolved future 1)
[13:19:20.068] Relaying remaining futures
[13:19:20.068] signalConditionsASAP(NULL, pos=0) ...
[13:19:20.068] - nx: 2
[13:19:20.068] - relay: TRUE
[13:19:20.068] - stdout: TRUE
[13:19:20.069] - signal: TRUE
[13:19:20.069] - resignal: FALSE
[13:19:20.069] - force: TRUE
[13:19:20.069] - relayed: [n=2] TRUE, FALSE
[13:19:20.069] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:20.069]  - relaying element #2
[13:19:20.070] - relayed: [n=2] TRUE, TRUE
[13:19:20.070] - queued futures: [n=2] TRUE, TRUE
[13:19:20.070] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:19:20.070] resolve() on list ... DONE
[13:19:20.070]  - Number of value chunks collected: 2
[13:19:20.071] Resolving 2 futures (chunks) ... DONE
[13:19:20.071] Reducing values from 2 chunks ...
[13:19:20.071]  - Number of values collected after concatenation: 2
[13:19:20.071]  - Number of values expected: 2
[13:19:20.071] Reducing values from 2 chunks ... DONE
[13:19:20.071] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:19:20.072] future_lapply() ...
[13:19:20.076] Number of chunks: 2
[13:19:20.077] getGlobalsAndPackagesXApply() ...
[13:19:20.077]  - future.globals: TRUE
[13:19:20.077] getGlobalsAndPackages() ...
[13:19:20.077] Searching for globals...
[13:19:20.079] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:20.079] Searching for globals ... DONE
[13:19:20.079] Resolving globals: FALSE
[13:19:20.080] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:20.080] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:20.080] - globals: [1] ‘FUN’
[13:19:20.080] 
[13:19:20.080] getGlobalsAndPackages() ... DONE
[13:19:20.080]  - globals found/used: [n=1] ‘FUN’
[13:19:20.081]  - needed namespaces: [n=0] 
[13:19:20.081] Finding globals ... DONE
[13:19:20.083]  - use_args: TRUE
[13:19:20.083]  - Getting '...' globals ...
[13:19:20.083] resolve() on list ...
[13:19:20.084]  recursive: 0
[13:19:20.084]  length: 1
[13:19:20.084]  elements: ‘...’
[13:19:20.084]  length: 0 (resolved future 1)
[13:19:20.084] resolve() on list ... DONE
[13:19:20.084]    - '...' content: [n=0] 
[13:19:20.084] List of 1
[13:19:20.084]  $ ...: list()
[13:19:20.084]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:20.084]  - attr(*, "where")=List of 1
[13:19:20.084]   ..$ ...:<environment: 0x5620060887f0> 
[13:19:20.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:20.084]  - attr(*, "resolved")= logi TRUE
[13:19:20.084]  - attr(*, "total_size")= num NA
[13:19:20.088]  - Getting '...' globals ... DONE
[13:19:20.088] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:20.088] List of 2
[13:19:20.088]  $ ...future.FUN:function (x)  
[13:19:20.088]  $ ...          : list()
[13:19:20.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:20.088]  - attr(*, "where")=List of 2
[13:19:20.088]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:20.088]   ..$ ...          :<environment: 0x5620060887f0> 
[13:19:20.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:20.088]  - attr(*, "resolved")= logi FALSE
[13:19:20.088]  - attr(*, "total_size")= num 4720
[13:19:20.091] Packages to be attached in all futures: [n=0] 
[13:19:20.091] getGlobalsAndPackagesXApply() ... DONE
[13:19:20.092] Number of futures (= number of chunks): 2
[13:19:20.092] Launching 2 futures (chunks) ...
[13:19:20.092] Chunk #1 of 2 ...
[13:19:20.092]  - Finding globals in 'X' for chunk #1 ...
[13:19:20.092] getGlobalsAndPackages() ...
[13:19:20.092] Searching for globals...
[13:19:20.092] 
[13:19:20.093] Searching for globals ... DONE
[13:19:20.093] - globals: [0] <none>
[13:19:20.093] getGlobalsAndPackages() ... DONE
[13:19:20.093]    + additional globals found: [n=0] 
[13:19:20.093]    + additional namespaces needed: [n=0] 
[13:19:20.093]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:20.093]  - seeds: <none>
[13:19:20.093] getGlobalsAndPackages() ...
[13:19:20.093] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:20.093] Resolving globals: FALSE
[13:19:20.094] Tweak future expression to call with '...' arguments ...
[13:19:20.094] {
[13:19:20.094]     do.call(function(...) {
[13:19:20.094]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.094]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:20.094]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.094]             on.exit(options(oopts), add = TRUE)
[13:19:20.094]         }
[13:19:20.094]         {
[13:19:20.094]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:20.094]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.094]                 ...future.FUN(...future.X_jj, ...)
[13:19:20.094]             })
[13:19:20.094]         }
[13:19:20.094]     }, args = future.call.arguments)
[13:19:20.094] }
[13:19:20.094] Tweak future expression to call with '...' arguments ... DONE
[13:19:20.094] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:20.094] 
[13:19:20.095] getGlobalsAndPackages() ... DONE
[13:19:20.095] run() for ‘Future’ ...
[13:19:20.095] - state: ‘created’
[13:19:20.095] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:20.099] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:20.099] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:20.099]   - Field: ‘label’
[13:19:20.099]   - Field: ‘local’
[13:19:20.099]   - Field: ‘owner’
[13:19:20.099]   - Field: ‘envir’
[13:19:20.100]   - Field: ‘workers’
[13:19:20.100]   - Field: ‘packages’
[13:19:20.100]   - Field: ‘gc’
[13:19:20.100]   - Field: ‘job’
[13:19:20.100]   - Field: ‘conditions’
[13:19:20.100]   - Field: ‘expr’
[13:19:20.100]   - Field: ‘uuid’
[13:19:20.100]   - Field: ‘seed’
[13:19:20.100]   - Field: ‘version’
[13:19:20.100]   - Field: ‘result’
[13:19:20.100]   - Field: ‘asynchronous’
[13:19:20.101]   - Field: ‘calls’
[13:19:20.101]   - Field: ‘globals’
[13:19:20.101]   - Field: ‘stdout’
[13:19:20.101]   - Field: ‘earlySignal’
[13:19:20.101]   - Field: ‘lazy’
[13:19:20.101]   - Field: ‘state’
[13:19:20.101] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:20.101] - Launch lazy future ...
[13:19:20.102] Packages needed by the future expression (n = 0): <none>
[13:19:20.102] Packages needed by future strategies (n = 0): <none>
[13:19:20.102] {
[13:19:20.102]     {
[13:19:20.102]         {
[13:19:20.102]             ...future.startTime <- base::Sys.time()
[13:19:20.102]             {
[13:19:20.102]                 {
[13:19:20.102]                   {
[13:19:20.102]                     {
[13:19:20.102]                       base::local({
[13:19:20.102]                         has_future <- base::requireNamespace("future", 
[13:19:20.102]                           quietly = TRUE)
[13:19:20.102]                         if (has_future) {
[13:19:20.102]                           ns <- base::getNamespace("future")
[13:19:20.102]                           version <- ns[[".package"]][["version"]]
[13:19:20.102]                           if (is.null(version)) 
[13:19:20.102]                             version <- utils::packageVersion("future")
[13:19:20.102]                         }
[13:19:20.102]                         else {
[13:19:20.102]                           version <- NULL
[13:19:20.102]                         }
[13:19:20.102]                         if (!has_future || version < "1.8.0") {
[13:19:20.102]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:20.102]                             "", base::R.version$version.string), 
[13:19:20.102]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:20.102]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:20.102]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:20.102]                               "release", "version")], collapse = " "), 
[13:19:20.102]                             hostname = base::Sys.info()[["nodename"]])
[13:19:20.102]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:20.102]                             info)
[13:19:20.102]                           info <- base::paste(info, collapse = "; ")
[13:19:20.102]                           if (!has_future) {
[13:19:20.102]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:20.102]                               info)
[13:19:20.102]                           }
[13:19:20.102]                           else {
[13:19:20.102]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:20.102]                               info, version)
[13:19:20.102]                           }
[13:19:20.102]                           base::stop(msg)
[13:19:20.102]                         }
[13:19:20.102]                       })
[13:19:20.102]                     }
[13:19:20.102]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:20.102]                     base::options(mc.cores = 1L)
[13:19:20.102]                   }
[13:19:20.102]                   options(future.plan = NULL)
[13:19:20.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:20.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:20.102]                 }
[13:19:20.102]                 ...future.workdir <- getwd()
[13:19:20.102]             }
[13:19:20.102]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:20.102]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:20.102]         }
[13:19:20.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:20.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:20.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:20.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:20.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:20.102]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:20.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:20.102]             base::names(...future.oldOptions))
[13:19:20.102]     }
[13:19:20.102]     if (FALSE) {
[13:19:20.102]     }
[13:19:20.102]     else {
[13:19:20.102]         if (TRUE) {
[13:19:20.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:20.102]                 open = "w")
[13:19:20.102]         }
[13:19:20.102]         else {
[13:19:20.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:20.102]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:20.102]         }
[13:19:20.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:20.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:20.102]             base::sink(type = "output", split = FALSE)
[13:19:20.102]             base::close(...future.stdout)
[13:19:20.102]         }, add = TRUE)
[13:19:20.102]     }
[13:19:20.102]     ...future.frame <- base::sys.nframe()
[13:19:20.102]     ...future.conditions <- base::list()
[13:19:20.102]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:20.102]     if (FALSE) {
[13:19:20.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:20.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:20.102]     }
[13:19:20.102]     ...future.result <- base::tryCatch({
[13:19:20.102]         base::withCallingHandlers({
[13:19:20.102]             ...future.value <- base::withVisible(base::local({
[13:19:20.102]                 withCallingHandlers({
[13:19:20.102]                   {
[13:19:20.102]                     do.call(function(...) {
[13:19:20.102]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.102]                       if (!identical(...future.globals.maxSize.org, 
[13:19:20.102]                         ...future.globals.maxSize)) {
[13:19:20.102]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.102]                         on.exit(options(oopts), add = TRUE)
[13:19:20.102]                       }
[13:19:20.102]                       {
[13:19:20.102]                         lapply(seq_along(...future.elements_ii), 
[13:19:20.102]                           FUN = function(jj) {
[13:19:20.102]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.102]                             ...future.FUN(...future.X_jj, ...)
[13:19:20.102]                           })
[13:19:20.102]                       }
[13:19:20.102]                     }, args = future.call.arguments)
[13:19:20.102]                   }
[13:19:20.102]                 }, immediateCondition = function(cond) {
[13:19:20.102]                   save_rds <- function (object, pathname, ...) 
[13:19:20.102]                   {
[13:19:20.102]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:20.102]                     if (file_test("-f", pathname_tmp)) {
[13:19:20.102]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.102]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:20.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.102]                         fi_tmp[["mtime"]])
[13:19:20.102]                     }
[13:19:20.102]                     tryCatch({
[13:19:20.102]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:20.102]                     }, error = function(ex) {
[13:19:20.102]                       msg <- conditionMessage(ex)
[13:19:20.102]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.102]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:20.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.102]                         fi_tmp[["mtime"]], msg)
[13:19:20.102]                       ex$message <- msg
[13:19:20.102]                       stop(ex)
[13:19:20.102]                     })
[13:19:20.102]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:20.102]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:20.102]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:20.102]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.102]                       fi <- file.info(pathname)
[13:19:20.102]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:20.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.102]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:20.102]                         fi[["size"]], fi[["mtime"]])
[13:19:20.102]                       stop(msg)
[13:19:20.102]                     }
[13:19:20.102]                     invisible(pathname)
[13:19:20.102]                   }
[13:19:20.102]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:20.102]                     rootPath = tempdir()) 
[13:19:20.102]                   {
[13:19:20.102]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:20.102]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:20.102]                       tmpdir = path, fileext = ".rds")
[13:19:20.102]                     save_rds(obj, file)
[13:19:20.102]                   }
[13:19:20.102]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:20.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.102]                   {
[13:19:20.102]                     inherits <- base::inherits
[13:19:20.102]                     invokeRestart <- base::invokeRestart
[13:19:20.102]                     is.null <- base::is.null
[13:19:20.102]                     muffled <- FALSE
[13:19:20.102]                     if (inherits(cond, "message")) {
[13:19:20.102]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:20.102]                       if (muffled) 
[13:19:20.102]                         invokeRestart("muffleMessage")
[13:19:20.102]                     }
[13:19:20.102]                     else if (inherits(cond, "warning")) {
[13:19:20.102]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:20.102]                       if (muffled) 
[13:19:20.102]                         invokeRestart("muffleWarning")
[13:19:20.102]                     }
[13:19:20.102]                     else if (inherits(cond, "condition")) {
[13:19:20.102]                       if (!is.null(pattern)) {
[13:19:20.102]                         computeRestarts <- base::computeRestarts
[13:19:20.102]                         grepl <- base::grepl
[13:19:20.102]                         restarts <- computeRestarts(cond)
[13:19:20.102]                         for (restart in restarts) {
[13:19:20.102]                           name <- restart$name
[13:19:20.102]                           if (is.null(name)) 
[13:19:20.102]                             next
[13:19:20.102]                           if (!grepl(pattern, name)) 
[13:19:20.102]                             next
[13:19:20.102]                           invokeRestart(restart)
[13:19:20.102]                           muffled <- TRUE
[13:19:20.102]                           break
[13:19:20.102]                         }
[13:19:20.102]                       }
[13:19:20.102]                     }
[13:19:20.102]                     invisible(muffled)
[13:19:20.102]                   }
[13:19:20.102]                   muffleCondition(cond)
[13:19:20.102]                 })
[13:19:20.102]             }))
[13:19:20.102]             future::FutureResult(value = ...future.value$value, 
[13:19:20.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:20.102]                   ...future.rng), globalenv = if (FALSE) 
[13:19:20.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:20.102]                     ...future.globalenv.names))
[13:19:20.102]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:20.102]         }, condition = base::local({
[13:19:20.102]             c <- base::c
[13:19:20.102]             inherits <- base::inherits
[13:19:20.102]             invokeRestart <- base::invokeRestart
[13:19:20.102]             length <- base::length
[13:19:20.102]             list <- base::list
[13:19:20.102]             seq.int <- base::seq.int
[13:19:20.102]             signalCondition <- base::signalCondition
[13:19:20.102]             sys.calls <- base::sys.calls
[13:19:20.102]             `[[` <- base::`[[`
[13:19:20.102]             `+` <- base::`+`
[13:19:20.102]             `<<-` <- base::`<<-`
[13:19:20.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:20.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:20.102]                   3L)]
[13:19:20.102]             }
[13:19:20.102]             function(cond) {
[13:19:20.102]                 is_error <- inherits(cond, "error")
[13:19:20.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:20.102]                   NULL)
[13:19:20.102]                 if (is_error) {
[13:19:20.102]                   sessionInformation <- function() {
[13:19:20.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:20.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:20.102]                       search = base::search(), system = base::Sys.info())
[13:19:20.102]                   }
[13:19:20.102]                   ...future.conditions[[length(...future.conditions) + 
[13:19:20.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:20.102]                     cond$call), session = sessionInformation(), 
[13:19:20.102]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:20.102]                   signalCondition(cond)
[13:19:20.102]                 }
[13:19:20.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:20.102]                 "immediateCondition"))) {
[13:19:20.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:20.102]                   ...future.conditions[[length(...future.conditions) + 
[13:19:20.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:20.102]                   if (TRUE && !signal) {
[13:19:20.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.102]                     {
[13:19:20.102]                       inherits <- base::inherits
[13:19:20.102]                       invokeRestart <- base::invokeRestart
[13:19:20.102]                       is.null <- base::is.null
[13:19:20.102]                       muffled <- FALSE
[13:19:20.102]                       if (inherits(cond, "message")) {
[13:19:20.102]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:20.102]                         if (muffled) 
[13:19:20.102]                           invokeRestart("muffleMessage")
[13:19:20.102]                       }
[13:19:20.102]                       else if (inherits(cond, "warning")) {
[13:19:20.102]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:20.102]                         if (muffled) 
[13:19:20.102]                           invokeRestart("muffleWarning")
[13:19:20.102]                       }
[13:19:20.102]                       else if (inherits(cond, "condition")) {
[13:19:20.102]                         if (!is.null(pattern)) {
[13:19:20.102]                           computeRestarts <- base::computeRestarts
[13:19:20.102]                           grepl <- base::grepl
[13:19:20.102]                           restarts <- computeRestarts(cond)
[13:19:20.102]                           for (restart in restarts) {
[13:19:20.102]                             name <- restart$name
[13:19:20.102]                             if (is.null(name)) 
[13:19:20.102]                               next
[13:19:20.102]                             if (!grepl(pattern, name)) 
[13:19:20.102]                               next
[13:19:20.102]                             invokeRestart(restart)
[13:19:20.102]                             muffled <- TRUE
[13:19:20.102]                             break
[13:19:20.102]                           }
[13:19:20.102]                         }
[13:19:20.102]                       }
[13:19:20.102]                       invisible(muffled)
[13:19:20.102]                     }
[13:19:20.102]                     muffleCondition(cond, pattern = "^muffle")
[13:19:20.102]                   }
[13:19:20.102]                 }
[13:19:20.102]                 else {
[13:19:20.102]                   if (TRUE) {
[13:19:20.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.102]                     {
[13:19:20.102]                       inherits <- base::inherits
[13:19:20.102]                       invokeRestart <- base::invokeRestart
[13:19:20.102]                       is.null <- base::is.null
[13:19:20.102]                       muffled <- FALSE
[13:19:20.102]                       if (inherits(cond, "message")) {
[13:19:20.102]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:20.102]                         if (muffled) 
[13:19:20.102]                           invokeRestart("muffleMessage")
[13:19:20.102]                       }
[13:19:20.102]                       else if (inherits(cond, "warning")) {
[13:19:20.102]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:20.102]                         if (muffled) 
[13:19:20.102]                           invokeRestart("muffleWarning")
[13:19:20.102]                       }
[13:19:20.102]                       else if (inherits(cond, "condition")) {
[13:19:20.102]                         if (!is.null(pattern)) {
[13:19:20.102]                           computeRestarts <- base::computeRestarts
[13:19:20.102]                           grepl <- base::grepl
[13:19:20.102]                           restarts <- computeRestarts(cond)
[13:19:20.102]                           for (restart in restarts) {
[13:19:20.102]                             name <- restart$name
[13:19:20.102]                             if (is.null(name)) 
[13:19:20.102]                               next
[13:19:20.102]                             if (!grepl(pattern, name)) 
[13:19:20.102]                               next
[13:19:20.102]                             invokeRestart(restart)
[13:19:20.102]                             muffled <- TRUE
[13:19:20.102]                             break
[13:19:20.102]                           }
[13:19:20.102]                         }
[13:19:20.102]                       }
[13:19:20.102]                       invisible(muffled)
[13:19:20.102]                     }
[13:19:20.102]                     muffleCondition(cond, pattern = "^muffle")
[13:19:20.102]                   }
[13:19:20.102]                 }
[13:19:20.102]             }
[13:19:20.102]         }))
[13:19:20.102]     }, error = function(ex) {
[13:19:20.102]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:20.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:20.102]                 ...future.rng), started = ...future.startTime, 
[13:19:20.102]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:20.102]             version = "1.8"), class = "FutureResult")
[13:19:20.102]     }, finally = {
[13:19:20.102]         if (!identical(...future.workdir, getwd())) 
[13:19:20.102]             setwd(...future.workdir)
[13:19:20.102]         {
[13:19:20.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:20.102]                 ...future.oldOptions$nwarnings <- NULL
[13:19:20.102]             }
[13:19:20.102]             base::options(...future.oldOptions)
[13:19:20.102]             if (.Platform$OS.type == "windows") {
[13:19:20.102]                 old_names <- names(...future.oldEnvVars)
[13:19:20.102]                 envs <- base::Sys.getenv()
[13:19:20.102]                 names <- names(envs)
[13:19:20.102]                 common <- intersect(names, old_names)
[13:19:20.102]                 added <- setdiff(names, old_names)
[13:19:20.102]                 removed <- setdiff(old_names, names)
[13:19:20.102]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:20.102]                   envs[common]]
[13:19:20.102]                 NAMES <- toupper(changed)
[13:19:20.102]                 args <- list()
[13:19:20.102]                 for (kk in seq_along(NAMES)) {
[13:19:20.102]                   name <- changed[[kk]]
[13:19:20.102]                   NAME <- NAMES[[kk]]
[13:19:20.102]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.102]                     next
[13:19:20.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:20.102]                 }
[13:19:20.102]                 NAMES <- toupper(added)
[13:19:20.102]                 for (kk in seq_along(NAMES)) {
[13:19:20.102]                   name <- added[[kk]]
[13:19:20.102]                   NAME <- NAMES[[kk]]
[13:19:20.102]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.102]                     next
[13:19:20.102]                   args[[name]] <- ""
[13:19:20.102]                 }
[13:19:20.102]                 NAMES <- toupper(removed)
[13:19:20.102]                 for (kk in seq_along(NAMES)) {
[13:19:20.102]                   name <- removed[[kk]]
[13:19:20.102]                   NAME <- NAMES[[kk]]
[13:19:20.102]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.102]                     next
[13:19:20.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:20.102]                 }
[13:19:20.102]                 if (length(args) > 0) 
[13:19:20.102]                   base::do.call(base::Sys.setenv, args = args)
[13:19:20.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:20.102]             }
[13:19:20.102]             else {
[13:19:20.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:20.102]             }
[13:19:20.102]             {
[13:19:20.102]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:20.102]                   0L) {
[13:19:20.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:20.102]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:20.102]                   base::options(opts)
[13:19:20.102]                 }
[13:19:20.102]                 {
[13:19:20.102]                   {
[13:19:20.102]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:20.102]                     NULL
[13:19:20.102]                   }
[13:19:20.102]                   options(future.plan = NULL)
[13:19:20.102]                   if (is.na(NA_character_)) 
[13:19:20.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:20.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:20.102]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:20.102]                     envir = parent.frame()) 
[13:19:20.102]                   {
[13:19:20.102]                     default_workers <- missing(workers)
[13:19:20.102]                     if (is.function(workers)) 
[13:19:20.102]                       workers <- workers()
[13:19:20.102]                     workers <- structure(as.integer(workers), 
[13:19:20.102]                       class = class(workers))
[13:19:20.102]                     stop_if_not(is.finite(workers), workers >= 
[13:19:20.102]                       1L)
[13:19:20.102]                     if ((workers == 1L && !inherits(workers, 
[13:19:20.102]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:20.102]                       if (default_workers) 
[13:19:20.102]                         supportsMulticore(warn = TRUE)
[13:19:20.102]                       return(sequential(..., envir = envir))
[13:19:20.102]                     }
[13:19:20.102]                     oopts <- options(mc.cores = workers)
[13:19:20.102]                     on.exit(options(oopts))
[13:19:20.102]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:20.102]                       envir = envir)
[13:19:20.102]                     if (!future$lazy) 
[13:19:20.102]                       future <- run(future)
[13:19:20.102]                     invisible(future)
[13:19:20.102]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:20.102]                 }
[13:19:20.102]             }
[13:19:20.102]         }
[13:19:20.102]     })
[13:19:20.102]     if (TRUE) {
[13:19:20.102]         base::sink(type = "output", split = FALSE)
[13:19:20.102]         if (TRUE) {
[13:19:20.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:20.102]         }
[13:19:20.102]         else {
[13:19:20.102]             ...future.result["stdout"] <- base::list(NULL)
[13:19:20.102]         }
[13:19:20.102]         base::close(...future.stdout)
[13:19:20.102]         ...future.stdout <- NULL
[13:19:20.102]     }
[13:19:20.102]     ...future.result$conditions <- ...future.conditions
[13:19:20.102]     ...future.result$finished <- base::Sys.time()
[13:19:20.102]     ...future.result
[13:19:20.102] }
[13:19:20.105] assign_globals() ...
[13:19:20.105] List of 5
[13:19:20.105]  $ ...future.FUN            :function (x)  
[13:19:20.105]  $ future.call.arguments    : list()
[13:19:20.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:20.105]  $ ...future.elements_ii    :List of 1
[13:19:20.105]   ..$ : int 1
[13:19:20.105]  $ ...future.seeds_ii       : NULL
[13:19:20.105]  $ ...future.globals.maxSize: NULL
[13:19:20.105]  - attr(*, "where")=List of 5
[13:19:20.105]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:20.105]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:20.105]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:20.105]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:20.105]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:20.105]  - attr(*, "resolved")= logi FALSE
[13:19:20.105]  - attr(*, "total_size")= num 4720
[13:19:20.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:20.105]  - attr(*, "already-done")= logi TRUE
[13:19:20.110] - reassign environment for ‘...future.FUN’
[13:19:20.110] - copied ‘...future.FUN’ to environment
[13:19:20.110] - copied ‘future.call.arguments’ to environment
[13:19:20.111] - copied ‘...future.elements_ii’ to environment
[13:19:20.112] - copied ‘...future.seeds_ii’ to environment
[13:19:20.113] - copied ‘...future.globals.maxSize’ to environment
[13:19:20.113] assign_globals() ... done
[13:19:20.113] requestCore(): workers = 2
[13:19:20.115] MulticoreFuture started
[13:19:20.116] - Launch lazy future ... done
[13:19:20.117] plan(): Setting new future strategy stack:
[13:19:20.117] run() for ‘MulticoreFuture’ ... done
[13:19:20.117] Created future:
[13:19:20.117] List of future strategies:
[13:19:20.117] 1. sequential:
[13:19:20.117]    - args: function (..., envir = parent.frame())
[13:19:20.117]    - tweaked: FALSE
[13:19:20.117]    - call: NULL
[13:19:20.118] plan(): nbrOfWorkers() = 1
[13:19:20.118] MulticoreFuture:
[13:19:20.118] Label: ‘future_lapply-1’
[13:19:20.118] Expression:
[13:19:20.118] {
[13:19:20.118]     do.call(function(...) {
[13:19:20.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:20.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.118]             on.exit(options(oopts), add = TRUE)
[13:19:20.118]         }
[13:19:20.118]         {
[13:19:20.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:20.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.118]                 ...future.FUN(...future.X_jj, ...)
[13:19:20.118]             })
[13:19:20.118]         }
[13:19:20.118]     }, args = future.call.arguments)
[13:19:20.118] }
[13:19:20.118] Lazy evaluation: FALSE
[13:19:20.118] Asynchronous evaluation: TRUE
[13:19:20.118] Local evaluation: TRUE
[13:19:20.118] Environment: R_GlobalEnv
[13:19:20.118] Capture standard output: TRUE
[13:19:20.118] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:20.118] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:20.118] Packages: <none>
[13:19:20.118] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:20.118] Resolved: FALSE
[13:19:20.118] Value: <not collected>
[13:19:20.118] Conditions captured: <none>
[13:19:20.118] Early signaling: FALSE
[13:19:20.118] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:20.118] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:20.132] Chunk #1 of 2 ... DONE
[13:19:20.132] Chunk #2 of 2 ...
[13:19:20.132]  - Finding globals in 'X' for chunk #2 ...
[13:19:20.133] getGlobalsAndPackages() ...
[13:19:20.133] Searching for globals...
[13:19:20.134] 
[13:19:20.134] Searching for globals ... DONE
[13:19:20.134] - globals: [0] <none>
[13:19:20.134] getGlobalsAndPackages() ... DONE
[13:19:20.135]    + additional globals found: [n=0] 
[13:19:20.135]    + additional namespaces needed: [n=0] 
[13:19:20.135]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:20.135]  - seeds: <none>
[13:19:20.136] getGlobalsAndPackages() ...
[13:19:20.136] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:20.136] Resolving globals: FALSE
[13:19:20.136] Tweak future expression to call with '...' arguments ...
[13:19:20.136] {
[13:19:20.136]     do.call(function(...) {
[13:19:20.136]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.136]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:20.136]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.136]             on.exit(options(oopts), add = TRUE)
[13:19:20.136]         }
[13:19:20.136]         {
[13:19:20.136]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:20.136]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.136]                 ...future.FUN(...future.X_jj, ...)
[13:19:20.136]             })
[13:19:20.136]         }
[13:19:20.136]     }, args = future.call.arguments)
[13:19:20.136] }
[13:19:20.137] Tweak future expression to call with '...' arguments ... DONE
[13:19:20.138] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:20.138] 
[13:19:20.138] getGlobalsAndPackages() ... DONE
[13:19:20.139] run() for ‘Future’ ...
[13:19:20.139] - state: ‘created’
[13:19:20.139] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:20.144] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:20.144] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:20.144]   - Field: ‘label’
[13:19:20.145]   - Field: ‘local’
[13:19:20.145]   - Field: ‘owner’
[13:19:20.145]   - Field: ‘envir’
[13:19:20.145]   - Field: ‘workers’
[13:19:20.145]   - Field: ‘packages’
[13:19:20.145]   - Field: ‘gc’
[13:19:20.145]   - Field: ‘job’
[13:19:20.146]   - Field: ‘conditions’
[13:19:20.146]   - Field: ‘expr’
[13:19:20.146]   - Field: ‘uuid’
[13:19:20.146]   - Field: ‘seed’
[13:19:20.146]   - Field: ‘version’
[13:19:20.146]   - Field: ‘result’
[13:19:20.146]   - Field: ‘asynchronous’
[13:19:20.147]   - Field: ‘calls’
[13:19:20.147]   - Field: ‘globals’
[13:19:20.147]   - Field: ‘stdout’
[13:19:20.147]   - Field: ‘earlySignal’
[13:19:20.147]   - Field: ‘lazy’
[13:19:20.147]   - Field: ‘state’
[13:19:20.147] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:20.148] - Launch lazy future ...
[13:19:20.148] Packages needed by the future expression (n = 0): <none>
[13:19:20.148] Packages needed by future strategies (n = 0): <none>
[13:19:20.149] {
[13:19:20.149]     {
[13:19:20.149]         {
[13:19:20.149]             ...future.startTime <- base::Sys.time()
[13:19:20.149]             {
[13:19:20.149]                 {
[13:19:20.149]                   {
[13:19:20.149]                     {
[13:19:20.149]                       base::local({
[13:19:20.149]                         has_future <- base::requireNamespace("future", 
[13:19:20.149]                           quietly = TRUE)
[13:19:20.149]                         if (has_future) {
[13:19:20.149]                           ns <- base::getNamespace("future")
[13:19:20.149]                           version <- ns[[".package"]][["version"]]
[13:19:20.149]                           if (is.null(version)) 
[13:19:20.149]                             version <- utils::packageVersion("future")
[13:19:20.149]                         }
[13:19:20.149]                         else {
[13:19:20.149]                           version <- NULL
[13:19:20.149]                         }
[13:19:20.149]                         if (!has_future || version < "1.8.0") {
[13:19:20.149]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:20.149]                             "", base::R.version$version.string), 
[13:19:20.149]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:20.149]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:20.149]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:20.149]                               "release", "version")], collapse = " "), 
[13:19:20.149]                             hostname = base::Sys.info()[["nodename"]])
[13:19:20.149]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:20.149]                             info)
[13:19:20.149]                           info <- base::paste(info, collapse = "; ")
[13:19:20.149]                           if (!has_future) {
[13:19:20.149]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:20.149]                               info)
[13:19:20.149]                           }
[13:19:20.149]                           else {
[13:19:20.149]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:20.149]                               info, version)
[13:19:20.149]                           }
[13:19:20.149]                           base::stop(msg)
[13:19:20.149]                         }
[13:19:20.149]                       })
[13:19:20.149]                     }
[13:19:20.149]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:20.149]                     base::options(mc.cores = 1L)
[13:19:20.149]                   }
[13:19:20.149]                   options(future.plan = NULL)
[13:19:20.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:20.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:20.149]                 }
[13:19:20.149]                 ...future.workdir <- getwd()
[13:19:20.149]             }
[13:19:20.149]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:20.149]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:20.149]         }
[13:19:20.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:20.149]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:20.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:20.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:20.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:20.149]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:20.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:20.149]             base::names(...future.oldOptions))
[13:19:20.149]     }
[13:19:20.149]     if (FALSE) {
[13:19:20.149]     }
[13:19:20.149]     else {
[13:19:20.149]         if (TRUE) {
[13:19:20.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:20.149]                 open = "w")
[13:19:20.149]         }
[13:19:20.149]         else {
[13:19:20.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:20.149]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:20.149]         }
[13:19:20.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:20.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:20.149]             base::sink(type = "output", split = FALSE)
[13:19:20.149]             base::close(...future.stdout)
[13:19:20.149]         }, add = TRUE)
[13:19:20.149]     }
[13:19:20.149]     ...future.frame <- base::sys.nframe()
[13:19:20.149]     ...future.conditions <- base::list()
[13:19:20.149]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:20.149]     if (FALSE) {
[13:19:20.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:20.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:20.149]     }
[13:19:20.149]     ...future.result <- base::tryCatch({
[13:19:20.149]         base::withCallingHandlers({
[13:19:20.149]             ...future.value <- base::withVisible(base::local({
[13:19:20.149]                 withCallingHandlers({
[13:19:20.149]                   {
[13:19:20.149]                     do.call(function(...) {
[13:19:20.149]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.149]                       if (!identical(...future.globals.maxSize.org, 
[13:19:20.149]                         ...future.globals.maxSize)) {
[13:19:20.149]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.149]                         on.exit(options(oopts), add = TRUE)
[13:19:20.149]                       }
[13:19:20.149]                       {
[13:19:20.149]                         lapply(seq_along(...future.elements_ii), 
[13:19:20.149]                           FUN = function(jj) {
[13:19:20.149]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.149]                             ...future.FUN(...future.X_jj, ...)
[13:19:20.149]                           })
[13:19:20.149]                       }
[13:19:20.149]                     }, args = future.call.arguments)
[13:19:20.149]                   }
[13:19:20.149]                 }, immediateCondition = function(cond) {
[13:19:20.149]                   save_rds <- function (object, pathname, ...) 
[13:19:20.149]                   {
[13:19:20.149]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:20.149]                     if (file_test("-f", pathname_tmp)) {
[13:19:20.149]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.149]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:20.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.149]                         fi_tmp[["mtime"]])
[13:19:20.149]                     }
[13:19:20.149]                     tryCatch({
[13:19:20.149]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:20.149]                     }, error = function(ex) {
[13:19:20.149]                       msg <- conditionMessage(ex)
[13:19:20.149]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.149]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:20.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.149]                         fi_tmp[["mtime"]], msg)
[13:19:20.149]                       ex$message <- msg
[13:19:20.149]                       stop(ex)
[13:19:20.149]                     })
[13:19:20.149]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:20.149]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:20.149]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:20.149]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.149]                       fi <- file.info(pathname)
[13:19:20.149]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:20.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.149]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:20.149]                         fi[["size"]], fi[["mtime"]])
[13:19:20.149]                       stop(msg)
[13:19:20.149]                     }
[13:19:20.149]                     invisible(pathname)
[13:19:20.149]                   }
[13:19:20.149]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:20.149]                     rootPath = tempdir()) 
[13:19:20.149]                   {
[13:19:20.149]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:20.149]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:20.149]                       tmpdir = path, fileext = ".rds")
[13:19:20.149]                     save_rds(obj, file)
[13:19:20.149]                   }
[13:19:20.149]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:20.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.149]                   {
[13:19:20.149]                     inherits <- base::inherits
[13:19:20.149]                     invokeRestart <- base::invokeRestart
[13:19:20.149]                     is.null <- base::is.null
[13:19:20.149]                     muffled <- FALSE
[13:19:20.149]                     if (inherits(cond, "message")) {
[13:19:20.149]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:20.149]                       if (muffled) 
[13:19:20.149]                         invokeRestart("muffleMessage")
[13:19:20.149]                     }
[13:19:20.149]                     else if (inherits(cond, "warning")) {
[13:19:20.149]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:20.149]                       if (muffled) 
[13:19:20.149]                         invokeRestart("muffleWarning")
[13:19:20.149]                     }
[13:19:20.149]                     else if (inherits(cond, "condition")) {
[13:19:20.149]                       if (!is.null(pattern)) {
[13:19:20.149]                         computeRestarts <- base::computeRestarts
[13:19:20.149]                         grepl <- base::grepl
[13:19:20.149]                         restarts <- computeRestarts(cond)
[13:19:20.149]                         for (restart in restarts) {
[13:19:20.149]                           name <- restart$name
[13:19:20.149]                           if (is.null(name)) 
[13:19:20.149]                             next
[13:19:20.149]                           if (!grepl(pattern, name)) 
[13:19:20.149]                             next
[13:19:20.149]                           invokeRestart(restart)
[13:19:20.149]                           muffled <- TRUE
[13:19:20.149]                           break
[13:19:20.149]                         }
[13:19:20.149]                       }
[13:19:20.149]                     }
[13:19:20.149]                     invisible(muffled)
[13:19:20.149]                   }
[13:19:20.149]                   muffleCondition(cond)
[13:19:20.149]                 })
[13:19:20.149]             }))
[13:19:20.149]             future::FutureResult(value = ...future.value$value, 
[13:19:20.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:20.149]                   ...future.rng), globalenv = if (FALSE) 
[13:19:20.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:20.149]                     ...future.globalenv.names))
[13:19:20.149]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:20.149]         }, condition = base::local({
[13:19:20.149]             c <- base::c
[13:19:20.149]             inherits <- base::inherits
[13:19:20.149]             invokeRestart <- base::invokeRestart
[13:19:20.149]             length <- base::length
[13:19:20.149]             list <- base::list
[13:19:20.149]             seq.int <- base::seq.int
[13:19:20.149]             signalCondition <- base::signalCondition
[13:19:20.149]             sys.calls <- base::sys.calls
[13:19:20.149]             `[[` <- base::`[[`
[13:19:20.149]             `+` <- base::`+`
[13:19:20.149]             `<<-` <- base::`<<-`
[13:19:20.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:20.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:20.149]                   3L)]
[13:19:20.149]             }
[13:19:20.149]             function(cond) {
[13:19:20.149]                 is_error <- inherits(cond, "error")
[13:19:20.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:20.149]                   NULL)
[13:19:20.149]                 if (is_error) {
[13:19:20.149]                   sessionInformation <- function() {
[13:19:20.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:20.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:20.149]                       search = base::search(), system = base::Sys.info())
[13:19:20.149]                   }
[13:19:20.149]                   ...future.conditions[[length(...future.conditions) + 
[13:19:20.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:20.149]                     cond$call), session = sessionInformation(), 
[13:19:20.149]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:20.149]                   signalCondition(cond)
[13:19:20.149]                 }
[13:19:20.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:20.149]                 "immediateCondition"))) {
[13:19:20.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:20.149]                   ...future.conditions[[length(...future.conditions) + 
[13:19:20.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:20.149]                   if (TRUE && !signal) {
[13:19:20.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.149]                     {
[13:19:20.149]                       inherits <- base::inherits
[13:19:20.149]                       invokeRestart <- base::invokeRestart
[13:19:20.149]                       is.null <- base::is.null
[13:19:20.149]                       muffled <- FALSE
[13:19:20.149]                       if (inherits(cond, "message")) {
[13:19:20.149]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:20.149]                         if (muffled) 
[13:19:20.149]                           invokeRestart("muffleMessage")
[13:19:20.149]                       }
[13:19:20.149]                       else if (inherits(cond, "warning")) {
[13:19:20.149]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:20.149]                         if (muffled) 
[13:19:20.149]                           invokeRestart("muffleWarning")
[13:19:20.149]                       }
[13:19:20.149]                       else if (inherits(cond, "condition")) {
[13:19:20.149]                         if (!is.null(pattern)) {
[13:19:20.149]                           computeRestarts <- base::computeRestarts
[13:19:20.149]                           grepl <- base::grepl
[13:19:20.149]                           restarts <- computeRestarts(cond)
[13:19:20.149]                           for (restart in restarts) {
[13:19:20.149]                             name <- restart$name
[13:19:20.149]                             if (is.null(name)) 
[13:19:20.149]                               next
[13:19:20.149]                             if (!grepl(pattern, name)) 
[13:19:20.149]                               next
[13:19:20.149]                             invokeRestart(restart)
[13:19:20.149]                             muffled <- TRUE
[13:19:20.149]                             break
[13:19:20.149]                           }
[13:19:20.149]                         }
[13:19:20.149]                       }
[13:19:20.149]                       invisible(muffled)
[13:19:20.149]                     }
[13:19:20.149]                     muffleCondition(cond, pattern = "^muffle")
[13:19:20.149]                   }
[13:19:20.149]                 }
[13:19:20.149]                 else {
[13:19:20.149]                   if (TRUE) {
[13:19:20.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.149]                     {
[13:19:20.149]                       inherits <- base::inherits
[13:19:20.149]                       invokeRestart <- base::invokeRestart
[13:19:20.149]                       is.null <- base::is.null
[13:19:20.149]                       muffled <- FALSE
[13:19:20.149]                       if (inherits(cond, "message")) {
[13:19:20.149]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:20.149]                         if (muffled) 
[13:19:20.149]                           invokeRestart("muffleMessage")
[13:19:20.149]                       }
[13:19:20.149]                       else if (inherits(cond, "warning")) {
[13:19:20.149]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:20.149]                         if (muffled) 
[13:19:20.149]                           invokeRestart("muffleWarning")
[13:19:20.149]                       }
[13:19:20.149]                       else if (inherits(cond, "condition")) {
[13:19:20.149]                         if (!is.null(pattern)) {
[13:19:20.149]                           computeRestarts <- base::computeRestarts
[13:19:20.149]                           grepl <- base::grepl
[13:19:20.149]                           restarts <- computeRestarts(cond)
[13:19:20.149]                           for (restart in restarts) {
[13:19:20.149]                             name <- restart$name
[13:19:20.149]                             if (is.null(name)) 
[13:19:20.149]                               next
[13:19:20.149]                             if (!grepl(pattern, name)) 
[13:19:20.149]                               next
[13:19:20.149]                             invokeRestart(restart)
[13:19:20.149]                             muffled <- TRUE
[13:19:20.149]                             break
[13:19:20.149]                           }
[13:19:20.149]                         }
[13:19:20.149]                       }
[13:19:20.149]                       invisible(muffled)
[13:19:20.149]                     }
[13:19:20.149]                     muffleCondition(cond, pattern = "^muffle")
[13:19:20.149]                   }
[13:19:20.149]                 }
[13:19:20.149]             }
[13:19:20.149]         }))
[13:19:20.149]     }, error = function(ex) {
[13:19:20.149]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:20.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:20.149]                 ...future.rng), started = ...future.startTime, 
[13:19:20.149]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:20.149]             version = "1.8"), class = "FutureResult")
[13:19:20.149]     }, finally = {
[13:19:20.149]         if (!identical(...future.workdir, getwd())) 
[13:19:20.149]             setwd(...future.workdir)
[13:19:20.149]         {
[13:19:20.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:20.149]                 ...future.oldOptions$nwarnings <- NULL
[13:19:20.149]             }
[13:19:20.149]             base::options(...future.oldOptions)
[13:19:20.149]             if (.Platform$OS.type == "windows") {
[13:19:20.149]                 old_names <- names(...future.oldEnvVars)
[13:19:20.149]                 envs <- base::Sys.getenv()
[13:19:20.149]                 names <- names(envs)
[13:19:20.149]                 common <- intersect(names, old_names)
[13:19:20.149]                 added <- setdiff(names, old_names)
[13:19:20.149]                 removed <- setdiff(old_names, names)
[13:19:20.149]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:20.149]                   envs[common]]
[13:19:20.149]                 NAMES <- toupper(changed)
[13:19:20.149]                 args <- list()
[13:19:20.149]                 for (kk in seq_along(NAMES)) {
[13:19:20.149]                   name <- changed[[kk]]
[13:19:20.149]                   NAME <- NAMES[[kk]]
[13:19:20.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.149]                     next
[13:19:20.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:20.149]                 }
[13:19:20.149]                 NAMES <- toupper(added)
[13:19:20.149]                 for (kk in seq_along(NAMES)) {
[13:19:20.149]                   name <- added[[kk]]
[13:19:20.149]                   NAME <- NAMES[[kk]]
[13:19:20.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.149]                     next
[13:19:20.149]                   args[[name]] <- ""
[13:19:20.149]                 }
[13:19:20.149]                 NAMES <- toupper(removed)
[13:19:20.149]                 for (kk in seq_along(NAMES)) {
[13:19:20.149]                   name <- removed[[kk]]
[13:19:20.149]                   NAME <- NAMES[[kk]]
[13:19:20.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.149]                     next
[13:19:20.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:20.149]                 }
[13:19:20.149]                 if (length(args) > 0) 
[13:19:20.149]                   base::do.call(base::Sys.setenv, args = args)
[13:19:20.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:20.149]             }
[13:19:20.149]             else {
[13:19:20.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:20.149]             }
[13:19:20.149]             {
[13:19:20.149]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:20.149]                   0L) {
[13:19:20.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:20.149]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:20.149]                   base::options(opts)
[13:19:20.149]                 }
[13:19:20.149]                 {
[13:19:20.149]                   {
[13:19:20.149]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:20.149]                     NULL
[13:19:20.149]                   }
[13:19:20.149]                   options(future.plan = NULL)
[13:19:20.149]                   if (is.na(NA_character_)) 
[13:19:20.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:20.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:20.149]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:20.149]                     envir = parent.frame()) 
[13:19:20.149]                   {
[13:19:20.149]                     default_workers <- missing(workers)
[13:19:20.149]                     if (is.function(workers)) 
[13:19:20.149]                       workers <- workers()
[13:19:20.149]                     workers <- structure(as.integer(workers), 
[13:19:20.149]                       class = class(workers))
[13:19:20.149]                     stop_if_not(is.finite(workers), workers >= 
[13:19:20.149]                       1L)
[13:19:20.149]                     if ((workers == 1L && !inherits(workers, 
[13:19:20.149]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:20.149]                       if (default_workers) 
[13:19:20.149]                         supportsMulticore(warn = TRUE)
[13:19:20.149]                       return(sequential(..., envir = envir))
[13:19:20.149]                     }
[13:19:20.149]                     oopts <- options(mc.cores = workers)
[13:19:20.149]                     on.exit(options(oopts))
[13:19:20.149]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:20.149]                       envir = envir)
[13:19:20.149]                     if (!future$lazy) 
[13:19:20.149]                       future <- run(future)
[13:19:20.149]                     invisible(future)
[13:19:20.149]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:20.149]                 }
[13:19:20.149]             }
[13:19:20.149]         }
[13:19:20.149]     })
[13:19:20.149]     if (TRUE) {
[13:19:20.149]         base::sink(type = "output", split = FALSE)
[13:19:20.149]         if (TRUE) {
[13:19:20.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:20.149]         }
[13:19:20.149]         else {
[13:19:20.149]             ...future.result["stdout"] <- base::list(NULL)
[13:19:20.149]         }
[13:19:20.149]         base::close(...future.stdout)
[13:19:20.149]         ...future.stdout <- NULL
[13:19:20.149]     }
[13:19:20.149]     ...future.result$conditions <- ...future.conditions
[13:19:20.149]     ...future.result$finished <- base::Sys.time()
[13:19:20.149]     ...future.result
[13:19:20.149] }
[13:19:20.152] assign_globals() ...
[13:19:20.152] List of 5
[13:19:20.152]  $ ...future.FUN            :function (x)  
[13:19:20.152]  $ future.call.arguments    : list()
[13:19:20.152]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:20.152]  $ ...future.elements_ii    :List of 1
[13:19:20.152]   ..$ : int 0
[13:19:20.152]  $ ...future.seeds_ii       : NULL
[13:19:20.152]  $ ...future.globals.maxSize: NULL
[13:19:20.152]  - attr(*, "where")=List of 5
[13:19:20.152]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:20.152]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:20.152]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:20.152]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:20.152]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:20.152]  - attr(*, "resolved")= logi FALSE
[13:19:20.152]  - attr(*, "total_size")= num 4720
[13:19:20.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:20.152]  - attr(*, "already-done")= logi TRUE
[13:19:20.159] - reassign environment for ‘...future.FUN’
[13:19:20.159] - copied ‘...future.FUN’ to environment
[13:19:20.159] - copied ‘future.call.arguments’ to environment
[13:19:20.159] - copied ‘...future.elements_ii’ to environment
[13:19:20.159] - copied ‘...future.seeds_ii’ to environment
[13:19:20.159] - copied ‘...future.globals.maxSize’ to environment
[13:19:20.160] assign_globals() ... done
[13:19:20.160] requestCore(): workers = 2
[13:19:20.162] MulticoreFuture started
[13:19:20.162] - Launch lazy future ... done
[13:19:20.163] run() for ‘MulticoreFuture’ ... done
[13:19:20.163] Created future:
[13:19:20.163] plan(): Setting new future strategy stack:
[13:19:20.163] List of future strategies:
[13:19:20.163] 1. sequential:
[13:19:20.163]    - args: function (..., envir = parent.frame())
[13:19:20.163]    - tweaked: FALSE
[13:19:20.163]    - call: NULL
[13:19:20.164] plan(): nbrOfWorkers() = 1
[13:19:20.166] plan(): Setting new future strategy stack:
[13:19:20.166] List of future strategies:
[13:19:20.166] 1. multicore:
[13:19:20.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:20.166]    - tweaked: FALSE
[13:19:20.166]    - call: plan(strategy)
[13:19:20.172] plan(): nbrOfWorkers() = 2
[13:19:20.163] MulticoreFuture:
[13:19:20.163] Label: ‘future_lapply-2’
[13:19:20.163] Expression:
[13:19:20.163] {
[13:19:20.163]     do.call(function(...) {
[13:19:20.163]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.163]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:20.163]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.163]             on.exit(options(oopts), add = TRUE)
[13:19:20.163]         }
[13:19:20.163]         {
[13:19:20.163]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:20.163]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.163]                 ...future.FUN(...future.X_jj, ...)
[13:19:20.163]             })
[13:19:20.163]         }
[13:19:20.163]     }, args = future.call.arguments)
[13:19:20.163] }
[13:19:20.163] Lazy evaluation: FALSE
[13:19:20.163] Asynchronous evaluation: TRUE
[13:19:20.163] Local evaluation: TRUE
[13:19:20.163] Environment: R_GlobalEnv
[13:19:20.163] Capture standard output: TRUE
[13:19:20.163] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:20.163] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:20.163] Packages: <none>
[13:19:20.163] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:20.163] Resolved: TRUE
[13:19:20.163] Value: <not collected>
[13:19:20.163] Conditions captured: <none>
[13:19:20.163] Early signaling: FALSE
[13:19:20.163] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:20.163] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:20.173] Chunk #2 of 2 ... DONE
[13:19:20.173] Launching 2 futures (chunks) ... DONE
[13:19:20.173] Resolving 2 futures (chunks) ...
[13:19:20.173] resolve() on list ...
[13:19:20.173]  recursive: 0
[13:19:20.174]  length: 2
[13:19:20.174] 
[13:19:20.184] Future #2
[13:19:20.185] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:20.186] - nx: 2
[13:19:20.186] - relay: TRUE
[13:19:20.186] - stdout: TRUE
[13:19:20.186] - signal: TRUE
[13:19:20.186] - resignal: FALSE
[13:19:20.186] - force: TRUE
[13:19:20.186] - relayed: [n=2] FALSE, FALSE
[13:19:20.187] - queued futures: [n=2] FALSE, FALSE
[13:19:20.187]  - until=1
[13:19:20.187]  - relaying element #1
[13:19:20.187] - relayed: [n=2] FALSE, FALSE
[13:19:20.187] - queued futures: [n=2] FALSE, TRUE
[13:19:20.187] signalConditionsASAP(NULL, pos=2) ... done
[13:19:20.187]  length: 1 (resolved future 2)
[13:19:20.622] plan(): Setting new future strategy stack:
[13:19:20.622] List of future strategies:
[13:19:20.622] 1. multicore:
[13:19:20.622]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:20.622]    - tweaked: FALSE
[13:19:20.622]    - call: plan(strategy)
[13:19:20.627] plan(): nbrOfWorkers() = 2
[13:19:20.628] Future #1
[13:19:20.629] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:20.629] - nx: 2
[13:19:20.630] - relay: TRUE
[13:19:20.630] - stdout: TRUE
[13:19:20.630] - signal: TRUE
[13:19:20.630] - resignal: FALSE
[13:19:20.630] - force: TRUE
[13:19:20.630] - relayed: [n=2] FALSE, FALSE
[13:19:20.631] - queued futures: [n=2] FALSE, TRUE
[13:19:20.631]  - until=1
[13:19:20.631]  - relaying element #1
[13:19:20.631] - relayed: [n=2] TRUE, FALSE
[13:19:20.631] - queued futures: [n=2] TRUE, TRUE
[13:19:20.631] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:20.632]  length: 0 (resolved future 1)
[13:19:20.632] Relaying remaining futures
[13:19:20.632] signalConditionsASAP(NULL, pos=0) ...
[13:19:20.632] - nx: 2
[13:19:20.632] - relay: TRUE
[13:19:20.632] - stdout: TRUE
[13:19:20.632] - signal: TRUE
[13:19:20.633] - resignal: FALSE
[13:19:20.633] - force: TRUE
[13:19:20.633] - relayed: [n=2] TRUE, FALSE
[13:19:20.633] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:20.633]  - relaying element #2
[13:19:20.633] - relayed: [n=2] TRUE, TRUE
[13:19:20.634] - queued futures: [n=2] TRUE, TRUE
[13:19:20.634] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:19:20.634] resolve() on list ... DONE
[13:19:20.634]  - Number of value chunks collected: 2
[13:19:20.634] Resolving 2 futures (chunks) ... DONE
[13:19:20.634] Reducing values from 2 chunks ...
[13:19:20.634]  - Number of values collected after concatenation: 2
[13:19:20.634]  - Number of values expected: 2
[13:19:20.635] Reducing values from 2 chunks ... DONE
[13:19:20.635] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:19:20.635] future_lapply() ...
[13:19:20.640] Number of chunks: 2
[13:19:20.640] getGlobalsAndPackagesXApply() ...
[13:19:20.640]  - future.globals: TRUE
[13:19:20.640] getGlobalsAndPackages() ...
[13:19:20.640] Searching for globals...
[13:19:20.642] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:20.642] Searching for globals ... DONE
[13:19:20.642] Resolving globals: FALSE
[13:19:20.643] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:20.643] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:20.643] - globals: [1] ‘FUN’
[13:19:20.643] 
[13:19:20.643] getGlobalsAndPackages() ... DONE
[13:19:20.643]  - globals found/used: [n=1] ‘FUN’
[13:19:20.644]  - needed namespaces: [n=0] 
[13:19:20.644] Finding globals ... DONE
[13:19:20.644]  - use_args: TRUE
[13:19:20.644]  - Getting '...' globals ...
[13:19:20.644] resolve() on list ...
[13:19:20.644]  recursive: 0
[13:19:20.644]  length: 1
[13:19:20.645]  elements: ‘...’
[13:19:20.645]  length: 0 (resolved future 1)
[13:19:20.645] resolve() on list ... DONE
[13:19:20.645]    - '...' content: [n=0] 
[13:19:20.645] List of 1
[13:19:20.645]  $ ...: list()
[13:19:20.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:20.645]  - attr(*, "where")=List of 1
[13:19:20.645]   ..$ ...:<environment: 0x56200429feb0> 
[13:19:20.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:20.645]  - attr(*, "resolved")= logi TRUE
[13:19:20.645]  - attr(*, "total_size")= num NA
[13:19:20.648]  - Getting '...' globals ... DONE
[13:19:20.648] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:20.648] List of 2
[13:19:20.648]  $ ...future.FUN:function (x)  
[13:19:20.648]  $ ...          : list()
[13:19:20.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:20.648]  - attr(*, "where")=List of 2
[13:19:20.648]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:20.648]   ..$ ...          :<environment: 0x56200429feb0> 
[13:19:20.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:20.648]  - attr(*, "resolved")= logi FALSE
[13:19:20.648]  - attr(*, "total_size")= num 4720
[13:19:20.651] Packages to be attached in all futures: [n=0] 
[13:19:20.651] getGlobalsAndPackagesXApply() ... DONE
[13:19:20.651] Number of futures (= number of chunks): 2
[13:19:20.651] Launching 2 futures (chunks) ...
[13:19:20.652] Chunk #1 of 2 ...
[13:19:20.652]  - Finding globals in 'X' for chunk #1 ...
[13:19:20.652] getGlobalsAndPackages() ...
[13:19:20.652] Searching for globals...
[13:19:20.652] 
[13:19:20.652] Searching for globals ... DONE
[13:19:20.652] - globals: [0] <none>
[13:19:20.652] getGlobalsAndPackages() ... DONE
[13:19:20.652]    + additional globals found: [n=0] 
[13:19:20.653]    + additional namespaces needed: [n=0] 
[13:19:20.653]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:20.653]  - seeds: <none>
[13:19:20.653] getGlobalsAndPackages() ...
[13:19:20.653] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:20.653] Resolving globals: FALSE
[13:19:20.653] Tweak future expression to call with '...' arguments ...
[13:19:20.653] {
[13:19:20.653]     do.call(function(...) {
[13:19:20.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:20.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.653]             on.exit(options(oopts), add = TRUE)
[13:19:20.653]         }
[13:19:20.653]         {
[13:19:20.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:20.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.653]                 ...future.FUN(...future.X_jj, ...)
[13:19:20.653]             })
[13:19:20.653]         }
[13:19:20.653]     }, args = future.call.arguments)
[13:19:20.653] }
[13:19:20.654] Tweak future expression to call with '...' arguments ... DONE
[13:19:20.654] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:20.654] 
[13:19:20.654] getGlobalsAndPackages() ... DONE
[13:19:20.655] run() for ‘Future’ ...
[13:19:20.656] - state: ‘created’
[13:19:20.657] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:20.660] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:20.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:20.661]   - Field: ‘label’
[13:19:20.661]   - Field: ‘local’
[13:19:20.661]   - Field: ‘owner’
[13:19:20.661]   - Field: ‘envir’
[13:19:20.661]   - Field: ‘workers’
[13:19:20.661]   - Field: ‘packages’
[13:19:20.661]   - Field: ‘gc’
[13:19:20.661]   - Field: ‘job’
[13:19:20.662]   - Field: ‘conditions’
[13:19:20.662]   - Field: ‘expr’
[13:19:20.662]   - Field: ‘uuid’
[13:19:20.662]   - Field: ‘seed’
[13:19:20.662]   - Field: ‘version’
[13:19:20.662]   - Field: ‘result’
[13:19:20.662]   - Field: ‘asynchronous’
[13:19:20.662]   - Field: ‘calls’
[13:19:20.662]   - Field: ‘globals’
[13:19:20.662]   - Field: ‘stdout’
[13:19:20.663]   - Field: ‘earlySignal’
[13:19:20.663]   - Field: ‘lazy’
[13:19:20.663]   - Field: ‘state’
[13:19:20.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:20.663] - Launch lazy future ...
[13:19:20.663] Packages needed by the future expression (n = 0): <none>
[13:19:20.663] Packages needed by future strategies (n = 0): <none>
[13:19:20.664] {
[13:19:20.664]     {
[13:19:20.664]         {
[13:19:20.664]             ...future.startTime <- base::Sys.time()
[13:19:20.664]             {
[13:19:20.664]                 {
[13:19:20.664]                   {
[13:19:20.664]                     {
[13:19:20.664]                       base::local({
[13:19:20.664]                         has_future <- base::requireNamespace("future", 
[13:19:20.664]                           quietly = TRUE)
[13:19:20.664]                         if (has_future) {
[13:19:20.664]                           ns <- base::getNamespace("future")
[13:19:20.664]                           version <- ns[[".package"]][["version"]]
[13:19:20.664]                           if (is.null(version)) 
[13:19:20.664]                             version <- utils::packageVersion("future")
[13:19:20.664]                         }
[13:19:20.664]                         else {
[13:19:20.664]                           version <- NULL
[13:19:20.664]                         }
[13:19:20.664]                         if (!has_future || version < "1.8.0") {
[13:19:20.664]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:20.664]                             "", base::R.version$version.string), 
[13:19:20.664]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:20.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:20.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:20.664]                               "release", "version")], collapse = " "), 
[13:19:20.664]                             hostname = base::Sys.info()[["nodename"]])
[13:19:20.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:20.664]                             info)
[13:19:20.664]                           info <- base::paste(info, collapse = "; ")
[13:19:20.664]                           if (!has_future) {
[13:19:20.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:20.664]                               info)
[13:19:20.664]                           }
[13:19:20.664]                           else {
[13:19:20.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:20.664]                               info, version)
[13:19:20.664]                           }
[13:19:20.664]                           base::stop(msg)
[13:19:20.664]                         }
[13:19:20.664]                       })
[13:19:20.664]                     }
[13:19:20.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:20.664]                     base::options(mc.cores = 1L)
[13:19:20.664]                   }
[13:19:20.664]                   options(future.plan = NULL)
[13:19:20.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:20.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:20.664]                 }
[13:19:20.664]                 ...future.workdir <- getwd()
[13:19:20.664]             }
[13:19:20.664]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:20.664]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:20.664]         }
[13:19:20.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:20.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:20.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:20.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:20.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:20.664]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:20.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:20.664]             base::names(...future.oldOptions))
[13:19:20.664]     }
[13:19:20.664]     if (TRUE) {
[13:19:20.664]     }
[13:19:20.664]     else {
[13:19:20.664]         if (NA) {
[13:19:20.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:20.664]                 open = "w")
[13:19:20.664]         }
[13:19:20.664]         else {
[13:19:20.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:20.664]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:20.664]         }
[13:19:20.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:20.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:20.664]             base::sink(type = "output", split = FALSE)
[13:19:20.664]             base::close(...future.stdout)
[13:19:20.664]         }, add = TRUE)
[13:19:20.664]     }
[13:19:20.664]     ...future.frame <- base::sys.nframe()
[13:19:20.664]     ...future.conditions <- base::list()
[13:19:20.664]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:20.664]     if (FALSE) {
[13:19:20.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:20.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:20.664]     }
[13:19:20.664]     ...future.result <- base::tryCatch({
[13:19:20.664]         base::withCallingHandlers({
[13:19:20.664]             ...future.value <- base::withVisible(base::local({
[13:19:20.664]                 withCallingHandlers({
[13:19:20.664]                   {
[13:19:20.664]                     do.call(function(...) {
[13:19:20.664]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.664]                       if (!identical(...future.globals.maxSize.org, 
[13:19:20.664]                         ...future.globals.maxSize)) {
[13:19:20.664]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.664]                         on.exit(options(oopts), add = TRUE)
[13:19:20.664]                       }
[13:19:20.664]                       {
[13:19:20.664]                         lapply(seq_along(...future.elements_ii), 
[13:19:20.664]                           FUN = function(jj) {
[13:19:20.664]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.664]                             ...future.FUN(...future.X_jj, ...)
[13:19:20.664]                           })
[13:19:20.664]                       }
[13:19:20.664]                     }, args = future.call.arguments)
[13:19:20.664]                   }
[13:19:20.664]                 }, immediateCondition = function(cond) {
[13:19:20.664]                   save_rds <- function (object, pathname, ...) 
[13:19:20.664]                   {
[13:19:20.664]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:20.664]                     if (file_test("-f", pathname_tmp)) {
[13:19:20.664]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.664]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:20.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.664]                         fi_tmp[["mtime"]])
[13:19:20.664]                     }
[13:19:20.664]                     tryCatch({
[13:19:20.664]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:20.664]                     }, error = function(ex) {
[13:19:20.664]                       msg <- conditionMessage(ex)
[13:19:20.664]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.664]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:20.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.664]                         fi_tmp[["mtime"]], msg)
[13:19:20.664]                       ex$message <- msg
[13:19:20.664]                       stop(ex)
[13:19:20.664]                     })
[13:19:20.664]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:20.664]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:20.664]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:20.664]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.664]                       fi <- file.info(pathname)
[13:19:20.664]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:20.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.664]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:20.664]                         fi[["size"]], fi[["mtime"]])
[13:19:20.664]                       stop(msg)
[13:19:20.664]                     }
[13:19:20.664]                     invisible(pathname)
[13:19:20.664]                   }
[13:19:20.664]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:20.664]                     rootPath = tempdir()) 
[13:19:20.664]                   {
[13:19:20.664]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:20.664]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:20.664]                       tmpdir = path, fileext = ".rds")
[13:19:20.664]                     save_rds(obj, file)
[13:19:20.664]                   }
[13:19:20.664]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:20.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.664]                   {
[13:19:20.664]                     inherits <- base::inherits
[13:19:20.664]                     invokeRestart <- base::invokeRestart
[13:19:20.664]                     is.null <- base::is.null
[13:19:20.664]                     muffled <- FALSE
[13:19:20.664]                     if (inherits(cond, "message")) {
[13:19:20.664]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:20.664]                       if (muffled) 
[13:19:20.664]                         invokeRestart("muffleMessage")
[13:19:20.664]                     }
[13:19:20.664]                     else if (inherits(cond, "warning")) {
[13:19:20.664]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:20.664]                       if (muffled) 
[13:19:20.664]                         invokeRestart("muffleWarning")
[13:19:20.664]                     }
[13:19:20.664]                     else if (inherits(cond, "condition")) {
[13:19:20.664]                       if (!is.null(pattern)) {
[13:19:20.664]                         computeRestarts <- base::computeRestarts
[13:19:20.664]                         grepl <- base::grepl
[13:19:20.664]                         restarts <- computeRestarts(cond)
[13:19:20.664]                         for (restart in restarts) {
[13:19:20.664]                           name <- restart$name
[13:19:20.664]                           if (is.null(name)) 
[13:19:20.664]                             next
[13:19:20.664]                           if (!grepl(pattern, name)) 
[13:19:20.664]                             next
[13:19:20.664]                           invokeRestart(restart)
[13:19:20.664]                           muffled <- TRUE
[13:19:20.664]                           break
[13:19:20.664]                         }
[13:19:20.664]                       }
[13:19:20.664]                     }
[13:19:20.664]                     invisible(muffled)
[13:19:20.664]                   }
[13:19:20.664]                   muffleCondition(cond)
[13:19:20.664]                 })
[13:19:20.664]             }))
[13:19:20.664]             future::FutureResult(value = ...future.value$value, 
[13:19:20.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:20.664]                   ...future.rng), globalenv = if (FALSE) 
[13:19:20.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:20.664]                     ...future.globalenv.names))
[13:19:20.664]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:20.664]         }, condition = base::local({
[13:19:20.664]             c <- base::c
[13:19:20.664]             inherits <- base::inherits
[13:19:20.664]             invokeRestart <- base::invokeRestart
[13:19:20.664]             length <- base::length
[13:19:20.664]             list <- base::list
[13:19:20.664]             seq.int <- base::seq.int
[13:19:20.664]             signalCondition <- base::signalCondition
[13:19:20.664]             sys.calls <- base::sys.calls
[13:19:20.664]             `[[` <- base::`[[`
[13:19:20.664]             `+` <- base::`+`
[13:19:20.664]             `<<-` <- base::`<<-`
[13:19:20.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:20.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:20.664]                   3L)]
[13:19:20.664]             }
[13:19:20.664]             function(cond) {
[13:19:20.664]                 is_error <- inherits(cond, "error")
[13:19:20.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:20.664]                   NULL)
[13:19:20.664]                 if (is_error) {
[13:19:20.664]                   sessionInformation <- function() {
[13:19:20.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:20.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:20.664]                       search = base::search(), system = base::Sys.info())
[13:19:20.664]                   }
[13:19:20.664]                   ...future.conditions[[length(...future.conditions) + 
[13:19:20.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:20.664]                     cond$call), session = sessionInformation(), 
[13:19:20.664]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:20.664]                   signalCondition(cond)
[13:19:20.664]                 }
[13:19:20.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:20.664]                 "immediateCondition"))) {
[13:19:20.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:20.664]                   ...future.conditions[[length(...future.conditions) + 
[13:19:20.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:20.664]                   if (TRUE && !signal) {
[13:19:20.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.664]                     {
[13:19:20.664]                       inherits <- base::inherits
[13:19:20.664]                       invokeRestart <- base::invokeRestart
[13:19:20.664]                       is.null <- base::is.null
[13:19:20.664]                       muffled <- FALSE
[13:19:20.664]                       if (inherits(cond, "message")) {
[13:19:20.664]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:20.664]                         if (muffled) 
[13:19:20.664]                           invokeRestart("muffleMessage")
[13:19:20.664]                       }
[13:19:20.664]                       else if (inherits(cond, "warning")) {
[13:19:20.664]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:20.664]                         if (muffled) 
[13:19:20.664]                           invokeRestart("muffleWarning")
[13:19:20.664]                       }
[13:19:20.664]                       else if (inherits(cond, "condition")) {
[13:19:20.664]                         if (!is.null(pattern)) {
[13:19:20.664]                           computeRestarts <- base::computeRestarts
[13:19:20.664]                           grepl <- base::grepl
[13:19:20.664]                           restarts <- computeRestarts(cond)
[13:19:20.664]                           for (restart in restarts) {
[13:19:20.664]                             name <- restart$name
[13:19:20.664]                             if (is.null(name)) 
[13:19:20.664]                               next
[13:19:20.664]                             if (!grepl(pattern, name)) 
[13:19:20.664]                               next
[13:19:20.664]                             invokeRestart(restart)
[13:19:20.664]                             muffled <- TRUE
[13:19:20.664]                             break
[13:19:20.664]                           }
[13:19:20.664]                         }
[13:19:20.664]                       }
[13:19:20.664]                       invisible(muffled)
[13:19:20.664]                     }
[13:19:20.664]                     muffleCondition(cond, pattern = "^muffle")
[13:19:20.664]                   }
[13:19:20.664]                 }
[13:19:20.664]                 else {
[13:19:20.664]                   if (TRUE) {
[13:19:20.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.664]                     {
[13:19:20.664]                       inherits <- base::inherits
[13:19:20.664]                       invokeRestart <- base::invokeRestart
[13:19:20.664]                       is.null <- base::is.null
[13:19:20.664]                       muffled <- FALSE
[13:19:20.664]                       if (inherits(cond, "message")) {
[13:19:20.664]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:20.664]                         if (muffled) 
[13:19:20.664]                           invokeRestart("muffleMessage")
[13:19:20.664]                       }
[13:19:20.664]                       else if (inherits(cond, "warning")) {
[13:19:20.664]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:20.664]                         if (muffled) 
[13:19:20.664]                           invokeRestart("muffleWarning")
[13:19:20.664]                       }
[13:19:20.664]                       else if (inherits(cond, "condition")) {
[13:19:20.664]                         if (!is.null(pattern)) {
[13:19:20.664]                           computeRestarts <- base::computeRestarts
[13:19:20.664]                           grepl <- base::grepl
[13:19:20.664]                           restarts <- computeRestarts(cond)
[13:19:20.664]                           for (restart in restarts) {
[13:19:20.664]                             name <- restart$name
[13:19:20.664]                             if (is.null(name)) 
[13:19:20.664]                               next
[13:19:20.664]                             if (!grepl(pattern, name)) 
[13:19:20.664]                               next
[13:19:20.664]                             invokeRestart(restart)
[13:19:20.664]                             muffled <- TRUE
[13:19:20.664]                             break
[13:19:20.664]                           }
[13:19:20.664]                         }
[13:19:20.664]                       }
[13:19:20.664]                       invisible(muffled)
[13:19:20.664]                     }
[13:19:20.664]                     muffleCondition(cond, pattern = "^muffle")
[13:19:20.664]                   }
[13:19:20.664]                 }
[13:19:20.664]             }
[13:19:20.664]         }))
[13:19:20.664]     }, error = function(ex) {
[13:19:20.664]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:20.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:20.664]                 ...future.rng), started = ...future.startTime, 
[13:19:20.664]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:20.664]             version = "1.8"), class = "FutureResult")
[13:19:20.664]     }, finally = {
[13:19:20.664]         if (!identical(...future.workdir, getwd())) 
[13:19:20.664]             setwd(...future.workdir)
[13:19:20.664]         {
[13:19:20.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:20.664]                 ...future.oldOptions$nwarnings <- NULL
[13:19:20.664]             }
[13:19:20.664]             base::options(...future.oldOptions)
[13:19:20.664]             if (.Platform$OS.type == "windows") {
[13:19:20.664]                 old_names <- names(...future.oldEnvVars)
[13:19:20.664]                 envs <- base::Sys.getenv()
[13:19:20.664]                 names <- names(envs)
[13:19:20.664]                 common <- intersect(names, old_names)
[13:19:20.664]                 added <- setdiff(names, old_names)
[13:19:20.664]                 removed <- setdiff(old_names, names)
[13:19:20.664]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:20.664]                   envs[common]]
[13:19:20.664]                 NAMES <- toupper(changed)
[13:19:20.664]                 args <- list()
[13:19:20.664]                 for (kk in seq_along(NAMES)) {
[13:19:20.664]                   name <- changed[[kk]]
[13:19:20.664]                   NAME <- NAMES[[kk]]
[13:19:20.664]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.664]                     next
[13:19:20.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:20.664]                 }
[13:19:20.664]                 NAMES <- toupper(added)
[13:19:20.664]                 for (kk in seq_along(NAMES)) {
[13:19:20.664]                   name <- added[[kk]]
[13:19:20.664]                   NAME <- NAMES[[kk]]
[13:19:20.664]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.664]                     next
[13:19:20.664]                   args[[name]] <- ""
[13:19:20.664]                 }
[13:19:20.664]                 NAMES <- toupper(removed)
[13:19:20.664]                 for (kk in seq_along(NAMES)) {
[13:19:20.664]                   name <- removed[[kk]]
[13:19:20.664]                   NAME <- NAMES[[kk]]
[13:19:20.664]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.664]                     next
[13:19:20.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:20.664]                 }
[13:19:20.664]                 if (length(args) > 0) 
[13:19:20.664]                   base::do.call(base::Sys.setenv, args = args)
[13:19:20.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:20.664]             }
[13:19:20.664]             else {
[13:19:20.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:20.664]             }
[13:19:20.664]             {
[13:19:20.664]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:20.664]                   0L) {
[13:19:20.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:20.664]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:20.664]                   base::options(opts)
[13:19:20.664]                 }
[13:19:20.664]                 {
[13:19:20.664]                   {
[13:19:20.664]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:20.664]                     NULL
[13:19:20.664]                   }
[13:19:20.664]                   options(future.plan = NULL)
[13:19:20.664]                   if (is.na(NA_character_)) 
[13:19:20.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:20.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:20.664]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:20.664]                     envir = parent.frame()) 
[13:19:20.664]                   {
[13:19:20.664]                     default_workers <- missing(workers)
[13:19:20.664]                     if (is.function(workers)) 
[13:19:20.664]                       workers <- workers()
[13:19:20.664]                     workers <- structure(as.integer(workers), 
[13:19:20.664]                       class = class(workers))
[13:19:20.664]                     stop_if_not(is.finite(workers), workers >= 
[13:19:20.664]                       1L)
[13:19:20.664]                     if ((workers == 1L && !inherits(workers, 
[13:19:20.664]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:20.664]                       if (default_workers) 
[13:19:20.664]                         supportsMulticore(warn = TRUE)
[13:19:20.664]                       return(sequential(..., envir = envir))
[13:19:20.664]                     }
[13:19:20.664]                     oopts <- options(mc.cores = workers)
[13:19:20.664]                     on.exit(options(oopts))
[13:19:20.664]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:20.664]                       envir = envir)
[13:19:20.664]                     if (!future$lazy) 
[13:19:20.664]                       future <- run(future)
[13:19:20.664]                     invisible(future)
[13:19:20.664]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:20.664]                 }
[13:19:20.664]             }
[13:19:20.664]         }
[13:19:20.664]     })
[13:19:20.664]     if (FALSE) {
[13:19:20.664]         base::sink(type = "output", split = FALSE)
[13:19:20.664]         if (NA) {
[13:19:20.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:20.664]         }
[13:19:20.664]         else {
[13:19:20.664]             ...future.result["stdout"] <- base::list(NULL)
[13:19:20.664]         }
[13:19:20.664]         base::close(...future.stdout)
[13:19:20.664]         ...future.stdout <- NULL
[13:19:20.664]     }
[13:19:20.664]     ...future.result$conditions <- ...future.conditions
[13:19:20.664]     ...future.result$finished <- base::Sys.time()
[13:19:20.664]     ...future.result
[13:19:20.664] }
[13:19:20.666] assign_globals() ...
[13:19:20.666] List of 5
[13:19:20.666]  $ ...future.FUN            :function (x)  
[13:19:20.666]  $ future.call.arguments    : list()
[13:19:20.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:20.666]  $ ...future.elements_ii    :List of 1
[13:19:20.666]   ..$ : int 1
[13:19:20.666]  $ ...future.seeds_ii       : NULL
[13:19:20.666]  $ ...future.globals.maxSize: NULL
[13:19:20.666]  - attr(*, "where")=List of 5
[13:19:20.666]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:20.666]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:20.666]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:20.666]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:20.666]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:20.666]  - attr(*, "resolved")= logi FALSE
[13:19:20.666]  - attr(*, "total_size")= num 4720
[13:19:20.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:20.666]  - attr(*, "already-done")= logi TRUE
[13:19:20.671] - reassign environment for ‘...future.FUN’
[13:19:20.671] - copied ‘...future.FUN’ to environment
[13:19:20.671] - copied ‘future.call.arguments’ to environment
[13:19:20.671] - copied ‘...future.elements_ii’ to environment
[13:19:20.671] - copied ‘...future.seeds_ii’ to environment
[13:19:20.671] - copied ‘...future.globals.maxSize’ to environment
[13:19:20.672] assign_globals() ... done
[13:19:20.672] requestCore(): workers = 2
[13:19:20.674] MulticoreFuture started
[13:19:20.674] - Launch lazy future ... done
[13:19:20.674] run() for ‘MulticoreFuture’ ... done
[13:19:20.674] Created future:
[13:19:20.675] plan(): Setting new future strategy stack:
[13:19:20.675] List of future strategies:
[13:19:20.675] 1. sequential:
[13:19:20.675]    - args: function (..., envir = parent.frame())
[13:19:20.675]    - tweaked: FALSE
[13:19:20.675]    - call: NULL
[13:19:20.676] plan(): nbrOfWorkers() = 1
[13:19:20.675] MulticoreFuture:
[13:19:20.675] Label: ‘future_lapply-1’
[13:19:20.675] Expression:
[13:19:20.675] {
[13:19:20.675]     do.call(function(...) {
[13:19:20.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:20.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.675]             on.exit(options(oopts), add = TRUE)
[13:19:20.675]         }
[13:19:20.675]         {
[13:19:20.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:20.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.675]                 ...future.FUN(...future.X_jj, ...)
[13:19:20.675]             })
[13:19:20.675]         }
[13:19:20.675]     }, args = future.call.arguments)
[13:19:20.675] }
[13:19:20.675] Lazy evaluation: FALSE
[13:19:20.675] Asynchronous evaluation: TRUE
[13:19:20.675] Local evaluation: TRUE
[13:19:20.675] Environment: R_GlobalEnv
[13:19:20.675] Capture standard output: NA
[13:19:20.675] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:20.675] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:20.675] Packages: <none>
[13:19:20.675] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:20.675] Resolved: FALSE
[13:19:20.675] Value: <not collected>
[13:19:20.675] Conditions captured: <none>
[13:19:20.675] Early signaling: FALSE
[13:19:20.675] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:20.675] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:20.688] Chunk #1 of 2 ... DONE
[13:19:20.688] Chunk #2 of 2 ...
[13:19:20.688]  - Finding globals in 'X' for chunk #2 ...
[13:19:20.688] getGlobalsAndPackages() ...
[13:19:20.688] Searching for globals...
[13:19:20.689] 
[13:19:20.689] Searching for globals ... DONE
[13:19:20.689] - globals: [0] <none>
[13:19:20.689] getGlobalsAndPackages() ... DONE
[13:19:20.689]    + additional globals found: [n=0] 
[13:19:20.690]    + additional namespaces needed: [n=0] 
[13:19:20.690]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:20.690]  - seeds: <none>
[13:19:20.690] getGlobalsAndPackages() ...
[13:19:20.690] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:20.690] Resolving globals: FALSE
[13:19:20.690] Tweak future expression to call with '...' arguments ...
[13:19:20.691] {
[13:19:20.691]     do.call(function(...) {
[13:19:20.691]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.691]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:20.691]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.691]             on.exit(options(oopts), add = TRUE)
[13:19:20.691]         }
[13:19:20.691]         {
[13:19:20.691]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:20.691]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.691]                 ...future.FUN(...future.X_jj, ...)
[13:19:20.691]             })
[13:19:20.691]         }
[13:19:20.691]     }, args = future.call.arguments)
[13:19:20.691] }
[13:19:20.691] Tweak future expression to call with '...' arguments ... DONE
[13:19:20.692] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:20.692] 
[13:19:20.692] getGlobalsAndPackages() ... DONE
[13:19:20.693] run() for ‘Future’ ...
[13:19:20.693] - state: ‘created’
[13:19:20.693] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:20.698] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:20.698] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:20.699]   - Field: ‘label’
[13:19:20.699]   - Field: ‘local’
[13:19:20.699]   - Field: ‘owner’
[13:19:20.699]   - Field: ‘envir’
[13:19:20.699]   - Field: ‘workers’
[13:19:20.699]   - Field: ‘packages’
[13:19:20.699]   - Field: ‘gc’
[13:19:20.700]   - Field: ‘job’
[13:19:20.700]   - Field: ‘conditions’
[13:19:20.700]   - Field: ‘expr’
[13:19:20.700]   - Field: ‘uuid’
[13:19:20.700]   - Field: ‘seed’
[13:19:20.700]   - Field: ‘version’
[13:19:20.700]   - Field: ‘result’
[13:19:20.701]   - Field: ‘asynchronous’
[13:19:20.701]   - Field: ‘calls’
[13:19:20.701]   - Field: ‘globals’
[13:19:20.701]   - Field: ‘stdout’
[13:19:20.701]   - Field: ‘earlySignal’
[13:19:20.701]   - Field: ‘lazy’
[13:19:20.701]   - Field: ‘state’
[13:19:20.702] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:20.702] - Launch lazy future ...
[13:19:20.702] Packages needed by the future expression (n = 0): <none>
[13:19:20.702] Packages needed by future strategies (n = 0): <none>
[13:19:20.703] {
[13:19:20.703]     {
[13:19:20.703]         {
[13:19:20.703]             ...future.startTime <- base::Sys.time()
[13:19:20.703]             {
[13:19:20.703]                 {
[13:19:20.703]                   {
[13:19:20.703]                     {
[13:19:20.703]                       base::local({
[13:19:20.703]                         has_future <- base::requireNamespace("future", 
[13:19:20.703]                           quietly = TRUE)
[13:19:20.703]                         if (has_future) {
[13:19:20.703]                           ns <- base::getNamespace("future")
[13:19:20.703]                           version <- ns[[".package"]][["version"]]
[13:19:20.703]                           if (is.null(version)) 
[13:19:20.703]                             version <- utils::packageVersion("future")
[13:19:20.703]                         }
[13:19:20.703]                         else {
[13:19:20.703]                           version <- NULL
[13:19:20.703]                         }
[13:19:20.703]                         if (!has_future || version < "1.8.0") {
[13:19:20.703]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:20.703]                             "", base::R.version$version.string), 
[13:19:20.703]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:20.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:20.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:20.703]                               "release", "version")], collapse = " "), 
[13:19:20.703]                             hostname = base::Sys.info()[["nodename"]])
[13:19:20.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:20.703]                             info)
[13:19:20.703]                           info <- base::paste(info, collapse = "; ")
[13:19:20.703]                           if (!has_future) {
[13:19:20.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:20.703]                               info)
[13:19:20.703]                           }
[13:19:20.703]                           else {
[13:19:20.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:20.703]                               info, version)
[13:19:20.703]                           }
[13:19:20.703]                           base::stop(msg)
[13:19:20.703]                         }
[13:19:20.703]                       })
[13:19:20.703]                     }
[13:19:20.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:20.703]                     base::options(mc.cores = 1L)
[13:19:20.703]                   }
[13:19:20.703]                   options(future.plan = NULL)
[13:19:20.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:20.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:20.703]                 }
[13:19:20.703]                 ...future.workdir <- getwd()
[13:19:20.703]             }
[13:19:20.703]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:20.703]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:20.703]         }
[13:19:20.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:20.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:20.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:20.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:20.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:20.703]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:20.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:20.703]             base::names(...future.oldOptions))
[13:19:20.703]     }
[13:19:20.703]     if (TRUE) {
[13:19:20.703]     }
[13:19:20.703]     else {
[13:19:20.703]         if (NA) {
[13:19:20.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:20.703]                 open = "w")
[13:19:20.703]         }
[13:19:20.703]         else {
[13:19:20.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:20.703]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:20.703]         }
[13:19:20.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:20.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:20.703]             base::sink(type = "output", split = FALSE)
[13:19:20.703]             base::close(...future.stdout)
[13:19:20.703]         }, add = TRUE)
[13:19:20.703]     }
[13:19:20.703]     ...future.frame <- base::sys.nframe()
[13:19:20.703]     ...future.conditions <- base::list()
[13:19:20.703]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:20.703]     if (FALSE) {
[13:19:20.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:20.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:20.703]     }
[13:19:20.703]     ...future.result <- base::tryCatch({
[13:19:20.703]         base::withCallingHandlers({
[13:19:20.703]             ...future.value <- base::withVisible(base::local({
[13:19:20.703]                 withCallingHandlers({
[13:19:20.703]                   {
[13:19:20.703]                     do.call(function(...) {
[13:19:20.703]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.703]                       if (!identical(...future.globals.maxSize.org, 
[13:19:20.703]                         ...future.globals.maxSize)) {
[13:19:20.703]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.703]                         on.exit(options(oopts), add = TRUE)
[13:19:20.703]                       }
[13:19:20.703]                       {
[13:19:20.703]                         lapply(seq_along(...future.elements_ii), 
[13:19:20.703]                           FUN = function(jj) {
[13:19:20.703]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.703]                             ...future.FUN(...future.X_jj, ...)
[13:19:20.703]                           })
[13:19:20.703]                       }
[13:19:20.703]                     }, args = future.call.arguments)
[13:19:20.703]                   }
[13:19:20.703]                 }, immediateCondition = function(cond) {
[13:19:20.703]                   save_rds <- function (object, pathname, ...) 
[13:19:20.703]                   {
[13:19:20.703]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:20.703]                     if (file_test("-f", pathname_tmp)) {
[13:19:20.703]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.703]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:20.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.703]                         fi_tmp[["mtime"]])
[13:19:20.703]                     }
[13:19:20.703]                     tryCatch({
[13:19:20.703]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:20.703]                     }, error = function(ex) {
[13:19:20.703]                       msg <- conditionMessage(ex)
[13:19:20.703]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.703]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:20.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.703]                         fi_tmp[["mtime"]], msg)
[13:19:20.703]                       ex$message <- msg
[13:19:20.703]                       stop(ex)
[13:19:20.703]                     })
[13:19:20.703]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:20.703]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:20.703]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:20.703]                       fi_tmp <- file.info(pathname_tmp)
[13:19:20.703]                       fi <- file.info(pathname)
[13:19:20.703]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:20.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:20.703]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:20.703]                         fi[["size"]], fi[["mtime"]])
[13:19:20.703]                       stop(msg)
[13:19:20.703]                     }
[13:19:20.703]                     invisible(pathname)
[13:19:20.703]                   }
[13:19:20.703]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:20.703]                     rootPath = tempdir()) 
[13:19:20.703]                   {
[13:19:20.703]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:20.703]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:20.703]                       tmpdir = path, fileext = ".rds")
[13:19:20.703]                     save_rds(obj, file)
[13:19:20.703]                   }
[13:19:20.703]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:20.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.703]                   {
[13:19:20.703]                     inherits <- base::inherits
[13:19:20.703]                     invokeRestart <- base::invokeRestart
[13:19:20.703]                     is.null <- base::is.null
[13:19:20.703]                     muffled <- FALSE
[13:19:20.703]                     if (inherits(cond, "message")) {
[13:19:20.703]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:20.703]                       if (muffled) 
[13:19:20.703]                         invokeRestart("muffleMessage")
[13:19:20.703]                     }
[13:19:20.703]                     else if (inherits(cond, "warning")) {
[13:19:20.703]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:20.703]                       if (muffled) 
[13:19:20.703]                         invokeRestart("muffleWarning")
[13:19:20.703]                     }
[13:19:20.703]                     else if (inherits(cond, "condition")) {
[13:19:20.703]                       if (!is.null(pattern)) {
[13:19:20.703]                         computeRestarts <- base::computeRestarts
[13:19:20.703]                         grepl <- base::grepl
[13:19:20.703]                         restarts <- computeRestarts(cond)
[13:19:20.703]                         for (restart in restarts) {
[13:19:20.703]                           name <- restart$name
[13:19:20.703]                           if (is.null(name)) 
[13:19:20.703]                             next
[13:19:20.703]                           if (!grepl(pattern, name)) 
[13:19:20.703]                             next
[13:19:20.703]                           invokeRestart(restart)
[13:19:20.703]                           muffled <- TRUE
[13:19:20.703]                           break
[13:19:20.703]                         }
[13:19:20.703]                       }
[13:19:20.703]                     }
[13:19:20.703]                     invisible(muffled)
[13:19:20.703]                   }
[13:19:20.703]                   muffleCondition(cond)
[13:19:20.703]                 })
[13:19:20.703]             }))
[13:19:20.703]             future::FutureResult(value = ...future.value$value, 
[13:19:20.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:20.703]                   ...future.rng), globalenv = if (FALSE) 
[13:19:20.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:20.703]                     ...future.globalenv.names))
[13:19:20.703]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:20.703]         }, condition = base::local({
[13:19:20.703]             c <- base::c
[13:19:20.703]             inherits <- base::inherits
[13:19:20.703]             invokeRestart <- base::invokeRestart
[13:19:20.703]             length <- base::length
[13:19:20.703]             list <- base::list
[13:19:20.703]             seq.int <- base::seq.int
[13:19:20.703]             signalCondition <- base::signalCondition
[13:19:20.703]             sys.calls <- base::sys.calls
[13:19:20.703]             `[[` <- base::`[[`
[13:19:20.703]             `+` <- base::`+`
[13:19:20.703]             `<<-` <- base::`<<-`
[13:19:20.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:20.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:20.703]                   3L)]
[13:19:20.703]             }
[13:19:20.703]             function(cond) {
[13:19:20.703]                 is_error <- inherits(cond, "error")
[13:19:20.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:20.703]                   NULL)
[13:19:20.703]                 if (is_error) {
[13:19:20.703]                   sessionInformation <- function() {
[13:19:20.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:20.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:20.703]                       search = base::search(), system = base::Sys.info())
[13:19:20.703]                   }
[13:19:20.703]                   ...future.conditions[[length(...future.conditions) + 
[13:19:20.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:20.703]                     cond$call), session = sessionInformation(), 
[13:19:20.703]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:20.703]                   signalCondition(cond)
[13:19:20.703]                 }
[13:19:20.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:20.703]                 "immediateCondition"))) {
[13:19:20.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:20.703]                   ...future.conditions[[length(...future.conditions) + 
[13:19:20.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:20.703]                   if (TRUE && !signal) {
[13:19:20.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.703]                     {
[13:19:20.703]                       inherits <- base::inherits
[13:19:20.703]                       invokeRestart <- base::invokeRestart
[13:19:20.703]                       is.null <- base::is.null
[13:19:20.703]                       muffled <- FALSE
[13:19:20.703]                       if (inherits(cond, "message")) {
[13:19:20.703]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:20.703]                         if (muffled) 
[13:19:20.703]                           invokeRestart("muffleMessage")
[13:19:20.703]                       }
[13:19:20.703]                       else if (inherits(cond, "warning")) {
[13:19:20.703]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:20.703]                         if (muffled) 
[13:19:20.703]                           invokeRestart("muffleWarning")
[13:19:20.703]                       }
[13:19:20.703]                       else if (inherits(cond, "condition")) {
[13:19:20.703]                         if (!is.null(pattern)) {
[13:19:20.703]                           computeRestarts <- base::computeRestarts
[13:19:20.703]                           grepl <- base::grepl
[13:19:20.703]                           restarts <- computeRestarts(cond)
[13:19:20.703]                           for (restart in restarts) {
[13:19:20.703]                             name <- restart$name
[13:19:20.703]                             if (is.null(name)) 
[13:19:20.703]                               next
[13:19:20.703]                             if (!grepl(pattern, name)) 
[13:19:20.703]                               next
[13:19:20.703]                             invokeRestart(restart)
[13:19:20.703]                             muffled <- TRUE
[13:19:20.703]                             break
[13:19:20.703]                           }
[13:19:20.703]                         }
[13:19:20.703]                       }
[13:19:20.703]                       invisible(muffled)
[13:19:20.703]                     }
[13:19:20.703]                     muffleCondition(cond, pattern = "^muffle")
[13:19:20.703]                   }
[13:19:20.703]                 }
[13:19:20.703]                 else {
[13:19:20.703]                   if (TRUE) {
[13:19:20.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:20.703]                     {
[13:19:20.703]                       inherits <- base::inherits
[13:19:20.703]                       invokeRestart <- base::invokeRestart
[13:19:20.703]                       is.null <- base::is.null
[13:19:20.703]                       muffled <- FALSE
[13:19:20.703]                       if (inherits(cond, "message")) {
[13:19:20.703]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:20.703]                         if (muffled) 
[13:19:20.703]                           invokeRestart("muffleMessage")
[13:19:20.703]                       }
[13:19:20.703]                       else if (inherits(cond, "warning")) {
[13:19:20.703]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:20.703]                         if (muffled) 
[13:19:20.703]                           invokeRestart("muffleWarning")
[13:19:20.703]                       }
[13:19:20.703]                       else if (inherits(cond, "condition")) {
[13:19:20.703]                         if (!is.null(pattern)) {
[13:19:20.703]                           computeRestarts <- base::computeRestarts
[13:19:20.703]                           grepl <- base::grepl
[13:19:20.703]                           restarts <- computeRestarts(cond)
[13:19:20.703]                           for (restart in restarts) {
[13:19:20.703]                             name <- restart$name
[13:19:20.703]                             if (is.null(name)) 
[13:19:20.703]                               next
[13:19:20.703]                             if (!grepl(pattern, name)) 
[13:19:20.703]                               next
[13:19:20.703]                             invokeRestart(restart)
[13:19:20.703]                             muffled <- TRUE
[13:19:20.703]                             break
[13:19:20.703]                           }
[13:19:20.703]                         }
[13:19:20.703]                       }
[13:19:20.703]                       invisible(muffled)
[13:19:20.703]                     }
[13:19:20.703]                     muffleCondition(cond, pattern = "^muffle")
[13:19:20.703]                   }
[13:19:20.703]                 }
[13:19:20.703]             }
[13:19:20.703]         }))
[13:19:20.703]     }, error = function(ex) {
[13:19:20.703]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:20.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:20.703]                 ...future.rng), started = ...future.startTime, 
[13:19:20.703]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:20.703]             version = "1.8"), class = "FutureResult")
[13:19:20.703]     }, finally = {
[13:19:20.703]         if (!identical(...future.workdir, getwd())) 
[13:19:20.703]             setwd(...future.workdir)
[13:19:20.703]         {
[13:19:20.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:20.703]                 ...future.oldOptions$nwarnings <- NULL
[13:19:20.703]             }
[13:19:20.703]             base::options(...future.oldOptions)
[13:19:20.703]             if (.Platform$OS.type == "windows") {
[13:19:20.703]                 old_names <- names(...future.oldEnvVars)
[13:19:20.703]                 envs <- base::Sys.getenv()
[13:19:20.703]                 names <- names(envs)
[13:19:20.703]                 common <- intersect(names, old_names)
[13:19:20.703]                 added <- setdiff(names, old_names)
[13:19:20.703]                 removed <- setdiff(old_names, names)
[13:19:20.703]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:20.703]                   envs[common]]
[13:19:20.703]                 NAMES <- toupper(changed)
[13:19:20.703]                 args <- list()
[13:19:20.703]                 for (kk in seq_along(NAMES)) {
[13:19:20.703]                   name <- changed[[kk]]
[13:19:20.703]                   NAME <- NAMES[[kk]]
[13:19:20.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.703]                     next
[13:19:20.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:20.703]                 }
[13:19:20.703]                 NAMES <- toupper(added)
[13:19:20.703]                 for (kk in seq_along(NAMES)) {
[13:19:20.703]                   name <- added[[kk]]
[13:19:20.703]                   NAME <- NAMES[[kk]]
[13:19:20.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.703]                     next
[13:19:20.703]                   args[[name]] <- ""
[13:19:20.703]                 }
[13:19:20.703]                 NAMES <- toupper(removed)
[13:19:20.703]                 for (kk in seq_along(NAMES)) {
[13:19:20.703]                   name <- removed[[kk]]
[13:19:20.703]                   NAME <- NAMES[[kk]]
[13:19:20.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:20.703]                     next
[13:19:20.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:20.703]                 }
[13:19:20.703]                 if (length(args) > 0) 
[13:19:20.703]                   base::do.call(base::Sys.setenv, args = args)
[13:19:20.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:20.703]             }
[13:19:20.703]             else {
[13:19:20.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:20.703]             }
[13:19:20.703]             {
[13:19:20.703]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:20.703]                   0L) {
[13:19:20.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:20.703]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:20.703]                   base::options(opts)
[13:19:20.703]                 }
[13:19:20.703]                 {
[13:19:20.703]                   {
[13:19:20.703]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:20.703]                     NULL
[13:19:20.703]                   }
[13:19:20.703]                   options(future.plan = NULL)
[13:19:20.703]                   if (is.na(NA_character_)) 
[13:19:20.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:20.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:20.703]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:20.703]                     envir = parent.frame()) 
[13:19:20.703]                   {
[13:19:20.703]                     default_workers <- missing(workers)
[13:19:20.703]                     if (is.function(workers)) 
[13:19:20.703]                       workers <- workers()
[13:19:20.703]                     workers <- structure(as.integer(workers), 
[13:19:20.703]                       class = class(workers))
[13:19:20.703]                     stop_if_not(is.finite(workers), workers >= 
[13:19:20.703]                       1L)
[13:19:20.703]                     if ((workers == 1L && !inherits(workers, 
[13:19:20.703]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:20.703]                       if (default_workers) 
[13:19:20.703]                         supportsMulticore(warn = TRUE)
[13:19:20.703]                       return(sequential(..., envir = envir))
[13:19:20.703]                     }
[13:19:20.703]                     oopts <- options(mc.cores = workers)
[13:19:20.703]                     on.exit(options(oopts))
[13:19:20.703]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:20.703]                       envir = envir)
[13:19:20.703]                     if (!future$lazy) 
[13:19:20.703]                       future <- run(future)
[13:19:20.703]                     invisible(future)
[13:19:20.703]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:20.703]                 }
[13:19:20.703]             }
[13:19:20.703]         }
[13:19:20.703]     })
[13:19:20.703]     if (FALSE) {
[13:19:20.703]         base::sink(type = "output", split = FALSE)
[13:19:20.703]         if (NA) {
[13:19:20.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:20.703]         }
[13:19:20.703]         else {
[13:19:20.703]             ...future.result["stdout"] <- base::list(NULL)
[13:19:20.703]         }
[13:19:20.703]         base::close(...future.stdout)
[13:19:20.703]         ...future.stdout <- NULL
[13:19:20.703]     }
[13:19:20.703]     ...future.result$conditions <- ...future.conditions
[13:19:20.703]     ...future.result$finished <- base::Sys.time()
[13:19:20.703]     ...future.result
[13:19:20.703] }
[13:19:20.707] assign_globals() ...
[13:19:20.707] List of 5
[13:19:20.707]  $ ...future.FUN            :function (x)  
[13:19:20.707]  $ future.call.arguments    : list()
[13:19:20.707]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:20.707]  $ ...future.elements_ii    :List of 1
[13:19:20.707]   ..$ : int 0
[13:19:20.707]  $ ...future.seeds_ii       : NULL
[13:19:20.707]  $ ...future.globals.maxSize: NULL
[13:19:20.707]  - attr(*, "where")=List of 5
[13:19:20.707]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:20.707]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:19:20.707]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:20.707]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:20.707]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:20.707]  - attr(*, "resolved")= logi FALSE
[13:19:20.707]  - attr(*, "total_size")= num 4720
[13:19:20.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:20.707]  - attr(*, "already-done")= logi TRUE
[13:19:20.720] - reassign environment for ‘...future.FUN’
[13:19:20.721] - copied ‘...future.FUN’ to environment
[13:19:20.721] - copied ‘future.call.arguments’ to environment
[13:19:20.721] - copied ‘...future.elements_ii’ to environment
[13:19:20.721] - copied ‘...future.seeds_ii’ to environment
[13:19:20.721] - copied ‘...future.globals.maxSize’ to environment
[13:19:20.721] assign_globals() ... done
[13:19:20.722] requestCore(): workers = 2
[13:19:20.724] MulticoreFuture started
[13:19:20.724] - Launch lazy future ... done
[13:19:20.724] run() for ‘MulticoreFuture’ ... done
[13:19:20.725] Created future:
[13:19:20.725] plan(): Setting new future strategy stack:
[13:19:20.725] List of future strategies:
[13:19:20.725] 1. sequential:
[13:19:20.725]    - args: function (..., envir = parent.frame())
[13:19:20.725]    - tweaked: FALSE
[13:19:20.725]    - call: NULL
[13:19:20.726] plan(): nbrOfWorkers() = 1
[13:19:20.728] plan(): Setting new future strategy stack:
[13:19:20.728] List of future strategies:
[13:19:20.728] 1. multicore:
[13:19:20.728]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:20.728]    - tweaked: FALSE
[13:19:20.728]    - call: plan(strategy)
[13:19:20.734] plan(): nbrOfWorkers() = 2
[13:19:20.725] MulticoreFuture:
[13:19:20.725] Label: ‘future_lapply-2’
[13:19:20.725] Expression:
[13:19:20.725] {
[13:19:20.725]     do.call(function(...) {
[13:19:20.725]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:20.725]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:20.725]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:20.725]             on.exit(options(oopts), add = TRUE)
[13:19:20.725]         }
[13:19:20.725]         {
[13:19:20.725]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:20.725]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:20.725]                 ...future.FUN(...future.X_jj, ...)
[13:19:20.725]             })
[13:19:20.725]         }
[13:19:20.725]     }, args = future.call.arguments)
[13:19:20.725] }
[13:19:20.725] Lazy evaluation: FALSE
[13:19:20.725] Asynchronous evaluation: TRUE
[13:19:20.725] Local evaluation: TRUE
[13:19:20.725] Environment: R_GlobalEnv
[13:19:20.725] Capture standard output: NA
[13:19:20.725] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:20.725] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:20.725] Packages: <none>
[13:19:20.725] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:20.725] Resolved: TRUE
[13:19:20.725] Value: <not collected>
[13:19:20.725] Conditions captured: <none>
[13:19:20.725] Early signaling: FALSE
[13:19:20.725] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:20.725] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:20.735] Chunk #2 of 2 ... DONE
[13:19:20.735] Launching 2 futures (chunks) ... DONE
[13:19:20.736] Resolving 2 futures (chunks) ...
[13:19:20.736] resolve() on list ...
[13:19:20.736]  recursive: 0
[13:19:20.736]  length: 2
[13:19:20.736] 
[13:19:20.747] Future #2
[13:19:20.748] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:20.748] - nx: 2
[13:19:20.749] - relay: TRUE
[13:19:20.749] - stdout: TRUE
[13:19:20.749] - signal: TRUE
[13:19:20.749] - resignal: FALSE
[13:19:20.749] - force: TRUE
[13:19:20.750] - relayed: [n=2] FALSE, FALSE
[13:19:20.750] - queued futures: [n=2] FALSE, FALSE
[13:19:20.750]  - until=1
[13:19:20.750]  - relaying element #1
[13:19:20.750] - relayed: [n=2] FALSE, FALSE
[13:19:20.751] - queued futures: [n=2] FALSE, TRUE
[13:19:20.751] signalConditionsASAP(NULL, pos=2) ... done
[13:19:20.751]  length: 1 (resolved future 2)
[13:19:21.179] plan(): Setting new future strategy stack:
[13:19:21.179] List of future strategies:
[13:19:21.179] 1. multicore:
[13:19:21.179]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:21.179]    - tweaked: FALSE
[13:19:21.179]    - call: plan(strategy)
[13:19:21.183] plan(): nbrOfWorkers() = 2
[13:19:21.189] Future #1
[13:19:21.190] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:21.190] - nx: 2
[13:19:21.190] - relay: TRUE
[13:19:21.190] - stdout: TRUE
[13:19:21.191] - signal: TRUE
[13:19:21.191] - resignal: FALSE
[13:19:21.191] - force: TRUE
[13:19:21.191] - relayed: [n=2] FALSE, FALSE
[13:19:21.191] - queued futures: [n=2] FALSE, TRUE
[13:19:21.191]  - until=1
[13:19:21.191]  - relaying element #1
[13:19:21.191] - relayed: [n=2] TRUE, FALSE
[13:19:21.192] - queued futures: [n=2] TRUE, TRUE
[13:19:21.192] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:21.192]  length: 0 (resolved future 1)
[13:19:21.192] Relaying remaining futures
[13:19:21.192] signalConditionsASAP(NULL, pos=0) ...
[13:19:21.192] - nx: 2
[13:19:21.192] - relay: TRUE
[13:19:21.192] - stdout: TRUE
[13:19:21.192] - signal: TRUE
[13:19:21.193] - resignal: FALSE
[13:19:21.193] - force: TRUE
[13:19:21.193] - relayed: [n=2] TRUE, FALSE
[13:19:21.193] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:21.193]  - relaying element #2
[13:19:21.193] - relayed: [n=2] TRUE, TRUE
[13:19:21.193] - queued futures: [n=2] TRUE, TRUE
[13:19:21.194] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:19:21.194] resolve() on list ... DONE
[13:19:21.194]  - Number of value chunks collected: 2
[13:19:21.194] Resolving 2 futures (chunks) ... DONE
[13:19:21.194] Reducing values from 2 chunks ...
[13:19:21.194]  - Number of values collected after concatenation: 2
[13:19:21.194]  - Number of values expected: 2
[13:19:21.195] Reducing values from 2 chunks ... DONE
[13:19:21.195] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:19:21.195] future_mapply() ...
[13:19:21.200] Number of chunks: 2
[13:19:21.200] getGlobalsAndPackagesXApply() ...
[13:19:21.200]  - future.globals: TRUE
[13:19:21.200] getGlobalsAndPackages() ...
[13:19:21.200] Searching for globals...
[13:19:21.202] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:21.202] Searching for globals ... DONE
[13:19:21.202] Resolving globals: FALSE
[13:19:21.203] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:21.203] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:21.203] - globals: [1] ‘FUN’
[13:19:21.204] 
[13:19:21.205] getGlobalsAndPackages() ... DONE
[13:19:21.206]  - globals found/used: [n=1] ‘FUN’
[13:19:21.206]  - needed namespaces: [n=0] 
[13:19:21.206] Finding globals ... DONE
[13:19:21.206] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:21.206] List of 2
[13:19:21.206]  $ ...future.FUN:function (x, y)  
[13:19:21.206]  $ MoreArgs     : NULL
[13:19:21.206]  - attr(*, "where")=List of 2
[13:19:21.206]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:21.206]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:21.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:21.206]  - attr(*, "resolved")= logi FALSE
[13:19:21.206]  - attr(*, "total_size")= num NA
[13:19:21.210] Packages to be attached in all futures: [n=0] 
[13:19:21.210] getGlobalsAndPackagesXApply() ... DONE
[13:19:21.210] Number of futures (= number of chunks): 2
[13:19:21.211] Launching 2 futures (chunks) ...
[13:19:21.211] Chunk #1 of 2 ...
[13:19:21.211]  - Finding globals in '...' for chunk #1 ...
[13:19:21.211] getGlobalsAndPackages() ...
[13:19:21.211] Searching for globals...
[13:19:21.212] 
[13:19:21.212] Searching for globals ... DONE
[13:19:21.212] - globals: [0] <none>
[13:19:21.212] getGlobalsAndPackages() ... DONE
[13:19:21.212]    + additional globals found: [n=0] 
[13:19:21.212]    + additional namespaces needed: [n=0] 
[13:19:21.212]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:21.212]  - seeds: <none>
[13:19:21.213] getGlobalsAndPackages() ...
[13:19:21.213] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:21.213] Resolving globals: FALSE
[13:19:21.213] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:21.214] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:21.214] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:21.214] 
[13:19:21.214] getGlobalsAndPackages() ... DONE
[13:19:21.214] run() for ‘Future’ ...
[13:19:21.215] - state: ‘created’
[13:19:21.215] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:21.218] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:21.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:21.218]   - Field: ‘label’
[13:19:21.219]   - Field: ‘local’
[13:19:21.219]   - Field: ‘owner’
[13:19:21.219]   - Field: ‘envir’
[13:19:21.219]   - Field: ‘workers’
[13:19:21.219]   - Field: ‘packages’
[13:19:21.219]   - Field: ‘gc’
[13:19:21.219]   - Field: ‘job’
[13:19:21.219]   - Field: ‘conditions’
[13:19:21.219]   - Field: ‘expr’
[13:19:21.219]   - Field: ‘uuid’
[13:19:21.220]   - Field: ‘seed’
[13:19:21.220]   - Field: ‘version’
[13:19:21.220]   - Field: ‘result’
[13:19:21.220]   - Field: ‘asynchronous’
[13:19:21.220]   - Field: ‘calls’
[13:19:21.220]   - Field: ‘globals’
[13:19:21.220]   - Field: ‘stdout’
[13:19:21.220]   - Field: ‘earlySignal’
[13:19:21.220]   - Field: ‘lazy’
[13:19:21.220]   - Field: ‘state’
[13:19:21.220] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:21.221] - Launch lazy future ...
[13:19:21.221] Packages needed by the future expression (n = 0): <none>
[13:19:21.221] Packages needed by future strategies (n = 0): <none>
[13:19:21.221] {
[13:19:21.221]     {
[13:19:21.221]         {
[13:19:21.221]             ...future.startTime <- base::Sys.time()
[13:19:21.221]             {
[13:19:21.221]                 {
[13:19:21.221]                   {
[13:19:21.221]                     {
[13:19:21.221]                       base::local({
[13:19:21.221]                         has_future <- base::requireNamespace("future", 
[13:19:21.221]                           quietly = TRUE)
[13:19:21.221]                         if (has_future) {
[13:19:21.221]                           ns <- base::getNamespace("future")
[13:19:21.221]                           version <- ns[[".package"]][["version"]]
[13:19:21.221]                           if (is.null(version)) 
[13:19:21.221]                             version <- utils::packageVersion("future")
[13:19:21.221]                         }
[13:19:21.221]                         else {
[13:19:21.221]                           version <- NULL
[13:19:21.221]                         }
[13:19:21.221]                         if (!has_future || version < "1.8.0") {
[13:19:21.221]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:21.221]                             "", base::R.version$version.string), 
[13:19:21.221]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:21.221]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:21.221]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:21.221]                               "release", "version")], collapse = " "), 
[13:19:21.221]                             hostname = base::Sys.info()[["nodename"]])
[13:19:21.221]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:21.221]                             info)
[13:19:21.221]                           info <- base::paste(info, collapse = "; ")
[13:19:21.221]                           if (!has_future) {
[13:19:21.221]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:21.221]                               info)
[13:19:21.221]                           }
[13:19:21.221]                           else {
[13:19:21.221]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:21.221]                               info, version)
[13:19:21.221]                           }
[13:19:21.221]                           base::stop(msg)
[13:19:21.221]                         }
[13:19:21.221]                       })
[13:19:21.221]                     }
[13:19:21.221]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:21.221]                     base::options(mc.cores = 1L)
[13:19:21.221]                   }
[13:19:21.221]                   options(future.plan = NULL)
[13:19:21.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:21.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:21.221]                 }
[13:19:21.221]                 ...future.workdir <- getwd()
[13:19:21.221]             }
[13:19:21.221]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:21.221]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:21.221]         }
[13:19:21.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:21.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:21.221]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:21.221]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:21.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:21.221]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:21.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:21.221]             base::names(...future.oldOptions))
[13:19:21.221]     }
[13:19:21.221]     if (FALSE) {
[13:19:21.221]     }
[13:19:21.221]     else {
[13:19:21.221]         if (FALSE) {
[13:19:21.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:21.221]                 open = "w")
[13:19:21.221]         }
[13:19:21.221]         else {
[13:19:21.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:21.221]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:21.221]         }
[13:19:21.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:21.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:21.221]             base::sink(type = "output", split = FALSE)
[13:19:21.221]             base::close(...future.stdout)
[13:19:21.221]         }, add = TRUE)
[13:19:21.221]     }
[13:19:21.221]     ...future.frame <- base::sys.nframe()
[13:19:21.221]     ...future.conditions <- base::list()
[13:19:21.221]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:21.221]     if (FALSE) {
[13:19:21.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:21.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:21.221]     }
[13:19:21.221]     ...future.result <- base::tryCatch({
[13:19:21.221]         base::withCallingHandlers({
[13:19:21.221]             ...future.value <- base::withVisible(base::local({
[13:19:21.221]                 withCallingHandlers({
[13:19:21.221]                   {
[13:19:21.221]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:21.221]                     if (!identical(...future.globals.maxSize.org, 
[13:19:21.221]                       ...future.globals.maxSize)) {
[13:19:21.221]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:21.221]                       on.exit(options(oopts), add = TRUE)
[13:19:21.221]                     }
[13:19:21.221]                     {
[13:19:21.221]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:21.221]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:21.221]                         USE.NAMES = FALSE)
[13:19:21.221]                       do.call(mapply, args = args)
[13:19:21.221]                     }
[13:19:21.221]                   }
[13:19:21.221]                 }, immediateCondition = function(cond) {
[13:19:21.221]                   save_rds <- function (object, pathname, ...) 
[13:19:21.221]                   {
[13:19:21.221]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:21.221]                     if (file_test("-f", pathname_tmp)) {
[13:19:21.221]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.221]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:21.221]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.221]                         fi_tmp[["mtime"]])
[13:19:21.221]                     }
[13:19:21.221]                     tryCatch({
[13:19:21.221]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:21.221]                     }, error = function(ex) {
[13:19:21.221]                       msg <- conditionMessage(ex)
[13:19:21.221]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.221]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:21.221]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.221]                         fi_tmp[["mtime"]], msg)
[13:19:21.221]                       ex$message <- msg
[13:19:21.221]                       stop(ex)
[13:19:21.221]                     })
[13:19:21.221]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:21.221]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:21.221]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:21.221]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.221]                       fi <- file.info(pathname)
[13:19:21.221]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:21.221]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.221]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:21.221]                         fi[["size"]], fi[["mtime"]])
[13:19:21.221]                       stop(msg)
[13:19:21.221]                     }
[13:19:21.221]                     invisible(pathname)
[13:19:21.221]                   }
[13:19:21.221]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:21.221]                     rootPath = tempdir()) 
[13:19:21.221]                   {
[13:19:21.221]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:21.221]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:21.221]                       tmpdir = path, fileext = ".rds")
[13:19:21.221]                     save_rds(obj, file)
[13:19:21.221]                   }
[13:19:21.221]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:21.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.221]                   {
[13:19:21.221]                     inherits <- base::inherits
[13:19:21.221]                     invokeRestart <- base::invokeRestart
[13:19:21.221]                     is.null <- base::is.null
[13:19:21.221]                     muffled <- FALSE
[13:19:21.221]                     if (inherits(cond, "message")) {
[13:19:21.221]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:21.221]                       if (muffled) 
[13:19:21.221]                         invokeRestart("muffleMessage")
[13:19:21.221]                     }
[13:19:21.221]                     else if (inherits(cond, "warning")) {
[13:19:21.221]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:21.221]                       if (muffled) 
[13:19:21.221]                         invokeRestart("muffleWarning")
[13:19:21.221]                     }
[13:19:21.221]                     else if (inherits(cond, "condition")) {
[13:19:21.221]                       if (!is.null(pattern)) {
[13:19:21.221]                         computeRestarts <- base::computeRestarts
[13:19:21.221]                         grepl <- base::grepl
[13:19:21.221]                         restarts <- computeRestarts(cond)
[13:19:21.221]                         for (restart in restarts) {
[13:19:21.221]                           name <- restart$name
[13:19:21.221]                           if (is.null(name)) 
[13:19:21.221]                             next
[13:19:21.221]                           if (!grepl(pattern, name)) 
[13:19:21.221]                             next
[13:19:21.221]                           invokeRestart(restart)
[13:19:21.221]                           muffled <- TRUE
[13:19:21.221]                           break
[13:19:21.221]                         }
[13:19:21.221]                       }
[13:19:21.221]                     }
[13:19:21.221]                     invisible(muffled)
[13:19:21.221]                   }
[13:19:21.221]                   muffleCondition(cond)
[13:19:21.221]                 })
[13:19:21.221]             }))
[13:19:21.221]             future::FutureResult(value = ...future.value$value, 
[13:19:21.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:21.221]                   ...future.rng), globalenv = if (FALSE) 
[13:19:21.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:21.221]                     ...future.globalenv.names))
[13:19:21.221]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:21.221]         }, condition = base::local({
[13:19:21.221]             c <- base::c
[13:19:21.221]             inherits <- base::inherits
[13:19:21.221]             invokeRestart <- base::invokeRestart
[13:19:21.221]             length <- base::length
[13:19:21.221]             list <- base::list
[13:19:21.221]             seq.int <- base::seq.int
[13:19:21.221]             signalCondition <- base::signalCondition
[13:19:21.221]             sys.calls <- base::sys.calls
[13:19:21.221]             `[[` <- base::`[[`
[13:19:21.221]             `+` <- base::`+`
[13:19:21.221]             `<<-` <- base::`<<-`
[13:19:21.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:21.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:21.221]                   3L)]
[13:19:21.221]             }
[13:19:21.221]             function(cond) {
[13:19:21.221]                 is_error <- inherits(cond, "error")
[13:19:21.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:21.221]                   NULL)
[13:19:21.221]                 if (is_error) {
[13:19:21.221]                   sessionInformation <- function() {
[13:19:21.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:21.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:21.221]                       search = base::search(), system = base::Sys.info())
[13:19:21.221]                   }
[13:19:21.221]                   ...future.conditions[[length(...future.conditions) + 
[13:19:21.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:21.221]                     cond$call), session = sessionInformation(), 
[13:19:21.221]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:21.221]                   signalCondition(cond)
[13:19:21.221]                 }
[13:19:21.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:21.221]                 "immediateCondition"))) {
[13:19:21.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:21.221]                   ...future.conditions[[length(...future.conditions) + 
[13:19:21.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:21.221]                   if (TRUE && !signal) {
[13:19:21.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.221]                     {
[13:19:21.221]                       inherits <- base::inherits
[13:19:21.221]                       invokeRestart <- base::invokeRestart
[13:19:21.221]                       is.null <- base::is.null
[13:19:21.221]                       muffled <- FALSE
[13:19:21.221]                       if (inherits(cond, "message")) {
[13:19:21.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:21.221]                         if (muffled) 
[13:19:21.221]                           invokeRestart("muffleMessage")
[13:19:21.221]                       }
[13:19:21.221]                       else if (inherits(cond, "warning")) {
[13:19:21.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:21.221]                         if (muffled) 
[13:19:21.221]                           invokeRestart("muffleWarning")
[13:19:21.221]                       }
[13:19:21.221]                       else if (inherits(cond, "condition")) {
[13:19:21.221]                         if (!is.null(pattern)) {
[13:19:21.221]                           computeRestarts <- base::computeRestarts
[13:19:21.221]                           grepl <- base::grepl
[13:19:21.221]                           restarts <- computeRestarts(cond)
[13:19:21.221]                           for (restart in restarts) {
[13:19:21.221]                             name <- restart$name
[13:19:21.221]                             if (is.null(name)) 
[13:19:21.221]                               next
[13:19:21.221]                             if (!grepl(pattern, name)) 
[13:19:21.221]                               next
[13:19:21.221]                             invokeRestart(restart)
[13:19:21.221]                             muffled <- TRUE
[13:19:21.221]                             break
[13:19:21.221]                           }
[13:19:21.221]                         }
[13:19:21.221]                       }
[13:19:21.221]                       invisible(muffled)
[13:19:21.221]                     }
[13:19:21.221]                     muffleCondition(cond, pattern = "^muffle")
[13:19:21.221]                   }
[13:19:21.221]                 }
[13:19:21.221]                 else {
[13:19:21.221]                   if (TRUE) {
[13:19:21.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.221]                     {
[13:19:21.221]                       inherits <- base::inherits
[13:19:21.221]                       invokeRestart <- base::invokeRestart
[13:19:21.221]                       is.null <- base::is.null
[13:19:21.221]                       muffled <- FALSE
[13:19:21.221]                       if (inherits(cond, "message")) {
[13:19:21.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:21.221]                         if (muffled) 
[13:19:21.221]                           invokeRestart("muffleMessage")
[13:19:21.221]                       }
[13:19:21.221]                       else if (inherits(cond, "warning")) {
[13:19:21.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:21.221]                         if (muffled) 
[13:19:21.221]                           invokeRestart("muffleWarning")
[13:19:21.221]                       }
[13:19:21.221]                       else if (inherits(cond, "condition")) {
[13:19:21.221]                         if (!is.null(pattern)) {
[13:19:21.221]                           computeRestarts <- base::computeRestarts
[13:19:21.221]                           grepl <- base::grepl
[13:19:21.221]                           restarts <- computeRestarts(cond)
[13:19:21.221]                           for (restart in restarts) {
[13:19:21.221]                             name <- restart$name
[13:19:21.221]                             if (is.null(name)) 
[13:19:21.221]                               next
[13:19:21.221]                             if (!grepl(pattern, name)) 
[13:19:21.221]                               next
[13:19:21.221]                             invokeRestart(restart)
[13:19:21.221]                             muffled <- TRUE
[13:19:21.221]                             break
[13:19:21.221]                           }
[13:19:21.221]                         }
[13:19:21.221]                       }
[13:19:21.221]                       invisible(muffled)
[13:19:21.221]                     }
[13:19:21.221]                     muffleCondition(cond, pattern = "^muffle")
[13:19:21.221]                   }
[13:19:21.221]                 }
[13:19:21.221]             }
[13:19:21.221]         }))
[13:19:21.221]     }, error = function(ex) {
[13:19:21.221]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:21.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:21.221]                 ...future.rng), started = ...future.startTime, 
[13:19:21.221]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:21.221]             version = "1.8"), class = "FutureResult")
[13:19:21.221]     }, finally = {
[13:19:21.221]         if (!identical(...future.workdir, getwd())) 
[13:19:21.221]             setwd(...future.workdir)
[13:19:21.221]         {
[13:19:21.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:21.221]                 ...future.oldOptions$nwarnings <- NULL
[13:19:21.221]             }
[13:19:21.221]             base::options(...future.oldOptions)
[13:19:21.221]             if (.Platform$OS.type == "windows") {
[13:19:21.221]                 old_names <- names(...future.oldEnvVars)
[13:19:21.221]                 envs <- base::Sys.getenv()
[13:19:21.221]                 names <- names(envs)
[13:19:21.221]                 common <- intersect(names, old_names)
[13:19:21.221]                 added <- setdiff(names, old_names)
[13:19:21.221]                 removed <- setdiff(old_names, names)
[13:19:21.221]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:21.221]                   envs[common]]
[13:19:21.221]                 NAMES <- toupper(changed)
[13:19:21.221]                 args <- list()
[13:19:21.221]                 for (kk in seq_along(NAMES)) {
[13:19:21.221]                   name <- changed[[kk]]
[13:19:21.221]                   NAME <- NAMES[[kk]]
[13:19:21.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.221]                     next
[13:19:21.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:21.221]                 }
[13:19:21.221]                 NAMES <- toupper(added)
[13:19:21.221]                 for (kk in seq_along(NAMES)) {
[13:19:21.221]                   name <- added[[kk]]
[13:19:21.221]                   NAME <- NAMES[[kk]]
[13:19:21.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.221]                     next
[13:19:21.221]                   args[[name]] <- ""
[13:19:21.221]                 }
[13:19:21.221]                 NAMES <- toupper(removed)
[13:19:21.221]                 for (kk in seq_along(NAMES)) {
[13:19:21.221]                   name <- removed[[kk]]
[13:19:21.221]                   NAME <- NAMES[[kk]]
[13:19:21.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.221]                     next
[13:19:21.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:21.221]                 }
[13:19:21.221]                 if (length(args) > 0) 
[13:19:21.221]                   base::do.call(base::Sys.setenv, args = args)
[13:19:21.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:21.221]             }
[13:19:21.221]             else {
[13:19:21.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:21.221]             }
[13:19:21.221]             {
[13:19:21.221]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:21.221]                   0L) {
[13:19:21.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:21.221]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:21.221]                   base::options(opts)
[13:19:21.221]                 }
[13:19:21.221]                 {
[13:19:21.221]                   {
[13:19:21.221]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:21.221]                     NULL
[13:19:21.221]                   }
[13:19:21.221]                   options(future.plan = NULL)
[13:19:21.221]                   if (is.na(NA_character_)) 
[13:19:21.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:21.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:21.221]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:21.221]                     envir = parent.frame()) 
[13:19:21.221]                   {
[13:19:21.221]                     default_workers <- missing(workers)
[13:19:21.221]                     if (is.function(workers)) 
[13:19:21.221]                       workers <- workers()
[13:19:21.221]                     workers <- structure(as.integer(workers), 
[13:19:21.221]                       class = class(workers))
[13:19:21.221]                     stop_if_not(is.finite(workers), workers >= 
[13:19:21.221]                       1L)
[13:19:21.221]                     if ((workers == 1L && !inherits(workers, 
[13:19:21.221]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:21.221]                       if (default_workers) 
[13:19:21.221]                         supportsMulticore(warn = TRUE)
[13:19:21.221]                       return(sequential(..., envir = envir))
[13:19:21.221]                     }
[13:19:21.221]                     oopts <- options(mc.cores = workers)
[13:19:21.221]                     on.exit(options(oopts))
[13:19:21.221]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:21.221]                       envir = envir)
[13:19:21.221]                     if (!future$lazy) 
[13:19:21.221]                       future <- run(future)
[13:19:21.221]                     invisible(future)
[13:19:21.221]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:21.221]                 }
[13:19:21.221]             }
[13:19:21.221]         }
[13:19:21.221]     })
[13:19:21.221]     if (TRUE) {
[13:19:21.221]         base::sink(type = "output", split = FALSE)
[13:19:21.221]         if (FALSE) {
[13:19:21.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:21.221]         }
[13:19:21.221]         else {
[13:19:21.221]             ...future.result["stdout"] <- base::list(NULL)
[13:19:21.221]         }
[13:19:21.221]         base::close(...future.stdout)
[13:19:21.221]         ...future.stdout <- NULL
[13:19:21.221]     }
[13:19:21.221]     ...future.result$conditions <- ...future.conditions
[13:19:21.221]     ...future.result$finished <- base::Sys.time()
[13:19:21.221]     ...future.result
[13:19:21.221] }
[13:19:21.224] assign_globals() ...
[13:19:21.224] List of 5
[13:19:21.224]  $ ...future.FUN            :function (x, y)  
[13:19:21.224]  $ MoreArgs                 : NULL
[13:19:21.224]  $ ...future.elements_ii    :List of 2
[13:19:21.224]   ..$ :List of 1
[13:19:21.224]   .. ..$ : int 1
[13:19:21.224]   ..$ :List of 1
[13:19:21.224]   .. ..$ : int 0
[13:19:21.224]  $ ...future.seeds_ii       : NULL
[13:19:21.224]  $ ...future.globals.maxSize: NULL
[13:19:21.224]  - attr(*, "where")=List of 5
[13:19:21.224]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:21.224]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:21.224]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:21.224]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:21.224]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:21.224]  - attr(*, "resolved")= logi FALSE
[13:19:21.224]  - attr(*, "total_size")= num 6368
[13:19:21.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:21.224]  - attr(*, "already-done")= logi TRUE
[13:19:21.229] - reassign environment for ‘...future.FUN’
[13:19:21.229] - copied ‘...future.FUN’ to environment
[13:19:21.229] - copied ‘MoreArgs’ to environment
[13:19:21.230] - copied ‘...future.elements_ii’ to environment
[13:19:21.230] - copied ‘...future.seeds_ii’ to environment
[13:19:21.230] - copied ‘...future.globals.maxSize’ to environment
[13:19:21.230] assign_globals() ... done
[13:19:21.230] requestCore(): workers = 2
[13:19:21.232] MulticoreFuture started
[13:19:21.233] - Launch lazy future ... done
[13:19:21.233] run() for ‘MulticoreFuture’ ... done
[13:19:21.233] plan(): Setting new future strategy stack:
[13:19:21.233] Created future:
[13:19:21.233] List of future strategies:
[13:19:21.233] 1. sequential:
[13:19:21.233]    - args: function (..., envir = parent.frame())
[13:19:21.233]    - tweaked: FALSE
[13:19:21.233]    - call: NULL
[13:19:21.234] plan(): nbrOfWorkers() = 1
[13:19:21.234] MulticoreFuture:
[13:19:21.234] Label: ‘future_mapply-1’
[13:19:21.234] Expression:
[13:19:21.234] {
[13:19:21.234]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:21.234]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:21.234]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:21.234]         on.exit(options(oopts), add = TRUE)
[13:19:21.234]     }
[13:19:21.234]     {
[13:19:21.234]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:21.234]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:21.234]         do.call(mapply, args = args)
[13:19:21.234]     }
[13:19:21.234] }
[13:19:21.234] Lazy evaluation: FALSE
[13:19:21.234] Asynchronous evaluation: TRUE
[13:19:21.234] Local evaluation: TRUE
[13:19:21.234] Environment: R_GlobalEnv
[13:19:21.234] Capture standard output: FALSE
[13:19:21.234] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:21.234] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:21.234] Packages: <none>
[13:19:21.234] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:21.234] Resolved: FALSE
[13:19:21.234] Value: <not collected>
[13:19:21.234] Conditions captured: <none>
[13:19:21.234] Early signaling: FALSE
[13:19:21.234] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:21.234] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:21.246] Chunk #1 of 2 ... DONE
[13:19:21.246] Chunk #2 of 2 ...
[13:19:21.246]  - Finding globals in '...' for chunk #2 ...
[13:19:21.247] getGlobalsAndPackages() ...
[13:19:21.247] Searching for globals...
[13:19:21.251] 
[13:19:21.252] Searching for globals ... DONE
[13:19:21.252] - globals: [0] <none>
[13:19:21.252] getGlobalsAndPackages() ... DONE
[13:19:21.253]    + additional globals found: [n=0] 
[13:19:21.253]    + additional namespaces needed: [n=0] 
[13:19:21.253]  - Finding globals in '...' for chunk #2 ... DONE
[13:19:21.254]  - seeds: <none>
[13:19:21.254] getGlobalsAndPackages() ...
[13:19:21.254] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:21.255] Resolving globals: FALSE
[13:19:21.256] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:21.257] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:21.257] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:21.258] 
[13:19:21.258] getGlobalsAndPackages() ... DONE
[13:19:21.258] run() for ‘Future’ ...
[13:19:21.259] - state: ‘created’
[13:19:21.259] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:21.264] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:21.264] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:21.264]   - Field: ‘label’
[13:19:21.265]   - Field: ‘local’
[13:19:21.265]   - Field: ‘owner’
[13:19:21.265]   - Field: ‘envir’
[13:19:21.265]   - Field: ‘workers’
[13:19:21.265]   - Field: ‘packages’
[13:19:21.265]   - Field: ‘gc’
[13:19:21.266]   - Field: ‘job’
[13:19:21.266]   - Field: ‘conditions’
[13:19:21.266]   - Field: ‘expr’
[13:19:21.266]   - Field: ‘uuid’
[13:19:21.266]   - Field: ‘seed’
[13:19:21.266]   - Field: ‘version’
[13:19:21.266]   - Field: ‘result’
[13:19:21.267]   - Field: ‘asynchronous’
[13:19:21.267]   - Field: ‘calls’
[13:19:21.267]   - Field: ‘globals’
[13:19:21.267]   - Field: ‘stdout’
[13:19:21.267]   - Field: ‘earlySignal’
[13:19:21.267]   - Field: ‘lazy’
[13:19:21.267]   - Field: ‘state’
[13:19:21.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:21.268] - Launch lazy future ...
[13:19:21.268] Packages needed by the future expression (n = 0): <none>
[13:19:21.268] Packages needed by future strategies (n = 0): <none>
[13:19:21.269] {
[13:19:21.269]     {
[13:19:21.269]         {
[13:19:21.269]             ...future.startTime <- base::Sys.time()
[13:19:21.269]             {
[13:19:21.269]                 {
[13:19:21.269]                   {
[13:19:21.269]                     {
[13:19:21.269]                       base::local({
[13:19:21.269]                         has_future <- base::requireNamespace("future", 
[13:19:21.269]                           quietly = TRUE)
[13:19:21.269]                         if (has_future) {
[13:19:21.269]                           ns <- base::getNamespace("future")
[13:19:21.269]                           version <- ns[[".package"]][["version"]]
[13:19:21.269]                           if (is.null(version)) 
[13:19:21.269]                             version <- utils::packageVersion("future")
[13:19:21.269]                         }
[13:19:21.269]                         else {
[13:19:21.269]                           version <- NULL
[13:19:21.269]                         }
[13:19:21.269]                         if (!has_future || version < "1.8.0") {
[13:19:21.269]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:21.269]                             "", base::R.version$version.string), 
[13:19:21.269]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:21.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:21.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:21.269]                               "release", "version")], collapse = " "), 
[13:19:21.269]                             hostname = base::Sys.info()[["nodename"]])
[13:19:21.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:21.269]                             info)
[13:19:21.269]                           info <- base::paste(info, collapse = "; ")
[13:19:21.269]                           if (!has_future) {
[13:19:21.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:21.269]                               info)
[13:19:21.269]                           }
[13:19:21.269]                           else {
[13:19:21.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:21.269]                               info, version)
[13:19:21.269]                           }
[13:19:21.269]                           base::stop(msg)
[13:19:21.269]                         }
[13:19:21.269]                       })
[13:19:21.269]                     }
[13:19:21.269]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:21.269]                     base::options(mc.cores = 1L)
[13:19:21.269]                   }
[13:19:21.269]                   options(future.plan = NULL)
[13:19:21.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:21.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:21.269]                 }
[13:19:21.269]                 ...future.workdir <- getwd()
[13:19:21.269]             }
[13:19:21.269]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:21.269]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:21.269]         }
[13:19:21.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:21.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:21.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:21.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:21.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:21.269]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:21.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:21.269]             base::names(...future.oldOptions))
[13:19:21.269]     }
[13:19:21.269]     if (FALSE) {
[13:19:21.269]     }
[13:19:21.269]     else {
[13:19:21.269]         if (FALSE) {
[13:19:21.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:21.269]                 open = "w")
[13:19:21.269]         }
[13:19:21.269]         else {
[13:19:21.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:21.269]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:21.269]         }
[13:19:21.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:21.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:21.269]             base::sink(type = "output", split = FALSE)
[13:19:21.269]             base::close(...future.stdout)
[13:19:21.269]         }, add = TRUE)
[13:19:21.269]     }
[13:19:21.269]     ...future.frame <- base::sys.nframe()
[13:19:21.269]     ...future.conditions <- base::list()
[13:19:21.269]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:21.269]     if (FALSE) {
[13:19:21.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:21.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:21.269]     }
[13:19:21.269]     ...future.result <- base::tryCatch({
[13:19:21.269]         base::withCallingHandlers({
[13:19:21.269]             ...future.value <- base::withVisible(base::local({
[13:19:21.269]                 withCallingHandlers({
[13:19:21.269]                   {
[13:19:21.269]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:21.269]                     if (!identical(...future.globals.maxSize.org, 
[13:19:21.269]                       ...future.globals.maxSize)) {
[13:19:21.269]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:21.269]                       on.exit(options(oopts), add = TRUE)
[13:19:21.269]                     }
[13:19:21.269]                     {
[13:19:21.269]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:21.269]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:21.269]                         USE.NAMES = FALSE)
[13:19:21.269]                       do.call(mapply, args = args)
[13:19:21.269]                     }
[13:19:21.269]                   }
[13:19:21.269]                 }, immediateCondition = function(cond) {
[13:19:21.269]                   save_rds <- function (object, pathname, ...) 
[13:19:21.269]                   {
[13:19:21.269]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:21.269]                     if (file_test("-f", pathname_tmp)) {
[13:19:21.269]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.269]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:21.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.269]                         fi_tmp[["mtime"]])
[13:19:21.269]                     }
[13:19:21.269]                     tryCatch({
[13:19:21.269]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:21.269]                     }, error = function(ex) {
[13:19:21.269]                       msg <- conditionMessage(ex)
[13:19:21.269]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.269]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:21.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.269]                         fi_tmp[["mtime"]], msg)
[13:19:21.269]                       ex$message <- msg
[13:19:21.269]                       stop(ex)
[13:19:21.269]                     })
[13:19:21.269]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:21.269]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:21.269]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:21.269]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.269]                       fi <- file.info(pathname)
[13:19:21.269]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:21.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.269]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:21.269]                         fi[["size"]], fi[["mtime"]])
[13:19:21.269]                       stop(msg)
[13:19:21.269]                     }
[13:19:21.269]                     invisible(pathname)
[13:19:21.269]                   }
[13:19:21.269]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:21.269]                     rootPath = tempdir()) 
[13:19:21.269]                   {
[13:19:21.269]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:21.269]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:21.269]                       tmpdir = path, fileext = ".rds")
[13:19:21.269]                     save_rds(obj, file)
[13:19:21.269]                   }
[13:19:21.269]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:21.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.269]                   {
[13:19:21.269]                     inherits <- base::inherits
[13:19:21.269]                     invokeRestart <- base::invokeRestart
[13:19:21.269]                     is.null <- base::is.null
[13:19:21.269]                     muffled <- FALSE
[13:19:21.269]                     if (inherits(cond, "message")) {
[13:19:21.269]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:21.269]                       if (muffled) 
[13:19:21.269]                         invokeRestart("muffleMessage")
[13:19:21.269]                     }
[13:19:21.269]                     else if (inherits(cond, "warning")) {
[13:19:21.269]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:21.269]                       if (muffled) 
[13:19:21.269]                         invokeRestart("muffleWarning")
[13:19:21.269]                     }
[13:19:21.269]                     else if (inherits(cond, "condition")) {
[13:19:21.269]                       if (!is.null(pattern)) {
[13:19:21.269]                         computeRestarts <- base::computeRestarts
[13:19:21.269]                         grepl <- base::grepl
[13:19:21.269]                         restarts <- computeRestarts(cond)
[13:19:21.269]                         for (restart in restarts) {
[13:19:21.269]                           name <- restart$name
[13:19:21.269]                           if (is.null(name)) 
[13:19:21.269]                             next
[13:19:21.269]                           if (!grepl(pattern, name)) 
[13:19:21.269]                             next
[13:19:21.269]                           invokeRestart(restart)
[13:19:21.269]                           muffled <- TRUE
[13:19:21.269]                           break
[13:19:21.269]                         }
[13:19:21.269]                       }
[13:19:21.269]                     }
[13:19:21.269]                     invisible(muffled)
[13:19:21.269]                   }
[13:19:21.269]                   muffleCondition(cond)
[13:19:21.269]                 })
[13:19:21.269]             }))
[13:19:21.269]             future::FutureResult(value = ...future.value$value, 
[13:19:21.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:21.269]                   ...future.rng), globalenv = if (FALSE) 
[13:19:21.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:21.269]                     ...future.globalenv.names))
[13:19:21.269]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:21.269]         }, condition = base::local({
[13:19:21.269]             c <- base::c
[13:19:21.269]             inherits <- base::inherits
[13:19:21.269]             invokeRestart <- base::invokeRestart
[13:19:21.269]             length <- base::length
[13:19:21.269]             list <- base::list
[13:19:21.269]             seq.int <- base::seq.int
[13:19:21.269]             signalCondition <- base::signalCondition
[13:19:21.269]             sys.calls <- base::sys.calls
[13:19:21.269]             `[[` <- base::`[[`
[13:19:21.269]             `+` <- base::`+`
[13:19:21.269]             `<<-` <- base::`<<-`
[13:19:21.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:21.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:21.269]                   3L)]
[13:19:21.269]             }
[13:19:21.269]             function(cond) {
[13:19:21.269]                 is_error <- inherits(cond, "error")
[13:19:21.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:21.269]                   NULL)
[13:19:21.269]                 if (is_error) {
[13:19:21.269]                   sessionInformation <- function() {
[13:19:21.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:21.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:21.269]                       search = base::search(), system = base::Sys.info())
[13:19:21.269]                   }
[13:19:21.269]                   ...future.conditions[[length(...future.conditions) + 
[13:19:21.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:21.269]                     cond$call), session = sessionInformation(), 
[13:19:21.269]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:21.269]                   signalCondition(cond)
[13:19:21.269]                 }
[13:19:21.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:21.269]                 "immediateCondition"))) {
[13:19:21.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:21.269]                   ...future.conditions[[length(...future.conditions) + 
[13:19:21.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:21.269]                   if (TRUE && !signal) {
[13:19:21.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.269]                     {
[13:19:21.269]                       inherits <- base::inherits
[13:19:21.269]                       invokeRestart <- base::invokeRestart
[13:19:21.269]                       is.null <- base::is.null
[13:19:21.269]                       muffled <- FALSE
[13:19:21.269]                       if (inherits(cond, "message")) {
[13:19:21.269]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:21.269]                         if (muffled) 
[13:19:21.269]                           invokeRestart("muffleMessage")
[13:19:21.269]                       }
[13:19:21.269]                       else if (inherits(cond, "warning")) {
[13:19:21.269]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:21.269]                         if (muffled) 
[13:19:21.269]                           invokeRestart("muffleWarning")
[13:19:21.269]                       }
[13:19:21.269]                       else if (inherits(cond, "condition")) {
[13:19:21.269]                         if (!is.null(pattern)) {
[13:19:21.269]                           computeRestarts <- base::computeRestarts
[13:19:21.269]                           grepl <- base::grepl
[13:19:21.269]                           restarts <- computeRestarts(cond)
[13:19:21.269]                           for (restart in restarts) {
[13:19:21.269]                             name <- restart$name
[13:19:21.269]                             if (is.null(name)) 
[13:19:21.269]                               next
[13:19:21.269]                             if (!grepl(pattern, name)) 
[13:19:21.269]                               next
[13:19:21.269]                             invokeRestart(restart)
[13:19:21.269]                             muffled <- TRUE
[13:19:21.269]                             break
[13:19:21.269]                           }
[13:19:21.269]                         }
[13:19:21.269]                       }
[13:19:21.269]                       invisible(muffled)
[13:19:21.269]                     }
[13:19:21.269]                     muffleCondition(cond, pattern = "^muffle")
[13:19:21.269]                   }
[13:19:21.269]                 }
[13:19:21.269]                 else {
[13:19:21.269]                   if (TRUE) {
[13:19:21.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.269]                     {
[13:19:21.269]                       inherits <- base::inherits
[13:19:21.269]                       invokeRestart <- base::invokeRestart
[13:19:21.269]                       is.null <- base::is.null
[13:19:21.269]                       muffled <- FALSE
[13:19:21.269]                       if (inherits(cond, "message")) {
[13:19:21.269]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:21.269]                         if (muffled) 
[13:19:21.269]                           invokeRestart("muffleMessage")
[13:19:21.269]                       }
[13:19:21.269]                       else if (inherits(cond, "warning")) {
[13:19:21.269]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:21.269]                         if (muffled) 
[13:19:21.269]                           invokeRestart("muffleWarning")
[13:19:21.269]                       }
[13:19:21.269]                       else if (inherits(cond, "condition")) {
[13:19:21.269]                         if (!is.null(pattern)) {
[13:19:21.269]                           computeRestarts <- base::computeRestarts
[13:19:21.269]                           grepl <- base::grepl
[13:19:21.269]                           restarts <- computeRestarts(cond)
[13:19:21.269]                           for (restart in restarts) {
[13:19:21.269]                             name <- restart$name
[13:19:21.269]                             if (is.null(name)) 
[13:19:21.269]                               next
[13:19:21.269]                             if (!grepl(pattern, name)) 
[13:19:21.269]                               next
[13:19:21.269]                             invokeRestart(restart)
[13:19:21.269]                             muffled <- TRUE
[13:19:21.269]                             break
[13:19:21.269]                           }
[13:19:21.269]                         }
[13:19:21.269]                       }
[13:19:21.269]                       invisible(muffled)
[13:19:21.269]                     }
[13:19:21.269]                     muffleCondition(cond, pattern = "^muffle")
[13:19:21.269]                   }
[13:19:21.269]                 }
[13:19:21.269]             }
[13:19:21.269]         }))
[13:19:21.269]     }, error = function(ex) {
[13:19:21.269]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:21.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:21.269]                 ...future.rng), started = ...future.startTime, 
[13:19:21.269]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:21.269]             version = "1.8"), class = "FutureResult")
[13:19:21.269]     }, finally = {
[13:19:21.269]         if (!identical(...future.workdir, getwd())) 
[13:19:21.269]             setwd(...future.workdir)
[13:19:21.269]         {
[13:19:21.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:21.269]                 ...future.oldOptions$nwarnings <- NULL
[13:19:21.269]             }
[13:19:21.269]             base::options(...future.oldOptions)
[13:19:21.269]             if (.Platform$OS.type == "windows") {
[13:19:21.269]                 old_names <- names(...future.oldEnvVars)
[13:19:21.269]                 envs <- base::Sys.getenv()
[13:19:21.269]                 names <- names(envs)
[13:19:21.269]                 common <- intersect(names, old_names)
[13:19:21.269]                 added <- setdiff(names, old_names)
[13:19:21.269]                 removed <- setdiff(old_names, names)
[13:19:21.269]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:21.269]                   envs[common]]
[13:19:21.269]                 NAMES <- toupper(changed)
[13:19:21.269]                 args <- list()
[13:19:21.269]                 for (kk in seq_along(NAMES)) {
[13:19:21.269]                   name <- changed[[kk]]
[13:19:21.269]                   NAME <- NAMES[[kk]]
[13:19:21.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.269]                     next
[13:19:21.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:21.269]                 }
[13:19:21.269]                 NAMES <- toupper(added)
[13:19:21.269]                 for (kk in seq_along(NAMES)) {
[13:19:21.269]                   name <- added[[kk]]
[13:19:21.269]                   NAME <- NAMES[[kk]]
[13:19:21.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.269]                     next
[13:19:21.269]                   args[[name]] <- ""
[13:19:21.269]                 }
[13:19:21.269]                 NAMES <- toupper(removed)
[13:19:21.269]                 for (kk in seq_along(NAMES)) {
[13:19:21.269]                   name <- removed[[kk]]
[13:19:21.269]                   NAME <- NAMES[[kk]]
[13:19:21.269]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.269]                     next
[13:19:21.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:21.269]                 }
[13:19:21.269]                 if (length(args) > 0) 
[13:19:21.269]                   base::do.call(base::Sys.setenv, args = args)
[13:19:21.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:21.269]             }
[13:19:21.269]             else {
[13:19:21.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:21.269]             }
[13:19:21.269]             {
[13:19:21.269]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:21.269]                   0L) {
[13:19:21.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:21.269]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:21.269]                   base::options(opts)
[13:19:21.269]                 }
[13:19:21.269]                 {
[13:19:21.269]                   {
[13:19:21.269]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:21.269]                     NULL
[13:19:21.269]                   }
[13:19:21.269]                   options(future.plan = NULL)
[13:19:21.269]                   if (is.na(NA_character_)) 
[13:19:21.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:21.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:21.269]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:21.269]                     envir = parent.frame()) 
[13:19:21.269]                   {
[13:19:21.269]                     default_workers <- missing(workers)
[13:19:21.269]                     if (is.function(workers)) 
[13:19:21.269]                       workers <- workers()
[13:19:21.269]                     workers <- structure(as.integer(workers), 
[13:19:21.269]                       class = class(workers))
[13:19:21.269]                     stop_if_not(is.finite(workers), workers >= 
[13:19:21.269]                       1L)
[13:19:21.269]                     if ((workers == 1L && !inherits(workers, 
[13:19:21.269]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:21.269]                       if (default_workers) 
[13:19:21.269]                         supportsMulticore(warn = TRUE)
[13:19:21.269]                       return(sequential(..., envir = envir))
[13:19:21.269]                     }
[13:19:21.269]                     oopts <- options(mc.cores = workers)
[13:19:21.269]                     on.exit(options(oopts))
[13:19:21.269]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:21.269]                       envir = envir)
[13:19:21.269]                     if (!future$lazy) 
[13:19:21.269]                       future <- run(future)
[13:19:21.269]                     invisible(future)
[13:19:21.269]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:21.269]                 }
[13:19:21.269]             }
[13:19:21.269]         }
[13:19:21.269]     })
[13:19:21.269]     if (TRUE) {
[13:19:21.269]         base::sink(type = "output", split = FALSE)
[13:19:21.269]         if (FALSE) {
[13:19:21.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:21.269]         }
[13:19:21.269]         else {
[13:19:21.269]             ...future.result["stdout"] <- base::list(NULL)
[13:19:21.269]         }
[13:19:21.269]         base::close(...future.stdout)
[13:19:21.269]         ...future.stdout <- NULL
[13:19:21.269]     }
[13:19:21.269]     ...future.result$conditions <- ...future.conditions
[13:19:21.269]     ...future.result$finished <- base::Sys.time()
[13:19:21.269]     ...future.result
[13:19:21.269] }
[13:19:21.272] assign_globals() ...
[13:19:21.272] List of 5
[13:19:21.272]  $ ...future.FUN            :function (x, y)  
[13:19:21.272]  $ MoreArgs                 : NULL
[13:19:21.272]  $ ...future.elements_ii    :List of 2
[13:19:21.272]   ..$ :List of 1
[13:19:21.272]   .. ..$ : int 0
[13:19:21.272]   ..$ :List of 1
[13:19:21.272]   .. ..$ : int 1
[13:19:21.272]  $ ...future.seeds_ii       : NULL
[13:19:21.272]  $ ...future.globals.maxSize: NULL
[13:19:21.272]  - attr(*, "where")=List of 5
[13:19:21.272]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:21.272]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:21.272]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:21.272]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:21.272]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:21.272]  - attr(*, "resolved")= logi FALSE
[13:19:21.272]  - attr(*, "total_size")= num 6368
[13:19:21.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:21.272]  - attr(*, "already-done")= logi TRUE
[13:19:21.278] - reassign environment for ‘...future.FUN’
[13:19:21.278] - copied ‘...future.FUN’ to environment
[13:19:21.279] - copied ‘MoreArgs’ to environment
[13:19:21.279] - copied ‘...future.elements_ii’ to environment
[13:19:21.279] - copied ‘...future.seeds_ii’ to environment
[13:19:21.279] - copied ‘...future.globals.maxSize’ to environment
[13:19:21.279] assign_globals() ... done
[13:19:21.279] requestCore(): workers = 2
[13:19:21.281] MulticoreFuture started
[13:19:21.282] - Launch lazy future ... done
[13:19:21.282] run() for ‘MulticoreFuture’ ... done
[13:19:21.282] Created future:
[13:19:21.283] plan(): Setting new future strategy stack:
[13:19:21.283] List of future strategies:
[13:19:21.283] 1. sequential:
[13:19:21.283]    - args: function (..., envir = parent.frame())
[13:19:21.283]    - tweaked: FALSE
[13:19:21.283]    - call: NULL
[13:19:21.284] plan(): nbrOfWorkers() = 1
[13:19:21.286] plan(): Setting new future strategy stack:
[13:19:21.286] List of future strategies:
[13:19:21.286] 1. multicore:
[13:19:21.286]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:21.286]    - tweaked: FALSE
[13:19:21.286]    - call: plan(strategy)
[13:19:21.291] plan(): nbrOfWorkers() = 2
[13:19:21.282] MulticoreFuture:
[13:19:21.282] Label: ‘future_mapply-2’
[13:19:21.282] Expression:
[13:19:21.282] {
[13:19:21.282]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:21.282]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:21.282]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:21.282]         on.exit(options(oopts), add = TRUE)
[13:19:21.282]     }
[13:19:21.282]     {
[13:19:21.282]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:21.282]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:21.282]         do.call(mapply, args = args)
[13:19:21.282]     }
[13:19:21.282] }
[13:19:21.282] Lazy evaluation: FALSE
[13:19:21.282] Asynchronous evaluation: TRUE
[13:19:21.282] Local evaluation: TRUE
[13:19:21.282] Environment: R_GlobalEnv
[13:19:21.282] Capture standard output: FALSE
[13:19:21.282] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:21.282] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:21.282] Packages: <none>
[13:19:21.282] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:21.282] Resolved: TRUE
[13:19:21.282] Value: <not collected>
[13:19:21.282] Conditions captured: <none>
[13:19:21.282] Early signaling: FALSE
[13:19:21.282] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:21.282] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:21.292] Chunk #2 of 2 ... DONE
[13:19:21.292] Launching 2 futures (chunks) ... DONE
[13:19:21.292] Resolving 2 futures (chunks) ...
[13:19:21.292] resolve() on list ...
[13:19:21.293]  recursive: 0
[13:19:21.293]  length: 2
[13:19:21.293] 
[13:19:21.304] Future #2
[13:19:21.305] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:21.305] - nx: 2
[13:19:21.305] - relay: TRUE
[13:19:21.305] - stdout: TRUE
[13:19:21.305] - signal: TRUE
[13:19:21.305] - resignal: FALSE
[13:19:21.306] - force: TRUE
[13:19:21.306] - relayed: [n=2] FALSE, FALSE
[13:19:21.306] - queued futures: [n=2] FALSE, FALSE
[13:19:21.306]  - until=1
[13:19:21.306]  - relaying element #1
[13:19:21.306] - relayed: [n=2] FALSE, FALSE
[13:19:21.306] - queued futures: [n=2] FALSE, TRUE
[13:19:21.307] signalConditionsASAP(NULL, pos=2) ... done
[13:19:21.307]  length: 1 (resolved future 2)
[13:19:21.737] plan(): Setting new future strategy stack:
[13:19:21.737] List of future strategies:
[13:19:21.737] 1. multicore:
[13:19:21.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:21.737]    - tweaked: FALSE
[13:19:21.737]    - call: plan(strategy)
[13:19:21.746] plan(): nbrOfWorkers() = 2
[13:19:21.746] Future #1
[13:19:21.747] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:21.749] - nx: 2
[13:19:21.750] - relay: TRUE
[13:19:21.750] - stdout: TRUE
[13:19:21.750] - signal: TRUE
[13:19:21.750] - resignal: FALSE
[13:19:21.750] - force: TRUE
[13:19:21.750] - relayed: [n=2] FALSE, FALSE
[13:19:21.751] - queued futures: [n=2] FALSE, TRUE
[13:19:21.751]  - until=1
[13:19:21.751]  - relaying element #1
[13:19:21.751] - relayed: [n=2] TRUE, FALSE
[13:19:21.752] - queued futures: [n=2] TRUE, TRUE
[13:19:21.752] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:21.752]  length: 0 (resolved future 1)
[13:19:21.752] Relaying remaining futures
[13:19:21.752] signalConditionsASAP(NULL, pos=0) ...
[13:19:21.752] - nx: 2
[13:19:21.753] - relay: TRUE
[13:19:21.753] - stdout: TRUE
[13:19:21.753] - signal: TRUE
[13:19:21.753] - resignal: FALSE
[13:19:21.753] - force: TRUE
[13:19:21.753] - relayed: [n=2] TRUE, FALSE
[13:19:21.754] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:21.754]  - relaying element #2
[13:19:21.754] - relayed: [n=2] TRUE, TRUE
[13:19:21.754] - queued futures: [n=2] TRUE, TRUE
[13:19:21.754] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:19:21.755] resolve() on list ... DONE
[13:19:21.755]  - Number of value chunks collected: 2
[13:19:21.755] Resolving 2 futures (chunks) ... DONE
[13:19:21.755] Reducing values from 2 chunks ...
[13:19:21.755]  - Number of values collected after concatenation: 2
[13:19:21.755]  - Number of values expected: 2
[13:19:21.756] Reducing values from 2 chunks ... DONE
[13:19:21.756] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:19:21.757] future_mapply() ...
[13:19:21.761] Number of chunks: 2
[13:19:21.761] getGlobalsAndPackagesXApply() ...
[13:19:21.761]  - future.globals: TRUE
[13:19:21.762] getGlobalsAndPackages() ...
[13:19:21.762] Searching for globals...
[13:19:21.764] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:21.764] Searching for globals ... DONE
[13:19:21.764] Resolving globals: FALSE
[13:19:21.765] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:21.765] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:21.765] - globals: [1] ‘FUN’
[13:19:21.765] 
[13:19:21.765] getGlobalsAndPackages() ... DONE
[13:19:21.765]  - globals found/used: [n=1] ‘FUN’
[13:19:21.766]  - needed namespaces: [n=0] 
[13:19:21.766] Finding globals ... DONE
[13:19:21.766] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:21.766] List of 2
[13:19:21.766]  $ ...future.FUN:function (x, y)  
[13:19:21.766]  $ MoreArgs     : NULL
[13:19:21.766]  - attr(*, "where")=List of 2
[13:19:21.766]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:21.766]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:21.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:21.766]  - attr(*, "resolved")= logi FALSE
[13:19:21.766]  - attr(*, "total_size")= num NA
[13:19:21.769] Packages to be attached in all futures: [n=0] 
[13:19:21.769] getGlobalsAndPackagesXApply() ... DONE
[13:19:21.769] Number of futures (= number of chunks): 2
[13:19:21.769] Launching 2 futures (chunks) ...
[13:19:21.770] Chunk #1 of 2 ...
[13:19:21.770]  - Finding globals in '...' for chunk #1 ...
[13:19:21.770] getGlobalsAndPackages() ...
[13:19:21.770] Searching for globals...
[13:19:21.770] 
[13:19:21.770] Searching for globals ... DONE
[13:19:21.770] - globals: [0] <none>
[13:19:21.771] getGlobalsAndPackages() ... DONE
[13:19:21.771]    + additional globals found: [n=0] 
[13:19:21.771]    + additional namespaces needed: [n=0] 
[13:19:21.771]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:21.771]  - seeds: <none>
[13:19:21.771] getGlobalsAndPackages() ...
[13:19:21.771] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:21.771] Resolving globals: FALSE
[13:19:21.772] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:21.772] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:21.772] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:21.772] 
[13:19:21.773] getGlobalsAndPackages() ... DONE
[13:19:21.773] run() for ‘Future’ ...
[13:19:21.773] - state: ‘created’
[13:19:21.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:21.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:21.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:21.777]   - Field: ‘label’
[13:19:21.777]   - Field: ‘local’
[13:19:21.777]   - Field: ‘owner’
[13:19:21.777]   - Field: ‘envir’
[13:19:21.777]   - Field: ‘workers’
[13:19:21.777]   - Field: ‘packages’
[13:19:21.778]   - Field: ‘gc’
[13:19:21.778]   - Field: ‘job’
[13:19:21.778]   - Field: ‘conditions’
[13:19:21.778]   - Field: ‘expr’
[13:19:21.778]   - Field: ‘uuid’
[13:19:21.778]   - Field: ‘seed’
[13:19:21.778]   - Field: ‘version’
[13:19:21.778]   - Field: ‘result’
[13:19:21.778]   - Field: ‘asynchronous’
[13:19:21.778]   - Field: ‘calls’
[13:19:21.778]   - Field: ‘globals’
[13:19:21.779]   - Field: ‘stdout’
[13:19:21.779]   - Field: ‘earlySignal’
[13:19:21.779]   - Field: ‘lazy’
[13:19:21.779]   - Field: ‘state’
[13:19:21.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:21.779] - Launch lazy future ...
[13:19:21.779] Packages needed by the future expression (n = 0): <none>
[13:19:21.779] Packages needed by future strategies (n = 0): <none>
[13:19:21.782] {
[13:19:21.782]     {
[13:19:21.782]         {
[13:19:21.782]             ...future.startTime <- base::Sys.time()
[13:19:21.782]             {
[13:19:21.782]                 {
[13:19:21.782]                   {
[13:19:21.782]                     {
[13:19:21.782]                       base::local({
[13:19:21.782]                         has_future <- base::requireNamespace("future", 
[13:19:21.782]                           quietly = TRUE)
[13:19:21.782]                         if (has_future) {
[13:19:21.782]                           ns <- base::getNamespace("future")
[13:19:21.782]                           version <- ns[[".package"]][["version"]]
[13:19:21.782]                           if (is.null(version)) 
[13:19:21.782]                             version <- utils::packageVersion("future")
[13:19:21.782]                         }
[13:19:21.782]                         else {
[13:19:21.782]                           version <- NULL
[13:19:21.782]                         }
[13:19:21.782]                         if (!has_future || version < "1.8.0") {
[13:19:21.782]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:21.782]                             "", base::R.version$version.string), 
[13:19:21.782]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:21.782]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:21.782]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:21.782]                               "release", "version")], collapse = " "), 
[13:19:21.782]                             hostname = base::Sys.info()[["nodename"]])
[13:19:21.782]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:21.782]                             info)
[13:19:21.782]                           info <- base::paste(info, collapse = "; ")
[13:19:21.782]                           if (!has_future) {
[13:19:21.782]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:21.782]                               info)
[13:19:21.782]                           }
[13:19:21.782]                           else {
[13:19:21.782]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:21.782]                               info, version)
[13:19:21.782]                           }
[13:19:21.782]                           base::stop(msg)
[13:19:21.782]                         }
[13:19:21.782]                       })
[13:19:21.782]                     }
[13:19:21.782]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:21.782]                     base::options(mc.cores = 1L)
[13:19:21.782]                   }
[13:19:21.782]                   options(future.plan = NULL)
[13:19:21.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:21.782]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:21.782]                 }
[13:19:21.782]                 ...future.workdir <- getwd()
[13:19:21.782]             }
[13:19:21.782]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:21.782]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:21.782]         }
[13:19:21.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:21.782]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:21.782]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:21.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:21.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:21.782]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:21.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:21.782]             base::names(...future.oldOptions))
[13:19:21.782]     }
[13:19:21.782]     if (FALSE) {
[13:19:21.782]     }
[13:19:21.782]     else {
[13:19:21.782]         if (TRUE) {
[13:19:21.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:21.782]                 open = "w")
[13:19:21.782]         }
[13:19:21.782]         else {
[13:19:21.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:21.782]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:21.782]         }
[13:19:21.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:21.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:21.782]             base::sink(type = "output", split = FALSE)
[13:19:21.782]             base::close(...future.stdout)
[13:19:21.782]         }, add = TRUE)
[13:19:21.782]     }
[13:19:21.782]     ...future.frame <- base::sys.nframe()
[13:19:21.782]     ...future.conditions <- base::list()
[13:19:21.782]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:21.782]     if (FALSE) {
[13:19:21.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:21.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:21.782]     }
[13:19:21.782]     ...future.result <- base::tryCatch({
[13:19:21.782]         base::withCallingHandlers({
[13:19:21.782]             ...future.value <- base::withVisible(base::local({
[13:19:21.782]                 withCallingHandlers({
[13:19:21.782]                   {
[13:19:21.782]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:21.782]                     if (!identical(...future.globals.maxSize.org, 
[13:19:21.782]                       ...future.globals.maxSize)) {
[13:19:21.782]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:21.782]                       on.exit(options(oopts), add = TRUE)
[13:19:21.782]                     }
[13:19:21.782]                     {
[13:19:21.782]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:21.782]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:21.782]                         USE.NAMES = FALSE)
[13:19:21.782]                       do.call(mapply, args = args)
[13:19:21.782]                     }
[13:19:21.782]                   }
[13:19:21.782]                 }, immediateCondition = function(cond) {
[13:19:21.782]                   save_rds <- function (object, pathname, ...) 
[13:19:21.782]                   {
[13:19:21.782]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:21.782]                     if (file_test("-f", pathname_tmp)) {
[13:19:21.782]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.782]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:21.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.782]                         fi_tmp[["mtime"]])
[13:19:21.782]                     }
[13:19:21.782]                     tryCatch({
[13:19:21.782]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:21.782]                     }, error = function(ex) {
[13:19:21.782]                       msg <- conditionMessage(ex)
[13:19:21.782]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.782]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:21.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.782]                         fi_tmp[["mtime"]], msg)
[13:19:21.782]                       ex$message <- msg
[13:19:21.782]                       stop(ex)
[13:19:21.782]                     })
[13:19:21.782]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:21.782]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:21.782]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:21.782]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.782]                       fi <- file.info(pathname)
[13:19:21.782]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:21.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.782]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:21.782]                         fi[["size"]], fi[["mtime"]])
[13:19:21.782]                       stop(msg)
[13:19:21.782]                     }
[13:19:21.782]                     invisible(pathname)
[13:19:21.782]                   }
[13:19:21.782]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:21.782]                     rootPath = tempdir()) 
[13:19:21.782]                   {
[13:19:21.782]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:21.782]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:21.782]                       tmpdir = path, fileext = ".rds")
[13:19:21.782]                     save_rds(obj, file)
[13:19:21.782]                   }
[13:19:21.782]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:21.782]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.782]                   {
[13:19:21.782]                     inherits <- base::inherits
[13:19:21.782]                     invokeRestart <- base::invokeRestart
[13:19:21.782]                     is.null <- base::is.null
[13:19:21.782]                     muffled <- FALSE
[13:19:21.782]                     if (inherits(cond, "message")) {
[13:19:21.782]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:21.782]                       if (muffled) 
[13:19:21.782]                         invokeRestart("muffleMessage")
[13:19:21.782]                     }
[13:19:21.782]                     else if (inherits(cond, "warning")) {
[13:19:21.782]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:21.782]                       if (muffled) 
[13:19:21.782]                         invokeRestart("muffleWarning")
[13:19:21.782]                     }
[13:19:21.782]                     else if (inherits(cond, "condition")) {
[13:19:21.782]                       if (!is.null(pattern)) {
[13:19:21.782]                         computeRestarts <- base::computeRestarts
[13:19:21.782]                         grepl <- base::grepl
[13:19:21.782]                         restarts <- computeRestarts(cond)
[13:19:21.782]                         for (restart in restarts) {
[13:19:21.782]                           name <- restart$name
[13:19:21.782]                           if (is.null(name)) 
[13:19:21.782]                             next
[13:19:21.782]                           if (!grepl(pattern, name)) 
[13:19:21.782]                             next
[13:19:21.782]                           invokeRestart(restart)
[13:19:21.782]                           muffled <- TRUE
[13:19:21.782]                           break
[13:19:21.782]                         }
[13:19:21.782]                       }
[13:19:21.782]                     }
[13:19:21.782]                     invisible(muffled)
[13:19:21.782]                   }
[13:19:21.782]                   muffleCondition(cond)
[13:19:21.782]                 })
[13:19:21.782]             }))
[13:19:21.782]             future::FutureResult(value = ...future.value$value, 
[13:19:21.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:21.782]                   ...future.rng), globalenv = if (FALSE) 
[13:19:21.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:21.782]                     ...future.globalenv.names))
[13:19:21.782]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:21.782]         }, condition = base::local({
[13:19:21.782]             c <- base::c
[13:19:21.782]             inherits <- base::inherits
[13:19:21.782]             invokeRestart <- base::invokeRestart
[13:19:21.782]             length <- base::length
[13:19:21.782]             list <- base::list
[13:19:21.782]             seq.int <- base::seq.int
[13:19:21.782]             signalCondition <- base::signalCondition
[13:19:21.782]             sys.calls <- base::sys.calls
[13:19:21.782]             `[[` <- base::`[[`
[13:19:21.782]             `+` <- base::`+`
[13:19:21.782]             `<<-` <- base::`<<-`
[13:19:21.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:21.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:21.782]                   3L)]
[13:19:21.782]             }
[13:19:21.782]             function(cond) {
[13:19:21.782]                 is_error <- inherits(cond, "error")
[13:19:21.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:21.782]                   NULL)
[13:19:21.782]                 if (is_error) {
[13:19:21.782]                   sessionInformation <- function() {
[13:19:21.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:21.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:21.782]                       search = base::search(), system = base::Sys.info())
[13:19:21.782]                   }
[13:19:21.782]                   ...future.conditions[[length(...future.conditions) + 
[13:19:21.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:21.782]                     cond$call), session = sessionInformation(), 
[13:19:21.782]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:21.782]                   signalCondition(cond)
[13:19:21.782]                 }
[13:19:21.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:21.782]                 "immediateCondition"))) {
[13:19:21.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:21.782]                   ...future.conditions[[length(...future.conditions) + 
[13:19:21.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:21.782]                   if (TRUE && !signal) {
[13:19:21.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.782]                     {
[13:19:21.782]                       inherits <- base::inherits
[13:19:21.782]                       invokeRestart <- base::invokeRestart
[13:19:21.782]                       is.null <- base::is.null
[13:19:21.782]                       muffled <- FALSE
[13:19:21.782]                       if (inherits(cond, "message")) {
[13:19:21.782]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:21.782]                         if (muffled) 
[13:19:21.782]                           invokeRestart("muffleMessage")
[13:19:21.782]                       }
[13:19:21.782]                       else if (inherits(cond, "warning")) {
[13:19:21.782]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:21.782]                         if (muffled) 
[13:19:21.782]                           invokeRestart("muffleWarning")
[13:19:21.782]                       }
[13:19:21.782]                       else if (inherits(cond, "condition")) {
[13:19:21.782]                         if (!is.null(pattern)) {
[13:19:21.782]                           computeRestarts <- base::computeRestarts
[13:19:21.782]                           grepl <- base::grepl
[13:19:21.782]                           restarts <- computeRestarts(cond)
[13:19:21.782]                           for (restart in restarts) {
[13:19:21.782]                             name <- restart$name
[13:19:21.782]                             if (is.null(name)) 
[13:19:21.782]                               next
[13:19:21.782]                             if (!grepl(pattern, name)) 
[13:19:21.782]                               next
[13:19:21.782]                             invokeRestart(restart)
[13:19:21.782]                             muffled <- TRUE
[13:19:21.782]                             break
[13:19:21.782]                           }
[13:19:21.782]                         }
[13:19:21.782]                       }
[13:19:21.782]                       invisible(muffled)
[13:19:21.782]                     }
[13:19:21.782]                     muffleCondition(cond, pattern = "^muffle")
[13:19:21.782]                   }
[13:19:21.782]                 }
[13:19:21.782]                 else {
[13:19:21.782]                   if (TRUE) {
[13:19:21.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.782]                     {
[13:19:21.782]                       inherits <- base::inherits
[13:19:21.782]                       invokeRestart <- base::invokeRestart
[13:19:21.782]                       is.null <- base::is.null
[13:19:21.782]                       muffled <- FALSE
[13:19:21.782]                       if (inherits(cond, "message")) {
[13:19:21.782]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:21.782]                         if (muffled) 
[13:19:21.782]                           invokeRestart("muffleMessage")
[13:19:21.782]                       }
[13:19:21.782]                       else if (inherits(cond, "warning")) {
[13:19:21.782]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:21.782]                         if (muffled) 
[13:19:21.782]                           invokeRestart("muffleWarning")
[13:19:21.782]                       }
[13:19:21.782]                       else if (inherits(cond, "condition")) {
[13:19:21.782]                         if (!is.null(pattern)) {
[13:19:21.782]                           computeRestarts <- base::computeRestarts
[13:19:21.782]                           grepl <- base::grepl
[13:19:21.782]                           restarts <- computeRestarts(cond)
[13:19:21.782]                           for (restart in restarts) {
[13:19:21.782]                             name <- restart$name
[13:19:21.782]                             if (is.null(name)) 
[13:19:21.782]                               next
[13:19:21.782]                             if (!grepl(pattern, name)) 
[13:19:21.782]                               next
[13:19:21.782]                             invokeRestart(restart)
[13:19:21.782]                             muffled <- TRUE
[13:19:21.782]                             break
[13:19:21.782]                           }
[13:19:21.782]                         }
[13:19:21.782]                       }
[13:19:21.782]                       invisible(muffled)
[13:19:21.782]                     }
[13:19:21.782]                     muffleCondition(cond, pattern = "^muffle")
[13:19:21.782]                   }
[13:19:21.782]                 }
[13:19:21.782]             }
[13:19:21.782]         }))
[13:19:21.782]     }, error = function(ex) {
[13:19:21.782]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:21.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:21.782]                 ...future.rng), started = ...future.startTime, 
[13:19:21.782]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:21.782]             version = "1.8"), class = "FutureResult")
[13:19:21.782]     }, finally = {
[13:19:21.782]         if (!identical(...future.workdir, getwd())) 
[13:19:21.782]             setwd(...future.workdir)
[13:19:21.782]         {
[13:19:21.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:21.782]                 ...future.oldOptions$nwarnings <- NULL
[13:19:21.782]             }
[13:19:21.782]             base::options(...future.oldOptions)
[13:19:21.782]             if (.Platform$OS.type == "windows") {
[13:19:21.782]                 old_names <- names(...future.oldEnvVars)
[13:19:21.782]                 envs <- base::Sys.getenv()
[13:19:21.782]                 names <- names(envs)
[13:19:21.782]                 common <- intersect(names, old_names)
[13:19:21.782]                 added <- setdiff(names, old_names)
[13:19:21.782]                 removed <- setdiff(old_names, names)
[13:19:21.782]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:21.782]                   envs[common]]
[13:19:21.782]                 NAMES <- toupper(changed)
[13:19:21.782]                 args <- list()
[13:19:21.782]                 for (kk in seq_along(NAMES)) {
[13:19:21.782]                   name <- changed[[kk]]
[13:19:21.782]                   NAME <- NAMES[[kk]]
[13:19:21.782]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.782]                     next
[13:19:21.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:21.782]                 }
[13:19:21.782]                 NAMES <- toupper(added)
[13:19:21.782]                 for (kk in seq_along(NAMES)) {
[13:19:21.782]                   name <- added[[kk]]
[13:19:21.782]                   NAME <- NAMES[[kk]]
[13:19:21.782]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.782]                     next
[13:19:21.782]                   args[[name]] <- ""
[13:19:21.782]                 }
[13:19:21.782]                 NAMES <- toupper(removed)
[13:19:21.782]                 for (kk in seq_along(NAMES)) {
[13:19:21.782]                   name <- removed[[kk]]
[13:19:21.782]                   NAME <- NAMES[[kk]]
[13:19:21.782]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.782]                     next
[13:19:21.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:21.782]                 }
[13:19:21.782]                 if (length(args) > 0) 
[13:19:21.782]                   base::do.call(base::Sys.setenv, args = args)
[13:19:21.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:21.782]             }
[13:19:21.782]             else {
[13:19:21.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:21.782]             }
[13:19:21.782]             {
[13:19:21.782]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:21.782]                   0L) {
[13:19:21.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:21.782]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:21.782]                   base::options(opts)
[13:19:21.782]                 }
[13:19:21.782]                 {
[13:19:21.782]                   {
[13:19:21.782]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:21.782]                     NULL
[13:19:21.782]                   }
[13:19:21.782]                   options(future.plan = NULL)
[13:19:21.782]                   if (is.na(NA_character_)) 
[13:19:21.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:21.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:21.782]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:21.782]                     envir = parent.frame()) 
[13:19:21.782]                   {
[13:19:21.782]                     default_workers <- missing(workers)
[13:19:21.782]                     if (is.function(workers)) 
[13:19:21.782]                       workers <- workers()
[13:19:21.782]                     workers <- structure(as.integer(workers), 
[13:19:21.782]                       class = class(workers))
[13:19:21.782]                     stop_if_not(is.finite(workers), workers >= 
[13:19:21.782]                       1L)
[13:19:21.782]                     if ((workers == 1L && !inherits(workers, 
[13:19:21.782]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:21.782]                       if (default_workers) 
[13:19:21.782]                         supportsMulticore(warn = TRUE)
[13:19:21.782]                       return(sequential(..., envir = envir))
[13:19:21.782]                     }
[13:19:21.782]                     oopts <- options(mc.cores = workers)
[13:19:21.782]                     on.exit(options(oopts))
[13:19:21.782]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:21.782]                       envir = envir)
[13:19:21.782]                     if (!future$lazy) 
[13:19:21.782]                       future <- run(future)
[13:19:21.782]                     invisible(future)
[13:19:21.782]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:21.782]                 }
[13:19:21.782]             }
[13:19:21.782]         }
[13:19:21.782]     })
[13:19:21.782]     if (TRUE) {
[13:19:21.782]         base::sink(type = "output", split = FALSE)
[13:19:21.782]         if (TRUE) {
[13:19:21.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:21.782]         }
[13:19:21.782]         else {
[13:19:21.782]             ...future.result["stdout"] <- base::list(NULL)
[13:19:21.782]         }
[13:19:21.782]         base::close(...future.stdout)
[13:19:21.782]         ...future.stdout <- NULL
[13:19:21.782]     }
[13:19:21.782]     ...future.result$conditions <- ...future.conditions
[13:19:21.782]     ...future.result$finished <- base::Sys.time()
[13:19:21.782]     ...future.result
[13:19:21.782] }
[13:19:21.784] assign_globals() ...
[13:19:21.784] List of 5
[13:19:21.784]  $ ...future.FUN            :function (x, y)  
[13:19:21.784]  $ MoreArgs                 : NULL
[13:19:21.784]  $ ...future.elements_ii    :List of 2
[13:19:21.784]   ..$ :List of 1
[13:19:21.784]   .. ..$ : int 1
[13:19:21.784]   ..$ :List of 1
[13:19:21.784]   .. ..$ : int 0
[13:19:21.784]  $ ...future.seeds_ii       : NULL
[13:19:21.784]  $ ...future.globals.maxSize: NULL
[13:19:21.784]  - attr(*, "where")=List of 5
[13:19:21.784]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:21.784]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:21.784]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:21.784]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:21.784]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:21.784]  - attr(*, "resolved")= logi FALSE
[13:19:21.784]  - attr(*, "total_size")= num 6368
[13:19:21.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:21.784]  - attr(*, "already-done")= logi TRUE
[13:19:21.790] - reassign environment for ‘...future.FUN’
[13:19:21.790] - copied ‘...future.FUN’ to environment
[13:19:21.790] - copied ‘MoreArgs’ to environment
[13:19:21.790] - copied ‘...future.elements_ii’ to environment
[13:19:21.790] - copied ‘...future.seeds_ii’ to environment
[13:19:21.790] - copied ‘...future.globals.maxSize’ to environment
[13:19:21.790] assign_globals() ... done
[13:19:21.790] requestCore(): workers = 2
[13:19:21.792] MulticoreFuture started
[13:19:21.793] - Launch lazy future ... done
[13:19:21.793] run() for ‘MulticoreFuture’ ... done
[13:19:21.793] Created future:
[13:19:21.794] plan(): Setting new future strategy stack:
[13:19:21.794] List of future strategies:
[13:19:21.794] 1. sequential:
[13:19:21.794]    - args: function (..., envir = parent.frame())
[13:19:21.794]    - tweaked: FALSE
[13:19:21.794]    - call: NULL
[13:19:21.795] plan(): nbrOfWorkers() = 1
[13:19:21.793] MulticoreFuture:
[13:19:21.793] Label: ‘future_mapply-1’
[13:19:21.793] Expression:
[13:19:21.793] {
[13:19:21.793]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:21.793]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:21.793]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:21.793]         on.exit(options(oopts), add = TRUE)
[13:19:21.793]     }
[13:19:21.793]     {
[13:19:21.793]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:21.793]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:21.793]         do.call(mapply, args = args)
[13:19:21.793]     }
[13:19:21.793] }
[13:19:21.793] Lazy evaluation: FALSE
[13:19:21.793] Asynchronous evaluation: TRUE
[13:19:21.793] Local evaluation: TRUE
[13:19:21.793] Environment: R_GlobalEnv
[13:19:21.793] Capture standard output: TRUE
[13:19:21.793] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:21.793] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:21.793] Packages: <none>
[13:19:21.793] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:21.793] Resolved: FALSE
[13:19:21.793] Value: <not collected>
[13:19:21.793] Conditions captured: <none>
[13:19:21.793] Early signaling: FALSE
[13:19:21.793] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:21.793] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:21.806] Chunk #1 of 2 ... DONE
[13:19:21.806] Chunk #2 of 2 ...
[13:19:21.806]  - Finding globals in '...' for chunk #2 ...
[13:19:21.807] getGlobalsAndPackages() ...
[13:19:21.807] Searching for globals...
[13:19:21.807] 
[13:19:21.807] Searching for globals ... DONE
[13:19:21.808] - globals: [0] <none>
[13:19:21.808] getGlobalsAndPackages() ... DONE
[13:19:21.808]    + additional globals found: [n=0] 
[13:19:21.808]    + additional namespaces needed: [n=0] 
[13:19:21.808]  - Finding globals in '...' for chunk #2 ... DONE
[13:19:21.808]  - seeds: <none>
[13:19:21.809] getGlobalsAndPackages() ...
[13:19:21.809] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:21.809] Resolving globals: FALSE
[13:19:21.810] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:21.811] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:21.811] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:21.811] 
[13:19:21.811] getGlobalsAndPackages() ... DONE
[13:19:21.812] run() for ‘Future’ ...
[13:19:21.812] - state: ‘created’
[13:19:21.812] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:21.817] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:21.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:21.817]   - Field: ‘label’
[13:19:21.817]   - Field: ‘local’
[13:19:21.817]   - Field: ‘owner’
[13:19:21.818]   - Field: ‘envir’
[13:19:21.818]   - Field: ‘workers’
[13:19:21.818]   - Field: ‘packages’
[13:19:21.818]   - Field: ‘gc’
[13:19:21.818]   - Field: ‘job’
[13:19:21.818]   - Field: ‘conditions’
[13:19:21.818]   - Field: ‘expr’
[13:19:21.819]   - Field: ‘uuid’
[13:19:21.819]   - Field: ‘seed’
[13:19:21.819]   - Field: ‘version’
[13:19:21.819]   - Field: ‘result’
[13:19:21.819]   - Field: ‘asynchronous’
[13:19:21.819]   - Field: ‘calls’
[13:19:21.819]   - Field: ‘globals’
[13:19:21.820]   - Field: ‘stdout’
[13:19:21.820]   - Field: ‘earlySignal’
[13:19:21.820]   - Field: ‘lazy’
[13:19:21.820]   - Field: ‘state’
[13:19:21.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:21.820] - Launch lazy future ...
[13:19:21.821] Packages needed by the future expression (n = 0): <none>
[13:19:21.821] Packages needed by future strategies (n = 0): <none>
[13:19:21.822] {
[13:19:21.822]     {
[13:19:21.822]         {
[13:19:21.822]             ...future.startTime <- base::Sys.time()
[13:19:21.822]             {
[13:19:21.822]                 {
[13:19:21.822]                   {
[13:19:21.822]                     {
[13:19:21.822]                       base::local({
[13:19:21.822]                         has_future <- base::requireNamespace("future", 
[13:19:21.822]                           quietly = TRUE)
[13:19:21.822]                         if (has_future) {
[13:19:21.822]                           ns <- base::getNamespace("future")
[13:19:21.822]                           version <- ns[[".package"]][["version"]]
[13:19:21.822]                           if (is.null(version)) 
[13:19:21.822]                             version <- utils::packageVersion("future")
[13:19:21.822]                         }
[13:19:21.822]                         else {
[13:19:21.822]                           version <- NULL
[13:19:21.822]                         }
[13:19:21.822]                         if (!has_future || version < "1.8.0") {
[13:19:21.822]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:21.822]                             "", base::R.version$version.string), 
[13:19:21.822]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:21.822]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:21.822]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:21.822]                               "release", "version")], collapse = " "), 
[13:19:21.822]                             hostname = base::Sys.info()[["nodename"]])
[13:19:21.822]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:21.822]                             info)
[13:19:21.822]                           info <- base::paste(info, collapse = "; ")
[13:19:21.822]                           if (!has_future) {
[13:19:21.822]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:21.822]                               info)
[13:19:21.822]                           }
[13:19:21.822]                           else {
[13:19:21.822]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:21.822]                               info, version)
[13:19:21.822]                           }
[13:19:21.822]                           base::stop(msg)
[13:19:21.822]                         }
[13:19:21.822]                       })
[13:19:21.822]                     }
[13:19:21.822]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:21.822]                     base::options(mc.cores = 1L)
[13:19:21.822]                   }
[13:19:21.822]                   options(future.plan = NULL)
[13:19:21.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:21.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:21.822]                 }
[13:19:21.822]                 ...future.workdir <- getwd()
[13:19:21.822]             }
[13:19:21.822]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:21.822]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:21.822]         }
[13:19:21.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:21.822]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:21.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:21.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:21.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:21.822]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:21.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:21.822]             base::names(...future.oldOptions))
[13:19:21.822]     }
[13:19:21.822]     if (FALSE) {
[13:19:21.822]     }
[13:19:21.822]     else {
[13:19:21.822]         if (TRUE) {
[13:19:21.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:21.822]                 open = "w")
[13:19:21.822]         }
[13:19:21.822]         else {
[13:19:21.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:21.822]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:21.822]         }
[13:19:21.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:21.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:21.822]             base::sink(type = "output", split = FALSE)
[13:19:21.822]             base::close(...future.stdout)
[13:19:21.822]         }, add = TRUE)
[13:19:21.822]     }
[13:19:21.822]     ...future.frame <- base::sys.nframe()
[13:19:21.822]     ...future.conditions <- base::list()
[13:19:21.822]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:21.822]     if (FALSE) {
[13:19:21.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:21.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:21.822]     }
[13:19:21.822]     ...future.result <- base::tryCatch({
[13:19:21.822]         base::withCallingHandlers({
[13:19:21.822]             ...future.value <- base::withVisible(base::local({
[13:19:21.822]                 withCallingHandlers({
[13:19:21.822]                   {
[13:19:21.822]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:21.822]                     if (!identical(...future.globals.maxSize.org, 
[13:19:21.822]                       ...future.globals.maxSize)) {
[13:19:21.822]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:21.822]                       on.exit(options(oopts), add = TRUE)
[13:19:21.822]                     }
[13:19:21.822]                     {
[13:19:21.822]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:21.822]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:21.822]                         USE.NAMES = FALSE)
[13:19:21.822]                       do.call(mapply, args = args)
[13:19:21.822]                     }
[13:19:21.822]                   }
[13:19:21.822]                 }, immediateCondition = function(cond) {
[13:19:21.822]                   save_rds <- function (object, pathname, ...) 
[13:19:21.822]                   {
[13:19:21.822]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:21.822]                     if (file_test("-f", pathname_tmp)) {
[13:19:21.822]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.822]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:21.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.822]                         fi_tmp[["mtime"]])
[13:19:21.822]                     }
[13:19:21.822]                     tryCatch({
[13:19:21.822]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:21.822]                     }, error = function(ex) {
[13:19:21.822]                       msg <- conditionMessage(ex)
[13:19:21.822]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.822]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:21.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.822]                         fi_tmp[["mtime"]], msg)
[13:19:21.822]                       ex$message <- msg
[13:19:21.822]                       stop(ex)
[13:19:21.822]                     })
[13:19:21.822]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:21.822]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:21.822]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:21.822]                       fi_tmp <- file.info(pathname_tmp)
[13:19:21.822]                       fi <- file.info(pathname)
[13:19:21.822]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:21.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:21.822]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:21.822]                         fi[["size"]], fi[["mtime"]])
[13:19:21.822]                       stop(msg)
[13:19:21.822]                     }
[13:19:21.822]                     invisible(pathname)
[13:19:21.822]                   }
[13:19:21.822]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:21.822]                     rootPath = tempdir()) 
[13:19:21.822]                   {
[13:19:21.822]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:21.822]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:21.822]                       tmpdir = path, fileext = ".rds")
[13:19:21.822]                     save_rds(obj, file)
[13:19:21.822]                   }
[13:19:21.822]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:21.822]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.822]                   {
[13:19:21.822]                     inherits <- base::inherits
[13:19:21.822]                     invokeRestart <- base::invokeRestart
[13:19:21.822]                     is.null <- base::is.null
[13:19:21.822]                     muffled <- FALSE
[13:19:21.822]                     if (inherits(cond, "message")) {
[13:19:21.822]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:21.822]                       if (muffled) 
[13:19:21.822]                         invokeRestart("muffleMessage")
[13:19:21.822]                     }
[13:19:21.822]                     else if (inherits(cond, "warning")) {
[13:19:21.822]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:21.822]                       if (muffled) 
[13:19:21.822]                         invokeRestart("muffleWarning")
[13:19:21.822]                     }
[13:19:21.822]                     else if (inherits(cond, "condition")) {
[13:19:21.822]                       if (!is.null(pattern)) {
[13:19:21.822]                         computeRestarts <- base::computeRestarts
[13:19:21.822]                         grepl <- base::grepl
[13:19:21.822]                         restarts <- computeRestarts(cond)
[13:19:21.822]                         for (restart in restarts) {
[13:19:21.822]                           name <- restart$name
[13:19:21.822]                           if (is.null(name)) 
[13:19:21.822]                             next
[13:19:21.822]                           if (!grepl(pattern, name)) 
[13:19:21.822]                             next
[13:19:21.822]                           invokeRestart(restart)
[13:19:21.822]                           muffled <- TRUE
[13:19:21.822]                           break
[13:19:21.822]                         }
[13:19:21.822]                       }
[13:19:21.822]                     }
[13:19:21.822]                     invisible(muffled)
[13:19:21.822]                   }
[13:19:21.822]                   muffleCondition(cond)
[13:19:21.822]                 })
[13:19:21.822]             }))
[13:19:21.822]             future::FutureResult(value = ...future.value$value, 
[13:19:21.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:21.822]                   ...future.rng), globalenv = if (FALSE) 
[13:19:21.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:21.822]                     ...future.globalenv.names))
[13:19:21.822]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:21.822]         }, condition = base::local({
[13:19:21.822]             c <- base::c
[13:19:21.822]             inherits <- base::inherits
[13:19:21.822]             invokeRestart <- base::invokeRestart
[13:19:21.822]             length <- base::length
[13:19:21.822]             list <- base::list
[13:19:21.822]             seq.int <- base::seq.int
[13:19:21.822]             signalCondition <- base::signalCondition
[13:19:21.822]             sys.calls <- base::sys.calls
[13:19:21.822]             `[[` <- base::`[[`
[13:19:21.822]             `+` <- base::`+`
[13:19:21.822]             `<<-` <- base::`<<-`
[13:19:21.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:21.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:21.822]                   3L)]
[13:19:21.822]             }
[13:19:21.822]             function(cond) {
[13:19:21.822]                 is_error <- inherits(cond, "error")
[13:19:21.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:21.822]                   NULL)
[13:19:21.822]                 if (is_error) {
[13:19:21.822]                   sessionInformation <- function() {
[13:19:21.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:21.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:21.822]                       search = base::search(), system = base::Sys.info())
[13:19:21.822]                   }
[13:19:21.822]                   ...future.conditions[[length(...future.conditions) + 
[13:19:21.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:21.822]                     cond$call), session = sessionInformation(), 
[13:19:21.822]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:21.822]                   signalCondition(cond)
[13:19:21.822]                 }
[13:19:21.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:21.822]                 "immediateCondition"))) {
[13:19:21.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:21.822]                   ...future.conditions[[length(...future.conditions) + 
[13:19:21.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:21.822]                   if (TRUE && !signal) {
[13:19:21.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.822]                     {
[13:19:21.822]                       inherits <- base::inherits
[13:19:21.822]                       invokeRestart <- base::invokeRestart
[13:19:21.822]                       is.null <- base::is.null
[13:19:21.822]                       muffled <- FALSE
[13:19:21.822]                       if (inherits(cond, "message")) {
[13:19:21.822]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:21.822]                         if (muffled) 
[13:19:21.822]                           invokeRestart("muffleMessage")
[13:19:21.822]                       }
[13:19:21.822]                       else if (inherits(cond, "warning")) {
[13:19:21.822]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:21.822]                         if (muffled) 
[13:19:21.822]                           invokeRestart("muffleWarning")
[13:19:21.822]                       }
[13:19:21.822]                       else if (inherits(cond, "condition")) {
[13:19:21.822]                         if (!is.null(pattern)) {
[13:19:21.822]                           computeRestarts <- base::computeRestarts
[13:19:21.822]                           grepl <- base::grepl
[13:19:21.822]                           restarts <- computeRestarts(cond)
[13:19:21.822]                           for (restart in restarts) {
[13:19:21.822]                             name <- restart$name
[13:19:21.822]                             if (is.null(name)) 
[13:19:21.822]                               next
[13:19:21.822]                             if (!grepl(pattern, name)) 
[13:19:21.822]                               next
[13:19:21.822]                             invokeRestart(restart)
[13:19:21.822]                             muffled <- TRUE
[13:19:21.822]                             break
[13:19:21.822]                           }
[13:19:21.822]                         }
[13:19:21.822]                       }
[13:19:21.822]                       invisible(muffled)
[13:19:21.822]                     }
[13:19:21.822]                     muffleCondition(cond, pattern = "^muffle")
[13:19:21.822]                   }
[13:19:21.822]                 }
[13:19:21.822]                 else {
[13:19:21.822]                   if (TRUE) {
[13:19:21.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:21.822]                     {
[13:19:21.822]                       inherits <- base::inherits
[13:19:21.822]                       invokeRestart <- base::invokeRestart
[13:19:21.822]                       is.null <- base::is.null
[13:19:21.822]                       muffled <- FALSE
[13:19:21.822]                       if (inherits(cond, "message")) {
[13:19:21.822]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:21.822]                         if (muffled) 
[13:19:21.822]                           invokeRestart("muffleMessage")
[13:19:21.822]                       }
[13:19:21.822]                       else if (inherits(cond, "warning")) {
[13:19:21.822]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:21.822]                         if (muffled) 
[13:19:21.822]                           invokeRestart("muffleWarning")
[13:19:21.822]                       }
[13:19:21.822]                       else if (inherits(cond, "condition")) {
[13:19:21.822]                         if (!is.null(pattern)) {
[13:19:21.822]                           computeRestarts <- base::computeRestarts
[13:19:21.822]                           grepl <- base::grepl
[13:19:21.822]                           restarts <- computeRestarts(cond)
[13:19:21.822]                           for (restart in restarts) {
[13:19:21.822]                             name <- restart$name
[13:19:21.822]                             if (is.null(name)) 
[13:19:21.822]                               next
[13:19:21.822]                             if (!grepl(pattern, name)) 
[13:19:21.822]                               next
[13:19:21.822]                             invokeRestart(restart)
[13:19:21.822]                             muffled <- TRUE
[13:19:21.822]                             break
[13:19:21.822]                           }
[13:19:21.822]                         }
[13:19:21.822]                       }
[13:19:21.822]                       invisible(muffled)
[13:19:21.822]                     }
[13:19:21.822]                     muffleCondition(cond, pattern = "^muffle")
[13:19:21.822]                   }
[13:19:21.822]                 }
[13:19:21.822]             }
[13:19:21.822]         }))
[13:19:21.822]     }, error = function(ex) {
[13:19:21.822]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:21.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:21.822]                 ...future.rng), started = ...future.startTime, 
[13:19:21.822]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:21.822]             version = "1.8"), class = "FutureResult")
[13:19:21.822]     }, finally = {
[13:19:21.822]         if (!identical(...future.workdir, getwd())) 
[13:19:21.822]             setwd(...future.workdir)
[13:19:21.822]         {
[13:19:21.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:21.822]                 ...future.oldOptions$nwarnings <- NULL
[13:19:21.822]             }
[13:19:21.822]             base::options(...future.oldOptions)
[13:19:21.822]             if (.Platform$OS.type == "windows") {
[13:19:21.822]                 old_names <- names(...future.oldEnvVars)
[13:19:21.822]                 envs <- base::Sys.getenv()
[13:19:21.822]                 names <- names(envs)
[13:19:21.822]                 common <- intersect(names, old_names)
[13:19:21.822]                 added <- setdiff(names, old_names)
[13:19:21.822]                 removed <- setdiff(old_names, names)
[13:19:21.822]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:21.822]                   envs[common]]
[13:19:21.822]                 NAMES <- toupper(changed)
[13:19:21.822]                 args <- list()
[13:19:21.822]                 for (kk in seq_along(NAMES)) {
[13:19:21.822]                   name <- changed[[kk]]
[13:19:21.822]                   NAME <- NAMES[[kk]]
[13:19:21.822]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.822]                     next
[13:19:21.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:21.822]                 }
[13:19:21.822]                 NAMES <- toupper(added)
[13:19:21.822]                 for (kk in seq_along(NAMES)) {
[13:19:21.822]                   name <- added[[kk]]
[13:19:21.822]                   NAME <- NAMES[[kk]]
[13:19:21.822]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.822]                     next
[13:19:21.822]                   args[[name]] <- ""
[13:19:21.822]                 }
[13:19:21.822]                 NAMES <- toupper(removed)
[13:19:21.822]                 for (kk in seq_along(NAMES)) {
[13:19:21.822]                   name <- removed[[kk]]
[13:19:21.822]                   NAME <- NAMES[[kk]]
[13:19:21.822]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:21.822]                     next
[13:19:21.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:21.822]                 }
[13:19:21.822]                 if (length(args) > 0) 
[13:19:21.822]                   base::do.call(base::Sys.setenv, args = args)
[13:19:21.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:21.822]             }
[13:19:21.822]             else {
[13:19:21.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:21.822]             }
[13:19:21.822]             {
[13:19:21.822]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:21.822]                   0L) {
[13:19:21.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:21.822]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:21.822]                   base::options(opts)
[13:19:21.822]                 }
[13:19:21.822]                 {
[13:19:21.822]                   {
[13:19:21.822]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:21.822]                     NULL
[13:19:21.822]                   }
[13:19:21.822]                   options(future.plan = NULL)
[13:19:21.822]                   if (is.na(NA_character_)) 
[13:19:21.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:21.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:21.822]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:21.822]                     envir = parent.frame()) 
[13:19:21.822]                   {
[13:19:21.822]                     default_workers <- missing(workers)
[13:19:21.822]                     if (is.function(workers)) 
[13:19:21.822]                       workers <- workers()
[13:19:21.822]                     workers <- structure(as.integer(workers), 
[13:19:21.822]                       class = class(workers))
[13:19:21.822]                     stop_if_not(is.finite(workers), workers >= 
[13:19:21.822]                       1L)
[13:19:21.822]                     if ((workers == 1L && !inherits(workers, 
[13:19:21.822]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:21.822]                       if (default_workers) 
[13:19:21.822]                         supportsMulticore(warn = TRUE)
[13:19:21.822]                       return(sequential(..., envir = envir))
[13:19:21.822]                     }
[13:19:21.822]                     oopts <- options(mc.cores = workers)
[13:19:21.822]                     on.exit(options(oopts))
[13:19:21.822]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:21.822]                       envir = envir)
[13:19:21.822]                     if (!future$lazy) 
[13:19:21.822]                       future <- run(future)
[13:19:21.822]                     invisible(future)
[13:19:21.822]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:21.822]                 }
[13:19:21.822]             }
[13:19:21.822]         }
[13:19:21.822]     })
[13:19:21.822]     if (TRUE) {
[13:19:21.822]         base::sink(type = "output", split = FALSE)
[13:19:21.822]         if (TRUE) {
[13:19:21.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:21.822]         }
[13:19:21.822]         else {
[13:19:21.822]             ...future.result["stdout"] <- base::list(NULL)
[13:19:21.822]         }
[13:19:21.822]         base::close(...future.stdout)
[13:19:21.822]         ...future.stdout <- NULL
[13:19:21.822]     }
[13:19:21.822]     ...future.result$conditions <- ...future.conditions
[13:19:21.822]     ...future.result$finished <- base::Sys.time()
[13:19:21.822]     ...future.result
[13:19:21.822] }
[13:19:21.825] assign_globals() ...
[13:19:21.825] List of 5
[13:19:21.825]  $ ...future.FUN            :function (x, y)  
[13:19:21.825]  $ MoreArgs                 : NULL
[13:19:21.825]  $ ...future.elements_ii    :List of 2
[13:19:21.825]   ..$ :List of 1
[13:19:21.825]   .. ..$ : int 0
[13:19:21.825]   ..$ :List of 1
[13:19:21.825]   .. ..$ : int 1
[13:19:21.825]  $ ...future.seeds_ii       : NULL
[13:19:21.825]  $ ...future.globals.maxSize: NULL
[13:19:21.825]  - attr(*, "where")=List of 5
[13:19:21.825]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:21.825]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:21.825]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:21.825]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:21.825]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:21.825]  - attr(*, "resolved")= logi FALSE
[13:19:21.825]  - attr(*, "total_size")= num 6368
[13:19:21.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:21.825]  - attr(*, "already-done")= logi TRUE
[13:19:21.840] - reassign environment for ‘...future.FUN’
[13:19:21.840] - copied ‘...future.FUN’ to environment
[13:19:21.841] - copied ‘MoreArgs’ to environment
[13:19:21.841] - copied ‘...future.elements_ii’ to environment
[13:19:21.841] - copied ‘...future.seeds_ii’ to environment
[13:19:21.841] - copied ‘...future.globals.maxSize’ to environment
[13:19:21.841] assign_globals() ... done
[13:19:21.841] requestCore(): workers = 2
[13:19:21.844] MulticoreFuture started
[13:19:21.844] - Launch lazy future ... done
[13:19:21.844] run() for ‘MulticoreFuture’ ... done
[13:19:21.845] Created future:
[13:19:21.845] plan(): Setting new future strategy stack:
[13:19:21.845] List of future strategies:
[13:19:21.845] 1. sequential:
[13:19:21.845]    - args: function (..., envir = parent.frame())
[13:19:21.845]    - tweaked: FALSE
[13:19:21.845]    - call: NULL
[13:19:21.846] plan(): nbrOfWorkers() = 1
[13:19:21.849] plan(): Setting new future strategy stack:
[13:19:21.849] List of future strategies:
[13:19:21.849] 1. multicore:
[13:19:21.849]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:21.849]    - tweaked: FALSE
[13:19:21.849]    - call: plan(strategy)
[13:19:21.855] plan(): nbrOfWorkers() = 2
[13:19:21.845] MulticoreFuture:
[13:19:21.845] Label: ‘future_mapply-2’
[13:19:21.845] Expression:
[13:19:21.845] {
[13:19:21.845]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:21.845]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:21.845]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:21.845]         on.exit(options(oopts), add = TRUE)
[13:19:21.845]     }
[13:19:21.845]     {
[13:19:21.845]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:21.845]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:21.845]         do.call(mapply, args = args)
[13:19:21.845]     }
[13:19:21.845] }
[13:19:21.845] Lazy evaluation: FALSE
[13:19:21.845] Asynchronous evaluation: TRUE
[13:19:21.845] Local evaluation: TRUE
[13:19:21.845] Environment: R_GlobalEnv
[13:19:21.845] Capture standard output: TRUE
[13:19:21.845] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:21.845] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:21.845] Packages: <none>
[13:19:21.845] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:21.845] Resolved: TRUE
[13:19:21.845] Value: <not collected>
[13:19:21.845] Conditions captured: <none>
[13:19:21.845] Early signaling: FALSE
[13:19:21.845] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:21.845] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:21.856] Chunk #2 of 2 ... DONE
[13:19:21.857] Launching 2 futures (chunks) ... DONE
[13:19:21.857] Resolving 2 futures (chunks) ...
[13:19:21.857] resolve() on list ...
[13:19:21.857]  recursive: 0
[13:19:21.858]  length: 2
[13:19:21.858] 
[13:19:21.869] Future #2
[13:19:21.870] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:21.870] - nx: 2
[13:19:21.870] - relay: TRUE
[13:19:21.870] - stdout: TRUE
[13:19:21.871] - signal: TRUE
[13:19:21.871] - resignal: FALSE
[13:19:21.871] - force: TRUE
[13:19:21.871] - relayed: [n=2] FALSE, FALSE
[13:19:21.871] - queued futures: [n=2] FALSE, FALSE
[13:19:21.871]  - until=1
[13:19:21.872]  - relaying element #1
[13:19:21.872] - relayed: [n=2] FALSE, FALSE
[13:19:21.872] - queued futures: [n=2] FALSE, TRUE
[13:19:21.872] signalConditionsASAP(NULL, pos=2) ... done
[13:19:21.872]  length: 1 (resolved future 2)
[13:19:22.297] plan(): Setting new future strategy stack:
[13:19:22.298] List of future strategies:
[13:19:22.298] 1. multicore:
[13:19:22.298]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:22.298]    - tweaked: FALSE
[13:19:22.298]    - call: plan(strategy)
[13:19:22.302] plan(): nbrOfWorkers() = 2
[13:19:22.310] Future #1
[13:19:22.310] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:22.311] - nx: 2
[13:19:22.311] - relay: TRUE
[13:19:22.311] - stdout: TRUE
[13:19:22.311] - signal: TRUE
[13:19:22.311] - resignal: FALSE
[13:19:22.311] - force: TRUE
[13:19:22.312] - relayed: [n=2] FALSE, FALSE
[13:19:22.312] - queued futures: [n=2] FALSE, TRUE
[13:19:22.312]  - until=1
[13:19:22.312]  - relaying element #1
[13:19:22.312] - relayed: [n=2] TRUE, FALSE
[13:19:22.313] - queued futures: [n=2] TRUE, TRUE
[13:19:22.313] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:22.313]  length: 0 (resolved future 1)
[13:19:22.313] Relaying remaining futures
[13:19:22.313] signalConditionsASAP(NULL, pos=0) ...
[13:19:22.313] - nx: 2
[13:19:22.314] - relay: TRUE
[13:19:22.314] - stdout: TRUE
[13:19:22.314] - signal: TRUE
[13:19:22.314] - resignal: FALSE
[13:19:22.314] - force: TRUE
[13:19:22.314] - relayed: [n=2] TRUE, FALSE
[13:19:22.314] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:22.315]  - relaying element #2
[13:19:22.315] - relayed: [n=2] TRUE, TRUE
[13:19:22.315] - queued futures: [n=2] TRUE, TRUE
[13:19:22.315] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:19:22.315] resolve() on list ... DONE
[13:19:22.316]  - Number of value chunks collected: 2
[13:19:22.316] Resolving 2 futures (chunks) ... DONE
[13:19:22.316] Reducing values from 2 chunks ...
[13:19:22.316]  - Number of values collected after concatenation: 2
[13:19:22.316]  - Number of values expected: 2
[13:19:22.316] Reducing values from 2 chunks ... DONE
[13:19:22.316] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:19:22.317] future_mapply() ...
[13:19:22.321] Number of chunks: 2
[13:19:22.321] getGlobalsAndPackagesXApply() ...
[13:19:22.321]  - future.globals: TRUE
[13:19:22.322] getGlobalsAndPackages() ...
[13:19:22.322] Searching for globals...
[13:19:22.324] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:22.324] Searching for globals ... DONE
[13:19:22.324] Resolving globals: FALSE
[13:19:22.324] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:22.325] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:22.325] - globals: [1] ‘FUN’
[13:19:22.325] 
[13:19:22.325] getGlobalsAndPackages() ... DONE
[13:19:22.325]  - globals found/used: [n=1] ‘FUN’
[13:19:22.326]  - needed namespaces: [n=0] 
[13:19:22.326] Finding globals ... DONE
[13:19:22.326] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:22.326] List of 2
[13:19:22.326]  $ ...future.FUN:function (x, y)  
[13:19:22.326]  $ MoreArgs     : NULL
[13:19:22.326]  - attr(*, "where")=List of 2
[13:19:22.326]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:22.326]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:22.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:22.326]  - attr(*, "resolved")= logi FALSE
[13:19:22.326]  - attr(*, "total_size")= num NA
[13:19:22.329] Packages to be attached in all futures: [n=0] 
[13:19:22.329] getGlobalsAndPackagesXApply() ... DONE
[13:19:22.329] Number of futures (= number of chunks): 2
[13:19:22.330] Launching 2 futures (chunks) ...
[13:19:22.331] Chunk #1 of 2 ...
[13:19:22.332]  - Finding globals in '...' for chunk #1 ...
[13:19:22.332] getGlobalsAndPackages() ...
[13:19:22.332] Searching for globals...
[13:19:22.332] 
[13:19:22.332] Searching for globals ... DONE
[13:19:22.333] - globals: [0] <none>
[13:19:22.333] getGlobalsAndPackages() ... DONE
[13:19:22.333]    + additional globals found: [n=0] 
[13:19:22.333]    + additional namespaces needed: [n=0] 
[13:19:22.333]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:22.333]  - seeds: <none>
[13:19:22.333] getGlobalsAndPackages() ...
[13:19:22.333] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:22.334] Resolving globals: FALSE
[13:19:22.334] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:22.335] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:22.335] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:22.335] 
[13:19:22.335] getGlobalsAndPackages() ... DONE
[13:19:22.336] run() for ‘Future’ ...
[13:19:22.336] - state: ‘created’
[13:19:22.336] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:22.340] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:22.340] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:22.340]   - Field: ‘label’
[13:19:22.340]   - Field: ‘local’
[13:19:22.340]   - Field: ‘owner’
[13:19:22.340]   - Field: ‘envir’
[13:19:22.340]   - Field: ‘workers’
[13:19:22.340]   - Field: ‘packages’
[13:19:22.341]   - Field: ‘gc’
[13:19:22.341]   - Field: ‘job’
[13:19:22.341]   - Field: ‘conditions’
[13:19:22.341]   - Field: ‘expr’
[13:19:22.341]   - Field: ‘uuid’
[13:19:22.341]   - Field: ‘seed’
[13:19:22.341]   - Field: ‘version’
[13:19:22.341]   - Field: ‘result’
[13:19:22.341]   - Field: ‘asynchronous’
[13:19:22.341]   - Field: ‘calls’
[13:19:22.342]   - Field: ‘globals’
[13:19:22.342]   - Field: ‘stdout’
[13:19:22.342]   - Field: ‘earlySignal’
[13:19:22.342]   - Field: ‘lazy’
[13:19:22.342]   - Field: ‘state’
[13:19:22.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:22.342] - Launch lazy future ...
[13:19:22.342] Packages needed by the future expression (n = 0): <none>
[13:19:22.343] Packages needed by future strategies (n = 0): <none>
[13:19:22.343] {
[13:19:22.343]     {
[13:19:22.343]         {
[13:19:22.343]             ...future.startTime <- base::Sys.time()
[13:19:22.343]             {
[13:19:22.343]                 {
[13:19:22.343]                   {
[13:19:22.343]                     {
[13:19:22.343]                       base::local({
[13:19:22.343]                         has_future <- base::requireNamespace("future", 
[13:19:22.343]                           quietly = TRUE)
[13:19:22.343]                         if (has_future) {
[13:19:22.343]                           ns <- base::getNamespace("future")
[13:19:22.343]                           version <- ns[[".package"]][["version"]]
[13:19:22.343]                           if (is.null(version)) 
[13:19:22.343]                             version <- utils::packageVersion("future")
[13:19:22.343]                         }
[13:19:22.343]                         else {
[13:19:22.343]                           version <- NULL
[13:19:22.343]                         }
[13:19:22.343]                         if (!has_future || version < "1.8.0") {
[13:19:22.343]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:22.343]                             "", base::R.version$version.string), 
[13:19:22.343]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:22.343]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:22.343]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:22.343]                               "release", "version")], collapse = " "), 
[13:19:22.343]                             hostname = base::Sys.info()[["nodename"]])
[13:19:22.343]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:22.343]                             info)
[13:19:22.343]                           info <- base::paste(info, collapse = "; ")
[13:19:22.343]                           if (!has_future) {
[13:19:22.343]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:22.343]                               info)
[13:19:22.343]                           }
[13:19:22.343]                           else {
[13:19:22.343]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:22.343]                               info, version)
[13:19:22.343]                           }
[13:19:22.343]                           base::stop(msg)
[13:19:22.343]                         }
[13:19:22.343]                       })
[13:19:22.343]                     }
[13:19:22.343]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:22.343]                     base::options(mc.cores = 1L)
[13:19:22.343]                   }
[13:19:22.343]                   options(future.plan = NULL)
[13:19:22.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:22.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:22.343]                 }
[13:19:22.343]                 ...future.workdir <- getwd()
[13:19:22.343]             }
[13:19:22.343]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:22.343]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:22.343]         }
[13:19:22.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:22.343]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:22.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:22.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:22.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:22.343]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:22.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:22.343]             base::names(...future.oldOptions))
[13:19:22.343]     }
[13:19:22.343]     if (TRUE) {
[13:19:22.343]     }
[13:19:22.343]     else {
[13:19:22.343]         if (NA) {
[13:19:22.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:22.343]                 open = "w")
[13:19:22.343]         }
[13:19:22.343]         else {
[13:19:22.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:22.343]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:22.343]         }
[13:19:22.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:22.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:22.343]             base::sink(type = "output", split = FALSE)
[13:19:22.343]             base::close(...future.stdout)
[13:19:22.343]         }, add = TRUE)
[13:19:22.343]     }
[13:19:22.343]     ...future.frame <- base::sys.nframe()
[13:19:22.343]     ...future.conditions <- base::list()
[13:19:22.343]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:22.343]     if (FALSE) {
[13:19:22.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:22.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:22.343]     }
[13:19:22.343]     ...future.result <- base::tryCatch({
[13:19:22.343]         base::withCallingHandlers({
[13:19:22.343]             ...future.value <- base::withVisible(base::local({
[13:19:22.343]                 withCallingHandlers({
[13:19:22.343]                   {
[13:19:22.343]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:22.343]                     if (!identical(...future.globals.maxSize.org, 
[13:19:22.343]                       ...future.globals.maxSize)) {
[13:19:22.343]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:22.343]                       on.exit(options(oopts), add = TRUE)
[13:19:22.343]                     }
[13:19:22.343]                     {
[13:19:22.343]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:22.343]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:22.343]                         USE.NAMES = FALSE)
[13:19:22.343]                       do.call(mapply, args = args)
[13:19:22.343]                     }
[13:19:22.343]                   }
[13:19:22.343]                 }, immediateCondition = function(cond) {
[13:19:22.343]                   save_rds <- function (object, pathname, ...) 
[13:19:22.343]                   {
[13:19:22.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:22.343]                     if (file_test("-f", pathname_tmp)) {
[13:19:22.343]                       fi_tmp <- file.info(pathname_tmp)
[13:19:22.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:22.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:22.343]                         fi_tmp[["mtime"]])
[13:19:22.343]                     }
[13:19:22.343]                     tryCatch({
[13:19:22.343]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:22.343]                     }, error = function(ex) {
[13:19:22.343]                       msg <- conditionMessage(ex)
[13:19:22.343]                       fi_tmp <- file.info(pathname_tmp)
[13:19:22.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:22.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:22.343]                         fi_tmp[["mtime"]], msg)
[13:19:22.343]                       ex$message <- msg
[13:19:22.343]                       stop(ex)
[13:19:22.343]                     })
[13:19:22.343]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:22.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:22.343]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:22.343]                       fi_tmp <- file.info(pathname_tmp)
[13:19:22.343]                       fi <- file.info(pathname)
[13:19:22.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:22.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:22.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:22.343]                         fi[["size"]], fi[["mtime"]])
[13:19:22.343]                       stop(msg)
[13:19:22.343]                     }
[13:19:22.343]                     invisible(pathname)
[13:19:22.343]                   }
[13:19:22.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:22.343]                     rootPath = tempdir()) 
[13:19:22.343]                   {
[13:19:22.343]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:22.343]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:22.343]                       tmpdir = path, fileext = ".rds")
[13:19:22.343]                     save_rds(obj, file)
[13:19:22.343]                   }
[13:19:22.343]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:22.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:22.343]                   {
[13:19:22.343]                     inherits <- base::inherits
[13:19:22.343]                     invokeRestart <- base::invokeRestart
[13:19:22.343]                     is.null <- base::is.null
[13:19:22.343]                     muffled <- FALSE
[13:19:22.343]                     if (inherits(cond, "message")) {
[13:19:22.343]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:22.343]                       if (muffled) 
[13:19:22.343]                         invokeRestart("muffleMessage")
[13:19:22.343]                     }
[13:19:22.343]                     else if (inherits(cond, "warning")) {
[13:19:22.343]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:22.343]                       if (muffled) 
[13:19:22.343]                         invokeRestart("muffleWarning")
[13:19:22.343]                     }
[13:19:22.343]                     else if (inherits(cond, "condition")) {
[13:19:22.343]                       if (!is.null(pattern)) {
[13:19:22.343]                         computeRestarts <- base::computeRestarts
[13:19:22.343]                         grepl <- base::grepl
[13:19:22.343]                         restarts <- computeRestarts(cond)
[13:19:22.343]                         for (restart in restarts) {
[13:19:22.343]                           name <- restart$name
[13:19:22.343]                           if (is.null(name)) 
[13:19:22.343]                             next
[13:19:22.343]                           if (!grepl(pattern, name)) 
[13:19:22.343]                             next
[13:19:22.343]                           invokeRestart(restart)
[13:19:22.343]                           muffled <- TRUE
[13:19:22.343]                           break
[13:19:22.343]                         }
[13:19:22.343]                       }
[13:19:22.343]                     }
[13:19:22.343]                     invisible(muffled)
[13:19:22.343]                   }
[13:19:22.343]                   muffleCondition(cond)
[13:19:22.343]                 })
[13:19:22.343]             }))
[13:19:22.343]             future::FutureResult(value = ...future.value$value, 
[13:19:22.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:22.343]                   ...future.rng), globalenv = if (FALSE) 
[13:19:22.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:22.343]                     ...future.globalenv.names))
[13:19:22.343]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:22.343]         }, condition = base::local({
[13:19:22.343]             c <- base::c
[13:19:22.343]             inherits <- base::inherits
[13:19:22.343]             invokeRestart <- base::invokeRestart
[13:19:22.343]             length <- base::length
[13:19:22.343]             list <- base::list
[13:19:22.343]             seq.int <- base::seq.int
[13:19:22.343]             signalCondition <- base::signalCondition
[13:19:22.343]             sys.calls <- base::sys.calls
[13:19:22.343]             `[[` <- base::`[[`
[13:19:22.343]             `+` <- base::`+`
[13:19:22.343]             `<<-` <- base::`<<-`
[13:19:22.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:22.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:22.343]                   3L)]
[13:19:22.343]             }
[13:19:22.343]             function(cond) {
[13:19:22.343]                 is_error <- inherits(cond, "error")
[13:19:22.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:22.343]                   NULL)
[13:19:22.343]                 if (is_error) {
[13:19:22.343]                   sessionInformation <- function() {
[13:19:22.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:22.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:22.343]                       search = base::search(), system = base::Sys.info())
[13:19:22.343]                   }
[13:19:22.343]                   ...future.conditions[[length(...future.conditions) + 
[13:19:22.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:22.343]                     cond$call), session = sessionInformation(), 
[13:19:22.343]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:22.343]                   signalCondition(cond)
[13:19:22.343]                 }
[13:19:22.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:22.343]                 "immediateCondition"))) {
[13:19:22.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:22.343]                   ...future.conditions[[length(...future.conditions) + 
[13:19:22.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:22.343]                   if (TRUE && !signal) {
[13:19:22.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:22.343]                     {
[13:19:22.343]                       inherits <- base::inherits
[13:19:22.343]                       invokeRestart <- base::invokeRestart
[13:19:22.343]                       is.null <- base::is.null
[13:19:22.343]                       muffled <- FALSE
[13:19:22.343]                       if (inherits(cond, "message")) {
[13:19:22.343]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:22.343]                         if (muffled) 
[13:19:22.343]                           invokeRestart("muffleMessage")
[13:19:22.343]                       }
[13:19:22.343]                       else if (inherits(cond, "warning")) {
[13:19:22.343]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:22.343]                         if (muffled) 
[13:19:22.343]                           invokeRestart("muffleWarning")
[13:19:22.343]                       }
[13:19:22.343]                       else if (inherits(cond, "condition")) {
[13:19:22.343]                         if (!is.null(pattern)) {
[13:19:22.343]                           computeRestarts <- base::computeRestarts
[13:19:22.343]                           grepl <- base::grepl
[13:19:22.343]                           restarts <- computeRestarts(cond)
[13:19:22.343]                           for (restart in restarts) {
[13:19:22.343]                             name <- restart$name
[13:19:22.343]                             if (is.null(name)) 
[13:19:22.343]                               next
[13:19:22.343]                             if (!grepl(pattern, name)) 
[13:19:22.343]                               next
[13:19:22.343]                             invokeRestart(restart)
[13:19:22.343]                             muffled <- TRUE
[13:19:22.343]                             break
[13:19:22.343]                           }
[13:19:22.343]                         }
[13:19:22.343]                       }
[13:19:22.343]                       invisible(muffled)
[13:19:22.343]                     }
[13:19:22.343]                     muffleCondition(cond, pattern = "^muffle")
[13:19:22.343]                   }
[13:19:22.343]                 }
[13:19:22.343]                 else {
[13:19:22.343]                   if (TRUE) {
[13:19:22.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:22.343]                     {
[13:19:22.343]                       inherits <- base::inherits
[13:19:22.343]                       invokeRestart <- base::invokeRestart
[13:19:22.343]                       is.null <- base::is.null
[13:19:22.343]                       muffled <- FALSE
[13:19:22.343]                       if (inherits(cond, "message")) {
[13:19:22.343]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:22.343]                         if (muffled) 
[13:19:22.343]                           invokeRestart("muffleMessage")
[13:19:22.343]                       }
[13:19:22.343]                       else if (inherits(cond, "warning")) {
[13:19:22.343]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:22.343]                         if (muffled) 
[13:19:22.343]                           invokeRestart("muffleWarning")
[13:19:22.343]                       }
[13:19:22.343]                       else if (inherits(cond, "condition")) {
[13:19:22.343]                         if (!is.null(pattern)) {
[13:19:22.343]                           computeRestarts <- base::computeRestarts
[13:19:22.343]                           grepl <- base::grepl
[13:19:22.343]                           restarts <- computeRestarts(cond)
[13:19:22.343]                           for (restart in restarts) {
[13:19:22.343]                             name <- restart$name
[13:19:22.343]                             if (is.null(name)) 
[13:19:22.343]                               next
[13:19:22.343]                             if (!grepl(pattern, name)) 
[13:19:22.343]                               next
[13:19:22.343]                             invokeRestart(restart)
[13:19:22.343]                             muffled <- TRUE
[13:19:22.343]                             break
[13:19:22.343]                           }
[13:19:22.343]                         }
[13:19:22.343]                       }
[13:19:22.343]                       invisible(muffled)
[13:19:22.343]                     }
[13:19:22.343]                     muffleCondition(cond, pattern = "^muffle")
[13:19:22.343]                   }
[13:19:22.343]                 }
[13:19:22.343]             }
[13:19:22.343]         }))
[13:19:22.343]     }, error = function(ex) {
[13:19:22.343]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:22.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:22.343]                 ...future.rng), started = ...future.startTime, 
[13:19:22.343]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:22.343]             version = "1.8"), class = "FutureResult")
[13:19:22.343]     }, finally = {
[13:19:22.343]         if (!identical(...future.workdir, getwd())) 
[13:19:22.343]             setwd(...future.workdir)
[13:19:22.343]         {
[13:19:22.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:22.343]                 ...future.oldOptions$nwarnings <- NULL
[13:19:22.343]             }
[13:19:22.343]             base::options(...future.oldOptions)
[13:19:22.343]             if (.Platform$OS.type == "windows") {
[13:19:22.343]                 old_names <- names(...future.oldEnvVars)
[13:19:22.343]                 envs <- base::Sys.getenv()
[13:19:22.343]                 names <- names(envs)
[13:19:22.343]                 common <- intersect(names, old_names)
[13:19:22.343]                 added <- setdiff(names, old_names)
[13:19:22.343]                 removed <- setdiff(old_names, names)
[13:19:22.343]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:22.343]                   envs[common]]
[13:19:22.343]                 NAMES <- toupper(changed)
[13:19:22.343]                 args <- list()
[13:19:22.343]                 for (kk in seq_along(NAMES)) {
[13:19:22.343]                   name <- changed[[kk]]
[13:19:22.343]                   NAME <- NAMES[[kk]]
[13:19:22.343]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:22.343]                     next
[13:19:22.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:22.343]                 }
[13:19:22.343]                 NAMES <- toupper(added)
[13:19:22.343]                 for (kk in seq_along(NAMES)) {
[13:19:22.343]                   name <- added[[kk]]
[13:19:22.343]                   NAME <- NAMES[[kk]]
[13:19:22.343]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:22.343]                     next
[13:19:22.343]                   args[[name]] <- ""
[13:19:22.343]                 }
[13:19:22.343]                 NAMES <- toupper(removed)
[13:19:22.343]                 for (kk in seq_along(NAMES)) {
[13:19:22.343]                   name <- removed[[kk]]
[13:19:22.343]                   NAME <- NAMES[[kk]]
[13:19:22.343]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:22.343]                     next
[13:19:22.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:22.343]                 }
[13:19:22.343]                 if (length(args) > 0) 
[13:19:22.343]                   base::do.call(base::Sys.setenv, args = args)
[13:19:22.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:22.343]             }
[13:19:22.343]             else {
[13:19:22.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:22.343]             }
[13:19:22.343]             {
[13:19:22.343]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:22.343]                   0L) {
[13:19:22.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:22.343]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:22.343]                   base::options(opts)
[13:19:22.343]                 }
[13:19:22.343]                 {
[13:19:22.343]                   {
[13:19:22.343]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:22.343]                     NULL
[13:19:22.343]                   }
[13:19:22.343]                   options(future.plan = NULL)
[13:19:22.343]                   if (is.na(NA_character_)) 
[13:19:22.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:22.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:22.343]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:22.343]                     envir = parent.frame()) 
[13:19:22.343]                   {
[13:19:22.343]                     default_workers <- missing(workers)
[13:19:22.343]                     if (is.function(workers)) 
[13:19:22.343]                       workers <- workers()
[13:19:22.343]                     workers <- structure(as.integer(workers), 
[13:19:22.343]                       class = class(workers))
[13:19:22.343]                     stop_if_not(is.finite(workers), workers >= 
[13:19:22.343]                       1L)
[13:19:22.343]                     if ((workers == 1L && !inherits(workers, 
[13:19:22.343]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:22.343]                       if (default_workers) 
[13:19:22.343]                         supportsMulticore(warn = TRUE)
[13:19:22.343]                       return(sequential(..., envir = envir))
[13:19:22.343]                     }
[13:19:22.343]                     oopts <- options(mc.cores = workers)
[13:19:22.343]                     on.exit(options(oopts))
[13:19:22.343]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:22.343]                       envir = envir)
[13:19:22.343]                     if (!future$lazy) 
[13:19:22.343]                       future <- run(future)
[13:19:22.343]                     invisible(future)
[13:19:22.343]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:22.343]                 }
[13:19:22.343]             }
[13:19:22.343]         }
[13:19:22.343]     })
[13:19:22.343]     if (FALSE) {
[13:19:22.343]         base::sink(type = "output", split = FALSE)
[13:19:22.343]         if (NA) {
[13:19:22.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:22.343]         }
[13:19:22.343]         else {
[13:19:22.343]             ...future.result["stdout"] <- base::list(NULL)
[13:19:22.343]         }
[13:19:22.343]         base::close(...future.stdout)
[13:19:22.343]         ...future.stdout <- NULL
[13:19:22.343]     }
[13:19:22.343]     ...future.result$conditions <- ...future.conditions
[13:19:22.343]     ...future.result$finished <- base::Sys.time()
[13:19:22.343]     ...future.result
[13:19:22.343] }
[13:19:22.346] assign_globals() ...
[13:19:22.346] List of 5
[13:19:22.346]  $ ...future.FUN            :function (x, y)  
[13:19:22.346]  $ MoreArgs                 : NULL
[13:19:22.346]  $ ...future.elements_ii    :List of 2
[13:19:22.346]   ..$ :List of 1
[13:19:22.346]   .. ..$ : int 1
[13:19:22.346]   ..$ :List of 1
[13:19:22.346]   .. ..$ : int 0
[13:19:22.346]  $ ...future.seeds_ii       : NULL
[13:19:22.346]  $ ...future.globals.maxSize: NULL
[13:19:22.346]  - attr(*, "where")=List of 5
[13:19:22.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:22.346]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:22.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:22.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:22.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:22.346]  - attr(*, "resolved")= logi FALSE
[13:19:22.346]  - attr(*, "total_size")= num 6368
[13:19:22.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:22.346]  - attr(*, "already-done")= logi TRUE
[13:19:22.351] - reassign environment for ‘...future.FUN’
[13:19:22.351] - copied ‘...future.FUN’ to environment
[13:19:22.351] - copied ‘MoreArgs’ to environment
[13:19:22.351] - copied ‘...future.elements_ii’ to environment
[13:19:22.351] - copied ‘...future.seeds_ii’ to environment
[13:19:22.351] - copied ‘...future.globals.maxSize’ to environment
[13:19:22.351] assign_globals() ... done
[13:19:22.351] requestCore(): workers = 2
[13:19:22.354] MulticoreFuture started
[13:19:22.354] - Launch lazy future ... done
[13:19:22.354] run() for ‘MulticoreFuture’ ... done
[13:19:22.354] Created future:
[13:19:22.355] plan(): Setting new future strategy stack:
[13:19:22.355] List of future strategies:
[13:19:22.355] 1. sequential:
[13:19:22.355]    - args: function (..., envir = parent.frame())
[13:19:22.355]    - tweaked: FALSE
[13:19:22.355]    - call: NULL
[13:19:22.356] plan(): nbrOfWorkers() = 1
[13:19:22.355] MulticoreFuture:
[13:19:22.355] Label: ‘future_mapply-1’
[13:19:22.355] Expression:
[13:19:22.355] {
[13:19:22.355]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:22.355]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:22.355]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:22.355]         on.exit(options(oopts), add = TRUE)
[13:19:22.355]     }
[13:19:22.355]     {
[13:19:22.355]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:22.355]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:22.355]         do.call(mapply, args = args)
[13:19:22.355]     }
[13:19:22.355] }
[13:19:22.355] Lazy evaluation: FALSE
[13:19:22.355] Asynchronous evaluation: TRUE
[13:19:22.355] Local evaluation: TRUE
[13:19:22.355] Environment: R_GlobalEnv
[13:19:22.355] Capture standard output: NA
[13:19:22.355] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:22.355] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:22.355] Packages: <none>
[13:19:22.355] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:22.355] Resolved: FALSE
[13:19:22.355] Value: <not collected>
[13:19:22.355] Conditions captured: <none>
[13:19:22.355] Early signaling: FALSE
[13:19:22.355] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:22.355] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:22.367] Chunk #1 of 2 ... DONE
[13:19:22.367] Chunk #2 of 2 ...
[13:19:22.367]  - Finding globals in '...' for chunk #2 ...
[13:19:22.368] getGlobalsAndPackages() ...
[13:19:22.368] Searching for globals...
[13:19:22.368] 
[13:19:22.369] Searching for globals ... DONE
[13:19:22.369] - globals: [0] <none>
[13:19:22.369] getGlobalsAndPackages() ... DONE
[13:19:22.369]    + additional globals found: [n=0] 
[13:19:22.369]    + additional namespaces needed: [n=0] 
[13:19:22.369]  - Finding globals in '...' for chunk #2 ... DONE
[13:19:22.370]  - seeds: <none>
[13:19:22.370] getGlobalsAndPackages() ...
[13:19:22.370] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:22.370] Resolving globals: FALSE
[13:19:22.371] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:22.372] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:22.372] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:22.372] 
[13:19:22.372] getGlobalsAndPackages() ... DONE
[13:19:22.373] run() for ‘Future’ ...
[13:19:22.373] - state: ‘created’
[13:19:22.373] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:19:22.378] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:22.379] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:19:22.379]   - Field: ‘label’
[13:19:22.379]   - Field: ‘local’
[13:19:22.379]   - Field: ‘owner’
[13:19:22.379]   - Field: ‘envir’
[13:19:22.379]   - Field: ‘workers’
[13:19:22.383]   - Field: ‘packages’
[13:19:22.383]   - Field: ‘gc’
[13:19:22.384]   - Field: ‘job’
[13:19:22.384]   - Field: ‘conditions’
[13:19:22.384]   - Field: ‘expr’
[13:19:22.385]   - Field: ‘uuid’
[13:19:22.385]   - Field: ‘seed’
[13:19:22.385]   - Field: ‘version’
[13:19:22.385]   - Field: ‘result’
[13:19:22.386]   - Field: ‘asynchronous’
[13:19:22.386]   - Field: ‘calls’
[13:19:22.386]   - Field: ‘globals’
[13:19:22.386]   - Field: ‘stdout’
[13:19:22.387]   - Field: ‘earlySignal’
[13:19:22.387]   - Field: ‘lazy’
[13:19:22.387]   - Field: ‘state’
[13:19:22.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:19:22.388] - Launch lazy future ...
[13:19:22.388] Packages needed by the future expression (n = 0): <none>
[13:19:22.388] Packages needed by future strategies (n = 0): <none>
[13:19:22.390] {
[13:19:22.390]     {
[13:19:22.390]         {
[13:19:22.390]             ...future.startTime <- base::Sys.time()
[13:19:22.390]             {
[13:19:22.390]                 {
[13:19:22.390]                   {
[13:19:22.390]                     {
[13:19:22.390]                       base::local({
[13:19:22.390]                         has_future <- base::requireNamespace("future", 
[13:19:22.390]                           quietly = TRUE)
[13:19:22.390]                         if (has_future) {
[13:19:22.390]                           ns <- base::getNamespace("future")
[13:19:22.390]                           version <- ns[[".package"]][["version"]]
[13:19:22.390]                           if (is.null(version)) 
[13:19:22.390]                             version <- utils::packageVersion("future")
[13:19:22.390]                         }
[13:19:22.390]                         else {
[13:19:22.390]                           version <- NULL
[13:19:22.390]                         }
[13:19:22.390]                         if (!has_future || version < "1.8.0") {
[13:19:22.390]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:22.390]                             "", base::R.version$version.string), 
[13:19:22.390]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:22.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:22.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:22.390]                               "release", "version")], collapse = " "), 
[13:19:22.390]                             hostname = base::Sys.info()[["nodename"]])
[13:19:22.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:22.390]                             info)
[13:19:22.390]                           info <- base::paste(info, collapse = "; ")
[13:19:22.390]                           if (!has_future) {
[13:19:22.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:22.390]                               info)
[13:19:22.390]                           }
[13:19:22.390]                           else {
[13:19:22.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:22.390]                               info, version)
[13:19:22.390]                           }
[13:19:22.390]                           base::stop(msg)
[13:19:22.390]                         }
[13:19:22.390]                       })
[13:19:22.390]                     }
[13:19:22.390]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:22.390]                     base::options(mc.cores = 1L)
[13:19:22.390]                   }
[13:19:22.390]                   options(future.plan = NULL)
[13:19:22.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:22.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:22.390]                 }
[13:19:22.390]                 ...future.workdir <- getwd()
[13:19:22.390]             }
[13:19:22.390]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:22.390]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:22.390]         }
[13:19:22.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:22.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:22.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:22.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:22.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:22.390]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:22.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:22.390]             base::names(...future.oldOptions))
[13:19:22.390]     }
[13:19:22.390]     if (TRUE) {
[13:19:22.390]     }
[13:19:22.390]     else {
[13:19:22.390]         if (NA) {
[13:19:22.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:22.390]                 open = "w")
[13:19:22.390]         }
[13:19:22.390]         else {
[13:19:22.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:22.390]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:22.390]         }
[13:19:22.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:22.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:22.390]             base::sink(type = "output", split = FALSE)
[13:19:22.390]             base::close(...future.stdout)
[13:19:22.390]         }, add = TRUE)
[13:19:22.390]     }
[13:19:22.390]     ...future.frame <- base::sys.nframe()
[13:19:22.390]     ...future.conditions <- base::list()
[13:19:22.390]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:22.390]     if (FALSE) {
[13:19:22.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:22.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:22.390]     }
[13:19:22.390]     ...future.result <- base::tryCatch({
[13:19:22.390]         base::withCallingHandlers({
[13:19:22.390]             ...future.value <- base::withVisible(base::local({
[13:19:22.390]                 withCallingHandlers({
[13:19:22.390]                   {
[13:19:22.390]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:22.390]                     if (!identical(...future.globals.maxSize.org, 
[13:19:22.390]                       ...future.globals.maxSize)) {
[13:19:22.390]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:22.390]                       on.exit(options(oopts), add = TRUE)
[13:19:22.390]                     }
[13:19:22.390]                     {
[13:19:22.390]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:22.390]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:22.390]                         USE.NAMES = FALSE)
[13:19:22.390]                       do.call(mapply, args = args)
[13:19:22.390]                     }
[13:19:22.390]                   }
[13:19:22.390]                 }, immediateCondition = function(cond) {
[13:19:22.390]                   save_rds <- function (object, pathname, ...) 
[13:19:22.390]                   {
[13:19:22.390]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:19:22.390]                     if (file_test("-f", pathname_tmp)) {
[13:19:22.390]                       fi_tmp <- file.info(pathname_tmp)
[13:19:22.390]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:19:22.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:22.390]                         fi_tmp[["mtime"]])
[13:19:22.390]                     }
[13:19:22.390]                     tryCatch({
[13:19:22.390]                       saveRDS(object, file = pathname_tmp, ...)
[13:19:22.390]                     }, error = function(ex) {
[13:19:22.390]                       msg <- conditionMessage(ex)
[13:19:22.390]                       fi_tmp <- file.info(pathname_tmp)
[13:19:22.390]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:19:22.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:22.390]                         fi_tmp[["mtime"]], msg)
[13:19:22.390]                       ex$message <- msg
[13:19:22.390]                       stop(ex)
[13:19:22.390]                     })
[13:19:22.390]                     stopifnot(file_test("-f", pathname_tmp))
[13:19:22.390]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:19:22.390]                     if (!res || file_test("-f", pathname_tmp)) {
[13:19:22.390]                       fi_tmp <- file.info(pathname_tmp)
[13:19:22.390]                       fi <- file.info(pathname)
[13:19:22.390]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:19:22.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:19:22.390]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:19:22.390]                         fi[["size"]], fi[["mtime"]])
[13:19:22.390]                       stop(msg)
[13:19:22.390]                     }
[13:19:22.390]                     invisible(pathname)
[13:19:22.390]                   }
[13:19:22.390]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:19:22.390]                     rootPath = tempdir()) 
[13:19:22.390]                   {
[13:19:22.390]                     obj <- list(time = Sys.time(), condition = cond)
[13:19:22.390]                     file <- tempfile(pattern = class(cond)[1], 
[13:19:22.390]                       tmpdir = path, fileext = ".rds")
[13:19:22.390]                     save_rds(obj, file)
[13:19:22.390]                   }
[13:19:22.390]                   saveImmediateCondition(cond, path = "/tmp/RtmpTU0vAz/.future/immediateConditions")
[13:19:22.390]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:22.390]                   {
[13:19:22.390]                     inherits <- base::inherits
[13:19:22.390]                     invokeRestart <- base::invokeRestart
[13:19:22.390]                     is.null <- base::is.null
[13:19:22.390]                     muffled <- FALSE
[13:19:22.390]                     if (inherits(cond, "message")) {
[13:19:22.390]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:22.390]                       if (muffled) 
[13:19:22.390]                         invokeRestart("muffleMessage")
[13:19:22.390]                     }
[13:19:22.390]                     else if (inherits(cond, "warning")) {
[13:19:22.390]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:22.390]                       if (muffled) 
[13:19:22.390]                         invokeRestart("muffleWarning")
[13:19:22.390]                     }
[13:19:22.390]                     else if (inherits(cond, "condition")) {
[13:19:22.390]                       if (!is.null(pattern)) {
[13:19:22.390]                         computeRestarts <- base::computeRestarts
[13:19:22.390]                         grepl <- base::grepl
[13:19:22.390]                         restarts <- computeRestarts(cond)
[13:19:22.390]                         for (restart in restarts) {
[13:19:22.390]                           name <- restart$name
[13:19:22.390]                           if (is.null(name)) 
[13:19:22.390]                             next
[13:19:22.390]                           if (!grepl(pattern, name)) 
[13:19:22.390]                             next
[13:19:22.390]                           invokeRestart(restart)
[13:19:22.390]                           muffled <- TRUE
[13:19:22.390]                           break
[13:19:22.390]                         }
[13:19:22.390]                       }
[13:19:22.390]                     }
[13:19:22.390]                     invisible(muffled)
[13:19:22.390]                   }
[13:19:22.390]                   muffleCondition(cond)
[13:19:22.390]                 })
[13:19:22.390]             }))
[13:19:22.390]             future::FutureResult(value = ...future.value$value, 
[13:19:22.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:22.390]                   ...future.rng), globalenv = if (FALSE) 
[13:19:22.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:22.390]                     ...future.globalenv.names))
[13:19:22.390]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:22.390]         }, condition = base::local({
[13:19:22.390]             c <- base::c
[13:19:22.390]             inherits <- base::inherits
[13:19:22.390]             invokeRestart <- base::invokeRestart
[13:19:22.390]             length <- base::length
[13:19:22.390]             list <- base::list
[13:19:22.390]             seq.int <- base::seq.int
[13:19:22.390]             signalCondition <- base::signalCondition
[13:19:22.390]             sys.calls <- base::sys.calls
[13:19:22.390]             `[[` <- base::`[[`
[13:19:22.390]             `+` <- base::`+`
[13:19:22.390]             `<<-` <- base::`<<-`
[13:19:22.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:22.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:22.390]                   3L)]
[13:19:22.390]             }
[13:19:22.390]             function(cond) {
[13:19:22.390]                 is_error <- inherits(cond, "error")
[13:19:22.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:22.390]                   NULL)
[13:19:22.390]                 if (is_error) {
[13:19:22.390]                   sessionInformation <- function() {
[13:19:22.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:22.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:22.390]                       search = base::search(), system = base::Sys.info())
[13:19:22.390]                   }
[13:19:22.390]                   ...future.conditions[[length(...future.conditions) + 
[13:19:22.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:22.390]                     cond$call), session = sessionInformation(), 
[13:19:22.390]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:22.390]                   signalCondition(cond)
[13:19:22.390]                 }
[13:19:22.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:22.390]                 "immediateCondition"))) {
[13:19:22.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:22.390]                   ...future.conditions[[length(...future.conditions) + 
[13:19:22.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:22.390]                   if (TRUE && !signal) {
[13:19:22.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:22.390]                     {
[13:19:22.390]                       inherits <- base::inherits
[13:19:22.390]                       invokeRestart <- base::invokeRestart
[13:19:22.390]                       is.null <- base::is.null
[13:19:22.390]                       muffled <- FALSE
[13:19:22.390]                       if (inherits(cond, "message")) {
[13:19:22.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:22.390]                         if (muffled) 
[13:19:22.390]                           invokeRestart("muffleMessage")
[13:19:22.390]                       }
[13:19:22.390]                       else if (inherits(cond, "warning")) {
[13:19:22.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:22.390]                         if (muffled) 
[13:19:22.390]                           invokeRestart("muffleWarning")
[13:19:22.390]                       }
[13:19:22.390]                       else if (inherits(cond, "condition")) {
[13:19:22.390]                         if (!is.null(pattern)) {
[13:19:22.390]                           computeRestarts <- base::computeRestarts
[13:19:22.390]                           grepl <- base::grepl
[13:19:22.390]                           restarts <- computeRestarts(cond)
[13:19:22.390]                           for (restart in restarts) {
[13:19:22.390]                             name <- restart$name
[13:19:22.390]                             if (is.null(name)) 
[13:19:22.390]                               next
[13:19:22.390]                             if (!grepl(pattern, name)) 
[13:19:22.390]                               next
[13:19:22.390]                             invokeRestart(restart)
[13:19:22.390]                             muffled <- TRUE
[13:19:22.390]                             break
[13:19:22.390]                           }
[13:19:22.390]                         }
[13:19:22.390]                       }
[13:19:22.390]                       invisible(muffled)
[13:19:22.390]                     }
[13:19:22.390]                     muffleCondition(cond, pattern = "^muffle")
[13:19:22.390]                   }
[13:19:22.390]                 }
[13:19:22.390]                 else {
[13:19:22.390]                   if (TRUE) {
[13:19:22.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:22.390]                     {
[13:19:22.390]                       inherits <- base::inherits
[13:19:22.390]                       invokeRestart <- base::invokeRestart
[13:19:22.390]                       is.null <- base::is.null
[13:19:22.390]                       muffled <- FALSE
[13:19:22.390]                       if (inherits(cond, "message")) {
[13:19:22.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:22.390]                         if (muffled) 
[13:19:22.390]                           invokeRestart("muffleMessage")
[13:19:22.390]                       }
[13:19:22.390]                       else if (inherits(cond, "warning")) {
[13:19:22.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:22.390]                         if (muffled) 
[13:19:22.390]                           invokeRestart("muffleWarning")
[13:19:22.390]                       }
[13:19:22.390]                       else if (inherits(cond, "condition")) {
[13:19:22.390]                         if (!is.null(pattern)) {
[13:19:22.390]                           computeRestarts <- base::computeRestarts
[13:19:22.390]                           grepl <- base::grepl
[13:19:22.390]                           restarts <- computeRestarts(cond)
[13:19:22.390]                           for (restart in restarts) {
[13:19:22.390]                             name <- restart$name
[13:19:22.390]                             if (is.null(name)) 
[13:19:22.390]                               next
[13:19:22.390]                             if (!grepl(pattern, name)) 
[13:19:22.390]                               next
[13:19:22.390]                             invokeRestart(restart)
[13:19:22.390]                             muffled <- TRUE
[13:19:22.390]                             break
[13:19:22.390]                           }
[13:19:22.390]                         }
[13:19:22.390]                       }
[13:19:22.390]                       invisible(muffled)
[13:19:22.390]                     }
[13:19:22.390]                     muffleCondition(cond, pattern = "^muffle")
[13:19:22.390]                   }
[13:19:22.390]                 }
[13:19:22.390]             }
[13:19:22.390]         }))
[13:19:22.390]     }, error = function(ex) {
[13:19:22.390]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:22.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:22.390]                 ...future.rng), started = ...future.startTime, 
[13:19:22.390]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:22.390]             version = "1.8"), class = "FutureResult")
[13:19:22.390]     }, finally = {
[13:19:22.390]         if (!identical(...future.workdir, getwd())) 
[13:19:22.390]             setwd(...future.workdir)
[13:19:22.390]         {
[13:19:22.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:22.390]                 ...future.oldOptions$nwarnings <- NULL
[13:19:22.390]             }
[13:19:22.390]             base::options(...future.oldOptions)
[13:19:22.390]             if (.Platform$OS.type == "windows") {
[13:19:22.390]                 old_names <- names(...future.oldEnvVars)
[13:19:22.390]                 envs <- base::Sys.getenv()
[13:19:22.390]                 names <- names(envs)
[13:19:22.390]                 common <- intersect(names, old_names)
[13:19:22.390]                 added <- setdiff(names, old_names)
[13:19:22.390]                 removed <- setdiff(old_names, names)
[13:19:22.390]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:22.390]                   envs[common]]
[13:19:22.390]                 NAMES <- toupper(changed)
[13:19:22.390]                 args <- list()
[13:19:22.390]                 for (kk in seq_along(NAMES)) {
[13:19:22.390]                   name <- changed[[kk]]
[13:19:22.390]                   NAME <- NAMES[[kk]]
[13:19:22.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:22.390]                     next
[13:19:22.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:22.390]                 }
[13:19:22.390]                 NAMES <- toupper(added)
[13:19:22.390]                 for (kk in seq_along(NAMES)) {
[13:19:22.390]                   name <- added[[kk]]
[13:19:22.390]                   NAME <- NAMES[[kk]]
[13:19:22.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:22.390]                     next
[13:19:22.390]                   args[[name]] <- ""
[13:19:22.390]                 }
[13:19:22.390]                 NAMES <- toupper(removed)
[13:19:22.390]                 for (kk in seq_along(NAMES)) {
[13:19:22.390]                   name <- removed[[kk]]
[13:19:22.390]                   NAME <- NAMES[[kk]]
[13:19:22.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:22.390]                     next
[13:19:22.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:22.390]                 }
[13:19:22.390]                 if (length(args) > 0) 
[13:19:22.390]                   base::do.call(base::Sys.setenv, args = args)
[13:19:22.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:22.390]             }
[13:19:22.390]             else {
[13:19:22.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:22.390]             }
[13:19:22.390]             {
[13:19:22.390]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:22.390]                   0L) {
[13:19:22.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:22.390]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:22.390]                   base::options(opts)
[13:19:22.390]                 }
[13:19:22.390]                 {
[13:19:22.390]                   {
[13:19:22.390]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:22.390]                     NULL
[13:19:22.390]                   }
[13:19:22.390]                   options(future.plan = NULL)
[13:19:22.390]                   if (is.na(NA_character_)) 
[13:19:22.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:22.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:22.390]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:19:22.390]                     envir = parent.frame()) 
[13:19:22.390]                   {
[13:19:22.390]                     default_workers <- missing(workers)
[13:19:22.390]                     if (is.function(workers)) 
[13:19:22.390]                       workers <- workers()
[13:19:22.390]                     workers <- structure(as.integer(workers), 
[13:19:22.390]                       class = class(workers))
[13:19:22.390]                     stop_if_not(is.finite(workers), workers >= 
[13:19:22.390]                       1L)
[13:19:22.390]                     if ((workers == 1L && !inherits(workers, 
[13:19:22.390]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:19:22.390]                       if (default_workers) 
[13:19:22.390]                         supportsMulticore(warn = TRUE)
[13:19:22.390]                       return(sequential(..., envir = envir))
[13:19:22.390]                     }
[13:19:22.390]                     oopts <- options(mc.cores = workers)
[13:19:22.390]                     on.exit(options(oopts))
[13:19:22.390]                     future <- MulticoreFuture(..., workers = workers, 
[13:19:22.390]                       envir = envir)
[13:19:22.390]                     if (!future$lazy) 
[13:19:22.390]                       future <- run(future)
[13:19:22.390]                     invisible(future)
[13:19:22.390]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:22.390]                 }
[13:19:22.390]             }
[13:19:22.390]         }
[13:19:22.390]     })
[13:19:22.390]     if (FALSE) {
[13:19:22.390]         base::sink(type = "output", split = FALSE)
[13:19:22.390]         if (NA) {
[13:19:22.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:22.390]         }
[13:19:22.390]         else {
[13:19:22.390]             ...future.result["stdout"] <- base::list(NULL)
[13:19:22.390]         }
[13:19:22.390]         base::close(...future.stdout)
[13:19:22.390]         ...future.stdout <- NULL
[13:19:22.390]     }
[13:19:22.390]     ...future.result$conditions <- ...future.conditions
[13:19:22.390]     ...future.result$finished <- base::Sys.time()
[13:19:22.390]     ...future.result
[13:19:22.390] }
[13:19:22.392] assign_globals() ...
[13:19:22.393] List of 5
[13:19:22.393]  $ ...future.FUN            :function (x, y)  
[13:19:22.393]  $ MoreArgs                 : NULL
[13:19:22.393]  $ ...future.elements_ii    :List of 2
[13:19:22.393]   ..$ :List of 1
[13:19:22.393]   .. ..$ : int 0
[13:19:22.393]   ..$ :List of 1
[13:19:22.393]   .. ..$ : int 1
[13:19:22.393]  $ ...future.seeds_ii       : NULL
[13:19:22.393]  $ ...future.globals.maxSize: NULL
[13:19:22.393]  - attr(*, "where")=List of 5
[13:19:22.393]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:19:22.393]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:19:22.393]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:19:22.393]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:19:22.393]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:19:22.393]  - attr(*, "resolved")= logi FALSE
[13:19:22.393]  - attr(*, "total_size")= num 6368
[13:19:22.393]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:22.393]  - attr(*, "already-done")= logi TRUE
[13:19:22.401] - reassign environment for ‘...future.FUN’
[13:19:22.401] - copied ‘...future.FUN’ to environment
[13:19:22.401] - copied ‘MoreArgs’ to environment
[13:19:22.401] - copied ‘...future.elements_ii’ to environment
[13:19:22.401] - copied ‘...future.seeds_ii’ to environment
[13:19:22.401] - copied ‘...future.globals.maxSize’ to environment
[13:19:22.402] assign_globals() ... done
[13:19:22.402] requestCore(): workers = 2
[13:19:22.404] MulticoreFuture started
[13:19:22.404] - Launch lazy future ... done
[13:19:22.405] run() for ‘MulticoreFuture’ ... done
[13:19:22.405] Created future:
[13:19:22.405] plan(): Setting new future strategy stack:
[13:19:22.406] List of future strategies:
[13:19:22.406] 1. sequential:
[13:19:22.406]    - args: function (..., envir = parent.frame())
[13:19:22.406]    - tweaked: FALSE
[13:19:22.406]    - call: NULL
[13:19:22.406] plan(): nbrOfWorkers() = 1
[13:19:22.408] plan(): Setting new future strategy stack:
[13:19:22.409] List of future strategies:
[13:19:22.409] 1. multicore:
[13:19:22.409]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:22.409]    - tweaked: FALSE
[13:19:22.409]    - call: plan(strategy)
[13:19:22.414] plan(): nbrOfWorkers() = 2
[13:19:22.405] MulticoreFuture:
[13:19:22.405] Label: ‘future_mapply-2’
[13:19:22.405] Expression:
[13:19:22.405] {
[13:19:22.405]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:22.405]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:22.405]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:22.405]         on.exit(options(oopts), add = TRUE)
[13:19:22.405]     }
[13:19:22.405]     {
[13:19:22.405]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:22.405]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:22.405]         do.call(mapply, args = args)
[13:19:22.405]     }
[13:19:22.405] }
[13:19:22.405] Lazy evaluation: FALSE
[13:19:22.405] Asynchronous evaluation: TRUE
[13:19:22.405] Local evaluation: TRUE
[13:19:22.405] Environment: R_GlobalEnv
[13:19:22.405] Capture standard output: NA
[13:19:22.405] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:22.405] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:22.405] Packages: <none>
[13:19:22.405] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:22.405] Resolved: TRUE
[13:19:22.405] Value: <not collected>
[13:19:22.405] Conditions captured: <none>
[13:19:22.405] Early signaling: FALSE
[13:19:22.405] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:22.405] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:22.415] Chunk #2 of 2 ... DONE
[13:19:22.415] Launching 2 futures (chunks) ... DONE
[13:19:22.415] Resolving 2 futures (chunks) ...
[13:19:22.415] resolve() on list ...
[13:19:22.416]  recursive: 0
[13:19:22.416]  length: 2
[13:19:22.416] 
[13:19:22.426] Future #2
[13:19:22.428] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:19:22.428] - nx: 2
[13:19:22.428] - relay: TRUE
[13:19:22.428] - stdout: TRUE
[13:19:22.428] - signal: TRUE
[13:19:22.428] - resignal: FALSE
[13:19:22.428] - force: TRUE
[13:19:22.428] - relayed: [n=2] FALSE, FALSE
[13:19:22.429] - queued futures: [n=2] FALSE, FALSE
[13:19:22.429]  - until=1
[13:19:22.429]  - relaying element #1
[13:19:22.429] - relayed: [n=2] FALSE, FALSE
[13:19:22.429] - queued futures: [n=2] FALSE, TRUE
[13:19:22.429] signalConditionsASAP(NULL, pos=2) ... done
[13:19:22.429]  length: 1 (resolved future 2)
[13:19:22.859] plan(): Setting new future strategy stack:
[13:19:22.859] List of future strategies:
[13:19:22.859] 1. multicore:
[13:19:22.859]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:19:22.859]    - tweaked: FALSE
[13:19:22.859]    - call: plan(strategy)
[13:19:22.864] plan(): nbrOfWorkers() = 2
[13:19:22.868] Future #1
[13:19:22.869] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:19:22.869] - nx: 2
[13:19:22.870] - relay: TRUE
[13:19:22.870] - stdout: TRUE
[13:19:22.870] - signal: TRUE
[13:19:22.870] - resignal: FALSE
[13:19:22.870] - force: TRUE
[13:19:22.870] - relayed: [n=2] FALSE, FALSE
[13:19:22.870] - queued futures: [n=2] FALSE, TRUE
[13:19:22.871]  - until=1
[13:19:22.871]  - relaying element #1
[13:19:22.871] - relayed: [n=2] TRUE, FALSE
[13:19:22.871] - queued futures: [n=2] TRUE, TRUE
[13:19:22.871] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:19:22.872]  length: 0 (resolved future 1)
[13:19:22.872] Relaying remaining futures
[13:19:22.872] signalConditionsASAP(NULL, pos=0) ...
[13:19:22.872] - nx: 2
[13:19:22.872] - relay: TRUE
[13:19:22.872] - stdout: TRUE
[13:19:22.873] - signal: TRUE
[13:19:22.873] - resignal: FALSE
[13:19:22.873] - force: TRUE
[13:19:22.873] - relayed: [n=2] TRUE, FALSE
[13:19:22.873] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:22.873]  - relaying element #2
[13:19:22.874] - relayed: [n=2] TRUE, TRUE
[13:19:22.874] - queued futures: [n=2] TRUE, TRUE
[13:19:22.874] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:19:22.874] resolve() on list ... DONE
[13:19:22.874]  - Number of value chunks collected: 2
[13:19:22.874] Resolving 2 futures (chunks) ... DONE
[13:19:22.875] Reducing values from 2 chunks ...
[13:19:22.875]  - Number of values collected after concatenation: 2
[13:19:22.875]  - Number of values expected: 2
[13:19:22.875] Reducing values from 2 chunks ... DONE
[13:19:22.875] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[13:19:22.876] plan(): Setting new future strategy stack:
[13:19:22.876] List of future strategies:
[13:19:22.876] 1. multisession:
[13:19:22.876]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:22.876]    - tweaked: FALSE
[13:19:22.876]    - call: plan(strategy)
[13:19:22.876] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:19:22.876] multisession:
[13:19:22.876] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:19:22.876] - tweaked: FALSE
[13:19:22.876] - call: plan(strategy)
[13:19:22.886] getGlobalsAndPackages() ...
[13:19:22.886] Not searching for globals
[13:19:22.887] - globals: [0] <none>
[13:19:22.887] getGlobalsAndPackages() ... DONE
[13:19:22.887] [local output] makeClusterPSOCK() ...
[13:19:22.929] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:19:22.935] [local output] Base port: 11184
[13:19:22.935] [local output] Getting setup options for 2 cluster nodes ...
[13:19:22.935] [local output]  - Node 1 of 2 ...
[13:19:22.936] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:22.937] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTU0vAz/worker.rank=1.parallelly.parent=80060.138bc5cd716d0.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpTU0vAz/worker.rank=1.parallelly.parent=80060.138bc5cd716d0.pid")'’
[13:19:23.127] - Possible to infer worker's PID: TRUE
[13:19:23.128] [local output] Rscript port: 11184

[13:19:23.128] [local output]  - Node 2 of 2 ...
[13:19:23.128] [local output] localMachine=TRUE => revtunnel=FALSE

[13:19:23.129] [local output] Rscript port: 11184

[13:19:23.129] [local output] Getting setup options for 2 cluster nodes ... done
[13:19:23.130] [local output]  - Parallel setup requested for some PSOCK nodes
[13:19:23.130] [local output] Setting up PSOCK nodes in parallel
[13:19:23.130] List of 36
[13:19:23.130]  $ worker          : chr "localhost"
[13:19:23.130]   ..- attr(*, "localhost")= logi TRUE
[13:19:23.130]  $ master          : chr "localhost"
[13:19:23.130]  $ port            : int 11184
[13:19:23.130]  $ connectTimeout  : num 120
[13:19:23.130]  $ timeout         : num 2592000
[13:19:23.130]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:19:23.130]  $ homogeneous     : logi TRUE
[13:19:23.130]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:19:23.130]  $ rscript_envs    : NULL
[13:19:23.130]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:23.130]  $ rscript_startup : NULL
[13:19:23.130]  $ rscript_sh      : chr "sh"
[13:19:23.130]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:23.130]  $ methods         : logi TRUE
[13:19:23.130]  $ socketOptions   : chr "no-delay"
[13:19:23.130]  $ useXDR          : logi FALSE
[13:19:23.130]  $ outfile         : chr "/dev/null"
[13:19:23.130]  $ renice          : int NA
[13:19:23.130]  $ rshcmd          : NULL
[13:19:23.130]  $ user            : chr(0) 
[13:19:23.130]  $ revtunnel       : logi FALSE
[13:19:23.130]  $ rshlogfile      : NULL
[13:19:23.130]  $ rshopts         : chr(0) 
[13:19:23.130]  $ rank            : int 1
[13:19:23.130]  $ manual          : logi FALSE
[13:19:23.130]  $ dryrun          : logi FALSE
[13:19:23.130]  $ quiet           : logi FALSE
[13:19:23.130]  $ setup_strategy  : chr "parallel"
[13:19:23.130]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:23.130]  $ pidfile         : chr "/tmp/RtmpTU0vAz/worker.rank=1.parallelly.parent=80060.138bc5cd716d0.pid"
[13:19:23.130]  $ rshcmd_label    : NULL
[13:19:23.130]  $ rsh_call        : NULL
[13:19:23.130]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:19:23.130]  $ localMachine    : logi TRUE
[13:19:23.130]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:19:23.130]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:19:23.130]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:19:23.130]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:19:23.130]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:19:23.130]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:19:23.130]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:19:23.130]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:19:23.130]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:19:23.130]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:19:23.130]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:19:23.130]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:19:23.130]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:19:23.130]  $ arguments       :List of 28
[13:19:23.130]   ..$ worker          : chr "localhost"
[13:19:23.130]   ..$ master          : NULL
[13:19:23.130]   ..$ port            : int 11184
[13:19:23.130]   ..$ connectTimeout  : num 120
[13:19:23.130]   ..$ timeout         : num 2592000
[13:19:23.130]   ..$ rscript         : NULL
[13:19:23.130]   ..$ homogeneous     : NULL
[13:19:23.130]   ..$ rscript_args    : NULL
[13:19:23.130]   ..$ rscript_envs    : NULL
[13:19:23.130]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:19:23.130]   ..$ rscript_startup : NULL
[13:19:23.130]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:19:23.130]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:19:23.130]   ..$ methods         : logi TRUE
[13:19:23.130]   ..$ socketOptions   : chr "no-delay"
[13:19:23.130]   ..$ useXDR          : logi FALSE
[13:19:23.130]   ..$ outfile         : chr "/dev/null"
[13:19:23.130]   ..$ renice          : int NA
[13:19:23.130]   ..$ rshcmd          : NULL
[13:19:23.130]   ..$ user            : NULL
[13:19:23.130]   ..$ revtunnel       : logi NA
[13:19:23.130]   ..$ rshlogfile      : NULL
[13:19:23.130]   ..$ rshopts         : NULL
[13:19:23.130]   ..$ rank            : int 1
[13:19:23.130]   ..$ manual          : logi FALSE
[13:19:23.130]   ..$ dryrun          : logi FALSE
[13:19:23.130]   ..$ quiet           : logi FALSE
[13:19:23.130]   ..$ setup_strategy  : chr "parallel"
[13:19:23.130]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:19:23.147] [local output] System call to launch all workers:
[13:19:23.147] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTU0vAz/worker.rank=1.parallelly.parent=80060.138bc5cd716d0.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11184 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:19:23.147] [local output] Starting PSOCK main server
[13:19:23.149] [local output] Workers launched
[13:19:23.149] [local output] Waiting for workers to connect back
[13:19:23.149]  - [local output] 0 workers out of 2 ready
[13:19:23.398]  - [local output] 0 workers out of 2 ready
[13:19:23.399]  - [local output] 0 workers out of 2 ready
[13:19:23.399]  - [local output] 1 workers out of 2 ready
[13:19:23.399]  - [local output] 2 workers out of 2 ready
[13:19:23.399] [local output] Launching of workers completed
[13:19:23.399] [local output] Collecting session information from workers
[13:19:23.400] [local output]  - Worker #1 of 2
[13:19:23.401] [local output]  - Worker #2 of 2
[13:19:23.401] [local output] makeClusterPSOCK() ... done
[13:19:23.414] Packages needed by the future expression (n = 0): <none>
[13:19:23.414] Packages needed by future strategies (n = 0): <none>
[13:19:23.415] {
[13:19:23.415]     {
[13:19:23.415]         {
[13:19:23.415]             ...future.startTime <- base::Sys.time()
[13:19:23.415]             {
[13:19:23.415]                 {
[13:19:23.415]                   {
[13:19:23.415]                     {
[13:19:23.415]                       base::local({
[13:19:23.415]                         has_future <- base::requireNamespace("future", 
[13:19:23.415]                           quietly = TRUE)
[13:19:23.415]                         if (has_future) {
[13:19:23.415]                           ns <- base::getNamespace("future")
[13:19:23.415]                           version <- ns[[".package"]][["version"]]
[13:19:23.415]                           if (is.null(version)) 
[13:19:23.415]                             version <- utils::packageVersion("future")
[13:19:23.415]                         }
[13:19:23.415]                         else {
[13:19:23.415]                           version <- NULL
[13:19:23.415]                         }
[13:19:23.415]                         if (!has_future || version < "1.8.0") {
[13:19:23.415]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:23.415]                             "", base::R.version$version.string), 
[13:19:23.415]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:23.415]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:23.415]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:23.415]                               "release", "version")], collapse = " "), 
[13:19:23.415]                             hostname = base::Sys.info()[["nodename"]])
[13:19:23.415]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:23.415]                             info)
[13:19:23.415]                           info <- base::paste(info, collapse = "; ")
[13:19:23.415]                           if (!has_future) {
[13:19:23.415]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:23.415]                               info)
[13:19:23.415]                           }
[13:19:23.415]                           else {
[13:19:23.415]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:23.415]                               info, version)
[13:19:23.415]                           }
[13:19:23.415]                           base::stop(msg)
[13:19:23.415]                         }
[13:19:23.415]                       })
[13:19:23.415]                     }
[13:19:23.415]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:23.415]                     base::options(mc.cores = 1L)
[13:19:23.415]                   }
[13:19:23.415]                   options(future.plan = NULL)
[13:19:23.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:23.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:23.415]                 }
[13:19:23.415]                 ...future.workdir <- getwd()
[13:19:23.415]             }
[13:19:23.415]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:23.415]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:23.415]         }
[13:19:23.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:23.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:23.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:23.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:23.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:23.415]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:23.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:23.415]             base::names(...future.oldOptions))
[13:19:23.415]     }
[13:19:23.415]     if (FALSE) {
[13:19:23.415]     }
[13:19:23.415]     else {
[13:19:23.415]         if (TRUE) {
[13:19:23.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:23.415]                 open = "w")
[13:19:23.415]         }
[13:19:23.415]         else {
[13:19:23.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:23.415]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:23.415]         }
[13:19:23.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:23.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:23.415]             base::sink(type = "output", split = FALSE)
[13:19:23.415]             base::close(...future.stdout)
[13:19:23.415]         }, add = TRUE)
[13:19:23.415]     }
[13:19:23.415]     ...future.frame <- base::sys.nframe()
[13:19:23.415]     ...future.conditions <- base::list()
[13:19:23.415]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:23.415]     if (FALSE) {
[13:19:23.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:23.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:23.415]     }
[13:19:23.415]     ...future.result <- base::tryCatch({
[13:19:23.415]         base::withCallingHandlers({
[13:19:23.415]             ...future.value <- base::withVisible(base::local({
[13:19:23.415]                 ...future.makeSendCondition <- local({
[13:19:23.415]                   sendCondition <- NULL
[13:19:23.415]                   function(frame = 1L) {
[13:19:23.415]                     if (is.function(sendCondition)) 
[13:19:23.415]                       return(sendCondition)
[13:19:23.415]                     ns <- getNamespace("parallel")
[13:19:23.415]                     if (exists("sendData", mode = "function", 
[13:19:23.415]                       envir = ns)) {
[13:19:23.415]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:23.415]                         envir = ns)
[13:19:23.415]                       envir <- sys.frame(frame)
[13:19:23.415]                       master <- NULL
[13:19:23.415]                       while (!identical(envir, .GlobalEnv) && 
[13:19:23.415]                         !identical(envir, emptyenv())) {
[13:19:23.415]                         if (exists("master", mode = "list", envir = envir, 
[13:19:23.415]                           inherits = FALSE)) {
[13:19:23.415]                           master <- get("master", mode = "list", 
[13:19:23.415]                             envir = envir, inherits = FALSE)
[13:19:23.415]                           if (inherits(master, c("SOCKnode", 
[13:19:23.415]                             "SOCK0node"))) {
[13:19:23.415]                             sendCondition <<- function(cond) {
[13:19:23.415]                               data <- list(type = "VALUE", value = cond, 
[13:19:23.415]                                 success = TRUE)
[13:19:23.415]                               parallel_sendData(master, data)
[13:19:23.415]                             }
[13:19:23.415]                             return(sendCondition)
[13:19:23.415]                           }
[13:19:23.415]                         }
[13:19:23.415]                         frame <- frame + 1L
[13:19:23.415]                         envir <- sys.frame(frame)
[13:19:23.415]                       }
[13:19:23.415]                     }
[13:19:23.415]                     sendCondition <<- function(cond) NULL
[13:19:23.415]                   }
[13:19:23.415]                 })
[13:19:23.415]                 withCallingHandlers({
[13:19:23.415]                   NA
[13:19:23.415]                 }, immediateCondition = function(cond) {
[13:19:23.415]                   sendCondition <- ...future.makeSendCondition()
[13:19:23.415]                   sendCondition(cond)
[13:19:23.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.415]                   {
[13:19:23.415]                     inherits <- base::inherits
[13:19:23.415]                     invokeRestart <- base::invokeRestart
[13:19:23.415]                     is.null <- base::is.null
[13:19:23.415]                     muffled <- FALSE
[13:19:23.415]                     if (inherits(cond, "message")) {
[13:19:23.415]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:23.415]                       if (muffled) 
[13:19:23.415]                         invokeRestart("muffleMessage")
[13:19:23.415]                     }
[13:19:23.415]                     else if (inherits(cond, "warning")) {
[13:19:23.415]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:23.415]                       if (muffled) 
[13:19:23.415]                         invokeRestart("muffleWarning")
[13:19:23.415]                     }
[13:19:23.415]                     else if (inherits(cond, "condition")) {
[13:19:23.415]                       if (!is.null(pattern)) {
[13:19:23.415]                         computeRestarts <- base::computeRestarts
[13:19:23.415]                         grepl <- base::grepl
[13:19:23.415]                         restarts <- computeRestarts(cond)
[13:19:23.415]                         for (restart in restarts) {
[13:19:23.415]                           name <- restart$name
[13:19:23.415]                           if (is.null(name)) 
[13:19:23.415]                             next
[13:19:23.415]                           if (!grepl(pattern, name)) 
[13:19:23.415]                             next
[13:19:23.415]                           invokeRestart(restart)
[13:19:23.415]                           muffled <- TRUE
[13:19:23.415]                           break
[13:19:23.415]                         }
[13:19:23.415]                       }
[13:19:23.415]                     }
[13:19:23.415]                     invisible(muffled)
[13:19:23.415]                   }
[13:19:23.415]                   muffleCondition(cond)
[13:19:23.415]                 })
[13:19:23.415]             }))
[13:19:23.415]             future::FutureResult(value = ...future.value$value, 
[13:19:23.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:23.415]                   ...future.rng), globalenv = if (FALSE) 
[13:19:23.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:23.415]                     ...future.globalenv.names))
[13:19:23.415]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:23.415]         }, condition = base::local({
[13:19:23.415]             c <- base::c
[13:19:23.415]             inherits <- base::inherits
[13:19:23.415]             invokeRestart <- base::invokeRestart
[13:19:23.415]             length <- base::length
[13:19:23.415]             list <- base::list
[13:19:23.415]             seq.int <- base::seq.int
[13:19:23.415]             signalCondition <- base::signalCondition
[13:19:23.415]             sys.calls <- base::sys.calls
[13:19:23.415]             `[[` <- base::`[[`
[13:19:23.415]             `+` <- base::`+`
[13:19:23.415]             `<<-` <- base::`<<-`
[13:19:23.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:23.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:23.415]                   3L)]
[13:19:23.415]             }
[13:19:23.415]             function(cond) {
[13:19:23.415]                 is_error <- inherits(cond, "error")
[13:19:23.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:23.415]                   NULL)
[13:19:23.415]                 if (is_error) {
[13:19:23.415]                   sessionInformation <- function() {
[13:19:23.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:23.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:23.415]                       search = base::search(), system = base::Sys.info())
[13:19:23.415]                   }
[13:19:23.415]                   ...future.conditions[[length(...future.conditions) + 
[13:19:23.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:23.415]                     cond$call), session = sessionInformation(), 
[13:19:23.415]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:23.415]                   signalCondition(cond)
[13:19:23.415]                 }
[13:19:23.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:23.415]                 "immediateCondition"))) {
[13:19:23.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:23.415]                   ...future.conditions[[length(...future.conditions) + 
[13:19:23.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:23.415]                   if (TRUE && !signal) {
[13:19:23.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.415]                     {
[13:19:23.415]                       inherits <- base::inherits
[13:19:23.415]                       invokeRestart <- base::invokeRestart
[13:19:23.415]                       is.null <- base::is.null
[13:19:23.415]                       muffled <- FALSE
[13:19:23.415]                       if (inherits(cond, "message")) {
[13:19:23.415]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:23.415]                         if (muffled) 
[13:19:23.415]                           invokeRestart("muffleMessage")
[13:19:23.415]                       }
[13:19:23.415]                       else if (inherits(cond, "warning")) {
[13:19:23.415]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:23.415]                         if (muffled) 
[13:19:23.415]                           invokeRestart("muffleWarning")
[13:19:23.415]                       }
[13:19:23.415]                       else if (inherits(cond, "condition")) {
[13:19:23.415]                         if (!is.null(pattern)) {
[13:19:23.415]                           computeRestarts <- base::computeRestarts
[13:19:23.415]                           grepl <- base::grepl
[13:19:23.415]                           restarts <- computeRestarts(cond)
[13:19:23.415]                           for (restart in restarts) {
[13:19:23.415]                             name <- restart$name
[13:19:23.415]                             if (is.null(name)) 
[13:19:23.415]                               next
[13:19:23.415]                             if (!grepl(pattern, name)) 
[13:19:23.415]                               next
[13:19:23.415]                             invokeRestart(restart)
[13:19:23.415]                             muffled <- TRUE
[13:19:23.415]                             break
[13:19:23.415]                           }
[13:19:23.415]                         }
[13:19:23.415]                       }
[13:19:23.415]                       invisible(muffled)
[13:19:23.415]                     }
[13:19:23.415]                     muffleCondition(cond, pattern = "^muffle")
[13:19:23.415]                   }
[13:19:23.415]                 }
[13:19:23.415]                 else {
[13:19:23.415]                   if (TRUE) {
[13:19:23.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.415]                     {
[13:19:23.415]                       inherits <- base::inherits
[13:19:23.415]                       invokeRestart <- base::invokeRestart
[13:19:23.415]                       is.null <- base::is.null
[13:19:23.415]                       muffled <- FALSE
[13:19:23.415]                       if (inherits(cond, "message")) {
[13:19:23.415]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:23.415]                         if (muffled) 
[13:19:23.415]                           invokeRestart("muffleMessage")
[13:19:23.415]                       }
[13:19:23.415]                       else if (inherits(cond, "warning")) {
[13:19:23.415]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:23.415]                         if (muffled) 
[13:19:23.415]                           invokeRestart("muffleWarning")
[13:19:23.415]                       }
[13:19:23.415]                       else if (inherits(cond, "condition")) {
[13:19:23.415]                         if (!is.null(pattern)) {
[13:19:23.415]                           computeRestarts <- base::computeRestarts
[13:19:23.415]                           grepl <- base::grepl
[13:19:23.415]                           restarts <- computeRestarts(cond)
[13:19:23.415]                           for (restart in restarts) {
[13:19:23.415]                             name <- restart$name
[13:19:23.415]                             if (is.null(name)) 
[13:19:23.415]                               next
[13:19:23.415]                             if (!grepl(pattern, name)) 
[13:19:23.415]                               next
[13:19:23.415]                             invokeRestart(restart)
[13:19:23.415]                             muffled <- TRUE
[13:19:23.415]                             break
[13:19:23.415]                           }
[13:19:23.415]                         }
[13:19:23.415]                       }
[13:19:23.415]                       invisible(muffled)
[13:19:23.415]                     }
[13:19:23.415]                     muffleCondition(cond, pattern = "^muffle")
[13:19:23.415]                   }
[13:19:23.415]                 }
[13:19:23.415]             }
[13:19:23.415]         }))
[13:19:23.415]     }, error = function(ex) {
[13:19:23.415]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:23.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:23.415]                 ...future.rng), started = ...future.startTime, 
[13:19:23.415]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:23.415]             version = "1.8"), class = "FutureResult")
[13:19:23.415]     }, finally = {
[13:19:23.415]         if (!identical(...future.workdir, getwd())) 
[13:19:23.415]             setwd(...future.workdir)
[13:19:23.415]         {
[13:19:23.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:23.415]                 ...future.oldOptions$nwarnings <- NULL
[13:19:23.415]             }
[13:19:23.415]             base::options(...future.oldOptions)
[13:19:23.415]             if (.Platform$OS.type == "windows") {
[13:19:23.415]                 old_names <- names(...future.oldEnvVars)
[13:19:23.415]                 envs <- base::Sys.getenv()
[13:19:23.415]                 names <- names(envs)
[13:19:23.415]                 common <- intersect(names, old_names)
[13:19:23.415]                 added <- setdiff(names, old_names)
[13:19:23.415]                 removed <- setdiff(old_names, names)
[13:19:23.415]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:23.415]                   envs[common]]
[13:19:23.415]                 NAMES <- toupper(changed)
[13:19:23.415]                 args <- list()
[13:19:23.415]                 for (kk in seq_along(NAMES)) {
[13:19:23.415]                   name <- changed[[kk]]
[13:19:23.415]                   NAME <- NAMES[[kk]]
[13:19:23.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.415]                     next
[13:19:23.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:23.415]                 }
[13:19:23.415]                 NAMES <- toupper(added)
[13:19:23.415]                 for (kk in seq_along(NAMES)) {
[13:19:23.415]                   name <- added[[kk]]
[13:19:23.415]                   NAME <- NAMES[[kk]]
[13:19:23.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.415]                     next
[13:19:23.415]                   args[[name]] <- ""
[13:19:23.415]                 }
[13:19:23.415]                 NAMES <- toupper(removed)
[13:19:23.415]                 for (kk in seq_along(NAMES)) {
[13:19:23.415]                   name <- removed[[kk]]
[13:19:23.415]                   NAME <- NAMES[[kk]]
[13:19:23.415]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.415]                     next
[13:19:23.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:23.415]                 }
[13:19:23.415]                 if (length(args) > 0) 
[13:19:23.415]                   base::do.call(base::Sys.setenv, args = args)
[13:19:23.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:23.415]             }
[13:19:23.415]             else {
[13:19:23.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:23.415]             }
[13:19:23.415]             {
[13:19:23.415]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:23.415]                   0L) {
[13:19:23.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:23.415]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:23.415]                   base::options(opts)
[13:19:23.415]                 }
[13:19:23.415]                 {
[13:19:23.415]                   {
[13:19:23.415]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:23.415]                     NULL
[13:19:23.415]                   }
[13:19:23.415]                   options(future.plan = NULL)
[13:19:23.415]                   if (is.na(NA_character_)) 
[13:19:23.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:23.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:23.415]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:23.415]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:23.415]                     envir = parent.frame()) 
[13:19:23.415]                   {
[13:19:23.415]                     if (is.function(workers)) 
[13:19:23.415]                       workers <- workers()
[13:19:23.415]                     workers <- structure(as.integer(workers), 
[13:19:23.415]                       class = class(workers))
[13:19:23.415]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:23.415]                       workers >= 1)
[13:19:23.415]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:23.415]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:23.415]                     }
[13:19:23.415]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:23.415]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:23.415]                       envir = envir)
[13:19:23.415]                     if (!future$lazy) 
[13:19:23.415]                       future <- run(future)
[13:19:23.415]                     invisible(future)
[13:19:23.415]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:23.415]                 }
[13:19:23.415]             }
[13:19:23.415]         }
[13:19:23.415]     })
[13:19:23.415]     if (TRUE) {
[13:19:23.415]         base::sink(type = "output", split = FALSE)
[13:19:23.415]         if (TRUE) {
[13:19:23.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:23.415]         }
[13:19:23.415]         else {
[13:19:23.415]             ...future.result["stdout"] <- base::list(NULL)
[13:19:23.415]         }
[13:19:23.415]         base::close(...future.stdout)
[13:19:23.415]         ...future.stdout <- NULL
[13:19:23.415]     }
[13:19:23.415]     ...future.result$conditions <- ...future.conditions
[13:19:23.415]     ...future.result$finished <- base::Sys.time()
[13:19:23.415]     ...future.result
[13:19:23.415] }
[13:19:23.489] MultisessionFuture started
[13:19:23.489] result() for ClusterFuture ...
[13:19:23.490] receiveMessageFromWorker() for ClusterFuture ...
[13:19:23.490] - Validating connection of MultisessionFuture
[13:19:23.523] - received message: FutureResult
[13:19:23.523] - Received FutureResult
[13:19:23.523] - Erased future from FutureRegistry
[13:19:23.524] result() for ClusterFuture ...
[13:19:23.524] - result already collected: FutureResult
[13:19:23.524] result() for ClusterFuture ... done
[13:19:23.524] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:23.524] result() for ClusterFuture ... done
[13:19:23.524] result() for ClusterFuture ...
[13:19:23.524] - result already collected: FutureResult
[13:19:23.524] result() for ClusterFuture ... done
[13:19:23.525] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:19:23.528] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:19:23.529] future_lapply() ...
[13:19:23.533] Number of chunks: 2
[13:19:23.533] getGlobalsAndPackagesXApply() ...
[13:19:23.533]  - future.globals: TRUE
[13:19:23.533] getGlobalsAndPackages() ...
[13:19:23.533] Searching for globals...
[13:19:23.535] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:23.535] Searching for globals ... DONE
[13:19:23.536] Resolving globals: FALSE
[13:19:23.536] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:23.536] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:23.537] - globals: [1] ‘FUN’
[13:19:23.537] 
[13:19:23.537] getGlobalsAndPackages() ... DONE
[13:19:23.537]  - globals found/used: [n=1] ‘FUN’
[13:19:23.537]  - needed namespaces: [n=0] 
[13:19:23.537] Finding globals ... DONE
[13:19:23.537]  - use_args: TRUE
[13:19:23.538]  - Getting '...' globals ...
[13:19:23.538] resolve() on list ...
[13:19:23.538]  recursive: 0
[13:19:23.538]  length: 1
[13:19:23.538]  elements: ‘...’
[13:19:23.538]  length: 0 (resolved future 1)
[13:19:23.539] resolve() on list ... DONE
[13:19:23.539]    - '...' content: [n=0] 
[13:19:23.539] List of 1
[13:19:23.539]  $ ...: list()
[13:19:23.539]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:23.539]  - attr(*, "where")=List of 1
[13:19:23.539]   ..$ ...:<environment: 0x5620071591f8> 
[13:19:23.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:23.539]  - attr(*, "resolved")= logi TRUE
[13:19:23.539]  - attr(*, "total_size")= num NA
[13:19:23.542]  - Getting '...' globals ... DONE
[13:19:23.542] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:23.542] List of 2
[13:19:23.542]  $ ...future.FUN:function (x)  
[13:19:23.542]  $ ...          : list()
[13:19:23.542]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:23.542]  - attr(*, "where")=List of 2
[13:19:23.542]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:23.542]   ..$ ...          :<environment: 0x5620071591f8> 
[13:19:23.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:23.542]  - attr(*, "resolved")= logi FALSE
[13:19:23.542]  - attr(*, "total_size")= num 4720
[13:19:23.546] Packages to be attached in all futures: [n=0] 
[13:19:23.546] getGlobalsAndPackagesXApply() ... DONE
[13:19:23.546] Number of futures (= number of chunks): 2
[13:19:23.546] Launching 2 futures (chunks) ...
[13:19:23.546] Chunk #1 of 2 ...
[13:19:23.547]  - Finding globals in 'X' for chunk #1 ...
[13:19:23.547] getGlobalsAndPackages() ...
[13:19:23.547] Searching for globals...
[13:19:23.547] 
[13:19:23.547] Searching for globals ... DONE
[13:19:23.547] - globals: [0] <none>
[13:19:23.547] getGlobalsAndPackages() ... DONE
[13:19:23.548]    + additional globals found: [n=0] 
[13:19:23.548]    + additional namespaces needed: [n=0] 
[13:19:23.548]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:23.548]  - seeds: <none>
[13:19:23.548] getGlobalsAndPackages() ...
[13:19:23.548] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:23.548] Resolving globals: FALSE
[13:19:23.548] Tweak future expression to call with '...' arguments ...
[13:19:23.549] {
[13:19:23.549]     do.call(function(...) {
[13:19:23.549]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:23.549]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:23.549]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:23.549]             on.exit(options(oopts), add = TRUE)
[13:19:23.549]         }
[13:19:23.549]         {
[13:19:23.549]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:23.549]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:23.549]                 ...future.FUN(...future.X_jj, ...)
[13:19:23.549]             })
[13:19:23.549]         }
[13:19:23.549]     }, args = future.call.arguments)
[13:19:23.549] }
[13:19:23.549] Tweak future expression to call with '...' arguments ... DONE
[13:19:23.549] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:23.549] 
[13:19:23.550] getGlobalsAndPackages() ... DONE
[13:19:23.550] run() for ‘Future’ ...
[13:19:23.550] - state: ‘created’
[13:19:23.550] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:23.567] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:23.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:23.567]   - Field: ‘node’
[13:19:23.567]   - Field: ‘label’
[13:19:23.567]   - Field: ‘local’
[13:19:23.567]   - Field: ‘owner’
[13:19:23.567]   - Field: ‘envir’
[13:19:23.567]   - Field: ‘workers’
[13:19:23.568]   - Field: ‘packages’
[13:19:23.568]   - Field: ‘gc’
[13:19:23.568]   - Field: ‘conditions’
[13:19:23.568]   - Field: ‘persistent’
[13:19:23.568]   - Field: ‘expr’
[13:19:23.568]   - Field: ‘uuid’
[13:19:23.568]   - Field: ‘seed’
[13:19:23.568]   - Field: ‘version’
[13:19:23.568]   - Field: ‘result’
[13:19:23.569]   - Field: ‘asynchronous’
[13:19:23.569]   - Field: ‘calls’
[13:19:23.569]   - Field: ‘globals’
[13:19:23.569]   - Field: ‘stdout’
[13:19:23.569]   - Field: ‘earlySignal’
[13:19:23.569]   - Field: ‘lazy’
[13:19:23.569]   - Field: ‘state’
[13:19:23.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:23.570] - Launch lazy future ...
[13:19:23.570] Packages needed by the future expression (n = 0): <none>
[13:19:23.570] Packages needed by future strategies (n = 0): <none>
[13:19:23.571] {
[13:19:23.571]     {
[13:19:23.571]         {
[13:19:23.571]             ...future.startTime <- base::Sys.time()
[13:19:23.571]             {
[13:19:23.571]                 {
[13:19:23.571]                   {
[13:19:23.571]                     {
[13:19:23.571]                       base::local({
[13:19:23.571]                         has_future <- base::requireNamespace("future", 
[13:19:23.571]                           quietly = TRUE)
[13:19:23.571]                         if (has_future) {
[13:19:23.571]                           ns <- base::getNamespace("future")
[13:19:23.571]                           version <- ns[[".package"]][["version"]]
[13:19:23.571]                           if (is.null(version)) 
[13:19:23.571]                             version <- utils::packageVersion("future")
[13:19:23.571]                         }
[13:19:23.571]                         else {
[13:19:23.571]                           version <- NULL
[13:19:23.571]                         }
[13:19:23.571]                         if (!has_future || version < "1.8.0") {
[13:19:23.571]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:23.571]                             "", base::R.version$version.string), 
[13:19:23.571]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:23.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:23.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:23.571]                               "release", "version")], collapse = " "), 
[13:19:23.571]                             hostname = base::Sys.info()[["nodename"]])
[13:19:23.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:23.571]                             info)
[13:19:23.571]                           info <- base::paste(info, collapse = "; ")
[13:19:23.571]                           if (!has_future) {
[13:19:23.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:23.571]                               info)
[13:19:23.571]                           }
[13:19:23.571]                           else {
[13:19:23.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:23.571]                               info, version)
[13:19:23.571]                           }
[13:19:23.571]                           base::stop(msg)
[13:19:23.571]                         }
[13:19:23.571]                       })
[13:19:23.571]                     }
[13:19:23.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:23.571]                     base::options(mc.cores = 1L)
[13:19:23.571]                   }
[13:19:23.571]                   options(future.plan = NULL)
[13:19:23.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:23.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:23.571]                 }
[13:19:23.571]                 ...future.workdir <- getwd()
[13:19:23.571]             }
[13:19:23.571]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:23.571]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:23.571]         }
[13:19:23.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:23.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:23.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:23.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:23.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:23.571]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:23.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:23.571]             base::names(...future.oldOptions))
[13:19:23.571]     }
[13:19:23.571]     if (FALSE) {
[13:19:23.571]     }
[13:19:23.571]     else {
[13:19:23.571]         if (FALSE) {
[13:19:23.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:23.571]                 open = "w")
[13:19:23.571]         }
[13:19:23.571]         else {
[13:19:23.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:23.571]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:23.571]         }
[13:19:23.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:23.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:23.571]             base::sink(type = "output", split = FALSE)
[13:19:23.571]             base::close(...future.stdout)
[13:19:23.571]         }, add = TRUE)
[13:19:23.571]     }
[13:19:23.571]     ...future.frame <- base::sys.nframe()
[13:19:23.571]     ...future.conditions <- base::list()
[13:19:23.571]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:23.571]     if (FALSE) {
[13:19:23.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:23.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:23.571]     }
[13:19:23.571]     ...future.result <- base::tryCatch({
[13:19:23.571]         base::withCallingHandlers({
[13:19:23.571]             ...future.value <- base::withVisible(base::local({
[13:19:23.571]                 ...future.makeSendCondition <- local({
[13:19:23.571]                   sendCondition <- NULL
[13:19:23.571]                   function(frame = 1L) {
[13:19:23.571]                     if (is.function(sendCondition)) 
[13:19:23.571]                       return(sendCondition)
[13:19:23.571]                     ns <- getNamespace("parallel")
[13:19:23.571]                     if (exists("sendData", mode = "function", 
[13:19:23.571]                       envir = ns)) {
[13:19:23.571]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:23.571]                         envir = ns)
[13:19:23.571]                       envir <- sys.frame(frame)
[13:19:23.571]                       master <- NULL
[13:19:23.571]                       while (!identical(envir, .GlobalEnv) && 
[13:19:23.571]                         !identical(envir, emptyenv())) {
[13:19:23.571]                         if (exists("master", mode = "list", envir = envir, 
[13:19:23.571]                           inherits = FALSE)) {
[13:19:23.571]                           master <- get("master", mode = "list", 
[13:19:23.571]                             envir = envir, inherits = FALSE)
[13:19:23.571]                           if (inherits(master, c("SOCKnode", 
[13:19:23.571]                             "SOCK0node"))) {
[13:19:23.571]                             sendCondition <<- function(cond) {
[13:19:23.571]                               data <- list(type = "VALUE", value = cond, 
[13:19:23.571]                                 success = TRUE)
[13:19:23.571]                               parallel_sendData(master, data)
[13:19:23.571]                             }
[13:19:23.571]                             return(sendCondition)
[13:19:23.571]                           }
[13:19:23.571]                         }
[13:19:23.571]                         frame <- frame + 1L
[13:19:23.571]                         envir <- sys.frame(frame)
[13:19:23.571]                       }
[13:19:23.571]                     }
[13:19:23.571]                     sendCondition <<- function(cond) NULL
[13:19:23.571]                   }
[13:19:23.571]                 })
[13:19:23.571]                 withCallingHandlers({
[13:19:23.571]                   {
[13:19:23.571]                     do.call(function(...) {
[13:19:23.571]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:23.571]                       if (!identical(...future.globals.maxSize.org, 
[13:19:23.571]                         ...future.globals.maxSize)) {
[13:19:23.571]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:23.571]                         on.exit(options(oopts), add = TRUE)
[13:19:23.571]                       }
[13:19:23.571]                       {
[13:19:23.571]                         lapply(seq_along(...future.elements_ii), 
[13:19:23.571]                           FUN = function(jj) {
[13:19:23.571]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:23.571]                             ...future.FUN(...future.X_jj, ...)
[13:19:23.571]                           })
[13:19:23.571]                       }
[13:19:23.571]                     }, args = future.call.arguments)
[13:19:23.571]                   }
[13:19:23.571]                 }, immediateCondition = function(cond) {
[13:19:23.571]                   sendCondition <- ...future.makeSendCondition()
[13:19:23.571]                   sendCondition(cond)
[13:19:23.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.571]                   {
[13:19:23.571]                     inherits <- base::inherits
[13:19:23.571]                     invokeRestart <- base::invokeRestart
[13:19:23.571]                     is.null <- base::is.null
[13:19:23.571]                     muffled <- FALSE
[13:19:23.571]                     if (inherits(cond, "message")) {
[13:19:23.571]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:23.571]                       if (muffled) 
[13:19:23.571]                         invokeRestart("muffleMessage")
[13:19:23.571]                     }
[13:19:23.571]                     else if (inherits(cond, "warning")) {
[13:19:23.571]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:23.571]                       if (muffled) 
[13:19:23.571]                         invokeRestart("muffleWarning")
[13:19:23.571]                     }
[13:19:23.571]                     else if (inherits(cond, "condition")) {
[13:19:23.571]                       if (!is.null(pattern)) {
[13:19:23.571]                         computeRestarts <- base::computeRestarts
[13:19:23.571]                         grepl <- base::grepl
[13:19:23.571]                         restarts <- computeRestarts(cond)
[13:19:23.571]                         for (restart in restarts) {
[13:19:23.571]                           name <- restart$name
[13:19:23.571]                           if (is.null(name)) 
[13:19:23.571]                             next
[13:19:23.571]                           if (!grepl(pattern, name)) 
[13:19:23.571]                             next
[13:19:23.571]                           invokeRestart(restart)
[13:19:23.571]                           muffled <- TRUE
[13:19:23.571]                           break
[13:19:23.571]                         }
[13:19:23.571]                       }
[13:19:23.571]                     }
[13:19:23.571]                     invisible(muffled)
[13:19:23.571]                   }
[13:19:23.571]                   muffleCondition(cond)
[13:19:23.571]                 })
[13:19:23.571]             }))
[13:19:23.571]             future::FutureResult(value = ...future.value$value, 
[13:19:23.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:23.571]                   ...future.rng), globalenv = if (FALSE) 
[13:19:23.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:23.571]                     ...future.globalenv.names))
[13:19:23.571]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:23.571]         }, condition = base::local({
[13:19:23.571]             c <- base::c
[13:19:23.571]             inherits <- base::inherits
[13:19:23.571]             invokeRestart <- base::invokeRestart
[13:19:23.571]             length <- base::length
[13:19:23.571]             list <- base::list
[13:19:23.571]             seq.int <- base::seq.int
[13:19:23.571]             signalCondition <- base::signalCondition
[13:19:23.571]             sys.calls <- base::sys.calls
[13:19:23.571]             `[[` <- base::`[[`
[13:19:23.571]             `+` <- base::`+`
[13:19:23.571]             `<<-` <- base::`<<-`
[13:19:23.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:23.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:23.571]                   3L)]
[13:19:23.571]             }
[13:19:23.571]             function(cond) {
[13:19:23.571]                 is_error <- inherits(cond, "error")
[13:19:23.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:23.571]                   NULL)
[13:19:23.571]                 if (is_error) {
[13:19:23.571]                   sessionInformation <- function() {
[13:19:23.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:23.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:23.571]                       search = base::search(), system = base::Sys.info())
[13:19:23.571]                   }
[13:19:23.571]                   ...future.conditions[[length(...future.conditions) + 
[13:19:23.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:23.571]                     cond$call), session = sessionInformation(), 
[13:19:23.571]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:23.571]                   signalCondition(cond)
[13:19:23.571]                 }
[13:19:23.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:23.571]                 "immediateCondition"))) {
[13:19:23.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:23.571]                   ...future.conditions[[length(...future.conditions) + 
[13:19:23.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:23.571]                   if (TRUE && !signal) {
[13:19:23.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.571]                     {
[13:19:23.571]                       inherits <- base::inherits
[13:19:23.571]                       invokeRestart <- base::invokeRestart
[13:19:23.571]                       is.null <- base::is.null
[13:19:23.571]                       muffled <- FALSE
[13:19:23.571]                       if (inherits(cond, "message")) {
[13:19:23.571]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:23.571]                         if (muffled) 
[13:19:23.571]                           invokeRestart("muffleMessage")
[13:19:23.571]                       }
[13:19:23.571]                       else if (inherits(cond, "warning")) {
[13:19:23.571]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:23.571]                         if (muffled) 
[13:19:23.571]                           invokeRestart("muffleWarning")
[13:19:23.571]                       }
[13:19:23.571]                       else if (inherits(cond, "condition")) {
[13:19:23.571]                         if (!is.null(pattern)) {
[13:19:23.571]                           computeRestarts <- base::computeRestarts
[13:19:23.571]                           grepl <- base::grepl
[13:19:23.571]                           restarts <- computeRestarts(cond)
[13:19:23.571]                           for (restart in restarts) {
[13:19:23.571]                             name <- restart$name
[13:19:23.571]                             if (is.null(name)) 
[13:19:23.571]                               next
[13:19:23.571]                             if (!grepl(pattern, name)) 
[13:19:23.571]                               next
[13:19:23.571]                             invokeRestart(restart)
[13:19:23.571]                             muffled <- TRUE
[13:19:23.571]                             break
[13:19:23.571]                           }
[13:19:23.571]                         }
[13:19:23.571]                       }
[13:19:23.571]                       invisible(muffled)
[13:19:23.571]                     }
[13:19:23.571]                     muffleCondition(cond, pattern = "^muffle")
[13:19:23.571]                   }
[13:19:23.571]                 }
[13:19:23.571]                 else {
[13:19:23.571]                   if (TRUE) {
[13:19:23.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.571]                     {
[13:19:23.571]                       inherits <- base::inherits
[13:19:23.571]                       invokeRestart <- base::invokeRestart
[13:19:23.571]                       is.null <- base::is.null
[13:19:23.571]                       muffled <- FALSE
[13:19:23.571]                       if (inherits(cond, "message")) {
[13:19:23.571]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:23.571]                         if (muffled) 
[13:19:23.571]                           invokeRestart("muffleMessage")
[13:19:23.571]                       }
[13:19:23.571]                       else if (inherits(cond, "warning")) {
[13:19:23.571]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:23.571]                         if (muffled) 
[13:19:23.571]                           invokeRestart("muffleWarning")
[13:19:23.571]                       }
[13:19:23.571]                       else if (inherits(cond, "condition")) {
[13:19:23.571]                         if (!is.null(pattern)) {
[13:19:23.571]                           computeRestarts <- base::computeRestarts
[13:19:23.571]                           grepl <- base::grepl
[13:19:23.571]                           restarts <- computeRestarts(cond)
[13:19:23.571]                           for (restart in restarts) {
[13:19:23.571]                             name <- restart$name
[13:19:23.571]                             if (is.null(name)) 
[13:19:23.571]                               next
[13:19:23.571]                             if (!grepl(pattern, name)) 
[13:19:23.571]                               next
[13:19:23.571]                             invokeRestart(restart)
[13:19:23.571]                             muffled <- TRUE
[13:19:23.571]                             break
[13:19:23.571]                           }
[13:19:23.571]                         }
[13:19:23.571]                       }
[13:19:23.571]                       invisible(muffled)
[13:19:23.571]                     }
[13:19:23.571]                     muffleCondition(cond, pattern = "^muffle")
[13:19:23.571]                   }
[13:19:23.571]                 }
[13:19:23.571]             }
[13:19:23.571]         }))
[13:19:23.571]     }, error = function(ex) {
[13:19:23.571]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:23.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:23.571]                 ...future.rng), started = ...future.startTime, 
[13:19:23.571]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:23.571]             version = "1.8"), class = "FutureResult")
[13:19:23.571]     }, finally = {
[13:19:23.571]         if (!identical(...future.workdir, getwd())) 
[13:19:23.571]             setwd(...future.workdir)
[13:19:23.571]         {
[13:19:23.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:23.571]                 ...future.oldOptions$nwarnings <- NULL
[13:19:23.571]             }
[13:19:23.571]             base::options(...future.oldOptions)
[13:19:23.571]             if (.Platform$OS.type == "windows") {
[13:19:23.571]                 old_names <- names(...future.oldEnvVars)
[13:19:23.571]                 envs <- base::Sys.getenv()
[13:19:23.571]                 names <- names(envs)
[13:19:23.571]                 common <- intersect(names, old_names)
[13:19:23.571]                 added <- setdiff(names, old_names)
[13:19:23.571]                 removed <- setdiff(old_names, names)
[13:19:23.571]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:23.571]                   envs[common]]
[13:19:23.571]                 NAMES <- toupper(changed)
[13:19:23.571]                 args <- list()
[13:19:23.571]                 for (kk in seq_along(NAMES)) {
[13:19:23.571]                   name <- changed[[kk]]
[13:19:23.571]                   NAME <- NAMES[[kk]]
[13:19:23.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.571]                     next
[13:19:23.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:23.571]                 }
[13:19:23.571]                 NAMES <- toupper(added)
[13:19:23.571]                 for (kk in seq_along(NAMES)) {
[13:19:23.571]                   name <- added[[kk]]
[13:19:23.571]                   NAME <- NAMES[[kk]]
[13:19:23.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.571]                     next
[13:19:23.571]                   args[[name]] <- ""
[13:19:23.571]                 }
[13:19:23.571]                 NAMES <- toupper(removed)
[13:19:23.571]                 for (kk in seq_along(NAMES)) {
[13:19:23.571]                   name <- removed[[kk]]
[13:19:23.571]                   NAME <- NAMES[[kk]]
[13:19:23.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.571]                     next
[13:19:23.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:23.571]                 }
[13:19:23.571]                 if (length(args) > 0) 
[13:19:23.571]                   base::do.call(base::Sys.setenv, args = args)
[13:19:23.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:23.571]             }
[13:19:23.571]             else {
[13:19:23.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:23.571]             }
[13:19:23.571]             {
[13:19:23.571]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:23.571]                   0L) {
[13:19:23.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:23.571]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:23.571]                   base::options(opts)
[13:19:23.571]                 }
[13:19:23.571]                 {
[13:19:23.571]                   {
[13:19:23.571]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:23.571]                     NULL
[13:19:23.571]                   }
[13:19:23.571]                   options(future.plan = NULL)
[13:19:23.571]                   if (is.na(NA_character_)) 
[13:19:23.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:23.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:23.571]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:23.571]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:23.571]                     envir = parent.frame()) 
[13:19:23.571]                   {
[13:19:23.571]                     if (is.function(workers)) 
[13:19:23.571]                       workers <- workers()
[13:19:23.571]                     workers <- structure(as.integer(workers), 
[13:19:23.571]                       class = class(workers))
[13:19:23.571]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:23.571]                       workers >= 1)
[13:19:23.571]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:23.571]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:23.571]                     }
[13:19:23.571]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:23.571]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:23.571]                       envir = envir)
[13:19:23.571]                     if (!future$lazy) 
[13:19:23.571]                       future <- run(future)
[13:19:23.571]                     invisible(future)
[13:19:23.571]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:23.571]                 }
[13:19:23.571]             }
[13:19:23.571]         }
[13:19:23.571]     })
[13:19:23.571]     if (TRUE) {
[13:19:23.571]         base::sink(type = "output", split = FALSE)
[13:19:23.571]         if (FALSE) {
[13:19:23.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:23.571]         }
[13:19:23.571]         else {
[13:19:23.571]             ...future.result["stdout"] <- base::list(NULL)
[13:19:23.571]         }
[13:19:23.571]         base::close(...future.stdout)
[13:19:23.571]         ...future.stdout <- NULL
[13:19:23.571]     }
[13:19:23.571]     ...future.result$conditions <- ...future.conditions
[13:19:23.571]     ...future.result$finished <- base::Sys.time()
[13:19:23.571]     ...future.result
[13:19:23.571] }
[13:19:23.574] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:19:23.574] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:19:23.575] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:19:23.575] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:23.575] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:23.575] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:19:23.576] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:19:23.576] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:23.576] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:23.576] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:23.577] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:23.577] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:19:23.577] MultisessionFuture started
[13:19:23.578] - Launch lazy future ... done
[13:19:23.578] run() for ‘MultisessionFuture’ ... done
[13:19:23.578] Created future:
[13:19:23.578] MultisessionFuture:
[13:19:23.578] Label: ‘future_lapply-1’
[13:19:23.578] Expression:
[13:19:23.578] {
[13:19:23.578]     do.call(function(...) {
[13:19:23.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:23.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:23.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:23.578]             on.exit(options(oopts), add = TRUE)
[13:19:23.578]         }
[13:19:23.578]         {
[13:19:23.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:23.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:23.578]                 ...future.FUN(...future.X_jj, ...)
[13:19:23.578]             })
[13:19:23.578]         }
[13:19:23.578]     }, args = future.call.arguments)
[13:19:23.578] }
[13:19:23.578] Lazy evaluation: FALSE
[13:19:23.578] Asynchronous evaluation: TRUE
[13:19:23.578] Local evaluation: TRUE
[13:19:23.578] Environment: R_GlobalEnv
[13:19:23.578] Capture standard output: FALSE
[13:19:23.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:23.578] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:23.578] Packages: <none>
[13:19:23.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:23.578] Resolved: FALSE
[13:19:23.578] Value: <not collected>
[13:19:23.578] Conditions captured: <none>
[13:19:23.578] Early signaling: FALSE
[13:19:23.578] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:23.578] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:23.590] Chunk #1 of 2 ... DONE
[13:19:23.590] Chunk #2 of 2 ...
[13:19:23.590]  - Finding globals in 'X' for chunk #2 ...
[13:19:23.591] getGlobalsAndPackages() ...
[13:19:23.591] Searching for globals...
[13:19:23.591] 
[13:19:23.591] Searching for globals ... DONE
[13:19:23.591] - globals: [0] <none>
[13:19:23.592] getGlobalsAndPackages() ... DONE
[13:19:23.592]    + additional globals found: [n=0] 
[13:19:23.592]    + additional namespaces needed: [n=0] 
[13:19:23.592]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:23.592]  - seeds: <none>
[13:19:23.592] getGlobalsAndPackages() ...
[13:19:23.592] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:23.592] Resolving globals: FALSE
[13:19:23.592] Tweak future expression to call with '...' arguments ...
[13:19:23.593] {
[13:19:23.593]     do.call(function(...) {
[13:19:23.593]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:23.593]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:23.593]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:23.593]             on.exit(options(oopts), add = TRUE)
[13:19:23.593]         }
[13:19:23.593]         {
[13:19:23.593]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:23.593]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:23.593]                 ...future.FUN(...future.X_jj, ...)
[13:19:23.593]             })
[13:19:23.593]         }
[13:19:23.593]     }, args = future.call.arguments)
[13:19:23.593] }
[13:19:23.593] Tweak future expression to call with '...' arguments ... DONE
[13:19:23.593] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:23.594] 
[13:19:23.594] getGlobalsAndPackages() ... DONE
[13:19:23.594] run() for ‘Future’ ...
[13:19:23.594] - state: ‘created’
[13:19:23.594] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:23.610] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:23.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:23.611]   - Field: ‘node’
[13:19:23.611]   - Field: ‘label’
[13:19:23.611]   - Field: ‘local’
[13:19:23.611]   - Field: ‘owner’
[13:19:23.611]   - Field: ‘envir’
[13:19:23.611]   - Field: ‘workers’
[13:19:23.611]   - Field: ‘packages’
[13:19:23.611]   - Field: ‘gc’
[13:19:23.611]   - Field: ‘conditions’
[13:19:23.612]   - Field: ‘persistent’
[13:19:23.612]   - Field: ‘expr’
[13:19:23.612]   - Field: ‘uuid’
[13:19:23.612]   - Field: ‘seed’
[13:19:23.612]   - Field: ‘version’
[13:19:23.612]   - Field: ‘result’
[13:19:23.612]   - Field: ‘asynchronous’
[13:19:23.612]   - Field: ‘calls’
[13:19:23.612]   - Field: ‘globals’
[13:19:23.613]   - Field: ‘stdout’
[13:19:23.613]   - Field: ‘earlySignal’
[13:19:23.613]   - Field: ‘lazy’
[13:19:23.613]   - Field: ‘state’
[13:19:23.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:23.613] - Launch lazy future ...
[13:19:23.614] Packages needed by the future expression (n = 0): <none>
[13:19:23.614] Packages needed by future strategies (n = 0): <none>
[13:19:23.614] {
[13:19:23.614]     {
[13:19:23.614]         {
[13:19:23.614]             ...future.startTime <- base::Sys.time()
[13:19:23.614]             {
[13:19:23.614]                 {
[13:19:23.614]                   {
[13:19:23.614]                     {
[13:19:23.614]                       base::local({
[13:19:23.614]                         has_future <- base::requireNamespace("future", 
[13:19:23.614]                           quietly = TRUE)
[13:19:23.614]                         if (has_future) {
[13:19:23.614]                           ns <- base::getNamespace("future")
[13:19:23.614]                           version <- ns[[".package"]][["version"]]
[13:19:23.614]                           if (is.null(version)) 
[13:19:23.614]                             version <- utils::packageVersion("future")
[13:19:23.614]                         }
[13:19:23.614]                         else {
[13:19:23.614]                           version <- NULL
[13:19:23.614]                         }
[13:19:23.614]                         if (!has_future || version < "1.8.0") {
[13:19:23.614]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:23.614]                             "", base::R.version$version.string), 
[13:19:23.614]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:23.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:23.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:23.614]                               "release", "version")], collapse = " "), 
[13:19:23.614]                             hostname = base::Sys.info()[["nodename"]])
[13:19:23.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:23.614]                             info)
[13:19:23.614]                           info <- base::paste(info, collapse = "; ")
[13:19:23.614]                           if (!has_future) {
[13:19:23.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:23.614]                               info)
[13:19:23.614]                           }
[13:19:23.614]                           else {
[13:19:23.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:23.614]                               info, version)
[13:19:23.614]                           }
[13:19:23.614]                           base::stop(msg)
[13:19:23.614]                         }
[13:19:23.614]                       })
[13:19:23.614]                     }
[13:19:23.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:23.614]                     base::options(mc.cores = 1L)
[13:19:23.614]                   }
[13:19:23.614]                   options(future.plan = NULL)
[13:19:23.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:23.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:23.614]                 }
[13:19:23.614]                 ...future.workdir <- getwd()
[13:19:23.614]             }
[13:19:23.614]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:23.614]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:23.614]         }
[13:19:23.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:23.614]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:23.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:23.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:23.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:23.614]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:23.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:23.614]             base::names(...future.oldOptions))
[13:19:23.614]     }
[13:19:23.614]     if (FALSE) {
[13:19:23.614]     }
[13:19:23.614]     else {
[13:19:23.614]         if (FALSE) {
[13:19:23.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:23.614]                 open = "w")
[13:19:23.614]         }
[13:19:23.614]         else {
[13:19:23.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:23.614]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:23.614]         }
[13:19:23.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:23.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:23.614]             base::sink(type = "output", split = FALSE)
[13:19:23.614]             base::close(...future.stdout)
[13:19:23.614]         }, add = TRUE)
[13:19:23.614]     }
[13:19:23.614]     ...future.frame <- base::sys.nframe()
[13:19:23.614]     ...future.conditions <- base::list()
[13:19:23.614]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:23.614]     if (FALSE) {
[13:19:23.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:23.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:23.614]     }
[13:19:23.614]     ...future.result <- base::tryCatch({
[13:19:23.614]         base::withCallingHandlers({
[13:19:23.614]             ...future.value <- base::withVisible(base::local({
[13:19:23.614]                 ...future.makeSendCondition <- local({
[13:19:23.614]                   sendCondition <- NULL
[13:19:23.614]                   function(frame = 1L) {
[13:19:23.614]                     if (is.function(sendCondition)) 
[13:19:23.614]                       return(sendCondition)
[13:19:23.614]                     ns <- getNamespace("parallel")
[13:19:23.614]                     if (exists("sendData", mode = "function", 
[13:19:23.614]                       envir = ns)) {
[13:19:23.614]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:23.614]                         envir = ns)
[13:19:23.614]                       envir <- sys.frame(frame)
[13:19:23.614]                       master <- NULL
[13:19:23.614]                       while (!identical(envir, .GlobalEnv) && 
[13:19:23.614]                         !identical(envir, emptyenv())) {
[13:19:23.614]                         if (exists("master", mode = "list", envir = envir, 
[13:19:23.614]                           inherits = FALSE)) {
[13:19:23.614]                           master <- get("master", mode = "list", 
[13:19:23.614]                             envir = envir, inherits = FALSE)
[13:19:23.614]                           if (inherits(master, c("SOCKnode", 
[13:19:23.614]                             "SOCK0node"))) {
[13:19:23.614]                             sendCondition <<- function(cond) {
[13:19:23.614]                               data <- list(type = "VALUE", value = cond, 
[13:19:23.614]                                 success = TRUE)
[13:19:23.614]                               parallel_sendData(master, data)
[13:19:23.614]                             }
[13:19:23.614]                             return(sendCondition)
[13:19:23.614]                           }
[13:19:23.614]                         }
[13:19:23.614]                         frame <- frame + 1L
[13:19:23.614]                         envir <- sys.frame(frame)
[13:19:23.614]                       }
[13:19:23.614]                     }
[13:19:23.614]                     sendCondition <<- function(cond) NULL
[13:19:23.614]                   }
[13:19:23.614]                 })
[13:19:23.614]                 withCallingHandlers({
[13:19:23.614]                   {
[13:19:23.614]                     do.call(function(...) {
[13:19:23.614]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:23.614]                       if (!identical(...future.globals.maxSize.org, 
[13:19:23.614]                         ...future.globals.maxSize)) {
[13:19:23.614]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:23.614]                         on.exit(options(oopts), add = TRUE)
[13:19:23.614]                       }
[13:19:23.614]                       {
[13:19:23.614]                         lapply(seq_along(...future.elements_ii), 
[13:19:23.614]                           FUN = function(jj) {
[13:19:23.614]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:23.614]                             ...future.FUN(...future.X_jj, ...)
[13:19:23.614]                           })
[13:19:23.614]                       }
[13:19:23.614]                     }, args = future.call.arguments)
[13:19:23.614]                   }
[13:19:23.614]                 }, immediateCondition = function(cond) {
[13:19:23.614]                   sendCondition <- ...future.makeSendCondition()
[13:19:23.614]                   sendCondition(cond)
[13:19:23.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.614]                   {
[13:19:23.614]                     inherits <- base::inherits
[13:19:23.614]                     invokeRestart <- base::invokeRestart
[13:19:23.614]                     is.null <- base::is.null
[13:19:23.614]                     muffled <- FALSE
[13:19:23.614]                     if (inherits(cond, "message")) {
[13:19:23.614]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:23.614]                       if (muffled) 
[13:19:23.614]                         invokeRestart("muffleMessage")
[13:19:23.614]                     }
[13:19:23.614]                     else if (inherits(cond, "warning")) {
[13:19:23.614]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:23.614]                       if (muffled) 
[13:19:23.614]                         invokeRestart("muffleWarning")
[13:19:23.614]                     }
[13:19:23.614]                     else if (inherits(cond, "condition")) {
[13:19:23.614]                       if (!is.null(pattern)) {
[13:19:23.614]                         computeRestarts <- base::computeRestarts
[13:19:23.614]                         grepl <- base::grepl
[13:19:23.614]                         restarts <- computeRestarts(cond)
[13:19:23.614]                         for (restart in restarts) {
[13:19:23.614]                           name <- restart$name
[13:19:23.614]                           if (is.null(name)) 
[13:19:23.614]                             next
[13:19:23.614]                           if (!grepl(pattern, name)) 
[13:19:23.614]                             next
[13:19:23.614]                           invokeRestart(restart)
[13:19:23.614]                           muffled <- TRUE
[13:19:23.614]                           break
[13:19:23.614]                         }
[13:19:23.614]                       }
[13:19:23.614]                     }
[13:19:23.614]                     invisible(muffled)
[13:19:23.614]                   }
[13:19:23.614]                   muffleCondition(cond)
[13:19:23.614]                 })
[13:19:23.614]             }))
[13:19:23.614]             future::FutureResult(value = ...future.value$value, 
[13:19:23.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:23.614]                   ...future.rng), globalenv = if (FALSE) 
[13:19:23.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:23.614]                     ...future.globalenv.names))
[13:19:23.614]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:23.614]         }, condition = base::local({
[13:19:23.614]             c <- base::c
[13:19:23.614]             inherits <- base::inherits
[13:19:23.614]             invokeRestart <- base::invokeRestart
[13:19:23.614]             length <- base::length
[13:19:23.614]             list <- base::list
[13:19:23.614]             seq.int <- base::seq.int
[13:19:23.614]             signalCondition <- base::signalCondition
[13:19:23.614]             sys.calls <- base::sys.calls
[13:19:23.614]             `[[` <- base::`[[`
[13:19:23.614]             `+` <- base::`+`
[13:19:23.614]             `<<-` <- base::`<<-`
[13:19:23.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:23.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:23.614]                   3L)]
[13:19:23.614]             }
[13:19:23.614]             function(cond) {
[13:19:23.614]                 is_error <- inherits(cond, "error")
[13:19:23.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:23.614]                   NULL)
[13:19:23.614]                 if (is_error) {
[13:19:23.614]                   sessionInformation <- function() {
[13:19:23.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:23.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:23.614]                       search = base::search(), system = base::Sys.info())
[13:19:23.614]                   }
[13:19:23.614]                   ...future.conditions[[length(...future.conditions) + 
[13:19:23.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:23.614]                     cond$call), session = sessionInformation(), 
[13:19:23.614]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:23.614]                   signalCondition(cond)
[13:19:23.614]                 }
[13:19:23.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:23.614]                 "immediateCondition"))) {
[13:19:23.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:23.614]                   ...future.conditions[[length(...future.conditions) + 
[13:19:23.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:23.614]                   if (TRUE && !signal) {
[13:19:23.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.614]                     {
[13:19:23.614]                       inherits <- base::inherits
[13:19:23.614]                       invokeRestart <- base::invokeRestart
[13:19:23.614]                       is.null <- base::is.null
[13:19:23.614]                       muffled <- FALSE
[13:19:23.614]                       if (inherits(cond, "message")) {
[13:19:23.614]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:23.614]                         if (muffled) 
[13:19:23.614]                           invokeRestart("muffleMessage")
[13:19:23.614]                       }
[13:19:23.614]                       else if (inherits(cond, "warning")) {
[13:19:23.614]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:23.614]                         if (muffled) 
[13:19:23.614]                           invokeRestart("muffleWarning")
[13:19:23.614]                       }
[13:19:23.614]                       else if (inherits(cond, "condition")) {
[13:19:23.614]                         if (!is.null(pattern)) {
[13:19:23.614]                           computeRestarts <- base::computeRestarts
[13:19:23.614]                           grepl <- base::grepl
[13:19:23.614]                           restarts <- computeRestarts(cond)
[13:19:23.614]                           for (restart in restarts) {
[13:19:23.614]                             name <- restart$name
[13:19:23.614]                             if (is.null(name)) 
[13:19:23.614]                               next
[13:19:23.614]                             if (!grepl(pattern, name)) 
[13:19:23.614]                               next
[13:19:23.614]                             invokeRestart(restart)
[13:19:23.614]                             muffled <- TRUE
[13:19:23.614]                             break
[13:19:23.614]                           }
[13:19:23.614]                         }
[13:19:23.614]                       }
[13:19:23.614]                       invisible(muffled)
[13:19:23.614]                     }
[13:19:23.614]                     muffleCondition(cond, pattern = "^muffle")
[13:19:23.614]                   }
[13:19:23.614]                 }
[13:19:23.614]                 else {
[13:19:23.614]                   if (TRUE) {
[13:19:23.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:23.614]                     {
[13:19:23.614]                       inherits <- base::inherits
[13:19:23.614]                       invokeRestart <- base::invokeRestart
[13:19:23.614]                       is.null <- base::is.null
[13:19:23.614]                       muffled <- FALSE
[13:19:23.614]                       if (inherits(cond, "message")) {
[13:19:23.614]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:23.614]                         if (muffled) 
[13:19:23.614]                           invokeRestart("muffleMessage")
[13:19:23.614]                       }
[13:19:23.614]                       else if (inherits(cond, "warning")) {
[13:19:23.614]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:23.614]                         if (muffled) 
[13:19:23.614]                           invokeRestart("muffleWarning")
[13:19:23.614]                       }
[13:19:23.614]                       else if (inherits(cond, "condition")) {
[13:19:23.614]                         if (!is.null(pattern)) {
[13:19:23.614]                           computeRestarts <- base::computeRestarts
[13:19:23.614]                           grepl <- base::grepl
[13:19:23.614]                           restarts <- computeRestarts(cond)
[13:19:23.614]                           for (restart in restarts) {
[13:19:23.614]                             name <- restart$name
[13:19:23.614]                             if (is.null(name)) 
[13:19:23.614]                               next
[13:19:23.614]                             if (!grepl(pattern, name)) 
[13:19:23.614]                               next
[13:19:23.614]                             invokeRestart(restart)
[13:19:23.614]                             muffled <- TRUE
[13:19:23.614]                             break
[13:19:23.614]                           }
[13:19:23.614]                         }
[13:19:23.614]                       }
[13:19:23.614]                       invisible(muffled)
[13:19:23.614]                     }
[13:19:23.614]                     muffleCondition(cond, pattern = "^muffle")
[13:19:23.614]                   }
[13:19:23.614]                 }
[13:19:23.614]             }
[13:19:23.614]         }))
[13:19:23.614]     }, error = function(ex) {
[13:19:23.614]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:23.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:23.614]                 ...future.rng), started = ...future.startTime, 
[13:19:23.614]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:23.614]             version = "1.8"), class = "FutureResult")
[13:19:23.614]     }, finally = {
[13:19:23.614]         if (!identical(...future.workdir, getwd())) 
[13:19:23.614]             setwd(...future.workdir)
[13:19:23.614]         {
[13:19:23.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:23.614]                 ...future.oldOptions$nwarnings <- NULL
[13:19:23.614]             }
[13:19:23.614]             base::options(...future.oldOptions)
[13:19:23.614]             if (.Platform$OS.type == "windows") {
[13:19:23.614]                 old_names <- names(...future.oldEnvVars)
[13:19:23.614]                 envs <- base::Sys.getenv()
[13:19:23.614]                 names <- names(envs)
[13:19:23.614]                 common <- intersect(names, old_names)
[13:19:23.614]                 added <- setdiff(names, old_names)
[13:19:23.614]                 removed <- setdiff(old_names, names)
[13:19:23.614]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:23.614]                   envs[common]]
[13:19:23.614]                 NAMES <- toupper(changed)
[13:19:23.614]                 args <- list()
[13:19:23.614]                 for (kk in seq_along(NAMES)) {
[13:19:23.614]                   name <- changed[[kk]]
[13:19:23.614]                   NAME <- NAMES[[kk]]
[13:19:23.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.614]                     next
[13:19:23.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:23.614]                 }
[13:19:23.614]                 NAMES <- toupper(added)
[13:19:23.614]                 for (kk in seq_along(NAMES)) {
[13:19:23.614]                   name <- added[[kk]]
[13:19:23.614]                   NAME <- NAMES[[kk]]
[13:19:23.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.614]                     next
[13:19:23.614]                   args[[name]] <- ""
[13:19:23.614]                 }
[13:19:23.614]                 NAMES <- toupper(removed)
[13:19:23.614]                 for (kk in seq_along(NAMES)) {
[13:19:23.614]                   name <- removed[[kk]]
[13:19:23.614]                   NAME <- NAMES[[kk]]
[13:19:23.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:23.614]                     next
[13:19:23.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:23.614]                 }
[13:19:23.614]                 if (length(args) > 0) 
[13:19:23.614]                   base::do.call(base::Sys.setenv, args = args)
[13:19:23.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:23.614]             }
[13:19:23.614]             else {
[13:19:23.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:23.614]             }
[13:19:23.614]             {
[13:19:23.614]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:23.614]                   0L) {
[13:19:23.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:23.614]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:23.614]                   base::options(opts)
[13:19:23.614]                 }
[13:19:23.614]                 {
[13:19:23.614]                   {
[13:19:23.614]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:23.614]                     NULL
[13:19:23.614]                   }
[13:19:23.614]                   options(future.plan = NULL)
[13:19:23.614]                   if (is.na(NA_character_)) 
[13:19:23.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:23.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:23.614]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:23.614]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:23.614]                     envir = parent.frame()) 
[13:19:23.614]                   {
[13:19:23.614]                     if (is.function(workers)) 
[13:19:23.614]                       workers <- workers()
[13:19:23.614]                     workers <- structure(as.integer(workers), 
[13:19:23.614]                       class = class(workers))
[13:19:23.614]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:23.614]                       workers >= 1)
[13:19:23.614]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:23.614]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:23.614]                     }
[13:19:23.614]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:23.614]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:23.614]                       envir = envir)
[13:19:23.614]                     if (!future$lazy) 
[13:19:23.614]                       future <- run(future)
[13:19:23.614]                     invisible(future)
[13:19:23.614]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:23.614]                 }
[13:19:23.614]             }
[13:19:23.614]         }
[13:19:23.614]     })
[13:19:23.614]     if (TRUE) {
[13:19:23.614]         base::sink(type = "output", split = FALSE)
[13:19:23.614]         if (FALSE) {
[13:19:23.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:23.614]         }
[13:19:23.614]         else {
[13:19:23.614]             ...future.result["stdout"] <- base::list(NULL)
[13:19:23.614]         }
[13:19:23.614]         base::close(...future.stdout)
[13:19:23.614]         ...future.stdout <- NULL
[13:19:23.614]     }
[13:19:23.614]     ...future.result$conditions <- ...future.conditions
[13:19:23.614]     ...future.result$finished <- base::Sys.time()
[13:19:23.614]     ...future.result
[13:19:23.614] }
[13:19:23.687] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:19:23.687] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:19:23.688] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:19:23.688] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:23.688] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:23.689] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:19:23.689] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:19:23.689] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:23.690] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:23.690] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:23.690] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:23.690] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:19:23.691] MultisessionFuture started
[13:19:23.691] - Launch lazy future ... done
[13:19:23.692] run() for ‘MultisessionFuture’ ... done
[13:19:23.692] Created future:
[13:19:23.692] MultisessionFuture:
[13:19:23.692] Label: ‘future_lapply-2’
[13:19:23.692] Expression:
[13:19:23.692] {
[13:19:23.692]     do.call(function(...) {
[13:19:23.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:23.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:23.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:23.692]             on.exit(options(oopts), add = TRUE)
[13:19:23.692]         }
[13:19:23.692]         {
[13:19:23.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:23.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:23.692]                 ...future.FUN(...future.X_jj, ...)
[13:19:23.692]             })
[13:19:23.692]         }
[13:19:23.692]     }, args = future.call.arguments)
[13:19:23.692] }
[13:19:23.692] Lazy evaluation: FALSE
[13:19:23.692] Asynchronous evaluation: TRUE
[13:19:23.692] Local evaluation: TRUE
[13:19:23.692] Environment: R_GlobalEnv
[13:19:23.692] Capture standard output: FALSE
[13:19:23.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:23.692] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:23.692] Packages: <none>
[13:19:23.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:23.692] Resolved: FALSE
[13:19:23.692] Value: <not collected>
[13:19:23.692] Conditions captured: <none>
[13:19:23.692] Early signaling: FALSE
[13:19:23.692] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:23.692] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:23.704] Chunk #2 of 2 ... DONE
[13:19:23.704] Launching 2 futures (chunks) ... DONE
[13:19:23.704] Resolving 2 futures (chunks) ...
[13:19:23.704] resolve() on list ...
[13:19:23.704]  recursive: 0
[13:19:23.705]  length: 2
[13:19:23.705] 
[13:19:23.781] receiveMessageFromWorker() for ClusterFuture ...
[13:19:23.781] - Validating connection of MultisessionFuture
[13:19:23.781] - received message: FutureResult
[13:19:23.782] - Received FutureResult
[13:19:23.782] - Erased future from FutureRegistry
[13:19:23.782] result() for ClusterFuture ...
[13:19:23.782] - result already collected: FutureResult
[13:19:23.782] result() for ClusterFuture ... done
[13:19:23.782] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:23.782] Future #2
[13:19:23.782] result() for ClusterFuture ...
[13:19:23.782] - result already collected: FutureResult
[13:19:23.782] result() for ClusterFuture ... done
[13:19:23.783] result() for ClusterFuture ...
[13:19:23.783] - result already collected: FutureResult
[13:19:23.783] result() for ClusterFuture ... done
[13:19:23.783] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:23.783] - nx: 2
[13:19:23.783] - relay: TRUE
[13:19:23.783] - stdout: TRUE
[13:19:23.783] - signal: TRUE
[13:19:23.783] - resignal: FALSE
[13:19:23.783] - force: TRUE
[13:19:23.783] - relayed: [n=2] FALSE, FALSE
[13:19:23.783] - queued futures: [n=2] FALSE, FALSE
[13:19:23.784]  - until=1
[13:19:23.784]  - relaying element #1
[13:19:23.784] - relayed: [n=2] FALSE, FALSE
[13:19:23.784] - queued futures: [n=2] FALSE, TRUE
[13:19:23.784] signalConditionsASAP(NULL, pos=2) ... done
[13:19:23.784]  length: 1 (resolved future 2)
[13:19:24.131] receiveMessageFromWorker() for ClusterFuture ...
[13:19:24.131] - Validating connection of MultisessionFuture
[13:19:24.132] - received message: FutureResult
[13:19:24.132] - Received FutureResult
[13:19:24.132] - Erased future from FutureRegistry
[13:19:24.132] result() for ClusterFuture ...
[13:19:24.132] - result already collected: FutureResult
[13:19:24.132] result() for ClusterFuture ... done
[13:19:24.132] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:24.132] Future #1
[13:19:24.132] result() for ClusterFuture ...
[13:19:24.132] - result already collected: FutureResult
[13:19:24.133] result() for ClusterFuture ... done
[13:19:24.133] result() for ClusterFuture ...
[13:19:24.133] - result already collected: FutureResult
[13:19:24.133] result() for ClusterFuture ... done
[13:19:24.133] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:24.133] - nx: 2
[13:19:24.133] - relay: TRUE
[13:19:24.133] - stdout: TRUE
[13:19:24.133] - signal: TRUE
[13:19:24.133] - resignal: FALSE
[13:19:24.133] - force: TRUE
[13:19:24.133] - relayed: [n=2] FALSE, FALSE
[13:19:24.134] - queued futures: [n=2] FALSE, TRUE
[13:19:24.134]  - until=1
[13:19:24.134]  - relaying element #1
[13:19:24.134] result() for ClusterFuture ...
[13:19:24.134] - result already collected: FutureResult
[13:19:24.134] result() for ClusterFuture ... done
[13:19:24.134] result() for ClusterFuture ...
[13:19:24.134] - result already collected: FutureResult
[13:19:24.134] result() for ClusterFuture ... done
[13:19:24.134] result() for ClusterFuture ...
[13:19:24.134] - result already collected: FutureResult
[13:19:24.135] result() for ClusterFuture ... done
[13:19:24.135] result() for ClusterFuture ...
[13:19:24.135] - result already collected: FutureResult
[13:19:24.135] result() for ClusterFuture ... done
[13:19:24.135] - relayed: [n=2] TRUE, FALSE
[13:19:24.135] - queued futures: [n=2] TRUE, TRUE
[13:19:24.135] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:24.135]  length: 0 (resolved future 1)
[13:19:24.135] Relaying remaining futures
[13:19:24.135] signalConditionsASAP(NULL, pos=0) ...
[13:19:24.135] - nx: 2
[13:19:24.135] - relay: TRUE
[13:19:24.136] - stdout: TRUE
[13:19:24.136] - signal: TRUE
[13:19:24.136] - resignal: FALSE
[13:19:24.136] - force: TRUE
[13:19:24.136] - relayed: [n=2] TRUE, FALSE
[13:19:24.136] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:24.136]  - relaying element #2
[13:19:24.136] result() for ClusterFuture ...
[13:19:24.136] - result already collected: FutureResult
[13:19:24.136] result() for ClusterFuture ... done
[13:19:24.136] result() for ClusterFuture ...
[13:19:24.136] - result already collected: FutureResult
[13:19:24.137] result() for ClusterFuture ... done
[13:19:24.137] result() for ClusterFuture ...
[13:19:24.137] - result already collected: FutureResult
[13:19:24.137] result() for ClusterFuture ... done
[13:19:24.137] result() for ClusterFuture ...
[13:19:24.137] - result already collected: FutureResult
[13:19:24.137] result() for ClusterFuture ... done
[13:19:24.137] - relayed: [n=2] TRUE, TRUE
[13:19:24.137] - queued futures: [n=2] TRUE, TRUE
[13:19:24.137] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:19:24.138] resolve() on list ... DONE
[13:19:24.138] result() for ClusterFuture ...
[13:19:24.138] - result already collected: FutureResult
[13:19:24.138] result() for ClusterFuture ... done
[13:19:24.138] result() for ClusterFuture ...
[13:19:24.138] - result already collected: FutureResult
[13:19:24.138] result() for ClusterFuture ... done
[13:19:24.138] result() for ClusterFuture ...
[13:19:24.138] - result already collected: FutureResult
[13:19:24.138] result() for ClusterFuture ... done
[13:19:24.138] result() for ClusterFuture ...
[13:19:24.138] - result already collected: FutureResult
[13:19:24.139] result() for ClusterFuture ... done
[13:19:24.139]  - Number of value chunks collected: 2
[13:19:24.139] Resolving 2 futures (chunks) ... DONE
[13:19:24.139] Reducing values from 2 chunks ...
[13:19:24.139]  - Number of values collected after concatenation: 2
[13:19:24.139]  - Number of values expected: 2
[13:19:24.139] Reducing values from 2 chunks ... DONE
[13:19:24.139] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:19:24.140] future_lapply() ...
[13:19:24.144] Number of chunks: 2
[13:19:24.144] getGlobalsAndPackagesXApply() ...
[13:19:24.144]  - future.globals: TRUE
[13:19:24.144] getGlobalsAndPackages() ...
[13:19:24.144] Searching for globals...
[13:19:24.145] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:24.146] Searching for globals ... DONE
[13:19:24.146] Resolving globals: FALSE
[13:19:24.146] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:24.146] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:24.146] - globals: [1] ‘FUN’
[13:19:24.147] 
[13:19:24.147] getGlobalsAndPackages() ... DONE
[13:19:24.147]  - globals found/used: [n=1] ‘FUN’
[13:19:24.147]  - needed namespaces: [n=0] 
[13:19:24.147] Finding globals ... DONE
[13:19:24.147]  - use_args: TRUE
[13:19:24.147]  - Getting '...' globals ...
[13:19:24.147] resolve() on list ...
[13:19:24.148]  recursive: 0
[13:19:24.148]  length: 1
[13:19:24.148]  elements: ‘...’
[13:19:24.148]  length: 0 (resolved future 1)
[13:19:24.148] resolve() on list ... DONE
[13:19:24.148]    - '...' content: [n=0] 
[13:19:24.148] List of 1
[13:19:24.148]  $ ...: list()
[13:19:24.148]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:24.148]  - attr(*, "where")=List of 1
[13:19:24.148]   ..$ ...:<environment: 0x562005926088> 
[13:19:24.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:24.148]  - attr(*, "resolved")= logi TRUE
[13:19:24.148]  - attr(*, "total_size")= num NA
[13:19:24.151]  - Getting '...' globals ... DONE
[13:19:24.151] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:24.151] List of 2
[13:19:24.151]  $ ...future.FUN:function (x)  
[13:19:24.151]  $ ...          : list()
[13:19:24.151]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:24.151]  - attr(*, "where")=List of 2
[13:19:24.151]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:24.151]   ..$ ...          :<environment: 0x562005926088> 
[13:19:24.151]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:24.151]  - attr(*, "resolved")= logi FALSE
[13:19:24.151]  - attr(*, "total_size")= num 4720
[13:19:24.154] Packages to be attached in all futures: [n=0] 
[13:19:24.154] getGlobalsAndPackagesXApply() ... DONE
[13:19:24.154] Number of futures (= number of chunks): 2
[13:19:24.154] Launching 2 futures (chunks) ...
[13:19:24.154] Chunk #1 of 2 ...
[13:19:24.154]  - Finding globals in 'X' for chunk #1 ...
[13:19:24.154] getGlobalsAndPackages() ...
[13:19:24.154] Searching for globals...
[13:19:24.155] 
[13:19:24.155] Searching for globals ... DONE
[13:19:24.155] - globals: [0] <none>
[13:19:24.155] getGlobalsAndPackages() ... DONE
[13:19:24.155]    + additional globals found: [n=0] 
[13:19:24.155]    + additional namespaces needed: [n=0] 
[13:19:24.155]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:24.155]  - seeds: <none>
[13:19:24.155] getGlobalsAndPackages() ...
[13:19:24.155] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:24.156] Resolving globals: FALSE
[13:19:24.156] Tweak future expression to call with '...' arguments ...
[13:19:24.156] {
[13:19:24.156]     do.call(function(...) {
[13:19:24.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:24.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.156]             on.exit(options(oopts), add = TRUE)
[13:19:24.156]         }
[13:19:24.156]         {
[13:19:24.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:24.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.156]                 ...future.FUN(...future.X_jj, ...)
[13:19:24.156]             })
[13:19:24.156]         }
[13:19:24.156]     }, args = future.call.arguments)
[13:19:24.156] }
[13:19:24.156] Tweak future expression to call with '...' arguments ... DONE
[13:19:24.156] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:24.156] 
[13:19:24.157] getGlobalsAndPackages() ... DONE
[13:19:24.157] run() for ‘Future’ ...
[13:19:24.157] - state: ‘created’
[13:19:24.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:24.171] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:24.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:24.172]   - Field: ‘node’
[13:19:24.172]   - Field: ‘label’
[13:19:24.172]   - Field: ‘local’
[13:19:24.172]   - Field: ‘owner’
[13:19:24.172]   - Field: ‘envir’
[13:19:24.172]   - Field: ‘workers’
[13:19:24.172]   - Field: ‘packages’
[13:19:24.172]   - Field: ‘gc’
[13:19:24.172]   - Field: ‘conditions’
[13:19:24.173]   - Field: ‘persistent’
[13:19:24.173]   - Field: ‘expr’
[13:19:24.173]   - Field: ‘uuid’
[13:19:24.173]   - Field: ‘seed’
[13:19:24.173]   - Field: ‘version’
[13:19:24.173]   - Field: ‘result’
[13:19:24.173]   - Field: ‘asynchronous’
[13:19:24.173]   - Field: ‘calls’
[13:19:24.173]   - Field: ‘globals’
[13:19:24.173]   - Field: ‘stdout’
[13:19:24.174]   - Field: ‘earlySignal’
[13:19:24.174]   - Field: ‘lazy’
[13:19:24.174]   - Field: ‘state’
[13:19:24.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:24.174] - Launch lazy future ...
[13:19:24.174] Packages needed by the future expression (n = 0): <none>
[13:19:24.174] Packages needed by future strategies (n = 0): <none>
[13:19:24.175] {
[13:19:24.175]     {
[13:19:24.175]         {
[13:19:24.175]             ...future.startTime <- base::Sys.time()
[13:19:24.175]             {
[13:19:24.175]                 {
[13:19:24.175]                   {
[13:19:24.175]                     {
[13:19:24.175]                       base::local({
[13:19:24.175]                         has_future <- base::requireNamespace("future", 
[13:19:24.175]                           quietly = TRUE)
[13:19:24.175]                         if (has_future) {
[13:19:24.175]                           ns <- base::getNamespace("future")
[13:19:24.175]                           version <- ns[[".package"]][["version"]]
[13:19:24.175]                           if (is.null(version)) 
[13:19:24.175]                             version <- utils::packageVersion("future")
[13:19:24.175]                         }
[13:19:24.175]                         else {
[13:19:24.175]                           version <- NULL
[13:19:24.175]                         }
[13:19:24.175]                         if (!has_future || version < "1.8.0") {
[13:19:24.175]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:24.175]                             "", base::R.version$version.string), 
[13:19:24.175]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:24.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:24.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:24.175]                               "release", "version")], collapse = " "), 
[13:19:24.175]                             hostname = base::Sys.info()[["nodename"]])
[13:19:24.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:24.175]                             info)
[13:19:24.175]                           info <- base::paste(info, collapse = "; ")
[13:19:24.175]                           if (!has_future) {
[13:19:24.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:24.175]                               info)
[13:19:24.175]                           }
[13:19:24.175]                           else {
[13:19:24.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:24.175]                               info, version)
[13:19:24.175]                           }
[13:19:24.175]                           base::stop(msg)
[13:19:24.175]                         }
[13:19:24.175]                       })
[13:19:24.175]                     }
[13:19:24.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:24.175]                     base::options(mc.cores = 1L)
[13:19:24.175]                   }
[13:19:24.175]                   options(future.plan = NULL)
[13:19:24.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:24.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:24.175]                 }
[13:19:24.175]                 ...future.workdir <- getwd()
[13:19:24.175]             }
[13:19:24.175]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:24.175]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:24.175]         }
[13:19:24.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:24.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:24.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:24.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:24.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:24.175]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:24.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:24.175]             base::names(...future.oldOptions))
[13:19:24.175]     }
[13:19:24.175]     if (FALSE) {
[13:19:24.175]     }
[13:19:24.175]     else {
[13:19:24.175]         if (TRUE) {
[13:19:24.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:24.175]                 open = "w")
[13:19:24.175]         }
[13:19:24.175]         else {
[13:19:24.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:24.175]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:24.175]         }
[13:19:24.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:24.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:24.175]             base::sink(type = "output", split = FALSE)
[13:19:24.175]             base::close(...future.stdout)
[13:19:24.175]         }, add = TRUE)
[13:19:24.175]     }
[13:19:24.175]     ...future.frame <- base::sys.nframe()
[13:19:24.175]     ...future.conditions <- base::list()
[13:19:24.175]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:24.175]     if (FALSE) {
[13:19:24.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:24.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:24.175]     }
[13:19:24.175]     ...future.result <- base::tryCatch({
[13:19:24.175]         base::withCallingHandlers({
[13:19:24.175]             ...future.value <- base::withVisible(base::local({
[13:19:24.175]                 ...future.makeSendCondition <- local({
[13:19:24.175]                   sendCondition <- NULL
[13:19:24.175]                   function(frame = 1L) {
[13:19:24.175]                     if (is.function(sendCondition)) 
[13:19:24.175]                       return(sendCondition)
[13:19:24.175]                     ns <- getNamespace("parallel")
[13:19:24.175]                     if (exists("sendData", mode = "function", 
[13:19:24.175]                       envir = ns)) {
[13:19:24.175]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:24.175]                         envir = ns)
[13:19:24.175]                       envir <- sys.frame(frame)
[13:19:24.175]                       master <- NULL
[13:19:24.175]                       while (!identical(envir, .GlobalEnv) && 
[13:19:24.175]                         !identical(envir, emptyenv())) {
[13:19:24.175]                         if (exists("master", mode = "list", envir = envir, 
[13:19:24.175]                           inherits = FALSE)) {
[13:19:24.175]                           master <- get("master", mode = "list", 
[13:19:24.175]                             envir = envir, inherits = FALSE)
[13:19:24.175]                           if (inherits(master, c("SOCKnode", 
[13:19:24.175]                             "SOCK0node"))) {
[13:19:24.175]                             sendCondition <<- function(cond) {
[13:19:24.175]                               data <- list(type = "VALUE", value = cond, 
[13:19:24.175]                                 success = TRUE)
[13:19:24.175]                               parallel_sendData(master, data)
[13:19:24.175]                             }
[13:19:24.175]                             return(sendCondition)
[13:19:24.175]                           }
[13:19:24.175]                         }
[13:19:24.175]                         frame <- frame + 1L
[13:19:24.175]                         envir <- sys.frame(frame)
[13:19:24.175]                       }
[13:19:24.175]                     }
[13:19:24.175]                     sendCondition <<- function(cond) NULL
[13:19:24.175]                   }
[13:19:24.175]                 })
[13:19:24.175]                 withCallingHandlers({
[13:19:24.175]                   {
[13:19:24.175]                     do.call(function(...) {
[13:19:24.175]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.175]                       if (!identical(...future.globals.maxSize.org, 
[13:19:24.175]                         ...future.globals.maxSize)) {
[13:19:24.175]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.175]                         on.exit(options(oopts), add = TRUE)
[13:19:24.175]                       }
[13:19:24.175]                       {
[13:19:24.175]                         lapply(seq_along(...future.elements_ii), 
[13:19:24.175]                           FUN = function(jj) {
[13:19:24.175]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.175]                             ...future.FUN(...future.X_jj, ...)
[13:19:24.175]                           })
[13:19:24.175]                       }
[13:19:24.175]                     }, args = future.call.arguments)
[13:19:24.175]                   }
[13:19:24.175]                 }, immediateCondition = function(cond) {
[13:19:24.175]                   sendCondition <- ...future.makeSendCondition()
[13:19:24.175]                   sendCondition(cond)
[13:19:24.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.175]                   {
[13:19:24.175]                     inherits <- base::inherits
[13:19:24.175]                     invokeRestart <- base::invokeRestart
[13:19:24.175]                     is.null <- base::is.null
[13:19:24.175]                     muffled <- FALSE
[13:19:24.175]                     if (inherits(cond, "message")) {
[13:19:24.175]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:24.175]                       if (muffled) 
[13:19:24.175]                         invokeRestart("muffleMessage")
[13:19:24.175]                     }
[13:19:24.175]                     else if (inherits(cond, "warning")) {
[13:19:24.175]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:24.175]                       if (muffled) 
[13:19:24.175]                         invokeRestart("muffleWarning")
[13:19:24.175]                     }
[13:19:24.175]                     else if (inherits(cond, "condition")) {
[13:19:24.175]                       if (!is.null(pattern)) {
[13:19:24.175]                         computeRestarts <- base::computeRestarts
[13:19:24.175]                         grepl <- base::grepl
[13:19:24.175]                         restarts <- computeRestarts(cond)
[13:19:24.175]                         for (restart in restarts) {
[13:19:24.175]                           name <- restart$name
[13:19:24.175]                           if (is.null(name)) 
[13:19:24.175]                             next
[13:19:24.175]                           if (!grepl(pattern, name)) 
[13:19:24.175]                             next
[13:19:24.175]                           invokeRestart(restart)
[13:19:24.175]                           muffled <- TRUE
[13:19:24.175]                           break
[13:19:24.175]                         }
[13:19:24.175]                       }
[13:19:24.175]                     }
[13:19:24.175]                     invisible(muffled)
[13:19:24.175]                   }
[13:19:24.175]                   muffleCondition(cond)
[13:19:24.175]                 })
[13:19:24.175]             }))
[13:19:24.175]             future::FutureResult(value = ...future.value$value, 
[13:19:24.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:24.175]                   ...future.rng), globalenv = if (FALSE) 
[13:19:24.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:24.175]                     ...future.globalenv.names))
[13:19:24.175]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:24.175]         }, condition = base::local({
[13:19:24.175]             c <- base::c
[13:19:24.175]             inherits <- base::inherits
[13:19:24.175]             invokeRestart <- base::invokeRestart
[13:19:24.175]             length <- base::length
[13:19:24.175]             list <- base::list
[13:19:24.175]             seq.int <- base::seq.int
[13:19:24.175]             signalCondition <- base::signalCondition
[13:19:24.175]             sys.calls <- base::sys.calls
[13:19:24.175]             `[[` <- base::`[[`
[13:19:24.175]             `+` <- base::`+`
[13:19:24.175]             `<<-` <- base::`<<-`
[13:19:24.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:24.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:24.175]                   3L)]
[13:19:24.175]             }
[13:19:24.175]             function(cond) {
[13:19:24.175]                 is_error <- inherits(cond, "error")
[13:19:24.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:24.175]                   NULL)
[13:19:24.175]                 if (is_error) {
[13:19:24.175]                   sessionInformation <- function() {
[13:19:24.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:24.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:24.175]                       search = base::search(), system = base::Sys.info())
[13:19:24.175]                   }
[13:19:24.175]                   ...future.conditions[[length(...future.conditions) + 
[13:19:24.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:24.175]                     cond$call), session = sessionInformation(), 
[13:19:24.175]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:24.175]                   signalCondition(cond)
[13:19:24.175]                 }
[13:19:24.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:24.175]                 "immediateCondition"))) {
[13:19:24.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:24.175]                   ...future.conditions[[length(...future.conditions) + 
[13:19:24.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:24.175]                   if (TRUE && !signal) {
[13:19:24.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.175]                     {
[13:19:24.175]                       inherits <- base::inherits
[13:19:24.175]                       invokeRestart <- base::invokeRestart
[13:19:24.175]                       is.null <- base::is.null
[13:19:24.175]                       muffled <- FALSE
[13:19:24.175]                       if (inherits(cond, "message")) {
[13:19:24.175]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:24.175]                         if (muffled) 
[13:19:24.175]                           invokeRestart("muffleMessage")
[13:19:24.175]                       }
[13:19:24.175]                       else if (inherits(cond, "warning")) {
[13:19:24.175]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:24.175]                         if (muffled) 
[13:19:24.175]                           invokeRestart("muffleWarning")
[13:19:24.175]                       }
[13:19:24.175]                       else if (inherits(cond, "condition")) {
[13:19:24.175]                         if (!is.null(pattern)) {
[13:19:24.175]                           computeRestarts <- base::computeRestarts
[13:19:24.175]                           grepl <- base::grepl
[13:19:24.175]                           restarts <- computeRestarts(cond)
[13:19:24.175]                           for (restart in restarts) {
[13:19:24.175]                             name <- restart$name
[13:19:24.175]                             if (is.null(name)) 
[13:19:24.175]                               next
[13:19:24.175]                             if (!grepl(pattern, name)) 
[13:19:24.175]                               next
[13:19:24.175]                             invokeRestart(restart)
[13:19:24.175]                             muffled <- TRUE
[13:19:24.175]                             break
[13:19:24.175]                           }
[13:19:24.175]                         }
[13:19:24.175]                       }
[13:19:24.175]                       invisible(muffled)
[13:19:24.175]                     }
[13:19:24.175]                     muffleCondition(cond, pattern = "^muffle")
[13:19:24.175]                   }
[13:19:24.175]                 }
[13:19:24.175]                 else {
[13:19:24.175]                   if (TRUE) {
[13:19:24.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.175]                     {
[13:19:24.175]                       inherits <- base::inherits
[13:19:24.175]                       invokeRestart <- base::invokeRestart
[13:19:24.175]                       is.null <- base::is.null
[13:19:24.175]                       muffled <- FALSE
[13:19:24.175]                       if (inherits(cond, "message")) {
[13:19:24.175]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:24.175]                         if (muffled) 
[13:19:24.175]                           invokeRestart("muffleMessage")
[13:19:24.175]                       }
[13:19:24.175]                       else if (inherits(cond, "warning")) {
[13:19:24.175]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:24.175]                         if (muffled) 
[13:19:24.175]                           invokeRestart("muffleWarning")
[13:19:24.175]                       }
[13:19:24.175]                       else if (inherits(cond, "condition")) {
[13:19:24.175]                         if (!is.null(pattern)) {
[13:19:24.175]                           computeRestarts <- base::computeRestarts
[13:19:24.175]                           grepl <- base::grepl
[13:19:24.175]                           restarts <- computeRestarts(cond)
[13:19:24.175]                           for (restart in restarts) {
[13:19:24.175]                             name <- restart$name
[13:19:24.175]                             if (is.null(name)) 
[13:19:24.175]                               next
[13:19:24.175]                             if (!grepl(pattern, name)) 
[13:19:24.175]                               next
[13:19:24.175]                             invokeRestart(restart)
[13:19:24.175]                             muffled <- TRUE
[13:19:24.175]                             break
[13:19:24.175]                           }
[13:19:24.175]                         }
[13:19:24.175]                       }
[13:19:24.175]                       invisible(muffled)
[13:19:24.175]                     }
[13:19:24.175]                     muffleCondition(cond, pattern = "^muffle")
[13:19:24.175]                   }
[13:19:24.175]                 }
[13:19:24.175]             }
[13:19:24.175]         }))
[13:19:24.175]     }, error = function(ex) {
[13:19:24.175]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:24.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:24.175]                 ...future.rng), started = ...future.startTime, 
[13:19:24.175]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:24.175]             version = "1.8"), class = "FutureResult")
[13:19:24.175]     }, finally = {
[13:19:24.175]         if (!identical(...future.workdir, getwd())) 
[13:19:24.175]             setwd(...future.workdir)
[13:19:24.175]         {
[13:19:24.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:24.175]                 ...future.oldOptions$nwarnings <- NULL
[13:19:24.175]             }
[13:19:24.175]             base::options(...future.oldOptions)
[13:19:24.175]             if (.Platform$OS.type == "windows") {
[13:19:24.175]                 old_names <- names(...future.oldEnvVars)
[13:19:24.175]                 envs <- base::Sys.getenv()
[13:19:24.175]                 names <- names(envs)
[13:19:24.175]                 common <- intersect(names, old_names)
[13:19:24.175]                 added <- setdiff(names, old_names)
[13:19:24.175]                 removed <- setdiff(old_names, names)
[13:19:24.175]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:24.175]                   envs[common]]
[13:19:24.175]                 NAMES <- toupper(changed)
[13:19:24.175]                 args <- list()
[13:19:24.175]                 for (kk in seq_along(NAMES)) {
[13:19:24.175]                   name <- changed[[kk]]
[13:19:24.175]                   NAME <- NAMES[[kk]]
[13:19:24.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.175]                     next
[13:19:24.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:24.175]                 }
[13:19:24.175]                 NAMES <- toupper(added)
[13:19:24.175]                 for (kk in seq_along(NAMES)) {
[13:19:24.175]                   name <- added[[kk]]
[13:19:24.175]                   NAME <- NAMES[[kk]]
[13:19:24.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.175]                     next
[13:19:24.175]                   args[[name]] <- ""
[13:19:24.175]                 }
[13:19:24.175]                 NAMES <- toupper(removed)
[13:19:24.175]                 for (kk in seq_along(NAMES)) {
[13:19:24.175]                   name <- removed[[kk]]
[13:19:24.175]                   NAME <- NAMES[[kk]]
[13:19:24.175]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.175]                     next
[13:19:24.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:24.175]                 }
[13:19:24.175]                 if (length(args) > 0) 
[13:19:24.175]                   base::do.call(base::Sys.setenv, args = args)
[13:19:24.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:24.175]             }
[13:19:24.175]             else {
[13:19:24.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:24.175]             }
[13:19:24.175]             {
[13:19:24.175]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:24.175]                   0L) {
[13:19:24.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:24.175]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:24.175]                   base::options(opts)
[13:19:24.175]                 }
[13:19:24.175]                 {
[13:19:24.175]                   {
[13:19:24.175]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:24.175]                     NULL
[13:19:24.175]                   }
[13:19:24.175]                   options(future.plan = NULL)
[13:19:24.175]                   if (is.na(NA_character_)) 
[13:19:24.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:24.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:24.175]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:24.175]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:24.175]                     envir = parent.frame()) 
[13:19:24.175]                   {
[13:19:24.175]                     if (is.function(workers)) 
[13:19:24.175]                       workers <- workers()
[13:19:24.175]                     workers <- structure(as.integer(workers), 
[13:19:24.175]                       class = class(workers))
[13:19:24.175]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:24.175]                       workers >= 1)
[13:19:24.175]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:24.175]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:24.175]                     }
[13:19:24.175]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:24.175]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:24.175]                       envir = envir)
[13:19:24.175]                     if (!future$lazy) 
[13:19:24.175]                       future <- run(future)
[13:19:24.175]                     invisible(future)
[13:19:24.175]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:24.175]                 }
[13:19:24.175]             }
[13:19:24.175]         }
[13:19:24.175]     })
[13:19:24.175]     if (TRUE) {
[13:19:24.175]         base::sink(type = "output", split = FALSE)
[13:19:24.175]         if (TRUE) {
[13:19:24.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:24.175]         }
[13:19:24.175]         else {
[13:19:24.175]             ...future.result["stdout"] <- base::list(NULL)
[13:19:24.175]         }
[13:19:24.175]         base::close(...future.stdout)
[13:19:24.175]         ...future.stdout <- NULL
[13:19:24.175]     }
[13:19:24.175]     ...future.result$conditions <- ...future.conditions
[13:19:24.175]     ...future.result$finished <- base::Sys.time()
[13:19:24.175]     ...future.result
[13:19:24.175] }
[13:19:24.178] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:19:24.178] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:19:24.178] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:19:24.178] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:24.179] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:24.179] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:19:24.179] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:19:24.179] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:24.180] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:24.180] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:24.180] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:24.180] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:19:24.181] MultisessionFuture started
[13:19:24.181] - Launch lazy future ... done
[13:19:24.181] run() for ‘MultisessionFuture’ ... done
[13:19:24.181] Created future:
[13:19:24.182] MultisessionFuture:
[13:19:24.182] Label: ‘future_lapply-1’
[13:19:24.182] Expression:
[13:19:24.182] {
[13:19:24.182]     do.call(function(...) {
[13:19:24.182]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.182]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:24.182]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.182]             on.exit(options(oopts), add = TRUE)
[13:19:24.182]         }
[13:19:24.182]         {
[13:19:24.182]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:24.182]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.182]                 ...future.FUN(...future.X_jj, ...)
[13:19:24.182]             })
[13:19:24.182]         }
[13:19:24.182]     }, args = future.call.arguments)
[13:19:24.182] }
[13:19:24.182] Lazy evaluation: FALSE
[13:19:24.182] Asynchronous evaluation: TRUE
[13:19:24.182] Local evaluation: TRUE
[13:19:24.182] Environment: R_GlobalEnv
[13:19:24.182] Capture standard output: TRUE
[13:19:24.182] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:24.182] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:24.182] Packages: <none>
[13:19:24.182] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:24.182] Resolved: FALSE
[13:19:24.182] Value: <not collected>
[13:19:24.182] Conditions captured: <none>
[13:19:24.182] Early signaling: FALSE
[13:19:24.182] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:24.182] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:24.193] Chunk #1 of 2 ... DONE
[13:19:24.193] Chunk #2 of 2 ...
[13:19:24.193]  - Finding globals in 'X' for chunk #2 ...
[13:19:24.193] getGlobalsAndPackages() ...
[13:19:24.193] Searching for globals...
[13:19:24.194] 
[13:19:24.194] Searching for globals ... DONE
[13:19:24.194] - globals: [0] <none>
[13:19:24.194] getGlobalsAndPackages() ... DONE
[13:19:24.194]    + additional globals found: [n=0] 
[13:19:24.194]    + additional namespaces needed: [n=0] 
[13:19:24.194]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:24.194]  - seeds: <none>
[13:19:24.194] getGlobalsAndPackages() ...
[13:19:24.195] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:24.195] Resolving globals: FALSE
[13:19:24.195] Tweak future expression to call with '...' arguments ...
[13:19:24.195] {
[13:19:24.195]     do.call(function(...) {
[13:19:24.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:24.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.195]             on.exit(options(oopts), add = TRUE)
[13:19:24.195]         }
[13:19:24.195]         {
[13:19:24.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:24.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.195]                 ...future.FUN(...future.X_jj, ...)
[13:19:24.195]             })
[13:19:24.195]         }
[13:19:24.195]     }, args = future.call.arguments)
[13:19:24.195] }
[13:19:24.195] Tweak future expression to call with '...' arguments ... DONE
[13:19:24.195] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:24.196] 
[13:19:24.196] getGlobalsAndPackages() ... DONE
[13:19:24.196] run() for ‘Future’ ...
[13:19:24.196] - state: ‘created’
[13:19:24.196] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:24.211] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:24.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:24.211]   - Field: ‘node’
[13:19:24.211]   - Field: ‘label’
[13:19:24.211]   - Field: ‘local’
[13:19:24.211]   - Field: ‘owner’
[13:19:24.212]   - Field: ‘envir’
[13:19:24.212]   - Field: ‘workers’
[13:19:24.212]   - Field: ‘packages’
[13:19:24.212]   - Field: ‘gc’
[13:19:24.212]   - Field: ‘conditions’
[13:19:24.212]   - Field: ‘persistent’
[13:19:24.212]   - Field: ‘expr’
[13:19:24.212]   - Field: ‘uuid’
[13:19:24.212]   - Field: ‘seed’
[13:19:24.212]   - Field: ‘version’
[13:19:24.212]   - Field: ‘result’
[13:19:24.213]   - Field: ‘asynchronous’
[13:19:24.213]   - Field: ‘calls’
[13:19:24.213]   - Field: ‘globals’
[13:19:24.213]   - Field: ‘stdout’
[13:19:24.213]   - Field: ‘earlySignal’
[13:19:24.213]   - Field: ‘lazy’
[13:19:24.213]   - Field: ‘state’
[13:19:24.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:24.213] - Launch lazy future ...
[13:19:24.214] Packages needed by the future expression (n = 0): <none>
[13:19:24.214] Packages needed by future strategies (n = 0): <none>
[13:19:24.214] {
[13:19:24.214]     {
[13:19:24.214]         {
[13:19:24.214]             ...future.startTime <- base::Sys.time()
[13:19:24.214]             {
[13:19:24.214]                 {
[13:19:24.214]                   {
[13:19:24.214]                     {
[13:19:24.214]                       base::local({
[13:19:24.214]                         has_future <- base::requireNamespace("future", 
[13:19:24.214]                           quietly = TRUE)
[13:19:24.214]                         if (has_future) {
[13:19:24.214]                           ns <- base::getNamespace("future")
[13:19:24.214]                           version <- ns[[".package"]][["version"]]
[13:19:24.214]                           if (is.null(version)) 
[13:19:24.214]                             version <- utils::packageVersion("future")
[13:19:24.214]                         }
[13:19:24.214]                         else {
[13:19:24.214]                           version <- NULL
[13:19:24.214]                         }
[13:19:24.214]                         if (!has_future || version < "1.8.0") {
[13:19:24.214]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:24.214]                             "", base::R.version$version.string), 
[13:19:24.214]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:24.214]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:24.214]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:24.214]                               "release", "version")], collapse = " "), 
[13:19:24.214]                             hostname = base::Sys.info()[["nodename"]])
[13:19:24.214]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:24.214]                             info)
[13:19:24.214]                           info <- base::paste(info, collapse = "; ")
[13:19:24.214]                           if (!has_future) {
[13:19:24.214]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:24.214]                               info)
[13:19:24.214]                           }
[13:19:24.214]                           else {
[13:19:24.214]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:24.214]                               info, version)
[13:19:24.214]                           }
[13:19:24.214]                           base::stop(msg)
[13:19:24.214]                         }
[13:19:24.214]                       })
[13:19:24.214]                     }
[13:19:24.214]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:24.214]                     base::options(mc.cores = 1L)
[13:19:24.214]                   }
[13:19:24.214]                   options(future.plan = NULL)
[13:19:24.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:24.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:24.214]                 }
[13:19:24.214]                 ...future.workdir <- getwd()
[13:19:24.214]             }
[13:19:24.214]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:24.214]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:24.214]         }
[13:19:24.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:24.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:24.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:24.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:24.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:24.214]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:24.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:24.214]             base::names(...future.oldOptions))
[13:19:24.214]     }
[13:19:24.214]     if (FALSE) {
[13:19:24.214]     }
[13:19:24.214]     else {
[13:19:24.214]         if (TRUE) {
[13:19:24.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:24.214]                 open = "w")
[13:19:24.214]         }
[13:19:24.214]         else {
[13:19:24.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:24.214]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:24.214]         }
[13:19:24.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:24.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:24.214]             base::sink(type = "output", split = FALSE)
[13:19:24.214]             base::close(...future.stdout)
[13:19:24.214]         }, add = TRUE)
[13:19:24.214]     }
[13:19:24.214]     ...future.frame <- base::sys.nframe()
[13:19:24.214]     ...future.conditions <- base::list()
[13:19:24.214]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:24.214]     if (FALSE) {
[13:19:24.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:24.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:24.214]     }
[13:19:24.214]     ...future.result <- base::tryCatch({
[13:19:24.214]         base::withCallingHandlers({
[13:19:24.214]             ...future.value <- base::withVisible(base::local({
[13:19:24.214]                 ...future.makeSendCondition <- local({
[13:19:24.214]                   sendCondition <- NULL
[13:19:24.214]                   function(frame = 1L) {
[13:19:24.214]                     if (is.function(sendCondition)) 
[13:19:24.214]                       return(sendCondition)
[13:19:24.214]                     ns <- getNamespace("parallel")
[13:19:24.214]                     if (exists("sendData", mode = "function", 
[13:19:24.214]                       envir = ns)) {
[13:19:24.214]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:24.214]                         envir = ns)
[13:19:24.214]                       envir <- sys.frame(frame)
[13:19:24.214]                       master <- NULL
[13:19:24.214]                       while (!identical(envir, .GlobalEnv) && 
[13:19:24.214]                         !identical(envir, emptyenv())) {
[13:19:24.214]                         if (exists("master", mode = "list", envir = envir, 
[13:19:24.214]                           inherits = FALSE)) {
[13:19:24.214]                           master <- get("master", mode = "list", 
[13:19:24.214]                             envir = envir, inherits = FALSE)
[13:19:24.214]                           if (inherits(master, c("SOCKnode", 
[13:19:24.214]                             "SOCK0node"))) {
[13:19:24.214]                             sendCondition <<- function(cond) {
[13:19:24.214]                               data <- list(type = "VALUE", value = cond, 
[13:19:24.214]                                 success = TRUE)
[13:19:24.214]                               parallel_sendData(master, data)
[13:19:24.214]                             }
[13:19:24.214]                             return(sendCondition)
[13:19:24.214]                           }
[13:19:24.214]                         }
[13:19:24.214]                         frame <- frame + 1L
[13:19:24.214]                         envir <- sys.frame(frame)
[13:19:24.214]                       }
[13:19:24.214]                     }
[13:19:24.214]                     sendCondition <<- function(cond) NULL
[13:19:24.214]                   }
[13:19:24.214]                 })
[13:19:24.214]                 withCallingHandlers({
[13:19:24.214]                   {
[13:19:24.214]                     do.call(function(...) {
[13:19:24.214]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.214]                       if (!identical(...future.globals.maxSize.org, 
[13:19:24.214]                         ...future.globals.maxSize)) {
[13:19:24.214]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.214]                         on.exit(options(oopts), add = TRUE)
[13:19:24.214]                       }
[13:19:24.214]                       {
[13:19:24.214]                         lapply(seq_along(...future.elements_ii), 
[13:19:24.214]                           FUN = function(jj) {
[13:19:24.214]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.214]                             ...future.FUN(...future.X_jj, ...)
[13:19:24.214]                           })
[13:19:24.214]                       }
[13:19:24.214]                     }, args = future.call.arguments)
[13:19:24.214]                   }
[13:19:24.214]                 }, immediateCondition = function(cond) {
[13:19:24.214]                   sendCondition <- ...future.makeSendCondition()
[13:19:24.214]                   sendCondition(cond)
[13:19:24.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.214]                   {
[13:19:24.214]                     inherits <- base::inherits
[13:19:24.214]                     invokeRestart <- base::invokeRestart
[13:19:24.214]                     is.null <- base::is.null
[13:19:24.214]                     muffled <- FALSE
[13:19:24.214]                     if (inherits(cond, "message")) {
[13:19:24.214]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:24.214]                       if (muffled) 
[13:19:24.214]                         invokeRestart("muffleMessage")
[13:19:24.214]                     }
[13:19:24.214]                     else if (inherits(cond, "warning")) {
[13:19:24.214]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:24.214]                       if (muffled) 
[13:19:24.214]                         invokeRestart("muffleWarning")
[13:19:24.214]                     }
[13:19:24.214]                     else if (inherits(cond, "condition")) {
[13:19:24.214]                       if (!is.null(pattern)) {
[13:19:24.214]                         computeRestarts <- base::computeRestarts
[13:19:24.214]                         grepl <- base::grepl
[13:19:24.214]                         restarts <- computeRestarts(cond)
[13:19:24.214]                         for (restart in restarts) {
[13:19:24.214]                           name <- restart$name
[13:19:24.214]                           if (is.null(name)) 
[13:19:24.214]                             next
[13:19:24.214]                           if (!grepl(pattern, name)) 
[13:19:24.214]                             next
[13:19:24.214]                           invokeRestart(restart)
[13:19:24.214]                           muffled <- TRUE
[13:19:24.214]                           break
[13:19:24.214]                         }
[13:19:24.214]                       }
[13:19:24.214]                     }
[13:19:24.214]                     invisible(muffled)
[13:19:24.214]                   }
[13:19:24.214]                   muffleCondition(cond)
[13:19:24.214]                 })
[13:19:24.214]             }))
[13:19:24.214]             future::FutureResult(value = ...future.value$value, 
[13:19:24.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:24.214]                   ...future.rng), globalenv = if (FALSE) 
[13:19:24.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:24.214]                     ...future.globalenv.names))
[13:19:24.214]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:24.214]         }, condition = base::local({
[13:19:24.214]             c <- base::c
[13:19:24.214]             inherits <- base::inherits
[13:19:24.214]             invokeRestart <- base::invokeRestart
[13:19:24.214]             length <- base::length
[13:19:24.214]             list <- base::list
[13:19:24.214]             seq.int <- base::seq.int
[13:19:24.214]             signalCondition <- base::signalCondition
[13:19:24.214]             sys.calls <- base::sys.calls
[13:19:24.214]             `[[` <- base::`[[`
[13:19:24.214]             `+` <- base::`+`
[13:19:24.214]             `<<-` <- base::`<<-`
[13:19:24.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:24.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:24.214]                   3L)]
[13:19:24.214]             }
[13:19:24.214]             function(cond) {
[13:19:24.214]                 is_error <- inherits(cond, "error")
[13:19:24.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:24.214]                   NULL)
[13:19:24.214]                 if (is_error) {
[13:19:24.214]                   sessionInformation <- function() {
[13:19:24.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:24.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:24.214]                       search = base::search(), system = base::Sys.info())
[13:19:24.214]                   }
[13:19:24.214]                   ...future.conditions[[length(...future.conditions) + 
[13:19:24.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:24.214]                     cond$call), session = sessionInformation(), 
[13:19:24.214]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:24.214]                   signalCondition(cond)
[13:19:24.214]                 }
[13:19:24.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:24.214]                 "immediateCondition"))) {
[13:19:24.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:24.214]                   ...future.conditions[[length(...future.conditions) + 
[13:19:24.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:24.214]                   if (TRUE && !signal) {
[13:19:24.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.214]                     {
[13:19:24.214]                       inherits <- base::inherits
[13:19:24.214]                       invokeRestart <- base::invokeRestart
[13:19:24.214]                       is.null <- base::is.null
[13:19:24.214]                       muffled <- FALSE
[13:19:24.214]                       if (inherits(cond, "message")) {
[13:19:24.214]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:24.214]                         if (muffled) 
[13:19:24.214]                           invokeRestart("muffleMessage")
[13:19:24.214]                       }
[13:19:24.214]                       else if (inherits(cond, "warning")) {
[13:19:24.214]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:24.214]                         if (muffled) 
[13:19:24.214]                           invokeRestart("muffleWarning")
[13:19:24.214]                       }
[13:19:24.214]                       else if (inherits(cond, "condition")) {
[13:19:24.214]                         if (!is.null(pattern)) {
[13:19:24.214]                           computeRestarts <- base::computeRestarts
[13:19:24.214]                           grepl <- base::grepl
[13:19:24.214]                           restarts <- computeRestarts(cond)
[13:19:24.214]                           for (restart in restarts) {
[13:19:24.214]                             name <- restart$name
[13:19:24.214]                             if (is.null(name)) 
[13:19:24.214]                               next
[13:19:24.214]                             if (!grepl(pattern, name)) 
[13:19:24.214]                               next
[13:19:24.214]                             invokeRestart(restart)
[13:19:24.214]                             muffled <- TRUE
[13:19:24.214]                             break
[13:19:24.214]                           }
[13:19:24.214]                         }
[13:19:24.214]                       }
[13:19:24.214]                       invisible(muffled)
[13:19:24.214]                     }
[13:19:24.214]                     muffleCondition(cond, pattern = "^muffle")
[13:19:24.214]                   }
[13:19:24.214]                 }
[13:19:24.214]                 else {
[13:19:24.214]                   if (TRUE) {
[13:19:24.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.214]                     {
[13:19:24.214]                       inherits <- base::inherits
[13:19:24.214]                       invokeRestart <- base::invokeRestart
[13:19:24.214]                       is.null <- base::is.null
[13:19:24.214]                       muffled <- FALSE
[13:19:24.214]                       if (inherits(cond, "message")) {
[13:19:24.214]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:24.214]                         if (muffled) 
[13:19:24.214]                           invokeRestart("muffleMessage")
[13:19:24.214]                       }
[13:19:24.214]                       else if (inherits(cond, "warning")) {
[13:19:24.214]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:24.214]                         if (muffled) 
[13:19:24.214]                           invokeRestart("muffleWarning")
[13:19:24.214]                       }
[13:19:24.214]                       else if (inherits(cond, "condition")) {
[13:19:24.214]                         if (!is.null(pattern)) {
[13:19:24.214]                           computeRestarts <- base::computeRestarts
[13:19:24.214]                           grepl <- base::grepl
[13:19:24.214]                           restarts <- computeRestarts(cond)
[13:19:24.214]                           for (restart in restarts) {
[13:19:24.214]                             name <- restart$name
[13:19:24.214]                             if (is.null(name)) 
[13:19:24.214]                               next
[13:19:24.214]                             if (!grepl(pattern, name)) 
[13:19:24.214]                               next
[13:19:24.214]                             invokeRestart(restart)
[13:19:24.214]                             muffled <- TRUE
[13:19:24.214]                             break
[13:19:24.214]                           }
[13:19:24.214]                         }
[13:19:24.214]                       }
[13:19:24.214]                       invisible(muffled)
[13:19:24.214]                     }
[13:19:24.214]                     muffleCondition(cond, pattern = "^muffle")
[13:19:24.214]                   }
[13:19:24.214]                 }
[13:19:24.214]             }
[13:19:24.214]         }))
[13:19:24.214]     }, error = function(ex) {
[13:19:24.214]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:24.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:24.214]                 ...future.rng), started = ...future.startTime, 
[13:19:24.214]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:24.214]             version = "1.8"), class = "FutureResult")
[13:19:24.214]     }, finally = {
[13:19:24.214]         if (!identical(...future.workdir, getwd())) 
[13:19:24.214]             setwd(...future.workdir)
[13:19:24.214]         {
[13:19:24.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:24.214]                 ...future.oldOptions$nwarnings <- NULL
[13:19:24.214]             }
[13:19:24.214]             base::options(...future.oldOptions)
[13:19:24.214]             if (.Platform$OS.type == "windows") {
[13:19:24.214]                 old_names <- names(...future.oldEnvVars)
[13:19:24.214]                 envs <- base::Sys.getenv()
[13:19:24.214]                 names <- names(envs)
[13:19:24.214]                 common <- intersect(names, old_names)
[13:19:24.214]                 added <- setdiff(names, old_names)
[13:19:24.214]                 removed <- setdiff(old_names, names)
[13:19:24.214]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:24.214]                   envs[common]]
[13:19:24.214]                 NAMES <- toupper(changed)
[13:19:24.214]                 args <- list()
[13:19:24.214]                 for (kk in seq_along(NAMES)) {
[13:19:24.214]                   name <- changed[[kk]]
[13:19:24.214]                   NAME <- NAMES[[kk]]
[13:19:24.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.214]                     next
[13:19:24.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:24.214]                 }
[13:19:24.214]                 NAMES <- toupper(added)
[13:19:24.214]                 for (kk in seq_along(NAMES)) {
[13:19:24.214]                   name <- added[[kk]]
[13:19:24.214]                   NAME <- NAMES[[kk]]
[13:19:24.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.214]                     next
[13:19:24.214]                   args[[name]] <- ""
[13:19:24.214]                 }
[13:19:24.214]                 NAMES <- toupper(removed)
[13:19:24.214]                 for (kk in seq_along(NAMES)) {
[13:19:24.214]                   name <- removed[[kk]]
[13:19:24.214]                   NAME <- NAMES[[kk]]
[13:19:24.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.214]                     next
[13:19:24.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:24.214]                 }
[13:19:24.214]                 if (length(args) > 0) 
[13:19:24.214]                   base::do.call(base::Sys.setenv, args = args)
[13:19:24.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:24.214]             }
[13:19:24.214]             else {
[13:19:24.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:24.214]             }
[13:19:24.214]             {
[13:19:24.214]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:24.214]                   0L) {
[13:19:24.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:24.214]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:24.214]                   base::options(opts)
[13:19:24.214]                 }
[13:19:24.214]                 {
[13:19:24.214]                   {
[13:19:24.214]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:24.214]                     NULL
[13:19:24.214]                   }
[13:19:24.214]                   options(future.plan = NULL)
[13:19:24.214]                   if (is.na(NA_character_)) 
[13:19:24.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:24.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:24.214]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:24.214]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:24.214]                     envir = parent.frame()) 
[13:19:24.214]                   {
[13:19:24.214]                     if (is.function(workers)) 
[13:19:24.214]                       workers <- workers()
[13:19:24.214]                     workers <- structure(as.integer(workers), 
[13:19:24.214]                       class = class(workers))
[13:19:24.214]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:24.214]                       workers >= 1)
[13:19:24.214]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:24.214]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:24.214]                     }
[13:19:24.214]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:24.214]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:24.214]                       envir = envir)
[13:19:24.214]                     if (!future$lazy) 
[13:19:24.214]                       future <- run(future)
[13:19:24.214]                     invisible(future)
[13:19:24.214]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:24.214]                 }
[13:19:24.214]             }
[13:19:24.214]         }
[13:19:24.214]     })
[13:19:24.214]     if (TRUE) {
[13:19:24.214]         base::sink(type = "output", split = FALSE)
[13:19:24.214]         if (TRUE) {
[13:19:24.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:24.214]         }
[13:19:24.214]         else {
[13:19:24.214]             ...future.result["stdout"] <- base::list(NULL)
[13:19:24.214]         }
[13:19:24.214]         base::close(...future.stdout)
[13:19:24.214]         ...future.stdout <- NULL
[13:19:24.214]     }
[13:19:24.214]     ...future.result$conditions <- ...future.conditions
[13:19:24.214]     ...future.result$finished <- base::Sys.time()
[13:19:24.214]     ...future.result
[13:19:24.214] }
[13:19:24.217] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:19:24.217] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:19:24.218] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:19:24.218] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:24.218] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:24.218] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:19:24.219] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:19:24.219] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:24.219] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:24.219] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:24.220] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:24.220] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:19:24.220] MultisessionFuture started
[13:19:24.221] - Launch lazy future ... done
[13:19:24.221] run() for ‘MultisessionFuture’ ... done
[13:19:24.221] Created future:
[13:19:24.221] MultisessionFuture:
[13:19:24.221] Label: ‘future_lapply-2’
[13:19:24.221] Expression:
[13:19:24.221] {
[13:19:24.221]     do.call(function(...) {
[13:19:24.221]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.221]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:24.221]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.221]             on.exit(options(oopts), add = TRUE)
[13:19:24.221]         }
[13:19:24.221]         {
[13:19:24.221]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:24.221]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.221]                 ...future.FUN(...future.X_jj, ...)
[13:19:24.221]             })
[13:19:24.221]         }
[13:19:24.221]     }, args = future.call.arguments)
[13:19:24.221] }
[13:19:24.221] Lazy evaluation: FALSE
[13:19:24.221] Asynchronous evaluation: TRUE
[13:19:24.221] Local evaluation: TRUE
[13:19:24.221] Environment: R_GlobalEnv
[13:19:24.221] Capture standard output: TRUE
[13:19:24.221] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:24.221] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:24.221] Packages: <none>
[13:19:24.221] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:24.221] Resolved: FALSE
[13:19:24.221] Value: <not collected>
[13:19:24.221] Conditions captured: <none>
[13:19:24.221] Early signaling: FALSE
[13:19:24.221] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:24.221] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:24.233] Chunk #2 of 2 ... DONE
[13:19:24.233] Launching 2 futures (chunks) ... DONE
[13:19:24.233] Resolving 2 futures (chunks) ...
[13:19:24.233] resolve() on list ...
[13:19:24.233]  recursive: 0
[13:19:24.233]  length: 2
[13:19:24.233] 
[13:19:24.276] receiveMessageFromWorker() for ClusterFuture ...
[13:19:24.276] - Validating connection of MultisessionFuture
[13:19:24.276] - received message: FutureResult
[13:19:24.276] - Received FutureResult
[13:19:24.276] - Erased future from FutureRegistry
[13:19:24.277] result() for ClusterFuture ...
[13:19:24.277] - result already collected: FutureResult
[13:19:24.277] result() for ClusterFuture ... done
[13:19:24.277] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:24.277] Future #2
[13:19:24.277] result() for ClusterFuture ...
[13:19:24.277] - result already collected: FutureResult
[13:19:24.277] result() for ClusterFuture ... done
[13:19:24.277] result() for ClusterFuture ...
[13:19:24.278] - result already collected: FutureResult
[13:19:24.278] result() for ClusterFuture ... done
[13:19:24.278] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:24.278] - nx: 2
[13:19:24.278] - relay: TRUE
[13:19:24.278] - stdout: TRUE
[13:19:24.278] - signal: TRUE
[13:19:24.278] - resignal: FALSE
[13:19:24.278] - force: TRUE
[13:19:24.278] - relayed: [n=2] FALSE, FALSE
[13:19:24.278] - queued futures: [n=2] FALSE, FALSE
[13:19:24.278]  - until=1
[13:19:24.279]  - relaying element #1
[13:19:24.279] - relayed: [n=2] FALSE, FALSE
[13:19:24.279] - queued futures: [n=2] FALSE, TRUE
[13:19:24.279] signalConditionsASAP(NULL, pos=2) ... done
[13:19:24.279]  length: 1 (resolved future 2)
[13:19:24.731] receiveMessageFromWorker() for ClusterFuture ...
[13:19:24.731] - Validating connection of MultisessionFuture
[13:19:24.731] - received message: FutureResult
[13:19:24.732] - Received FutureResult
[13:19:24.732] - Erased future from FutureRegistry
[13:19:24.732] result() for ClusterFuture ...
[13:19:24.732] - result already collected: FutureResult
[13:19:24.732] result() for ClusterFuture ... done
[13:19:24.732] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:24.732] Future #1
[13:19:24.732] result() for ClusterFuture ...
[13:19:24.732] - result already collected: FutureResult
[13:19:24.733] result() for ClusterFuture ... done
[13:19:24.733] result() for ClusterFuture ...
[13:19:24.733] - result already collected: FutureResult
[13:19:24.733] result() for ClusterFuture ... done
[13:19:24.733] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:24.733] - nx: 2
[13:19:24.733] - relay: TRUE
[13:19:24.733] - stdout: TRUE
[13:19:24.733] - signal: TRUE
[13:19:24.733] - resignal: FALSE
[13:19:24.733] - force: TRUE
[13:19:24.734] - relayed: [n=2] FALSE, FALSE
[13:19:24.734] - queued futures: [n=2] FALSE, TRUE
[13:19:24.734]  - until=1
[13:19:24.734]  - relaying element #1
[13:19:24.734] result() for ClusterFuture ...
[13:19:24.734] - result already collected: FutureResult
[13:19:24.734] result() for ClusterFuture ... done
[13:19:24.734] result() for ClusterFuture ...
[13:19:24.734] - result already collected: FutureResult
[13:19:24.734] result() for ClusterFuture ... done
[13:19:24.735] result() for ClusterFuture ...
[13:19:24.735] - result already collected: FutureResult
[13:19:24.735] result() for ClusterFuture ... done
[13:19:24.735] result() for ClusterFuture ...
[13:19:24.735] - result already collected: FutureResult
[13:19:24.735] result() for ClusterFuture ... done
[13:19:24.735] - relayed: [n=2] TRUE, FALSE
[13:19:24.735] - queued futures: [n=2] TRUE, TRUE
[13:19:24.735] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:24.735]  length: 0 (resolved future 1)
[13:19:24.736] Relaying remaining futures
[13:19:24.736] signalConditionsASAP(NULL, pos=0) ...
[13:19:24.736] - nx: 2
[13:19:24.736] - relay: TRUE
[13:19:24.736] - stdout: TRUE
[13:19:24.736] - signal: TRUE
[13:19:24.736] - resignal: FALSE
[13:19:24.736] - force: TRUE
[13:19:24.736] - relayed: [n=2] TRUE, FALSE
[13:19:24.736] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:24.736]  - relaying element #2
[13:19:24.737] result() for ClusterFuture ...
[13:19:24.737] - result already collected: FutureResult
[13:19:24.739] result() for ClusterFuture ... done
[13:19:24.739] result() for ClusterFuture ...
[13:19:24.739] - result already collected: FutureResult
[13:19:24.739] result() for ClusterFuture ... done
[13:19:24.739] result() for ClusterFuture ...
[13:19:24.739] - result already collected: FutureResult
[13:19:24.739] result() for ClusterFuture ... done
[13:19:24.739] result() for ClusterFuture ...
[13:19:24.739] - result already collected: FutureResult
[13:19:24.739] result() for ClusterFuture ... done
[13:19:24.740] - relayed: [n=2] TRUE, TRUE
[13:19:24.740] - queued futures: [n=2] TRUE, TRUE
[13:19:24.740] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:19:24.740] resolve() on list ... DONE
[13:19:24.740] result() for ClusterFuture ...
[13:19:24.740] - result already collected: FutureResult
[13:19:24.740] result() for ClusterFuture ... done
[13:19:24.740] result() for ClusterFuture ...
[13:19:24.740] - result already collected: FutureResult
[13:19:24.740] result() for ClusterFuture ... done
[13:19:24.740] result() for ClusterFuture ...
[13:19:24.740] - result already collected: FutureResult
[13:19:24.741] result() for ClusterFuture ... done
[13:19:24.741] result() for ClusterFuture ...
[13:19:24.741] - result already collected: FutureResult
[13:19:24.741] result() for ClusterFuture ... done
[13:19:24.741]  - Number of value chunks collected: 2
[13:19:24.741] Resolving 2 futures (chunks) ... DONE
[13:19:24.741] Reducing values from 2 chunks ...
[13:19:24.741]  - Number of values collected after concatenation: 2
[13:19:24.741]  - Number of values expected: 2
[13:19:24.741] Reducing values from 2 chunks ... DONE
[13:19:24.742] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:19:24.742] future_lapply() ...
[13:19:24.746] Number of chunks: 2
[13:19:24.746] getGlobalsAndPackagesXApply() ...
[13:19:24.746]  - future.globals: TRUE
[13:19:24.746] getGlobalsAndPackages() ...
[13:19:24.746] Searching for globals...
[13:19:24.748] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:19:24.748] Searching for globals ... DONE
[13:19:24.748] Resolving globals: FALSE
[13:19:24.748] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:19:24.749] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:19:24.749] - globals: [1] ‘FUN’
[13:19:24.749] 
[13:19:24.749] getGlobalsAndPackages() ... DONE
[13:19:24.749]  - globals found/used: [n=1] ‘FUN’
[13:19:24.750]  - needed namespaces: [n=0] 
[13:19:24.750] Finding globals ... DONE
[13:19:24.750]  - use_args: TRUE
[13:19:24.750]  - Getting '...' globals ...
[13:19:24.750] resolve() on list ...
[13:19:24.750]  recursive: 0
[13:19:24.751]  length: 1
[13:19:24.751]  elements: ‘...’
[13:19:24.751]  length: 0 (resolved future 1)
[13:19:24.751] resolve() on list ... DONE
[13:19:24.751]    - '...' content: [n=0] 
[13:19:24.751] List of 1
[13:19:24.751]  $ ...: list()
[13:19:24.751]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:24.751]  - attr(*, "where")=List of 1
[13:19:24.751]   ..$ ...:<environment: 0x562006503be0> 
[13:19:24.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:24.751]  - attr(*, "resolved")= logi TRUE
[13:19:24.751]  - attr(*, "total_size")= num NA
[13:19:24.754]  - Getting '...' globals ... DONE
[13:19:24.755] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:19:24.755] List of 2
[13:19:24.755]  $ ...future.FUN:function (x)  
[13:19:24.755]  $ ...          : list()
[13:19:24.755]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:19:24.755]  - attr(*, "where")=List of 2
[13:19:24.755]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:24.755]   ..$ ...          :<environment: 0x562006503be0> 
[13:19:24.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:24.755]  - attr(*, "resolved")= logi FALSE
[13:19:24.755]  - attr(*, "total_size")= num 4720
[13:19:24.758] Packages to be attached in all futures: [n=0] 
[13:19:24.758] getGlobalsAndPackagesXApply() ... DONE
[13:19:24.758] Number of futures (= number of chunks): 2
[13:19:24.758] Launching 2 futures (chunks) ...
[13:19:24.758] Chunk #1 of 2 ...
[13:19:24.758]  - Finding globals in 'X' for chunk #1 ...
[13:19:24.758] getGlobalsAndPackages() ...
[13:19:24.758] Searching for globals...
[13:19:24.759] 
[13:19:24.759] Searching for globals ... DONE
[13:19:24.759] - globals: [0] <none>
[13:19:24.759] getGlobalsAndPackages() ... DONE
[13:19:24.759]    + additional globals found: [n=0] 
[13:19:24.759]    + additional namespaces needed: [n=0] 
[13:19:24.759]  - Finding globals in 'X' for chunk #1 ... DONE
[13:19:24.759]  - seeds: <none>
[13:19:24.759] getGlobalsAndPackages() ...
[13:19:24.759] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:24.760] Resolving globals: FALSE
[13:19:24.760] Tweak future expression to call with '...' arguments ...
[13:19:24.760] {
[13:19:24.760]     do.call(function(...) {
[13:19:24.760]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.760]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:24.760]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.760]             on.exit(options(oopts), add = TRUE)
[13:19:24.760]         }
[13:19:24.760]         {
[13:19:24.760]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:24.760]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.760]                 ...future.FUN(...future.X_jj, ...)
[13:19:24.760]             })
[13:19:24.760]         }
[13:19:24.760]     }, args = future.call.arguments)
[13:19:24.760] }
[13:19:24.760] Tweak future expression to call with '...' arguments ... DONE
[13:19:24.760] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:24.760] 
[13:19:24.761] getGlobalsAndPackages() ... DONE
[13:19:24.761] run() for ‘Future’ ...
[13:19:24.761] - state: ‘created’
[13:19:24.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:24.778] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:24.778] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:24.778]   - Field: ‘node’
[13:19:24.778]   - Field: ‘label’
[13:19:24.778]   - Field: ‘local’
[13:19:24.778]   - Field: ‘owner’
[13:19:24.778]   - Field: ‘envir’
[13:19:24.778]   - Field: ‘workers’
[13:19:24.778]   - Field: ‘packages’
[13:19:24.779]   - Field: ‘gc’
[13:19:24.779]   - Field: ‘conditions’
[13:19:24.779]   - Field: ‘persistent’
[13:19:24.779]   - Field: ‘expr’
[13:19:24.779]   - Field: ‘uuid’
[13:19:24.779]   - Field: ‘seed’
[13:19:24.779]   - Field: ‘version’
[13:19:24.779]   - Field: ‘result’
[13:19:24.779]   - Field: ‘asynchronous’
[13:19:24.779]   - Field: ‘calls’
[13:19:24.779]   - Field: ‘globals’
[13:19:24.780]   - Field: ‘stdout’
[13:19:24.780]   - Field: ‘earlySignal’
[13:19:24.780]   - Field: ‘lazy’
[13:19:24.780]   - Field: ‘state’
[13:19:24.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:24.780] - Launch lazy future ...
[13:19:24.780] Packages needed by the future expression (n = 0): <none>
[13:19:24.780] Packages needed by future strategies (n = 0): <none>
[13:19:24.781] {
[13:19:24.781]     {
[13:19:24.781]         {
[13:19:24.781]             ...future.startTime <- base::Sys.time()
[13:19:24.781]             {
[13:19:24.781]                 {
[13:19:24.781]                   {
[13:19:24.781]                     {
[13:19:24.781]                       base::local({
[13:19:24.781]                         has_future <- base::requireNamespace("future", 
[13:19:24.781]                           quietly = TRUE)
[13:19:24.781]                         if (has_future) {
[13:19:24.781]                           ns <- base::getNamespace("future")
[13:19:24.781]                           version <- ns[[".package"]][["version"]]
[13:19:24.781]                           if (is.null(version)) 
[13:19:24.781]                             version <- utils::packageVersion("future")
[13:19:24.781]                         }
[13:19:24.781]                         else {
[13:19:24.781]                           version <- NULL
[13:19:24.781]                         }
[13:19:24.781]                         if (!has_future || version < "1.8.0") {
[13:19:24.781]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:24.781]                             "", base::R.version$version.string), 
[13:19:24.781]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:24.781]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:24.781]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:24.781]                               "release", "version")], collapse = " "), 
[13:19:24.781]                             hostname = base::Sys.info()[["nodename"]])
[13:19:24.781]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:24.781]                             info)
[13:19:24.781]                           info <- base::paste(info, collapse = "; ")
[13:19:24.781]                           if (!has_future) {
[13:19:24.781]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:24.781]                               info)
[13:19:24.781]                           }
[13:19:24.781]                           else {
[13:19:24.781]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:24.781]                               info, version)
[13:19:24.781]                           }
[13:19:24.781]                           base::stop(msg)
[13:19:24.781]                         }
[13:19:24.781]                       })
[13:19:24.781]                     }
[13:19:24.781]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:24.781]                     base::options(mc.cores = 1L)
[13:19:24.781]                   }
[13:19:24.781]                   options(future.plan = NULL)
[13:19:24.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:24.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:24.781]                 }
[13:19:24.781]                 ...future.workdir <- getwd()
[13:19:24.781]             }
[13:19:24.781]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:24.781]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:24.781]         }
[13:19:24.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:24.781]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:24.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:24.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:24.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:24.781]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:24.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:24.781]             base::names(...future.oldOptions))
[13:19:24.781]     }
[13:19:24.781]     if (TRUE) {
[13:19:24.781]     }
[13:19:24.781]     else {
[13:19:24.781]         if (NA) {
[13:19:24.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:24.781]                 open = "w")
[13:19:24.781]         }
[13:19:24.781]         else {
[13:19:24.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:24.781]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:24.781]         }
[13:19:24.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:24.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:24.781]             base::sink(type = "output", split = FALSE)
[13:19:24.781]             base::close(...future.stdout)
[13:19:24.781]         }, add = TRUE)
[13:19:24.781]     }
[13:19:24.781]     ...future.frame <- base::sys.nframe()
[13:19:24.781]     ...future.conditions <- base::list()
[13:19:24.781]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:24.781]     if (FALSE) {
[13:19:24.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:24.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:24.781]     }
[13:19:24.781]     ...future.result <- base::tryCatch({
[13:19:24.781]         base::withCallingHandlers({
[13:19:24.781]             ...future.value <- base::withVisible(base::local({
[13:19:24.781]                 ...future.makeSendCondition <- local({
[13:19:24.781]                   sendCondition <- NULL
[13:19:24.781]                   function(frame = 1L) {
[13:19:24.781]                     if (is.function(sendCondition)) 
[13:19:24.781]                       return(sendCondition)
[13:19:24.781]                     ns <- getNamespace("parallel")
[13:19:24.781]                     if (exists("sendData", mode = "function", 
[13:19:24.781]                       envir = ns)) {
[13:19:24.781]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:24.781]                         envir = ns)
[13:19:24.781]                       envir <- sys.frame(frame)
[13:19:24.781]                       master <- NULL
[13:19:24.781]                       while (!identical(envir, .GlobalEnv) && 
[13:19:24.781]                         !identical(envir, emptyenv())) {
[13:19:24.781]                         if (exists("master", mode = "list", envir = envir, 
[13:19:24.781]                           inherits = FALSE)) {
[13:19:24.781]                           master <- get("master", mode = "list", 
[13:19:24.781]                             envir = envir, inherits = FALSE)
[13:19:24.781]                           if (inherits(master, c("SOCKnode", 
[13:19:24.781]                             "SOCK0node"))) {
[13:19:24.781]                             sendCondition <<- function(cond) {
[13:19:24.781]                               data <- list(type = "VALUE", value = cond, 
[13:19:24.781]                                 success = TRUE)
[13:19:24.781]                               parallel_sendData(master, data)
[13:19:24.781]                             }
[13:19:24.781]                             return(sendCondition)
[13:19:24.781]                           }
[13:19:24.781]                         }
[13:19:24.781]                         frame <- frame + 1L
[13:19:24.781]                         envir <- sys.frame(frame)
[13:19:24.781]                       }
[13:19:24.781]                     }
[13:19:24.781]                     sendCondition <<- function(cond) NULL
[13:19:24.781]                   }
[13:19:24.781]                 })
[13:19:24.781]                 withCallingHandlers({
[13:19:24.781]                   {
[13:19:24.781]                     do.call(function(...) {
[13:19:24.781]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.781]                       if (!identical(...future.globals.maxSize.org, 
[13:19:24.781]                         ...future.globals.maxSize)) {
[13:19:24.781]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.781]                         on.exit(options(oopts), add = TRUE)
[13:19:24.781]                       }
[13:19:24.781]                       {
[13:19:24.781]                         lapply(seq_along(...future.elements_ii), 
[13:19:24.781]                           FUN = function(jj) {
[13:19:24.781]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.781]                             ...future.FUN(...future.X_jj, ...)
[13:19:24.781]                           })
[13:19:24.781]                       }
[13:19:24.781]                     }, args = future.call.arguments)
[13:19:24.781]                   }
[13:19:24.781]                 }, immediateCondition = function(cond) {
[13:19:24.781]                   sendCondition <- ...future.makeSendCondition()
[13:19:24.781]                   sendCondition(cond)
[13:19:24.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.781]                   {
[13:19:24.781]                     inherits <- base::inherits
[13:19:24.781]                     invokeRestart <- base::invokeRestart
[13:19:24.781]                     is.null <- base::is.null
[13:19:24.781]                     muffled <- FALSE
[13:19:24.781]                     if (inherits(cond, "message")) {
[13:19:24.781]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:24.781]                       if (muffled) 
[13:19:24.781]                         invokeRestart("muffleMessage")
[13:19:24.781]                     }
[13:19:24.781]                     else if (inherits(cond, "warning")) {
[13:19:24.781]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:24.781]                       if (muffled) 
[13:19:24.781]                         invokeRestart("muffleWarning")
[13:19:24.781]                     }
[13:19:24.781]                     else if (inherits(cond, "condition")) {
[13:19:24.781]                       if (!is.null(pattern)) {
[13:19:24.781]                         computeRestarts <- base::computeRestarts
[13:19:24.781]                         grepl <- base::grepl
[13:19:24.781]                         restarts <- computeRestarts(cond)
[13:19:24.781]                         for (restart in restarts) {
[13:19:24.781]                           name <- restart$name
[13:19:24.781]                           if (is.null(name)) 
[13:19:24.781]                             next
[13:19:24.781]                           if (!grepl(pattern, name)) 
[13:19:24.781]                             next
[13:19:24.781]                           invokeRestart(restart)
[13:19:24.781]                           muffled <- TRUE
[13:19:24.781]                           break
[13:19:24.781]                         }
[13:19:24.781]                       }
[13:19:24.781]                     }
[13:19:24.781]                     invisible(muffled)
[13:19:24.781]                   }
[13:19:24.781]                   muffleCondition(cond)
[13:19:24.781]                 })
[13:19:24.781]             }))
[13:19:24.781]             future::FutureResult(value = ...future.value$value, 
[13:19:24.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:24.781]                   ...future.rng), globalenv = if (FALSE) 
[13:19:24.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:24.781]                     ...future.globalenv.names))
[13:19:24.781]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:24.781]         }, condition = base::local({
[13:19:24.781]             c <- base::c
[13:19:24.781]             inherits <- base::inherits
[13:19:24.781]             invokeRestart <- base::invokeRestart
[13:19:24.781]             length <- base::length
[13:19:24.781]             list <- base::list
[13:19:24.781]             seq.int <- base::seq.int
[13:19:24.781]             signalCondition <- base::signalCondition
[13:19:24.781]             sys.calls <- base::sys.calls
[13:19:24.781]             `[[` <- base::`[[`
[13:19:24.781]             `+` <- base::`+`
[13:19:24.781]             `<<-` <- base::`<<-`
[13:19:24.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:24.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:24.781]                   3L)]
[13:19:24.781]             }
[13:19:24.781]             function(cond) {
[13:19:24.781]                 is_error <- inherits(cond, "error")
[13:19:24.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:24.781]                   NULL)
[13:19:24.781]                 if (is_error) {
[13:19:24.781]                   sessionInformation <- function() {
[13:19:24.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:24.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:24.781]                       search = base::search(), system = base::Sys.info())
[13:19:24.781]                   }
[13:19:24.781]                   ...future.conditions[[length(...future.conditions) + 
[13:19:24.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:24.781]                     cond$call), session = sessionInformation(), 
[13:19:24.781]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:24.781]                   signalCondition(cond)
[13:19:24.781]                 }
[13:19:24.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:24.781]                 "immediateCondition"))) {
[13:19:24.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:24.781]                   ...future.conditions[[length(...future.conditions) + 
[13:19:24.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:24.781]                   if (TRUE && !signal) {
[13:19:24.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.781]                     {
[13:19:24.781]                       inherits <- base::inherits
[13:19:24.781]                       invokeRestart <- base::invokeRestart
[13:19:24.781]                       is.null <- base::is.null
[13:19:24.781]                       muffled <- FALSE
[13:19:24.781]                       if (inherits(cond, "message")) {
[13:19:24.781]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:24.781]                         if (muffled) 
[13:19:24.781]                           invokeRestart("muffleMessage")
[13:19:24.781]                       }
[13:19:24.781]                       else if (inherits(cond, "warning")) {
[13:19:24.781]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:24.781]                         if (muffled) 
[13:19:24.781]                           invokeRestart("muffleWarning")
[13:19:24.781]                       }
[13:19:24.781]                       else if (inherits(cond, "condition")) {
[13:19:24.781]                         if (!is.null(pattern)) {
[13:19:24.781]                           computeRestarts <- base::computeRestarts
[13:19:24.781]                           grepl <- base::grepl
[13:19:24.781]                           restarts <- computeRestarts(cond)
[13:19:24.781]                           for (restart in restarts) {
[13:19:24.781]                             name <- restart$name
[13:19:24.781]                             if (is.null(name)) 
[13:19:24.781]                               next
[13:19:24.781]                             if (!grepl(pattern, name)) 
[13:19:24.781]                               next
[13:19:24.781]                             invokeRestart(restart)
[13:19:24.781]                             muffled <- TRUE
[13:19:24.781]                             break
[13:19:24.781]                           }
[13:19:24.781]                         }
[13:19:24.781]                       }
[13:19:24.781]                       invisible(muffled)
[13:19:24.781]                     }
[13:19:24.781]                     muffleCondition(cond, pattern = "^muffle")
[13:19:24.781]                   }
[13:19:24.781]                 }
[13:19:24.781]                 else {
[13:19:24.781]                   if (TRUE) {
[13:19:24.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.781]                     {
[13:19:24.781]                       inherits <- base::inherits
[13:19:24.781]                       invokeRestart <- base::invokeRestart
[13:19:24.781]                       is.null <- base::is.null
[13:19:24.781]                       muffled <- FALSE
[13:19:24.781]                       if (inherits(cond, "message")) {
[13:19:24.781]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:24.781]                         if (muffled) 
[13:19:24.781]                           invokeRestart("muffleMessage")
[13:19:24.781]                       }
[13:19:24.781]                       else if (inherits(cond, "warning")) {
[13:19:24.781]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:24.781]                         if (muffled) 
[13:19:24.781]                           invokeRestart("muffleWarning")
[13:19:24.781]                       }
[13:19:24.781]                       else if (inherits(cond, "condition")) {
[13:19:24.781]                         if (!is.null(pattern)) {
[13:19:24.781]                           computeRestarts <- base::computeRestarts
[13:19:24.781]                           grepl <- base::grepl
[13:19:24.781]                           restarts <- computeRestarts(cond)
[13:19:24.781]                           for (restart in restarts) {
[13:19:24.781]                             name <- restart$name
[13:19:24.781]                             if (is.null(name)) 
[13:19:24.781]                               next
[13:19:24.781]                             if (!grepl(pattern, name)) 
[13:19:24.781]                               next
[13:19:24.781]                             invokeRestart(restart)
[13:19:24.781]                             muffled <- TRUE
[13:19:24.781]                             break
[13:19:24.781]                           }
[13:19:24.781]                         }
[13:19:24.781]                       }
[13:19:24.781]                       invisible(muffled)
[13:19:24.781]                     }
[13:19:24.781]                     muffleCondition(cond, pattern = "^muffle")
[13:19:24.781]                   }
[13:19:24.781]                 }
[13:19:24.781]             }
[13:19:24.781]         }))
[13:19:24.781]     }, error = function(ex) {
[13:19:24.781]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:24.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:24.781]                 ...future.rng), started = ...future.startTime, 
[13:19:24.781]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:24.781]             version = "1.8"), class = "FutureResult")
[13:19:24.781]     }, finally = {
[13:19:24.781]         if (!identical(...future.workdir, getwd())) 
[13:19:24.781]             setwd(...future.workdir)
[13:19:24.781]         {
[13:19:24.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:24.781]                 ...future.oldOptions$nwarnings <- NULL
[13:19:24.781]             }
[13:19:24.781]             base::options(...future.oldOptions)
[13:19:24.781]             if (.Platform$OS.type == "windows") {
[13:19:24.781]                 old_names <- names(...future.oldEnvVars)
[13:19:24.781]                 envs <- base::Sys.getenv()
[13:19:24.781]                 names <- names(envs)
[13:19:24.781]                 common <- intersect(names, old_names)
[13:19:24.781]                 added <- setdiff(names, old_names)
[13:19:24.781]                 removed <- setdiff(old_names, names)
[13:19:24.781]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:24.781]                   envs[common]]
[13:19:24.781]                 NAMES <- toupper(changed)
[13:19:24.781]                 args <- list()
[13:19:24.781]                 for (kk in seq_along(NAMES)) {
[13:19:24.781]                   name <- changed[[kk]]
[13:19:24.781]                   NAME <- NAMES[[kk]]
[13:19:24.781]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.781]                     next
[13:19:24.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:24.781]                 }
[13:19:24.781]                 NAMES <- toupper(added)
[13:19:24.781]                 for (kk in seq_along(NAMES)) {
[13:19:24.781]                   name <- added[[kk]]
[13:19:24.781]                   NAME <- NAMES[[kk]]
[13:19:24.781]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.781]                     next
[13:19:24.781]                   args[[name]] <- ""
[13:19:24.781]                 }
[13:19:24.781]                 NAMES <- toupper(removed)
[13:19:24.781]                 for (kk in seq_along(NAMES)) {
[13:19:24.781]                   name <- removed[[kk]]
[13:19:24.781]                   NAME <- NAMES[[kk]]
[13:19:24.781]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.781]                     next
[13:19:24.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:24.781]                 }
[13:19:24.781]                 if (length(args) > 0) 
[13:19:24.781]                   base::do.call(base::Sys.setenv, args = args)
[13:19:24.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:24.781]             }
[13:19:24.781]             else {
[13:19:24.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:24.781]             }
[13:19:24.781]             {
[13:19:24.781]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:24.781]                   0L) {
[13:19:24.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:24.781]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:24.781]                   base::options(opts)
[13:19:24.781]                 }
[13:19:24.781]                 {
[13:19:24.781]                   {
[13:19:24.781]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:24.781]                     NULL
[13:19:24.781]                   }
[13:19:24.781]                   options(future.plan = NULL)
[13:19:24.781]                   if (is.na(NA_character_)) 
[13:19:24.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:24.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:24.781]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:24.781]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:24.781]                     envir = parent.frame()) 
[13:19:24.781]                   {
[13:19:24.781]                     if (is.function(workers)) 
[13:19:24.781]                       workers <- workers()
[13:19:24.781]                     workers <- structure(as.integer(workers), 
[13:19:24.781]                       class = class(workers))
[13:19:24.781]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:24.781]                       workers >= 1)
[13:19:24.781]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:24.781]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:24.781]                     }
[13:19:24.781]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:24.781]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:24.781]                       envir = envir)
[13:19:24.781]                     if (!future$lazy) 
[13:19:24.781]                       future <- run(future)
[13:19:24.781]                     invisible(future)
[13:19:24.781]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:24.781]                 }
[13:19:24.781]             }
[13:19:24.781]         }
[13:19:24.781]     })
[13:19:24.781]     if (FALSE) {
[13:19:24.781]         base::sink(type = "output", split = FALSE)
[13:19:24.781]         if (NA) {
[13:19:24.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:24.781]         }
[13:19:24.781]         else {
[13:19:24.781]             ...future.result["stdout"] <- base::list(NULL)
[13:19:24.781]         }
[13:19:24.781]         base::close(...future.stdout)
[13:19:24.781]         ...future.stdout <- NULL
[13:19:24.781]     }
[13:19:24.781]     ...future.result$conditions <- ...future.conditions
[13:19:24.781]     ...future.result$finished <- base::Sys.time()
[13:19:24.781]     ...future.result
[13:19:24.781] }
[13:19:24.784] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:19:24.784] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:19:24.784] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:19:24.785] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:19:24.785] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:19:24.785] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:19:24.786] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:19:24.786] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:24.786] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:24.786] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:24.787] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:24.787] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:19:24.787] MultisessionFuture started
[13:19:24.787] - Launch lazy future ... done
[13:19:24.787] run() for ‘MultisessionFuture’ ... done
[13:19:24.787] Created future:
[13:19:24.788] MultisessionFuture:
[13:19:24.788] Label: ‘future_lapply-1’
[13:19:24.788] Expression:
[13:19:24.788] {
[13:19:24.788]     do.call(function(...) {
[13:19:24.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:24.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.788]             on.exit(options(oopts), add = TRUE)
[13:19:24.788]         }
[13:19:24.788]         {
[13:19:24.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:24.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.788]                 ...future.FUN(...future.X_jj, ...)
[13:19:24.788]             })
[13:19:24.788]         }
[13:19:24.788]     }, args = future.call.arguments)
[13:19:24.788] }
[13:19:24.788] Lazy evaluation: FALSE
[13:19:24.788] Asynchronous evaluation: TRUE
[13:19:24.788] Local evaluation: TRUE
[13:19:24.788] Environment: R_GlobalEnv
[13:19:24.788] Capture standard output: NA
[13:19:24.788] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:24.788] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:24.788] Packages: <none>
[13:19:24.788] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:24.788] Resolved: FALSE
[13:19:24.788] Value: <not collected>
[13:19:24.788] Conditions captured: <none>
[13:19:24.788] Early signaling: FALSE
[13:19:24.788] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:24.788] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:24.799] Chunk #1 of 2 ... DONE
[13:19:24.799] Chunk #2 of 2 ...
[13:19:24.799]  - Finding globals in 'X' for chunk #2 ...
[13:19:24.799] getGlobalsAndPackages() ...
[13:19:24.800] Searching for globals...
[13:19:24.800] 
[13:19:24.800] Searching for globals ... DONE
[13:19:24.800] - globals: [0] <none>
[13:19:24.800] getGlobalsAndPackages() ... DONE
[13:19:24.800]    + additional globals found: [n=0] 
[13:19:24.800]    + additional namespaces needed: [n=0] 
[13:19:24.800]  - Finding globals in 'X' for chunk #2 ... DONE
[13:19:24.801]  - seeds: <none>
[13:19:24.801] getGlobalsAndPackages() ...
[13:19:24.801] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:24.801] Resolving globals: FALSE
[13:19:24.801] Tweak future expression to call with '...' arguments ...
[13:19:24.801] {
[13:19:24.801]     do.call(function(...) {
[13:19:24.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:24.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.801]             on.exit(options(oopts), add = TRUE)
[13:19:24.801]         }
[13:19:24.801]         {
[13:19:24.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:24.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.801]                 ...future.FUN(...future.X_jj, ...)
[13:19:24.801]             })
[13:19:24.801]         }
[13:19:24.801]     }, args = future.call.arguments)
[13:19:24.801] }
[13:19:24.801] Tweak future expression to call with '...' arguments ... DONE
[13:19:24.802] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:24.802] 
[13:19:24.802] getGlobalsAndPackages() ... DONE
[13:19:24.802] run() for ‘Future’ ...
[13:19:24.802] - state: ‘created’
[13:19:24.802] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:24.817] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:24.817] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:24.818]   - Field: ‘node’
[13:19:24.818]   - Field: ‘label’
[13:19:24.818]   - Field: ‘local’
[13:19:24.818]   - Field: ‘owner’
[13:19:24.818]   - Field: ‘envir’
[13:19:24.818]   - Field: ‘workers’
[13:19:24.818]   - Field: ‘packages’
[13:19:24.818]   - Field: ‘gc’
[13:19:24.818]   - Field: ‘conditions’
[13:19:24.818]   - Field: ‘persistent’
[13:19:24.819]   - Field: ‘expr’
[13:19:24.819]   - Field: ‘uuid’
[13:19:24.819]   - Field: ‘seed’
[13:19:24.819]   - Field: ‘version’
[13:19:24.819]   - Field: ‘result’
[13:19:24.819]   - Field: ‘asynchronous’
[13:19:24.819]   - Field: ‘calls’
[13:19:24.819]   - Field: ‘globals’
[13:19:24.819]   - Field: ‘stdout’
[13:19:24.819]   - Field: ‘earlySignal’
[13:19:24.819]   - Field: ‘lazy’
[13:19:24.820]   - Field: ‘state’
[13:19:24.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:24.820] - Launch lazy future ...
[13:19:24.820] Packages needed by the future expression (n = 0): <none>
[13:19:24.820] Packages needed by future strategies (n = 0): <none>
[13:19:24.821] {
[13:19:24.821]     {
[13:19:24.821]         {
[13:19:24.821]             ...future.startTime <- base::Sys.time()
[13:19:24.821]             {
[13:19:24.821]                 {
[13:19:24.821]                   {
[13:19:24.821]                     {
[13:19:24.821]                       base::local({
[13:19:24.821]                         has_future <- base::requireNamespace("future", 
[13:19:24.821]                           quietly = TRUE)
[13:19:24.821]                         if (has_future) {
[13:19:24.821]                           ns <- base::getNamespace("future")
[13:19:24.821]                           version <- ns[[".package"]][["version"]]
[13:19:24.821]                           if (is.null(version)) 
[13:19:24.821]                             version <- utils::packageVersion("future")
[13:19:24.821]                         }
[13:19:24.821]                         else {
[13:19:24.821]                           version <- NULL
[13:19:24.821]                         }
[13:19:24.821]                         if (!has_future || version < "1.8.0") {
[13:19:24.821]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:24.821]                             "", base::R.version$version.string), 
[13:19:24.821]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:24.821]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:24.821]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:24.821]                               "release", "version")], collapse = " "), 
[13:19:24.821]                             hostname = base::Sys.info()[["nodename"]])
[13:19:24.821]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:24.821]                             info)
[13:19:24.821]                           info <- base::paste(info, collapse = "; ")
[13:19:24.821]                           if (!has_future) {
[13:19:24.821]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:24.821]                               info)
[13:19:24.821]                           }
[13:19:24.821]                           else {
[13:19:24.821]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:24.821]                               info, version)
[13:19:24.821]                           }
[13:19:24.821]                           base::stop(msg)
[13:19:24.821]                         }
[13:19:24.821]                       })
[13:19:24.821]                     }
[13:19:24.821]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:24.821]                     base::options(mc.cores = 1L)
[13:19:24.821]                   }
[13:19:24.821]                   options(future.plan = NULL)
[13:19:24.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:24.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:24.821]                 }
[13:19:24.821]                 ...future.workdir <- getwd()
[13:19:24.821]             }
[13:19:24.821]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:24.821]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:24.821]         }
[13:19:24.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:24.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:24.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:24.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:24.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:24.821]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:24.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:24.821]             base::names(...future.oldOptions))
[13:19:24.821]     }
[13:19:24.821]     if (TRUE) {
[13:19:24.821]     }
[13:19:24.821]     else {
[13:19:24.821]         if (NA) {
[13:19:24.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:24.821]                 open = "w")
[13:19:24.821]         }
[13:19:24.821]         else {
[13:19:24.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:24.821]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:24.821]         }
[13:19:24.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:24.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:24.821]             base::sink(type = "output", split = FALSE)
[13:19:24.821]             base::close(...future.stdout)
[13:19:24.821]         }, add = TRUE)
[13:19:24.821]     }
[13:19:24.821]     ...future.frame <- base::sys.nframe()
[13:19:24.821]     ...future.conditions <- base::list()
[13:19:24.821]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:24.821]     if (FALSE) {
[13:19:24.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:24.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:24.821]     }
[13:19:24.821]     ...future.result <- base::tryCatch({
[13:19:24.821]         base::withCallingHandlers({
[13:19:24.821]             ...future.value <- base::withVisible(base::local({
[13:19:24.821]                 ...future.makeSendCondition <- local({
[13:19:24.821]                   sendCondition <- NULL
[13:19:24.821]                   function(frame = 1L) {
[13:19:24.821]                     if (is.function(sendCondition)) 
[13:19:24.821]                       return(sendCondition)
[13:19:24.821]                     ns <- getNamespace("parallel")
[13:19:24.821]                     if (exists("sendData", mode = "function", 
[13:19:24.821]                       envir = ns)) {
[13:19:24.821]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:24.821]                         envir = ns)
[13:19:24.821]                       envir <- sys.frame(frame)
[13:19:24.821]                       master <- NULL
[13:19:24.821]                       while (!identical(envir, .GlobalEnv) && 
[13:19:24.821]                         !identical(envir, emptyenv())) {
[13:19:24.821]                         if (exists("master", mode = "list", envir = envir, 
[13:19:24.821]                           inherits = FALSE)) {
[13:19:24.821]                           master <- get("master", mode = "list", 
[13:19:24.821]                             envir = envir, inherits = FALSE)
[13:19:24.821]                           if (inherits(master, c("SOCKnode", 
[13:19:24.821]                             "SOCK0node"))) {
[13:19:24.821]                             sendCondition <<- function(cond) {
[13:19:24.821]                               data <- list(type = "VALUE", value = cond, 
[13:19:24.821]                                 success = TRUE)
[13:19:24.821]                               parallel_sendData(master, data)
[13:19:24.821]                             }
[13:19:24.821]                             return(sendCondition)
[13:19:24.821]                           }
[13:19:24.821]                         }
[13:19:24.821]                         frame <- frame + 1L
[13:19:24.821]                         envir <- sys.frame(frame)
[13:19:24.821]                       }
[13:19:24.821]                     }
[13:19:24.821]                     sendCondition <<- function(cond) NULL
[13:19:24.821]                   }
[13:19:24.821]                 })
[13:19:24.821]                 withCallingHandlers({
[13:19:24.821]                   {
[13:19:24.821]                     do.call(function(...) {
[13:19:24.821]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.821]                       if (!identical(...future.globals.maxSize.org, 
[13:19:24.821]                         ...future.globals.maxSize)) {
[13:19:24.821]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.821]                         on.exit(options(oopts), add = TRUE)
[13:19:24.821]                       }
[13:19:24.821]                       {
[13:19:24.821]                         lapply(seq_along(...future.elements_ii), 
[13:19:24.821]                           FUN = function(jj) {
[13:19:24.821]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.821]                             ...future.FUN(...future.X_jj, ...)
[13:19:24.821]                           })
[13:19:24.821]                       }
[13:19:24.821]                     }, args = future.call.arguments)
[13:19:24.821]                   }
[13:19:24.821]                 }, immediateCondition = function(cond) {
[13:19:24.821]                   sendCondition <- ...future.makeSendCondition()
[13:19:24.821]                   sendCondition(cond)
[13:19:24.821]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.821]                   {
[13:19:24.821]                     inherits <- base::inherits
[13:19:24.821]                     invokeRestart <- base::invokeRestart
[13:19:24.821]                     is.null <- base::is.null
[13:19:24.821]                     muffled <- FALSE
[13:19:24.821]                     if (inherits(cond, "message")) {
[13:19:24.821]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:24.821]                       if (muffled) 
[13:19:24.821]                         invokeRestart("muffleMessage")
[13:19:24.821]                     }
[13:19:24.821]                     else if (inherits(cond, "warning")) {
[13:19:24.821]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:24.821]                       if (muffled) 
[13:19:24.821]                         invokeRestart("muffleWarning")
[13:19:24.821]                     }
[13:19:24.821]                     else if (inherits(cond, "condition")) {
[13:19:24.821]                       if (!is.null(pattern)) {
[13:19:24.821]                         computeRestarts <- base::computeRestarts
[13:19:24.821]                         grepl <- base::grepl
[13:19:24.821]                         restarts <- computeRestarts(cond)
[13:19:24.821]                         for (restart in restarts) {
[13:19:24.821]                           name <- restart$name
[13:19:24.821]                           if (is.null(name)) 
[13:19:24.821]                             next
[13:19:24.821]                           if (!grepl(pattern, name)) 
[13:19:24.821]                             next
[13:19:24.821]                           invokeRestart(restart)
[13:19:24.821]                           muffled <- TRUE
[13:19:24.821]                           break
[13:19:24.821]                         }
[13:19:24.821]                       }
[13:19:24.821]                     }
[13:19:24.821]                     invisible(muffled)
[13:19:24.821]                   }
[13:19:24.821]                   muffleCondition(cond)
[13:19:24.821]                 })
[13:19:24.821]             }))
[13:19:24.821]             future::FutureResult(value = ...future.value$value, 
[13:19:24.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:24.821]                   ...future.rng), globalenv = if (FALSE) 
[13:19:24.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:24.821]                     ...future.globalenv.names))
[13:19:24.821]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:24.821]         }, condition = base::local({
[13:19:24.821]             c <- base::c
[13:19:24.821]             inherits <- base::inherits
[13:19:24.821]             invokeRestart <- base::invokeRestart
[13:19:24.821]             length <- base::length
[13:19:24.821]             list <- base::list
[13:19:24.821]             seq.int <- base::seq.int
[13:19:24.821]             signalCondition <- base::signalCondition
[13:19:24.821]             sys.calls <- base::sys.calls
[13:19:24.821]             `[[` <- base::`[[`
[13:19:24.821]             `+` <- base::`+`
[13:19:24.821]             `<<-` <- base::`<<-`
[13:19:24.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:24.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:24.821]                   3L)]
[13:19:24.821]             }
[13:19:24.821]             function(cond) {
[13:19:24.821]                 is_error <- inherits(cond, "error")
[13:19:24.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:24.821]                   NULL)
[13:19:24.821]                 if (is_error) {
[13:19:24.821]                   sessionInformation <- function() {
[13:19:24.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:24.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:24.821]                       search = base::search(), system = base::Sys.info())
[13:19:24.821]                   }
[13:19:24.821]                   ...future.conditions[[length(...future.conditions) + 
[13:19:24.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:24.821]                     cond$call), session = sessionInformation(), 
[13:19:24.821]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:24.821]                   signalCondition(cond)
[13:19:24.821]                 }
[13:19:24.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:24.821]                 "immediateCondition"))) {
[13:19:24.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:24.821]                   ...future.conditions[[length(...future.conditions) + 
[13:19:24.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:24.821]                   if (TRUE && !signal) {
[13:19:24.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.821]                     {
[13:19:24.821]                       inherits <- base::inherits
[13:19:24.821]                       invokeRestart <- base::invokeRestart
[13:19:24.821]                       is.null <- base::is.null
[13:19:24.821]                       muffled <- FALSE
[13:19:24.821]                       if (inherits(cond, "message")) {
[13:19:24.821]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:24.821]                         if (muffled) 
[13:19:24.821]                           invokeRestart("muffleMessage")
[13:19:24.821]                       }
[13:19:24.821]                       else if (inherits(cond, "warning")) {
[13:19:24.821]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:24.821]                         if (muffled) 
[13:19:24.821]                           invokeRestart("muffleWarning")
[13:19:24.821]                       }
[13:19:24.821]                       else if (inherits(cond, "condition")) {
[13:19:24.821]                         if (!is.null(pattern)) {
[13:19:24.821]                           computeRestarts <- base::computeRestarts
[13:19:24.821]                           grepl <- base::grepl
[13:19:24.821]                           restarts <- computeRestarts(cond)
[13:19:24.821]                           for (restart in restarts) {
[13:19:24.821]                             name <- restart$name
[13:19:24.821]                             if (is.null(name)) 
[13:19:24.821]                               next
[13:19:24.821]                             if (!grepl(pattern, name)) 
[13:19:24.821]                               next
[13:19:24.821]                             invokeRestart(restart)
[13:19:24.821]                             muffled <- TRUE
[13:19:24.821]                             break
[13:19:24.821]                           }
[13:19:24.821]                         }
[13:19:24.821]                       }
[13:19:24.821]                       invisible(muffled)
[13:19:24.821]                     }
[13:19:24.821]                     muffleCondition(cond, pattern = "^muffle")
[13:19:24.821]                   }
[13:19:24.821]                 }
[13:19:24.821]                 else {
[13:19:24.821]                   if (TRUE) {
[13:19:24.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:24.821]                     {
[13:19:24.821]                       inherits <- base::inherits
[13:19:24.821]                       invokeRestart <- base::invokeRestart
[13:19:24.821]                       is.null <- base::is.null
[13:19:24.821]                       muffled <- FALSE
[13:19:24.821]                       if (inherits(cond, "message")) {
[13:19:24.821]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:24.821]                         if (muffled) 
[13:19:24.821]                           invokeRestart("muffleMessage")
[13:19:24.821]                       }
[13:19:24.821]                       else if (inherits(cond, "warning")) {
[13:19:24.821]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:24.821]                         if (muffled) 
[13:19:24.821]                           invokeRestart("muffleWarning")
[13:19:24.821]                       }
[13:19:24.821]                       else if (inherits(cond, "condition")) {
[13:19:24.821]                         if (!is.null(pattern)) {
[13:19:24.821]                           computeRestarts <- base::computeRestarts
[13:19:24.821]                           grepl <- base::grepl
[13:19:24.821]                           restarts <- computeRestarts(cond)
[13:19:24.821]                           for (restart in restarts) {
[13:19:24.821]                             name <- restart$name
[13:19:24.821]                             if (is.null(name)) 
[13:19:24.821]                               next
[13:19:24.821]                             if (!grepl(pattern, name)) 
[13:19:24.821]                               next
[13:19:24.821]                             invokeRestart(restart)
[13:19:24.821]                             muffled <- TRUE
[13:19:24.821]                             break
[13:19:24.821]                           }
[13:19:24.821]                         }
[13:19:24.821]                       }
[13:19:24.821]                       invisible(muffled)
[13:19:24.821]                     }
[13:19:24.821]                     muffleCondition(cond, pattern = "^muffle")
[13:19:24.821]                   }
[13:19:24.821]                 }
[13:19:24.821]             }
[13:19:24.821]         }))
[13:19:24.821]     }, error = function(ex) {
[13:19:24.821]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:24.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:24.821]                 ...future.rng), started = ...future.startTime, 
[13:19:24.821]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:24.821]             version = "1.8"), class = "FutureResult")
[13:19:24.821]     }, finally = {
[13:19:24.821]         if (!identical(...future.workdir, getwd())) 
[13:19:24.821]             setwd(...future.workdir)
[13:19:24.821]         {
[13:19:24.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:24.821]                 ...future.oldOptions$nwarnings <- NULL
[13:19:24.821]             }
[13:19:24.821]             base::options(...future.oldOptions)
[13:19:24.821]             if (.Platform$OS.type == "windows") {
[13:19:24.821]                 old_names <- names(...future.oldEnvVars)
[13:19:24.821]                 envs <- base::Sys.getenv()
[13:19:24.821]                 names <- names(envs)
[13:19:24.821]                 common <- intersect(names, old_names)
[13:19:24.821]                 added <- setdiff(names, old_names)
[13:19:24.821]                 removed <- setdiff(old_names, names)
[13:19:24.821]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:24.821]                   envs[common]]
[13:19:24.821]                 NAMES <- toupper(changed)
[13:19:24.821]                 args <- list()
[13:19:24.821]                 for (kk in seq_along(NAMES)) {
[13:19:24.821]                   name <- changed[[kk]]
[13:19:24.821]                   NAME <- NAMES[[kk]]
[13:19:24.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.821]                     next
[13:19:24.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:24.821]                 }
[13:19:24.821]                 NAMES <- toupper(added)
[13:19:24.821]                 for (kk in seq_along(NAMES)) {
[13:19:24.821]                   name <- added[[kk]]
[13:19:24.821]                   NAME <- NAMES[[kk]]
[13:19:24.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.821]                     next
[13:19:24.821]                   args[[name]] <- ""
[13:19:24.821]                 }
[13:19:24.821]                 NAMES <- toupper(removed)
[13:19:24.821]                 for (kk in seq_along(NAMES)) {
[13:19:24.821]                   name <- removed[[kk]]
[13:19:24.821]                   NAME <- NAMES[[kk]]
[13:19:24.821]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:24.821]                     next
[13:19:24.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:24.821]                 }
[13:19:24.821]                 if (length(args) > 0) 
[13:19:24.821]                   base::do.call(base::Sys.setenv, args = args)
[13:19:24.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:24.821]             }
[13:19:24.821]             else {
[13:19:24.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:24.821]             }
[13:19:24.821]             {
[13:19:24.821]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:24.821]                   0L) {
[13:19:24.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:24.821]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:24.821]                   base::options(opts)
[13:19:24.821]                 }
[13:19:24.821]                 {
[13:19:24.821]                   {
[13:19:24.821]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:24.821]                     NULL
[13:19:24.821]                   }
[13:19:24.821]                   options(future.plan = NULL)
[13:19:24.821]                   if (is.na(NA_character_)) 
[13:19:24.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:24.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:24.821]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:24.821]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:24.821]                     envir = parent.frame()) 
[13:19:24.821]                   {
[13:19:24.821]                     if (is.function(workers)) 
[13:19:24.821]                       workers <- workers()
[13:19:24.821]                     workers <- structure(as.integer(workers), 
[13:19:24.821]                       class = class(workers))
[13:19:24.821]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:24.821]                       workers >= 1)
[13:19:24.821]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:24.821]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:24.821]                     }
[13:19:24.821]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:24.821]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:24.821]                       envir = envir)
[13:19:24.821]                     if (!future$lazy) 
[13:19:24.821]                       future <- run(future)
[13:19:24.821]                     invisible(future)
[13:19:24.821]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:24.821]                 }
[13:19:24.821]             }
[13:19:24.821]         }
[13:19:24.821]     })
[13:19:24.821]     if (FALSE) {
[13:19:24.821]         base::sink(type = "output", split = FALSE)
[13:19:24.821]         if (NA) {
[13:19:24.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:24.821]         }
[13:19:24.821]         else {
[13:19:24.821]             ...future.result["stdout"] <- base::list(NULL)
[13:19:24.821]         }
[13:19:24.821]         base::close(...future.stdout)
[13:19:24.821]         ...future.stdout <- NULL
[13:19:24.821]     }
[13:19:24.821]     ...future.result$conditions <- ...future.conditions
[13:19:24.821]     ...future.result$finished <- base::Sys.time()
[13:19:24.821]     ...future.result
[13:19:24.821] }
[13:19:24.823] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:19:24.824] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:19:24.824] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:19:24.824] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:19:24.825] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:19:24.825] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:19:24.825] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:19:24.825] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:24.826] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:24.826] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:24.826] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:24.826] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:19:24.827] MultisessionFuture started
[13:19:24.827] - Launch lazy future ... done
[13:19:24.827] run() for ‘MultisessionFuture’ ... done
[13:19:24.827] Created future:
[13:19:24.827] MultisessionFuture:
[13:19:24.827] Label: ‘future_lapply-2’
[13:19:24.827] Expression:
[13:19:24.827] {
[13:19:24.827]     do.call(function(...) {
[13:19:24.827]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:24.827]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:24.827]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:24.827]             on.exit(options(oopts), add = TRUE)
[13:19:24.827]         }
[13:19:24.827]         {
[13:19:24.827]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:19:24.827]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:19:24.827]                 ...future.FUN(...future.X_jj, ...)
[13:19:24.827]             })
[13:19:24.827]         }
[13:19:24.827]     }, args = future.call.arguments)
[13:19:24.827] }
[13:19:24.827] Lazy evaluation: FALSE
[13:19:24.827] Asynchronous evaluation: TRUE
[13:19:24.827] Local evaluation: TRUE
[13:19:24.827] Environment: R_GlobalEnv
[13:19:24.827] Capture standard output: NA
[13:19:24.827] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:24.827] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:24.827] Packages: <none>
[13:19:24.827] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:24.827] Resolved: FALSE
[13:19:24.827] Value: <not collected>
[13:19:24.827] Conditions captured: <none>
[13:19:24.827] Early signaling: FALSE
[13:19:24.827] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:24.827] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:24.839] Chunk #2 of 2 ... DONE
[13:19:24.839] Launching 2 futures (chunks) ... DONE
[13:19:24.839] Resolving 2 futures (chunks) ...
[13:19:24.839] resolve() on list ...
[13:19:24.839]  recursive: 0
[13:19:24.839]  length: 2
[13:19:24.839] 
[13:19:24.881] receiveMessageFromWorker() for ClusterFuture ...
[13:19:24.882] - Validating connection of MultisessionFuture
[13:19:24.882] - received message: FutureResult
[13:19:24.882] - Received FutureResult
[13:19:24.882] - Erased future from FutureRegistry
[13:19:24.882] result() for ClusterFuture ...
[13:19:24.882] - result already collected: FutureResult
[13:19:24.882] result() for ClusterFuture ... done
[13:19:24.883] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:24.883] Future #2
[13:19:24.883] result() for ClusterFuture ...
[13:19:24.883] - result already collected: FutureResult
[13:19:24.883] result() for ClusterFuture ... done
[13:19:24.883] result() for ClusterFuture ...
[13:19:24.883] - result already collected: FutureResult
[13:19:24.883] result() for ClusterFuture ... done
[13:19:24.883] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:24.883] - nx: 2
[13:19:24.883] - relay: TRUE
[13:19:24.884] - stdout: TRUE
[13:19:24.884] - signal: TRUE
[13:19:24.884] - resignal: FALSE
[13:19:24.884] - force: TRUE
[13:19:24.884] - relayed: [n=2] FALSE, FALSE
[13:19:24.884] - queued futures: [n=2] FALSE, FALSE
[13:19:24.884]  - until=1
[13:19:24.884]  - relaying element #1
[13:19:24.884] - relayed: [n=2] FALSE, FALSE
[13:19:24.884] - queued futures: [n=2] FALSE, TRUE
[13:19:24.884] signalConditionsASAP(NULL, pos=2) ... done
[13:19:24.885]  length: 1 (resolved future 2)
[13:19:25.334] receiveMessageFromWorker() for ClusterFuture ...
[13:19:25.335] - Validating connection of MultisessionFuture
[13:19:25.335] - received message: FutureResult
[13:19:25.335] - Received FutureResult
[13:19:25.335] - Erased future from FutureRegistry
[13:19:25.335] result() for ClusterFuture ...
[13:19:25.335] - result already collected: FutureResult
[13:19:25.335] result() for ClusterFuture ... done
[13:19:25.335] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:25.336] Future #1
[13:19:25.336] result() for ClusterFuture ...
[13:19:25.336] - result already collected: FutureResult
[13:19:25.336] result() for ClusterFuture ... done
[13:19:25.336] result() for ClusterFuture ...
[13:19:25.336] - result already collected: FutureResult
[13:19:25.336] result() for ClusterFuture ... done
[13:19:25.336] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:25.336] - nx: 2
[13:19:25.336] - relay: TRUE
[13:19:25.336] - stdout: TRUE
[13:19:25.337] - signal: TRUE
[13:19:25.337] - resignal: FALSE
[13:19:25.337] - force: TRUE
[13:19:25.337] - relayed: [n=2] FALSE, FALSE
[13:19:25.337] - queued futures: [n=2] FALSE, TRUE
[13:19:25.337]  - until=1
[13:19:25.337]  - relaying element #1
[13:19:25.337] result() for ClusterFuture ...
[13:19:25.337] - result already collected: FutureResult
[13:19:25.337] result() for ClusterFuture ... done
[13:19:25.338] result() for ClusterFuture ...
[13:19:25.338] - result already collected: FutureResult
[13:19:25.338] result() for ClusterFuture ... done
[13:19:25.338] result() for ClusterFuture ...
[13:19:25.338] - result already collected: FutureResult
[13:19:25.338] result() for ClusterFuture ... done
[13:19:25.338] result() for ClusterFuture ...
[13:19:25.338] - result already collected: FutureResult
[13:19:25.338] result() for ClusterFuture ... done
[13:19:25.338] - relayed: [n=2] TRUE, FALSE
[13:19:25.338] - queued futures: [n=2] TRUE, TRUE
[13:19:25.338] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:25.339]  length: 0 (resolved future 1)
[13:19:25.339] Relaying remaining futures
[13:19:25.339] signalConditionsASAP(NULL, pos=0) ...
[13:19:25.339] - nx: 2
[13:19:25.339] - relay: TRUE
[13:19:25.339] - stdout: TRUE
[13:19:25.339] - signal: TRUE
[13:19:25.339] - resignal: FALSE
[13:19:25.339] - force: TRUE
[13:19:25.339] - relayed: [n=2] TRUE, FALSE
[13:19:25.339] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:25.340]  - relaying element #2
[13:19:25.340] result() for ClusterFuture ...
[13:19:25.340] - result already collected: FutureResult
[13:19:25.340] result() for ClusterFuture ... done
[13:19:25.340] result() for ClusterFuture ...
[13:19:25.340] - result already collected: FutureResult
[13:19:25.340] result() for ClusterFuture ... done
[13:19:25.340] result() for ClusterFuture ...
[13:19:25.340] - result already collected: FutureResult
[13:19:25.340] result() for ClusterFuture ... done
[13:19:25.340] result() for ClusterFuture ...
[13:19:25.340] - result already collected: FutureResult
[13:19:25.341] result() for ClusterFuture ... done
[13:19:25.341] - relayed: [n=2] TRUE, TRUE
[13:19:25.341] - queued futures: [n=2] TRUE, TRUE
[13:19:25.341] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:19:25.341] resolve() on list ... DONE
[13:19:25.341] result() for ClusterFuture ...
[13:19:25.341] - result already collected: FutureResult
[13:19:25.341] result() for ClusterFuture ... done
[13:19:25.341] result() for ClusterFuture ...
[13:19:25.341] - result already collected: FutureResult
[13:19:25.342] result() for ClusterFuture ... done
[13:19:25.342] result() for ClusterFuture ...
[13:19:25.342] - result already collected: FutureResult
[13:19:25.342] result() for ClusterFuture ... done
[13:19:25.342] result() for ClusterFuture ...
[13:19:25.342] - result already collected: FutureResult
[13:19:25.342] result() for ClusterFuture ... done
[13:19:25.342]  - Number of value chunks collected: 2
[13:19:25.342] Resolving 2 futures (chunks) ... DONE
[13:19:25.342] Reducing values from 2 chunks ...
[13:19:25.342]  - Number of values collected after concatenation: 2
[13:19:25.343]  - Number of values expected: 2
[13:19:25.343] Reducing values from 2 chunks ... DONE
[13:19:25.343] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:19:25.343] future_mapply() ...
[13:19:25.347] Number of chunks: 2
[13:19:25.347] getGlobalsAndPackagesXApply() ...
[13:19:25.347]  - future.globals: TRUE
[13:19:25.347] getGlobalsAndPackages() ...
[13:19:25.347] Searching for globals...
[13:19:25.349] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:25.349] Searching for globals ... DONE
[13:19:25.349] Resolving globals: FALSE
[13:19:25.349] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:25.350] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:25.350] - globals: [1] ‘FUN’
[13:19:25.350] 
[13:19:25.350] getGlobalsAndPackages() ... DONE
[13:19:25.350]  - globals found/used: [n=1] ‘FUN’
[13:19:25.350]  - needed namespaces: [n=0] 
[13:19:25.350] Finding globals ... DONE
[13:19:25.351] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:25.351] List of 2
[13:19:25.351]  $ ...future.FUN:function (x, y)  
[13:19:25.351]  $ MoreArgs     : NULL
[13:19:25.351]  - attr(*, "where")=List of 2
[13:19:25.351]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:25.351]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:25.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:25.351]  - attr(*, "resolved")= logi FALSE
[13:19:25.351]  - attr(*, "total_size")= num NA
[13:19:25.353] Packages to be attached in all futures: [n=0] 
[13:19:25.353] getGlobalsAndPackagesXApply() ... DONE
[13:19:25.354] Number of futures (= number of chunks): 2
[13:19:25.354] Launching 2 futures (chunks) ...
[13:19:25.354] Chunk #1 of 2 ...
[13:19:25.354]  - Finding globals in '...' for chunk #1 ...
[13:19:25.354] getGlobalsAndPackages() ...
[13:19:25.354] Searching for globals...
[13:19:25.354] 
[13:19:25.354] Searching for globals ... DONE
[13:19:25.355] - globals: [0] <none>
[13:19:25.355] getGlobalsAndPackages() ... DONE
[13:19:25.355]    + additional globals found: [n=0] 
[13:19:25.355]    + additional namespaces needed: [n=0] 
[13:19:25.355]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:25.355]  - seeds: <none>
[13:19:25.355] getGlobalsAndPackages() ...
[13:19:25.355] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:25.355] Resolving globals: FALSE
[13:19:25.356] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:25.358] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:25.358] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:25.358] 
[13:19:25.358] getGlobalsAndPackages() ... DONE
[13:19:25.359] run() for ‘Future’ ...
[13:19:25.359] - state: ‘created’
[13:19:25.359] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:25.375] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:25.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:25.375]   - Field: ‘node’
[13:19:25.375]   - Field: ‘label’
[13:19:25.375]   - Field: ‘local’
[13:19:25.375]   - Field: ‘owner’
[13:19:25.375]   - Field: ‘envir’
[13:19:25.375]   - Field: ‘workers’
[13:19:25.375]   - Field: ‘packages’
[13:19:25.375]   - Field: ‘gc’
[13:19:25.376]   - Field: ‘conditions’
[13:19:25.376]   - Field: ‘persistent’
[13:19:25.376]   - Field: ‘expr’
[13:19:25.376]   - Field: ‘uuid’
[13:19:25.376]   - Field: ‘seed’
[13:19:25.376]   - Field: ‘version’
[13:19:25.376]   - Field: ‘result’
[13:19:25.376]   - Field: ‘asynchronous’
[13:19:25.376]   - Field: ‘calls’
[13:19:25.376]   - Field: ‘globals’
[13:19:25.376]   - Field: ‘stdout’
[13:19:25.377]   - Field: ‘earlySignal’
[13:19:25.377]   - Field: ‘lazy’
[13:19:25.377]   - Field: ‘state’
[13:19:25.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:25.377] - Launch lazy future ...
[13:19:25.377] Packages needed by the future expression (n = 0): <none>
[13:19:25.377] Packages needed by future strategies (n = 0): <none>
[13:19:25.378] {
[13:19:25.378]     {
[13:19:25.378]         {
[13:19:25.378]             ...future.startTime <- base::Sys.time()
[13:19:25.378]             {
[13:19:25.378]                 {
[13:19:25.378]                   {
[13:19:25.378]                     {
[13:19:25.378]                       base::local({
[13:19:25.378]                         has_future <- base::requireNamespace("future", 
[13:19:25.378]                           quietly = TRUE)
[13:19:25.378]                         if (has_future) {
[13:19:25.378]                           ns <- base::getNamespace("future")
[13:19:25.378]                           version <- ns[[".package"]][["version"]]
[13:19:25.378]                           if (is.null(version)) 
[13:19:25.378]                             version <- utils::packageVersion("future")
[13:19:25.378]                         }
[13:19:25.378]                         else {
[13:19:25.378]                           version <- NULL
[13:19:25.378]                         }
[13:19:25.378]                         if (!has_future || version < "1.8.0") {
[13:19:25.378]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:25.378]                             "", base::R.version$version.string), 
[13:19:25.378]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:25.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:25.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:25.378]                               "release", "version")], collapse = " "), 
[13:19:25.378]                             hostname = base::Sys.info()[["nodename"]])
[13:19:25.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:25.378]                             info)
[13:19:25.378]                           info <- base::paste(info, collapse = "; ")
[13:19:25.378]                           if (!has_future) {
[13:19:25.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:25.378]                               info)
[13:19:25.378]                           }
[13:19:25.378]                           else {
[13:19:25.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:25.378]                               info, version)
[13:19:25.378]                           }
[13:19:25.378]                           base::stop(msg)
[13:19:25.378]                         }
[13:19:25.378]                       })
[13:19:25.378]                     }
[13:19:25.378]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:25.378]                     base::options(mc.cores = 1L)
[13:19:25.378]                   }
[13:19:25.378]                   options(future.plan = NULL)
[13:19:25.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:25.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:25.378]                 }
[13:19:25.378]                 ...future.workdir <- getwd()
[13:19:25.378]             }
[13:19:25.378]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:25.378]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:25.378]         }
[13:19:25.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:25.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:25.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:25.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:25.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:25.378]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:25.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:25.378]             base::names(...future.oldOptions))
[13:19:25.378]     }
[13:19:25.378]     if (FALSE) {
[13:19:25.378]     }
[13:19:25.378]     else {
[13:19:25.378]         if (FALSE) {
[13:19:25.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:25.378]                 open = "w")
[13:19:25.378]         }
[13:19:25.378]         else {
[13:19:25.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:25.378]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:25.378]         }
[13:19:25.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:25.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:25.378]             base::sink(type = "output", split = FALSE)
[13:19:25.378]             base::close(...future.stdout)
[13:19:25.378]         }, add = TRUE)
[13:19:25.378]     }
[13:19:25.378]     ...future.frame <- base::sys.nframe()
[13:19:25.378]     ...future.conditions <- base::list()
[13:19:25.378]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:25.378]     if (FALSE) {
[13:19:25.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:25.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:25.378]     }
[13:19:25.378]     ...future.result <- base::tryCatch({
[13:19:25.378]         base::withCallingHandlers({
[13:19:25.378]             ...future.value <- base::withVisible(base::local({
[13:19:25.378]                 ...future.makeSendCondition <- local({
[13:19:25.378]                   sendCondition <- NULL
[13:19:25.378]                   function(frame = 1L) {
[13:19:25.378]                     if (is.function(sendCondition)) 
[13:19:25.378]                       return(sendCondition)
[13:19:25.378]                     ns <- getNamespace("parallel")
[13:19:25.378]                     if (exists("sendData", mode = "function", 
[13:19:25.378]                       envir = ns)) {
[13:19:25.378]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:25.378]                         envir = ns)
[13:19:25.378]                       envir <- sys.frame(frame)
[13:19:25.378]                       master <- NULL
[13:19:25.378]                       while (!identical(envir, .GlobalEnv) && 
[13:19:25.378]                         !identical(envir, emptyenv())) {
[13:19:25.378]                         if (exists("master", mode = "list", envir = envir, 
[13:19:25.378]                           inherits = FALSE)) {
[13:19:25.378]                           master <- get("master", mode = "list", 
[13:19:25.378]                             envir = envir, inherits = FALSE)
[13:19:25.378]                           if (inherits(master, c("SOCKnode", 
[13:19:25.378]                             "SOCK0node"))) {
[13:19:25.378]                             sendCondition <<- function(cond) {
[13:19:25.378]                               data <- list(type = "VALUE", value = cond, 
[13:19:25.378]                                 success = TRUE)
[13:19:25.378]                               parallel_sendData(master, data)
[13:19:25.378]                             }
[13:19:25.378]                             return(sendCondition)
[13:19:25.378]                           }
[13:19:25.378]                         }
[13:19:25.378]                         frame <- frame + 1L
[13:19:25.378]                         envir <- sys.frame(frame)
[13:19:25.378]                       }
[13:19:25.378]                     }
[13:19:25.378]                     sendCondition <<- function(cond) NULL
[13:19:25.378]                   }
[13:19:25.378]                 })
[13:19:25.378]                 withCallingHandlers({
[13:19:25.378]                   {
[13:19:25.378]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:25.378]                     if (!identical(...future.globals.maxSize.org, 
[13:19:25.378]                       ...future.globals.maxSize)) {
[13:19:25.378]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:25.378]                       on.exit(options(oopts), add = TRUE)
[13:19:25.378]                     }
[13:19:25.378]                     {
[13:19:25.378]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:25.378]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:25.378]                         USE.NAMES = FALSE)
[13:19:25.378]                       do.call(mapply, args = args)
[13:19:25.378]                     }
[13:19:25.378]                   }
[13:19:25.378]                 }, immediateCondition = function(cond) {
[13:19:25.378]                   sendCondition <- ...future.makeSendCondition()
[13:19:25.378]                   sendCondition(cond)
[13:19:25.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.378]                   {
[13:19:25.378]                     inherits <- base::inherits
[13:19:25.378]                     invokeRestart <- base::invokeRestart
[13:19:25.378]                     is.null <- base::is.null
[13:19:25.378]                     muffled <- FALSE
[13:19:25.378]                     if (inherits(cond, "message")) {
[13:19:25.378]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:25.378]                       if (muffled) 
[13:19:25.378]                         invokeRestart("muffleMessage")
[13:19:25.378]                     }
[13:19:25.378]                     else if (inherits(cond, "warning")) {
[13:19:25.378]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:25.378]                       if (muffled) 
[13:19:25.378]                         invokeRestart("muffleWarning")
[13:19:25.378]                     }
[13:19:25.378]                     else if (inherits(cond, "condition")) {
[13:19:25.378]                       if (!is.null(pattern)) {
[13:19:25.378]                         computeRestarts <- base::computeRestarts
[13:19:25.378]                         grepl <- base::grepl
[13:19:25.378]                         restarts <- computeRestarts(cond)
[13:19:25.378]                         for (restart in restarts) {
[13:19:25.378]                           name <- restart$name
[13:19:25.378]                           if (is.null(name)) 
[13:19:25.378]                             next
[13:19:25.378]                           if (!grepl(pattern, name)) 
[13:19:25.378]                             next
[13:19:25.378]                           invokeRestart(restart)
[13:19:25.378]                           muffled <- TRUE
[13:19:25.378]                           break
[13:19:25.378]                         }
[13:19:25.378]                       }
[13:19:25.378]                     }
[13:19:25.378]                     invisible(muffled)
[13:19:25.378]                   }
[13:19:25.378]                   muffleCondition(cond)
[13:19:25.378]                 })
[13:19:25.378]             }))
[13:19:25.378]             future::FutureResult(value = ...future.value$value, 
[13:19:25.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:25.378]                   ...future.rng), globalenv = if (FALSE) 
[13:19:25.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:25.378]                     ...future.globalenv.names))
[13:19:25.378]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:25.378]         }, condition = base::local({
[13:19:25.378]             c <- base::c
[13:19:25.378]             inherits <- base::inherits
[13:19:25.378]             invokeRestart <- base::invokeRestart
[13:19:25.378]             length <- base::length
[13:19:25.378]             list <- base::list
[13:19:25.378]             seq.int <- base::seq.int
[13:19:25.378]             signalCondition <- base::signalCondition
[13:19:25.378]             sys.calls <- base::sys.calls
[13:19:25.378]             `[[` <- base::`[[`
[13:19:25.378]             `+` <- base::`+`
[13:19:25.378]             `<<-` <- base::`<<-`
[13:19:25.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:25.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:25.378]                   3L)]
[13:19:25.378]             }
[13:19:25.378]             function(cond) {
[13:19:25.378]                 is_error <- inherits(cond, "error")
[13:19:25.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:25.378]                   NULL)
[13:19:25.378]                 if (is_error) {
[13:19:25.378]                   sessionInformation <- function() {
[13:19:25.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:25.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:25.378]                       search = base::search(), system = base::Sys.info())
[13:19:25.378]                   }
[13:19:25.378]                   ...future.conditions[[length(...future.conditions) + 
[13:19:25.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:25.378]                     cond$call), session = sessionInformation(), 
[13:19:25.378]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:25.378]                   signalCondition(cond)
[13:19:25.378]                 }
[13:19:25.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:25.378]                 "immediateCondition"))) {
[13:19:25.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:25.378]                   ...future.conditions[[length(...future.conditions) + 
[13:19:25.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:25.378]                   if (TRUE && !signal) {
[13:19:25.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.378]                     {
[13:19:25.378]                       inherits <- base::inherits
[13:19:25.378]                       invokeRestart <- base::invokeRestart
[13:19:25.378]                       is.null <- base::is.null
[13:19:25.378]                       muffled <- FALSE
[13:19:25.378]                       if (inherits(cond, "message")) {
[13:19:25.378]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:25.378]                         if (muffled) 
[13:19:25.378]                           invokeRestart("muffleMessage")
[13:19:25.378]                       }
[13:19:25.378]                       else if (inherits(cond, "warning")) {
[13:19:25.378]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:25.378]                         if (muffled) 
[13:19:25.378]                           invokeRestart("muffleWarning")
[13:19:25.378]                       }
[13:19:25.378]                       else if (inherits(cond, "condition")) {
[13:19:25.378]                         if (!is.null(pattern)) {
[13:19:25.378]                           computeRestarts <- base::computeRestarts
[13:19:25.378]                           grepl <- base::grepl
[13:19:25.378]                           restarts <- computeRestarts(cond)
[13:19:25.378]                           for (restart in restarts) {
[13:19:25.378]                             name <- restart$name
[13:19:25.378]                             if (is.null(name)) 
[13:19:25.378]                               next
[13:19:25.378]                             if (!grepl(pattern, name)) 
[13:19:25.378]                               next
[13:19:25.378]                             invokeRestart(restart)
[13:19:25.378]                             muffled <- TRUE
[13:19:25.378]                             break
[13:19:25.378]                           }
[13:19:25.378]                         }
[13:19:25.378]                       }
[13:19:25.378]                       invisible(muffled)
[13:19:25.378]                     }
[13:19:25.378]                     muffleCondition(cond, pattern = "^muffle")
[13:19:25.378]                   }
[13:19:25.378]                 }
[13:19:25.378]                 else {
[13:19:25.378]                   if (TRUE) {
[13:19:25.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.378]                     {
[13:19:25.378]                       inherits <- base::inherits
[13:19:25.378]                       invokeRestart <- base::invokeRestart
[13:19:25.378]                       is.null <- base::is.null
[13:19:25.378]                       muffled <- FALSE
[13:19:25.378]                       if (inherits(cond, "message")) {
[13:19:25.378]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:25.378]                         if (muffled) 
[13:19:25.378]                           invokeRestart("muffleMessage")
[13:19:25.378]                       }
[13:19:25.378]                       else if (inherits(cond, "warning")) {
[13:19:25.378]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:25.378]                         if (muffled) 
[13:19:25.378]                           invokeRestart("muffleWarning")
[13:19:25.378]                       }
[13:19:25.378]                       else if (inherits(cond, "condition")) {
[13:19:25.378]                         if (!is.null(pattern)) {
[13:19:25.378]                           computeRestarts <- base::computeRestarts
[13:19:25.378]                           grepl <- base::grepl
[13:19:25.378]                           restarts <- computeRestarts(cond)
[13:19:25.378]                           for (restart in restarts) {
[13:19:25.378]                             name <- restart$name
[13:19:25.378]                             if (is.null(name)) 
[13:19:25.378]                               next
[13:19:25.378]                             if (!grepl(pattern, name)) 
[13:19:25.378]                               next
[13:19:25.378]                             invokeRestart(restart)
[13:19:25.378]                             muffled <- TRUE
[13:19:25.378]                             break
[13:19:25.378]                           }
[13:19:25.378]                         }
[13:19:25.378]                       }
[13:19:25.378]                       invisible(muffled)
[13:19:25.378]                     }
[13:19:25.378]                     muffleCondition(cond, pattern = "^muffle")
[13:19:25.378]                   }
[13:19:25.378]                 }
[13:19:25.378]             }
[13:19:25.378]         }))
[13:19:25.378]     }, error = function(ex) {
[13:19:25.378]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:25.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:25.378]                 ...future.rng), started = ...future.startTime, 
[13:19:25.378]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:25.378]             version = "1.8"), class = "FutureResult")
[13:19:25.378]     }, finally = {
[13:19:25.378]         if (!identical(...future.workdir, getwd())) 
[13:19:25.378]             setwd(...future.workdir)
[13:19:25.378]         {
[13:19:25.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:25.378]                 ...future.oldOptions$nwarnings <- NULL
[13:19:25.378]             }
[13:19:25.378]             base::options(...future.oldOptions)
[13:19:25.378]             if (.Platform$OS.type == "windows") {
[13:19:25.378]                 old_names <- names(...future.oldEnvVars)
[13:19:25.378]                 envs <- base::Sys.getenv()
[13:19:25.378]                 names <- names(envs)
[13:19:25.378]                 common <- intersect(names, old_names)
[13:19:25.378]                 added <- setdiff(names, old_names)
[13:19:25.378]                 removed <- setdiff(old_names, names)
[13:19:25.378]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:25.378]                   envs[common]]
[13:19:25.378]                 NAMES <- toupper(changed)
[13:19:25.378]                 args <- list()
[13:19:25.378]                 for (kk in seq_along(NAMES)) {
[13:19:25.378]                   name <- changed[[kk]]
[13:19:25.378]                   NAME <- NAMES[[kk]]
[13:19:25.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.378]                     next
[13:19:25.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:25.378]                 }
[13:19:25.378]                 NAMES <- toupper(added)
[13:19:25.378]                 for (kk in seq_along(NAMES)) {
[13:19:25.378]                   name <- added[[kk]]
[13:19:25.378]                   NAME <- NAMES[[kk]]
[13:19:25.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.378]                     next
[13:19:25.378]                   args[[name]] <- ""
[13:19:25.378]                 }
[13:19:25.378]                 NAMES <- toupper(removed)
[13:19:25.378]                 for (kk in seq_along(NAMES)) {
[13:19:25.378]                   name <- removed[[kk]]
[13:19:25.378]                   NAME <- NAMES[[kk]]
[13:19:25.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.378]                     next
[13:19:25.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:25.378]                 }
[13:19:25.378]                 if (length(args) > 0) 
[13:19:25.378]                   base::do.call(base::Sys.setenv, args = args)
[13:19:25.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:25.378]             }
[13:19:25.378]             else {
[13:19:25.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:25.378]             }
[13:19:25.378]             {
[13:19:25.378]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:25.378]                   0L) {
[13:19:25.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:25.378]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:25.378]                   base::options(opts)
[13:19:25.378]                 }
[13:19:25.378]                 {
[13:19:25.378]                   {
[13:19:25.378]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:25.378]                     NULL
[13:19:25.378]                   }
[13:19:25.378]                   options(future.plan = NULL)
[13:19:25.378]                   if (is.na(NA_character_)) 
[13:19:25.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:25.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:25.378]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:25.378]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:25.378]                     envir = parent.frame()) 
[13:19:25.378]                   {
[13:19:25.378]                     if (is.function(workers)) 
[13:19:25.378]                       workers <- workers()
[13:19:25.378]                     workers <- structure(as.integer(workers), 
[13:19:25.378]                       class = class(workers))
[13:19:25.378]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:25.378]                       workers >= 1)
[13:19:25.378]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:25.378]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:25.378]                     }
[13:19:25.378]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:25.378]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:25.378]                       envir = envir)
[13:19:25.378]                     if (!future$lazy) 
[13:19:25.378]                       future <- run(future)
[13:19:25.378]                     invisible(future)
[13:19:25.378]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:25.378]                 }
[13:19:25.378]             }
[13:19:25.378]         }
[13:19:25.378]     })
[13:19:25.378]     if (TRUE) {
[13:19:25.378]         base::sink(type = "output", split = FALSE)
[13:19:25.378]         if (FALSE) {
[13:19:25.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:25.378]         }
[13:19:25.378]         else {
[13:19:25.378]             ...future.result["stdout"] <- base::list(NULL)
[13:19:25.378]         }
[13:19:25.378]         base::close(...future.stdout)
[13:19:25.378]         ...future.stdout <- NULL
[13:19:25.378]     }
[13:19:25.378]     ...future.result$conditions <- ...future.conditions
[13:19:25.378]     ...future.result$finished <- base::Sys.time()
[13:19:25.378]     ...future.result
[13:19:25.378] }
[13:19:25.381] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:19:25.381] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:19:25.381] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:19:25.381] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:19:25.382] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:19:25.382] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:19:25.382] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:19:25.382] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:25.383] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:25.383] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:25.383] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:25.383] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:19:25.384] MultisessionFuture started
[13:19:25.384] - Launch lazy future ... done
[13:19:25.384] run() for ‘MultisessionFuture’ ... done
[13:19:25.384] Created future:
[13:19:25.384] MultisessionFuture:
[13:19:25.384] Label: ‘future_mapply-1’
[13:19:25.384] Expression:
[13:19:25.384] {
[13:19:25.384]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:25.384]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:25.384]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:25.384]         on.exit(options(oopts), add = TRUE)
[13:19:25.384]     }
[13:19:25.384]     {
[13:19:25.384]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:25.384]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:25.384]         do.call(mapply, args = args)
[13:19:25.384]     }
[13:19:25.384] }
[13:19:25.384] Lazy evaluation: FALSE
[13:19:25.384] Asynchronous evaluation: TRUE
[13:19:25.384] Local evaluation: TRUE
[13:19:25.384] Environment: R_GlobalEnv
[13:19:25.384] Capture standard output: FALSE
[13:19:25.384] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:25.384] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:25.384] Packages: <none>
[13:19:25.384] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:25.384] Resolved: FALSE
[13:19:25.384] Value: <not collected>
[13:19:25.384] Conditions captured: <none>
[13:19:25.384] Early signaling: FALSE
[13:19:25.384] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:25.384] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:25.396] Chunk #1 of 2 ... DONE
[13:19:25.396] Chunk #2 of 2 ...
[13:19:25.396]  - Finding globals in '...' for chunk #2 ...
[13:19:25.396] getGlobalsAndPackages() ...
[13:19:25.396] Searching for globals...
[13:19:25.397] 
[13:19:25.397] Searching for globals ... DONE
[13:19:25.397] - globals: [0] <none>
[13:19:25.397] getGlobalsAndPackages() ... DONE
[13:19:25.397]    + additional globals found: [n=0] 
[13:19:25.397]    + additional namespaces needed: [n=0] 
[13:19:25.397]  - Finding globals in '...' for chunk #2 ... DONE
[13:19:25.397]  - seeds: <none>
[13:19:25.398] getGlobalsAndPackages() ...
[13:19:25.398] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:25.398] Resolving globals: FALSE
[13:19:25.398] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:25.399] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:25.399] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:25.399] 
[13:19:25.399] getGlobalsAndPackages() ... DONE
[13:19:25.399] run() for ‘Future’ ...
[13:19:25.399] - state: ‘created’
[13:19:25.400] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:25.414] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:25.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:25.415]   - Field: ‘node’
[13:19:25.415]   - Field: ‘label’
[13:19:25.415]   - Field: ‘local’
[13:19:25.415]   - Field: ‘owner’
[13:19:25.415]   - Field: ‘envir’
[13:19:25.415]   - Field: ‘workers’
[13:19:25.415]   - Field: ‘packages’
[13:19:25.415]   - Field: ‘gc’
[13:19:25.416]   - Field: ‘conditions’
[13:19:25.416]   - Field: ‘persistent’
[13:19:25.416]   - Field: ‘expr’
[13:19:25.416]   - Field: ‘uuid’
[13:19:25.416]   - Field: ‘seed’
[13:19:25.416]   - Field: ‘version’
[13:19:25.416]   - Field: ‘result’
[13:19:25.416]   - Field: ‘asynchronous’
[13:19:25.416]   - Field: ‘calls’
[13:19:25.416]   - Field: ‘globals’
[13:19:25.416]   - Field: ‘stdout’
[13:19:25.417]   - Field: ‘earlySignal’
[13:19:25.417]   - Field: ‘lazy’
[13:19:25.417]   - Field: ‘state’
[13:19:25.417] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:25.417] - Launch lazy future ...
[13:19:25.417] Packages needed by the future expression (n = 0): <none>
[13:19:25.417] Packages needed by future strategies (n = 0): <none>
[13:19:25.418] {
[13:19:25.418]     {
[13:19:25.418]         {
[13:19:25.418]             ...future.startTime <- base::Sys.time()
[13:19:25.418]             {
[13:19:25.418]                 {
[13:19:25.418]                   {
[13:19:25.418]                     {
[13:19:25.418]                       base::local({
[13:19:25.418]                         has_future <- base::requireNamespace("future", 
[13:19:25.418]                           quietly = TRUE)
[13:19:25.418]                         if (has_future) {
[13:19:25.418]                           ns <- base::getNamespace("future")
[13:19:25.418]                           version <- ns[[".package"]][["version"]]
[13:19:25.418]                           if (is.null(version)) 
[13:19:25.418]                             version <- utils::packageVersion("future")
[13:19:25.418]                         }
[13:19:25.418]                         else {
[13:19:25.418]                           version <- NULL
[13:19:25.418]                         }
[13:19:25.418]                         if (!has_future || version < "1.8.0") {
[13:19:25.418]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:25.418]                             "", base::R.version$version.string), 
[13:19:25.418]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:25.418]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:25.418]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:25.418]                               "release", "version")], collapse = " "), 
[13:19:25.418]                             hostname = base::Sys.info()[["nodename"]])
[13:19:25.418]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:25.418]                             info)
[13:19:25.418]                           info <- base::paste(info, collapse = "; ")
[13:19:25.418]                           if (!has_future) {
[13:19:25.418]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:25.418]                               info)
[13:19:25.418]                           }
[13:19:25.418]                           else {
[13:19:25.418]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:25.418]                               info, version)
[13:19:25.418]                           }
[13:19:25.418]                           base::stop(msg)
[13:19:25.418]                         }
[13:19:25.418]                       })
[13:19:25.418]                     }
[13:19:25.418]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:25.418]                     base::options(mc.cores = 1L)
[13:19:25.418]                   }
[13:19:25.418]                   options(future.plan = NULL)
[13:19:25.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:25.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:25.418]                 }
[13:19:25.418]                 ...future.workdir <- getwd()
[13:19:25.418]             }
[13:19:25.418]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:25.418]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:25.418]         }
[13:19:25.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:25.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:25.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:25.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:25.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:25.418]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:25.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:25.418]             base::names(...future.oldOptions))
[13:19:25.418]     }
[13:19:25.418]     if (FALSE) {
[13:19:25.418]     }
[13:19:25.418]     else {
[13:19:25.418]         if (FALSE) {
[13:19:25.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:25.418]                 open = "w")
[13:19:25.418]         }
[13:19:25.418]         else {
[13:19:25.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:25.418]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:25.418]         }
[13:19:25.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:25.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:25.418]             base::sink(type = "output", split = FALSE)
[13:19:25.418]             base::close(...future.stdout)
[13:19:25.418]         }, add = TRUE)
[13:19:25.418]     }
[13:19:25.418]     ...future.frame <- base::sys.nframe()
[13:19:25.418]     ...future.conditions <- base::list()
[13:19:25.418]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:25.418]     if (FALSE) {
[13:19:25.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:25.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:25.418]     }
[13:19:25.418]     ...future.result <- base::tryCatch({
[13:19:25.418]         base::withCallingHandlers({
[13:19:25.418]             ...future.value <- base::withVisible(base::local({
[13:19:25.418]                 ...future.makeSendCondition <- local({
[13:19:25.418]                   sendCondition <- NULL
[13:19:25.418]                   function(frame = 1L) {
[13:19:25.418]                     if (is.function(sendCondition)) 
[13:19:25.418]                       return(sendCondition)
[13:19:25.418]                     ns <- getNamespace("parallel")
[13:19:25.418]                     if (exists("sendData", mode = "function", 
[13:19:25.418]                       envir = ns)) {
[13:19:25.418]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:25.418]                         envir = ns)
[13:19:25.418]                       envir <- sys.frame(frame)
[13:19:25.418]                       master <- NULL
[13:19:25.418]                       while (!identical(envir, .GlobalEnv) && 
[13:19:25.418]                         !identical(envir, emptyenv())) {
[13:19:25.418]                         if (exists("master", mode = "list", envir = envir, 
[13:19:25.418]                           inherits = FALSE)) {
[13:19:25.418]                           master <- get("master", mode = "list", 
[13:19:25.418]                             envir = envir, inherits = FALSE)
[13:19:25.418]                           if (inherits(master, c("SOCKnode", 
[13:19:25.418]                             "SOCK0node"))) {
[13:19:25.418]                             sendCondition <<- function(cond) {
[13:19:25.418]                               data <- list(type = "VALUE", value = cond, 
[13:19:25.418]                                 success = TRUE)
[13:19:25.418]                               parallel_sendData(master, data)
[13:19:25.418]                             }
[13:19:25.418]                             return(sendCondition)
[13:19:25.418]                           }
[13:19:25.418]                         }
[13:19:25.418]                         frame <- frame + 1L
[13:19:25.418]                         envir <- sys.frame(frame)
[13:19:25.418]                       }
[13:19:25.418]                     }
[13:19:25.418]                     sendCondition <<- function(cond) NULL
[13:19:25.418]                   }
[13:19:25.418]                 })
[13:19:25.418]                 withCallingHandlers({
[13:19:25.418]                   {
[13:19:25.418]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:25.418]                     if (!identical(...future.globals.maxSize.org, 
[13:19:25.418]                       ...future.globals.maxSize)) {
[13:19:25.418]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:25.418]                       on.exit(options(oopts), add = TRUE)
[13:19:25.418]                     }
[13:19:25.418]                     {
[13:19:25.418]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:25.418]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:25.418]                         USE.NAMES = FALSE)
[13:19:25.418]                       do.call(mapply, args = args)
[13:19:25.418]                     }
[13:19:25.418]                   }
[13:19:25.418]                 }, immediateCondition = function(cond) {
[13:19:25.418]                   sendCondition <- ...future.makeSendCondition()
[13:19:25.418]                   sendCondition(cond)
[13:19:25.418]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.418]                   {
[13:19:25.418]                     inherits <- base::inherits
[13:19:25.418]                     invokeRestart <- base::invokeRestart
[13:19:25.418]                     is.null <- base::is.null
[13:19:25.418]                     muffled <- FALSE
[13:19:25.418]                     if (inherits(cond, "message")) {
[13:19:25.418]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:25.418]                       if (muffled) 
[13:19:25.418]                         invokeRestart("muffleMessage")
[13:19:25.418]                     }
[13:19:25.418]                     else if (inherits(cond, "warning")) {
[13:19:25.418]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:25.418]                       if (muffled) 
[13:19:25.418]                         invokeRestart("muffleWarning")
[13:19:25.418]                     }
[13:19:25.418]                     else if (inherits(cond, "condition")) {
[13:19:25.418]                       if (!is.null(pattern)) {
[13:19:25.418]                         computeRestarts <- base::computeRestarts
[13:19:25.418]                         grepl <- base::grepl
[13:19:25.418]                         restarts <- computeRestarts(cond)
[13:19:25.418]                         for (restart in restarts) {
[13:19:25.418]                           name <- restart$name
[13:19:25.418]                           if (is.null(name)) 
[13:19:25.418]                             next
[13:19:25.418]                           if (!grepl(pattern, name)) 
[13:19:25.418]                             next
[13:19:25.418]                           invokeRestart(restart)
[13:19:25.418]                           muffled <- TRUE
[13:19:25.418]                           break
[13:19:25.418]                         }
[13:19:25.418]                       }
[13:19:25.418]                     }
[13:19:25.418]                     invisible(muffled)
[13:19:25.418]                   }
[13:19:25.418]                   muffleCondition(cond)
[13:19:25.418]                 })
[13:19:25.418]             }))
[13:19:25.418]             future::FutureResult(value = ...future.value$value, 
[13:19:25.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:25.418]                   ...future.rng), globalenv = if (FALSE) 
[13:19:25.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:25.418]                     ...future.globalenv.names))
[13:19:25.418]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:25.418]         }, condition = base::local({
[13:19:25.418]             c <- base::c
[13:19:25.418]             inherits <- base::inherits
[13:19:25.418]             invokeRestart <- base::invokeRestart
[13:19:25.418]             length <- base::length
[13:19:25.418]             list <- base::list
[13:19:25.418]             seq.int <- base::seq.int
[13:19:25.418]             signalCondition <- base::signalCondition
[13:19:25.418]             sys.calls <- base::sys.calls
[13:19:25.418]             `[[` <- base::`[[`
[13:19:25.418]             `+` <- base::`+`
[13:19:25.418]             `<<-` <- base::`<<-`
[13:19:25.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:25.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:25.418]                   3L)]
[13:19:25.418]             }
[13:19:25.418]             function(cond) {
[13:19:25.418]                 is_error <- inherits(cond, "error")
[13:19:25.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:25.418]                   NULL)
[13:19:25.418]                 if (is_error) {
[13:19:25.418]                   sessionInformation <- function() {
[13:19:25.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:25.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:25.418]                       search = base::search(), system = base::Sys.info())
[13:19:25.418]                   }
[13:19:25.418]                   ...future.conditions[[length(...future.conditions) + 
[13:19:25.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:25.418]                     cond$call), session = sessionInformation(), 
[13:19:25.418]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:25.418]                   signalCondition(cond)
[13:19:25.418]                 }
[13:19:25.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:25.418]                 "immediateCondition"))) {
[13:19:25.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:25.418]                   ...future.conditions[[length(...future.conditions) + 
[13:19:25.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:25.418]                   if (TRUE && !signal) {
[13:19:25.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.418]                     {
[13:19:25.418]                       inherits <- base::inherits
[13:19:25.418]                       invokeRestart <- base::invokeRestart
[13:19:25.418]                       is.null <- base::is.null
[13:19:25.418]                       muffled <- FALSE
[13:19:25.418]                       if (inherits(cond, "message")) {
[13:19:25.418]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:25.418]                         if (muffled) 
[13:19:25.418]                           invokeRestart("muffleMessage")
[13:19:25.418]                       }
[13:19:25.418]                       else if (inherits(cond, "warning")) {
[13:19:25.418]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:25.418]                         if (muffled) 
[13:19:25.418]                           invokeRestart("muffleWarning")
[13:19:25.418]                       }
[13:19:25.418]                       else if (inherits(cond, "condition")) {
[13:19:25.418]                         if (!is.null(pattern)) {
[13:19:25.418]                           computeRestarts <- base::computeRestarts
[13:19:25.418]                           grepl <- base::grepl
[13:19:25.418]                           restarts <- computeRestarts(cond)
[13:19:25.418]                           for (restart in restarts) {
[13:19:25.418]                             name <- restart$name
[13:19:25.418]                             if (is.null(name)) 
[13:19:25.418]                               next
[13:19:25.418]                             if (!grepl(pattern, name)) 
[13:19:25.418]                               next
[13:19:25.418]                             invokeRestart(restart)
[13:19:25.418]                             muffled <- TRUE
[13:19:25.418]                             break
[13:19:25.418]                           }
[13:19:25.418]                         }
[13:19:25.418]                       }
[13:19:25.418]                       invisible(muffled)
[13:19:25.418]                     }
[13:19:25.418]                     muffleCondition(cond, pattern = "^muffle")
[13:19:25.418]                   }
[13:19:25.418]                 }
[13:19:25.418]                 else {
[13:19:25.418]                   if (TRUE) {
[13:19:25.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.418]                     {
[13:19:25.418]                       inherits <- base::inherits
[13:19:25.418]                       invokeRestart <- base::invokeRestart
[13:19:25.418]                       is.null <- base::is.null
[13:19:25.418]                       muffled <- FALSE
[13:19:25.418]                       if (inherits(cond, "message")) {
[13:19:25.418]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:25.418]                         if (muffled) 
[13:19:25.418]                           invokeRestart("muffleMessage")
[13:19:25.418]                       }
[13:19:25.418]                       else if (inherits(cond, "warning")) {
[13:19:25.418]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:25.418]                         if (muffled) 
[13:19:25.418]                           invokeRestart("muffleWarning")
[13:19:25.418]                       }
[13:19:25.418]                       else if (inherits(cond, "condition")) {
[13:19:25.418]                         if (!is.null(pattern)) {
[13:19:25.418]                           computeRestarts <- base::computeRestarts
[13:19:25.418]                           grepl <- base::grepl
[13:19:25.418]                           restarts <- computeRestarts(cond)
[13:19:25.418]                           for (restart in restarts) {
[13:19:25.418]                             name <- restart$name
[13:19:25.418]                             if (is.null(name)) 
[13:19:25.418]                               next
[13:19:25.418]                             if (!grepl(pattern, name)) 
[13:19:25.418]                               next
[13:19:25.418]                             invokeRestart(restart)
[13:19:25.418]                             muffled <- TRUE
[13:19:25.418]                             break
[13:19:25.418]                           }
[13:19:25.418]                         }
[13:19:25.418]                       }
[13:19:25.418]                       invisible(muffled)
[13:19:25.418]                     }
[13:19:25.418]                     muffleCondition(cond, pattern = "^muffle")
[13:19:25.418]                   }
[13:19:25.418]                 }
[13:19:25.418]             }
[13:19:25.418]         }))
[13:19:25.418]     }, error = function(ex) {
[13:19:25.418]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:25.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:25.418]                 ...future.rng), started = ...future.startTime, 
[13:19:25.418]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:25.418]             version = "1.8"), class = "FutureResult")
[13:19:25.418]     }, finally = {
[13:19:25.418]         if (!identical(...future.workdir, getwd())) 
[13:19:25.418]             setwd(...future.workdir)
[13:19:25.418]         {
[13:19:25.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:25.418]                 ...future.oldOptions$nwarnings <- NULL
[13:19:25.418]             }
[13:19:25.418]             base::options(...future.oldOptions)
[13:19:25.418]             if (.Platform$OS.type == "windows") {
[13:19:25.418]                 old_names <- names(...future.oldEnvVars)
[13:19:25.418]                 envs <- base::Sys.getenv()
[13:19:25.418]                 names <- names(envs)
[13:19:25.418]                 common <- intersect(names, old_names)
[13:19:25.418]                 added <- setdiff(names, old_names)
[13:19:25.418]                 removed <- setdiff(old_names, names)
[13:19:25.418]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:25.418]                   envs[common]]
[13:19:25.418]                 NAMES <- toupper(changed)
[13:19:25.418]                 args <- list()
[13:19:25.418]                 for (kk in seq_along(NAMES)) {
[13:19:25.418]                   name <- changed[[kk]]
[13:19:25.418]                   NAME <- NAMES[[kk]]
[13:19:25.418]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.418]                     next
[13:19:25.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:25.418]                 }
[13:19:25.418]                 NAMES <- toupper(added)
[13:19:25.418]                 for (kk in seq_along(NAMES)) {
[13:19:25.418]                   name <- added[[kk]]
[13:19:25.418]                   NAME <- NAMES[[kk]]
[13:19:25.418]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.418]                     next
[13:19:25.418]                   args[[name]] <- ""
[13:19:25.418]                 }
[13:19:25.418]                 NAMES <- toupper(removed)
[13:19:25.418]                 for (kk in seq_along(NAMES)) {
[13:19:25.418]                   name <- removed[[kk]]
[13:19:25.418]                   NAME <- NAMES[[kk]]
[13:19:25.418]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.418]                     next
[13:19:25.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:25.418]                 }
[13:19:25.418]                 if (length(args) > 0) 
[13:19:25.418]                   base::do.call(base::Sys.setenv, args = args)
[13:19:25.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:25.418]             }
[13:19:25.418]             else {
[13:19:25.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:25.418]             }
[13:19:25.418]             {
[13:19:25.418]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:25.418]                   0L) {
[13:19:25.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:25.418]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:25.418]                   base::options(opts)
[13:19:25.418]                 }
[13:19:25.418]                 {
[13:19:25.418]                   {
[13:19:25.418]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:25.418]                     NULL
[13:19:25.418]                   }
[13:19:25.418]                   options(future.plan = NULL)
[13:19:25.418]                   if (is.na(NA_character_)) 
[13:19:25.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:25.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:25.418]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:25.418]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:25.418]                     envir = parent.frame()) 
[13:19:25.418]                   {
[13:19:25.418]                     if (is.function(workers)) 
[13:19:25.418]                       workers <- workers()
[13:19:25.418]                     workers <- structure(as.integer(workers), 
[13:19:25.418]                       class = class(workers))
[13:19:25.418]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:25.418]                       workers >= 1)
[13:19:25.418]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:25.418]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:25.418]                     }
[13:19:25.418]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:25.418]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:25.418]                       envir = envir)
[13:19:25.418]                     if (!future$lazy) 
[13:19:25.418]                       future <- run(future)
[13:19:25.418]                     invisible(future)
[13:19:25.418]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:25.418]                 }
[13:19:25.418]             }
[13:19:25.418]         }
[13:19:25.418]     })
[13:19:25.418]     if (TRUE) {
[13:19:25.418]         base::sink(type = "output", split = FALSE)
[13:19:25.418]         if (FALSE) {
[13:19:25.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:25.418]         }
[13:19:25.418]         else {
[13:19:25.418]             ...future.result["stdout"] <- base::list(NULL)
[13:19:25.418]         }
[13:19:25.418]         base::close(...future.stdout)
[13:19:25.418]         ...future.stdout <- NULL
[13:19:25.418]     }
[13:19:25.418]     ...future.result$conditions <- ...future.conditions
[13:19:25.418]     ...future.result$finished <- base::Sys.time()
[13:19:25.418]     ...future.result
[13:19:25.418] }
[13:19:25.421] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:19:25.421] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:19:25.421] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:19:25.421] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:19:25.422] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:19:25.422] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:19:25.422] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:19:25.422] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:25.422] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:25.423] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:25.423] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:25.423] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:19:25.424] MultisessionFuture started
[13:19:25.424] - Launch lazy future ... done
[13:19:25.424] run() for ‘MultisessionFuture’ ... done
[13:19:25.424] Created future:
[13:19:25.424] MultisessionFuture:
[13:19:25.424] Label: ‘future_mapply-2’
[13:19:25.424] Expression:
[13:19:25.424] {
[13:19:25.424]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:25.424]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:25.424]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:25.424]         on.exit(options(oopts), add = TRUE)
[13:19:25.424]     }
[13:19:25.424]     {
[13:19:25.424]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:25.424]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:25.424]         do.call(mapply, args = args)
[13:19:25.424]     }
[13:19:25.424] }
[13:19:25.424] Lazy evaluation: FALSE
[13:19:25.424] Asynchronous evaluation: TRUE
[13:19:25.424] Local evaluation: TRUE
[13:19:25.424] Environment: R_GlobalEnv
[13:19:25.424] Capture standard output: FALSE
[13:19:25.424] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:25.424] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:25.424] Packages: <none>
[13:19:25.424] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:25.424] Resolved: FALSE
[13:19:25.424] Value: <not collected>
[13:19:25.424] Conditions captured: <none>
[13:19:25.424] Early signaling: FALSE
[13:19:25.424] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:25.424] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:25.436] Chunk #2 of 2 ... DONE
[13:19:25.436] Launching 2 futures (chunks) ... DONE
[13:19:25.436] Resolving 2 futures (chunks) ...
[13:19:25.436] resolve() on list ...
[13:19:25.436]  recursive: 0
[13:19:25.436]  length: 2
[13:19:25.436] 
[13:19:25.478] receiveMessageFromWorker() for ClusterFuture ...
[13:19:25.478] - Validating connection of MultisessionFuture
[13:19:25.479] - received message: FutureResult
[13:19:25.479] - Received FutureResult
[13:19:25.479] - Erased future from FutureRegistry
[13:19:25.479] result() for ClusterFuture ...
[13:19:25.479] - result already collected: FutureResult
[13:19:25.479] result() for ClusterFuture ... done
[13:19:25.479] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:25.479] Future #2
[13:19:25.479] result() for ClusterFuture ...
[13:19:25.480] - result already collected: FutureResult
[13:19:25.480] result() for ClusterFuture ... done
[13:19:25.480] result() for ClusterFuture ...
[13:19:25.480] - result already collected: FutureResult
[13:19:25.480] result() for ClusterFuture ... done
[13:19:25.480] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:25.480] - nx: 2
[13:19:25.480] - relay: TRUE
[13:19:25.480] - stdout: TRUE
[13:19:25.480] - signal: TRUE
[13:19:25.480] - resignal: FALSE
[13:19:25.481] - force: TRUE
[13:19:25.481] - relayed: [n=2] FALSE, FALSE
[13:19:25.481] - queued futures: [n=2] FALSE, FALSE
[13:19:25.481]  - until=1
[13:19:25.481]  - relaying element #1
[13:19:25.481] - relayed: [n=2] FALSE, FALSE
[13:19:25.481] - queued futures: [n=2] FALSE, TRUE
[13:19:25.481] signalConditionsASAP(NULL, pos=2) ... done
[13:19:25.481]  length: 1 (resolved future 2)
[13:19:25.930] receiveMessageFromWorker() for ClusterFuture ...
[13:19:25.931] - Validating connection of MultisessionFuture
[13:19:25.931] - received message: FutureResult
[13:19:25.931] - Received FutureResult
[13:19:25.931] - Erased future from FutureRegistry
[13:19:25.931] result() for ClusterFuture ...
[13:19:25.931] - result already collected: FutureResult
[13:19:25.931] result() for ClusterFuture ... done
[13:19:25.932] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:25.932] Future #1
[13:19:25.932] result() for ClusterFuture ...
[13:19:25.932] - result already collected: FutureResult
[13:19:25.932] result() for ClusterFuture ... done
[13:19:25.932] result() for ClusterFuture ...
[13:19:25.932] - result already collected: FutureResult
[13:19:25.932] result() for ClusterFuture ... done
[13:19:25.932] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:25.932] - nx: 2
[13:19:25.932] - relay: TRUE
[13:19:25.932] - stdout: TRUE
[13:19:25.933] - signal: TRUE
[13:19:25.933] - resignal: FALSE
[13:19:25.933] - force: TRUE
[13:19:25.933] - relayed: [n=2] FALSE, FALSE
[13:19:25.933] - queued futures: [n=2] FALSE, TRUE
[13:19:25.933]  - until=1
[13:19:25.933]  - relaying element #1
[13:19:25.933] result() for ClusterFuture ...
[13:19:25.933] - result already collected: FutureResult
[13:19:25.933] result() for ClusterFuture ... done
[13:19:25.933] result() for ClusterFuture ...
[13:19:25.934] - result already collected: FutureResult
[13:19:25.934] result() for ClusterFuture ... done
[13:19:25.934] result() for ClusterFuture ...
[13:19:25.934] - result already collected: FutureResult
[13:19:25.934] result() for ClusterFuture ... done
[13:19:25.934] result() for ClusterFuture ...
[13:19:25.934] - result already collected: FutureResult
[13:19:25.934] result() for ClusterFuture ... done
[13:19:25.934] - relayed: [n=2] TRUE, FALSE
[13:19:25.934] - queued futures: [n=2] TRUE, TRUE
[13:19:25.934] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:25.935]  length: 0 (resolved future 1)
[13:19:25.935] Relaying remaining futures
[13:19:25.935] signalConditionsASAP(NULL, pos=0) ...
[13:19:25.935] - nx: 2
[13:19:25.935] - relay: TRUE
[13:19:25.935] - stdout: TRUE
[13:19:25.935] - signal: TRUE
[13:19:25.935] - resignal: FALSE
[13:19:25.935] - force: TRUE
[13:19:25.935] - relayed: [n=2] TRUE, FALSE
[13:19:25.935] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:25.935]  - relaying element #2
[13:19:25.936] result() for ClusterFuture ...
[13:19:25.936] - result already collected: FutureResult
[13:19:25.936] result() for ClusterFuture ... done
[13:19:25.936] result() for ClusterFuture ...
[13:19:25.936] - result already collected: FutureResult
[13:19:25.936] result() for ClusterFuture ... done
[13:19:25.936] result() for ClusterFuture ...
[13:19:25.936] - result already collected: FutureResult
[13:19:25.936] result() for ClusterFuture ... done
[13:19:25.936] result() for ClusterFuture ...
[13:19:25.936] - result already collected: FutureResult
[13:19:25.937] result() for ClusterFuture ... done
[13:19:25.937] - relayed: [n=2] TRUE, TRUE
[13:19:25.937] - queued futures: [n=2] TRUE, TRUE
[13:19:25.937] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:19:25.937] resolve() on list ... DONE
[13:19:25.937] result() for ClusterFuture ...
[13:19:25.937] - result already collected: FutureResult
[13:19:25.937] result() for ClusterFuture ... done
[13:19:25.937] result() for ClusterFuture ...
[13:19:25.937] - result already collected: FutureResult
[13:19:25.937] result() for ClusterFuture ... done
[13:19:25.937] result() for ClusterFuture ...
[13:19:25.938] - result already collected: FutureResult
[13:19:25.938] result() for ClusterFuture ... done
[13:19:25.938] result() for ClusterFuture ...
[13:19:25.938] - result already collected: FutureResult
[13:19:25.938] result() for ClusterFuture ... done
[13:19:25.938]  - Number of value chunks collected: 2
[13:19:25.938] Resolving 2 futures (chunks) ... DONE
[13:19:25.938] Reducing values from 2 chunks ...
[13:19:25.938]  - Number of values collected after concatenation: 2
[13:19:25.938]  - Number of values expected: 2
[13:19:25.938] Reducing values from 2 chunks ... DONE
[13:19:25.939] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:19:25.939] future_mapply() ...
[13:19:25.943] Number of chunks: 2
[13:19:25.943] getGlobalsAndPackagesXApply() ...
[13:19:25.943]  - future.globals: TRUE
[13:19:25.943] getGlobalsAndPackages() ...
[13:19:25.943] Searching for globals...
[13:19:25.945] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:25.945] Searching for globals ... DONE
[13:19:25.945] Resolving globals: FALSE
[13:19:25.945] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:25.946] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:25.946] - globals: [1] ‘FUN’
[13:19:25.946] 
[13:19:25.946] getGlobalsAndPackages() ... DONE
[13:19:25.946]  - globals found/used: [n=1] ‘FUN’
[13:19:25.946]  - needed namespaces: [n=0] 
[13:19:25.946] Finding globals ... DONE
[13:19:25.946] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:25.946] List of 2
[13:19:25.946]  $ ...future.FUN:function (x, y)  
[13:19:25.946]  $ MoreArgs     : NULL
[13:19:25.946]  - attr(*, "where")=List of 2
[13:19:25.946]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:25.946]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:25.946]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:25.946]  - attr(*, "resolved")= logi FALSE
[13:19:25.946]  - attr(*, "total_size")= num NA
[13:19:25.949] Packages to be attached in all futures: [n=0] 
[13:19:25.949] getGlobalsAndPackagesXApply() ... DONE
[13:19:25.949] Number of futures (= number of chunks): 2
[13:19:25.949] Launching 2 futures (chunks) ...
[13:19:25.949] Chunk #1 of 2 ...
[13:19:25.950]  - Finding globals in '...' for chunk #1 ...
[13:19:25.950] getGlobalsAndPackages() ...
[13:19:25.950] Searching for globals...
[13:19:25.950] 
[13:19:25.950] Searching for globals ... DONE
[13:19:25.950] - globals: [0] <none>
[13:19:25.950] getGlobalsAndPackages() ... DONE
[13:19:25.950]    + additional globals found: [n=0] 
[13:19:25.950]    + additional namespaces needed: [n=0] 
[13:19:25.951]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:25.951]  - seeds: <none>
[13:19:25.951] getGlobalsAndPackages() ...
[13:19:25.951] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:25.951] Resolving globals: FALSE
[13:19:25.951] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:25.952] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:25.952] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:25.952] 
[13:19:25.952] getGlobalsAndPackages() ... DONE
[13:19:25.952] run() for ‘Future’ ...
[13:19:25.953] - state: ‘created’
[13:19:25.953] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:25.967] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:25.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:25.967]   - Field: ‘node’
[13:19:25.968]   - Field: ‘label’
[13:19:25.968]   - Field: ‘local’
[13:19:25.968]   - Field: ‘owner’
[13:19:25.968]   - Field: ‘envir’
[13:19:25.968]   - Field: ‘workers’
[13:19:25.968]   - Field: ‘packages’
[13:19:25.968]   - Field: ‘gc’
[13:19:25.968]   - Field: ‘conditions’
[13:19:25.968]   - Field: ‘persistent’
[13:19:25.968]   - Field: ‘expr’
[13:19:25.969]   - Field: ‘uuid’
[13:19:25.969]   - Field: ‘seed’
[13:19:25.969]   - Field: ‘version’
[13:19:25.969]   - Field: ‘result’
[13:19:25.969]   - Field: ‘asynchronous’
[13:19:25.969]   - Field: ‘calls’
[13:19:25.969]   - Field: ‘globals’
[13:19:25.969]   - Field: ‘stdout’
[13:19:25.969]   - Field: ‘earlySignal’
[13:19:25.969]   - Field: ‘lazy’
[13:19:25.970]   - Field: ‘state’
[13:19:25.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:25.970] - Launch lazy future ...
[13:19:25.970] Packages needed by the future expression (n = 0): <none>
[13:19:25.970] Packages needed by future strategies (n = 0): <none>
[13:19:25.971] {
[13:19:25.971]     {
[13:19:25.971]         {
[13:19:25.971]             ...future.startTime <- base::Sys.time()
[13:19:25.971]             {
[13:19:25.971]                 {
[13:19:25.971]                   {
[13:19:25.971]                     {
[13:19:25.971]                       base::local({
[13:19:25.971]                         has_future <- base::requireNamespace("future", 
[13:19:25.971]                           quietly = TRUE)
[13:19:25.971]                         if (has_future) {
[13:19:25.971]                           ns <- base::getNamespace("future")
[13:19:25.971]                           version <- ns[[".package"]][["version"]]
[13:19:25.971]                           if (is.null(version)) 
[13:19:25.971]                             version <- utils::packageVersion("future")
[13:19:25.971]                         }
[13:19:25.971]                         else {
[13:19:25.971]                           version <- NULL
[13:19:25.971]                         }
[13:19:25.971]                         if (!has_future || version < "1.8.0") {
[13:19:25.971]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:25.971]                             "", base::R.version$version.string), 
[13:19:25.971]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:25.971]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:25.971]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:25.971]                               "release", "version")], collapse = " "), 
[13:19:25.971]                             hostname = base::Sys.info()[["nodename"]])
[13:19:25.971]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:25.971]                             info)
[13:19:25.971]                           info <- base::paste(info, collapse = "; ")
[13:19:25.971]                           if (!has_future) {
[13:19:25.971]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:25.971]                               info)
[13:19:25.971]                           }
[13:19:25.971]                           else {
[13:19:25.971]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:25.971]                               info, version)
[13:19:25.971]                           }
[13:19:25.971]                           base::stop(msg)
[13:19:25.971]                         }
[13:19:25.971]                       })
[13:19:25.971]                     }
[13:19:25.971]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:25.971]                     base::options(mc.cores = 1L)
[13:19:25.971]                   }
[13:19:25.971]                   options(future.plan = NULL)
[13:19:25.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:25.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:25.971]                 }
[13:19:25.971]                 ...future.workdir <- getwd()
[13:19:25.971]             }
[13:19:25.971]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:25.971]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:25.971]         }
[13:19:25.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:25.971]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:25.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:25.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:25.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:25.971]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:25.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:25.971]             base::names(...future.oldOptions))
[13:19:25.971]     }
[13:19:25.971]     if (FALSE) {
[13:19:25.971]     }
[13:19:25.971]     else {
[13:19:25.971]         if (TRUE) {
[13:19:25.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:25.971]                 open = "w")
[13:19:25.971]         }
[13:19:25.971]         else {
[13:19:25.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:25.971]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:25.971]         }
[13:19:25.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:25.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:25.971]             base::sink(type = "output", split = FALSE)
[13:19:25.971]             base::close(...future.stdout)
[13:19:25.971]         }, add = TRUE)
[13:19:25.971]     }
[13:19:25.971]     ...future.frame <- base::sys.nframe()
[13:19:25.971]     ...future.conditions <- base::list()
[13:19:25.971]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:25.971]     if (FALSE) {
[13:19:25.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:25.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:25.971]     }
[13:19:25.971]     ...future.result <- base::tryCatch({
[13:19:25.971]         base::withCallingHandlers({
[13:19:25.971]             ...future.value <- base::withVisible(base::local({
[13:19:25.971]                 ...future.makeSendCondition <- local({
[13:19:25.971]                   sendCondition <- NULL
[13:19:25.971]                   function(frame = 1L) {
[13:19:25.971]                     if (is.function(sendCondition)) 
[13:19:25.971]                       return(sendCondition)
[13:19:25.971]                     ns <- getNamespace("parallel")
[13:19:25.971]                     if (exists("sendData", mode = "function", 
[13:19:25.971]                       envir = ns)) {
[13:19:25.971]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:25.971]                         envir = ns)
[13:19:25.971]                       envir <- sys.frame(frame)
[13:19:25.971]                       master <- NULL
[13:19:25.971]                       while (!identical(envir, .GlobalEnv) && 
[13:19:25.971]                         !identical(envir, emptyenv())) {
[13:19:25.971]                         if (exists("master", mode = "list", envir = envir, 
[13:19:25.971]                           inherits = FALSE)) {
[13:19:25.971]                           master <- get("master", mode = "list", 
[13:19:25.971]                             envir = envir, inherits = FALSE)
[13:19:25.971]                           if (inherits(master, c("SOCKnode", 
[13:19:25.971]                             "SOCK0node"))) {
[13:19:25.971]                             sendCondition <<- function(cond) {
[13:19:25.971]                               data <- list(type = "VALUE", value = cond, 
[13:19:25.971]                                 success = TRUE)
[13:19:25.971]                               parallel_sendData(master, data)
[13:19:25.971]                             }
[13:19:25.971]                             return(sendCondition)
[13:19:25.971]                           }
[13:19:25.971]                         }
[13:19:25.971]                         frame <- frame + 1L
[13:19:25.971]                         envir <- sys.frame(frame)
[13:19:25.971]                       }
[13:19:25.971]                     }
[13:19:25.971]                     sendCondition <<- function(cond) NULL
[13:19:25.971]                   }
[13:19:25.971]                 })
[13:19:25.971]                 withCallingHandlers({
[13:19:25.971]                   {
[13:19:25.971]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:25.971]                     if (!identical(...future.globals.maxSize.org, 
[13:19:25.971]                       ...future.globals.maxSize)) {
[13:19:25.971]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:25.971]                       on.exit(options(oopts), add = TRUE)
[13:19:25.971]                     }
[13:19:25.971]                     {
[13:19:25.971]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:25.971]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:25.971]                         USE.NAMES = FALSE)
[13:19:25.971]                       do.call(mapply, args = args)
[13:19:25.971]                     }
[13:19:25.971]                   }
[13:19:25.971]                 }, immediateCondition = function(cond) {
[13:19:25.971]                   sendCondition <- ...future.makeSendCondition()
[13:19:25.971]                   sendCondition(cond)
[13:19:25.971]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.971]                   {
[13:19:25.971]                     inherits <- base::inherits
[13:19:25.971]                     invokeRestart <- base::invokeRestart
[13:19:25.971]                     is.null <- base::is.null
[13:19:25.971]                     muffled <- FALSE
[13:19:25.971]                     if (inherits(cond, "message")) {
[13:19:25.971]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:25.971]                       if (muffled) 
[13:19:25.971]                         invokeRestart("muffleMessage")
[13:19:25.971]                     }
[13:19:25.971]                     else if (inherits(cond, "warning")) {
[13:19:25.971]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:25.971]                       if (muffled) 
[13:19:25.971]                         invokeRestart("muffleWarning")
[13:19:25.971]                     }
[13:19:25.971]                     else if (inherits(cond, "condition")) {
[13:19:25.971]                       if (!is.null(pattern)) {
[13:19:25.971]                         computeRestarts <- base::computeRestarts
[13:19:25.971]                         grepl <- base::grepl
[13:19:25.971]                         restarts <- computeRestarts(cond)
[13:19:25.971]                         for (restart in restarts) {
[13:19:25.971]                           name <- restart$name
[13:19:25.971]                           if (is.null(name)) 
[13:19:25.971]                             next
[13:19:25.971]                           if (!grepl(pattern, name)) 
[13:19:25.971]                             next
[13:19:25.971]                           invokeRestart(restart)
[13:19:25.971]                           muffled <- TRUE
[13:19:25.971]                           break
[13:19:25.971]                         }
[13:19:25.971]                       }
[13:19:25.971]                     }
[13:19:25.971]                     invisible(muffled)
[13:19:25.971]                   }
[13:19:25.971]                   muffleCondition(cond)
[13:19:25.971]                 })
[13:19:25.971]             }))
[13:19:25.971]             future::FutureResult(value = ...future.value$value, 
[13:19:25.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:25.971]                   ...future.rng), globalenv = if (FALSE) 
[13:19:25.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:25.971]                     ...future.globalenv.names))
[13:19:25.971]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:25.971]         }, condition = base::local({
[13:19:25.971]             c <- base::c
[13:19:25.971]             inherits <- base::inherits
[13:19:25.971]             invokeRestart <- base::invokeRestart
[13:19:25.971]             length <- base::length
[13:19:25.971]             list <- base::list
[13:19:25.971]             seq.int <- base::seq.int
[13:19:25.971]             signalCondition <- base::signalCondition
[13:19:25.971]             sys.calls <- base::sys.calls
[13:19:25.971]             `[[` <- base::`[[`
[13:19:25.971]             `+` <- base::`+`
[13:19:25.971]             `<<-` <- base::`<<-`
[13:19:25.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:25.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:25.971]                   3L)]
[13:19:25.971]             }
[13:19:25.971]             function(cond) {
[13:19:25.971]                 is_error <- inherits(cond, "error")
[13:19:25.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:25.971]                   NULL)
[13:19:25.971]                 if (is_error) {
[13:19:25.971]                   sessionInformation <- function() {
[13:19:25.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:25.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:25.971]                       search = base::search(), system = base::Sys.info())
[13:19:25.971]                   }
[13:19:25.971]                   ...future.conditions[[length(...future.conditions) + 
[13:19:25.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:25.971]                     cond$call), session = sessionInformation(), 
[13:19:25.971]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:25.971]                   signalCondition(cond)
[13:19:25.971]                 }
[13:19:25.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:25.971]                 "immediateCondition"))) {
[13:19:25.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:25.971]                   ...future.conditions[[length(...future.conditions) + 
[13:19:25.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:25.971]                   if (TRUE && !signal) {
[13:19:25.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.971]                     {
[13:19:25.971]                       inherits <- base::inherits
[13:19:25.971]                       invokeRestart <- base::invokeRestart
[13:19:25.971]                       is.null <- base::is.null
[13:19:25.971]                       muffled <- FALSE
[13:19:25.971]                       if (inherits(cond, "message")) {
[13:19:25.971]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:25.971]                         if (muffled) 
[13:19:25.971]                           invokeRestart("muffleMessage")
[13:19:25.971]                       }
[13:19:25.971]                       else if (inherits(cond, "warning")) {
[13:19:25.971]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:25.971]                         if (muffled) 
[13:19:25.971]                           invokeRestart("muffleWarning")
[13:19:25.971]                       }
[13:19:25.971]                       else if (inherits(cond, "condition")) {
[13:19:25.971]                         if (!is.null(pattern)) {
[13:19:25.971]                           computeRestarts <- base::computeRestarts
[13:19:25.971]                           grepl <- base::grepl
[13:19:25.971]                           restarts <- computeRestarts(cond)
[13:19:25.971]                           for (restart in restarts) {
[13:19:25.971]                             name <- restart$name
[13:19:25.971]                             if (is.null(name)) 
[13:19:25.971]                               next
[13:19:25.971]                             if (!grepl(pattern, name)) 
[13:19:25.971]                               next
[13:19:25.971]                             invokeRestart(restart)
[13:19:25.971]                             muffled <- TRUE
[13:19:25.971]                             break
[13:19:25.971]                           }
[13:19:25.971]                         }
[13:19:25.971]                       }
[13:19:25.971]                       invisible(muffled)
[13:19:25.971]                     }
[13:19:25.971]                     muffleCondition(cond, pattern = "^muffle")
[13:19:25.971]                   }
[13:19:25.971]                 }
[13:19:25.971]                 else {
[13:19:25.971]                   if (TRUE) {
[13:19:25.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:25.971]                     {
[13:19:25.971]                       inherits <- base::inherits
[13:19:25.971]                       invokeRestart <- base::invokeRestart
[13:19:25.971]                       is.null <- base::is.null
[13:19:25.971]                       muffled <- FALSE
[13:19:25.971]                       if (inherits(cond, "message")) {
[13:19:25.971]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:25.971]                         if (muffled) 
[13:19:25.971]                           invokeRestart("muffleMessage")
[13:19:25.971]                       }
[13:19:25.971]                       else if (inherits(cond, "warning")) {
[13:19:25.971]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:25.971]                         if (muffled) 
[13:19:25.971]                           invokeRestart("muffleWarning")
[13:19:25.971]                       }
[13:19:25.971]                       else if (inherits(cond, "condition")) {
[13:19:25.971]                         if (!is.null(pattern)) {
[13:19:25.971]                           computeRestarts <- base::computeRestarts
[13:19:25.971]                           grepl <- base::grepl
[13:19:25.971]                           restarts <- computeRestarts(cond)
[13:19:25.971]                           for (restart in restarts) {
[13:19:25.971]                             name <- restart$name
[13:19:25.971]                             if (is.null(name)) 
[13:19:25.971]                               next
[13:19:25.971]                             if (!grepl(pattern, name)) 
[13:19:25.971]                               next
[13:19:25.971]                             invokeRestart(restart)
[13:19:25.971]                             muffled <- TRUE
[13:19:25.971]                             break
[13:19:25.971]                           }
[13:19:25.971]                         }
[13:19:25.971]                       }
[13:19:25.971]                       invisible(muffled)
[13:19:25.971]                     }
[13:19:25.971]                     muffleCondition(cond, pattern = "^muffle")
[13:19:25.971]                   }
[13:19:25.971]                 }
[13:19:25.971]             }
[13:19:25.971]         }))
[13:19:25.971]     }, error = function(ex) {
[13:19:25.971]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:25.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:25.971]                 ...future.rng), started = ...future.startTime, 
[13:19:25.971]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:25.971]             version = "1.8"), class = "FutureResult")
[13:19:25.971]     }, finally = {
[13:19:25.971]         if (!identical(...future.workdir, getwd())) 
[13:19:25.971]             setwd(...future.workdir)
[13:19:25.971]         {
[13:19:25.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:25.971]                 ...future.oldOptions$nwarnings <- NULL
[13:19:25.971]             }
[13:19:25.971]             base::options(...future.oldOptions)
[13:19:25.971]             if (.Platform$OS.type == "windows") {
[13:19:25.971]                 old_names <- names(...future.oldEnvVars)
[13:19:25.971]                 envs <- base::Sys.getenv()
[13:19:25.971]                 names <- names(envs)
[13:19:25.971]                 common <- intersect(names, old_names)
[13:19:25.971]                 added <- setdiff(names, old_names)
[13:19:25.971]                 removed <- setdiff(old_names, names)
[13:19:25.971]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:25.971]                   envs[common]]
[13:19:25.971]                 NAMES <- toupper(changed)
[13:19:25.971]                 args <- list()
[13:19:25.971]                 for (kk in seq_along(NAMES)) {
[13:19:25.971]                   name <- changed[[kk]]
[13:19:25.971]                   NAME <- NAMES[[kk]]
[13:19:25.971]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.971]                     next
[13:19:25.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:25.971]                 }
[13:19:25.971]                 NAMES <- toupper(added)
[13:19:25.971]                 for (kk in seq_along(NAMES)) {
[13:19:25.971]                   name <- added[[kk]]
[13:19:25.971]                   NAME <- NAMES[[kk]]
[13:19:25.971]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.971]                     next
[13:19:25.971]                   args[[name]] <- ""
[13:19:25.971]                 }
[13:19:25.971]                 NAMES <- toupper(removed)
[13:19:25.971]                 for (kk in seq_along(NAMES)) {
[13:19:25.971]                   name <- removed[[kk]]
[13:19:25.971]                   NAME <- NAMES[[kk]]
[13:19:25.971]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:25.971]                     next
[13:19:25.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:25.971]                 }
[13:19:25.971]                 if (length(args) > 0) 
[13:19:25.971]                   base::do.call(base::Sys.setenv, args = args)
[13:19:25.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:25.971]             }
[13:19:25.971]             else {
[13:19:25.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:25.971]             }
[13:19:25.971]             {
[13:19:25.971]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:25.971]                   0L) {
[13:19:25.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:25.971]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:25.971]                   base::options(opts)
[13:19:25.971]                 }
[13:19:25.971]                 {
[13:19:25.971]                   {
[13:19:25.971]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:25.971]                     NULL
[13:19:25.971]                   }
[13:19:25.971]                   options(future.plan = NULL)
[13:19:25.971]                   if (is.na(NA_character_)) 
[13:19:25.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:25.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:25.971]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:25.971]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:25.971]                     envir = parent.frame()) 
[13:19:25.971]                   {
[13:19:25.971]                     if (is.function(workers)) 
[13:19:25.971]                       workers <- workers()
[13:19:25.971]                     workers <- structure(as.integer(workers), 
[13:19:25.971]                       class = class(workers))
[13:19:25.971]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:25.971]                       workers >= 1)
[13:19:25.971]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:25.971]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:25.971]                     }
[13:19:25.971]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:25.971]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:25.971]                       envir = envir)
[13:19:25.971]                     if (!future$lazy) 
[13:19:25.971]                       future <- run(future)
[13:19:25.971]                     invisible(future)
[13:19:25.971]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:25.971]                 }
[13:19:25.971]             }
[13:19:25.971]         }
[13:19:25.971]     })
[13:19:25.971]     if (TRUE) {
[13:19:25.971]         base::sink(type = "output", split = FALSE)
[13:19:25.971]         if (TRUE) {
[13:19:25.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:25.971]         }
[13:19:25.971]         else {
[13:19:25.971]             ...future.result["stdout"] <- base::list(NULL)
[13:19:25.971]         }
[13:19:25.971]         base::close(...future.stdout)
[13:19:25.971]         ...future.stdout <- NULL
[13:19:25.971]     }
[13:19:25.971]     ...future.result$conditions <- ...future.conditions
[13:19:25.971]     ...future.result$finished <- base::Sys.time()
[13:19:25.971]     ...future.result
[13:19:25.971] }
[13:19:25.973] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:19:25.974] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:19:25.974] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:19:25.974] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:19:25.974] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:19:25.975] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:19:25.975] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:19:25.975] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:25.975] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:25.975] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:25.976] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:25.976] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:19:25.976] MultisessionFuture started
[13:19:25.976] - Launch lazy future ... done
[13:19:25.977] run() for ‘MultisessionFuture’ ... done
[13:19:25.977] Created future:
[13:19:25.977] MultisessionFuture:
[13:19:25.977] Label: ‘future_mapply-1’
[13:19:25.977] Expression:
[13:19:25.977] {
[13:19:25.977]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:25.977]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:25.977]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:25.977]         on.exit(options(oopts), add = TRUE)
[13:19:25.977]     }
[13:19:25.977]     {
[13:19:25.977]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:25.977]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:25.977]         do.call(mapply, args = args)
[13:19:25.977]     }
[13:19:25.977] }
[13:19:25.977] Lazy evaluation: FALSE
[13:19:25.977] Asynchronous evaluation: TRUE
[13:19:25.977] Local evaluation: TRUE
[13:19:25.977] Environment: R_GlobalEnv
[13:19:25.977] Capture standard output: TRUE
[13:19:25.977] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:25.977] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:25.977] Packages: <none>
[13:19:25.977] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:25.977] Resolved: FALSE
[13:19:25.977] Value: <not collected>
[13:19:25.977] Conditions captured: <none>
[13:19:25.977] Early signaling: FALSE
[13:19:25.977] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:25.977] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:25.988] Chunk #1 of 2 ... DONE
[13:19:25.988] Chunk #2 of 2 ...
[13:19:25.989]  - Finding globals in '...' for chunk #2 ...
[13:19:25.989] getGlobalsAndPackages() ...
[13:19:25.989] Searching for globals...
[13:19:25.989] 
[13:19:25.989] Searching for globals ... DONE
[13:19:25.989] - globals: [0] <none>
[13:19:25.989] getGlobalsAndPackages() ... DONE
[13:19:25.990]    + additional globals found: [n=0] 
[13:19:25.990]    + additional namespaces needed: [n=0] 
[13:19:25.990]  - Finding globals in '...' for chunk #2 ... DONE
[13:19:25.990]  - seeds: <none>
[13:19:25.990] getGlobalsAndPackages() ...
[13:19:25.990] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:25.990] Resolving globals: FALSE
[13:19:25.991] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:25.991] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:25.991] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:25.991] 
[13:19:25.991] getGlobalsAndPackages() ... DONE
[13:19:25.992] run() for ‘Future’ ...
[13:19:25.992] - state: ‘created’
[13:19:25.992] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:26.007] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:26.007] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:26.007]   - Field: ‘node’
[13:19:26.008]   - Field: ‘label’
[13:19:26.008]   - Field: ‘local’
[13:19:26.008]   - Field: ‘owner’
[13:19:26.008]   - Field: ‘envir’
[13:19:26.008]   - Field: ‘workers’
[13:19:26.008]   - Field: ‘packages’
[13:19:26.008]   - Field: ‘gc’
[13:19:26.008]   - Field: ‘conditions’
[13:19:26.008]   - Field: ‘persistent’
[13:19:26.008]   - Field: ‘expr’
[13:19:26.009]   - Field: ‘uuid’
[13:19:26.009]   - Field: ‘seed’
[13:19:26.011]   - Field: ‘version’
[13:19:26.011]   - Field: ‘result’
[13:19:26.011]   - Field: ‘asynchronous’
[13:19:26.011]   - Field: ‘calls’
[13:19:26.011]   - Field: ‘globals’
[13:19:26.011]   - Field: ‘stdout’
[13:19:26.011]   - Field: ‘earlySignal’
[13:19:26.011]   - Field: ‘lazy’
[13:19:26.012]   - Field: ‘state’
[13:19:26.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:26.012] - Launch lazy future ...
[13:19:26.012] Packages needed by the future expression (n = 0): <none>
[13:19:26.012] Packages needed by future strategies (n = 0): <none>
[13:19:26.013] {
[13:19:26.013]     {
[13:19:26.013]         {
[13:19:26.013]             ...future.startTime <- base::Sys.time()
[13:19:26.013]             {
[13:19:26.013]                 {
[13:19:26.013]                   {
[13:19:26.013]                     {
[13:19:26.013]                       base::local({
[13:19:26.013]                         has_future <- base::requireNamespace("future", 
[13:19:26.013]                           quietly = TRUE)
[13:19:26.013]                         if (has_future) {
[13:19:26.013]                           ns <- base::getNamespace("future")
[13:19:26.013]                           version <- ns[[".package"]][["version"]]
[13:19:26.013]                           if (is.null(version)) 
[13:19:26.013]                             version <- utils::packageVersion("future")
[13:19:26.013]                         }
[13:19:26.013]                         else {
[13:19:26.013]                           version <- NULL
[13:19:26.013]                         }
[13:19:26.013]                         if (!has_future || version < "1.8.0") {
[13:19:26.013]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:26.013]                             "", base::R.version$version.string), 
[13:19:26.013]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:26.013]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:26.013]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:26.013]                               "release", "version")], collapse = " "), 
[13:19:26.013]                             hostname = base::Sys.info()[["nodename"]])
[13:19:26.013]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:26.013]                             info)
[13:19:26.013]                           info <- base::paste(info, collapse = "; ")
[13:19:26.013]                           if (!has_future) {
[13:19:26.013]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:26.013]                               info)
[13:19:26.013]                           }
[13:19:26.013]                           else {
[13:19:26.013]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:26.013]                               info, version)
[13:19:26.013]                           }
[13:19:26.013]                           base::stop(msg)
[13:19:26.013]                         }
[13:19:26.013]                       })
[13:19:26.013]                     }
[13:19:26.013]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:26.013]                     base::options(mc.cores = 1L)
[13:19:26.013]                   }
[13:19:26.013]                   options(future.plan = NULL)
[13:19:26.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:26.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:26.013]                 }
[13:19:26.013]                 ...future.workdir <- getwd()
[13:19:26.013]             }
[13:19:26.013]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:26.013]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:26.013]         }
[13:19:26.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:26.013]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:26.013]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:26.013]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:26.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:26.013]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:26.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:26.013]             base::names(...future.oldOptions))
[13:19:26.013]     }
[13:19:26.013]     if (FALSE) {
[13:19:26.013]     }
[13:19:26.013]     else {
[13:19:26.013]         if (TRUE) {
[13:19:26.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:26.013]                 open = "w")
[13:19:26.013]         }
[13:19:26.013]         else {
[13:19:26.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:26.013]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:26.013]         }
[13:19:26.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:26.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:26.013]             base::sink(type = "output", split = FALSE)
[13:19:26.013]             base::close(...future.stdout)
[13:19:26.013]         }, add = TRUE)
[13:19:26.013]     }
[13:19:26.013]     ...future.frame <- base::sys.nframe()
[13:19:26.013]     ...future.conditions <- base::list()
[13:19:26.013]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:26.013]     if (FALSE) {
[13:19:26.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:26.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:26.013]     }
[13:19:26.013]     ...future.result <- base::tryCatch({
[13:19:26.013]         base::withCallingHandlers({
[13:19:26.013]             ...future.value <- base::withVisible(base::local({
[13:19:26.013]                 ...future.makeSendCondition <- local({
[13:19:26.013]                   sendCondition <- NULL
[13:19:26.013]                   function(frame = 1L) {
[13:19:26.013]                     if (is.function(sendCondition)) 
[13:19:26.013]                       return(sendCondition)
[13:19:26.013]                     ns <- getNamespace("parallel")
[13:19:26.013]                     if (exists("sendData", mode = "function", 
[13:19:26.013]                       envir = ns)) {
[13:19:26.013]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:26.013]                         envir = ns)
[13:19:26.013]                       envir <- sys.frame(frame)
[13:19:26.013]                       master <- NULL
[13:19:26.013]                       while (!identical(envir, .GlobalEnv) && 
[13:19:26.013]                         !identical(envir, emptyenv())) {
[13:19:26.013]                         if (exists("master", mode = "list", envir = envir, 
[13:19:26.013]                           inherits = FALSE)) {
[13:19:26.013]                           master <- get("master", mode = "list", 
[13:19:26.013]                             envir = envir, inherits = FALSE)
[13:19:26.013]                           if (inherits(master, c("SOCKnode", 
[13:19:26.013]                             "SOCK0node"))) {
[13:19:26.013]                             sendCondition <<- function(cond) {
[13:19:26.013]                               data <- list(type = "VALUE", value = cond, 
[13:19:26.013]                                 success = TRUE)
[13:19:26.013]                               parallel_sendData(master, data)
[13:19:26.013]                             }
[13:19:26.013]                             return(sendCondition)
[13:19:26.013]                           }
[13:19:26.013]                         }
[13:19:26.013]                         frame <- frame + 1L
[13:19:26.013]                         envir <- sys.frame(frame)
[13:19:26.013]                       }
[13:19:26.013]                     }
[13:19:26.013]                     sendCondition <<- function(cond) NULL
[13:19:26.013]                   }
[13:19:26.013]                 })
[13:19:26.013]                 withCallingHandlers({
[13:19:26.013]                   {
[13:19:26.013]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:26.013]                     if (!identical(...future.globals.maxSize.org, 
[13:19:26.013]                       ...future.globals.maxSize)) {
[13:19:26.013]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:26.013]                       on.exit(options(oopts), add = TRUE)
[13:19:26.013]                     }
[13:19:26.013]                     {
[13:19:26.013]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:26.013]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:26.013]                         USE.NAMES = FALSE)
[13:19:26.013]                       do.call(mapply, args = args)
[13:19:26.013]                     }
[13:19:26.013]                   }
[13:19:26.013]                 }, immediateCondition = function(cond) {
[13:19:26.013]                   sendCondition <- ...future.makeSendCondition()
[13:19:26.013]                   sendCondition(cond)
[13:19:26.013]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.013]                   {
[13:19:26.013]                     inherits <- base::inherits
[13:19:26.013]                     invokeRestart <- base::invokeRestart
[13:19:26.013]                     is.null <- base::is.null
[13:19:26.013]                     muffled <- FALSE
[13:19:26.013]                     if (inherits(cond, "message")) {
[13:19:26.013]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:26.013]                       if (muffled) 
[13:19:26.013]                         invokeRestart("muffleMessage")
[13:19:26.013]                     }
[13:19:26.013]                     else if (inherits(cond, "warning")) {
[13:19:26.013]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:26.013]                       if (muffled) 
[13:19:26.013]                         invokeRestart("muffleWarning")
[13:19:26.013]                     }
[13:19:26.013]                     else if (inherits(cond, "condition")) {
[13:19:26.013]                       if (!is.null(pattern)) {
[13:19:26.013]                         computeRestarts <- base::computeRestarts
[13:19:26.013]                         grepl <- base::grepl
[13:19:26.013]                         restarts <- computeRestarts(cond)
[13:19:26.013]                         for (restart in restarts) {
[13:19:26.013]                           name <- restart$name
[13:19:26.013]                           if (is.null(name)) 
[13:19:26.013]                             next
[13:19:26.013]                           if (!grepl(pattern, name)) 
[13:19:26.013]                             next
[13:19:26.013]                           invokeRestart(restart)
[13:19:26.013]                           muffled <- TRUE
[13:19:26.013]                           break
[13:19:26.013]                         }
[13:19:26.013]                       }
[13:19:26.013]                     }
[13:19:26.013]                     invisible(muffled)
[13:19:26.013]                   }
[13:19:26.013]                   muffleCondition(cond)
[13:19:26.013]                 })
[13:19:26.013]             }))
[13:19:26.013]             future::FutureResult(value = ...future.value$value, 
[13:19:26.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:26.013]                   ...future.rng), globalenv = if (FALSE) 
[13:19:26.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:26.013]                     ...future.globalenv.names))
[13:19:26.013]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:26.013]         }, condition = base::local({
[13:19:26.013]             c <- base::c
[13:19:26.013]             inherits <- base::inherits
[13:19:26.013]             invokeRestart <- base::invokeRestart
[13:19:26.013]             length <- base::length
[13:19:26.013]             list <- base::list
[13:19:26.013]             seq.int <- base::seq.int
[13:19:26.013]             signalCondition <- base::signalCondition
[13:19:26.013]             sys.calls <- base::sys.calls
[13:19:26.013]             `[[` <- base::`[[`
[13:19:26.013]             `+` <- base::`+`
[13:19:26.013]             `<<-` <- base::`<<-`
[13:19:26.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:26.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:26.013]                   3L)]
[13:19:26.013]             }
[13:19:26.013]             function(cond) {
[13:19:26.013]                 is_error <- inherits(cond, "error")
[13:19:26.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:26.013]                   NULL)
[13:19:26.013]                 if (is_error) {
[13:19:26.013]                   sessionInformation <- function() {
[13:19:26.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:26.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:26.013]                       search = base::search(), system = base::Sys.info())
[13:19:26.013]                   }
[13:19:26.013]                   ...future.conditions[[length(...future.conditions) + 
[13:19:26.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:26.013]                     cond$call), session = sessionInformation(), 
[13:19:26.013]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:26.013]                   signalCondition(cond)
[13:19:26.013]                 }
[13:19:26.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:26.013]                 "immediateCondition"))) {
[13:19:26.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:26.013]                   ...future.conditions[[length(...future.conditions) + 
[13:19:26.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:26.013]                   if (TRUE && !signal) {
[13:19:26.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.013]                     {
[13:19:26.013]                       inherits <- base::inherits
[13:19:26.013]                       invokeRestart <- base::invokeRestart
[13:19:26.013]                       is.null <- base::is.null
[13:19:26.013]                       muffled <- FALSE
[13:19:26.013]                       if (inherits(cond, "message")) {
[13:19:26.013]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:26.013]                         if (muffled) 
[13:19:26.013]                           invokeRestart("muffleMessage")
[13:19:26.013]                       }
[13:19:26.013]                       else if (inherits(cond, "warning")) {
[13:19:26.013]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:26.013]                         if (muffled) 
[13:19:26.013]                           invokeRestart("muffleWarning")
[13:19:26.013]                       }
[13:19:26.013]                       else if (inherits(cond, "condition")) {
[13:19:26.013]                         if (!is.null(pattern)) {
[13:19:26.013]                           computeRestarts <- base::computeRestarts
[13:19:26.013]                           grepl <- base::grepl
[13:19:26.013]                           restarts <- computeRestarts(cond)
[13:19:26.013]                           for (restart in restarts) {
[13:19:26.013]                             name <- restart$name
[13:19:26.013]                             if (is.null(name)) 
[13:19:26.013]                               next
[13:19:26.013]                             if (!grepl(pattern, name)) 
[13:19:26.013]                               next
[13:19:26.013]                             invokeRestart(restart)
[13:19:26.013]                             muffled <- TRUE
[13:19:26.013]                             break
[13:19:26.013]                           }
[13:19:26.013]                         }
[13:19:26.013]                       }
[13:19:26.013]                       invisible(muffled)
[13:19:26.013]                     }
[13:19:26.013]                     muffleCondition(cond, pattern = "^muffle")
[13:19:26.013]                   }
[13:19:26.013]                 }
[13:19:26.013]                 else {
[13:19:26.013]                   if (TRUE) {
[13:19:26.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.013]                     {
[13:19:26.013]                       inherits <- base::inherits
[13:19:26.013]                       invokeRestart <- base::invokeRestart
[13:19:26.013]                       is.null <- base::is.null
[13:19:26.013]                       muffled <- FALSE
[13:19:26.013]                       if (inherits(cond, "message")) {
[13:19:26.013]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:26.013]                         if (muffled) 
[13:19:26.013]                           invokeRestart("muffleMessage")
[13:19:26.013]                       }
[13:19:26.013]                       else if (inherits(cond, "warning")) {
[13:19:26.013]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:26.013]                         if (muffled) 
[13:19:26.013]                           invokeRestart("muffleWarning")
[13:19:26.013]                       }
[13:19:26.013]                       else if (inherits(cond, "condition")) {
[13:19:26.013]                         if (!is.null(pattern)) {
[13:19:26.013]                           computeRestarts <- base::computeRestarts
[13:19:26.013]                           grepl <- base::grepl
[13:19:26.013]                           restarts <- computeRestarts(cond)
[13:19:26.013]                           for (restart in restarts) {
[13:19:26.013]                             name <- restart$name
[13:19:26.013]                             if (is.null(name)) 
[13:19:26.013]                               next
[13:19:26.013]                             if (!grepl(pattern, name)) 
[13:19:26.013]                               next
[13:19:26.013]                             invokeRestart(restart)
[13:19:26.013]                             muffled <- TRUE
[13:19:26.013]                             break
[13:19:26.013]                           }
[13:19:26.013]                         }
[13:19:26.013]                       }
[13:19:26.013]                       invisible(muffled)
[13:19:26.013]                     }
[13:19:26.013]                     muffleCondition(cond, pattern = "^muffle")
[13:19:26.013]                   }
[13:19:26.013]                 }
[13:19:26.013]             }
[13:19:26.013]         }))
[13:19:26.013]     }, error = function(ex) {
[13:19:26.013]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:26.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:26.013]                 ...future.rng), started = ...future.startTime, 
[13:19:26.013]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:26.013]             version = "1.8"), class = "FutureResult")
[13:19:26.013]     }, finally = {
[13:19:26.013]         if (!identical(...future.workdir, getwd())) 
[13:19:26.013]             setwd(...future.workdir)
[13:19:26.013]         {
[13:19:26.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:26.013]                 ...future.oldOptions$nwarnings <- NULL
[13:19:26.013]             }
[13:19:26.013]             base::options(...future.oldOptions)
[13:19:26.013]             if (.Platform$OS.type == "windows") {
[13:19:26.013]                 old_names <- names(...future.oldEnvVars)
[13:19:26.013]                 envs <- base::Sys.getenv()
[13:19:26.013]                 names <- names(envs)
[13:19:26.013]                 common <- intersect(names, old_names)
[13:19:26.013]                 added <- setdiff(names, old_names)
[13:19:26.013]                 removed <- setdiff(old_names, names)
[13:19:26.013]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:26.013]                   envs[common]]
[13:19:26.013]                 NAMES <- toupper(changed)
[13:19:26.013]                 args <- list()
[13:19:26.013]                 for (kk in seq_along(NAMES)) {
[13:19:26.013]                   name <- changed[[kk]]
[13:19:26.013]                   NAME <- NAMES[[kk]]
[13:19:26.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.013]                     next
[13:19:26.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:26.013]                 }
[13:19:26.013]                 NAMES <- toupper(added)
[13:19:26.013]                 for (kk in seq_along(NAMES)) {
[13:19:26.013]                   name <- added[[kk]]
[13:19:26.013]                   NAME <- NAMES[[kk]]
[13:19:26.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.013]                     next
[13:19:26.013]                   args[[name]] <- ""
[13:19:26.013]                 }
[13:19:26.013]                 NAMES <- toupper(removed)
[13:19:26.013]                 for (kk in seq_along(NAMES)) {
[13:19:26.013]                   name <- removed[[kk]]
[13:19:26.013]                   NAME <- NAMES[[kk]]
[13:19:26.013]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.013]                     next
[13:19:26.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:26.013]                 }
[13:19:26.013]                 if (length(args) > 0) 
[13:19:26.013]                   base::do.call(base::Sys.setenv, args = args)
[13:19:26.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:26.013]             }
[13:19:26.013]             else {
[13:19:26.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:26.013]             }
[13:19:26.013]             {
[13:19:26.013]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:26.013]                   0L) {
[13:19:26.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:26.013]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:26.013]                   base::options(opts)
[13:19:26.013]                 }
[13:19:26.013]                 {
[13:19:26.013]                   {
[13:19:26.013]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:26.013]                     NULL
[13:19:26.013]                   }
[13:19:26.013]                   options(future.plan = NULL)
[13:19:26.013]                   if (is.na(NA_character_)) 
[13:19:26.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:26.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:26.013]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:26.013]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:26.013]                     envir = parent.frame()) 
[13:19:26.013]                   {
[13:19:26.013]                     if (is.function(workers)) 
[13:19:26.013]                       workers <- workers()
[13:19:26.013]                     workers <- structure(as.integer(workers), 
[13:19:26.013]                       class = class(workers))
[13:19:26.013]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:26.013]                       workers >= 1)
[13:19:26.013]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:26.013]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:26.013]                     }
[13:19:26.013]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:26.013]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:26.013]                       envir = envir)
[13:19:26.013]                     if (!future$lazy) 
[13:19:26.013]                       future <- run(future)
[13:19:26.013]                     invisible(future)
[13:19:26.013]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:26.013]                 }
[13:19:26.013]             }
[13:19:26.013]         }
[13:19:26.013]     })
[13:19:26.013]     if (TRUE) {
[13:19:26.013]         base::sink(type = "output", split = FALSE)
[13:19:26.013]         if (TRUE) {
[13:19:26.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:26.013]         }
[13:19:26.013]         else {
[13:19:26.013]             ...future.result["stdout"] <- base::list(NULL)
[13:19:26.013]         }
[13:19:26.013]         base::close(...future.stdout)
[13:19:26.013]         ...future.stdout <- NULL
[13:19:26.013]     }
[13:19:26.013]     ...future.result$conditions <- ...future.conditions
[13:19:26.013]     ...future.result$finished <- base::Sys.time()
[13:19:26.013]     ...future.result
[13:19:26.013] }
[13:19:26.015] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:19:26.016] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:19:26.016] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:19:26.016] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:19:26.017] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:19:26.017] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:19:26.017] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:19:26.017] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:26.018] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:26.018] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:26.018] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:26.018] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:19:26.019] MultisessionFuture started
[13:19:26.019] - Launch lazy future ... done
[13:19:26.019] run() for ‘MultisessionFuture’ ... done
[13:19:26.019] Created future:
[13:19:26.019] MultisessionFuture:
[13:19:26.019] Label: ‘future_mapply-2’
[13:19:26.019] Expression:
[13:19:26.019] {
[13:19:26.019]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:26.019]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:26.019]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:26.019]         on.exit(options(oopts), add = TRUE)
[13:19:26.019]     }
[13:19:26.019]     {
[13:19:26.019]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:26.019]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:26.019]         do.call(mapply, args = args)
[13:19:26.019]     }
[13:19:26.019] }
[13:19:26.019] Lazy evaluation: FALSE
[13:19:26.019] Asynchronous evaluation: TRUE
[13:19:26.019] Local evaluation: TRUE
[13:19:26.019] Environment: R_GlobalEnv
[13:19:26.019] Capture standard output: TRUE
[13:19:26.019] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:26.019] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:26.019] Packages: <none>
[13:19:26.019] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:26.019] Resolved: FALSE
[13:19:26.019] Value: <not collected>
[13:19:26.019] Conditions captured: <none>
[13:19:26.019] Early signaling: FALSE
[13:19:26.019] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:26.019] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:26.031] Chunk #2 of 2 ... DONE
[13:19:26.031] Launching 2 futures (chunks) ... DONE
[13:19:26.031] Resolving 2 futures (chunks) ...
[13:19:26.031] resolve() on list ...
[13:19:26.031]  recursive: 0
[13:19:26.031]  length: 2
[13:19:26.031] 
[13:19:26.074] receiveMessageFromWorker() for ClusterFuture ...
[13:19:26.074] - Validating connection of MultisessionFuture
[13:19:26.074] - received message: FutureResult
[13:19:26.074] - Received FutureResult
[13:19:26.075] - Erased future from FutureRegistry
[13:19:26.075] result() for ClusterFuture ...
[13:19:26.075] - result already collected: FutureResult
[13:19:26.075] result() for ClusterFuture ... done
[13:19:26.075] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:26.075] Future #2
[13:19:26.075] result() for ClusterFuture ...
[13:19:26.075] - result already collected: FutureResult
[13:19:26.075] result() for ClusterFuture ... done
[13:19:26.075] result() for ClusterFuture ...
[13:19:26.075] - result already collected: FutureResult
[13:19:26.076] result() for ClusterFuture ... done
[13:19:26.076] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:26.076] - nx: 2
[13:19:26.076] - relay: TRUE
[13:19:26.076] - stdout: TRUE
[13:19:26.076] - signal: TRUE
[13:19:26.076] - resignal: FALSE
[13:19:26.076] - force: TRUE
[13:19:26.076] - relayed: [n=2] FALSE, FALSE
[13:19:26.076] - queued futures: [n=2] FALSE, FALSE
[13:19:26.076]  - until=1
[13:19:26.077]  - relaying element #1
[13:19:26.077] - relayed: [n=2] FALSE, FALSE
[13:19:26.077] - queued futures: [n=2] FALSE, TRUE
[13:19:26.077] signalConditionsASAP(NULL, pos=2) ... done
[13:19:26.077]  length: 1 (resolved future 2)
[13:19:26.523] receiveMessageFromWorker() for ClusterFuture ...
[13:19:26.523] - Validating connection of MultisessionFuture
[13:19:26.524] - received message: FutureResult
[13:19:26.524] - Received FutureResult
[13:19:26.524] - Erased future from FutureRegistry
[13:19:26.524] result() for ClusterFuture ...
[13:19:26.524] - result already collected: FutureResult
[13:19:26.524] result() for ClusterFuture ... done
[13:19:26.524] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:26.524] Future #1
[13:19:26.524] result() for ClusterFuture ...
[13:19:26.524] - result already collected: FutureResult
[13:19:26.525] result() for ClusterFuture ... done
[13:19:26.525] result() for ClusterFuture ...
[13:19:26.525] - result already collected: FutureResult
[13:19:26.525] result() for ClusterFuture ... done
[13:19:26.525] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:26.525] - nx: 2
[13:19:26.525] - relay: TRUE
[13:19:26.525] - stdout: TRUE
[13:19:26.525] - signal: TRUE
[13:19:26.525] - resignal: FALSE
[13:19:26.525] - force: TRUE
[13:19:26.526] - relayed: [n=2] FALSE, FALSE
[13:19:26.526] - queued futures: [n=2] FALSE, TRUE
[13:19:26.526]  - until=1
[13:19:26.526]  - relaying element #1
[13:19:26.526] result() for ClusterFuture ...
[13:19:26.526] - result already collected: FutureResult
[13:19:26.526] result() for ClusterFuture ... done
[13:19:26.526] result() for ClusterFuture ...
[13:19:26.526] - result already collected: FutureResult
[13:19:26.526] result() for ClusterFuture ... done
[13:19:26.527] result() for ClusterFuture ...
[13:19:26.527] - result already collected: FutureResult
[13:19:26.527] result() for ClusterFuture ... done
[13:19:26.527] result() for ClusterFuture ...
[13:19:26.527] - result already collected: FutureResult
[13:19:26.527] result() for ClusterFuture ... done
[13:19:26.527] - relayed: [n=2] TRUE, FALSE
[13:19:26.527] - queued futures: [n=2] TRUE, TRUE
[13:19:26.527] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:26.527]  length: 0 (resolved future 1)
[13:19:26.527] Relaying remaining futures
[13:19:26.527] signalConditionsASAP(NULL, pos=0) ...
[13:19:26.528] - nx: 2
[13:19:26.528] - relay: TRUE
[13:19:26.528] - stdout: TRUE
[13:19:26.528] - signal: TRUE
[13:19:26.528] - resignal: FALSE
[13:19:26.528] - force: TRUE
[13:19:26.528] - relayed: [n=2] TRUE, FALSE
[13:19:26.528] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:26.528]  - relaying element #2
[13:19:26.528] result() for ClusterFuture ...
[13:19:26.528] - result already collected: FutureResult
[13:19:26.529] result() for ClusterFuture ... done
[13:19:26.529] result() for ClusterFuture ...
[13:19:26.529] - result already collected: FutureResult
[13:19:26.529] result() for ClusterFuture ... done
[13:19:26.529] result() for ClusterFuture ...
[13:19:26.529] - result already collected: FutureResult
[13:19:26.529] result() for ClusterFuture ... done
[13:19:26.529] result() for ClusterFuture ...
[13:19:26.529] - result already collected: FutureResult
[13:19:26.529] result() for ClusterFuture ... done
[13:19:26.529] - relayed: [n=2] TRUE, TRUE
[13:19:26.530] - queued futures: [n=2] TRUE, TRUE
[13:19:26.530] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:19:26.530] resolve() on list ... DONE
[13:19:26.530] result() for ClusterFuture ...
[13:19:26.530] - result already collected: FutureResult
[13:19:26.530] result() for ClusterFuture ... done
[13:19:26.530] result() for ClusterFuture ...
[13:19:26.530] - result already collected: FutureResult
[13:19:26.530] result() for ClusterFuture ... done
[13:19:26.530] result() for ClusterFuture ...
[13:19:26.530] - result already collected: FutureResult
[13:19:26.531] result() for ClusterFuture ... done
[13:19:26.531] result() for ClusterFuture ...
[13:19:26.531] - result already collected: FutureResult
[13:19:26.531] result() for ClusterFuture ... done
[13:19:26.531]  - Number of value chunks collected: 2
[13:19:26.531] Resolving 2 futures (chunks) ... DONE
[13:19:26.531] Reducing values from 2 chunks ...
[13:19:26.531]  - Number of values collected after concatenation: 2
[13:19:26.531]  - Number of values expected: 2
[13:19:26.531] Reducing values from 2 chunks ... DONE
[13:19:26.532] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:19:26.532] future_mapply() ...
[13:19:26.536] Number of chunks: 2
[13:19:26.536] getGlobalsAndPackagesXApply() ...
[13:19:26.536]  - future.globals: TRUE
[13:19:26.536] getGlobalsAndPackages() ...
[13:19:26.536] Searching for globals...
[13:19:26.538] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:19:26.538] Searching for globals ... DONE
[13:19:26.538] Resolving globals: FALSE
[13:19:26.539] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:19:26.539] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:19:26.539] - globals: [1] ‘FUN’
[13:19:26.539] 
[13:19:26.540] getGlobalsAndPackages() ... DONE
[13:19:26.540]  - globals found/used: [n=1] ‘FUN’
[13:19:26.540]  - needed namespaces: [n=0] 
[13:19:26.540] Finding globals ... DONE
[13:19:26.540] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:19:26.540] List of 2
[13:19:26.540]  $ ...future.FUN:function (x, y)  
[13:19:26.540]  $ MoreArgs     : NULL
[13:19:26.540]  - attr(*, "where")=List of 2
[13:19:26.540]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:19:26.540]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:19:26.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:19:26.540]  - attr(*, "resolved")= logi FALSE
[13:19:26.540]  - attr(*, "total_size")= num NA
[13:19:26.543] Packages to be attached in all futures: [n=0] 
[13:19:26.543] getGlobalsAndPackagesXApply() ... DONE
[13:19:26.543] Number of futures (= number of chunks): 2
[13:19:26.543] Launching 2 futures (chunks) ...
[13:19:26.543] Chunk #1 of 2 ...
[13:19:26.543]  - Finding globals in '...' for chunk #1 ...
[13:19:26.543] getGlobalsAndPackages() ...
[13:19:26.544] Searching for globals...
[13:19:26.544] 
[13:19:26.544] Searching for globals ... DONE
[13:19:26.544] - globals: [0] <none>
[13:19:26.544] getGlobalsAndPackages() ... DONE
[13:19:26.544]    + additional globals found: [n=0] 
[13:19:26.544]    + additional namespaces needed: [n=0] 
[13:19:26.544]  - Finding globals in '...' for chunk #1 ... DONE
[13:19:26.544]  - seeds: <none>
[13:19:26.545] getGlobalsAndPackages() ...
[13:19:26.545] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:26.545] Resolving globals: FALSE
[13:19:26.545] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:26.546] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:26.546] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:26.546] 
[13:19:26.546] getGlobalsAndPackages() ... DONE
[13:19:26.546] run() for ‘Future’ ...
[13:19:26.546] - state: ‘created’
[13:19:26.547] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:26.561] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:26.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:26.561]   - Field: ‘node’
[13:19:26.562]   - Field: ‘label’
[13:19:26.562]   - Field: ‘local’
[13:19:26.562]   - Field: ‘owner’
[13:19:26.562]   - Field: ‘envir’
[13:19:26.562]   - Field: ‘workers’
[13:19:26.562]   - Field: ‘packages’
[13:19:26.562]   - Field: ‘gc’
[13:19:26.562]   - Field: ‘conditions’
[13:19:26.562]   - Field: ‘persistent’
[13:19:26.562]   - Field: ‘expr’
[13:19:26.563]   - Field: ‘uuid’
[13:19:26.563]   - Field: ‘seed’
[13:19:26.563]   - Field: ‘version’
[13:19:26.563]   - Field: ‘result’
[13:19:26.563]   - Field: ‘asynchronous’
[13:19:26.563]   - Field: ‘calls’
[13:19:26.563]   - Field: ‘globals’
[13:19:26.563]   - Field: ‘stdout’
[13:19:26.563]   - Field: ‘earlySignal’
[13:19:26.563]   - Field: ‘lazy’
[13:19:26.563]   - Field: ‘state’
[13:19:26.564] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:26.564] - Launch lazy future ...
[13:19:26.564] Packages needed by the future expression (n = 0): <none>
[13:19:26.564] Packages needed by future strategies (n = 0): <none>
[13:19:26.564] {
[13:19:26.564]     {
[13:19:26.564]         {
[13:19:26.564]             ...future.startTime <- base::Sys.time()
[13:19:26.564]             {
[13:19:26.564]                 {
[13:19:26.564]                   {
[13:19:26.564]                     {
[13:19:26.564]                       base::local({
[13:19:26.564]                         has_future <- base::requireNamespace("future", 
[13:19:26.564]                           quietly = TRUE)
[13:19:26.564]                         if (has_future) {
[13:19:26.564]                           ns <- base::getNamespace("future")
[13:19:26.564]                           version <- ns[[".package"]][["version"]]
[13:19:26.564]                           if (is.null(version)) 
[13:19:26.564]                             version <- utils::packageVersion("future")
[13:19:26.564]                         }
[13:19:26.564]                         else {
[13:19:26.564]                           version <- NULL
[13:19:26.564]                         }
[13:19:26.564]                         if (!has_future || version < "1.8.0") {
[13:19:26.564]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:26.564]                             "", base::R.version$version.string), 
[13:19:26.564]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:26.564]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:26.564]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:26.564]                               "release", "version")], collapse = " "), 
[13:19:26.564]                             hostname = base::Sys.info()[["nodename"]])
[13:19:26.564]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:26.564]                             info)
[13:19:26.564]                           info <- base::paste(info, collapse = "; ")
[13:19:26.564]                           if (!has_future) {
[13:19:26.564]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:26.564]                               info)
[13:19:26.564]                           }
[13:19:26.564]                           else {
[13:19:26.564]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:26.564]                               info, version)
[13:19:26.564]                           }
[13:19:26.564]                           base::stop(msg)
[13:19:26.564]                         }
[13:19:26.564]                       })
[13:19:26.564]                     }
[13:19:26.564]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:26.564]                     base::options(mc.cores = 1L)
[13:19:26.564]                   }
[13:19:26.564]                   options(future.plan = NULL)
[13:19:26.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:26.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:26.564]                 }
[13:19:26.564]                 ...future.workdir <- getwd()
[13:19:26.564]             }
[13:19:26.564]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:26.564]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:26.564]         }
[13:19:26.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:26.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:26.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:26.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:26.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:26.564]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:26.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:26.564]             base::names(...future.oldOptions))
[13:19:26.564]     }
[13:19:26.564]     if (TRUE) {
[13:19:26.564]     }
[13:19:26.564]     else {
[13:19:26.564]         if (NA) {
[13:19:26.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:26.564]                 open = "w")
[13:19:26.564]         }
[13:19:26.564]         else {
[13:19:26.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:26.564]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:26.564]         }
[13:19:26.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:26.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:26.564]             base::sink(type = "output", split = FALSE)
[13:19:26.564]             base::close(...future.stdout)
[13:19:26.564]         }, add = TRUE)
[13:19:26.564]     }
[13:19:26.564]     ...future.frame <- base::sys.nframe()
[13:19:26.564]     ...future.conditions <- base::list()
[13:19:26.564]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:26.564]     if (FALSE) {
[13:19:26.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:26.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:26.564]     }
[13:19:26.564]     ...future.result <- base::tryCatch({
[13:19:26.564]         base::withCallingHandlers({
[13:19:26.564]             ...future.value <- base::withVisible(base::local({
[13:19:26.564]                 ...future.makeSendCondition <- local({
[13:19:26.564]                   sendCondition <- NULL
[13:19:26.564]                   function(frame = 1L) {
[13:19:26.564]                     if (is.function(sendCondition)) 
[13:19:26.564]                       return(sendCondition)
[13:19:26.564]                     ns <- getNamespace("parallel")
[13:19:26.564]                     if (exists("sendData", mode = "function", 
[13:19:26.564]                       envir = ns)) {
[13:19:26.564]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:26.564]                         envir = ns)
[13:19:26.564]                       envir <- sys.frame(frame)
[13:19:26.564]                       master <- NULL
[13:19:26.564]                       while (!identical(envir, .GlobalEnv) && 
[13:19:26.564]                         !identical(envir, emptyenv())) {
[13:19:26.564]                         if (exists("master", mode = "list", envir = envir, 
[13:19:26.564]                           inherits = FALSE)) {
[13:19:26.564]                           master <- get("master", mode = "list", 
[13:19:26.564]                             envir = envir, inherits = FALSE)
[13:19:26.564]                           if (inherits(master, c("SOCKnode", 
[13:19:26.564]                             "SOCK0node"))) {
[13:19:26.564]                             sendCondition <<- function(cond) {
[13:19:26.564]                               data <- list(type = "VALUE", value = cond, 
[13:19:26.564]                                 success = TRUE)
[13:19:26.564]                               parallel_sendData(master, data)
[13:19:26.564]                             }
[13:19:26.564]                             return(sendCondition)
[13:19:26.564]                           }
[13:19:26.564]                         }
[13:19:26.564]                         frame <- frame + 1L
[13:19:26.564]                         envir <- sys.frame(frame)
[13:19:26.564]                       }
[13:19:26.564]                     }
[13:19:26.564]                     sendCondition <<- function(cond) NULL
[13:19:26.564]                   }
[13:19:26.564]                 })
[13:19:26.564]                 withCallingHandlers({
[13:19:26.564]                   {
[13:19:26.564]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:26.564]                     if (!identical(...future.globals.maxSize.org, 
[13:19:26.564]                       ...future.globals.maxSize)) {
[13:19:26.564]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:26.564]                       on.exit(options(oopts), add = TRUE)
[13:19:26.564]                     }
[13:19:26.564]                     {
[13:19:26.564]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:26.564]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:26.564]                         USE.NAMES = FALSE)
[13:19:26.564]                       do.call(mapply, args = args)
[13:19:26.564]                     }
[13:19:26.564]                   }
[13:19:26.564]                 }, immediateCondition = function(cond) {
[13:19:26.564]                   sendCondition <- ...future.makeSendCondition()
[13:19:26.564]                   sendCondition(cond)
[13:19:26.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.564]                   {
[13:19:26.564]                     inherits <- base::inherits
[13:19:26.564]                     invokeRestart <- base::invokeRestart
[13:19:26.564]                     is.null <- base::is.null
[13:19:26.564]                     muffled <- FALSE
[13:19:26.564]                     if (inherits(cond, "message")) {
[13:19:26.564]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:26.564]                       if (muffled) 
[13:19:26.564]                         invokeRestart("muffleMessage")
[13:19:26.564]                     }
[13:19:26.564]                     else if (inherits(cond, "warning")) {
[13:19:26.564]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:26.564]                       if (muffled) 
[13:19:26.564]                         invokeRestart("muffleWarning")
[13:19:26.564]                     }
[13:19:26.564]                     else if (inherits(cond, "condition")) {
[13:19:26.564]                       if (!is.null(pattern)) {
[13:19:26.564]                         computeRestarts <- base::computeRestarts
[13:19:26.564]                         grepl <- base::grepl
[13:19:26.564]                         restarts <- computeRestarts(cond)
[13:19:26.564]                         for (restart in restarts) {
[13:19:26.564]                           name <- restart$name
[13:19:26.564]                           if (is.null(name)) 
[13:19:26.564]                             next
[13:19:26.564]                           if (!grepl(pattern, name)) 
[13:19:26.564]                             next
[13:19:26.564]                           invokeRestart(restart)
[13:19:26.564]                           muffled <- TRUE
[13:19:26.564]                           break
[13:19:26.564]                         }
[13:19:26.564]                       }
[13:19:26.564]                     }
[13:19:26.564]                     invisible(muffled)
[13:19:26.564]                   }
[13:19:26.564]                   muffleCondition(cond)
[13:19:26.564]                 })
[13:19:26.564]             }))
[13:19:26.564]             future::FutureResult(value = ...future.value$value, 
[13:19:26.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:26.564]                   ...future.rng), globalenv = if (FALSE) 
[13:19:26.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:26.564]                     ...future.globalenv.names))
[13:19:26.564]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:26.564]         }, condition = base::local({
[13:19:26.564]             c <- base::c
[13:19:26.564]             inherits <- base::inherits
[13:19:26.564]             invokeRestart <- base::invokeRestart
[13:19:26.564]             length <- base::length
[13:19:26.564]             list <- base::list
[13:19:26.564]             seq.int <- base::seq.int
[13:19:26.564]             signalCondition <- base::signalCondition
[13:19:26.564]             sys.calls <- base::sys.calls
[13:19:26.564]             `[[` <- base::`[[`
[13:19:26.564]             `+` <- base::`+`
[13:19:26.564]             `<<-` <- base::`<<-`
[13:19:26.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:26.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:26.564]                   3L)]
[13:19:26.564]             }
[13:19:26.564]             function(cond) {
[13:19:26.564]                 is_error <- inherits(cond, "error")
[13:19:26.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:26.564]                   NULL)
[13:19:26.564]                 if (is_error) {
[13:19:26.564]                   sessionInformation <- function() {
[13:19:26.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:26.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:26.564]                       search = base::search(), system = base::Sys.info())
[13:19:26.564]                   }
[13:19:26.564]                   ...future.conditions[[length(...future.conditions) + 
[13:19:26.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:26.564]                     cond$call), session = sessionInformation(), 
[13:19:26.564]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:26.564]                   signalCondition(cond)
[13:19:26.564]                 }
[13:19:26.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:26.564]                 "immediateCondition"))) {
[13:19:26.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:26.564]                   ...future.conditions[[length(...future.conditions) + 
[13:19:26.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:26.564]                   if (TRUE && !signal) {
[13:19:26.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.564]                     {
[13:19:26.564]                       inherits <- base::inherits
[13:19:26.564]                       invokeRestart <- base::invokeRestart
[13:19:26.564]                       is.null <- base::is.null
[13:19:26.564]                       muffled <- FALSE
[13:19:26.564]                       if (inherits(cond, "message")) {
[13:19:26.564]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:26.564]                         if (muffled) 
[13:19:26.564]                           invokeRestart("muffleMessage")
[13:19:26.564]                       }
[13:19:26.564]                       else if (inherits(cond, "warning")) {
[13:19:26.564]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:26.564]                         if (muffled) 
[13:19:26.564]                           invokeRestart("muffleWarning")
[13:19:26.564]                       }
[13:19:26.564]                       else if (inherits(cond, "condition")) {
[13:19:26.564]                         if (!is.null(pattern)) {
[13:19:26.564]                           computeRestarts <- base::computeRestarts
[13:19:26.564]                           grepl <- base::grepl
[13:19:26.564]                           restarts <- computeRestarts(cond)
[13:19:26.564]                           for (restart in restarts) {
[13:19:26.564]                             name <- restart$name
[13:19:26.564]                             if (is.null(name)) 
[13:19:26.564]                               next
[13:19:26.564]                             if (!grepl(pattern, name)) 
[13:19:26.564]                               next
[13:19:26.564]                             invokeRestart(restart)
[13:19:26.564]                             muffled <- TRUE
[13:19:26.564]                             break
[13:19:26.564]                           }
[13:19:26.564]                         }
[13:19:26.564]                       }
[13:19:26.564]                       invisible(muffled)
[13:19:26.564]                     }
[13:19:26.564]                     muffleCondition(cond, pattern = "^muffle")
[13:19:26.564]                   }
[13:19:26.564]                 }
[13:19:26.564]                 else {
[13:19:26.564]                   if (TRUE) {
[13:19:26.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.564]                     {
[13:19:26.564]                       inherits <- base::inherits
[13:19:26.564]                       invokeRestart <- base::invokeRestart
[13:19:26.564]                       is.null <- base::is.null
[13:19:26.564]                       muffled <- FALSE
[13:19:26.564]                       if (inherits(cond, "message")) {
[13:19:26.564]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:26.564]                         if (muffled) 
[13:19:26.564]                           invokeRestart("muffleMessage")
[13:19:26.564]                       }
[13:19:26.564]                       else if (inherits(cond, "warning")) {
[13:19:26.564]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:26.564]                         if (muffled) 
[13:19:26.564]                           invokeRestart("muffleWarning")
[13:19:26.564]                       }
[13:19:26.564]                       else if (inherits(cond, "condition")) {
[13:19:26.564]                         if (!is.null(pattern)) {
[13:19:26.564]                           computeRestarts <- base::computeRestarts
[13:19:26.564]                           grepl <- base::grepl
[13:19:26.564]                           restarts <- computeRestarts(cond)
[13:19:26.564]                           for (restart in restarts) {
[13:19:26.564]                             name <- restart$name
[13:19:26.564]                             if (is.null(name)) 
[13:19:26.564]                               next
[13:19:26.564]                             if (!grepl(pattern, name)) 
[13:19:26.564]                               next
[13:19:26.564]                             invokeRestart(restart)
[13:19:26.564]                             muffled <- TRUE
[13:19:26.564]                             break
[13:19:26.564]                           }
[13:19:26.564]                         }
[13:19:26.564]                       }
[13:19:26.564]                       invisible(muffled)
[13:19:26.564]                     }
[13:19:26.564]                     muffleCondition(cond, pattern = "^muffle")
[13:19:26.564]                   }
[13:19:26.564]                 }
[13:19:26.564]             }
[13:19:26.564]         }))
[13:19:26.564]     }, error = function(ex) {
[13:19:26.564]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:26.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:26.564]                 ...future.rng), started = ...future.startTime, 
[13:19:26.564]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:26.564]             version = "1.8"), class = "FutureResult")
[13:19:26.564]     }, finally = {
[13:19:26.564]         if (!identical(...future.workdir, getwd())) 
[13:19:26.564]             setwd(...future.workdir)
[13:19:26.564]         {
[13:19:26.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:26.564]                 ...future.oldOptions$nwarnings <- NULL
[13:19:26.564]             }
[13:19:26.564]             base::options(...future.oldOptions)
[13:19:26.564]             if (.Platform$OS.type == "windows") {
[13:19:26.564]                 old_names <- names(...future.oldEnvVars)
[13:19:26.564]                 envs <- base::Sys.getenv()
[13:19:26.564]                 names <- names(envs)
[13:19:26.564]                 common <- intersect(names, old_names)
[13:19:26.564]                 added <- setdiff(names, old_names)
[13:19:26.564]                 removed <- setdiff(old_names, names)
[13:19:26.564]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:26.564]                   envs[common]]
[13:19:26.564]                 NAMES <- toupper(changed)
[13:19:26.564]                 args <- list()
[13:19:26.564]                 for (kk in seq_along(NAMES)) {
[13:19:26.564]                   name <- changed[[kk]]
[13:19:26.564]                   NAME <- NAMES[[kk]]
[13:19:26.564]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.564]                     next
[13:19:26.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:26.564]                 }
[13:19:26.564]                 NAMES <- toupper(added)
[13:19:26.564]                 for (kk in seq_along(NAMES)) {
[13:19:26.564]                   name <- added[[kk]]
[13:19:26.564]                   NAME <- NAMES[[kk]]
[13:19:26.564]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.564]                     next
[13:19:26.564]                   args[[name]] <- ""
[13:19:26.564]                 }
[13:19:26.564]                 NAMES <- toupper(removed)
[13:19:26.564]                 for (kk in seq_along(NAMES)) {
[13:19:26.564]                   name <- removed[[kk]]
[13:19:26.564]                   NAME <- NAMES[[kk]]
[13:19:26.564]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.564]                     next
[13:19:26.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:26.564]                 }
[13:19:26.564]                 if (length(args) > 0) 
[13:19:26.564]                   base::do.call(base::Sys.setenv, args = args)
[13:19:26.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:26.564]             }
[13:19:26.564]             else {
[13:19:26.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:26.564]             }
[13:19:26.564]             {
[13:19:26.564]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:26.564]                   0L) {
[13:19:26.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:26.564]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:26.564]                   base::options(opts)
[13:19:26.564]                 }
[13:19:26.564]                 {
[13:19:26.564]                   {
[13:19:26.564]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:26.564]                     NULL
[13:19:26.564]                   }
[13:19:26.564]                   options(future.plan = NULL)
[13:19:26.564]                   if (is.na(NA_character_)) 
[13:19:26.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:26.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:26.564]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:26.564]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:26.564]                     envir = parent.frame()) 
[13:19:26.564]                   {
[13:19:26.564]                     if (is.function(workers)) 
[13:19:26.564]                       workers <- workers()
[13:19:26.564]                     workers <- structure(as.integer(workers), 
[13:19:26.564]                       class = class(workers))
[13:19:26.564]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:26.564]                       workers >= 1)
[13:19:26.564]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:26.564]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:26.564]                     }
[13:19:26.564]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:26.564]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:26.564]                       envir = envir)
[13:19:26.564]                     if (!future$lazy) 
[13:19:26.564]                       future <- run(future)
[13:19:26.564]                     invisible(future)
[13:19:26.564]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:26.564]                 }
[13:19:26.564]             }
[13:19:26.564]         }
[13:19:26.564]     })
[13:19:26.564]     if (FALSE) {
[13:19:26.564]         base::sink(type = "output", split = FALSE)
[13:19:26.564]         if (NA) {
[13:19:26.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:26.564]         }
[13:19:26.564]         else {
[13:19:26.564]             ...future.result["stdout"] <- base::list(NULL)
[13:19:26.564]         }
[13:19:26.564]         base::close(...future.stdout)
[13:19:26.564]         ...future.stdout <- NULL
[13:19:26.564]     }
[13:19:26.564]     ...future.result$conditions <- ...future.conditions
[13:19:26.564]     ...future.result$finished <- base::Sys.time()
[13:19:26.564]     ...future.result
[13:19:26.564] }
[13:19:26.567] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:19:26.568] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:19:26.568] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:19:26.568] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:19:26.568] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:19:26.568] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:19:26.569] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:19:26.569] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:19:26.569] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:19:26.569] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:19:26.570] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:19:26.570] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:19:26.570] MultisessionFuture started
[13:19:26.570] - Launch lazy future ... done
[13:19:26.571] run() for ‘MultisessionFuture’ ... done
[13:19:26.571] Created future:
[13:19:26.571] MultisessionFuture:
[13:19:26.571] Label: ‘future_mapply-1’
[13:19:26.571] Expression:
[13:19:26.571] {
[13:19:26.571]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:26.571]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:26.571]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:26.571]         on.exit(options(oopts), add = TRUE)
[13:19:26.571]     }
[13:19:26.571]     {
[13:19:26.571]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:26.571]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:26.571]         do.call(mapply, args = args)
[13:19:26.571]     }
[13:19:26.571] }
[13:19:26.571] Lazy evaluation: FALSE
[13:19:26.571] Asynchronous evaluation: TRUE
[13:19:26.571] Local evaluation: TRUE
[13:19:26.571] Environment: R_GlobalEnv
[13:19:26.571] Capture standard output: NA
[13:19:26.571] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:26.571] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:26.571] Packages: <none>
[13:19:26.571] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:26.571] Resolved: FALSE
[13:19:26.571] Value: <not collected>
[13:19:26.571] Conditions captured: <none>
[13:19:26.571] Early signaling: FALSE
[13:19:26.571] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:26.571] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:26.582] Chunk #1 of 2 ... DONE
[13:19:26.582] Chunk #2 of 2 ...
[13:19:26.582]  - Finding globals in '...' for chunk #2 ...
[13:19:26.582] getGlobalsAndPackages() ...
[13:19:26.583] Searching for globals...
[13:19:26.583] 
[13:19:26.583] Searching for globals ... DONE
[13:19:26.583] - globals: [0] <none>
[13:19:26.583] getGlobalsAndPackages() ... DONE
[13:19:26.583]    + additional globals found: [n=0] 
[13:19:26.583]    + additional namespaces needed: [n=0] 
[13:19:26.583]  - Finding globals in '...' for chunk #2 ... DONE
[13:19:26.584]  - seeds: <none>
[13:19:26.584] getGlobalsAndPackages() ...
[13:19:26.584] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:26.584] Resolving globals: FALSE
[13:19:26.584] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:19:26.585] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:19:26.585] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:19:26.585] 
[13:19:26.585] getGlobalsAndPackages() ... DONE
[13:19:26.585] run() for ‘Future’ ...
[13:19:26.586] - state: ‘created’
[13:19:26.586] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:19:26.601] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:26.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:19:26.601]   - Field: ‘node’
[13:19:26.601]   - Field: ‘label’
[13:19:26.601]   - Field: ‘local’
[13:19:26.601]   - Field: ‘owner’
[13:19:26.602]   - Field: ‘envir’
[13:19:26.602]   - Field: ‘workers’
[13:19:26.602]   - Field: ‘packages’
[13:19:26.602]   - Field: ‘gc’
[13:19:26.602]   - Field: ‘conditions’
[13:19:26.602]   - Field: ‘persistent’
[13:19:26.602]   - Field: ‘expr’
[13:19:26.602]   - Field: ‘uuid’
[13:19:26.602]   - Field: ‘seed’
[13:19:26.602]   - Field: ‘version’
[13:19:26.602]   - Field: ‘result’
[13:19:26.603]   - Field: ‘asynchronous’
[13:19:26.603]   - Field: ‘calls’
[13:19:26.603]   - Field: ‘globals’
[13:19:26.603]   - Field: ‘stdout’
[13:19:26.603]   - Field: ‘earlySignal’
[13:19:26.603]   - Field: ‘lazy’
[13:19:26.603]   - Field: ‘state’
[13:19:26.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:19:26.603] - Launch lazy future ...
[13:19:26.604] Packages needed by the future expression (n = 0): <none>
[13:19:26.604] Packages needed by future strategies (n = 0): <none>
[13:19:26.604] {
[13:19:26.604]     {
[13:19:26.604]         {
[13:19:26.604]             ...future.startTime <- base::Sys.time()
[13:19:26.604]             {
[13:19:26.604]                 {
[13:19:26.604]                   {
[13:19:26.604]                     {
[13:19:26.604]                       base::local({
[13:19:26.604]                         has_future <- base::requireNamespace("future", 
[13:19:26.604]                           quietly = TRUE)
[13:19:26.604]                         if (has_future) {
[13:19:26.604]                           ns <- base::getNamespace("future")
[13:19:26.604]                           version <- ns[[".package"]][["version"]]
[13:19:26.604]                           if (is.null(version)) 
[13:19:26.604]                             version <- utils::packageVersion("future")
[13:19:26.604]                         }
[13:19:26.604]                         else {
[13:19:26.604]                           version <- NULL
[13:19:26.604]                         }
[13:19:26.604]                         if (!has_future || version < "1.8.0") {
[13:19:26.604]                           info <- base::c(r_version = base::gsub("R version ", 
[13:19:26.604]                             "", base::R.version$version.string), 
[13:19:26.604]                             platform = base::sprintf("%s (%s-bit)", 
[13:19:26.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:19:26.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:19:26.604]                               "release", "version")], collapse = " "), 
[13:19:26.604]                             hostname = base::Sys.info()[["nodename"]])
[13:19:26.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:19:26.604]                             info)
[13:19:26.604]                           info <- base::paste(info, collapse = "; ")
[13:19:26.604]                           if (!has_future) {
[13:19:26.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:19:26.604]                               info)
[13:19:26.604]                           }
[13:19:26.604]                           else {
[13:19:26.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:19:26.604]                               info, version)
[13:19:26.604]                           }
[13:19:26.604]                           base::stop(msg)
[13:19:26.604]                         }
[13:19:26.604]                       })
[13:19:26.604]                     }
[13:19:26.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:19:26.604]                     base::options(mc.cores = 1L)
[13:19:26.604]                   }
[13:19:26.604]                   options(future.plan = NULL)
[13:19:26.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:19:26.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:19:26.604]                 }
[13:19:26.604]                 ...future.workdir <- getwd()
[13:19:26.604]             }
[13:19:26.604]             ...future.oldOptions <- base::as.list(base::.Options)
[13:19:26.604]             ...future.oldEnvVars <- base::Sys.getenv()
[13:19:26.604]         }
[13:19:26.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:19:26.604]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:19:26.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:19:26.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:19:26.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:19:26.604]             future.stdout.windows.reencode = NULL, width = 80L)
[13:19:26.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:19:26.604]             base::names(...future.oldOptions))
[13:19:26.604]     }
[13:19:26.604]     if (TRUE) {
[13:19:26.604]     }
[13:19:26.604]     else {
[13:19:26.604]         if (NA) {
[13:19:26.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:19:26.604]                 open = "w")
[13:19:26.604]         }
[13:19:26.604]         else {
[13:19:26.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:19:26.604]                 windows = "NUL", "/dev/null"), open = "w")
[13:19:26.604]         }
[13:19:26.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:19:26.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:19:26.604]             base::sink(type = "output", split = FALSE)
[13:19:26.604]             base::close(...future.stdout)
[13:19:26.604]         }, add = TRUE)
[13:19:26.604]     }
[13:19:26.604]     ...future.frame <- base::sys.nframe()
[13:19:26.604]     ...future.conditions <- base::list()
[13:19:26.604]     ...future.rng <- base::globalenv()$.Random.seed
[13:19:26.604]     if (FALSE) {
[13:19:26.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:19:26.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:19:26.604]     }
[13:19:26.604]     ...future.result <- base::tryCatch({
[13:19:26.604]         base::withCallingHandlers({
[13:19:26.604]             ...future.value <- base::withVisible(base::local({
[13:19:26.604]                 ...future.makeSendCondition <- local({
[13:19:26.604]                   sendCondition <- NULL
[13:19:26.604]                   function(frame = 1L) {
[13:19:26.604]                     if (is.function(sendCondition)) 
[13:19:26.604]                       return(sendCondition)
[13:19:26.604]                     ns <- getNamespace("parallel")
[13:19:26.604]                     if (exists("sendData", mode = "function", 
[13:19:26.604]                       envir = ns)) {
[13:19:26.604]                       parallel_sendData <- get("sendData", mode = "function", 
[13:19:26.604]                         envir = ns)
[13:19:26.604]                       envir <- sys.frame(frame)
[13:19:26.604]                       master <- NULL
[13:19:26.604]                       while (!identical(envir, .GlobalEnv) && 
[13:19:26.604]                         !identical(envir, emptyenv())) {
[13:19:26.604]                         if (exists("master", mode = "list", envir = envir, 
[13:19:26.604]                           inherits = FALSE)) {
[13:19:26.604]                           master <- get("master", mode = "list", 
[13:19:26.604]                             envir = envir, inherits = FALSE)
[13:19:26.604]                           if (inherits(master, c("SOCKnode", 
[13:19:26.604]                             "SOCK0node"))) {
[13:19:26.604]                             sendCondition <<- function(cond) {
[13:19:26.604]                               data <- list(type = "VALUE", value = cond, 
[13:19:26.604]                                 success = TRUE)
[13:19:26.604]                               parallel_sendData(master, data)
[13:19:26.604]                             }
[13:19:26.604]                             return(sendCondition)
[13:19:26.604]                           }
[13:19:26.604]                         }
[13:19:26.604]                         frame <- frame + 1L
[13:19:26.604]                         envir <- sys.frame(frame)
[13:19:26.604]                       }
[13:19:26.604]                     }
[13:19:26.604]                     sendCondition <<- function(cond) NULL
[13:19:26.604]                   }
[13:19:26.604]                 })
[13:19:26.604]                 withCallingHandlers({
[13:19:26.604]                   {
[13:19:26.604]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:26.604]                     if (!identical(...future.globals.maxSize.org, 
[13:19:26.604]                       ...future.globals.maxSize)) {
[13:19:26.604]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:26.604]                       on.exit(options(oopts), add = TRUE)
[13:19:26.604]                     }
[13:19:26.604]                     {
[13:19:26.604]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:26.604]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:19:26.604]                         USE.NAMES = FALSE)
[13:19:26.604]                       do.call(mapply, args = args)
[13:19:26.604]                     }
[13:19:26.604]                   }
[13:19:26.604]                 }, immediateCondition = function(cond) {
[13:19:26.604]                   sendCondition <- ...future.makeSendCondition()
[13:19:26.604]                   sendCondition(cond)
[13:19:26.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.604]                   {
[13:19:26.604]                     inherits <- base::inherits
[13:19:26.604]                     invokeRestart <- base::invokeRestart
[13:19:26.604]                     is.null <- base::is.null
[13:19:26.604]                     muffled <- FALSE
[13:19:26.604]                     if (inherits(cond, "message")) {
[13:19:26.604]                       muffled <- grepl(pattern, "muffleMessage")
[13:19:26.604]                       if (muffled) 
[13:19:26.604]                         invokeRestart("muffleMessage")
[13:19:26.604]                     }
[13:19:26.604]                     else if (inherits(cond, "warning")) {
[13:19:26.604]                       muffled <- grepl(pattern, "muffleWarning")
[13:19:26.604]                       if (muffled) 
[13:19:26.604]                         invokeRestart("muffleWarning")
[13:19:26.604]                     }
[13:19:26.604]                     else if (inherits(cond, "condition")) {
[13:19:26.604]                       if (!is.null(pattern)) {
[13:19:26.604]                         computeRestarts <- base::computeRestarts
[13:19:26.604]                         grepl <- base::grepl
[13:19:26.604]                         restarts <- computeRestarts(cond)
[13:19:26.604]                         for (restart in restarts) {
[13:19:26.604]                           name <- restart$name
[13:19:26.604]                           if (is.null(name)) 
[13:19:26.604]                             next
[13:19:26.604]                           if (!grepl(pattern, name)) 
[13:19:26.604]                             next
[13:19:26.604]                           invokeRestart(restart)
[13:19:26.604]                           muffled <- TRUE
[13:19:26.604]                           break
[13:19:26.604]                         }
[13:19:26.604]                       }
[13:19:26.604]                     }
[13:19:26.604]                     invisible(muffled)
[13:19:26.604]                   }
[13:19:26.604]                   muffleCondition(cond)
[13:19:26.604]                 })
[13:19:26.604]             }))
[13:19:26.604]             future::FutureResult(value = ...future.value$value, 
[13:19:26.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:26.604]                   ...future.rng), globalenv = if (FALSE) 
[13:19:26.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:19:26.604]                     ...future.globalenv.names))
[13:19:26.604]                 else NULL, started = ...future.startTime, version = "1.8")
[13:19:26.604]         }, condition = base::local({
[13:19:26.604]             c <- base::c
[13:19:26.604]             inherits <- base::inherits
[13:19:26.604]             invokeRestart <- base::invokeRestart
[13:19:26.604]             length <- base::length
[13:19:26.604]             list <- base::list
[13:19:26.604]             seq.int <- base::seq.int
[13:19:26.604]             signalCondition <- base::signalCondition
[13:19:26.604]             sys.calls <- base::sys.calls
[13:19:26.604]             `[[` <- base::`[[`
[13:19:26.604]             `+` <- base::`+`
[13:19:26.604]             `<<-` <- base::`<<-`
[13:19:26.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:19:26.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:19:26.604]                   3L)]
[13:19:26.604]             }
[13:19:26.604]             function(cond) {
[13:19:26.604]                 is_error <- inherits(cond, "error")
[13:19:26.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:19:26.604]                   NULL)
[13:19:26.604]                 if (is_error) {
[13:19:26.604]                   sessionInformation <- function() {
[13:19:26.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:19:26.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:19:26.604]                       search = base::search(), system = base::Sys.info())
[13:19:26.604]                   }
[13:19:26.604]                   ...future.conditions[[length(...future.conditions) + 
[13:19:26.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:19:26.604]                     cond$call), session = sessionInformation(), 
[13:19:26.604]                     timestamp = base::Sys.time(), signaled = 0L)
[13:19:26.604]                   signalCondition(cond)
[13:19:26.604]                 }
[13:19:26.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:19:26.604]                 "immediateCondition"))) {
[13:19:26.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:19:26.604]                   ...future.conditions[[length(...future.conditions) + 
[13:19:26.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:19:26.604]                   if (TRUE && !signal) {
[13:19:26.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.604]                     {
[13:19:26.604]                       inherits <- base::inherits
[13:19:26.604]                       invokeRestart <- base::invokeRestart
[13:19:26.604]                       is.null <- base::is.null
[13:19:26.604]                       muffled <- FALSE
[13:19:26.604]                       if (inherits(cond, "message")) {
[13:19:26.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:26.604]                         if (muffled) 
[13:19:26.604]                           invokeRestart("muffleMessage")
[13:19:26.604]                       }
[13:19:26.604]                       else if (inherits(cond, "warning")) {
[13:19:26.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:26.604]                         if (muffled) 
[13:19:26.604]                           invokeRestart("muffleWarning")
[13:19:26.604]                       }
[13:19:26.604]                       else if (inherits(cond, "condition")) {
[13:19:26.604]                         if (!is.null(pattern)) {
[13:19:26.604]                           computeRestarts <- base::computeRestarts
[13:19:26.604]                           grepl <- base::grepl
[13:19:26.604]                           restarts <- computeRestarts(cond)
[13:19:26.604]                           for (restart in restarts) {
[13:19:26.604]                             name <- restart$name
[13:19:26.604]                             if (is.null(name)) 
[13:19:26.604]                               next
[13:19:26.604]                             if (!grepl(pattern, name)) 
[13:19:26.604]                               next
[13:19:26.604]                             invokeRestart(restart)
[13:19:26.604]                             muffled <- TRUE
[13:19:26.604]                             break
[13:19:26.604]                           }
[13:19:26.604]                         }
[13:19:26.604]                       }
[13:19:26.604]                       invisible(muffled)
[13:19:26.604]                     }
[13:19:26.604]                     muffleCondition(cond, pattern = "^muffle")
[13:19:26.604]                   }
[13:19:26.604]                 }
[13:19:26.604]                 else {
[13:19:26.604]                   if (TRUE) {
[13:19:26.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:19:26.604]                     {
[13:19:26.604]                       inherits <- base::inherits
[13:19:26.604]                       invokeRestart <- base::invokeRestart
[13:19:26.604]                       is.null <- base::is.null
[13:19:26.604]                       muffled <- FALSE
[13:19:26.604]                       if (inherits(cond, "message")) {
[13:19:26.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:19:26.604]                         if (muffled) 
[13:19:26.604]                           invokeRestart("muffleMessage")
[13:19:26.604]                       }
[13:19:26.604]                       else if (inherits(cond, "warning")) {
[13:19:26.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:19:26.604]                         if (muffled) 
[13:19:26.604]                           invokeRestart("muffleWarning")
[13:19:26.604]                       }
[13:19:26.604]                       else if (inherits(cond, "condition")) {
[13:19:26.604]                         if (!is.null(pattern)) {
[13:19:26.604]                           computeRestarts <- base::computeRestarts
[13:19:26.604]                           grepl <- base::grepl
[13:19:26.604]                           restarts <- computeRestarts(cond)
[13:19:26.604]                           for (restart in restarts) {
[13:19:26.604]                             name <- restart$name
[13:19:26.604]                             if (is.null(name)) 
[13:19:26.604]                               next
[13:19:26.604]                             if (!grepl(pattern, name)) 
[13:19:26.604]                               next
[13:19:26.604]                             invokeRestart(restart)
[13:19:26.604]                             muffled <- TRUE
[13:19:26.604]                             break
[13:19:26.604]                           }
[13:19:26.604]                         }
[13:19:26.604]                       }
[13:19:26.604]                       invisible(muffled)
[13:19:26.604]                     }
[13:19:26.604]                     muffleCondition(cond, pattern = "^muffle")
[13:19:26.604]                   }
[13:19:26.604]                 }
[13:19:26.604]             }
[13:19:26.604]         }))
[13:19:26.604]     }, error = function(ex) {
[13:19:26.604]         base::structure(base::list(value = NULL, visible = NULL, 
[13:19:26.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:19:26.604]                 ...future.rng), started = ...future.startTime, 
[13:19:26.604]             finished = Sys.time(), session_uuid = NA_character_, 
[13:19:26.604]             version = "1.8"), class = "FutureResult")
[13:19:26.604]     }, finally = {
[13:19:26.604]         if (!identical(...future.workdir, getwd())) 
[13:19:26.604]             setwd(...future.workdir)
[13:19:26.604]         {
[13:19:26.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:19:26.604]                 ...future.oldOptions$nwarnings <- NULL
[13:19:26.604]             }
[13:19:26.604]             base::options(...future.oldOptions)
[13:19:26.604]             if (.Platform$OS.type == "windows") {
[13:19:26.604]                 old_names <- names(...future.oldEnvVars)
[13:19:26.604]                 envs <- base::Sys.getenv()
[13:19:26.604]                 names <- names(envs)
[13:19:26.604]                 common <- intersect(names, old_names)
[13:19:26.604]                 added <- setdiff(names, old_names)
[13:19:26.604]                 removed <- setdiff(old_names, names)
[13:19:26.604]                 changed <- common[...future.oldEnvVars[common] != 
[13:19:26.604]                   envs[common]]
[13:19:26.604]                 NAMES <- toupper(changed)
[13:19:26.604]                 args <- list()
[13:19:26.604]                 for (kk in seq_along(NAMES)) {
[13:19:26.604]                   name <- changed[[kk]]
[13:19:26.604]                   NAME <- NAMES[[kk]]
[13:19:26.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.604]                     next
[13:19:26.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:26.604]                 }
[13:19:26.604]                 NAMES <- toupper(added)
[13:19:26.604]                 for (kk in seq_along(NAMES)) {
[13:19:26.604]                   name <- added[[kk]]
[13:19:26.604]                   NAME <- NAMES[[kk]]
[13:19:26.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.604]                     next
[13:19:26.604]                   args[[name]] <- ""
[13:19:26.604]                 }
[13:19:26.604]                 NAMES <- toupper(removed)
[13:19:26.604]                 for (kk in seq_along(NAMES)) {
[13:19:26.604]                   name <- removed[[kk]]
[13:19:26.604]                   NAME <- NAMES[[kk]]
[13:19:26.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:19:26.604]                     next
[13:19:26.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:19:26.604]                 }
[13:19:26.604]                 if (length(args) > 0) 
[13:19:26.604]                   base::do.call(base::Sys.setenv, args = args)
[13:19:26.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:19:26.604]             }
[13:19:26.604]             else {
[13:19:26.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:19:26.604]             }
[13:19:26.604]             {
[13:19:26.604]                 if (base::length(...future.futureOptionsAdded) > 
[13:19:26.604]                   0L) {
[13:19:26.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:19:26.604]                   base::names(opts) <- ...future.futureOptionsAdded
[13:19:26.604]                   base::options(opts)
[13:19:26.604]                 }
[13:19:26.604]                 {
[13:19:26.604]                   {
[13:19:26.604]                     base::options(mc.cores = ...future.mc.cores.old)
[13:19:26.604]                     NULL
[13:19:26.604]                   }
[13:19:26.604]                   options(future.plan = NULL)
[13:19:26.604]                   if (is.na(NA_character_)) 
[13:19:26.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:19:26.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:19:26.604]                   future::plan(list(function (..., workers = availableCores(), 
[13:19:26.604]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:19:26.604]                     envir = parent.frame()) 
[13:19:26.604]                   {
[13:19:26.604]                     if (is.function(workers)) 
[13:19:26.604]                       workers <- workers()
[13:19:26.604]                     workers <- structure(as.integer(workers), 
[13:19:26.604]                       class = class(workers))
[13:19:26.604]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:19:26.604]                       workers >= 1)
[13:19:26.604]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:19:26.604]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:19:26.604]                     }
[13:19:26.604]                     future <- MultisessionFuture(..., workers = workers, 
[13:19:26.604]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:19:26.604]                       envir = envir)
[13:19:26.604]                     if (!future$lazy) 
[13:19:26.604]                       future <- run(future)
[13:19:26.604]                     invisible(future)
[13:19:26.604]                   }), .cleanup = FALSE, .init = FALSE)
[13:19:26.604]                 }
[13:19:26.604]             }
[13:19:26.604]         }
[13:19:26.604]     })
[13:19:26.604]     if (FALSE) {
[13:19:26.604]         base::sink(type = "output", split = FALSE)
[13:19:26.604]         if (NA) {
[13:19:26.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:19:26.604]         }
[13:19:26.604]         else {
[13:19:26.604]             ...future.result["stdout"] <- base::list(NULL)
[13:19:26.604]         }
[13:19:26.604]         base::close(...future.stdout)
[13:19:26.604]         ...future.stdout <- NULL
[13:19:26.604]     }
[13:19:26.604]     ...future.result$conditions <- ...future.conditions
[13:19:26.604]     ...future.result$finished <- base::Sys.time()
[13:19:26.604]     ...future.result
[13:19:26.604] }
[13:19:26.607] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:19:26.607] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:19:26.607] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:19:26.608] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:19:26.608] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:19:26.608] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:19:26.608] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:19:26.608] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:19:26.609] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:19:26.609] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:19:26.609] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:19:26.609] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:19:26.610] MultisessionFuture started
[13:19:26.610] - Launch lazy future ... done
[13:19:26.610] run() for ‘MultisessionFuture’ ... done
[13:19:26.610] Created future:
[13:19:26.610] MultisessionFuture:
[13:19:26.610] Label: ‘future_mapply-2’
[13:19:26.610] Expression:
[13:19:26.610] {
[13:19:26.610]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:19:26.610]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:19:26.610]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:19:26.610]         on.exit(options(oopts), add = TRUE)
[13:19:26.610]     }
[13:19:26.610]     {
[13:19:26.610]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:19:26.610]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:19:26.610]         do.call(mapply, args = args)
[13:19:26.610]     }
[13:19:26.610] }
[13:19:26.610] Lazy evaluation: FALSE
[13:19:26.610] Asynchronous evaluation: TRUE
[13:19:26.610] Local evaluation: TRUE
[13:19:26.610] Environment: R_GlobalEnv
[13:19:26.610] Capture standard output: NA
[13:19:26.610] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:19:26.610] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:19:26.610] Packages: <none>
[13:19:26.610] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:19:26.610] Resolved: FALSE
[13:19:26.610] Value: <not collected>
[13:19:26.610] Conditions captured: <none>
[13:19:26.610] Early signaling: FALSE
[13:19:26.610] Owner process: cb761111-df09-4f25-0832-098d30e6bf62
[13:19:26.610] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:19:26.622] Chunk #2 of 2 ... DONE
[13:19:26.622] Launching 2 futures (chunks) ... DONE
[13:19:26.622] Resolving 2 futures (chunks) ...
[13:19:26.622] resolve() on list ...
[13:19:26.622]  recursive: 0
[13:19:26.622]  length: 2
[13:19:26.622] 
[13:19:26.664] receiveMessageFromWorker() for ClusterFuture ...
[13:19:26.665] - Validating connection of MultisessionFuture
[13:19:26.665] - received message: FutureResult
[13:19:26.665] - Received FutureResult
[13:19:26.665] - Erased future from FutureRegistry
[13:19:26.665] result() for ClusterFuture ...
[13:19:26.665] - result already collected: FutureResult
[13:19:26.665] result() for ClusterFuture ... done
[13:19:26.666] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:26.666] Future #2
[13:19:26.666] result() for ClusterFuture ...
[13:19:26.666] - result already collected: FutureResult
[13:19:26.666] result() for ClusterFuture ... done
[13:19:26.666] result() for ClusterFuture ...
[13:19:26.666] - result already collected: FutureResult
[13:19:26.666] result() for ClusterFuture ... done
[13:19:26.666] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:19:26.666] - nx: 2
[13:19:26.667] - relay: TRUE
[13:19:26.667] - stdout: TRUE
[13:19:26.667] - signal: TRUE
[13:19:26.667] - resignal: FALSE
[13:19:26.667] - force: TRUE
[13:19:26.667] - relayed: [n=2] FALSE, FALSE
[13:19:26.667] - queued futures: [n=2] FALSE, FALSE
[13:19:26.667]  - until=1
[13:19:26.667]  - relaying element #1
[13:19:26.667] - relayed: [n=2] FALSE, FALSE
[13:19:26.667] - queued futures: [n=2] FALSE, TRUE
[13:19:26.668] signalConditionsASAP(NULL, pos=2) ... done
[13:19:26.668]  length: 1 (resolved future 2)
[13:19:27.118] receiveMessageFromWorker() for ClusterFuture ...
[13:19:27.119] - Validating connection of MultisessionFuture
[13:19:27.119] - received message: FutureResult
[13:19:27.119] - Received FutureResult
[13:19:27.119] - Erased future from FutureRegistry
[13:19:27.119] result() for ClusterFuture ...
[13:19:27.119] - result already collected: FutureResult
[13:19:27.119] result() for ClusterFuture ... done
[13:19:27.120] receiveMessageFromWorker() for ClusterFuture ... done
[13:19:27.120] Future #1
[13:19:27.120] result() for ClusterFuture ...
[13:19:27.120] - result already collected: FutureResult
[13:19:27.120] result() for ClusterFuture ... done
[13:19:27.120] result() for ClusterFuture ...
[13:19:27.120] - result already collected: FutureResult
[13:19:27.120] result() for ClusterFuture ... done
[13:19:27.122] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:19:27.122] - nx: 2
[13:19:27.123] - relay: TRUE
[13:19:27.123] - stdout: TRUE
[13:19:27.123] - signal: TRUE
[13:19:27.123] - resignal: FALSE
[13:19:27.123] - force: TRUE
[13:19:27.123] - relayed: [n=2] FALSE, FALSE
[13:19:27.123] - queued futures: [n=2] FALSE, TRUE
[13:19:27.123]  - until=1
[13:19:27.123]  - relaying element #1
[13:19:27.123] result() for ClusterFuture ...
[13:19:27.123] - result already collected: FutureResult
[13:19:27.123] result() for ClusterFuture ... done
[13:19:27.124] result() for ClusterFuture ...
[13:19:27.124] - result already collected: FutureResult
[13:19:27.124] result() for ClusterFuture ... done
[13:19:27.124] result() for ClusterFuture ...
[13:19:27.124] - result already collected: FutureResult
[13:19:27.124] result() for ClusterFuture ... done
[13:19:27.124] result() for ClusterFuture ...
[13:19:27.124] - result already collected: FutureResult
[13:19:27.124] result() for ClusterFuture ... done
[13:19:27.124] - relayed: [n=2] TRUE, FALSE
[13:19:27.124] - queued futures: [n=2] TRUE, TRUE
[13:19:27.124] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:19:27.125]  length: 0 (resolved future 1)
[13:19:27.125] Relaying remaining futures
[13:19:27.125] signalConditionsASAP(NULL, pos=0) ...
[13:19:27.125] - nx: 2
[13:19:27.125] - relay: TRUE
[13:19:27.125] - stdout: TRUE
[13:19:27.125] - signal: TRUE
[13:19:27.125] - resignal: FALSE
[13:19:27.125] - force: TRUE
[13:19:27.125] - relayed: [n=2] TRUE, FALSE
[13:19:27.125] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:19:27.126]  - relaying element #2
[13:19:27.126] result() for ClusterFuture ...
[13:19:27.126] - result already collected: FutureResult
[13:19:27.126] result() for ClusterFuture ... done
[13:19:27.126] result() for ClusterFuture ...
[13:19:27.126] - result already collected: FutureResult
[13:19:27.126] result() for ClusterFuture ... done
[13:19:27.126] result() for ClusterFuture ...
[13:19:27.126] - result already collected: FutureResult
[13:19:27.126] result() for ClusterFuture ... done
[13:19:27.127] result() for ClusterFuture ...
[13:19:27.127] - result already collected: FutureResult
[13:19:27.127] result() for ClusterFuture ... done
[13:19:27.127] - relayed: [n=2] TRUE, TRUE
[13:19:27.127] - queued futures: [n=2] TRUE, TRUE
[13:19:27.127] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:19:27.127] resolve() on list ... DONE
[13:19:27.127] result() for ClusterFuture ...
[13:19:27.127] - result already collected: FutureResult
[13:19:27.127] result() for ClusterFuture ... done
[13:19:27.127] result() for ClusterFuture ...
[13:19:27.127] - result already collected: FutureResult
[13:19:27.128] result() for ClusterFuture ... done
[13:19:27.128] result() for ClusterFuture ...
[13:19:27.128] - result already collected: FutureResult
[13:19:27.128] result() for ClusterFuture ... done
[13:19:27.128] result() for ClusterFuture ...
[13:19:27.128] - result already collected: FutureResult
[13:19:27.128] result() for ClusterFuture ... done
[13:19:27.128]  - Number of value chunks collected: 2
[13:19:27.128] Resolving 2 futures (chunks) ... DONE
[13:19:27.128] Reducing values from 2 chunks ...
[13:19:27.128]  - Number of values collected after concatenation: 2
[13:19:27.128]  - Number of values expected: 2
[13:19:27.129] Reducing values from 2 chunks ... DONE
[13:19:27.129] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[13:19:27.130] plan(): Setting new future strategy stack:
[13:19:27.130] List of future strategies:
[13:19:27.130] 1. FutureStrategy:
[13:19:27.130]    - args: function (..., envir = parent.frame())
[13:19:27.130]    - tweaked: FALSE
[13:19:27.130]    - call: future::plan(oplan)
[13:19:27.130] plan(): nbrOfWorkers() = 1
> 
