
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:10:59.594] plan(): Setting new future strategy stack:
[16:10:59.594] List of future strategies:
[16:10:59.594] 1. sequential:
[16:10:59.594]    - args: function (..., envir = parent.frame())
[16:10:59.594]    - tweaked: FALSE
[16:10:59.594]    - call: future::plan("sequential")
[16:10:59.604] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:10:59.705] plan(): Setting new future strategy stack:
[16:10:59.705] List of future strategies:
[16:10:59.705] 1. sequential:
[16:10:59.705]    - args: function (..., envir = parent.frame())
[16:10:59.705]    - tweaked: FALSE
[16:10:59.705]    - call: plan(strategy)
[16:10:59.716] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:10:59.722] future_lapply() ...
[16:10:59.728] Number of chunks: 1
[16:10:59.728] getGlobalsAndPackagesXApply() ...
[16:10:59.728]  - future.globals: TRUE
[16:10:59.729] getGlobalsAndPackages() ...
[16:10:59.729] Searching for globals...
[16:10:59.733] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:10:59.733] Searching for globals ... DONE
[16:10:59.733] Resolving globals: FALSE
[16:10:59.735] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:10:59.735] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:10:59.735] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.735] - packages: [1] ‘future.apply’
[16:10:59.736] getGlobalsAndPackages() ... DONE
[16:10:59.736]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.736]  - needed namespaces: [n=1] ‘future.apply’
[16:10:59.736] Finding globals ... DONE
[16:10:59.736]  - use_args: TRUE
[16:10:59.736]  - Getting '...' globals ...
[16:10:59.737] resolve() on list ...
[16:10:59.737]  recursive: 0
[16:10:59.737]  length: 1
[16:10:59.737]  elements: ‘...’
[16:10:59.738]  length: 0 (resolved future 1)
[16:10:59.738] resolve() on list ... DONE
[16:10:59.738]    - '...' content: [n=0] 
[16:10:59.738] List of 1
[16:10:59.738]  $ ...: list()
[16:10:59.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.738]  - attr(*, "where")=List of 1
[16:10:59.738]   ..$ ...:<environment: 0x561e8a191bc8> 
[16:10:59.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.738]  - attr(*, "resolved")= logi TRUE
[16:10:59.738]  - attr(*, "total_size")= num NA
[16:10:59.742]  - Getting '...' globals ... DONE
[16:10:59.743] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:10:59.743] List of 8
[16:10:59.743]  $ ...future.FUN:function (x, ...)  
[16:10:59.743]  $ x_FUN        :function (x)  
[16:10:59.743]  $ times        : int 1
[16:10:59.743]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.743]  $ stop_if_not  :function (...)  
[16:10:59.743]  $ dim          : NULL
[16:10:59.743]  $ valid_types  : chr "character"
[16:10:59.743]  $ ...          : list()
[16:10:59.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.743]  - attr(*, "where")=List of 8
[16:10:59.743]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:10:59.743]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:10:59.743]   ..$ times        :<environment: R_EmptyEnv> 
[16:10:59.743]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:10:59.743]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:10:59.743]   ..$ dim          :<environment: R_EmptyEnv> 
[16:10:59.743]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:10:59.743]   ..$ ...          :<environment: 0x561e8a191bc8> 
[16:10:59.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.743]  - attr(*, "resolved")= logi FALSE
[16:10:59.743]  - attr(*, "total_size")= num 94208
[16:10:59.748] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:10:59.748] getGlobalsAndPackagesXApply() ... DONE
[16:10:59.748] Number of futures (= number of chunks): 1
[16:10:59.748] Launching 1 futures (chunks) ...
[16:10:59.749] Chunk #1 of 1 ...
[16:10:59.749]  - Finding globals in 'X' for chunk #1 ...
[16:10:59.749] getGlobalsAndPackages() ...
[16:10:59.749] Searching for globals...
[16:10:59.749] 
[16:10:59.749] Searching for globals ... DONE
[16:10:59.750] - globals: [0] <none>
[16:10:59.750] getGlobalsAndPackages() ... DONE
[16:10:59.750]    + additional globals found: [n=0] 
[16:10:59.750]    + additional namespaces needed: [n=0] 
[16:10:59.750]  - Finding globals in 'X' for chunk #1 ... DONE
[16:10:59.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:10:59.750]  - seeds: <none>
[16:10:59.750] getGlobalsAndPackages() ...
[16:10:59.750] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.751] Resolving globals: FALSE
[16:10:59.751] Tweak future expression to call with '...' arguments ...
[16:10:59.751] {
[16:10:59.751]     do.call(function(...) {
[16:10:59.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.751]             on.exit(options(oopts), add = TRUE)
[16:10:59.751]         }
[16:10:59.751]         {
[16:10:59.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.751]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.751]             })
[16:10:59.751]         }
[16:10:59.751]     }, args = future.call.arguments)
[16:10:59.751] }
[16:10:59.751] Tweak future expression to call with '...' arguments ... DONE
[16:10:59.752] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.752] - packages: [1] ‘future.apply’
[16:10:59.752] getGlobalsAndPackages() ... DONE
[16:10:59.752] run() for ‘Future’ ...
[16:10:59.753] - state: ‘created’
[16:10:59.753] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:10:59.753] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:10:59.753]   - Field: ‘label’
[16:10:59.753]   - Field: ‘local’
[16:10:59.754]   - Field: ‘owner’
[16:10:59.754]   - Field: ‘envir’
[16:10:59.754]   - Field: ‘packages’
[16:10:59.754]   - Field: ‘gc’
[16:10:59.754]   - Field: ‘conditions’
[16:10:59.754]   - Field: ‘expr’
[16:10:59.754]   - Field: ‘uuid’
[16:10:59.754]   - Field: ‘seed’
[16:10:59.754]   - Field: ‘version’
[16:10:59.754]   - Field: ‘result’
[16:10:59.754]   - Field: ‘asynchronous’
[16:10:59.755]   - Field: ‘calls’
[16:10:59.755]   - Field: ‘globals’
[16:10:59.755]   - Field: ‘stdout’
[16:10:59.755]   - Field: ‘earlySignal’
[16:10:59.755]   - Field: ‘lazy’
[16:10:59.755]   - Field: ‘state’
[16:10:59.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:10:59.755] - Launch lazy future ...
[16:10:59.756] Packages needed by the future expression (n = 1): ‘future.apply’
[16:10:59.756] Packages needed by future strategies (n = 0): <none>
[16:10:59.757] {
[16:10:59.757]     {
[16:10:59.757]         {
[16:10:59.757]             ...future.startTime <- base::Sys.time()
[16:10:59.757]             {
[16:10:59.757]                 {
[16:10:59.757]                   {
[16:10:59.757]                     {
[16:10:59.757]                       base::local({
[16:10:59.757]                         has_future <- base::requireNamespace("future", 
[16:10:59.757]                           quietly = TRUE)
[16:10:59.757]                         if (has_future) {
[16:10:59.757]                           ns <- base::getNamespace("future")
[16:10:59.757]                           version <- ns[[".package"]][["version"]]
[16:10:59.757]                           if (is.null(version)) 
[16:10:59.757]                             version <- utils::packageVersion("future")
[16:10:59.757]                         }
[16:10:59.757]                         else {
[16:10:59.757]                           version <- NULL
[16:10:59.757]                         }
[16:10:59.757]                         if (!has_future || version < "1.8.0") {
[16:10:59.757]                           info <- base::c(r_version = base::gsub("R version ", 
[16:10:59.757]                             "", base::R.version$version.string), 
[16:10:59.757]                             platform = base::sprintf("%s (%s-bit)", 
[16:10:59.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:10:59.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:10:59.757]                               "release", "version")], collapse = " "), 
[16:10:59.757]                             hostname = base::Sys.info()[["nodename"]])
[16:10:59.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:10:59.757]                             info)
[16:10:59.757]                           info <- base::paste(info, collapse = "; ")
[16:10:59.757]                           if (!has_future) {
[16:10:59.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:10:59.757]                               info)
[16:10:59.757]                           }
[16:10:59.757]                           else {
[16:10:59.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:10:59.757]                               info, version)
[16:10:59.757]                           }
[16:10:59.757]                           base::stop(msg)
[16:10:59.757]                         }
[16:10:59.757]                       })
[16:10:59.757]                     }
[16:10:59.757]                     base::local({
[16:10:59.757]                       for (pkg in "future.apply") {
[16:10:59.757]                         base::loadNamespace(pkg)
[16:10:59.757]                         base::library(pkg, character.only = TRUE)
[16:10:59.757]                       }
[16:10:59.757]                     })
[16:10:59.757]                   }
[16:10:59.757]                   options(future.plan = NULL)
[16:10:59.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:10:59.757]                 }
[16:10:59.757]                 ...future.workdir <- getwd()
[16:10:59.757]             }
[16:10:59.757]             ...future.oldOptions <- base::as.list(base::.Options)
[16:10:59.757]             ...future.oldEnvVars <- base::Sys.getenv()
[16:10:59.757]         }
[16:10:59.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:10:59.757]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:10:59.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:10:59.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:10:59.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:10:59.757]             future.stdout.windows.reencode = NULL, width = 80L)
[16:10:59.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:10:59.757]             base::names(...future.oldOptions))
[16:10:59.757]     }
[16:10:59.757]     if (FALSE) {
[16:10:59.757]     }
[16:10:59.757]     else {
[16:10:59.757]         if (TRUE) {
[16:10:59.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:10:59.757]                 open = "w")
[16:10:59.757]         }
[16:10:59.757]         else {
[16:10:59.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:10:59.757]                 windows = "NUL", "/dev/null"), open = "w")
[16:10:59.757]         }
[16:10:59.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:10:59.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:10:59.757]             base::sink(type = "output", split = FALSE)
[16:10:59.757]             base::close(...future.stdout)
[16:10:59.757]         }, add = TRUE)
[16:10:59.757]     }
[16:10:59.757]     ...future.frame <- base::sys.nframe()
[16:10:59.757]     ...future.conditions <- base::list()
[16:10:59.757]     ...future.rng <- base::globalenv()$.Random.seed
[16:10:59.757]     if (FALSE) {
[16:10:59.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:10:59.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:10:59.757]     }
[16:10:59.757]     ...future.result <- base::tryCatch({
[16:10:59.757]         base::withCallingHandlers({
[16:10:59.757]             ...future.value <- base::withVisible(base::local({
[16:10:59.757]                 do.call(function(...) {
[16:10:59.757]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.757]                   if (!identical(...future.globals.maxSize.org, 
[16:10:59.757]                     ...future.globals.maxSize)) {
[16:10:59.757]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.757]                     on.exit(options(oopts), add = TRUE)
[16:10:59.757]                   }
[16:10:59.757]                   {
[16:10:59.757]                     lapply(seq_along(...future.elements_ii), 
[16:10:59.757]                       FUN = function(jj) {
[16:10:59.757]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.757]                         ...future.FUN(...future.X_jj, ...)
[16:10:59.757]                       })
[16:10:59.757]                   }
[16:10:59.757]                 }, args = future.call.arguments)
[16:10:59.757]             }))
[16:10:59.757]             future::FutureResult(value = ...future.value$value, 
[16:10:59.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.757]                   ...future.rng), globalenv = if (FALSE) 
[16:10:59.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:10:59.757]                     ...future.globalenv.names))
[16:10:59.757]                 else NULL, started = ...future.startTime, version = "1.8")
[16:10:59.757]         }, condition = base::local({
[16:10:59.757]             c <- base::c
[16:10:59.757]             inherits <- base::inherits
[16:10:59.757]             invokeRestart <- base::invokeRestart
[16:10:59.757]             length <- base::length
[16:10:59.757]             list <- base::list
[16:10:59.757]             seq.int <- base::seq.int
[16:10:59.757]             signalCondition <- base::signalCondition
[16:10:59.757]             sys.calls <- base::sys.calls
[16:10:59.757]             `[[` <- base::`[[`
[16:10:59.757]             `+` <- base::`+`
[16:10:59.757]             `<<-` <- base::`<<-`
[16:10:59.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:10:59.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:10:59.757]                   3L)]
[16:10:59.757]             }
[16:10:59.757]             function(cond) {
[16:10:59.757]                 is_error <- inherits(cond, "error")
[16:10:59.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:10:59.757]                   NULL)
[16:10:59.757]                 if (is_error) {
[16:10:59.757]                   sessionInformation <- function() {
[16:10:59.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:10:59.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:10:59.757]                       search = base::search(), system = base::Sys.info())
[16:10:59.757]                   }
[16:10:59.757]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:10:59.757]                     cond$call), session = sessionInformation(), 
[16:10:59.757]                     timestamp = base::Sys.time(), signaled = 0L)
[16:10:59.757]                   signalCondition(cond)
[16:10:59.757]                 }
[16:10:59.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:10:59.757]                 "immediateCondition"))) {
[16:10:59.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:10:59.757]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:10:59.757]                   if (TRUE && !signal) {
[16:10:59.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.757]                     {
[16:10:59.757]                       inherits <- base::inherits
[16:10:59.757]                       invokeRestart <- base::invokeRestart
[16:10:59.757]                       is.null <- base::is.null
[16:10:59.757]                       muffled <- FALSE
[16:10:59.757]                       if (inherits(cond, "message")) {
[16:10:59.757]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.757]                         if (muffled) 
[16:10:59.757]                           invokeRestart("muffleMessage")
[16:10:59.757]                       }
[16:10:59.757]                       else if (inherits(cond, "warning")) {
[16:10:59.757]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.757]                         if (muffled) 
[16:10:59.757]                           invokeRestart("muffleWarning")
[16:10:59.757]                       }
[16:10:59.757]                       else if (inherits(cond, "condition")) {
[16:10:59.757]                         if (!is.null(pattern)) {
[16:10:59.757]                           computeRestarts <- base::computeRestarts
[16:10:59.757]                           grepl <- base::grepl
[16:10:59.757]                           restarts <- computeRestarts(cond)
[16:10:59.757]                           for (restart in restarts) {
[16:10:59.757]                             name <- restart$name
[16:10:59.757]                             if (is.null(name)) 
[16:10:59.757]                               next
[16:10:59.757]                             if (!grepl(pattern, name)) 
[16:10:59.757]                               next
[16:10:59.757]                             invokeRestart(restart)
[16:10:59.757]                             muffled <- TRUE
[16:10:59.757]                             break
[16:10:59.757]                           }
[16:10:59.757]                         }
[16:10:59.757]                       }
[16:10:59.757]                       invisible(muffled)
[16:10:59.757]                     }
[16:10:59.757]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.757]                   }
[16:10:59.757]                 }
[16:10:59.757]                 else {
[16:10:59.757]                   if (TRUE) {
[16:10:59.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.757]                     {
[16:10:59.757]                       inherits <- base::inherits
[16:10:59.757]                       invokeRestart <- base::invokeRestart
[16:10:59.757]                       is.null <- base::is.null
[16:10:59.757]                       muffled <- FALSE
[16:10:59.757]                       if (inherits(cond, "message")) {
[16:10:59.757]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.757]                         if (muffled) 
[16:10:59.757]                           invokeRestart("muffleMessage")
[16:10:59.757]                       }
[16:10:59.757]                       else if (inherits(cond, "warning")) {
[16:10:59.757]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.757]                         if (muffled) 
[16:10:59.757]                           invokeRestart("muffleWarning")
[16:10:59.757]                       }
[16:10:59.757]                       else if (inherits(cond, "condition")) {
[16:10:59.757]                         if (!is.null(pattern)) {
[16:10:59.757]                           computeRestarts <- base::computeRestarts
[16:10:59.757]                           grepl <- base::grepl
[16:10:59.757]                           restarts <- computeRestarts(cond)
[16:10:59.757]                           for (restart in restarts) {
[16:10:59.757]                             name <- restart$name
[16:10:59.757]                             if (is.null(name)) 
[16:10:59.757]                               next
[16:10:59.757]                             if (!grepl(pattern, name)) 
[16:10:59.757]                               next
[16:10:59.757]                             invokeRestart(restart)
[16:10:59.757]                             muffled <- TRUE
[16:10:59.757]                             break
[16:10:59.757]                           }
[16:10:59.757]                         }
[16:10:59.757]                       }
[16:10:59.757]                       invisible(muffled)
[16:10:59.757]                     }
[16:10:59.757]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.757]                   }
[16:10:59.757]                 }
[16:10:59.757]             }
[16:10:59.757]         }))
[16:10:59.757]     }, error = function(ex) {
[16:10:59.757]         base::structure(base::list(value = NULL, visible = NULL, 
[16:10:59.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.757]                 ...future.rng), started = ...future.startTime, 
[16:10:59.757]             finished = Sys.time(), session_uuid = NA_character_, 
[16:10:59.757]             version = "1.8"), class = "FutureResult")
[16:10:59.757]     }, finally = {
[16:10:59.757]         if (!identical(...future.workdir, getwd())) 
[16:10:59.757]             setwd(...future.workdir)
[16:10:59.757]         {
[16:10:59.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:10:59.757]                 ...future.oldOptions$nwarnings <- NULL
[16:10:59.757]             }
[16:10:59.757]             base::options(...future.oldOptions)
[16:10:59.757]             if (.Platform$OS.type == "windows") {
[16:10:59.757]                 old_names <- names(...future.oldEnvVars)
[16:10:59.757]                 envs <- base::Sys.getenv()
[16:10:59.757]                 names <- names(envs)
[16:10:59.757]                 common <- intersect(names, old_names)
[16:10:59.757]                 added <- setdiff(names, old_names)
[16:10:59.757]                 removed <- setdiff(old_names, names)
[16:10:59.757]                 changed <- common[...future.oldEnvVars[common] != 
[16:10:59.757]                   envs[common]]
[16:10:59.757]                 NAMES <- toupper(changed)
[16:10:59.757]                 args <- list()
[16:10:59.757]                 for (kk in seq_along(NAMES)) {
[16:10:59.757]                   name <- changed[[kk]]
[16:10:59.757]                   NAME <- NAMES[[kk]]
[16:10:59.757]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.757]                     next
[16:10:59.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.757]                 }
[16:10:59.757]                 NAMES <- toupper(added)
[16:10:59.757]                 for (kk in seq_along(NAMES)) {
[16:10:59.757]                   name <- added[[kk]]
[16:10:59.757]                   NAME <- NAMES[[kk]]
[16:10:59.757]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.757]                     next
[16:10:59.757]                   args[[name]] <- ""
[16:10:59.757]                 }
[16:10:59.757]                 NAMES <- toupper(removed)
[16:10:59.757]                 for (kk in seq_along(NAMES)) {
[16:10:59.757]                   name <- removed[[kk]]
[16:10:59.757]                   NAME <- NAMES[[kk]]
[16:10:59.757]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.757]                     next
[16:10:59.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.757]                 }
[16:10:59.757]                 if (length(args) > 0) 
[16:10:59.757]                   base::do.call(base::Sys.setenv, args = args)
[16:10:59.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:10:59.757]             }
[16:10:59.757]             else {
[16:10:59.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:10:59.757]             }
[16:10:59.757]             {
[16:10:59.757]                 if (base::length(...future.futureOptionsAdded) > 
[16:10:59.757]                   0L) {
[16:10:59.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:10:59.757]                   base::names(opts) <- ...future.futureOptionsAdded
[16:10:59.757]                   base::options(opts)
[16:10:59.757]                 }
[16:10:59.757]                 {
[16:10:59.757]                   {
[16:10:59.757]                     NULL
[16:10:59.757]                     RNGkind("Mersenne-Twister")
[16:10:59.757]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:10:59.757]                       inherits = FALSE)
[16:10:59.757]                   }
[16:10:59.757]                   options(future.plan = NULL)
[16:10:59.757]                   if (is.na(NA_character_)) 
[16:10:59.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:10:59.757]                   future::plan(list(function (..., envir = parent.frame()) 
[16:10:59.757]                   {
[16:10:59.757]                     future <- SequentialFuture(..., envir = envir)
[16:10:59.757]                     if (!future$lazy) 
[16:10:59.757]                       future <- run(future)
[16:10:59.757]                     invisible(future)
[16:10:59.757]                   }), .cleanup = FALSE, .init = FALSE)
[16:10:59.757]                 }
[16:10:59.757]             }
[16:10:59.757]         }
[16:10:59.757]     })
[16:10:59.757]     if (TRUE) {
[16:10:59.757]         base::sink(type = "output", split = FALSE)
[16:10:59.757]         if (TRUE) {
[16:10:59.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:10:59.757]         }
[16:10:59.757]         else {
[16:10:59.757]             ...future.result["stdout"] <- base::list(NULL)
[16:10:59.757]         }
[16:10:59.757]         base::close(...future.stdout)
[16:10:59.757]         ...future.stdout <- NULL
[16:10:59.757]     }
[16:10:59.757]     ...future.result$conditions <- ...future.conditions
[16:10:59.757]     ...future.result$finished <- base::Sys.time()
[16:10:59.757]     ...future.result
[16:10:59.757] }
[16:10:59.759] assign_globals() ...
[16:10:59.759] List of 11
[16:10:59.759]  $ ...future.FUN            :function (x, ...)  
[16:10:59.759]  $ x_FUN                    :function (x)  
[16:10:59.759]  $ times                    : int 1
[16:10:59.759]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.759]  $ stop_if_not              :function (...)  
[16:10:59.759]  $ dim                      : NULL
[16:10:59.759]  $ valid_types              : chr "character"
[16:10:59.759]  $ future.call.arguments    : list()
[16:10:59.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.759]  $ ...future.elements_ii    :List of 2
[16:10:59.759]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:10:59.759]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[16:10:59.759]  $ ...future.seeds_ii       : NULL
[16:10:59.759]  $ ...future.globals.maxSize: NULL
[16:10:59.759]  - attr(*, "resolved")= logi FALSE
[16:10:59.759]  - attr(*, "total_size")= num 94208
[16:10:59.759]  - attr(*, "where")=List of 11
[16:10:59.759]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ times                    :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:10:59.759]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:10:59.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.759]  - attr(*, "already-done")= logi TRUE
[16:10:59.768] - copied ‘...future.FUN’ to environment
[16:10:59.768] - copied ‘x_FUN’ to environment
[16:10:59.768] - copied ‘times’ to environment
[16:10:59.768] - copied ‘stopf’ to environment
[16:10:59.768] - copied ‘stop_if_not’ to environment
[16:10:59.768] - copied ‘dim’ to environment
[16:10:59.768] - copied ‘valid_types’ to environment
[16:10:59.768] - copied ‘future.call.arguments’ to environment
[16:10:59.768] - copied ‘...future.elements_ii’ to environment
[16:10:59.769] - copied ‘...future.seeds_ii’ to environment
[16:10:59.769] - copied ‘...future.globals.maxSize’ to environment
[16:10:59.769] assign_globals() ... done
[16:10:59.769] plan(): Setting new future strategy stack:
[16:10:59.769] List of future strategies:
[16:10:59.769] 1. sequential:
[16:10:59.769]    - args: function (..., envir = parent.frame())
[16:10:59.769]    - tweaked: FALSE
[16:10:59.769]    - call: NULL
[16:10:59.770] plan(): nbrOfWorkers() = 1
[16:10:59.771] plan(): Setting new future strategy stack:
[16:10:59.771] List of future strategies:
[16:10:59.771] 1. sequential:
[16:10:59.771]    - args: function (..., envir = parent.frame())
[16:10:59.771]    - tweaked: FALSE
[16:10:59.771]    - call: plan(strategy)
[16:10:59.771] plan(): nbrOfWorkers() = 1
[16:10:59.771] SequentialFuture started (and completed)
[16:10:59.772] - Launch lazy future ... done
[16:10:59.772] run() for ‘SequentialFuture’ ... done
[16:10:59.772] Created future:
[16:10:59.772] SequentialFuture:
[16:10:59.772] Label: ‘future_vapply-1’
[16:10:59.772] Expression:
[16:10:59.772] {
[16:10:59.772]     do.call(function(...) {
[16:10:59.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.772]             on.exit(options(oopts), add = TRUE)
[16:10:59.772]         }
[16:10:59.772]         {
[16:10:59.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.772]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.772]             })
[16:10:59.772]         }
[16:10:59.772]     }, args = future.call.arguments)
[16:10:59.772] }
[16:10:59.772] Lazy evaluation: FALSE
[16:10:59.772] Asynchronous evaluation: FALSE
[16:10:59.772] Local evaluation: TRUE
[16:10:59.772] Environment: R_GlobalEnv
[16:10:59.772] Capture standard output: TRUE
[16:10:59.772] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:10:59.772] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:10:59.772] Packages: 1 packages (‘future.apply’)
[16:10:59.772] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:10:59.772] Resolved: TRUE
[16:10:59.772] Value: 232 bytes of class ‘list’
[16:10:59.772] Early signaling: FALSE
[16:10:59.772] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:10:59.772] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.774] Chunk #1 of 1 ... DONE
[16:10:59.774] Launching 1 futures (chunks) ... DONE
[16:10:59.774] Resolving 1 futures (chunks) ...
[16:10:59.774] resolve() on list ...
[16:10:59.774]  recursive: 0
[16:10:59.774]  length: 1
[16:10:59.774] 
[16:10:59.775] resolved() for ‘SequentialFuture’ ...
[16:10:59.775] - state: ‘finished’
[16:10:59.775] - run: TRUE
[16:10:59.775] - result: ‘FutureResult’
[16:10:59.775] resolved() for ‘SequentialFuture’ ... done
[16:10:59.775] Future #1
[16:10:59.775] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:10:59.776] - nx: 1
[16:10:59.776] - relay: TRUE
[16:10:59.776] - stdout: TRUE
[16:10:59.776] - signal: TRUE
[16:10:59.776] - resignal: FALSE
[16:10:59.776] - force: TRUE
[16:10:59.776] - relayed: [n=1] FALSE
[16:10:59.776] - queued futures: [n=1] FALSE
[16:10:59.776]  - until=1
[16:10:59.776]  - relaying element #1
[16:10:59.776] - relayed: [n=1] TRUE
[16:10:59.777] - queued futures: [n=1] TRUE
[16:10:59.777] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:10:59.777]  length: 0 (resolved future 1)
[16:10:59.777] Relaying remaining futures
[16:10:59.777] signalConditionsASAP(NULL, pos=0) ...
[16:10:59.777] - nx: 1
[16:10:59.777] - relay: TRUE
[16:10:59.777] - stdout: TRUE
[16:10:59.777] - signal: TRUE
[16:10:59.777] - resignal: FALSE
[16:10:59.778] - force: TRUE
[16:10:59.778] - relayed: [n=1] TRUE
[16:10:59.778] - queued futures: [n=1] TRUE
 - flush all
[16:10:59.778] - relayed: [n=1] TRUE
[16:10:59.778] - queued futures: [n=1] TRUE
[16:10:59.778] signalConditionsASAP(NULL, pos=0) ... done
[16:10:59.778] resolve() on list ... DONE
[16:10:59.778]  - Number of value chunks collected: 1
[16:10:59.778] Resolving 1 futures (chunks) ... DONE
[16:10:59.778] Reducing values from 1 chunks ...
[16:10:59.779]  - Number of values collected after concatenation: 2
[16:10:59.779]  - Number of values expected: 2
[16:10:59.779] Reducing values from 1 chunks ... DONE
[16:10:59.779] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:10:59.780] future_lapply() ...
[16:10:59.782] Number of chunks: 1
[16:10:59.782] getGlobalsAndPackagesXApply() ...
[16:10:59.782]  - future.globals: TRUE
[16:10:59.782] getGlobalsAndPackages() ...
[16:10:59.782] Searching for globals...
[16:10:59.785] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:10:59.785] Searching for globals ... DONE
[16:10:59.785] Resolving globals: FALSE
[16:10:59.786] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:10:59.787] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:10:59.787] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.787] - packages: [1] ‘future.apply’
[16:10:59.787] getGlobalsAndPackages() ... DONE
[16:10:59.787]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.787]  - needed namespaces: [n=1] ‘future.apply’
[16:10:59.787] Finding globals ... DONE
[16:10:59.787]  - use_args: TRUE
[16:10:59.787]  - Getting '...' globals ...
[16:10:59.788] resolve() on list ...
[16:10:59.788]  recursive: 0
[16:10:59.788]  length: 1
[16:10:59.788]  elements: ‘...’
[16:10:59.788]  length: 0 (resolved future 1)
[16:10:59.788] resolve() on list ... DONE
[16:10:59.788]    - '...' content: [n=0] 
[16:10:59.788] List of 1
[16:10:59.788]  $ ...: list()
[16:10:59.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.788]  - attr(*, "where")=List of 1
[16:10:59.788]   ..$ ...:<environment: 0x561e8a03e268> 
[16:10:59.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.788]  - attr(*, "resolved")= logi TRUE
[16:10:59.788]  - attr(*, "total_size")= num NA
[16:10:59.792]  - Getting '...' globals ... DONE
[16:10:59.792] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:10:59.792] List of 8
[16:10:59.792]  $ ...future.FUN:function (x, ...)  
[16:10:59.792]  $ x_FUN        :function (x)  
[16:10:59.792]  $ times        : int 0
[16:10:59.792]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.792]  $ stop_if_not  :function (...)  
[16:10:59.792]  $ dim          : NULL
[16:10:59.792]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:10:59.792]  $ ...          : list()
[16:10:59.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.792]  - attr(*, "where")=List of 8
[16:10:59.792]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:10:59.792]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:10:59.792]   ..$ times        :<environment: R_EmptyEnv> 
[16:10:59.792]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:10:59.792]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:10:59.792]   ..$ dim          :<environment: R_EmptyEnv> 
[16:10:59.792]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:10:59.792]   ..$ ...          :<environment: 0x561e8a03e268> 
[16:10:59.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.792]  - attr(*, "resolved")= logi FALSE
[16:10:59.792]  - attr(*, "total_size")= num 95472
[16:10:59.797] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:10:59.797] getGlobalsAndPackagesXApply() ... DONE
[16:10:59.798] Number of futures (= number of chunks): 1
[16:10:59.798] Launching 1 futures (chunks) ...
[16:10:59.798] Chunk #1 of 1 ...
[16:10:59.798]  - Finding globals in 'X' for chunk #1 ...
[16:10:59.798] getGlobalsAndPackages() ...
[16:10:59.798] Searching for globals...
[16:10:59.798] 
[16:10:59.798] Searching for globals ... DONE
[16:10:59.798] - globals: [0] <none>
[16:10:59.799] getGlobalsAndPackages() ... DONE
[16:10:59.799]    + additional globals found: [n=0] 
[16:10:59.799]    + additional namespaces needed: [n=0] 
[16:10:59.799]  - Finding globals in 'X' for chunk #1 ... DONE
[16:10:59.799]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[16:10:59.799]  - seeds: <none>
[16:10:59.799] getGlobalsAndPackages() ...
[16:10:59.799] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.799] Resolving globals: FALSE
[16:10:59.799] Tweak future expression to call with '...' arguments ...
[16:10:59.800] {
[16:10:59.800]     do.call(function(...) {
[16:10:59.800]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.800]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.800]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.800]             on.exit(options(oopts), add = TRUE)
[16:10:59.800]         }
[16:10:59.800]         {
[16:10:59.800]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.800]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.800]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.800]             })
[16:10:59.800]         }
[16:10:59.800]     }, args = future.call.arguments)
[16:10:59.800] }
[16:10:59.800] Tweak future expression to call with '...' arguments ... DONE
[16:10:59.800] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.800] - packages: [1] ‘future.apply’
[16:10:59.800] getGlobalsAndPackages() ... DONE
[16:10:59.801] run() for ‘Future’ ...
[16:10:59.801] - state: ‘created’
[16:10:59.801] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:10:59.801] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.801] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:10:59.801]   - Field: ‘label’
[16:10:59.801]   - Field: ‘local’
[16:10:59.802]   - Field: ‘owner’
[16:10:59.802]   - Field: ‘envir’
[16:10:59.802]   - Field: ‘packages’
[16:10:59.802]   - Field: ‘gc’
[16:10:59.802]   - Field: ‘conditions’
[16:10:59.802]   - Field: ‘expr’
[16:10:59.802]   - Field: ‘uuid’
[16:10:59.802]   - Field: ‘seed’
[16:10:59.802]   - Field: ‘version’
[16:10:59.802]   - Field: ‘result’
[16:10:59.802]   - Field: ‘asynchronous’
[16:10:59.803]   - Field: ‘calls’
[16:10:59.803]   - Field: ‘globals’
[16:10:59.803]   - Field: ‘stdout’
[16:10:59.803]   - Field: ‘earlySignal’
[16:10:59.803]   - Field: ‘lazy’
[16:10:59.803]   - Field: ‘state’
[16:10:59.803] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:10:59.803] - Launch lazy future ...
[16:10:59.803] Packages needed by the future expression (n = 1): ‘future.apply’
[16:10:59.803] Packages needed by future strategies (n = 0): <none>
[16:10:59.804] {
[16:10:59.804]     {
[16:10:59.804]         {
[16:10:59.804]             ...future.startTime <- base::Sys.time()
[16:10:59.804]             {
[16:10:59.804]                 {
[16:10:59.804]                   {
[16:10:59.804]                     {
[16:10:59.804]                       base::local({
[16:10:59.804]                         has_future <- base::requireNamespace("future", 
[16:10:59.804]                           quietly = TRUE)
[16:10:59.804]                         if (has_future) {
[16:10:59.804]                           ns <- base::getNamespace("future")
[16:10:59.804]                           version <- ns[[".package"]][["version"]]
[16:10:59.804]                           if (is.null(version)) 
[16:10:59.804]                             version <- utils::packageVersion("future")
[16:10:59.804]                         }
[16:10:59.804]                         else {
[16:10:59.804]                           version <- NULL
[16:10:59.804]                         }
[16:10:59.804]                         if (!has_future || version < "1.8.0") {
[16:10:59.804]                           info <- base::c(r_version = base::gsub("R version ", 
[16:10:59.804]                             "", base::R.version$version.string), 
[16:10:59.804]                             platform = base::sprintf("%s (%s-bit)", 
[16:10:59.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:10:59.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:10:59.804]                               "release", "version")], collapse = " "), 
[16:10:59.804]                             hostname = base::Sys.info()[["nodename"]])
[16:10:59.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:10:59.804]                             info)
[16:10:59.804]                           info <- base::paste(info, collapse = "; ")
[16:10:59.804]                           if (!has_future) {
[16:10:59.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:10:59.804]                               info)
[16:10:59.804]                           }
[16:10:59.804]                           else {
[16:10:59.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:10:59.804]                               info, version)
[16:10:59.804]                           }
[16:10:59.804]                           base::stop(msg)
[16:10:59.804]                         }
[16:10:59.804]                       })
[16:10:59.804]                     }
[16:10:59.804]                     base::local({
[16:10:59.804]                       for (pkg in "future.apply") {
[16:10:59.804]                         base::loadNamespace(pkg)
[16:10:59.804]                         base::library(pkg, character.only = TRUE)
[16:10:59.804]                       }
[16:10:59.804]                     })
[16:10:59.804]                   }
[16:10:59.804]                   options(future.plan = NULL)
[16:10:59.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:10:59.804]                 }
[16:10:59.804]                 ...future.workdir <- getwd()
[16:10:59.804]             }
[16:10:59.804]             ...future.oldOptions <- base::as.list(base::.Options)
[16:10:59.804]             ...future.oldEnvVars <- base::Sys.getenv()
[16:10:59.804]         }
[16:10:59.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:10:59.804]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[16:10:59.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:10:59.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:10:59.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:10:59.804]             future.stdout.windows.reencode = NULL, width = 80L)
[16:10:59.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:10:59.804]             base::names(...future.oldOptions))
[16:10:59.804]     }
[16:10:59.804]     if (FALSE) {
[16:10:59.804]     }
[16:10:59.804]     else {
[16:10:59.804]         if (TRUE) {
[16:10:59.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:10:59.804]                 open = "w")
[16:10:59.804]         }
[16:10:59.804]         else {
[16:10:59.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:10:59.804]                 windows = "NUL", "/dev/null"), open = "w")
[16:10:59.804]         }
[16:10:59.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:10:59.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:10:59.804]             base::sink(type = "output", split = FALSE)
[16:10:59.804]             base::close(...future.stdout)
[16:10:59.804]         }, add = TRUE)
[16:10:59.804]     }
[16:10:59.804]     ...future.frame <- base::sys.nframe()
[16:10:59.804]     ...future.conditions <- base::list()
[16:10:59.804]     ...future.rng <- base::globalenv()$.Random.seed
[16:10:59.804]     if (FALSE) {
[16:10:59.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:10:59.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:10:59.804]     }
[16:10:59.804]     ...future.result <- base::tryCatch({
[16:10:59.804]         base::withCallingHandlers({
[16:10:59.804]             ...future.value <- base::withVisible(base::local({
[16:10:59.804]                 do.call(function(...) {
[16:10:59.804]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.804]                   if (!identical(...future.globals.maxSize.org, 
[16:10:59.804]                     ...future.globals.maxSize)) {
[16:10:59.804]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.804]                     on.exit(options(oopts), add = TRUE)
[16:10:59.804]                   }
[16:10:59.804]                   {
[16:10:59.804]                     lapply(seq_along(...future.elements_ii), 
[16:10:59.804]                       FUN = function(jj) {
[16:10:59.804]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.804]                         ...future.FUN(...future.X_jj, ...)
[16:10:59.804]                       })
[16:10:59.804]                   }
[16:10:59.804]                 }, args = future.call.arguments)
[16:10:59.804]             }))
[16:10:59.804]             future::FutureResult(value = ...future.value$value, 
[16:10:59.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.804]                   ...future.rng), globalenv = if (FALSE) 
[16:10:59.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:10:59.804]                     ...future.globalenv.names))
[16:10:59.804]                 else NULL, started = ...future.startTime, version = "1.8")
[16:10:59.804]         }, condition = base::local({
[16:10:59.804]             c <- base::c
[16:10:59.804]             inherits <- base::inherits
[16:10:59.804]             invokeRestart <- base::invokeRestart
[16:10:59.804]             length <- base::length
[16:10:59.804]             list <- base::list
[16:10:59.804]             seq.int <- base::seq.int
[16:10:59.804]             signalCondition <- base::signalCondition
[16:10:59.804]             sys.calls <- base::sys.calls
[16:10:59.804]             `[[` <- base::`[[`
[16:10:59.804]             `+` <- base::`+`
[16:10:59.804]             `<<-` <- base::`<<-`
[16:10:59.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:10:59.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:10:59.804]                   3L)]
[16:10:59.804]             }
[16:10:59.804]             function(cond) {
[16:10:59.804]                 is_error <- inherits(cond, "error")
[16:10:59.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:10:59.804]                   NULL)
[16:10:59.804]                 if (is_error) {
[16:10:59.804]                   sessionInformation <- function() {
[16:10:59.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:10:59.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:10:59.804]                       search = base::search(), system = base::Sys.info())
[16:10:59.804]                   }
[16:10:59.804]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:10:59.804]                     cond$call), session = sessionInformation(), 
[16:10:59.804]                     timestamp = base::Sys.time(), signaled = 0L)
[16:10:59.804]                   signalCondition(cond)
[16:10:59.804]                 }
[16:10:59.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:10:59.804]                 "immediateCondition"))) {
[16:10:59.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:10:59.804]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:10:59.804]                   if (TRUE && !signal) {
[16:10:59.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.804]                     {
[16:10:59.804]                       inherits <- base::inherits
[16:10:59.804]                       invokeRestart <- base::invokeRestart
[16:10:59.804]                       is.null <- base::is.null
[16:10:59.804]                       muffled <- FALSE
[16:10:59.804]                       if (inherits(cond, "message")) {
[16:10:59.804]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.804]                         if (muffled) 
[16:10:59.804]                           invokeRestart("muffleMessage")
[16:10:59.804]                       }
[16:10:59.804]                       else if (inherits(cond, "warning")) {
[16:10:59.804]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.804]                         if (muffled) 
[16:10:59.804]                           invokeRestart("muffleWarning")
[16:10:59.804]                       }
[16:10:59.804]                       else if (inherits(cond, "condition")) {
[16:10:59.804]                         if (!is.null(pattern)) {
[16:10:59.804]                           computeRestarts <- base::computeRestarts
[16:10:59.804]                           grepl <- base::grepl
[16:10:59.804]                           restarts <- computeRestarts(cond)
[16:10:59.804]                           for (restart in restarts) {
[16:10:59.804]                             name <- restart$name
[16:10:59.804]                             if (is.null(name)) 
[16:10:59.804]                               next
[16:10:59.804]                             if (!grepl(pattern, name)) 
[16:10:59.804]                               next
[16:10:59.804]                             invokeRestart(restart)
[16:10:59.804]                             muffled <- TRUE
[16:10:59.804]                             break
[16:10:59.804]                           }
[16:10:59.804]                         }
[16:10:59.804]                       }
[16:10:59.804]                       invisible(muffled)
[16:10:59.804]                     }
[16:10:59.804]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.804]                   }
[16:10:59.804]                 }
[16:10:59.804]                 else {
[16:10:59.804]                   if (TRUE) {
[16:10:59.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.804]                     {
[16:10:59.804]                       inherits <- base::inherits
[16:10:59.804]                       invokeRestart <- base::invokeRestart
[16:10:59.804]                       is.null <- base::is.null
[16:10:59.804]                       muffled <- FALSE
[16:10:59.804]                       if (inherits(cond, "message")) {
[16:10:59.804]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.804]                         if (muffled) 
[16:10:59.804]                           invokeRestart("muffleMessage")
[16:10:59.804]                       }
[16:10:59.804]                       else if (inherits(cond, "warning")) {
[16:10:59.804]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.804]                         if (muffled) 
[16:10:59.804]                           invokeRestart("muffleWarning")
[16:10:59.804]                       }
[16:10:59.804]                       else if (inherits(cond, "condition")) {
[16:10:59.804]                         if (!is.null(pattern)) {
[16:10:59.804]                           computeRestarts <- base::computeRestarts
[16:10:59.804]                           grepl <- base::grepl
[16:10:59.804]                           restarts <- computeRestarts(cond)
[16:10:59.804]                           for (restart in restarts) {
[16:10:59.804]                             name <- restart$name
[16:10:59.804]                             if (is.null(name)) 
[16:10:59.804]                               next
[16:10:59.804]                             if (!grepl(pattern, name)) 
[16:10:59.804]                               next
[16:10:59.804]                             invokeRestart(restart)
[16:10:59.804]                             muffled <- TRUE
[16:10:59.804]                             break
[16:10:59.804]                           }
[16:10:59.804]                         }
[16:10:59.804]                       }
[16:10:59.804]                       invisible(muffled)
[16:10:59.804]                     }
[16:10:59.804]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.804]                   }
[16:10:59.804]                 }
[16:10:59.804]             }
[16:10:59.804]         }))
[16:10:59.804]     }, error = function(ex) {
[16:10:59.804]         base::structure(base::list(value = NULL, visible = NULL, 
[16:10:59.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.804]                 ...future.rng), started = ...future.startTime, 
[16:10:59.804]             finished = Sys.time(), session_uuid = NA_character_, 
[16:10:59.804]             version = "1.8"), class = "FutureResult")
[16:10:59.804]     }, finally = {
[16:10:59.804]         if (!identical(...future.workdir, getwd())) 
[16:10:59.804]             setwd(...future.workdir)
[16:10:59.804]         {
[16:10:59.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:10:59.804]                 ...future.oldOptions$nwarnings <- NULL
[16:10:59.804]             }
[16:10:59.804]             base::options(...future.oldOptions)
[16:10:59.804]             if (.Platform$OS.type == "windows") {
[16:10:59.804]                 old_names <- names(...future.oldEnvVars)
[16:10:59.804]                 envs <- base::Sys.getenv()
[16:10:59.804]                 names <- names(envs)
[16:10:59.804]                 common <- intersect(names, old_names)
[16:10:59.804]                 added <- setdiff(names, old_names)
[16:10:59.804]                 removed <- setdiff(old_names, names)
[16:10:59.804]                 changed <- common[...future.oldEnvVars[common] != 
[16:10:59.804]                   envs[common]]
[16:10:59.804]                 NAMES <- toupper(changed)
[16:10:59.804]                 args <- list()
[16:10:59.804]                 for (kk in seq_along(NAMES)) {
[16:10:59.804]                   name <- changed[[kk]]
[16:10:59.804]                   NAME <- NAMES[[kk]]
[16:10:59.804]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.804]                     next
[16:10:59.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.804]                 }
[16:10:59.804]                 NAMES <- toupper(added)
[16:10:59.804]                 for (kk in seq_along(NAMES)) {
[16:10:59.804]                   name <- added[[kk]]
[16:10:59.804]                   NAME <- NAMES[[kk]]
[16:10:59.804]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.804]                     next
[16:10:59.804]                   args[[name]] <- ""
[16:10:59.804]                 }
[16:10:59.804]                 NAMES <- toupper(removed)
[16:10:59.804]                 for (kk in seq_along(NAMES)) {
[16:10:59.804]                   name <- removed[[kk]]
[16:10:59.804]                   NAME <- NAMES[[kk]]
[16:10:59.804]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.804]                     next
[16:10:59.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.804]                 }
[16:10:59.804]                 if (length(args) > 0) 
[16:10:59.804]                   base::do.call(base::Sys.setenv, args = args)
[16:10:59.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:10:59.804]             }
[16:10:59.804]             else {
[16:10:59.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:10:59.804]             }
[16:10:59.804]             {
[16:10:59.804]                 if (base::length(...future.futureOptionsAdded) > 
[16:10:59.804]                   0L) {
[16:10:59.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:10:59.804]                   base::names(opts) <- ...future.futureOptionsAdded
[16:10:59.804]                   base::options(opts)
[16:10:59.804]                 }
[16:10:59.804]                 {
[16:10:59.804]                   {
[16:10:59.804]                     NULL
[16:10:59.804]                     RNGkind("Mersenne-Twister")
[16:10:59.804]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:10:59.804]                       inherits = FALSE)
[16:10:59.804]                   }
[16:10:59.804]                   options(future.plan = NULL)
[16:10:59.804]                   if (is.na(NA_character_)) 
[16:10:59.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:10:59.804]                   future::plan(list(function (..., envir = parent.frame()) 
[16:10:59.804]                   {
[16:10:59.804]                     future <- SequentialFuture(..., envir = envir)
[16:10:59.804]                     if (!future$lazy) 
[16:10:59.804]                       future <- run(future)
[16:10:59.804]                     invisible(future)
[16:10:59.804]                   }), .cleanup = FALSE, .init = FALSE)
[16:10:59.804]                 }
[16:10:59.804]             }
[16:10:59.804]         }
[16:10:59.804]     })
[16:10:59.804]     if (TRUE) {
[16:10:59.804]         base::sink(type = "output", split = FALSE)
[16:10:59.804]         if (TRUE) {
[16:10:59.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:10:59.804]         }
[16:10:59.804]         else {
[16:10:59.804]             ...future.result["stdout"] <- base::list(NULL)
[16:10:59.804]         }
[16:10:59.804]         base::close(...future.stdout)
[16:10:59.804]         ...future.stdout <- NULL
[16:10:59.804]     }
[16:10:59.804]     ...future.result$conditions <- ...future.conditions
[16:10:59.804]     ...future.result$finished <- base::Sys.time()
[16:10:59.804]     ...future.result
[16:10:59.804] }
[16:10:59.806] assign_globals() ...
[16:10:59.806] List of 11
[16:10:59.806]  $ ...future.FUN            :function (x, ...)  
[16:10:59.806]  $ x_FUN                    :function (x)  
[16:10:59.806]  $ times                    : int 0
[16:10:59.806]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.806]  $ stop_if_not              :function (...)  
[16:10:59.806]  $ dim                      : NULL
[16:10:59.806]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:10:59.806]  $ future.call.arguments    : list()
[16:10:59.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.806]  $ ...future.elements_ii    :List of 10
[16:10:59.806]   ..$ : int 1
[16:10:59.806]   ..$ : int 2
[16:10:59.806]   ..$ : int 3
[16:10:59.806]   ..$ : int 4
[16:10:59.806]   ..$ : int 5
[16:10:59.806]   ..$ : int 6
[16:10:59.806]   ..$ : int 7
[16:10:59.806]   ..$ : int 8
[16:10:59.806]   ..$ : int 9
[16:10:59.806]   ..$ : int 10
[16:10:59.806]  $ ...future.seeds_ii       : NULL
[16:10:59.806]  $ ...future.globals.maxSize: NULL
[16:10:59.806]  - attr(*, "resolved")= logi FALSE
[16:10:59.806]  - attr(*, "total_size")= num 95472
[16:10:59.806]  - attr(*, "where")=List of 11
[16:10:59.806]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ times                    :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:10:59.806]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:10:59.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.806]  - attr(*, "already-done")= logi TRUE
[16:10:59.817] - copied ‘...future.FUN’ to environment
[16:10:59.817] - reassign environment for ‘x_FUN’
[16:10:59.817] - copied ‘x_FUN’ to environment
[16:10:59.817] - copied ‘times’ to environment
[16:10:59.817] - copied ‘stopf’ to environment
[16:10:59.817] - copied ‘stop_if_not’ to environment
[16:10:59.817] - copied ‘dim’ to environment
[16:10:59.818] - copied ‘valid_types’ to environment
[16:10:59.818] - copied ‘future.call.arguments’ to environment
[16:10:59.818] - copied ‘...future.elements_ii’ to environment
[16:10:59.818] - copied ‘...future.seeds_ii’ to environment
[16:10:59.818] - copied ‘...future.globals.maxSize’ to environment
[16:10:59.818] assign_globals() ... done
[16:10:59.818] plan(): Setting new future strategy stack:
[16:10:59.818] List of future strategies:
[16:10:59.818] 1. sequential:
[16:10:59.818]    - args: function (..., envir = parent.frame())
[16:10:59.818]    - tweaked: FALSE
[16:10:59.818]    - call: NULL
[16:10:59.819] plan(): nbrOfWorkers() = 1
[16:10:59.820] plan(): Setting new future strategy stack:
[16:10:59.820] List of future strategies:
[16:10:59.820] 1. sequential:
[16:10:59.820]    - args: function (..., envir = parent.frame())
[16:10:59.820]    - tweaked: FALSE
[16:10:59.820]    - call: plan(strategy)
[16:10:59.820] plan(): nbrOfWorkers() = 1
[16:10:59.820] SequentialFuture started (and completed)
[16:10:59.820] - Launch lazy future ... done
[16:10:59.821] run() for ‘SequentialFuture’ ... done
[16:10:59.821] Created future:
[16:10:59.821] SequentialFuture:
[16:10:59.821] Label: ‘future_vapply-1’
[16:10:59.821] Expression:
[16:10:59.821] {
[16:10:59.821]     do.call(function(...) {
[16:10:59.821]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.821]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.821]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.821]             on.exit(options(oopts), add = TRUE)
[16:10:59.821]         }
[16:10:59.821]         {
[16:10:59.821]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.821]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.821]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.821]             })
[16:10:59.821]         }
[16:10:59.821]     }, args = future.call.arguments)
[16:10:59.821] }
[16:10:59.821] Lazy evaluation: FALSE
[16:10:59.821] Asynchronous evaluation: FALSE
[16:10:59.821] Local evaluation: TRUE
[16:10:59.821] Environment: R_GlobalEnv
[16:10:59.821] Capture standard output: TRUE
[16:10:59.821] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:10:59.821] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:10:59.821] Packages: 1 packages (‘future.apply’)
[16:10:59.821] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:10:59.821] Resolved: TRUE
[16:10:59.821] Value: 480 bytes of class ‘list’
[16:10:59.821] Early signaling: FALSE
[16:10:59.821] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:10:59.821] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.822] Chunk #1 of 1 ... DONE
[16:10:59.822] Launching 1 futures (chunks) ... DONE
[16:10:59.822] Resolving 1 futures (chunks) ...
[16:10:59.822] resolve() on list ...
[16:10:59.822]  recursive: 0
[16:10:59.822]  length: 1
[16:10:59.822] 
[16:10:59.823] resolved() for ‘SequentialFuture’ ...
[16:10:59.823] - state: ‘finished’
[16:10:59.823] - run: TRUE
[16:10:59.823] - result: ‘FutureResult’
[16:10:59.823] resolved() for ‘SequentialFuture’ ... done
[16:10:59.823] Future #1
[16:10:59.823] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:10:59.823] - nx: 1
[16:10:59.823] - relay: TRUE
[16:10:59.823] - stdout: TRUE
[16:10:59.824] - signal: TRUE
[16:10:59.824] - resignal: FALSE
[16:10:59.824] - force: TRUE
[16:10:59.824] - relayed: [n=1] FALSE
[16:10:59.824] - queued futures: [n=1] FALSE
[16:10:59.824]  - until=1
[16:10:59.824]  - relaying element #1
[16:10:59.824] - relayed: [n=1] TRUE
[16:10:59.824] - queued futures: [n=1] TRUE
[16:10:59.824] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:10:59.825]  length: 0 (resolved future 1)
[16:10:59.825] Relaying remaining futures
[16:10:59.825] signalConditionsASAP(NULL, pos=0) ...
[16:10:59.825] - nx: 1
[16:10:59.825] - relay: TRUE
[16:10:59.825] - stdout: TRUE
[16:10:59.825] - signal: TRUE
[16:10:59.825] - resignal: FALSE
[16:10:59.825] - force: TRUE
[16:10:59.825] - relayed: [n=1] TRUE
[16:10:59.825] - queued futures: [n=1] TRUE
 - flush all
[16:10:59.826] - relayed: [n=1] TRUE
[16:10:59.826] - queued futures: [n=1] TRUE
[16:10:59.826] signalConditionsASAP(NULL, pos=0) ... done
[16:10:59.826] resolve() on list ... DONE
[16:10:59.826]  - Number of value chunks collected: 1
[16:10:59.826] Resolving 1 futures (chunks) ... DONE
[16:10:59.826] Reducing values from 1 chunks ...
[16:10:59.826]  - Number of values collected after concatenation: 10
[16:10:59.826]  - Number of values expected: 10
[16:10:59.826] Reducing values from 1 chunks ... DONE
[16:10:59.826] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:10:59.827] future_lapply() ...
[16:10:59.829] Number of chunks: 1
[16:10:59.829] getGlobalsAndPackagesXApply() ...
[16:10:59.829]  - future.globals: TRUE
[16:10:59.829] getGlobalsAndPackages() ...
[16:10:59.829] Searching for globals...
[16:10:59.833] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:10:59.834] Searching for globals ... DONE
[16:10:59.834] Resolving globals: FALSE
[16:10:59.835] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:10:59.836] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:10:59.836] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.836] - packages: [1] ‘future.apply’
[16:10:59.836] getGlobalsAndPackages() ... DONE
[16:10:59.836]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.836]  - needed namespaces: [n=1] ‘future.apply’
[16:10:59.836] Finding globals ... DONE
[16:10:59.836]  - use_args: TRUE
[16:10:59.836]  - Getting '...' globals ...
[16:10:59.837] resolve() on list ...
[16:10:59.837]  recursive: 0
[16:10:59.837]  length: 1
[16:10:59.837]  elements: ‘...’
[16:10:59.837]  length: 0 (resolved future 1)
[16:10:59.837] resolve() on list ... DONE
[16:10:59.837]    - '...' content: [n=0] 
[16:10:59.837] List of 1
[16:10:59.837]  $ ...: list()
[16:10:59.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.837]  - attr(*, "where")=List of 1
[16:10:59.837]   ..$ ...:<environment: 0x561e8a41b2d0> 
[16:10:59.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.837]  - attr(*, "resolved")= logi TRUE
[16:10:59.837]  - attr(*, "total_size")= num NA
[16:10:59.840]  - Getting '...' globals ... DONE
[16:10:59.840] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:10:59.840] List of 8
[16:10:59.840]  $ ...future.FUN:function (x, ...)  
[16:10:59.840]  $ x_FUN        :function (x)  
[16:10:59.840]  $ times        : int 0
[16:10:59.840]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.840]  $ stop_if_not  :function (...)  
[16:10:59.840]  $ dim          : NULL
[16:10:59.840]  $ valid_types  : chr [1:2] "logical" "integer"
[16:10:59.840]  $ ...          : list()
[16:10:59.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.840]  - attr(*, "where")=List of 8
[16:10:59.840]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:10:59.840]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:10:59.840]   ..$ times        :<environment: R_EmptyEnv> 
[16:10:59.840]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:10:59.840]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:10:59.840]   ..$ dim          :<environment: R_EmptyEnv> 
[16:10:59.840]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:10:59.840]   ..$ ...          :<environment: 0x561e8a41b2d0> 
[16:10:59.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.840]  - attr(*, "resolved")= logi FALSE
[16:10:59.840]  - attr(*, "total_size")= num 95400
[16:10:59.845] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:10:59.845] getGlobalsAndPackagesXApply() ... DONE
[16:10:59.846] Number of futures (= number of chunks): 1
[16:10:59.846] Launching 1 futures (chunks) ...
[16:10:59.846] Chunk #1 of 1 ...
[16:10:59.846]  - Finding globals in 'X' for chunk #1 ...
[16:10:59.846] getGlobalsAndPackages() ...
[16:10:59.846] Searching for globals...
[16:10:59.846] 
[16:10:59.846] Searching for globals ... DONE
[16:10:59.847] - globals: [0] <none>
[16:10:59.847] getGlobalsAndPackages() ... DONE
[16:10:59.847]    + additional globals found: [n=0] 
[16:10:59.847]    + additional namespaces needed: [n=0] 
[16:10:59.847]  - Finding globals in 'X' for chunk #1 ... DONE
[16:10:59.847]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[16:10:59.847]  - seeds: <none>
[16:10:59.847] getGlobalsAndPackages() ...
[16:10:59.847] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.847] Resolving globals: FALSE
[16:10:59.848] Tweak future expression to call with '...' arguments ...
[16:10:59.848] {
[16:10:59.848]     do.call(function(...) {
[16:10:59.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.848]             on.exit(options(oopts), add = TRUE)
[16:10:59.848]         }
[16:10:59.848]         {
[16:10:59.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.848]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.848]             })
[16:10:59.848]         }
[16:10:59.848]     }, args = future.call.arguments)
[16:10:59.848] }
[16:10:59.848] Tweak future expression to call with '...' arguments ... DONE
[16:10:59.848] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.849] - packages: [1] ‘future.apply’
[16:10:59.849] getGlobalsAndPackages() ... DONE
[16:10:59.849] run() for ‘Future’ ...
[16:10:59.849] - state: ‘created’
[16:10:59.849] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:10:59.849] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:10:59.850]   - Field: ‘label’
[16:10:59.850]   - Field: ‘local’
[16:10:59.850]   - Field: ‘owner’
[16:10:59.850]   - Field: ‘envir’
[16:10:59.850]   - Field: ‘packages’
[16:10:59.850]   - Field: ‘gc’
[16:10:59.850]   - Field: ‘conditions’
[16:10:59.850]   - Field: ‘expr’
[16:10:59.850]   - Field: ‘uuid’
[16:10:59.850]   - Field: ‘seed’
[16:10:59.851]   - Field: ‘version’
[16:10:59.851]   - Field: ‘result’
[16:10:59.851]   - Field: ‘asynchronous’
[16:10:59.851]   - Field: ‘calls’
[16:10:59.851]   - Field: ‘globals’
[16:10:59.851]   - Field: ‘stdout’
[16:10:59.851]   - Field: ‘earlySignal’
[16:10:59.851]   - Field: ‘lazy’
[16:10:59.851]   - Field: ‘state’
[16:10:59.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:10:59.851] - Launch lazy future ...
[16:10:59.852] Packages needed by the future expression (n = 1): ‘future.apply’
[16:10:59.852] Packages needed by future strategies (n = 0): <none>
[16:10:59.852] {
[16:10:59.852]     {
[16:10:59.852]         {
[16:10:59.852]             ...future.startTime <- base::Sys.time()
[16:10:59.852]             {
[16:10:59.852]                 {
[16:10:59.852]                   {
[16:10:59.852]                     {
[16:10:59.852]                       base::local({
[16:10:59.852]                         has_future <- base::requireNamespace("future", 
[16:10:59.852]                           quietly = TRUE)
[16:10:59.852]                         if (has_future) {
[16:10:59.852]                           ns <- base::getNamespace("future")
[16:10:59.852]                           version <- ns[[".package"]][["version"]]
[16:10:59.852]                           if (is.null(version)) 
[16:10:59.852]                             version <- utils::packageVersion("future")
[16:10:59.852]                         }
[16:10:59.852]                         else {
[16:10:59.852]                           version <- NULL
[16:10:59.852]                         }
[16:10:59.852]                         if (!has_future || version < "1.8.0") {
[16:10:59.852]                           info <- base::c(r_version = base::gsub("R version ", 
[16:10:59.852]                             "", base::R.version$version.string), 
[16:10:59.852]                             platform = base::sprintf("%s (%s-bit)", 
[16:10:59.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:10:59.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:10:59.852]                               "release", "version")], collapse = " "), 
[16:10:59.852]                             hostname = base::Sys.info()[["nodename"]])
[16:10:59.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:10:59.852]                             info)
[16:10:59.852]                           info <- base::paste(info, collapse = "; ")
[16:10:59.852]                           if (!has_future) {
[16:10:59.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:10:59.852]                               info)
[16:10:59.852]                           }
[16:10:59.852]                           else {
[16:10:59.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:10:59.852]                               info, version)
[16:10:59.852]                           }
[16:10:59.852]                           base::stop(msg)
[16:10:59.852]                         }
[16:10:59.852]                       })
[16:10:59.852]                     }
[16:10:59.852]                     base::local({
[16:10:59.852]                       for (pkg in "future.apply") {
[16:10:59.852]                         base::loadNamespace(pkg)
[16:10:59.852]                         base::library(pkg, character.only = TRUE)
[16:10:59.852]                       }
[16:10:59.852]                     })
[16:10:59.852]                   }
[16:10:59.852]                   options(future.plan = NULL)
[16:10:59.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:10:59.852]                 }
[16:10:59.852]                 ...future.workdir <- getwd()
[16:10:59.852]             }
[16:10:59.852]             ...future.oldOptions <- base::as.list(base::.Options)
[16:10:59.852]             ...future.oldEnvVars <- base::Sys.getenv()
[16:10:59.852]         }
[16:10:59.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:10:59.852]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[16:10:59.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:10:59.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:10:59.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:10:59.852]             future.stdout.windows.reencode = NULL, width = 80L)
[16:10:59.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:10:59.852]             base::names(...future.oldOptions))
[16:10:59.852]     }
[16:10:59.852]     if (FALSE) {
[16:10:59.852]     }
[16:10:59.852]     else {
[16:10:59.852]         if (TRUE) {
[16:10:59.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:10:59.852]                 open = "w")
[16:10:59.852]         }
[16:10:59.852]         else {
[16:10:59.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:10:59.852]                 windows = "NUL", "/dev/null"), open = "w")
[16:10:59.852]         }
[16:10:59.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:10:59.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:10:59.852]             base::sink(type = "output", split = FALSE)
[16:10:59.852]             base::close(...future.stdout)
[16:10:59.852]         }, add = TRUE)
[16:10:59.852]     }
[16:10:59.852]     ...future.frame <- base::sys.nframe()
[16:10:59.852]     ...future.conditions <- base::list()
[16:10:59.852]     ...future.rng <- base::globalenv()$.Random.seed
[16:10:59.852]     if (FALSE) {
[16:10:59.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:10:59.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:10:59.852]     }
[16:10:59.852]     ...future.result <- base::tryCatch({
[16:10:59.852]         base::withCallingHandlers({
[16:10:59.852]             ...future.value <- base::withVisible(base::local({
[16:10:59.852]                 do.call(function(...) {
[16:10:59.852]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.852]                   if (!identical(...future.globals.maxSize.org, 
[16:10:59.852]                     ...future.globals.maxSize)) {
[16:10:59.852]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.852]                     on.exit(options(oopts), add = TRUE)
[16:10:59.852]                   }
[16:10:59.852]                   {
[16:10:59.852]                     lapply(seq_along(...future.elements_ii), 
[16:10:59.852]                       FUN = function(jj) {
[16:10:59.852]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.852]                         ...future.FUN(...future.X_jj, ...)
[16:10:59.852]                       })
[16:10:59.852]                   }
[16:10:59.852]                 }, args = future.call.arguments)
[16:10:59.852]             }))
[16:10:59.852]             future::FutureResult(value = ...future.value$value, 
[16:10:59.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.852]                   ...future.rng), globalenv = if (FALSE) 
[16:10:59.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:10:59.852]                     ...future.globalenv.names))
[16:10:59.852]                 else NULL, started = ...future.startTime, version = "1.8")
[16:10:59.852]         }, condition = base::local({
[16:10:59.852]             c <- base::c
[16:10:59.852]             inherits <- base::inherits
[16:10:59.852]             invokeRestart <- base::invokeRestart
[16:10:59.852]             length <- base::length
[16:10:59.852]             list <- base::list
[16:10:59.852]             seq.int <- base::seq.int
[16:10:59.852]             signalCondition <- base::signalCondition
[16:10:59.852]             sys.calls <- base::sys.calls
[16:10:59.852]             `[[` <- base::`[[`
[16:10:59.852]             `+` <- base::`+`
[16:10:59.852]             `<<-` <- base::`<<-`
[16:10:59.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:10:59.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:10:59.852]                   3L)]
[16:10:59.852]             }
[16:10:59.852]             function(cond) {
[16:10:59.852]                 is_error <- inherits(cond, "error")
[16:10:59.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:10:59.852]                   NULL)
[16:10:59.852]                 if (is_error) {
[16:10:59.852]                   sessionInformation <- function() {
[16:10:59.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:10:59.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:10:59.852]                       search = base::search(), system = base::Sys.info())
[16:10:59.852]                   }
[16:10:59.852]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:10:59.852]                     cond$call), session = sessionInformation(), 
[16:10:59.852]                     timestamp = base::Sys.time(), signaled = 0L)
[16:10:59.852]                   signalCondition(cond)
[16:10:59.852]                 }
[16:10:59.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:10:59.852]                 "immediateCondition"))) {
[16:10:59.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:10:59.852]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:10:59.852]                   if (TRUE && !signal) {
[16:10:59.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.852]                     {
[16:10:59.852]                       inherits <- base::inherits
[16:10:59.852]                       invokeRestart <- base::invokeRestart
[16:10:59.852]                       is.null <- base::is.null
[16:10:59.852]                       muffled <- FALSE
[16:10:59.852]                       if (inherits(cond, "message")) {
[16:10:59.852]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.852]                         if (muffled) 
[16:10:59.852]                           invokeRestart("muffleMessage")
[16:10:59.852]                       }
[16:10:59.852]                       else if (inherits(cond, "warning")) {
[16:10:59.852]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.852]                         if (muffled) 
[16:10:59.852]                           invokeRestart("muffleWarning")
[16:10:59.852]                       }
[16:10:59.852]                       else if (inherits(cond, "condition")) {
[16:10:59.852]                         if (!is.null(pattern)) {
[16:10:59.852]                           computeRestarts <- base::computeRestarts
[16:10:59.852]                           grepl <- base::grepl
[16:10:59.852]                           restarts <- computeRestarts(cond)
[16:10:59.852]                           for (restart in restarts) {
[16:10:59.852]                             name <- restart$name
[16:10:59.852]                             if (is.null(name)) 
[16:10:59.852]                               next
[16:10:59.852]                             if (!grepl(pattern, name)) 
[16:10:59.852]                               next
[16:10:59.852]                             invokeRestart(restart)
[16:10:59.852]                             muffled <- TRUE
[16:10:59.852]                             break
[16:10:59.852]                           }
[16:10:59.852]                         }
[16:10:59.852]                       }
[16:10:59.852]                       invisible(muffled)
[16:10:59.852]                     }
[16:10:59.852]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.852]                   }
[16:10:59.852]                 }
[16:10:59.852]                 else {
[16:10:59.852]                   if (TRUE) {
[16:10:59.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.852]                     {
[16:10:59.852]                       inherits <- base::inherits
[16:10:59.852]                       invokeRestart <- base::invokeRestart
[16:10:59.852]                       is.null <- base::is.null
[16:10:59.852]                       muffled <- FALSE
[16:10:59.852]                       if (inherits(cond, "message")) {
[16:10:59.852]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.852]                         if (muffled) 
[16:10:59.852]                           invokeRestart("muffleMessage")
[16:10:59.852]                       }
[16:10:59.852]                       else if (inherits(cond, "warning")) {
[16:10:59.852]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.852]                         if (muffled) 
[16:10:59.852]                           invokeRestart("muffleWarning")
[16:10:59.852]                       }
[16:10:59.852]                       else if (inherits(cond, "condition")) {
[16:10:59.852]                         if (!is.null(pattern)) {
[16:10:59.852]                           computeRestarts <- base::computeRestarts
[16:10:59.852]                           grepl <- base::grepl
[16:10:59.852]                           restarts <- computeRestarts(cond)
[16:10:59.852]                           for (restart in restarts) {
[16:10:59.852]                             name <- restart$name
[16:10:59.852]                             if (is.null(name)) 
[16:10:59.852]                               next
[16:10:59.852]                             if (!grepl(pattern, name)) 
[16:10:59.852]                               next
[16:10:59.852]                             invokeRestart(restart)
[16:10:59.852]                             muffled <- TRUE
[16:10:59.852]                             break
[16:10:59.852]                           }
[16:10:59.852]                         }
[16:10:59.852]                       }
[16:10:59.852]                       invisible(muffled)
[16:10:59.852]                     }
[16:10:59.852]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.852]                   }
[16:10:59.852]                 }
[16:10:59.852]             }
[16:10:59.852]         }))
[16:10:59.852]     }, error = function(ex) {
[16:10:59.852]         base::structure(base::list(value = NULL, visible = NULL, 
[16:10:59.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.852]                 ...future.rng), started = ...future.startTime, 
[16:10:59.852]             finished = Sys.time(), session_uuid = NA_character_, 
[16:10:59.852]             version = "1.8"), class = "FutureResult")
[16:10:59.852]     }, finally = {
[16:10:59.852]         if (!identical(...future.workdir, getwd())) 
[16:10:59.852]             setwd(...future.workdir)
[16:10:59.852]         {
[16:10:59.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:10:59.852]                 ...future.oldOptions$nwarnings <- NULL
[16:10:59.852]             }
[16:10:59.852]             base::options(...future.oldOptions)
[16:10:59.852]             if (.Platform$OS.type == "windows") {
[16:10:59.852]                 old_names <- names(...future.oldEnvVars)
[16:10:59.852]                 envs <- base::Sys.getenv()
[16:10:59.852]                 names <- names(envs)
[16:10:59.852]                 common <- intersect(names, old_names)
[16:10:59.852]                 added <- setdiff(names, old_names)
[16:10:59.852]                 removed <- setdiff(old_names, names)
[16:10:59.852]                 changed <- common[...future.oldEnvVars[common] != 
[16:10:59.852]                   envs[common]]
[16:10:59.852]                 NAMES <- toupper(changed)
[16:10:59.852]                 args <- list()
[16:10:59.852]                 for (kk in seq_along(NAMES)) {
[16:10:59.852]                   name <- changed[[kk]]
[16:10:59.852]                   NAME <- NAMES[[kk]]
[16:10:59.852]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.852]                     next
[16:10:59.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.852]                 }
[16:10:59.852]                 NAMES <- toupper(added)
[16:10:59.852]                 for (kk in seq_along(NAMES)) {
[16:10:59.852]                   name <- added[[kk]]
[16:10:59.852]                   NAME <- NAMES[[kk]]
[16:10:59.852]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.852]                     next
[16:10:59.852]                   args[[name]] <- ""
[16:10:59.852]                 }
[16:10:59.852]                 NAMES <- toupper(removed)
[16:10:59.852]                 for (kk in seq_along(NAMES)) {
[16:10:59.852]                   name <- removed[[kk]]
[16:10:59.852]                   NAME <- NAMES[[kk]]
[16:10:59.852]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.852]                     next
[16:10:59.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.852]                 }
[16:10:59.852]                 if (length(args) > 0) 
[16:10:59.852]                   base::do.call(base::Sys.setenv, args = args)
[16:10:59.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:10:59.852]             }
[16:10:59.852]             else {
[16:10:59.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:10:59.852]             }
[16:10:59.852]             {
[16:10:59.852]                 if (base::length(...future.futureOptionsAdded) > 
[16:10:59.852]                   0L) {
[16:10:59.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:10:59.852]                   base::names(opts) <- ...future.futureOptionsAdded
[16:10:59.852]                   base::options(opts)
[16:10:59.852]                 }
[16:10:59.852]                 {
[16:10:59.852]                   {
[16:10:59.852]                     NULL
[16:10:59.852]                     RNGkind("Mersenne-Twister")
[16:10:59.852]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:10:59.852]                       inherits = FALSE)
[16:10:59.852]                   }
[16:10:59.852]                   options(future.plan = NULL)
[16:10:59.852]                   if (is.na(NA_character_)) 
[16:10:59.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:10:59.852]                   future::plan(list(function (..., envir = parent.frame()) 
[16:10:59.852]                   {
[16:10:59.852]                     future <- SequentialFuture(..., envir = envir)
[16:10:59.852]                     if (!future$lazy) 
[16:10:59.852]                       future <- run(future)
[16:10:59.852]                     invisible(future)
[16:10:59.852]                   }), .cleanup = FALSE, .init = FALSE)
[16:10:59.852]                 }
[16:10:59.852]             }
[16:10:59.852]         }
[16:10:59.852]     })
[16:10:59.852]     if (TRUE) {
[16:10:59.852]         base::sink(type = "output", split = FALSE)
[16:10:59.852]         if (TRUE) {
[16:10:59.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:10:59.852]         }
[16:10:59.852]         else {
[16:10:59.852]             ...future.result["stdout"] <- base::list(NULL)
[16:10:59.852]         }
[16:10:59.852]         base::close(...future.stdout)
[16:10:59.852]         ...future.stdout <- NULL
[16:10:59.852]     }
[16:10:59.852]     ...future.result$conditions <- ...future.conditions
[16:10:59.852]     ...future.result$finished <- base::Sys.time()
[16:10:59.852]     ...future.result
[16:10:59.852] }
[16:10:59.854] assign_globals() ...
[16:10:59.854] List of 11
[16:10:59.854]  $ ...future.FUN            :function (x, ...)  
[16:10:59.854]  $ x_FUN                    :function (x)  
[16:10:59.854]  $ times                    : int 0
[16:10:59.854]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.854]  $ stop_if_not              :function (...)  
[16:10:59.854]  $ dim                      : NULL
[16:10:59.854]  $ valid_types              : chr [1:2] "logical" "integer"
[16:10:59.854]  $ future.call.arguments    : list()
[16:10:59.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.854]  $ ...future.elements_ii    :List of 10
[16:10:59.854]   ..$ : int 1
[16:10:59.854]   ..$ : int 2
[16:10:59.854]   ..$ : int 3
[16:10:59.854]   ..$ : int 4
[16:10:59.854]   ..$ : int 5
[16:10:59.854]   ..$ : int 6
[16:10:59.854]   ..$ : int 7
[16:10:59.854]   ..$ : int 8
[16:10:59.854]   ..$ : int 9
[16:10:59.854]   ..$ : int 10
[16:10:59.854]  $ ...future.seeds_ii       : NULL
[16:10:59.854]  $ ...future.globals.maxSize: NULL
[16:10:59.854]  - attr(*, "resolved")= logi FALSE
[16:10:59.854]  - attr(*, "total_size")= num 95400
[16:10:59.854]  - attr(*, "where")=List of 11
[16:10:59.854]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ times                    :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:10:59.854]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:10:59.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.854]  - attr(*, "already-done")= logi TRUE
[16:10:59.865] - copied ‘...future.FUN’ to environment
[16:10:59.865] - reassign environment for ‘x_FUN’
[16:10:59.865] - copied ‘x_FUN’ to environment
[16:10:59.865] - copied ‘times’ to environment
[16:10:59.865] - copied ‘stopf’ to environment
[16:10:59.865] - copied ‘stop_if_not’ to environment
[16:10:59.865] - copied ‘dim’ to environment
[16:10:59.866] - copied ‘valid_types’ to environment
[16:10:59.866] - copied ‘future.call.arguments’ to environment
[16:10:59.866] - copied ‘...future.elements_ii’ to environment
[16:10:59.866] - copied ‘...future.seeds_ii’ to environment
[16:10:59.866] - copied ‘...future.globals.maxSize’ to environment
[16:10:59.866] assign_globals() ... done
[16:10:59.866] plan(): Setting new future strategy stack:
[16:10:59.866] List of future strategies:
[16:10:59.866] 1. sequential:
[16:10:59.866]    - args: function (..., envir = parent.frame())
[16:10:59.866]    - tweaked: FALSE
[16:10:59.866]    - call: NULL
[16:10:59.867] plan(): nbrOfWorkers() = 1
[16:10:59.867] plan(): Setting new future strategy stack:
[16:10:59.868] List of future strategies:
[16:10:59.868] 1. sequential:
[16:10:59.868]    - args: function (..., envir = parent.frame())
[16:10:59.868]    - tweaked: FALSE
[16:10:59.868]    - call: plan(strategy)
[16:10:59.868] plan(): nbrOfWorkers() = 1
[16:10:59.868] SequentialFuture started (and completed)
[16:10:59.868] - Launch lazy future ... done
[16:10:59.868] run() for ‘SequentialFuture’ ... done
[16:10:59.868] Created future:
[16:10:59.869] SequentialFuture:
[16:10:59.869] Label: ‘future_vapply-1’
[16:10:59.869] Expression:
[16:10:59.869] {
[16:10:59.869]     do.call(function(...) {
[16:10:59.869]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.869]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.869]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.869]             on.exit(options(oopts), add = TRUE)
[16:10:59.869]         }
[16:10:59.869]         {
[16:10:59.869]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.869]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.869]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.869]             })
[16:10:59.869]         }
[16:10:59.869]     }, args = future.call.arguments)
[16:10:59.869] }
[16:10:59.869] Lazy evaluation: FALSE
[16:10:59.869] Asynchronous evaluation: FALSE
[16:10:59.869] Local evaluation: TRUE
[16:10:59.869] Environment: R_GlobalEnv
[16:10:59.869] Capture standard output: TRUE
[16:10:59.869] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:10:59.869] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:10:59.869] Packages: 1 packages (‘future.apply’)
[16:10:59.869] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:10:59.869] Resolved: TRUE
[16:10:59.869] Value: 480 bytes of class ‘list’
[16:10:59.869] Early signaling: FALSE
[16:10:59.869] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:10:59.869] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.870] Chunk #1 of 1 ... DONE
[16:10:59.870] Launching 1 futures (chunks) ... DONE
[16:10:59.870] Resolving 1 futures (chunks) ...
[16:10:59.870] resolve() on list ...
[16:10:59.870]  recursive: 0
[16:10:59.870]  length: 1
[16:10:59.870] 
[16:10:59.870] resolved() for ‘SequentialFuture’ ...
[16:10:59.870] - state: ‘finished’
[16:10:59.870] - run: TRUE
[16:10:59.871] - result: ‘FutureResult’
[16:10:59.871] resolved() for ‘SequentialFuture’ ... done
[16:10:59.871] Future #1
[16:10:59.871] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:10:59.871] - nx: 1
[16:10:59.871] - relay: TRUE
[16:10:59.871] - stdout: TRUE
[16:10:59.871] - signal: TRUE
[16:10:59.871] - resignal: FALSE
[16:10:59.871] - force: TRUE
[16:10:59.871] - relayed: [n=1] FALSE
[16:10:59.871] - queued futures: [n=1] FALSE
[16:10:59.872]  - until=1
[16:10:59.872]  - relaying element #1
[16:10:59.872] - relayed: [n=1] TRUE
[16:10:59.872] - queued futures: [n=1] TRUE
[16:10:59.872] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:10:59.872]  length: 0 (resolved future 1)
[16:10:59.872] Relaying remaining futures
[16:10:59.872] signalConditionsASAP(NULL, pos=0) ...
[16:10:59.872] - nx: 1
[16:10:59.872] - relay: TRUE
[16:10:59.873] - stdout: TRUE
[16:10:59.873] - signal: TRUE
[16:10:59.873] - resignal: FALSE
[16:10:59.873] - force: TRUE
[16:10:59.873] - relayed: [n=1] TRUE
[16:10:59.873] - queued futures: [n=1] TRUE
 - flush all
[16:10:59.873] - relayed: [n=1] TRUE
[16:10:59.873] - queued futures: [n=1] TRUE
[16:10:59.873] signalConditionsASAP(NULL, pos=0) ... done
[16:10:59.873] resolve() on list ... DONE
[16:10:59.873]  - Number of value chunks collected: 1
[16:10:59.874] Resolving 1 futures (chunks) ... DONE
[16:10:59.874] Reducing values from 1 chunks ...
[16:10:59.874]  - Number of values collected after concatenation: 10
[16:10:59.874]  - Number of values expected: 10
[16:10:59.874] Reducing values from 1 chunks ... DONE
[16:10:59.874] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:10:59.875] future_lapply() ...
[16:10:59.876] Number of chunks: 1
[16:10:59.876] getGlobalsAndPackagesXApply() ...
[16:10:59.877]  - future.globals: TRUE
[16:10:59.878] getGlobalsAndPackages() ...
[16:10:59.878] Searching for globals...
[16:10:59.881] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:10:59.881] Searching for globals ... DONE
[16:10:59.881] Resolving globals: FALSE
[16:10:59.882] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:10:59.882] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:10:59.882] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.882] - packages: [1] ‘future.apply’
[16:10:59.882] getGlobalsAndPackages() ... DONE
[16:10:59.882]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.883]  - needed namespaces: [n=1] ‘future.apply’
[16:10:59.883] Finding globals ... DONE
[16:10:59.883]  - use_args: TRUE
[16:10:59.883]  - Getting '...' globals ...
[16:10:59.883] resolve() on list ...
[16:10:59.883]  recursive: 0
[16:10:59.883]  length: 1
[16:10:59.883]  elements: ‘...’
[16:10:59.883]  length: 0 (resolved future 1)
[16:10:59.884] resolve() on list ... DONE
[16:10:59.884]    - '...' content: [n=0] 
[16:10:59.884] List of 1
[16:10:59.884]  $ ...: list()
[16:10:59.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.884]  - attr(*, "where")=List of 1
[16:10:59.884]   ..$ ...:<environment: 0x561e8a728230> 
[16:10:59.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.884]  - attr(*, "resolved")= logi TRUE
[16:10:59.884]  - attr(*, "total_size")= num NA
[16:10:59.886]  - Getting '...' globals ... DONE
[16:10:59.886] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:10:59.886] List of 8
[16:10:59.886]  $ ...future.FUN:function (x, ...)  
[16:10:59.886]  $ x_FUN        :function (x)  
[16:10:59.886]  $ times        : int 1
[16:10:59.886]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.886]  $ stop_if_not  :function (...)  
[16:10:59.886]  $ dim          : NULL
[16:10:59.886]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:10:59.886]  $ ...          : list()
[16:10:59.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.886]  - attr(*, "where")=List of 8
[16:10:59.886]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:10:59.886]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:10:59.886]   ..$ times        :<environment: R_EmptyEnv> 
[16:10:59.886]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:10:59.886]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:10:59.886]   ..$ dim          :<environment: R_EmptyEnv> 
[16:10:59.886]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:10:59.886]   ..$ ...          :<environment: 0x561e8a728230> 
[16:10:59.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.886]  - attr(*, "resolved")= logi FALSE
[16:10:59.886]  - attr(*, "total_size")= num 94336
[16:10:59.891] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:10:59.891] getGlobalsAndPackagesXApply() ... DONE
[16:10:59.892] Number of futures (= number of chunks): 1
[16:10:59.892] Launching 1 futures (chunks) ...
[16:10:59.892] Chunk #1 of 1 ...
[16:10:59.892]  - Finding globals in 'X' for chunk #1 ...
[16:10:59.892] getGlobalsAndPackages() ...
[16:10:59.892] Searching for globals...
[16:10:59.892] 
[16:10:59.892] Searching for globals ... DONE
[16:10:59.893] - globals: [0] <none>
[16:10:59.893] getGlobalsAndPackages() ... DONE
[16:10:59.893]    + additional globals found: [n=0] 
[16:10:59.893]    + additional namespaces needed: [n=0] 
[16:10:59.893]  - Finding globals in 'X' for chunk #1 ... DONE
[16:10:59.893]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[16:10:59.893]  - seeds: <none>
[16:10:59.893] getGlobalsAndPackages() ...
[16:10:59.893] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.893] Resolving globals: FALSE
[16:10:59.894] Tweak future expression to call with '...' arguments ...
[16:10:59.894] {
[16:10:59.894]     do.call(function(...) {
[16:10:59.894]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.894]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.894]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.894]             on.exit(options(oopts), add = TRUE)
[16:10:59.894]         }
[16:10:59.894]         {
[16:10:59.894]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.894]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.894]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.894]             })
[16:10:59.894]         }
[16:10:59.894]     }, args = future.call.arguments)
[16:10:59.894] }
[16:10:59.894] Tweak future expression to call with '...' arguments ... DONE
[16:10:59.894] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.894] - packages: [1] ‘future.apply’
[16:10:59.895] getGlobalsAndPackages() ... DONE
[16:10:59.895] run() for ‘Future’ ...
[16:10:59.895] - state: ‘created’
[16:10:59.895] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:10:59.895] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:10:59.896]   - Field: ‘label’
[16:10:59.896]   - Field: ‘local’
[16:10:59.896]   - Field: ‘owner’
[16:10:59.896]   - Field: ‘envir’
[16:10:59.896]   - Field: ‘packages’
[16:10:59.896]   - Field: ‘gc’
[16:10:59.896]   - Field: ‘conditions’
[16:10:59.896]   - Field: ‘expr’
[16:10:59.896]   - Field: ‘uuid’
[16:10:59.896]   - Field: ‘seed’
[16:10:59.896]   - Field: ‘version’
[16:10:59.897]   - Field: ‘result’
[16:10:59.897]   - Field: ‘asynchronous’
[16:10:59.897]   - Field: ‘calls’
[16:10:59.897]   - Field: ‘globals’
[16:10:59.898]   - Field: ‘stdout’
[16:10:59.898]   - Field: ‘earlySignal’
[16:10:59.898]   - Field: ‘lazy’
[16:10:59.898]   - Field: ‘state’
[16:10:59.898] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:10:59.898] - Launch lazy future ...
[16:10:59.899] Packages needed by the future expression (n = 1): ‘future.apply’
[16:10:59.899] Packages needed by future strategies (n = 0): <none>
[16:10:59.899] {
[16:10:59.899]     {
[16:10:59.899]         {
[16:10:59.899]             ...future.startTime <- base::Sys.time()
[16:10:59.899]             {
[16:10:59.899]                 {
[16:10:59.899]                   {
[16:10:59.899]                     {
[16:10:59.899]                       base::local({
[16:10:59.899]                         has_future <- base::requireNamespace("future", 
[16:10:59.899]                           quietly = TRUE)
[16:10:59.899]                         if (has_future) {
[16:10:59.899]                           ns <- base::getNamespace("future")
[16:10:59.899]                           version <- ns[[".package"]][["version"]]
[16:10:59.899]                           if (is.null(version)) 
[16:10:59.899]                             version <- utils::packageVersion("future")
[16:10:59.899]                         }
[16:10:59.899]                         else {
[16:10:59.899]                           version <- NULL
[16:10:59.899]                         }
[16:10:59.899]                         if (!has_future || version < "1.8.0") {
[16:10:59.899]                           info <- base::c(r_version = base::gsub("R version ", 
[16:10:59.899]                             "", base::R.version$version.string), 
[16:10:59.899]                             platform = base::sprintf("%s (%s-bit)", 
[16:10:59.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:10:59.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:10:59.899]                               "release", "version")], collapse = " "), 
[16:10:59.899]                             hostname = base::Sys.info()[["nodename"]])
[16:10:59.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:10:59.899]                             info)
[16:10:59.899]                           info <- base::paste(info, collapse = "; ")
[16:10:59.899]                           if (!has_future) {
[16:10:59.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:10:59.899]                               info)
[16:10:59.899]                           }
[16:10:59.899]                           else {
[16:10:59.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:10:59.899]                               info, version)
[16:10:59.899]                           }
[16:10:59.899]                           base::stop(msg)
[16:10:59.899]                         }
[16:10:59.899]                       })
[16:10:59.899]                     }
[16:10:59.899]                     base::local({
[16:10:59.899]                       for (pkg in "future.apply") {
[16:10:59.899]                         base::loadNamespace(pkg)
[16:10:59.899]                         base::library(pkg, character.only = TRUE)
[16:10:59.899]                       }
[16:10:59.899]                     })
[16:10:59.899]                   }
[16:10:59.899]                   options(future.plan = NULL)
[16:10:59.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:10:59.899]                 }
[16:10:59.899]                 ...future.workdir <- getwd()
[16:10:59.899]             }
[16:10:59.899]             ...future.oldOptions <- base::as.list(base::.Options)
[16:10:59.899]             ...future.oldEnvVars <- base::Sys.getenv()
[16:10:59.899]         }
[16:10:59.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:10:59.899]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[16:10:59.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:10:59.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:10:59.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:10:59.899]             future.stdout.windows.reencode = NULL, width = 80L)
[16:10:59.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:10:59.899]             base::names(...future.oldOptions))
[16:10:59.899]     }
[16:10:59.899]     if (FALSE) {
[16:10:59.899]     }
[16:10:59.899]     else {
[16:10:59.899]         if (TRUE) {
[16:10:59.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:10:59.899]                 open = "w")
[16:10:59.899]         }
[16:10:59.899]         else {
[16:10:59.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:10:59.899]                 windows = "NUL", "/dev/null"), open = "w")
[16:10:59.899]         }
[16:10:59.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:10:59.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:10:59.899]             base::sink(type = "output", split = FALSE)
[16:10:59.899]             base::close(...future.stdout)
[16:10:59.899]         }, add = TRUE)
[16:10:59.899]     }
[16:10:59.899]     ...future.frame <- base::sys.nframe()
[16:10:59.899]     ...future.conditions <- base::list()
[16:10:59.899]     ...future.rng <- base::globalenv()$.Random.seed
[16:10:59.899]     if (FALSE) {
[16:10:59.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:10:59.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:10:59.899]     }
[16:10:59.899]     ...future.result <- base::tryCatch({
[16:10:59.899]         base::withCallingHandlers({
[16:10:59.899]             ...future.value <- base::withVisible(base::local({
[16:10:59.899]                 do.call(function(...) {
[16:10:59.899]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.899]                   if (!identical(...future.globals.maxSize.org, 
[16:10:59.899]                     ...future.globals.maxSize)) {
[16:10:59.899]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.899]                     on.exit(options(oopts), add = TRUE)
[16:10:59.899]                   }
[16:10:59.899]                   {
[16:10:59.899]                     lapply(seq_along(...future.elements_ii), 
[16:10:59.899]                       FUN = function(jj) {
[16:10:59.899]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.899]                         ...future.FUN(...future.X_jj, ...)
[16:10:59.899]                       })
[16:10:59.899]                   }
[16:10:59.899]                 }, args = future.call.arguments)
[16:10:59.899]             }))
[16:10:59.899]             future::FutureResult(value = ...future.value$value, 
[16:10:59.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.899]                   ...future.rng), globalenv = if (FALSE) 
[16:10:59.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:10:59.899]                     ...future.globalenv.names))
[16:10:59.899]                 else NULL, started = ...future.startTime, version = "1.8")
[16:10:59.899]         }, condition = base::local({
[16:10:59.899]             c <- base::c
[16:10:59.899]             inherits <- base::inherits
[16:10:59.899]             invokeRestart <- base::invokeRestart
[16:10:59.899]             length <- base::length
[16:10:59.899]             list <- base::list
[16:10:59.899]             seq.int <- base::seq.int
[16:10:59.899]             signalCondition <- base::signalCondition
[16:10:59.899]             sys.calls <- base::sys.calls
[16:10:59.899]             `[[` <- base::`[[`
[16:10:59.899]             `+` <- base::`+`
[16:10:59.899]             `<<-` <- base::`<<-`
[16:10:59.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:10:59.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:10:59.899]                   3L)]
[16:10:59.899]             }
[16:10:59.899]             function(cond) {
[16:10:59.899]                 is_error <- inherits(cond, "error")
[16:10:59.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:10:59.899]                   NULL)
[16:10:59.899]                 if (is_error) {
[16:10:59.899]                   sessionInformation <- function() {
[16:10:59.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:10:59.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:10:59.899]                       search = base::search(), system = base::Sys.info())
[16:10:59.899]                   }
[16:10:59.899]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:10:59.899]                     cond$call), session = sessionInformation(), 
[16:10:59.899]                     timestamp = base::Sys.time(), signaled = 0L)
[16:10:59.899]                   signalCondition(cond)
[16:10:59.899]                 }
[16:10:59.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:10:59.899]                 "immediateCondition"))) {
[16:10:59.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:10:59.899]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:10:59.899]                   if (TRUE && !signal) {
[16:10:59.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.899]                     {
[16:10:59.899]                       inherits <- base::inherits
[16:10:59.899]                       invokeRestart <- base::invokeRestart
[16:10:59.899]                       is.null <- base::is.null
[16:10:59.899]                       muffled <- FALSE
[16:10:59.899]                       if (inherits(cond, "message")) {
[16:10:59.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.899]                         if (muffled) 
[16:10:59.899]                           invokeRestart("muffleMessage")
[16:10:59.899]                       }
[16:10:59.899]                       else if (inherits(cond, "warning")) {
[16:10:59.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.899]                         if (muffled) 
[16:10:59.899]                           invokeRestart("muffleWarning")
[16:10:59.899]                       }
[16:10:59.899]                       else if (inherits(cond, "condition")) {
[16:10:59.899]                         if (!is.null(pattern)) {
[16:10:59.899]                           computeRestarts <- base::computeRestarts
[16:10:59.899]                           grepl <- base::grepl
[16:10:59.899]                           restarts <- computeRestarts(cond)
[16:10:59.899]                           for (restart in restarts) {
[16:10:59.899]                             name <- restart$name
[16:10:59.899]                             if (is.null(name)) 
[16:10:59.899]                               next
[16:10:59.899]                             if (!grepl(pattern, name)) 
[16:10:59.899]                               next
[16:10:59.899]                             invokeRestart(restart)
[16:10:59.899]                             muffled <- TRUE
[16:10:59.899]                             break
[16:10:59.899]                           }
[16:10:59.899]                         }
[16:10:59.899]                       }
[16:10:59.899]                       invisible(muffled)
[16:10:59.899]                     }
[16:10:59.899]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.899]                   }
[16:10:59.899]                 }
[16:10:59.899]                 else {
[16:10:59.899]                   if (TRUE) {
[16:10:59.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.899]                     {
[16:10:59.899]                       inherits <- base::inherits
[16:10:59.899]                       invokeRestart <- base::invokeRestart
[16:10:59.899]                       is.null <- base::is.null
[16:10:59.899]                       muffled <- FALSE
[16:10:59.899]                       if (inherits(cond, "message")) {
[16:10:59.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.899]                         if (muffled) 
[16:10:59.899]                           invokeRestart("muffleMessage")
[16:10:59.899]                       }
[16:10:59.899]                       else if (inherits(cond, "warning")) {
[16:10:59.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.899]                         if (muffled) 
[16:10:59.899]                           invokeRestart("muffleWarning")
[16:10:59.899]                       }
[16:10:59.899]                       else if (inherits(cond, "condition")) {
[16:10:59.899]                         if (!is.null(pattern)) {
[16:10:59.899]                           computeRestarts <- base::computeRestarts
[16:10:59.899]                           grepl <- base::grepl
[16:10:59.899]                           restarts <- computeRestarts(cond)
[16:10:59.899]                           for (restart in restarts) {
[16:10:59.899]                             name <- restart$name
[16:10:59.899]                             if (is.null(name)) 
[16:10:59.899]                               next
[16:10:59.899]                             if (!grepl(pattern, name)) 
[16:10:59.899]                               next
[16:10:59.899]                             invokeRestart(restart)
[16:10:59.899]                             muffled <- TRUE
[16:10:59.899]                             break
[16:10:59.899]                           }
[16:10:59.899]                         }
[16:10:59.899]                       }
[16:10:59.899]                       invisible(muffled)
[16:10:59.899]                     }
[16:10:59.899]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.899]                   }
[16:10:59.899]                 }
[16:10:59.899]             }
[16:10:59.899]         }))
[16:10:59.899]     }, error = function(ex) {
[16:10:59.899]         base::structure(base::list(value = NULL, visible = NULL, 
[16:10:59.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.899]                 ...future.rng), started = ...future.startTime, 
[16:10:59.899]             finished = Sys.time(), session_uuid = NA_character_, 
[16:10:59.899]             version = "1.8"), class = "FutureResult")
[16:10:59.899]     }, finally = {
[16:10:59.899]         if (!identical(...future.workdir, getwd())) 
[16:10:59.899]             setwd(...future.workdir)
[16:10:59.899]         {
[16:10:59.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:10:59.899]                 ...future.oldOptions$nwarnings <- NULL
[16:10:59.899]             }
[16:10:59.899]             base::options(...future.oldOptions)
[16:10:59.899]             if (.Platform$OS.type == "windows") {
[16:10:59.899]                 old_names <- names(...future.oldEnvVars)
[16:10:59.899]                 envs <- base::Sys.getenv()
[16:10:59.899]                 names <- names(envs)
[16:10:59.899]                 common <- intersect(names, old_names)
[16:10:59.899]                 added <- setdiff(names, old_names)
[16:10:59.899]                 removed <- setdiff(old_names, names)
[16:10:59.899]                 changed <- common[...future.oldEnvVars[common] != 
[16:10:59.899]                   envs[common]]
[16:10:59.899]                 NAMES <- toupper(changed)
[16:10:59.899]                 args <- list()
[16:10:59.899]                 for (kk in seq_along(NAMES)) {
[16:10:59.899]                   name <- changed[[kk]]
[16:10:59.899]                   NAME <- NAMES[[kk]]
[16:10:59.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.899]                     next
[16:10:59.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.899]                 }
[16:10:59.899]                 NAMES <- toupper(added)
[16:10:59.899]                 for (kk in seq_along(NAMES)) {
[16:10:59.899]                   name <- added[[kk]]
[16:10:59.899]                   NAME <- NAMES[[kk]]
[16:10:59.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.899]                     next
[16:10:59.899]                   args[[name]] <- ""
[16:10:59.899]                 }
[16:10:59.899]                 NAMES <- toupper(removed)
[16:10:59.899]                 for (kk in seq_along(NAMES)) {
[16:10:59.899]                   name <- removed[[kk]]
[16:10:59.899]                   NAME <- NAMES[[kk]]
[16:10:59.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.899]                     next
[16:10:59.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.899]                 }
[16:10:59.899]                 if (length(args) > 0) 
[16:10:59.899]                   base::do.call(base::Sys.setenv, args = args)
[16:10:59.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:10:59.899]             }
[16:10:59.899]             else {
[16:10:59.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:10:59.899]             }
[16:10:59.899]             {
[16:10:59.899]                 if (base::length(...future.futureOptionsAdded) > 
[16:10:59.899]                   0L) {
[16:10:59.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:10:59.899]                   base::names(opts) <- ...future.futureOptionsAdded
[16:10:59.899]                   base::options(opts)
[16:10:59.899]                 }
[16:10:59.899]                 {
[16:10:59.899]                   {
[16:10:59.899]                     NULL
[16:10:59.899]                     RNGkind("Mersenne-Twister")
[16:10:59.899]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:10:59.899]                       inherits = FALSE)
[16:10:59.899]                   }
[16:10:59.899]                   options(future.plan = NULL)
[16:10:59.899]                   if (is.na(NA_character_)) 
[16:10:59.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:10:59.899]                   future::plan(list(function (..., envir = parent.frame()) 
[16:10:59.899]                   {
[16:10:59.899]                     future <- SequentialFuture(..., envir = envir)
[16:10:59.899]                     if (!future$lazy) 
[16:10:59.899]                       future <- run(future)
[16:10:59.899]                     invisible(future)
[16:10:59.899]                   }), .cleanup = FALSE, .init = FALSE)
[16:10:59.899]                 }
[16:10:59.899]             }
[16:10:59.899]         }
[16:10:59.899]     })
[16:10:59.899]     if (TRUE) {
[16:10:59.899]         base::sink(type = "output", split = FALSE)
[16:10:59.899]         if (TRUE) {
[16:10:59.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:10:59.899]         }
[16:10:59.899]         else {
[16:10:59.899]             ...future.result["stdout"] <- base::list(NULL)
[16:10:59.899]         }
[16:10:59.899]         base::close(...future.stdout)
[16:10:59.899]         ...future.stdout <- NULL
[16:10:59.899]     }
[16:10:59.899]     ...future.result$conditions <- ...future.conditions
[16:10:59.899]     ...future.result$finished <- base::Sys.time()
[16:10:59.899]     ...future.result
[16:10:59.899] }
[16:10:59.901] assign_globals() ...
[16:10:59.901] List of 11
[16:10:59.901]  $ ...future.FUN            :function (x, ...)  
[16:10:59.901]  $ x_FUN                    :function (x)  
[16:10:59.901]  $ times                    : int 1
[16:10:59.901]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.901]  $ stop_if_not              :function (...)  
[16:10:59.901]  $ dim                      : NULL
[16:10:59.901]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:10:59.901]  $ future.call.arguments    : list()
[16:10:59.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.901]  $ ...future.elements_ii    :List of 10
[16:10:59.901]   ..$ : int 1
[16:10:59.901]   ..$ : int 2
[16:10:59.901]   ..$ : int 3
[16:10:59.901]   ..$ : int 4
[16:10:59.901]   ..$ : int 5
[16:10:59.901]   ..$ : int 6
[16:10:59.901]   ..$ : int 7
[16:10:59.901]   ..$ : int 8
[16:10:59.901]   ..$ : int 9
[16:10:59.901]   ..$ : int 10
[16:10:59.901]  $ ...future.seeds_ii       : NULL
[16:10:59.901]  $ ...future.globals.maxSize: NULL
[16:10:59.901]  - attr(*, "resolved")= logi FALSE
[16:10:59.901]  - attr(*, "total_size")= num 94336
[16:10:59.901]  - attr(*, "where")=List of 11
[16:10:59.901]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ times                    :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:10:59.901]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:10:59.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.901]  - attr(*, "already-done")= logi TRUE
[16:10:59.910] - copied ‘...future.FUN’ to environment
[16:10:59.910] - copied ‘x_FUN’ to environment
[16:10:59.910] - copied ‘times’ to environment
[16:10:59.911] - copied ‘stopf’ to environment
[16:10:59.911] - copied ‘stop_if_not’ to environment
[16:10:59.911] - copied ‘dim’ to environment
[16:10:59.911] - copied ‘valid_types’ to environment
[16:10:59.911] - copied ‘future.call.arguments’ to environment
[16:10:59.911] - copied ‘...future.elements_ii’ to environment
[16:10:59.911] - copied ‘...future.seeds_ii’ to environment
[16:10:59.911] - copied ‘...future.globals.maxSize’ to environment
[16:10:59.911] assign_globals() ... done
[16:10:59.912] plan(): Setting new future strategy stack:
[16:10:59.912] List of future strategies:
[16:10:59.912] 1. sequential:
[16:10:59.912]    - args: function (..., envir = parent.frame())
[16:10:59.912]    - tweaked: FALSE
[16:10:59.912]    - call: NULL
[16:10:59.912] plan(): nbrOfWorkers() = 1
[16:10:59.913] plan(): Setting new future strategy stack:
[16:10:59.913] List of future strategies:
[16:10:59.913] 1. sequential:
[16:10:59.913]    - args: function (..., envir = parent.frame())
[16:10:59.913]    - tweaked: FALSE
[16:10:59.913]    - call: plan(strategy)
[16:10:59.913] plan(): nbrOfWorkers() = 1
[16:10:59.914] SequentialFuture started (and completed)
[16:10:59.914] - Launch lazy future ... done
[16:10:59.914] run() for ‘SequentialFuture’ ... done
[16:10:59.914] Created future:
[16:10:59.914] SequentialFuture:
[16:10:59.914] Label: ‘future_vapply-1’
[16:10:59.914] Expression:
[16:10:59.914] {
[16:10:59.914]     do.call(function(...) {
[16:10:59.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.914]             on.exit(options(oopts), add = TRUE)
[16:10:59.914]         }
[16:10:59.914]         {
[16:10:59.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.914]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.914]             })
[16:10:59.914]         }
[16:10:59.914]     }, args = future.call.arguments)
[16:10:59.914] }
[16:10:59.914] Lazy evaluation: FALSE
[16:10:59.914] Asynchronous evaluation: FALSE
[16:10:59.914] Local evaluation: TRUE
[16:10:59.914] Environment: R_GlobalEnv
[16:10:59.914] Capture standard output: TRUE
[16:10:59.914] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:10:59.914] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:10:59.914] Packages: 1 packages (‘future.apply’)
[16:10:59.914] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:10:59.914] Resolved: TRUE
[16:10:59.914] Value: 560 bytes of class ‘list’
[16:10:59.914] Early signaling: FALSE
[16:10:59.914] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:10:59.914] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.915] Chunk #1 of 1 ... DONE
[16:10:59.915] Launching 1 futures (chunks) ... DONE
[16:10:59.915] Resolving 1 futures (chunks) ...
[16:10:59.915] resolve() on list ...
[16:10:59.915]  recursive: 0
[16:10:59.915]  length: 1
[16:10:59.916] 
[16:10:59.916] resolved() for ‘SequentialFuture’ ...
[16:10:59.916] - state: ‘finished’
[16:10:59.916] - run: TRUE
[16:10:59.916] - result: ‘FutureResult’
[16:10:59.916] resolved() for ‘SequentialFuture’ ... done
[16:10:59.916] Future #1
[16:10:59.916] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:10:59.916] - nx: 1
[16:10:59.916] - relay: TRUE
[16:10:59.917] - stdout: TRUE
[16:10:59.917] - signal: TRUE
[16:10:59.917] - resignal: FALSE
[16:10:59.917] - force: TRUE
[16:10:59.917] - relayed: [n=1] FALSE
[16:10:59.917] - queued futures: [n=1] FALSE
[16:10:59.917]  - until=1
[16:10:59.917]  - relaying element #1
[16:10:59.917] - relayed: [n=1] TRUE
[16:10:59.917] - queued futures: [n=1] TRUE
[16:10:59.917] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:10:59.918]  length: 0 (resolved future 1)
[16:10:59.918] Relaying remaining futures
[16:10:59.918] signalConditionsASAP(NULL, pos=0) ...
[16:10:59.918] - nx: 1
[16:10:59.918] - relay: TRUE
[16:10:59.918] - stdout: TRUE
[16:10:59.918] - signal: TRUE
[16:10:59.918] - resignal: FALSE
[16:10:59.918] - force: TRUE
[16:10:59.918] - relayed: [n=1] TRUE
[16:10:59.918] - queued futures: [n=1] TRUE
 - flush all
[16:10:59.920] - relayed: [n=1] TRUE
[16:10:59.920] - queued futures: [n=1] TRUE
[16:10:59.920] signalConditionsASAP(NULL, pos=0) ... done
[16:10:59.920] resolve() on list ... DONE
[16:10:59.920]  - Number of value chunks collected: 1
[16:10:59.920] Resolving 1 futures (chunks) ... DONE
[16:10:59.920] Reducing values from 1 chunks ...
[16:10:59.920]  - Number of values collected after concatenation: 10
[16:10:59.920]  - Number of values expected: 10
[16:10:59.921] Reducing values from 1 chunks ... DONE
[16:10:59.921] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:10:59.921] future_lapply() ...
[16:10:59.923] Number of chunks: 1
[16:10:59.923] getGlobalsAndPackagesXApply() ...
[16:10:59.923]  - future.globals: TRUE
[16:10:59.923] getGlobalsAndPackages() ...
[16:10:59.923] Searching for globals...
[16:10:59.927] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:10:59.927] Searching for globals ... DONE
[16:10:59.927] Resolving globals: FALSE
[16:10:59.928] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:10:59.928] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:10:59.928] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.928] - packages: [1] ‘future.apply’
[16:10:59.929] getGlobalsAndPackages() ... DONE
[16:10:59.929]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.929]  - needed namespaces: [n=1] ‘future.apply’
[16:10:59.929] Finding globals ... DONE
[16:10:59.929]  - use_args: TRUE
[16:10:59.929]  - Getting '...' globals ...
[16:10:59.929] resolve() on list ...
[16:10:59.929]  recursive: 0
[16:10:59.929]  length: 1
[16:10:59.930]  elements: ‘...’
[16:10:59.930]  length: 0 (resolved future 1)
[16:10:59.930] resolve() on list ... DONE
[16:10:59.930]    - '...' content: [n=0] 
[16:10:59.930] List of 1
[16:10:59.930]  $ ...: list()
[16:10:59.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.930]  - attr(*, "where")=List of 1
[16:10:59.930]   ..$ ...:<environment: 0x561e88f07d98> 
[16:10:59.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.930]  - attr(*, "resolved")= logi TRUE
[16:10:59.930]  - attr(*, "total_size")= num NA
[16:10:59.932]  - Getting '...' globals ... DONE
[16:10:59.932] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:10:59.933] List of 8
[16:10:59.933]  $ ...future.FUN:function (x, ...)  
[16:10:59.933]  $ x_FUN        :function (x)  
[16:10:59.933]  $ times        : int 2
[16:10:59.933]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.933]  $ stop_if_not  :function (...)  
[16:10:59.933]  $ dim          : NULL
[16:10:59.933]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:10:59.933]  $ ...          : list()
[16:10:59.933]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.933]  - attr(*, "where")=List of 8
[16:10:59.933]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:10:59.933]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:10:59.933]   ..$ times        :<environment: R_EmptyEnv> 
[16:10:59.933]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:10:59.933]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:10:59.933]   ..$ dim          :<environment: R_EmptyEnv> 
[16:10:59.933]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:10:59.933]   ..$ ...          :<environment: 0x561e88f07d98> 
[16:10:59.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.933]  - attr(*, "resolved")= logi FALSE
[16:10:59.933]  - attr(*, "total_size")= num 96456
[16:10:59.938] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:10:59.938] getGlobalsAndPackagesXApply() ... DONE
[16:10:59.938] Number of futures (= number of chunks): 1
[16:10:59.938] Launching 1 futures (chunks) ...
[16:10:59.938] Chunk #1 of 1 ...
[16:10:59.938]  - Finding globals in 'X' for chunk #1 ...
[16:10:59.938] getGlobalsAndPackages() ...
[16:10:59.939] Searching for globals...
[16:10:59.940] 
[16:10:59.940] Searching for globals ... DONE
[16:10:59.940] - globals: [0] <none>
[16:10:59.940] getGlobalsAndPackages() ... DONE
[16:10:59.940]    + additional globals found: [n=0] 
[16:10:59.940]    + additional namespaces needed: [n=0] 
[16:10:59.940]  - Finding globals in 'X' for chunk #1 ... DONE
[16:10:59.940]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[16:10:59.940]  - seeds: <none>
[16:10:59.941] getGlobalsAndPackages() ...
[16:10:59.941] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.941] Resolving globals: FALSE
[16:10:59.941] Tweak future expression to call with '...' arguments ...
[16:10:59.941] {
[16:10:59.941]     do.call(function(...) {
[16:10:59.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.941]             on.exit(options(oopts), add = TRUE)
[16:10:59.941]         }
[16:10:59.941]         {
[16:10:59.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.941]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.941]             })
[16:10:59.941]         }
[16:10:59.941]     }, args = future.call.arguments)
[16:10:59.941] }
[16:10:59.941] Tweak future expression to call with '...' arguments ... DONE
[16:10:59.942] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.942] - packages: [1] ‘future.apply’
[16:10:59.942] getGlobalsAndPackages() ... DONE
[16:10:59.942] run() for ‘Future’ ...
[16:10:59.942] - state: ‘created’
[16:10:59.942] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:10:59.943] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:10:59.943]   - Field: ‘label’
[16:10:59.943]   - Field: ‘local’
[16:10:59.943]   - Field: ‘owner’
[16:10:59.943]   - Field: ‘envir’
[16:10:59.943]   - Field: ‘packages’
[16:10:59.943]   - Field: ‘gc’
[16:10:59.943]   - Field: ‘conditions’
[16:10:59.943]   - Field: ‘expr’
[16:10:59.944]   - Field: ‘uuid’
[16:10:59.944]   - Field: ‘seed’
[16:10:59.944]   - Field: ‘version’
[16:10:59.944]   - Field: ‘result’
[16:10:59.944]   - Field: ‘asynchronous’
[16:10:59.944]   - Field: ‘calls’
[16:10:59.944]   - Field: ‘globals’
[16:10:59.944]   - Field: ‘stdout’
[16:10:59.944]   - Field: ‘earlySignal’
[16:10:59.944]   - Field: ‘lazy’
[16:10:59.944]   - Field: ‘state’
[16:10:59.945] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:10:59.945] - Launch lazy future ...
[16:10:59.945] Packages needed by the future expression (n = 1): ‘future.apply’
[16:10:59.945] Packages needed by future strategies (n = 0): <none>
[16:10:59.945] {
[16:10:59.945]     {
[16:10:59.945]         {
[16:10:59.945]             ...future.startTime <- base::Sys.time()
[16:10:59.945]             {
[16:10:59.945]                 {
[16:10:59.945]                   {
[16:10:59.945]                     {
[16:10:59.945]                       base::local({
[16:10:59.945]                         has_future <- base::requireNamespace("future", 
[16:10:59.945]                           quietly = TRUE)
[16:10:59.945]                         if (has_future) {
[16:10:59.945]                           ns <- base::getNamespace("future")
[16:10:59.945]                           version <- ns[[".package"]][["version"]]
[16:10:59.945]                           if (is.null(version)) 
[16:10:59.945]                             version <- utils::packageVersion("future")
[16:10:59.945]                         }
[16:10:59.945]                         else {
[16:10:59.945]                           version <- NULL
[16:10:59.945]                         }
[16:10:59.945]                         if (!has_future || version < "1.8.0") {
[16:10:59.945]                           info <- base::c(r_version = base::gsub("R version ", 
[16:10:59.945]                             "", base::R.version$version.string), 
[16:10:59.945]                             platform = base::sprintf("%s (%s-bit)", 
[16:10:59.945]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:10:59.945]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:10:59.945]                               "release", "version")], collapse = " "), 
[16:10:59.945]                             hostname = base::Sys.info()[["nodename"]])
[16:10:59.945]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:10:59.945]                             info)
[16:10:59.945]                           info <- base::paste(info, collapse = "; ")
[16:10:59.945]                           if (!has_future) {
[16:10:59.945]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:10:59.945]                               info)
[16:10:59.945]                           }
[16:10:59.945]                           else {
[16:10:59.945]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:10:59.945]                               info, version)
[16:10:59.945]                           }
[16:10:59.945]                           base::stop(msg)
[16:10:59.945]                         }
[16:10:59.945]                       })
[16:10:59.945]                     }
[16:10:59.945]                     base::local({
[16:10:59.945]                       for (pkg in "future.apply") {
[16:10:59.945]                         base::loadNamespace(pkg)
[16:10:59.945]                         base::library(pkg, character.only = TRUE)
[16:10:59.945]                       }
[16:10:59.945]                     })
[16:10:59.945]                   }
[16:10:59.945]                   options(future.plan = NULL)
[16:10:59.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:10:59.945]                 }
[16:10:59.945]                 ...future.workdir <- getwd()
[16:10:59.945]             }
[16:10:59.945]             ...future.oldOptions <- base::as.list(base::.Options)
[16:10:59.945]             ...future.oldEnvVars <- base::Sys.getenv()
[16:10:59.945]         }
[16:10:59.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:10:59.945]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[16:10:59.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:10:59.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:10:59.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:10:59.945]             future.stdout.windows.reencode = NULL, width = 80L)
[16:10:59.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:10:59.945]             base::names(...future.oldOptions))
[16:10:59.945]     }
[16:10:59.945]     if (FALSE) {
[16:10:59.945]     }
[16:10:59.945]     else {
[16:10:59.945]         if (TRUE) {
[16:10:59.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:10:59.945]                 open = "w")
[16:10:59.945]         }
[16:10:59.945]         else {
[16:10:59.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:10:59.945]                 windows = "NUL", "/dev/null"), open = "w")
[16:10:59.945]         }
[16:10:59.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:10:59.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:10:59.945]             base::sink(type = "output", split = FALSE)
[16:10:59.945]             base::close(...future.stdout)
[16:10:59.945]         }, add = TRUE)
[16:10:59.945]     }
[16:10:59.945]     ...future.frame <- base::sys.nframe()
[16:10:59.945]     ...future.conditions <- base::list()
[16:10:59.945]     ...future.rng <- base::globalenv()$.Random.seed
[16:10:59.945]     if (FALSE) {
[16:10:59.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:10:59.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:10:59.945]     }
[16:10:59.945]     ...future.result <- base::tryCatch({
[16:10:59.945]         base::withCallingHandlers({
[16:10:59.945]             ...future.value <- base::withVisible(base::local({
[16:10:59.945]                 do.call(function(...) {
[16:10:59.945]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.945]                   if (!identical(...future.globals.maxSize.org, 
[16:10:59.945]                     ...future.globals.maxSize)) {
[16:10:59.945]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.945]                     on.exit(options(oopts), add = TRUE)
[16:10:59.945]                   }
[16:10:59.945]                   {
[16:10:59.945]                     lapply(seq_along(...future.elements_ii), 
[16:10:59.945]                       FUN = function(jj) {
[16:10:59.945]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.945]                         ...future.FUN(...future.X_jj, ...)
[16:10:59.945]                       })
[16:10:59.945]                   }
[16:10:59.945]                 }, args = future.call.arguments)
[16:10:59.945]             }))
[16:10:59.945]             future::FutureResult(value = ...future.value$value, 
[16:10:59.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.945]                   ...future.rng), globalenv = if (FALSE) 
[16:10:59.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:10:59.945]                     ...future.globalenv.names))
[16:10:59.945]                 else NULL, started = ...future.startTime, version = "1.8")
[16:10:59.945]         }, condition = base::local({
[16:10:59.945]             c <- base::c
[16:10:59.945]             inherits <- base::inherits
[16:10:59.945]             invokeRestart <- base::invokeRestart
[16:10:59.945]             length <- base::length
[16:10:59.945]             list <- base::list
[16:10:59.945]             seq.int <- base::seq.int
[16:10:59.945]             signalCondition <- base::signalCondition
[16:10:59.945]             sys.calls <- base::sys.calls
[16:10:59.945]             `[[` <- base::`[[`
[16:10:59.945]             `+` <- base::`+`
[16:10:59.945]             `<<-` <- base::`<<-`
[16:10:59.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:10:59.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:10:59.945]                   3L)]
[16:10:59.945]             }
[16:10:59.945]             function(cond) {
[16:10:59.945]                 is_error <- inherits(cond, "error")
[16:10:59.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:10:59.945]                   NULL)
[16:10:59.945]                 if (is_error) {
[16:10:59.945]                   sessionInformation <- function() {
[16:10:59.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:10:59.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:10:59.945]                       search = base::search(), system = base::Sys.info())
[16:10:59.945]                   }
[16:10:59.945]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:10:59.945]                     cond$call), session = sessionInformation(), 
[16:10:59.945]                     timestamp = base::Sys.time(), signaled = 0L)
[16:10:59.945]                   signalCondition(cond)
[16:10:59.945]                 }
[16:10:59.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:10:59.945]                 "immediateCondition"))) {
[16:10:59.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:10:59.945]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:10:59.945]                   if (TRUE && !signal) {
[16:10:59.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.945]                     {
[16:10:59.945]                       inherits <- base::inherits
[16:10:59.945]                       invokeRestart <- base::invokeRestart
[16:10:59.945]                       is.null <- base::is.null
[16:10:59.945]                       muffled <- FALSE
[16:10:59.945]                       if (inherits(cond, "message")) {
[16:10:59.945]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.945]                         if (muffled) 
[16:10:59.945]                           invokeRestart("muffleMessage")
[16:10:59.945]                       }
[16:10:59.945]                       else if (inherits(cond, "warning")) {
[16:10:59.945]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.945]                         if (muffled) 
[16:10:59.945]                           invokeRestart("muffleWarning")
[16:10:59.945]                       }
[16:10:59.945]                       else if (inherits(cond, "condition")) {
[16:10:59.945]                         if (!is.null(pattern)) {
[16:10:59.945]                           computeRestarts <- base::computeRestarts
[16:10:59.945]                           grepl <- base::grepl
[16:10:59.945]                           restarts <- computeRestarts(cond)
[16:10:59.945]                           for (restart in restarts) {
[16:10:59.945]                             name <- restart$name
[16:10:59.945]                             if (is.null(name)) 
[16:10:59.945]                               next
[16:10:59.945]                             if (!grepl(pattern, name)) 
[16:10:59.945]                               next
[16:10:59.945]                             invokeRestart(restart)
[16:10:59.945]                             muffled <- TRUE
[16:10:59.945]                             break
[16:10:59.945]                           }
[16:10:59.945]                         }
[16:10:59.945]                       }
[16:10:59.945]                       invisible(muffled)
[16:10:59.945]                     }
[16:10:59.945]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.945]                   }
[16:10:59.945]                 }
[16:10:59.945]                 else {
[16:10:59.945]                   if (TRUE) {
[16:10:59.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.945]                     {
[16:10:59.945]                       inherits <- base::inherits
[16:10:59.945]                       invokeRestart <- base::invokeRestart
[16:10:59.945]                       is.null <- base::is.null
[16:10:59.945]                       muffled <- FALSE
[16:10:59.945]                       if (inherits(cond, "message")) {
[16:10:59.945]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.945]                         if (muffled) 
[16:10:59.945]                           invokeRestart("muffleMessage")
[16:10:59.945]                       }
[16:10:59.945]                       else if (inherits(cond, "warning")) {
[16:10:59.945]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.945]                         if (muffled) 
[16:10:59.945]                           invokeRestart("muffleWarning")
[16:10:59.945]                       }
[16:10:59.945]                       else if (inherits(cond, "condition")) {
[16:10:59.945]                         if (!is.null(pattern)) {
[16:10:59.945]                           computeRestarts <- base::computeRestarts
[16:10:59.945]                           grepl <- base::grepl
[16:10:59.945]                           restarts <- computeRestarts(cond)
[16:10:59.945]                           for (restart in restarts) {
[16:10:59.945]                             name <- restart$name
[16:10:59.945]                             if (is.null(name)) 
[16:10:59.945]                               next
[16:10:59.945]                             if (!grepl(pattern, name)) 
[16:10:59.945]                               next
[16:10:59.945]                             invokeRestart(restart)
[16:10:59.945]                             muffled <- TRUE
[16:10:59.945]                             break
[16:10:59.945]                           }
[16:10:59.945]                         }
[16:10:59.945]                       }
[16:10:59.945]                       invisible(muffled)
[16:10:59.945]                     }
[16:10:59.945]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.945]                   }
[16:10:59.945]                 }
[16:10:59.945]             }
[16:10:59.945]         }))
[16:10:59.945]     }, error = function(ex) {
[16:10:59.945]         base::structure(base::list(value = NULL, visible = NULL, 
[16:10:59.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.945]                 ...future.rng), started = ...future.startTime, 
[16:10:59.945]             finished = Sys.time(), session_uuid = NA_character_, 
[16:10:59.945]             version = "1.8"), class = "FutureResult")
[16:10:59.945]     }, finally = {
[16:10:59.945]         if (!identical(...future.workdir, getwd())) 
[16:10:59.945]             setwd(...future.workdir)
[16:10:59.945]         {
[16:10:59.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:10:59.945]                 ...future.oldOptions$nwarnings <- NULL
[16:10:59.945]             }
[16:10:59.945]             base::options(...future.oldOptions)
[16:10:59.945]             if (.Platform$OS.type == "windows") {
[16:10:59.945]                 old_names <- names(...future.oldEnvVars)
[16:10:59.945]                 envs <- base::Sys.getenv()
[16:10:59.945]                 names <- names(envs)
[16:10:59.945]                 common <- intersect(names, old_names)
[16:10:59.945]                 added <- setdiff(names, old_names)
[16:10:59.945]                 removed <- setdiff(old_names, names)
[16:10:59.945]                 changed <- common[...future.oldEnvVars[common] != 
[16:10:59.945]                   envs[common]]
[16:10:59.945]                 NAMES <- toupper(changed)
[16:10:59.945]                 args <- list()
[16:10:59.945]                 for (kk in seq_along(NAMES)) {
[16:10:59.945]                   name <- changed[[kk]]
[16:10:59.945]                   NAME <- NAMES[[kk]]
[16:10:59.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.945]                     next
[16:10:59.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.945]                 }
[16:10:59.945]                 NAMES <- toupper(added)
[16:10:59.945]                 for (kk in seq_along(NAMES)) {
[16:10:59.945]                   name <- added[[kk]]
[16:10:59.945]                   NAME <- NAMES[[kk]]
[16:10:59.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.945]                     next
[16:10:59.945]                   args[[name]] <- ""
[16:10:59.945]                 }
[16:10:59.945]                 NAMES <- toupper(removed)
[16:10:59.945]                 for (kk in seq_along(NAMES)) {
[16:10:59.945]                   name <- removed[[kk]]
[16:10:59.945]                   NAME <- NAMES[[kk]]
[16:10:59.945]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.945]                     next
[16:10:59.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.945]                 }
[16:10:59.945]                 if (length(args) > 0) 
[16:10:59.945]                   base::do.call(base::Sys.setenv, args = args)
[16:10:59.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:10:59.945]             }
[16:10:59.945]             else {
[16:10:59.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:10:59.945]             }
[16:10:59.945]             {
[16:10:59.945]                 if (base::length(...future.futureOptionsAdded) > 
[16:10:59.945]                   0L) {
[16:10:59.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:10:59.945]                   base::names(opts) <- ...future.futureOptionsAdded
[16:10:59.945]                   base::options(opts)
[16:10:59.945]                 }
[16:10:59.945]                 {
[16:10:59.945]                   {
[16:10:59.945]                     NULL
[16:10:59.945]                     RNGkind("Mersenne-Twister")
[16:10:59.945]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:10:59.945]                       inherits = FALSE)
[16:10:59.945]                   }
[16:10:59.945]                   options(future.plan = NULL)
[16:10:59.945]                   if (is.na(NA_character_)) 
[16:10:59.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:10:59.945]                   future::plan(list(function (..., envir = parent.frame()) 
[16:10:59.945]                   {
[16:10:59.945]                     future <- SequentialFuture(..., envir = envir)
[16:10:59.945]                     if (!future$lazy) 
[16:10:59.945]                       future <- run(future)
[16:10:59.945]                     invisible(future)
[16:10:59.945]                   }), .cleanup = FALSE, .init = FALSE)
[16:10:59.945]                 }
[16:10:59.945]             }
[16:10:59.945]         }
[16:10:59.945]     })
[16:10:59.945]     if (TRUE) {
[16:10:59.945]         base::sink(type = "output", split = FALSE)
[16:10:59.945]         if (TRUE) {
[16:10:59.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:10:59.945]         }
[16:10:59.945]         else {
[16:10:59.945]             ...future.result["stdout"] <- base::list(NULL)
[16:10:59.945]         }
[16:10:59.945]         base::close(...future.stdout)
[16:10:59.945]         ...future.stdout <- NULL
[16:10:59.945]     }
[16:10:59.945]     ...future.result$conditions <- ...future.conditions
[16:10:59.945]     ...future.result$finished <- base::Sys.time()
[16:10:59.945]     ...future.result
[16:10:59.945] }
[16:10:59.947] assign_globals() ...
[16:10:59.947] List of 11
[16:10:59.947]  $ ...future.FUN            :function (x, ...)  
[16:10:59.947]  $ x_FUN                    :function (x)  
[16:10:59.947]  $ times                    : int 2
[16:10:59.947]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.947]  $ stop_if_not              :function (...)  
[16:10:59.947]  $ dim                      : NULL
[16:10:59.947]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:10:59.947]  $ future.call.arguments    : list()
[16:10:59.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.947]  $ ...future.elements_ii    :List of 10
[16:10:59.947]   ..$ : int 1
[16:10:59.947]   ..$ : int 2
[16:10:59.947]   ..$ : int 3
[16:10:59.947]   ..$ : int 4
[16:10:59.947]   ..$ : int 5
[16:10:59.947]   ..$ : int 6
[16:10:59.947]   ..$ : int 7
[16:10:59.947]   ..$ : int 8
[16:10:59.947]   ..$ : int 9
[16:10:59.947]   ..$ : int 10
[16:10:59.947]  $ ...future.seeds_ii       : NULL
[16:10:59.947]  $ ...future.globals.maxSize: NULL
[16:10:59.947]  - attr(*, "resolved")= logi FALSE
[16:10:59.947]  - attr(*, "total_size")= num 96456
[16:10:59.947]  - attr(*, "where")=List of 11
[16:10:59.947]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ times                    :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:10:59.947]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:10:59.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.947]  - attr(*, "already-done")= logi TRUE
[16:10:59.956] - copied ‘...future.FUN’ to environment
[16:10:59.956] - reassign environment for ‘x_FUN’
[16:10:59.956] - copied ‘x_FUN’ to environment
[16:10:59.957] - copied ‘times’ to environment
[16:10:59.957] - copied ‘stopf’ to environment
[16:10:59.957] - copied ‘stop_if_not’ to environment
[16:10:59.957] - copied ‘dim’ to environment
[16:10:59.957] - copied ‘valid_types’ to environment
[16:10:59.957] - copied ‘future.call.arguments’ to environment
[16:10:59.957] - copied ‘...future.elements_ii’ to environment
[16:10:59.957] - copied ‘...future.seeds_ii’ to environment
[16:10:59.957] - copied ‘...future.globals.maxSize’ to environment
[16:10:59.957] assign_globals() ... done
[16:10:59.958] plan(): Setting new future strategy stack:
[16:10:59.958] List of future strategies:
[16:10:59.958] 1. sequential:
[16:10:59.958]    - args: function (..., envir = parent.frame())
[16:10:59.958]    - tweaked: FALSE
[16:10:59.958]    - call: NULL
[16:10:59.958] plan(): nbrOfWorkers() = 1
[16:10:59.959] plan(): Setting new future strategy stack:
[16:10:59.959] List of future strategies:
[16:10:59.959] 1. sequential:
[16:10:59.959]    - args: function (..., envir = parent.frame())
[16:10:59.959]    - tweaked: FALSE
[16:10:59.959]    - call: plan(strategy)
[16:10:59.959] plan(): nbrOfWorkers() = 1
[16:10:59.960] SequentialFuture started (and completed)
[16:10:59.961] - Launch lazy future ... done
[16:10:59.961] run() for ‘SequentialFuture’ ... done
[16:10:59.961] Created future:
[16:10:59.961] SequentialFuture:
[16:10:59.961] Label: ‘future_vapply-1’
[16:10:59.961] Expression:
[16:10:59.961] {
[16:10:59.961]     do.call(function(...) {
[16:10:59.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.961]             on.exit(options(oopts), add = TRUE)
[16:10:59.961]         }
[16:10:59.961]         {
[16:10:59.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.961]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.961]             })
[16:10:59.961]         }
[16:10:59.961]     }, args = future.call.arguments)
[16:10:59.961] }
[16:10:59.961] Lazy evaluation: FALSE
[16:10:59.961] Asynchronous evaluation: FALSE
[16:10:59.961] Local evaluation: TRUE
[16:10:59.961] Environment: R_GlobalEnv
[16:10:59.961] Capture standard output: TRUE
[16:10:59.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:10:59.961] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:10:59.961] Packages: 1 packages (‘future.apply’)
[16:10:59.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:10:59.961] Resolved: TRUE
[16:10:59.961] Value: 640 bytes of class ‘list’
[16:10:59.961] Early signaling: FALSE
[16:10:59.961] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:10:59.961] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.962] Chunk #1 of 1 ... DONE
[16:10:59.962] Launching 1 futures (chunks) ... DONE
[16:10:59.962] Resolving 1 futures (chunks) ...
[16:10:59.962] resolve() on list ...
[16:10:59.963]  recursive: 0
[16:10:59.963]  length: 1
[16:10:59.963] 
[16:10:59.963] resolved() for ‘SequentialFuture’ ...
[16:10:59.963] - state: ‘finished’
[16:10:59.963] - run: TRUE
[16:10:59.963] - result: ‘FutureResult’
[16:10:59.963] resolved() for ‘SequentialFuture’ ... done
[16:10:59.963] Future #1
[16:10:59.963] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:10:59.963] - nx: 1
[16:10:59.964] - relay: TRUE
[16:10:59.964] - stdout: TRUE
[16:10:59.964] - signal: TRUE
[16:10:59.964] - resignal: FALSE
[16:10:59.964] - force: TRUE
[16:10:59.964] - relayed: [n=1] FALSE
[16:10:59.964] - queued futures: [n=1] FALSE
[16:10:59.964]  - until=1
[16:10:59.964]  - relaying element #1
[16:10:59.964] - relayed: [n=1] TRUE
[16:10:59.965] - queued futures: [n=1] TRUE
[16:10:59.965] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:10:59.965]  length: 0 (resolved future 1)
[16:10:59.965] Relaying remaining futures
[16:10:59.965] signalConditionsASAP(NULL, pos=0) ...
[16:10:59.965] - nx: 1
[16:10:59.965] - relay: TRUE
[16:10:59.965] - stdout: TRUE
[16:10:59.965] - signal: TRUE
[16:10:59.965] - resignal: FALSE
[16:10:59.965] - force: TRUE
[16:10:59.965] - relayed: [n=1] TRUE
[16:10:59.966] - queued futures: [n=1] TRUE
 - flush all
[16:10:59.966] - relayed: [n=1] TRUE
[16:10:59.966] - queued futures: [n=1] TRUE
[16:10:59.966] signalConditionsASAP(NULL, pos=0) ... done
[16:10:59.966] resolve() on list ... DONE
[16:10:59.966]  - Number of value chunks collected: 1
[16:10:59.966] Resolving 1 futures (chunks) ... DONE
[16:10:59.966] Reducing values from 1 chunks ...
[16:10:59.966]  - Number of values collected after concatenation: 10
[16:10:59.966]  - Number of values expected: 10
[16:10:59.966] Reducing values from 1 chunks ... DONE
[16:10:59.967] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:10:59.967] future_lapply() ...
[16:10:59.969] Number of chunks: 1
[16:10:59.969] getGlobalsAndPackagesXApply() ...
[16:10:59.969]  - future.globals: TRUE
[16:10:59.969] getGlobalsAndPackages() ...
[16:10:59.969] Searching for globals...
[16:10:59.973] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:10:59.973] Searching for globals ... DONE
[16:10:59.973] Resolving globals: FALSE
[16:10:59.974] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:10:59.974] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:10:59.974] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.974] - packages: [1] ‘future.apply’
[16:10:59.974] getGlobalsAndPackages() ... DONE
[16:10:59.974]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:10:59.975]  - needed namespaces: [n=1] ‘future.apply’
[16:10:59.975] Finding globals ... DONE
[16:10:59.975]  - use_args: TRUE
[16:10:59.975]  - Getting '...' globals ...
[16:10:59.975] resolve() on list ...
[16:10:59.975]  recursive: 0
[16:10:59.975]  length: 1
[16:10:59.975]  elements: ‘...’
[16:10:59.975]  length: 0 (resolved future 1)
[16:10:59.976] resolve() on list ... DONE
[16:10:59.976]    - '...' content: [n=0] 
[16:10:59.976] List of 1
[16:10:59.976]  $ ...: list()
[16:10:59.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.976]  - attr(*, "where")=List of 1
[16:10:59.976]   ..$ ...:<environment: 0x561e88decbc8> 
[16:10:59.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.976]  - attr(*, "resolved")= logi TRUE
[16:10:59.976]  - attr(*, "total_size")= num NA
[16:10:59.978]  - Getting '...' globals ... DONE
[16:10:59.978] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:10:59.978] List of 8
[16:10:59.978]  $ ...future.FUN:function (x, ...)  
[16:10:59.978]  $ x_FUN        :function (x)  
[16:10:59.978]  $ times        : int 4
[16:10:59.978]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.978]  $ stop_if_not  :function (...)  
[16:10:59.978]  $ dim          : int [1:2] 2 2
[16:10:59.978]  $ valid_types  : chr [1:2] "logical" "integer"
[16:10:59.978]  $ ...          : list()
[16:10:59.978]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.978]  - attr(*, "where")=List of 8
[16:10:59.978]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:10:59.978]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:10:59.978]   ..$ times        :<environment: R_EmptyEnv> 
[16:10:59.978]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:10:59.978]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:10:59.978]   ..$ dim          :<environment: R_EmptyEnv> 
[16:10:59.978]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:10:59.978]   ..$ ...          :<environment: 0x561e88decbc8> 
[16:10:59.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.978]  - attr(*, "resolved")= logi FALSE
[16:10:59.978]  - attr(*, "total_size")= num 97232
[16:10:59.985] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:10:59.985] getGlobalsAndPackagesXApply() ... DONE
[16:10:59.985] Number of futures (= number of chunks): 1
[16:10:59.985] Launching 1 futures (chunks) ...
[16:10:59.985] Chunk #1 of 1 ...
[16:10:59.985]  - Finding globals in 'X' for chunk #1 ...
[16:10:59.985] getGlobalsAndPackages() ...
[16:10:59.985] Searching for globals...
[16:10:59.986] 
[16:10:59.986] Searching for globals ... DONE
[16:10:59.986] - globals: [0] <none>
[16:10:59.986] getGlobalsAndPackages() ... DONE
[16:10:59.986]    + additional globals found: [n=0] 
[16:10:59.986]    + additional namespaces needed: [n=0] 
[16:10:59.986]  - Finding globals in 'X' for chunk #1 ... DONE
[16:10:59.986]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[16:10:59.986]  - seeds: <none>
[16:10:59.987] getGlobalsAndPackages() ...
[16:10:59.987] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.987] Resolving globals: FALSE
[16:10:59.987] Tweak future expression to call with '...' arguments ...
[16:10:59.987] {
[16:10:59.987]     do.call(function(...) {
[16:10:59.987]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.987]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:10:59.987]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.987]             on.exit(options(oopts), add = TRUE)
[16:10:59.987]         }
[16:10:59.987]         {
[16:10:59.987]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:10:59.987]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.987]                 ...future.FUN(...future.X_jj, ...)
[16:10:59.987]             })
[16:10:59.987]         }
[16:10:59.987]     }, args = future.call.arguments)
[16:10:59.987] }
[16:10:59.987] Tweak future expression to call with '...' arguments ... DONE
[16:10:59.988] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:10:59.988] - packages: [1] ‘future.apply’
[16:10:59.988] getGlobalsAndPackages() ... DONE
[16:10:59.988] run() for ‘Future’ ...
[16:10:59.988] - state: ‘created’
[16:10:59.988] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:10:59.989] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:10:59.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:10:59.989]   - Field: ‘label’
[16:10:59.989]   - Field: ‘local’
[16:10:59.989]   - Field: ‘owner’
[16:10:59.989]   - Field: ‘envir’
[16:10:59.989]   - Field: ‘packages’
[16:10:59.989]   - Field: ‘gc’
[16:10:59.989]   - Field: ‘conditions’
[16:10:59.990]   - Field: ‘expr’
[16:10:59.990]   - Field: ‘uuid’
[16:10:59.990]   - Field: ‘seed’
[16:10:59.990]   - Field: ‘version’
[16:10:59.990]   - Field: ‘result’
[16:10:59.990]   - Field: ‘asynchronous’
[16:10:59.990]   - Field: ‘calls’
[16:10:59.990]   - Field: ‘globals’
[16:10:59.990]   - Field: ‘stdout’
[16:10:59.990]   - Field: ‘earlySignal’
[16:10:59.990]   - Field: ‘lazy’
[16:10:59.990]   - Field: ‘state’
[16:10:59.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:10:59.991] - Launch lazy future ...
[16:10:59.991] Packages needed by the future expression (n = 1): ‘future.apply’
[16:10:59.991] Packages needed by future strategies (n = 0): <none>
[16:10:59.991] {
[16:10:59.991]     {
[16:10:59.991]         {
[16:10:59.991]             ...future.startTime <- base::Sys.time()
[16:10:59.991]             {
[16:10:59.991]                 {
[16:10:59.991]                   {
[16:10:59.991]                     {
[16:10:59.991]                       base::local({
[16:10:59.991]                         has_future <- base::requireNamespace("future", 
[16:10:59.991]                           quietly = TRUE)
[16:10:59.991]                         if (has_future) {
[16:10:59.991]                           ns <- base::getNamespace("future")
[16:10:59.991]                           version <- ns[[".package"]][["version"]]
[16:10:59.991]                           if (is.null(version)) 
[16:10:59.991]                             version <- utils::packageVersion("future")
[16:10:59.991]                         }
[16:10:59.991]                         else {
[16:10:59.991]                           version <- NULL
[16:10:59.991]                         }
[16:10:59.991]                         if (!has_future || version < "1.8.0") {
[16:10:59.991]                           info <- base::c(r_version = base::gsub("R version ", 
[16:10:59.991]                             "", base::R.version$version.string), 
[16:10:59.991]                             platform = base::sprintf("%s (%s-bit)", 
[16:10:59.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:10:59.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:10:59.991]                               "release", "version")], collapse = " "), 
[16:10:59.991]                             hostname = base::Sys.info()[["nodename"]])
[16:10:59.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:10:59.991]                             info)
[16:10:59.991]                           info <- base::paste(info, collapse = "; ")
[16:10:59.991]                           if (!has_future) {
[16:10:59.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:10:59.991]                               info)
[16:10:59.991]                           }
[16:10:59.991]                           else {
[16:10:59.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:10:59.991]                               info, version)
[16:10:59.991]                           }
[16:10:59.991]                           base::stop(msg)
[16:10:59.991]                         }
[16:10:59.991]                       })
[16:10:59.991]                     }
[16:10:59.991]                     base::local({
[16:10:59.991]                       for (pkg in "future.apply") {
[16:10:59.991]                         base::loadNamespace(pkg)
[16:10:59.991]                         base::library(pkg, character.only = TRUE)
[16:10:59.991]                       }
[16:10:59.991]                     })
[16:10:59.991]                   }
[16:10:59.991]                   options(future.plan = NULL)
[16:10:59.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:10:59.991]                 }
[16:10:59.991]                 ...future.workdir <- getwd()
[16:10:59.991]             }
[16:10:59.991]             ...future.oldOptions <- base::as.list(base::.Options)
[16:10:59.991]             ...future.oldEnvVars <- base::Sys.getenv()
[16:10:59.991]         }
[16:10:59.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:10:59.991]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[16:10:59.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:10:59.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:10:59.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:10:59.991]             future.stdout.windows.reencode = NULL, width = 80L)
[16:10:59.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:10:59.991]             base::names(...future.oldOptions))
[16:10:59.991]     }
[16:10:59.991]     if (FALSE) {
[16:10:59.991]     }
[16:10:59.991]     else {
[16:10:59.991]         if (TRUE) {
[16:10:59.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:10:59.991]                 open = "w")
[16:10:59.991]         }
[16:10:59.991]         else {
[16:10:59.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:10:59.991]                 windows = "NUL", "/dev/null"), open = "w")
[16:10:59.991]         }
[16:10:59.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:10:59.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:10:59.991]             base::sink(type = "output", split = FALSE)
[16:10:59.991]             base::close(...future.stdout)
[16:10:59.991]         }, add = TRUE)
[16:10:59.991]     }
[16:10:59.991]     ...future.frame <- base::sys.nframe()
[16:10:59.991]     ...future.conditions <- base::list()
[16:10:59.991]     ...future.rng <- base::globalenv()$.Random.seed
[16:10:59.991]     if (FALSE) {
[16:10:59.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:10:59.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:10:59.991]     }
[16:10:59.991]     ...future.result <- base::tryCatch({
[16:10:59.991]         base::withCallingHandlers({
[16:10:59.991]             ...future.value <- base::withVisible(base::local({
[16:10:59.991]                 do.call(function(...) {
[16:10:59.991]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:10:59.991]                   if (!identical(...future.globals.maxSize.org, 
[16:10:59.991]                     ...future.globals.maxSize)) {
[16:10:59.991]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:10:59.991]                     on.exit(options(oopts), add = TRUE)
[16:10:59.991]                   }
[16:10:59.991]                   {
[16:10:59.991]                     lapply(seq_along(...future.elements_ii), 
[16:10:59.991]                       FUN = function(jj) {
[16:10:59.991]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:10:59.991]                         ...future.FUN(...future.X_jj, ...)
[16:10:59.991]                       })
[16:10:59.991]                   }
[16:10:59.991]                 }, args = future.call.arguments)
[16:10:59.991]             }))
[16:10:59.991]             future::FutureResult(value = ...future.value$value, 
[16:10:59.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.991]                   ...future.rng), globalenv = if (FALSE) 
[16:10:59.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:10:59.991]                     ...future.globalenv.names))
[16:10:59.991]                 else NULL, started = ...future.startTime, version = "1.8")
[16:10:59.991]         }, condition = base::local({
[16:10:59.991]             c <- base::c
[16:10:59.991]             inherits <- base::inherits
[16:10:59.991]             invokeRestart <- base::invokeRestart
[16:10:59.991]             length <- base::length
[16:10:59.991]             list <- base::list
[16:10:59.991]             seq.int <- base::seq.int
[16:10:59.991]             signalCondition <- base::signalCondition
[16:10:59.991]             sys.calls <- base::sys.calls
[16:10:59.991]             `[[` <- base::`[[`
[16:10:59.991]             `+` <- base::`+`
[16:10:59.991]             `<<-` <- base::`<<-`
[16:10:59.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:10:59.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:10:59.991]                   3L)]
[16:10:59.991]             }
[16:10:59.991]             function(cond) {
[16:10:59.991]                 is_error <- inherits(cond, "error")
[16:10:59.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:10:59.991]                   NULL)
[16:10:59.991]                 if (is_error) {
[16:10:59.991]                   sessionInformation <- function() {
[16:10:59.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:10:59.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:10:59.991]                       search = base::search(), system = base::Sys.info())
[16:10:59.991]                   }
[16:10:59.991]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:10:59.991]                     cond$call), session = sessionInformation(), 
[16:10:59.991]                     timestamp = base::Sys.time(), signaled = 0L)
[16:10:59.991]                   signalCondition(cond)
[16:10:59.991]                 }
[16:10:59.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:10:59.991]                 "immediateCondition"))) {
[16:10:59.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:10:59.991]                   ...future.conditions[[length(...future.conditions) + 
[16:10:59.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:10:59.991]                   if (TRUE && !signal) {
[16:10:59.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.991]                     {
[16:10:59.991]                       inherits <- base::inherits
[16:10:59.991]                       invokeRestart <- base::invokeRestart
[16:10:59.991]                       is.null <- base::is.null
[16:10:59.991]                       muffled <- FALSE
[16:10:59.991]                       if (inherits(cond, "message")) {
[16:10:59.991]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.991]                         if (muffled) 
[16:10:59.991]                           invokeRestart("muffleMessage")
[16:10:59.991]                       }
[16:10:59.991]                       else if (inherits(cond, "warning")) {
[16:10:59.991]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.991]                         if (muffled) 
[16:10:59.991]                           invokeRestart("muffleWarning")
[16:10:59.991]                       }
[16:10:59.991]                       else if (inherits(cond, "condition")) {
[16:10:59.991]                         if (!is.null(pattern)) {
[16:10:59.991]                           computeRestarts <- base::computeRestarts
[16:10:59.991]                           grepl <- base::grepl
[16:10:59.991]                           restarts <- computeRestarts(cond)
[16:10:59.991]                           for (restart in restarts) {
[16:10:59.991]                             name <- restart$name
[16:10:59.991]                             if (is.null(name)) 
[16:10:59.991]                               next
[16:10:59.991]                             if (!grepl(pattern, name)) 
[16:10:59.991]                               next
[16:10:59.991]                             invokeRestart(restart)
[16:10:59.991]                             muffled <- TRUE
[16:10:59.991]                             break
[16:10:59.991]                           }
[16:10:59.991]                         }
[16:10:59.991]                       }
[16:10:59.991]                       invisible(muffled)
[16:10:59.991]                     }
[16:10:59.991]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.991]                   }
[16:10:59.991]                 }
[16:10:59.991]                 else {
[16:10:59.991]                   if (TRUE) {
[16:10:59.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:10:59.991]                     {
[16:10:59.991]                       inherits <- base::inherits
[16:10:59.991]                       invokeRestart <- base::invokeRestart
[16:10:59.991]                       is.null <- base::is.null
[16:10:59.991]                       muffled <- FALSE
[16:10:59.991]                       if (inherits(cond, "message")) {
[16:10:59.991]                         muffled <- grepl(pattern, "muffleMessage")
[16:10:59.991]                         if (muffled) 
[16:10:59.991]                           invokeRestart("muffleMessage")
[16:10:59.991]                       }
[16:10:59.991]                       else if (inherits(cond, "warning")) {
[16:10:59.991]                         muffled <- grepl(pattern, "muffleWarning")
[16:10:59.991]                         if (muffled) 
[16:10:59.991]                           invokeRestart("muffleWarning")
[16:10:59.991]                       }
[16:10:59.991]                       else if (inherits(cond, "condition")) {
[16:10:59.991]                         if (!is.null(pattern)) {
[16:10:59.991]                           computeRestarts <- base::computeRestarts
[16:10:59.991]                           grepl <- base::grepl
[16:10:59.991]                           restarts <- computeRestarts(cond)
[16:10:59.991]                           for (restart in restarts) {
[16:10:59.991]                             name <- restart$name
[16:10:59.991]                             if (is.null(name)) 
[16:10:59.991]                               next
[16:10:59.991]                             if (!grepl(pattern, name)) 
[16:10:59.991]                               next
[16:10:59.991]                             invokeRestart(restart)
[16:10:59.991]                             muffled <- TRUE
[16:10:59.991]                             break
[16:10:59.991]                           }
[16:10:59.991]                         }
[16:10:59.991]                       }
[16:10:59.991]                       invisible(muffled)
[16:10:59.991]                     }
[16:10:59.991]                     muffleCondition(cond, pattern = "^muffle")
[16:10:59.991]                   }
[16:10:59.991]                 }
[16:10:59.991]             }
[16:10:59.991]         }))
[16:10:59.991]     }, error = function(ex) {
[16:10:59.991]         base::structure(base::list(value = NULL, visible = NULL, 
[16:10:59.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:10:59.991]                 ...future.rng), started = ...future.startTime, 
[16:10:59.991]             finished = Sys.time(), session_uuid = NA_character_, 
[16:10:59.991]             version = "1.8"), class = "FutureResult")
[16:10:59.991]     }, finally = {
[16:10:59.991]         if (!identical(...future.workdir, getwd())) 
[16:10:59.991]             setwd(...future.workdir)
[16:10:59.991]         {
[16:10:59.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:10:59.991]                 ...future.oldOptions$nwarnings <- NULL
[16:10:59.991]             }
[16:10:59.991]             base::options(...future.oldOptions)
[16:10:59.991]             if (.Platform$OS.type == "windows") {
[16:10:59.991]                 old_names <- names(...future.oldEnvVars)
[16:10:59.991]                 envs <- base::Sys.getenv()
[16:10:59.991]                 names <- names(envs)
[16:10:59.991]                 common <- intersect(names, old_names)
[16:10:59.991]                 added <- setdiff(names, old_names)
[16:10:59.991]                 removed <- setdiff(old_names, names)
[16:10:59.991]                 changed <- common[...future.oldEnvVars[common] != 
[16:10:59.991]                   envs[common]]
[16:10:59.991]                 NAMES <- toupper(changed)
[16:10:59.991]                 args <- list()
[16:10:59.991]                 for (kk in seq_along(NAMES)) {
[16:10:59.991]                   name <- changed[[kk]]
[16:10:59.991]                   NAME <- NAMES[[kk]]
[16:10:59.991]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.991]                     next
[16:10:59.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.991]                 }
[16:10:59.991]                 NAMES <- toupper(added)
[16:10:59.991]                 for (kk in seq_along(NAMES)) {
[16:10:59.991]                   name <- added[[kk]]
[16:10:59.991]                   NAME <- NAMES[[kk]]
[16:10:59.991]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.991]                     next
[16:10:59.991]                   args[[name]] <- ""
[16:10:59.991]                 }
[16:10:59.991]                 NAMES <- toupper(removed)
[16:10:59.991]                 for (kk in seq_along(NAMES)) {
[16:10:59.991]                   name <- removed[[kk]]
[16:10:59.991]                   NAME <- NAMES[[kk]]
[16:10:59.991]                   if (name != NAME && is.element(NAME, old_names)) 
[16:10:59.991]                     next
[16:10:59.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:10:59.991]                 }
[16:10:59.991]                 if (length(args) > 0) 
[16:10:59.991]                   base::do.call(base::Sys.setenv, args = args)
[16:10:59.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:10:59.991]             }
[16:10:59.991]             else {
[16:10:59.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:10:59.991]             }
[16:10:59.991]             {
[16:10:59.991]                 if (base::length(...future.futureOptionsAdded) > 
[16:10:59.991]                   0L) {
[16:10:59.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:10:59.991]                   base::names(opts) <- ...future.futureOptionsAdded
[16:10:59.991]                   base::options(opts)
[16:10:59.991]                 }
[16:10:59.991]                 {
[16:10:59.991]                   {
[16:10:59.991]                     NULL
[16:10:59.991]                     RNGkind("Mersenne-Twister")
[16:10:59.991]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:10:59.991]                       inherits = FALSE)
[16:10:59.991]                   }
[16:10:59.991]                   options(future.plan = NULL)
[16:10:59.991]                   if (is.na(NA_character_)) 
[16:10:59.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:10:59.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:10:59.991]                   future::plan(list(function (..., envir = parent.frame()) 
[16:10:59.991]                   {
[16:10:59.991]                     future <- SequentialFuture(..., envir = envir)
[16:10:59.991]                     if (!future$lazy) 
[16:10:59.991]                       future <- run(future)
[16:10:59.991]                     invisible(future)
[16:10:59.991]                   }), .cleanup = FALSE, .init = FALSE)
[16:10:59.991]                 }
[16:10:59.991]             }
[16:10:59.991]         }
[16:10:59.991]     })
[16:10:59.991]     if (TRUE) {
[16:10:59.991]         base::sink(type = "output", split = FALSE)
[16:10:59.991]         if (TRUE) {
[16:10:59.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:10:59.991]         }
[16:10:59.991]         else {
[16:10:59.991]             ...future.result["stdout"] <- base::list(NULL)
[16:10:59.991]         }
[16:10:59.991]         base::close(...future.stdout)
[16:10:59.991]         ...future.stdout <- NULL
[16:10:59.991]     }
[16:10:59.991]     ...future.result$conditions <- ...future.conditions
[16:10:59.991]     ...future.result$finished <- base::Sys.time()
[16:10:59.991]     ...future.result
[16:10:59.991] }
[16:10:59.993] assign_globals() ...
[16:10:59.993] List of 11
[16:10:59.993]  $ ...future.FUN            :function (x, ...)  
[16:10:59.993]  $ x_FUN                    :function (x)  
[16:10:59.993]  $ times                    : int 4
[16:10:59.993]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:10:59.993]  $ stop_if_not              :function (...)  
[16:10:59.993]  $ dim                      : int [1:2] 2 2
[16:10:59.993]  $ valid_types              : chr [1:2] "logical" "integer"
[16:10:59.993]  $ future.call.arguments    : list()
[16:10:59.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:10:59.993]  $ ...future.elements_ii    :List of 10
[16:10:59.993]   ..$ : int 1
[16:10:59.993]   ..$ : int 2
[16:10:59.993]   ..$ : int 3
[16:10:59.993]   ..$ : int 4
[16:10:59.993]   ..$ : int 5
[16:10:59.993]   ..$ : int 6
[16:10:59.993]   ..$ : int 7
[16:10:59.993]   ..$ : int 8
[16:10:59.993]   ..$ : int 9
[16:10:59.993]   ..$ : int 10
[16:10:59.993]  $ ...future.seeds_ii       : NULL
[16:10:59.993]  $ ...future.globals.maxSize: NULL
[16:10:59.993]  - attr(*, "resolved")= logi FALSE
[16:10:59.993]  - attr(*, "total_size")= num 97232
[16:10:59.993]  - attr(*, "where")=List of 11
[16:10:59.993]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ times                    :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:10:59.993]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:10:59.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:10:59.993]  - attr(*, "already-done")= logi TRUE
[16:11:00.004] - copied ‘...future.FUN’ to environment
[16:11:00.004] - reassign environment for ‘x_FUN’
[16:11:00.004] - copied ‘x_FUN’ to environment
[16:11:00.004] - copied ‘times’ to environment
[16:11:00.004] - copied ‘stopf’ to environment
[16:11:00.004] - copied ‘stop_if_not’ to environment
[16:11:00.004] - copied ‘dim’ to environment
[16:11:00.004] - copied ‘valid_types’ to environment
[16:11:00.004] - copied ‘future.call.arguments’ to environment
[16:11:00.005] - copied ‘...future.elements_ii’ to environment
[16:11:00.005] - copied ‘...future.seeds_ii’ to environment
[16:11:00.005] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.005] assign_globals() ... done
[16:11:00.005] plan(): Setting new future strategy stack:
[16:11:00.005] List of future strategies:
[16:11:00.005] 1. sequential:
[16:11:00.005]    - args: function (..., envir = parent.frame())
[16:11:00.005]    - tweaked: FALSE
[16:11:00.005]    - call: NULL
[16:11:00.006] plan(): nbrOfWorkers() = 1
[16:11:00.006] plan(): Setting new future strategy stack:
[16:11:00.006] List of future strategies:
[16:11:00.006] 1. sequential:
[16:11:00.006]    - args: function (..., envir = parent.frame())
[16:11:00.006]    - tweaked: FALSE
[16:11:00.006]    - call: plan(strategy)
[16:11:00.007] plan(): nbrOfWorkers() = 1
[16:11:00.007] SequentialFuture started (and completed)
[16:11:00.007] - Launch lazy future ... done
[16:11:00.007] run() for ‘SequentialFuture’ ... done
[16:11:00.007] Created future:
[16:11:00.007] SequentialFuture:
[16:11:00.007] Label: ‘future_vapply-1’
[16:11:00.007] Expression:
[16:11:00.007] {
[16:11:00.007]     do.call(function(...) {
[16:11:00.007]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.007]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.007]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.007]             on.exit(options(oopts), add = TRUE)
[16:11:00.007]         }
[16:11:00.007]         {
[16:11:00.007]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.007]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.007]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.007]             })
[16:11:00.007]         }
[16:11:00.007]     }, args = future.call.arguments)
[16:11:00.007] }
[16:11:00.007] Lazy evaluation: FALSE
[16:11:00.007] Asynchronous evaluation: FALSE
[16:11:00.007] Local evaluation: TRUE
[16:11:00.007] Environment: R_GlobalEnv
[16:11:00.007] Capture standard output: TRUE
[16:11:00.007] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.007] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.007] Packages: 1 packages (‘future.apply’)
[16:11:00.007] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.007] Resolved: TRUE
[16:11:00.007] Value: 2.27 KiB of class ‘list’
[16:11:00.007] Early signaling: FALSE
[16:11:00.007] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.007] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.008] Chunk #1 of 1 ... DONE
[16:11:00.009] Launching 1 futures (chunks) ... DONE
[16:11:00.009] Resolving 1 futures (chunks) ...
[16:11:00.009] resolve() on list ...
[16:11:00.009]  recursive: 0
[16:11:00.009]  length: 1
[16:11:00.009] 
[16:11:00.009] resolved() for ‘SequentialFuture’ ...
[16:11:00.009] - state: ‘finished’
[16:11:00.009] - run: TRUE
[16:11:00.009] - result: ‘FutureResult’
[16:11:00.009] resolved() for ‘SequentialFuture’ ... done
[16:11:00.010] Future #1
[16:11:00.010] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.010] - nx: 1
[16:11:00.010] - relay: TRUE
[16:11:00.010] - stdout: TRUE
[16:11:00.010] - signal: TRUE
[16:11:00.010] - resignal: FALSE
[16:11:00.010] - force: TRUE
[16:11:00.010] - relayed: [n=1] FALSE
[16:11:00.010] - queued futures: [n=1] FALSE
[16:11:00.010]  - until=1
[16:11:00.010]  - relaying element #1
[16:11:00.011] - relayed: [n=1] TRUE
[16:11:00.011] - queued futures: [n=1] TRUE
[16:11:00.011] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.011]  length: 0 (resolved future 1)
[16:11:00.011] Relaying remaining futures
[16:11:00.011] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.011] - nx: 1
[16:11:00.011] - relay: TRUE
[16:11:00.011] - stdout: TRUE
[16:11:00.011] - signal: TRUE
[16:11:00.011] - resignal: FALSE
[16:11:00.012] - force: TRUE
[16:11:00.012] - relayed: [n=1] TRUE
[16:11:00.012] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.012] - relayed: [n=1] TRUE
[16:11:00.012] - queued futures: [n=1] TRUE
[16:11:00.012] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.012] resolve() on list ... DONE
[16:11:00.012]  - Number of value chunks collected: 1
[16:11:00.012] Resolving 1 futures (chunks) ... DONE
[16:11:00.012] Reducing values from 1 chunks ...
[16:11:00.013]  - Number of values collected after concatenation: 10
[16:11:00.013]  - Number of values expected: 10
[16:11:00.013] Reducing values from 1 chunks ... DONE
[16:11:00.013] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:11:00.014] future_lapply() ...
[16:11:00.015] Number of chunks: 1
[16:11:00.015] getGlobalsAndPackagesXApply() ...
[16:11:00.015]  - future.globals: TRUE
[16:11:00.016] getGlobalsAndPackages() ...
[16:11:00.016] Searching for globals...
[16:11:00.019] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:11:00.019] Searching for globals ... DONE
[16:11:00.019] Resolving globals: FALSE
[16:11:00.020] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:11:00.021] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.021] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.022] - packages: [1] ‘future.apply’
[16:11:00.022] getGlobalsAndPackages() ... DONE
[16:11:00.022]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.022]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.022] Finding globals ... DONE
[16:11:00.022]  - use_args: TRUE
[16:11:00.022]  - Getting '...' globals ...
[16:11:00.022] resolve() on list ...
[16:11:00.023]  recursive: 0
[16:11:00.023]  length: 1
[16:11:00.023]  elements: ‘...’
[16:11:00.023]  length: 0 (resolved future 1)
[16:11:00.023] resolve() on list ... DONE
[16:11:00.023]    - '...' content: [n=0] 
[16:11:00.023] List of 1
[16:11:00.023]  $ ...: list()
[16:11:00.023]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.023]  - attr(*, "where")=List of 1
[16:11:00.023]   ..$ ...:<environment: 0x561e8a170788> 
[16:11:00.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.023]  - attr(*, "resolved")= logi TRUE
[16:11:00.023]  - attr(*, "total_size")= num NA
[16:11:00.025]  - Getting '...' globals ... DONE
[16:11:00.026] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.026] List of 8
[16:11:00.026]  $ ...future.FUN:function (x, ...)  
[16:11:00.026]  $ x_FUN        :function (x)  
[16:11:00.026]  $ times        : int 4
[16:11:00.026]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.026]  $ stop_if_not  :function (...)  
[16:11:00.026]  $ dim          : int [1:2] 2 2
[16:11:00.026]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:00.026]  $ ...          : list()
[16:11:00.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.026]  - attr(*, "where")=List of 8
[16:11:00.026]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.026]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.026]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.026]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.026]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.026]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.026]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.026]   ..$ ...          :<environment: 0x561e8a170788> 
[16:11:00.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.026]  - attr(*, "resolved")= logi FALSE
[16:11:00.026]  - attr(*, "total_size")= num 97304
[16:11:00.031] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.031] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.031] Number of futures (= number of chunks): 1
[16:11:00.031] Launching 1 futures (chunks) ...
[16:11:00.031] Chunk #1 of 1 ...
[16:11:00.032]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.032] getGlobalsAndPackages() ...
[16:11:00.032] Searching for globals...
[16:11:00.032] 
[16:11:00.032] Searching for globals ... DONE
[16:11:00.032] - globals: [0] <none>
[16:11:00.032] getGlobalsAndPackages() ... DONE
[16:11:00.032]    + additional globals found: [n=0] 
[16:11:00.032]    + additional namespaces needed: [n=0] 
[16:11:00.033]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.033]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[16:11:00.033]  - seeds: <none>
[16:11:00.033] getGlobalsAndPackages() ...
[16:11:00.033] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.033] Resolving globals: FALSE
[16:11:00.033] Tweak future expression to call with '...' arguments ...
[16:11:00.033] {
[16:11:00.033]     do.call(function(...) {
[16:11:00.033]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.033]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.033]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.033]             on.exit(options(oopts), add = TRUE)
[16:11:00.033]         }
[16:11:00.033]         {
[16:11:00.033]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.033]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.033]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.033]             })
[16:11:00.033]         }
[16:11:00.033]     }, args = future.call.arguments)
[16:11:00.033] }
[16:11:00.034] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.034] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.034] - packages: [1] ‘future.apply’
[16:11:00.034] getGlobalsAndPackages() ... DONE
[16:11:00.034] run() for ‘Future’ ...
[16:11:00.035] - state: ‘created’
[16:11:00.035] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.035] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.035] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.035]   - Field: ‘label’
[16:11:00.035]   - Field: ‘local’
[16:11:00.035]   - Field: ‘owner’
[16:11:00.035]   - Field: ‘envir’
[16:11:00.036]   - Field: ‘packages’
[16:11:00.036]   - Field: ‘gc’
[16:11:00.036]   - Field: ‘conditions’
[16:11:00.036]   - Field: ‘expr’
[16:11:00.036]   - Field: ‘uuid’
[16:11:00.036]   - Field: ‘seed’
[16:11:00.036]   - Field: ‘version’
[16:11:00.036]   - Field: ‘result’
[16:11:00.036]   - Field: ‘asynchronous’
[16:11:00.036]   - Field: ‘calls’
[16:11:00.036]   - Field: ‘globals’
[16:11:00.037]   - Field: ‘stdout’
[16:11:00.037]   - Field: ‘earlySignal’
[16:11:00.037]   - Field: ‘lazy’
[16:11:00.037]   - Field: ‘state’
[16:11:00.037] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.037] - Launch lazy future ...
[16:11:00.037] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.037] Packages needed by future strategies (n = 0): <none>
[16:11:00.038] {
[16:11:00.038]     {
[16:11:00.038]         {
[16:11:00.038]             ...future.startTime <- base::Sys.time()
[16:11:00.038]             {
[16:11:00.038]                 {
[16:11:00.038]                   {
[16:11:00.038]                     {
[16:11:00.038]                       base::local({
[16:11:00.038]                         has_future <- base::requireNamespace("future", 
[16:11:00.038]                           quietly = TRUE)
[16:11:00.038]                         if (has_future) {
[16:11:00.038]                           ns <- base::getNamespace("future")
[16:11:00.038]                           version <- ns[[".package"]][["version"]]
[16:11:00.038]                           if (is.null(version)) 
[16:11:00.038]                             version <- utils::packageVersion("future")
[16:11:00.038]                         }
[16:11:00.038]                         else {
[16:11:00.038]                           version <- NULL
[16:11:00.038]                         }
[16:11:00.038]                         if (!has_future || version < "1.8.0") {
[16:11:00.038]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.038]                             "", base::R.version$version.string), 
[16:11:00.038]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.038]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.038]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.038]                               "release", "version")], collapse = " "), 
[16:11:00.038]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.038]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.038]                             info)
[16:11:00.038]                           info <- base::paste(info, collapse = "; ")
[16:11:00.038]                           if (!has_future) {
[16:11:00.038]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.038]                               info)
[16:11:00.038]                           }
[16:11:00.038]                           else {
[16:11:00.038]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.038]                               info, version)
[16:11:00.038]                           }
[16:11:00.038]                           base::stop(msg)
[16:11:00.038]                         }
[16:11:00.038]                       })
[16:11:00.038]                     }
[16:11:00.038]                     base::local({
[16:11:00.038]                       for (pkg in "future.apply") {
[16:11:00.038]                         base::loadNamespace(pkg)
[16:11:00.038]                         base::library(pkg, character.only = TRUE)
[16:11:00.038]                       }
[16:11:00.038]                     })
[16:11:00.038]                   }
[16:11:00.038]                   options(future.plan = NULL)
[16:11:00.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.038]                 }
[16:11:00.038]                 ...future.workdir <- getwd()
[16:11:00.038]             }
[16:11:00.038]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.038]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.038]         }
[16:11:00.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.038]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[16:11:00.038]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.038]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.038]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.038]             base::names(...future.oldOptions))
[16:11:00.038]     }
[16:11:00.038]     if (FALSE) {
[16:11:00.038]     }
[16:11:00.038]     else {
[16:11:00.038]         if (TRUE) {
[16:11:00.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.038]                 open = "w")
[16:11:00.038]         }
[16:11:00.038]         else {
[16:11:00.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.038]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.038]         }
[16:11:00.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.038]             base::sink(type = "output", split = FALSE)
[16:11:00.038]             base::close(...future.stdout)
[16:11:00.038]         }, add = TRUE)
[16:11:00.038]     }
[16:11:00.038]     ...future.frame <- base::sys.nframe()
[16:11:00.038]     ...future.conditions <- base::list()
[16:11:00.038]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.038]     if (FALSE) {
[16:11:00.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.038]     }
[16:11:00.038]     ...future.result <- base::tryCatch({
[16:11:00.038]         base::withCallingHandlers({
[16:11:00.038]             ...future.value <- base::withVisible(base::local({
[16:11:00.038]                 do.call(function(...) {
[16:11:00.038]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.038]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.038]                     ...future.globals.maxSize)) {
[16:11:00.038]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.038]                     on.exit(options(oopts), add = TRUE)
[16:11:00.038]                   }
[16:11:00.038]                   {
[16:11:00.038]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.038]                       FUN = function(jj) {
[16:11:00.038]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.038]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.038]                       })
[16:11:00.038]                   }
[16:11:00.038]                 }, args = future.call.arguments)
[16:11:00.038]             }))
[16:11:00.038]             future::FutureResult(value = ...future.value$value, 
[16:11:00.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.038]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.038]                     ...future.globalenv.names))
[16:11:00.038]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.038]         }, condition = base::local({
[16:11:00.038]             c <- base::c
[16:11:00.038]             inherits <- base::inherits
[16:11:00.038]             invokeRestart <- base::invokeRestart
[16:11:00.038]             length <- base::length
[16:11:00.038]             list <- base::list
[16:11:00.038]             seq.int <- base::seq.int
[16:11:00.038]             signalCondition <- base::signalCondition
[16:11:00.038]             sys.calls <- base::sys.calls
[16:11:00.038]             `[[` <- base::`[[`
[16:11:00.038]             `+` <- base::`+`
[16:11:00.038]             `<<-` <- base::`<<-`
[16:11:00.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.038]                   3L)]
[16:11:00.038]             }
[16:11:00.038]             function(cond) {
[16:11:00.038]                 is_error <- inherits(cond, "error")
[16:11:00.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.038]                   NULL)
[16:11:00.038]                 if (is_error) {
[16:11:00.038]                   sessionInformation <- function() {
[16:11:00.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.038]                       search = base::search(), system = base::Sys.info())
[16:11:00.038]                   }
[16:11:00.038]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.038]                     cond$call), session = sessionInformation(), 
[16:11:00.038]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.038]                   signalCondition(cond)
[16:11:00.038]                 }
[16:11:00.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.038]                 "immediateCondition"))) {
[16:11:00.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.038]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.038]                   if (TRUE && !signal) {
[16:11:00.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.038]                     {
[16:11:00.038]                       inherits <- base::inherits
[16:11:00.038]                       invokeRestart <- base::invokeRestart
[16:11:00.038]                       is.null <- base::is.null
[16:11:00.038]                       muffled <- FALSE
[16:11:00.038]                       if (inherits(cond, "message")) {
[16:11:00.038]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.038]                         if (muffled) 
[16:11:00.038]                           invokeRestart("muffleMessage")
[16:11:00.038]                       }
[16:11:00.038]                       else if (inherits(cond, "warning")) {
[16:11:00.038]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.038]                         if (muffled) 
[16:11:00.038]                           invokeRestart("muffleWarning")
[16:11:00.038]                       }
[16:11:00.038]                       else if (inherits(cond, "condition")) {
[16:11:00.038]                         if (!is.null(pattern)) {
[16:11:00.038]                           computeRestarts <- base::computeRestarts
[16:11:00.038]                           grepl <- base::grepl
[16:11:00.038]                           restarts <- computeRestarts(cond)
[16:11:00.038]                           for (restart in restarts) {
[16:11:00.038]                             name <- restart$name
[16:11:00.038]                             if (is.null(name)) 
[16:11:00.038]                               next
[16:11:00.038]                             if (!grepl(pattern, name)) 
[16:11:00.038]                               next
[16:11:00.038]                             invokeRestart(restart)
[16:11:00.038]                             muffled <- TRUE
[16:11:00.038]                             break
[16:11:00.038]                           }
[16:11:00.038]                         }
[16:11:00.038]                       }
[16:11:00.038]                       invisible(muffled)
[16:11:00.038]                     }
[16:11:00.038]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.038]                   }
[16:11:00.038]                 }
[16:11:00.038]                 else {
[16:11:00.038]                   if (TRUE) {
[16:11:00.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.038]                     {
[16:11:00.038]                       inherits <- base::inherits
[16:11:00.038]                       invokeRestart <- base::invokeRestart
[16:11:00.038]                       is.null <- base::is.null
[16:11:00.038]                       muffled <- FALSE
[16:11:00.038]                       if (inherits(cond, "message")) {
[16:11:00.038]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.038]                         if (muffled) 
[16:11:00.038]                           invokeRestart("muffleMessage")
[16:11:00.038]                       }
[16:11:00.038]                       else if (inherits(cond, "warning")) {
[16:11:00.038]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.038]                         if (muffled) 
[16:11:00.038]                           invokeRestart("muffleWarning")
[16:11:00.038]                       }
[16:11:00.038]                       else if (inherits(cond, "condition")) {
[16:11:00.038]                         if (!is.null(pattern)) {
[16:11:00.038]                           computeRestarts <- base::computeRestarts
[16:11:00.038]                           grepl <- base::grepl
[16:11:00.038]                           restarts <- computeRestarts(cond)
[16:11:00.038]                           for (restart in restarts) {
[16:11:00.038]                             name <- restart$name
[16:11:00.038]                             if (is.null(name)) 
[16:11:00.038]                               next
[16:11:00.038]                             if (!grepl(pattern, name)) 
[16:11:00.038]                               next
[16:11:00.038]                             invokeRestart(restart)
[16:11:00.038]                             muffled <- TRUE
[16:11:00.038]                             break
[16:11:00.038]                           }
[16:11:00.038]                         }
[16:11:00.038]                       }
[16:11:00.038]                       invisible(muffled)
[16:11:00.038]                     }
[16:11:00.038]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.038]                   }
[16:11:00.038]                 }
[16:11:00.038]             }
[16:11:00.038]         }))
[16:11:00.038]     }, error = function(ex) {
[16:11:00.038]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.038]                 ...future.rng), started = ...future.startTime, 
[16:11:00.038]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.038]             version = "1.8"), class = "FutureResult")
[16:11:00.038]     }, finally = {
[16:11:00.038]         if (!identical(...future.workdir, getwd())) 
[16:11:00.038]             setwd(...future.workdir)
[16:11:00.038]         {
[16:11:00.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.038]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.038]             }
[16:11:00.038]             base::options(...future.oldOptions)
[16:11:00.038]             if (.Platform$OS.type == "windows") {
[16:11:00.038]                 old_names <- names(...future.oldEnvVars)
[16:11:00.038]                 envs <- base::Sys.getenv()
[16:11:00.038]                 names <- names(envs)
[16:11:00.038]                 common <- intersect(names, old_names)
[16:11:00.038]                 added <- setdiff(names, old_names)
[16:11:00.038]                 removed <- setdiff(old_names, names)
[16:11:00.038]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.038]                   envs[common]]
[16:11:00.038]                 NAMES <- toupper(changed)
[16:11:00.038]                 args <- list()
[16:11:00.038]                 for (kk in seq_along(NAMES)) {
[16:11:00.038]                   name <- changed[[kk]]
[16:11:00.038]                   NAME <- NAMES[[kk]]
[16:11:00.038]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.038]                     next
[16:11:00.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.038]                 }
[16:11:00.038]                 NAMES <- toupper(added)
[16:11:00.038]                 for (kk in seq_along(NAMES)) {
[16:11:00.038]                   name <- added[[kk]]
[16:11:00.038]                   NAME <- NAMES[[kk]]
[16:11:00.038]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.038]                     next
[16:11:00.038]                   args[[name]] <- ""
[16:11:00.038]                 }
[16:11:00.038]                 NAMES <- toupper(removed)
[16:11:00.038]                 for (kk in seq_along(NAMES)) {
[16:11:00.038]                   name <- removed[[kk]]
[16:11:00.038]                   NAME <- NAMES[[kk]]
[16:11:00.038]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.038]                     next
[16:11:00.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.038]                 }
[16:11:00.038]                 if (length(args) > 0) 
[16:11:00.038]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.038]             }
[16:11:00.038]             else {
[16:11:00.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.038]             }
[16:11:00.038]             {
[16:11:00.038]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.038]                   0L) {
[16:11:00.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.038]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.038]                   base::options(opts)
[16:11:00.038]                 }
[16:11:00.038]                 {
[16:11:00.038]                   {
[16:11:00.038]                     NULL
[16:11:00.038]                     RNGkind("Mersenne-Twister")
[16:11:00.038]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.038]                       inherits = FALSE)
[16:11:00.038]                   }
[16:11:00.038]                   options(future.plan = NULL)
[16:11:00.038]                   if (is.na(NA_character_)) 
[16:11:00.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.038]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.038]                   {
[16:11:00.038]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.038]                     if (!future$lazy) 
[16:11:00.038]                       future <- run(future)
[16:11:00.038]                     invisible(future)
[16:11:00.038]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.038]                 }
[16:11:00.038]             }
[16:11:00.038]         }
[16:11:00.038]     })
[16:11:00.038]     if (TRUE) {
[16:11:00.038]         base::sink(type = "output", split = FALSE)
[16:11:00.038]         if (TRUE) {
[16:11:00.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.038]         }
[16:11:00.038]         else {
[16:11:00.038]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.038]         }
[16:11:00.038]         base::close(...future.stdout)
[16:11:00.038]         ...future.stdout <- NULL
[16:11:00.038]     }
[16:11:00.038]     ...future.result$conditions <- ...future.conditions
[16:11:00.038]     ...future.result$finished <- base::Sys.time()
[16:11:00.038]     ...future.result
[16:11:00.038] }
[16:11:00.039] assign_globals() ...
[16:11:00.040] List of 11
[16:11:00.040]  $ ...future.FUN            :function (x, ...)  
[16:11:00.040]  $ x_FUN                    :function (x)  
[16:11:00.040]  $ times                    : int 4
[16:11:00.040]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.040]  $ stop_if_not              :function (...)  
[16:11:00.040]  $ dim                      : int [1:2] 2 2
[16:11:00.040]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.040]  $ future.call.arguments    : list()
[16:11:00.040]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.040]  $ ...future.elements_ii    :List of 10
[16:11:00.040]   ..$ : int 1
[16:11:00.040]   ..$ : int 2
[16:11:00.040]   ..$ : int 3
[16:11:00.040]   ..$ : int 4
[16:11:00.040]   ..$ : int 5
[16:11:00.040]   ..$ : int 6
[16:11:00.040]   ..$ : int 7
[16:11:00.040]   ..$ : int 8
[16:11:00.040]   ..$ : int 9
[16:11:00.040]   ..$ : int 10
[16:11:00.040]  $ ...future.seeds_ii       : NULL
[16:11:00.040]  $ ...future.globals.maxSize: NULL
[16:11:00.040]  - attr(*, "resolved")= logi FALSE
[16:11:00.040]  - attr(*, "total_size")= num 97304
[16:11:00.040]  - attr(*, "where")=List of 11
[16:11:00.040]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.040]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.040]  - attr(*, "already-done")= logi TRUE
[16:11:00.073] - copied ‘...future.FUN’ to environment
[16:11:00.073] - reassign environment for ‘x_FUN’
[16:11:00.073] - copied ‘x_FUN’ to environment
[16:11:00.073] - copied ‘times’ to environment
[16:11:00.073] - copied ‘stopf’ to environment
[16:11:00.074] - copied ‘stop_if_not’ to environment
[16:11:00.074] - copied ‘dim’ to environment
[16:11:00.074] - copied ‘valid_types’ to environment
[16:11:00.074] - copied ‘future.call.arguments’ to environment
[16:11:00.074] - copied ‘...future.elements_ii’ to environment
[16:11:00.074] - copied ‘...future.seeds_ii’ to environment
[16:11:00.074] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.074] assign_globals() ... done
[16:11:00.075] plan(): Setting new future strategy stack:
[16:11:00.075] List of future strategies:
[16:11:00.075] 1. sequential:
[16:11:00.075]    - args: function (..., envir = parent.frame())
[16:11:00.075]    - tweaked: FALSE
[16:11:00.075]    - call: NULL
[16:11:00.075] plan(): nbrOfWorkers() = 1
[16:11:00.076] plan(): Setting new future strategy stack:
[16:11:00.076] List of future strategies:
[16:11:00.076] 1. sequential:
[16:11:00.076]    - args: function (..., envir = parent.frame())
[16:11:00.076]    - tweaked: FALSE
[16:11:00.076]    - call: plan(strategy)
[16:11:00.076] plan(): nbrOfWorkers() = 1
[16:11:00.077] SequentialFuture started (and completed)
[16:11:00.077] - Launch lazy future ... done
[16:11:00.077] run() for ‘SequentialFuture’ ... done
[16:11:00.077] Created future:
[16:11:00.077] SequentialFuture:
[16:11:00.077] Label: ‘future_vapply-1’
[16:11:00.077] Expression:
[16:11:00.077] {
[16:11:00.077]     do.call(function(...) {
[16:11:00.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.077]             on.exit(options(oopts), add = TRUE)
[16:11:00.077]         }
[16:11:00.077]         {
[16:11:00.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.077]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.077]             })
[16:11:00.077]         }
[16:11:00.077]     }, args = future.call.arguments)
[16:11:00.077] }
[16:11:00.077] Lazy evaluation: FALSE
[16:11:00.077] Asynchronous evaluation: FALSE
[16:11:00.077] Local evaluation: TRUE
[16:11:00.077] Environment: R_GlobalEnv
[16:11:00.077] Capture standard output: TRUE
[16:11:00.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.077] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.077] Packages: 1 packages (‘future.apply’)
[16:11:00.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.077] Resolved: TRUE
[16:11:00.077] Value: 2.27 KiB of class ‘list’
[16:11:00.077] Early signaling: FALSE
[16:11:00.077] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.077] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.078] Chunk #1 of 1 ... DONE
[16:11:00.078] Launching 1 futures (chunks) ... DONE
[16:11:00.078] Resolving 1 futures (chunks) ...
[16:11:00.078] resolve() on list ...
[16:11:00.078]  recursive: 0
[16:11:00.079]  length: 1
[16:11:00.079] 
[16:11:00.079] resolved() for ‘SequentialFuture’ ...
[16:11:00.079] - state: ‘finished’
[16:11:00.079] - run: TRUE
[16:11:00.079] - result: ‘FutureResult’
[16:11:00.079] resolved() for ‘SequentialFuture’ ... done
[16:11:00.079] Future #1
[16:11:00.079] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.079] - nx: 1
[16:11:00.080] - relay: TRUE
[16:11:00.080] - stdout: TRUE
[16:11:00.080] - signal: TRUE
[16:11:00.080] - resignal: FALSE
[16:11:00.080] - force: TRUE
[16:11:00.080] - relayed: [n=1] FALSE
[16:11:00.080] - queued futures: [n=1] FALSE
[16:11:00.080]  - until=1
[16:11:00.080]  - relaying element #1
[16:11:00.080] - relayed: [n=1] TRUE
[16:11:00.080] - queued futures: [n=1] TRUE
[16:11:00.081] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.081]  length: 0 (resolved future 1)
[16:11:00.081] Relaying remaining futures
[16:11:00.081] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.081] - nx: 1
[16:11:00.081] - relay: TRUE
[16:11:00.081] - stdout: TRUE
[16:11:00.081] - signal: TRUE
[16:11:00.081] - resignal: FALSE
[16:11:00.081] - force: TRUE
[16:11:00.081] - relayed: [n=1] TRUE
[16:11:00.081] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.082] - relayed: [n=1] TRUE
[16:11:00.082] - queued futures: [n=1] TRUE
[16:11:00.082] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.082] resolve() on list ... DONE
[16:11:00.082]  - Number of value chunks collected: 1
[16:11:00.082] Resolving 1 futures (chunks) ... DONE
[16:11:00.082] Reducing values from 1 chunks ...
[16:11:00.082]  - Number of values collected after concatenation: 10
[16:11:00.082]  - Number of values expected: 10
[16:11:00.082] Reducing values from 1 chunks ... DONE
[16:11:00.083] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:11:00.084] future_lapply() ...
[16:11:00.086] Number of chunks: 1
[16:11:00.086] getGlobalsAndPackagesXApply() ...
[16:11:00.086]  - future.globals: TRUE
[16:11:00.086] getGlobalsAndPackages() ...
[16:11:00.086] Searching for globals...
[16:11:00.091] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:11:00.091] Searching for globals ... DONE
[16:11:00.091] Resolving globals: FALSE
[16:11:00.092] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:11:00.092] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.093] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.093] - packages: [1] ‘future.apply’
[16:11:00.093] getGlobalsAndPackages() ... DONE
[16:11:00.093]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.093]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.093] Finding globals ... DONE
[16:11:00.093]  - use_args: TRUE
[16:11:00.093]  - Getting '...' globals ...
[16:11:00.094] resolve() on list ...
[16:11:00.094]  recursive: 0
[16:11:00.094]  length: 1
[16:11:00.094]  elements: ‘...’
[16:11:00.094]  length: 0 (resolved future 1)
[16:11:00.094] resolve() on list ... DONE
[16:11:00.094]    - '...' content: [n=0] 
[16:11:00.094] List of 1
[16:11:00.094]  $ ...: list()
[16:11:00.094]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.094]  - attr(*, "where")=List of 1
[16:11:00.094]   ..$ ...:<environment: 0x561e8a7367f0> 
[16:11:00.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.094]  - attr(*, "resolved")= logi TRUE
[16:11:00.094]  - attr(*, "total_size")= num NA
[16:11:00.097]  - Getting '...' globals ... DONE
[16:11:00.097] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.097] List of 8
[16:11:00.097]  $ ...future.FUN:function (x, ...)  
[16:11:00.097]  $ x_FUN        :function (x)  
[16:11:00.097]  $ times        : int 4
[16:11:00.097]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.097]  $ stop_if_not  :function (...)  
[16:11:00.097]  $ dim          : int [1:2] 2 2
[16:11:00.097]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:00.097]  $ ...          : list()
[16:11:00.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.097]  - attr(*, "where")=List of 8
[16:11:00.097]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.097]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.097]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.097]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.097]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.097]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.097]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.097]   ..$ ...          :<environment: 0x561e8a7367f0> 
[16:11:00.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.097]  - attr(*, "resolved")= logi FALSE
[16:11:00.097]  - attr(*, "total_size")= num 105552
[16:11:00.102] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.102] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.103] Number of futures (= number of chunks): 1
[16:11:00.103] Launching 1 futures (chunks) ...
[16:11:00.103] Chunk #1 of 1 ...
[16:11:00.103]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.103] getGlobalsAndPackages() ...
[16:11:00.103] Searching for globals...
[16:11:00.103] 
[16:11:00.103] Searching for globals ... DONE
[16:11:00.103] - globals: [0] <none>
[16:11:00.104] getGlobalsAndPackages() ... DONE
[16:11:00.104]    + additional globals found: [n=0] 
[16:11:00.104]    + additional namespaces needed: [n=0] 
[16:11:00.104]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.104]  - Adjusted option 'future.globals.maxSize': 524288000 -> 10 * 524288000 = 5242880000 (bytes)
[16:11:00.104]  - seeds: <none>
[16:11:00.104] getGlobalsAndPackages() ...
[16:11:00.104] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.104] Resolving globals: FALSE
[16:11:00.104] Tweak future expression to call with '...' arguments ...
[16:11:00.105] {
[16:11:00.105]     do.call(function(...) {
[16:11:00.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.105]             on.exit(options(oopts), add = TRUE)
[16:11:00.105]         }
[16:11:00.105]         {
[16:11:00.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.105]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.105]             })
[16:11:00.105]         }
[16:11:00.105]     }, args = future.call.arguments)
[16:11:00.105] }
[16:11:00.105] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.105] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.105] - packages: [1] ‘future.apply’
[16:11:00.105] getGlobalsAndPackages() ... DONE
[16:11:00.106] run() for ‘Future’ ...
[16:11:00.106] - state: ‘created’
[16:11:00.106] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.106]   - Field: ‘label’
[16:11:00.107]   - Field: ‘local’
[16:11:00.107]   - Field: ‘owner’
[16:11:00.107]   - Field: ‘envir’
[16:11:00.107]   - Field: ‘packages’
[16:11:00.107]   - Field: ‘gc’
[16:11:00.107]   - Field: ‘conditions’
[16:11:00.107]   - Field: ‘expr’
[16:11:00.107]   - Field: ‘uuid’
[16:11:00.107]   - Field: ‘seed’
[16:11:00.107]   - Field: ‘version’
[16:11:00.107]   - Field: ‘result’
[16:11:00.108]   - Field: ‘asynchronous’
[16:11:00.108]   - Field: ‘calls’
[16:11:00.108]   - Field: ‘globals’
[16:11:00.108]   - Field: ‘stdout’
[16:11:00.108]   - Field: ‘earlySignal’
[16:11:00.108]   - Field: ‘lazy’
[16:11:00.108]   - Field: ‘state’
[16:11:00.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.109] - Launch lazy future ...
[16:11:00.109] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.109] Packages needed by future strategies (n = 0): <none>
[16:11:00.110] {
[16:11:00.110]     {
[16:11:00.110]         {
[16:11:00.110]             ...future.startTime <- base::Sys.time()
[16:11:00.110]             {
[16:11:00.110]                 {
[16:11:00.110]                   {
[16:11:00.110]                     {
[16:11:00.110]                       base::local({
[16:11:00.110]                         has_future <- base::requireNamespace("future", 
[16:11:00.110]                           quietly = TRUE)
[16:11:00.110]                         if (has_future) {
[16:11:00.110]                           ns <- base::getNamespace("future")
[16:11:00.110]                           version <- ns[[".package"]][["version"]]
[16:11:00.110]                           if (is.null(version)) 
[16:11:00.110]                             version <- utils::packageVersion("future")
[16:11:00.110]                         }
[16:11:00.110]                         else {
[16:11:00.110]                           version <- NULL
[16:11:00.110]                         }
[16:11:00.110]                         if (!has_future || version < "1.8.0") {
[16:11:00.110]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.110]                             "", base::R.version$version.string), 
[16:11:00.110]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.110]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.110]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.110]                               "release", "version")], collapse = " "), 
[16:11:00.110]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.110]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.110]                             info)
[16:11:00.110]                           info <- base::paste(info, collapse = "; ")
[16:11:00.110]                           if (!has_future) {
[16:11:00.110]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.110]                               info)
[16:11:00.110]                           }
[16:11:00.110]                           else {
[16:11:00.110]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.110]                               info, version)
[16:11:00.110]                           }
[16:11:00.110]                           base::stop(msg)
[16:11:00.110]                         }
[16:11:00.110]                       })
[16:11:00.110]                     }
[16:11:00.110]                     base::local({
[16:11:00.110]                       for (pkg in "future.apply") {
[16:11:00.110]                         base::loadNamespace(pkg)
[16:11:00.110]                         base::library(pkg, character.only = TRUE)
[16:11:00.110]                       }
[16:11:00.110]                     })
[16:11:00.110]                   }
[16:11:00.110]                   options(future.plan = NULL)
[16:11:00.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.110]                 }
[16:11:00.110]                 ...future.workdir <- getwd()
[16:11:00.110]             }
[16:11:00.110]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.110]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.110]         }
[16:11:00.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.110]             future.globals.maxSize = 5242880000, future.globals.method = NULL, 
[16:11:00.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.110]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.110]             base::names(...future.oldOptions))
[16:11:00.110]     }
[16:11:00.110]     if (FALSE) {
[16:11:00.110]     }
[16:11:00.110]     else {
[16:11:00.110]         if (TRUE) {
[16:11:00.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.110]                 open = "w")
[16:11:00.110]         }
[16:11:00.110]         else {
[16:11:00.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.110]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.110]         }
[16:11:00.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.110]             base::sink(type = "output", split = FALSE)
[16:11:00.110]             base::close(...future.stdout)
[16:11:00.110]         }, add = TRUE)
[16:11:00.110]     }
[16:11:00.110]     ...future.frame <- base::sys.nframe()
[16:11:00.110]     ...future.conditions <- base::list()
[16:11:00.110]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.110]     if (FALSE) {
[16:11:00.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.110]     }
[16:11:00.110]     ...future.result <- base::tryCatch({
[16:11:00.110]         base::withCallingHandlers({
[16:11:00.110]             ...future.value <- base::withVisible(base::local({
[16:11:00.110]                 do.call(function(...) {
[16:11:00.110]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.110]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.110]                     ...future.globals.maxSize)) {
[16:11:00.110]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.110]                     on.exit(options(oopts), add = TRUE)
[16:11:00.110]                   }
[16:11:00.110]                   {
[16:11:00.110]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.110]                       FUN = function(jj) {
[16:11:00.110]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.110]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.110]                       })
[16:11:00.110]                   }
[16:11:00.110]                 }, args = future.call.arguments)
[16:11:00.110]             }))
[16:11:00.110]             future::FutureResult(value = ...future.value$value, 
[16:11:00.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.110]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.110]                     ...future.globalenv.names))
[16:11:00.110]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.110]         }, condition = base::local({
[16:11:00.110]             c <- base::c
[16:11:00.110]             inherits <- base::inherits
[16:11:00.110]             invokeRestart <- base::invokeRestart
[16:11:00.110]             length <- base::length
[16:11:00.110]             list <- base::list
[16:11:00.110]             seq.int <- base::seq.int
[16:11:00.110]             signalCondition <- base::signalCondition
[16:11:00.110]             sys.calls <- base::sys.calls
[16:11:00.110]             `[[` <- base::`[[`
[16:11:00.110]             `+` <- base::`+`
[16:11:00.110]             `<<-` <- base::`<<-`
[16:11:00.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.110]                   3L)]
[16:11:00.110]             }
[16:11:00.110]             function(cond) {
[16:11:00.110]                 is_error <- inherits(cond, "error")
[16:11:00.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.110]                   NULL)
[16:11:00.110]                 if (is_error) {
[16:11:00.110]                   sessionInformation <- function() {
[16:11:00.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.110]                       search = base::search(), system = base::Sys.info())
[16:11:00.110]                   }
[16:11:00.110]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.110]                     cond$call), session = sessionInformation(), 
[16:11:00.110]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.110]                   signalCondition(cond)
[16:11:00.110]                 }
[16:11:00.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.110]                 "immediateCondition"))) {
[16:11:00.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.110]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.110]                   if (TRUE && !signal) {
[16:11:00.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.110]                     {
[16:11:00.110]                       inherits <- base::inherits
[16:11:00.110]                       invokeRestart <- base::invokeRestart
[16:11:00.110]                       is.null <- base::is.null
[16:11:00.110]                       muffled <- FALSE
[16:11:00.110]                       if (inherits(cond, "message")) {
[16:11:00.110]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.110]                         if (muffled) 
[16:11:00.110]                           invokeRestart("muffleMessage")
[16:11:00.110]                       }
[16:11:00.110]                       else if (inherits(cond, "warning")) {
[16:11:00.110]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.110]                         if (muffled) 
[16:11:00.110]                           invokeRestart("muffleWarning")
[16:11:00.110]                       }
[16:11:00.110]                       else if (inherits(cond, "condition")) {
[16:11:00.110]                         if (!is.null(pattern)) {
[16:11:00.110]                           computeRestarts <- base::computeRestarts
[16:11:00.110]                           grepl <- base::grepl
[16:11:00.110]                           restarts <- computeRestarts(cond)
[16:11:00.110]                           for (restart in restarts) {
[16:11:00.110]                             name <- restart$name
[16:11:00.110]                             if (is.null(name)) 
[16:11:00.110]                               next
[16:11:00.110]                             if (!grepl(pattern, name)) 
[16:11:00.110]                               next
[16:11:00.110]                             invokeRestart(restart)
[16:11:00.110]                             muffled <- TRUE
[16:11:00.110]                             break
[16:11:00.110]                           }
[16:11:00.110]                         }
[16:11:00.110]                       }
[16:11:00.110]                       invisible(muffled)
[16:11:00.110]                     }
[16:11:00.110]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.110]                   }
[16:11:00.110]                 }
[16:11:00.110]                 else {
[16:11:00.110]                   if (TRUE) {
[16:11:00.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.110]                     {
[16:11:00.110]                       inherits <- base::inherits
[16:11:00.110]                       invokeRestart <- base::invokeRestart
[16:11:00.110]                       is.null <- base::is.null
[16:11:00.110]                       muffled <- FALSE
[16:11:00.110]                       if (inherits(cond, "message")) {
[16:11:00.110]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.110]                         if (muffled) 
[16:11:00.110]                           invokeRestart("muffleMessage")
[16:11:00.110]                       }
[16:11:00.110]                       else if (inherits(cond, "warning")) {
[16:11:00.110]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.110]                         if (muffled) 
[16:11:00.110]                           invokeRestart("muffleWarning")
[16:11:00.110]                       }
[16:11:00.110]                       else if (inherits(cond, "condition")) {
[16:11:00.110]                         if (!is.null(pattern)) {
[16:11:00.110]                           computeRestarts <- base::computeRestarts
[16:11:00.110]                           grepl <- base::grepl
[16:11:00.110]                           restarts <- computeRestarts(cond)
[16:11:00.110]                           for (restart in restarts) {
[16:11:00.110]                             name <- restart$name
[16:11:00.110]                             if (is.null(name)) 
[16:11:00.110]                               next
[16:11:00.110]                             if (!grepl(pattern, name)) 
[16:11:00.110]                               next
[16:11:00.110]                             invokeRestart(restart)
[16:11:00.110]                             muffled <- TRUE
[16:11:00.110]                             break
[16:11:00.110]                           }
[16:11:00.110]                         }
[16:11:00.110]                       }
[16:11:00.110]                       invisible(muffled)
[16:11:00.110]                     }
[16:11:00.110]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.110]                   }
[16:11:00.110]                 }
[16:11:00.110]             }
[16:11:00.110]         }))
[16:11:00.110]     }, error = function(ex) {
[16:11:00.110]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.110]                 ...future.rng), started = ...future.startTime, 
[16:11:00.110]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.110]             version = "1.8"), class = "FutureResult")
[16:11:00.110]     }, finally = {
[16:11:00.110]         if (!identical(...future.workdir, getwd())) 
[16:11:00.110]             setwd(...future.workdir)
[16:11:00.110]         {
[16:11:00.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.110]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.110]             }
[16:11:00.110]             base::options(...future.oldOptions)
[16:11:00.110]             if (.Platform$OS.type == "windows") {
[16:11:00.110]                 old_names <- names(...future.oldEnvVars)
[16:11:00.110]                 envs <- base::Sys.getenv()
[16:11:00.110]                 names <- names(envs)
[16:11:00.110]                 common <- intersect(names, old_names)
[16:11:00.110]                 added <- setdiff(names, old_names)
[16:11:00.110]                 removed <- setdiff(old_names, names)
[16:11:00.110]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.110]                   envs[common]]
[16:11:00.110]                 NAMES <- toupper(changed)
[16:11:00.110]                 args <- list()
[16:11:00.110]                 for (kk in seq_along(NAMES)) {
[16:11:00.110]                   name <- changed[[kk]]
[16:11:00.110]                   NAME <- NAMES[[kk]]
[16:11:00.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.110]                     next
[16:11:00.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.110]                 }
[16:11:00.110]                 NAMES <- toupper(added)
[16:11:00.110]                 for (kk in seq_along(NAMES)) {
[16:11:00.110]                   name <- added[[kk]]
[16:11:00.110]                   NAME <- NAMES[[kk]]
[16:11:00.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.110]                     next
[16:11:00.110]                   args[[name]] <- ""
[16:11:00.110]                 }
[16:11:00.110]                 NAMES <- toupper(removed)
[16:11:00.110]                 for (kk in seq_along(NAMES)) {
[16:11:00.110]                   name <- removed[[kk]]
[16:11:00.110]                   NAME <- NAMES[[kk]]
[16:11:00.110]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.110]                     next
[16:11:00.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.110]                 }
[16:11:00.110]                 if (length(args) > 0) 
[16:11:00.110]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.110]             }
[16:11:00.110]             else {
[16:11:00.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.110]             }
[16:11:00.110]             {
[16:11:00.110]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.110]                   0L) {
[16:11:00.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.110]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.110]                   base::options(opts)
[16:11:00.110]                 }
[16:11:00.110]                 {
[16:11:00.110]                   {
[16:11:00.110]                     NULL
[16:11:00.110]                     RNGkind("Mersenne-Twister")
[16:11:00.110]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.110]                       inherits = FALSE)
[16:11:00.110]                   }
[16:11:00.110]                   options(future.plan = NULL)
[16:11:00.110]                   if (is.na(NA_character_)) 
[16:11:00.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.110]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.110]                   {
[16:11:00.110]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.110]                     if (!future$lazy) 
[16:11:00.110]                       future <- run(future)
[16:11:00.110]                     invisible(future)
[16:11:00.110]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.110]                 }
[16:11:00.110]             }
[16:11:00.110]         }
[16:11:00.110]     })
[16:11:00.110]     if (TRUE) {
[16:11:00.110]         base::sink(type = "output", split = FALSE)
[16:11:00.110]         if (TRUE) {
[16:11:00.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.110]         }
[16:11:00.110]         else {
[16:11:00.110]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.110]         }
[16:11:00.110]         base::close(...future.stdout)
[16:11:00.110]         ...future.stdout <- NULL
[16:11:00.110]     }
[16:11:00.110]     ...future.result$conditions <- ...future.conditions
[16:11:00.110]     ...future.result$finished <- base::Sys.time()
[16:11:00.110]     ...future.result
[16:11:00.110] }
[16:11:00.112] assign_globals() ...
[16:11:00.112] List of 11
[16:11:00.112]  $ ...future.FUN            :function (x, ...)  
[16:11:00.112]  $ x_FUN                    :function (x)  
[16:11:00.112]  $ times                    : int 4
[16:11:00.112]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.112]  $ stop_if_not              :function (...)  
[16:11:00.112]  $ dim                      : int [1:2] 2 2
[16:11:00.112]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.112]  $ future.call.arguments    : list()
[16:11:00.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.112]  $ ...future.elements_ii    :List of 10
[16:11:00.112]   ..$ : int 1
[16:11:00.112]   ..$ : int 2
[16:11:00.112]   ..$ : int 3
[16:11:00.112]   ..$ : int 4
[16:11:00.112]   ..$ : int 5
[16:11:00.112]   ..$ : int 6
[16:11:00.112]   ..$ : int 7
[16:11:00.112]   ..$ : int 8
[16:11:00.112]   ..$ : int 9
[16:11:00.112]   ..$ : int 10
[16:11:00.112]  $ ...future.seeds_ii       : NULL
[16:11:00.112]  $ ...future.globals.maxSize: NULL
[16:11:00.112]  - attr(*, "resolved")= logi FALSE
[16:11:00.112]  - attr(*, "total_size")= num 105552
[16:11:00.112]  - attr(*, "where")=List of 11
[16:11:00.112]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.112]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.112]  - attr(*, "already-done")= logi TRUE
[16:11:00.121] - copied ‘...future.FUN’ to environment
[16:11:00.121] - reassign environment for ‘x_FUN’
[16:11:00.121] - copied ‘x_FUN’ to environment
[16:11:00.122] - copied ‘times’ to environment
[16:11:00.122] - copied ‘stopf’ to environment
[16:11:00.122] - copied ‘stop_if_not’ to environment
[16:11:00.122] - copied ‘dim’ to environment
[16:11:00.122] - copied ‘valid_types’ to environment
[16:11:00.122] - copied ‘future.call.arguments’ to environment
[16:11:00.122] - copied ‘...future.elements_ii’ to environment
[16:11:00.122] - copied ‘...future.seeds_ii’ to environment
[16:11:00.122] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.122] assign_globals() ... done
[16:11:00.123] plan(): Setting new future strategy stack:
[16:11:00.123] List of future strategies:
[16:11:00.123] 1. sequential:
[16:11:00.123]    - args: function (..., envir = parent.frame())
[16:11:00.123]    - tweaked: FALSE
[16:11:00.123]    - call: NULL
[16:11:00.123] plan(): nbrOfWorkers() = 1
[16:11:00.124] plan(): Setting new future strategy stack:
[16:11:00.124] List of future strategies:
[16:11:00.124] 1. sequential:
[16:11:00.124]    - args: function (..., envir = parent.frame())
[16:11:00.124]    - tweaked: FALSE
[16:11:00.124]    - call: plan(strategy)
[16:11:00.124] plan(): nbrOfWorkers() = 1
[16:11:00.125] SequentialFuture started (and completed)
[16:11:00.125] - Launch lazy future ... done
[16:11:00.125] run() for ‘SequentialFuture’ ... done
[16:11:00.125] Created future:
[16:11:00.125] SequentialFuture:
[16:11:00.125] Label: ‘future_vapply-1’
[16:11:00.125] Expression:
[16:11:00.125] {
[16:11:00.125]     do.call(function(...) {
[16:11:00.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.125]             on.exit(options(oopts), add = TRUE)
[16:11:00.125]         }
[16:11:00.125]         {
[16:11:00.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.125]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.125]             })
[16:11:00.125]         }
[16:11:00.125]     }, args = future.call.arguments)
[16:11:00.125] }
[16:11:00.125] Lazy evaluation: FALSE
[16:11:00.125] Asynchronous evaluation: FALSE
[16:11:00.125] Local evaluation: TRUE
[16:11:00.125] Environment: R_GlobalEnv
[16:11:00.125] Capture standard output: TRUE
[16:11:00.125] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.125] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.125] Packages: 1 packages (‘future.apply’)
[16:11:00.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.125] Resolved: TRUE
[16:11:00.125] Value: 7.42 KiB of class ‘list’
[16:11:00.125] Early signaling: FALSE
[16:11:00.125] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.125] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.126] Chunk #1 of 1 ... DONE
[16:11:00.126] Launching 1 futures (chunks) ... DONE
[16:11:00.126] Resolving 1 futures (chunks) ...
[16:11:00.126] resolve() on list ...
[16:11:00.127]  recursive: 0
[16:11:00.127]  length: 1
[16:11:00.127] 
[16:11:00.127] resolved() for ‘SequentialFuture’ ...
[16:11:00.127] - state: ‘finished’
[16:11:00.127] - run: TRUE
[16:11:00.127] - result: ‘FutureResult’
[16:11:00.127] resolved() for ‘SequentialFuture’ ... done
[16:11:00.127] Future #1
[16:11:00.127] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.127] - nx: 1
[16:11:00.128] - relay: TRUE
[16:11:00.128] - stdout: TRUE
[16:11:00.128] - signal: TRUE
[16:11:00.128] - resignal: FALSE
[16:11:00.128] - force: TRUE
[16:11:00.128] - relayed: [n=1] FALSE
[16:11:00.128] - queued futures: [n=1] FALSE
[16:11:00.128]  - until=1
[16:11:00.128]  - relaying element #1
[16:11:00.128] - relayed: [n=1] TRUE
[16:11:00.129] - queued futures: [n=1] TRUE
[16:11:00.129] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.129]  length: 0 (resolved future 1)
[16:11:00.129] Relaying remaining futures
[16:11:00.129] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.129] - nx: 1
[16:11:00.129] - relay: TRUE
[16:11:00.129] - stdout: TRUE
[16:11:00.129] - signal: TRUE
[16:11:00.129] - resignal: FALSE
[16:11:00.129] - force: TRUE
[16:11:00.129] - relayed: [n=1] TRUE
[16:11:00.129] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.130] - relayed: [n=1] TRUE
[16:11:00.130] - queued futures: [n=1] TRUE
[16:11:00.130] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.130] resolve() on list ... DONE
[16:11:00.130]  - Number of value chunks collected: 1
[16:11:00.130] Resolving 1 futures (chunks) ... DONE
[16:11:00.130] Reducing values from 1 chunks ...
[16:11:00.130]  - Number of values collected after concatenation: 10
[16:11:00.130]  - Number of values expected: 10
[16:11:00.130] Reducing values from 1 chunks ... DONE
[16:11:00.131] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:11:00.135] future_lapply() ...
[16:11:00.137] Number of chunks: 1
[16:11:00.137] getGlobalsAndPackagesXApply() ...
[16:11:00.137]  - future.globals: TRUE
[16:11:00.137] getGlobalsAndPackages() ...
[16:11:00.137] Searching for globals...
[16:11:00.140] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:11:00.141] Searching for globals ... DONE
[16:11:00.141] Resolving globals: FALSE
[16:11:00.142] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:11:00.142] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.142] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.142] - packages: [2] ‘stats’, ‘future.apply’
[16:11:00.142] getGlobalsAndPackages() ... DONE
[16:11:00.142]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.142]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:11:00.143] Finding globals ... DONE
[16:11:00.143]  - use_args: TRUE
[16:11:00.143]  - Getting '...' globals ...
[16:11:00.143] resolve() on list ...
[16:11:00.143]  recursive: 0
[16:11:00.143]  length: 1
[16:11:00.143]  elements: ‘...’
[16:11:00.143]  length: 0 (resolved future 1)
[16:11:00.143] resolve() on list ... DONE
[16:11:00.144]    - '...' content: [n=0] 
[16:11:00.144] List of 1
[16:11:00.144]  $ ...: list()
[16:11:00.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.144]  - attr(*, "where")=List of 1
[16:11:00.144]   ..$ ...:<environment: 0x561e897d14d0> 
[16:11:00.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.144]  - attr(*, "resolved")= logi TRUE
[16:11:00.144]  - attr(*, "total_size")= num NA
[16:11:00.146]  - Getting '...' globals ... DONE
[16:11:00.146] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.146] List of 8
[16:11:00.146]  $ ...future.FUN:function (x, ...)  
[16:11:00.146]  $ x_FUN        :function (x, ...)  
[16:11:00.146]  $ times        : int 5
[16:11:00.146]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.146]  $ stop_if_not  :function (...)  
[16:11:00.146]  $ dim          : NULL
[16:11:00.146]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:00.146]  $ ...          : list()
[16:11:00.146]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.146]  - attr(*, "where")=List of 8
[16:11:00.146]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.146]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.146]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.146]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.146]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.146]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.146]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.146]   ..$ ...          :<environment: 0x561e897d14d0> 
[16:11:00.146]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.146]  - attr(*, "resolved")= logi FALSE
[16:11:00.146]  - attr(*, "total_size")= num 95528
[16:11:00.151] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:11:00.151] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.152] Number of futures (= number of chunks): 1
[16:11:00.152] Launching 1 futures (chunks) ...
[16:11:00.152] Chunk #1 of 1 ...
[16:11:00.152]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.152] getGlobalsAndPackages() ...
[16:11:00.152] Searching for globals...
[16:11:00.152] 
[16:11:00.153] Searching for globals ... DONE
[16:11:00.153] - globals: [0] <none>
[16:11:00.153] getGlobalsAndPackages() ... DONE
[16:11:00.153]    + additional globals found: [n=0] 
[16:11:00.153]    + additional namespaces needed: [n=0] 
[16:11:00.153]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.154]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:11:00.154]  - seeds: <none>
[16:11:00.154] getGlobalsAndPackages() ...
[16:11:00.154] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.154] Resolving globals: FALSE
[16:11:00.154] Tweak future expression to call with '...' arguments ...
[16:11:00.155] {
[16:11:00.155]     do.call(function(...) {
[16:11:00.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.155]             on.exit(options(oopts), add = TRUE)
[16:11:00.155]         }
[16:11:00.155]         {
[16:11:00.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.155]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.155]             })
[16:11:00.155]         }
[16:11:00.155]     }, args = future.call.arguments)
[16:11:00.155] }
[16:11:00.155] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.155] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.155] - packages: [2] ‘stats’, ‘future.apply’
[16:11:00.156] getGlobalsAndPackages() ... DONE
[16:11:00.156] run() for ‘Future’ ...
[16:11:00.156] - state: ‘created’
[16:11:00.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.157]   - Field: ‘label’
[16:11:00.157]   - Field: ‘local’
[16:11:00.157]   - Field: ‘owner’
[16:11:00.157]   - Field: ‘envir’
[16:11:00.157]   - Field: ‘packages’
[16:11:00.157]   - Field: ‘gc’
[16:11:00.157]   - Field: ‘conditions’
[16:11:00.157]   - Field: ‘expr’
[16:11:00.157]   - Field: ‘uuid’
[16:11:00.157]   - Field: ‘seed’
[16:11:00.157]   - Field: ‘version’
[16:11:00.158]   - Field: ‘result’
[16:11:00.158]   - Field: ‘asynchronous’
[16:11:00.158]   - Field: ‘calls’
[16:11:00.158]   - Field: ‘globals’
[16:11:00.158]   - Field: ‘stdout’
[16:11:00.158]   - Field: ‘earlySignal’
[16:11:00.158]   - Field: ‘lazy’
[16:11:00.158]   - Field: ‘state’
[16:11:00.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.158] - Launch lazy future ...
[16:11:00.158] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:00.159] Packages needed by future strategies (n = 0): <none>
[16:11:00.159] {
[16:11:00.159]     {
[16:11:00.159]         {
[16:11:00.159]             ...future.startTime <- base::Sys.time()
[16:11:00.159]             {
[16:11:00.159]                 {
[16:11:00.159]                   {
[16:11:00.159]                     {
[16:11:00.159]                       base::local({
[16:11:00.159]                         has_future <- base::requireNamespace("future", 
[16:11:00.159]                           quietly = TRUE)
[16:11:00.159]                         if (has_future) {
[16:11:00.159]                           ns <- base::getNamespace("future")
[16:11:00.159]                           version <- ns[[".package"]][["version"]]
[16:11:00.159]                           if (is.null(version)) 
[16:11:00.159]                             version <- utils::packageVersion("future")
[16:11:00.159]                         }
[16:11:00.159]                         else {
[16:11:00.159]                           version <- NULL
[16:11:00.159]                         }
[16:11:00.159]                         if (!has_future || version < "1.8.0") {
[16:11:00.159]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.159]                             "", base::R.version$version.string), 
[16:11:00.159]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.159]                               "release", "version")], collapse = " "), 
[16:11:00.159]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.159]                             info)
[16:11:00.159]                           info <- base::paste(info, collapse = "; ")
[16:11:00.159]                           if (!has_future) {
[16:11:00.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.159]                               info)
[16:11:00.159]                           }
[16:11:00.159]                           else {
[16:11:00.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.159]                               info, version)
[16:11:00.159]                           }
[16:11:00.159]                           base::stop(msg)
[16:11:00.159]                         }
[16:11:00.159]                       })
[16:11:00.159]                     }
[16:11:00.159]                     base::local({
[16:11:00.159]                       for (pkg in c("stats", "future.apply")) {
[16:11:00.159]                         base::loadNamespace(pkg)
[16:11:00.159]                         base::library(pkg, character.only = TRUE)
[16:11:00.159]                       }
[16:11:00.159]                     })
[16:11:00.159]                   }
[16:11:00.159]                   options(future.plan = NULL)
[16:11:00.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.159]                 }
[16:11:00.159]                 ...future.workdir <- getwd()
[16:11:00.159]             }
[16:11:00.159]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.159]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.159]         }
[16:11:00.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.159]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:11:00.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.159]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.159]             base::names(...future.oldOptions))
[16:11:00.159]     }
[16:11:00.159]     if (FALSE) {
[16:11:00.159]     }
[16:11:00.159]     else {
[16:11:00.159]         if (TRUE) {
[16:11:00.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.159]                 open = "w")
[16:11:00.159]         }
[16:11:00.159]         else {
[16:11:00.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.159]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.159]         }
[16:11:00.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.159]             base::sink(type = "output", split = FALSE)
[16:11:00.159]             base::close(...future.stdout)
[16:11:00.159]         }, add = TRUE)
[16:11:00.159]     }
[16:11:00.159]     ...future.frame <- base::sys.nframe()
[16:11:00.159]     ...future.conditions <- base::list()
[16:11:00.159]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.159]     if (FALSE) {
[16:11:00.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.159]     }
[16:11:00.159]     ...future.result <- base::tryCatch({
[16:11:00.159]         base::withCallingHandlers({
[16:11:00.159]             ...future.value <- base::withVisible(base::local({
[16:11:00.159]                 do.call(function(...) {
[16:11:00.159]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.159]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.159]                     ...future.globals.maxSize)) {
[16:11:00.159]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.159]                     on.exit(options(oopts), add = TRUE)
[16:11:00.159]                   }
[16:11:00.159]                   {
[16:11:00.159]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.159]                       FUN = function(jj) {
[16:11:00.159]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.159]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.159]                       })
[16:11:00.159]                   }
[16:11:00.159]                 }, args = future.call.arguments)
[16:11:00.159]             }))
[16:11:00.159]             future::FutureResult(value = ...future.value$value, 
[16:11:00.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.159]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.159]                     ...future.globalenv.names))
[16:11:00.159]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.159]         }, condition = base::local({
[16:11:00.159]             c <- base::c
[16:11:00.159]             inherits <- base::inherits
[16:11:00.159]             invokeRestart <- base::invokeRestart
[16:11:00.159]             length <- base::length
[16:11:00.159]             list <- base::list
[16:11:00.159]             seq.int <- base::seq.int
[16:11:00.159]             signalCondition <- base::signalCondition
[16:11:00.159]             sys.calls <- base::sys.calls
[16:11:00.159]             `[[` <- base::`[[`
[16:11:00.159]             `+` <- base::`+`
[16:11:00.159]             `<<-` <- base::`<<-`
[16:11:00.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.159]                   3L)]
[16:11:00.159]             }
[16:11:00.159]             function(cond) {
[16:11:00.159]                 is_error <- inherits(cond, "error")
[16:11:00.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.159]                   NULL)
[16:11:00.159]                 if (is_error) {
[16:11:00.159]                   sessionInformation <- function() {
[16:11:00.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.159]                       search = base::search(), system = base::Sys.info())
[16:11:00.159]                   }
[16:11:00.159]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.159]                     cond$call), session = sessionInformation(), 
[16:11:00.159]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.159]                   signalCondition(cond)
[16:11:00.159]                 }
[16:11:00.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.159]                 "immediateCondition"))) {
[16:11:00.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.159]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.159]                   if (TRUE && !signal) {
[16:11:00.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.159]                     {
[16:11:00.159]                       inherits <- base::inherits
[16:11:00.159]                       invokeRestart <- base::invokeRestart
[16:11:00.159]                       is.null <- base::is.null
[16:11:00.159]                       muffled <- FALSE
[16:11:00.159]                       if (inherits(cond, "message")) {
[16:11:00.159]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.159]                         if (muffled) 
[16:11:00.159]                           invokeRestart("muffleMessage")
[16:11:00.159]                       }
[16:11:00.159]                       else if (inherits(cond, "warning")) {
[16:11:00.159]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.159]                         if (muffled) 
[16:11:00.159]                           invokeRestart("muffleWarning")
[16:11:00.159]                       }
[16:11:00.159]                       else if (inherits(cond, "condition")) {
[16:11:00.159]                         if (!is.null(pattern)) {
[16:11:00.159]                           computeRestarts <- base::computeRestarts
[16:11:00.159]                           grepl <- base::grepl
[16:11:00.159]                           restarts <- computeRestarts(cond)
[16:11:00.159]                           for (restart in restarts) {
[16:11:00.159]                             name <- restart$name
[16:11:00.159]                             if (is.null(name)) 
[16:11:00.159]                               next
[16:11:00.159]                             if (!grepl(pattern, name)) 
[16:11:00.159]                               next
[16:11:00.159]                             invokeRestart(restart)
[16:11:00.159]                             muffled <- TRUE
[16:11:00.159]                             break
[16:11:00.159]                           }
[16:11:00.159]                         }
[16:11:00.159]                       }
[16:11:00.159]                       invisible(muffled)
[16:11:00.159]                     }
[16:11:00.159]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.159]                   }
[16:11:00.159]                 }
[16:11:00.159]                 else {
[16:11:00.159]                   if (TRUE) {
[16:11:00.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.159]                     {
[16:11:00.159]                       inherits <- base::inherits
[16:11:00.159]                       invokeRestart <- base::invokeRestart
[16:11:00.159]                       is.null <- base::is.null
[16:11:00.159]                       muffled <- FALSE
[16:11:00.159]                       if (inherits(cond, "message")) {
[16:11:00.159]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.159]                         if (muffled) 
[16:11:00.159]                           invokeRestart("muffleMessage")
[16:11:00.159]                       }
[16:11:00.159]                       else if (inherits(cond, "warning")) {
[16:11:00.159]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.159]                         if (muffled) 
[16:11:00.159]                           invokeRestart("muffleWarning")
[16:11:00.159]                       }
[16:11:00.159]                       else if (inherits(cond, "condition")) {
[16:11:00.159]                         if (!is.null(pattern)) {
[16:11:00.159]                           computeRestarts <- base::computeRestarts
[16:11:00.159]                           grepl <- base::grepl
[16:11:00.159]                           restarts <- computeRestarts(cond)
[16:11:00.159]                           for (restart in restarts) {
[16:11:00.159]                             name <- restart$name
[16:11:00.159]                             if (is.null(name)) 
[16:11:00.159]                               next
[16:11:00.159]                             if (!grepl(pattern, name)) 
[16:11:00.159]                               next
[16:11:00.159]                             invokeRestart(restart)
[16:11:00.159]                             muffled <- TRUE
[16:11:00.159]                             break
[16:11:00.159]                           }
[16:11:00.159]                         }
[16:11:00.159]                       }
[16:11:00.159]                       invisible(muffled)
[16:11:00.159]                     }
[16:11:00.159]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.159]                   }
[16:11:00.159]                 }
[16:11:00.159]             }
[16:11:00.159]         }))
[16:11:00.159]     }, error = function(ex) {
[16:11:00.159]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.159]                 ...future.rng), started = ...future.startTime, 
[16:11:00.159]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.159]             version = "1.8"), class = "FutureResult")
[16:11:00.159]     }, finally = {
[16:11:00.159]         if (!identical(...future.workdir, getwd())) 
[16:11:00.159]             setwd(...future.workdir)
[16:11:00.159]         {
[16:11:00.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.159]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.159]             }
[16:11:00.159]             base::options(...future.oldOptions)
[16:11:00.159]             if (.Platform$OS.type == "windows") {
[16:11:00.159]                 old_names <- names(...future.oldEnvVars)
[16:11:00.159]                 envs <- base::Sys.getenv()
[16:11:00.159]                 names <- names(envs)
[16:11:00.159]                 common <- intersect(names, old_names)
[16:11:00.159]                 added <- setdiff(names, old_names)
[16:11:00.159]                 removed <- setdiff(old_names, names)
[16:11:00.159]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.159]                   envs[common]]
[16:11:00.159]                 NAMES <- toupper(changed)
[16:11:00.159]                 args <- list()
[16:11:00.159]                 for (kk in seq_along(NAMES)) {
[16:11:00.159]                   name <- changed[[kk]]
[16:11:00.159]                   NAME <- NAMES[[kk]]
[16:11:00.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.159]                     next
[16:11:00.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.159]                 }
[16:11:00.159]                 NAMES <- toupper(added)
[16:11:00.159]                 for (kk in seq_along(NAMES)) {
[16:11:00.159]                   name <- added[[kk]]
[16:11:00.159]                   NAME <- NAMES[[kk]]
[16:11:00.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.159]                     next
[16:11:00.159]                   args[[name]] <- ""
[16:11:00.159]                 }
[16:11:00.159]                 NAMES <- toupper(removed)
[16:11:00.159]                 for (kk in seq_along(NAMES)) {
[16:11:00.159]                   name <- removed[[kk]]
[16:11:00.159]                   NAME <- NAMES[[kk]]
[16:11:00.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.159]                     next
[16:11:00.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.159]                 }
[16:11:00.159]                 if (length(args) > 0) 
[16:11:00.159]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.159]             }
[16:11:00.159]             else {
[16:11:00.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.159]             }
[16:11:00.159]             {
[16:11:00.159]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.159]                   0L) {
[16:11:00.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.159]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.159]                   base::options(opts)
[16:11:00.159]                 }
[16:11:00.159]                 {
[16:11:00.159]                   {
[16:11:00.159]                     NULL
[16:11:00.159]                     RNGkind("Mersenne-Twister")
[16:11:00.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.159]                       inherits = FALSE)
[16:11:00.159]                   }
[16:11:00.159]                   options(future.plan = NULL)
[16:11:00.159]                   if (is.na(NA_character_)) 
[16:11:00.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.159]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.159]                   {
[16:11:00.159]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.159]                     if (!future$lazy) 
[16:11:00.159]                       future <- run(future)
[16:11:00.159]                     invisible(future)
[16:11:00.159]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.159]                 }
[16:11:00.159]             }
[16:11:00.159]         }
[16:11:00.159]     })
[16:11:00.159]     if (TRUE) {
[16:11:00.159]         base::sink(type = "output", split = FALSE)
[16:11:00.159]         if (TRUE) {
[16:11:00.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.159]         }
[16:11:00.159]         else {
[16:11:00.159]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.159]         }
[16:11:00.159]         base::close(...future.stdout)
[16:11:00.159]         ...future.stdout <- NULL
[16:11:00.159]     }
[16:11:00.159]     ...future.result$conditions <- ...future.conditions
[16:11:00.159]     ...future.result$finished <- base::Sys.time()
[16:11:00.159]     ...future.result
[16:11:00.159] }
[16:11:00.161] assign_globals() ...
[16:11:00.161] List of 11
[16:11:00.161]  $ ...future.FUN            :function (x, ...)  
[16:11:00.161]  $ x_FUN                    :function (x, ...)  
[16:11:00.161]  $ times                    : int 5
[16:11:00.161]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.161]  $ stop_if_not              :function (...)  
[16:11:00.161]  $ dim                      : NULL
[16:11:00.161]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.161]  $ future.call.arguments    : list()
[16:11:00.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.161]  $ ...future.elements_ii    :List of 3
[16:11:00.161]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:11:00.161]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:11:00.161]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:11:00.161]  $ ...future.seeds_ii       : NULL
[16:11:00.161]  $ ...future.globals.maxSize: NULL
[16:11:00.161]  - attr(*, "resolved")= logi FALSE
[16:11:00.161]  - attr(*, "total_size")= num 95528
[16:11:00.161]  - attr(*, "where")=List of 11
[16:11:00.161]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.161]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.161]  - attr(*, "already-done")= logi TRUE
[16:11:00.168] - copied ‘...future.FUN’ to environment
[16:11:00.169] - copied ‘x_FUN’ to environment
[16:11:00.169] - copied ‘times’ to environment
[16:11:00.169] - copied ‘stopf’ to environment
[16:11:00.169] - copied ‘stop_if_not’ to environment
[16:11:00.169] - copied ‘dim’ to environment
[16:11:00.169] - copied ‘valid_types’ to environment
[16:11:00.169] - copied ‘future.call.arguments’ to environment
[16:11:00.169] - copied ‘...future.elements_ii’ to environment
[16:11:00.169] - copied ‘...future.seeds_ii’ to environment
[16:11:00.169] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.169] assign_globals() ... done
[16:11:00.170] plan(): Setting new future strategy stack:
[16:11:00.170] List of future strategies:
[16:11:00.170] 1. sequential:
[16:11:00.170]    - args: function (..., envir = parent.frame())
[16:11:00.170]    - tweaked: FALSE
[16:11:00.170]    - call: NULL
[16:11:00.170] plan(): nbrOfWorkers() = 1
[16:11:00.171] plan(): Setting new future strategy stack:
[16:11:00.172] List of future strategies:
[16:11:00.172] 1. sequential:
[16:11:00.172]    - args: function (..., envir = parent.frame())
[16:11:00.172]    - tweaked: FALSE
[16:11:00.172]    - call: plan(strategy)
[16:11:00.172] plan(): nbrOfWorkers() = 1
[16:11:00.172] SequentialFuture started (and completed)
[16:11:00.172] - Launch lazy future ... done
[16:11:00.172] run() for ‘SequentialFuture’ ... done
[16:11:00.172] Created future:
[16:11:00.172] SequentialFuture:
[16:11:00.172] Label: ‘future_vapply-1’
[16:11:00.172] Expression:
[16:11:00.172] {
[16:11:00.172]     do.call(function(...) {
[16:11:00.172]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.172]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.172]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.172]             on.exit(options(oopts), add = TRUE)
[16:11:00.172]         }
[16:11:00.172]         {
[16:11:00.172]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.172]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.172]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.172]             })
[16:11:00.172]         }
[16:11:00.172]     }, args = future.call.arguments)
[16:11:00.172] }
[16:11:00.172] Lazy evaluation: FALSE
[16:11:00.172] Asynchronous evaluation: FALSE
[16:11:00.172] Local evaluation: TRUE
[16:11:00.172] Environment: R_GlobalEnv
[16:11:00.172] Capture standard output: TRUE
[16:11:00.172] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.172] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.172] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:00.172] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.172] Resolved: TRUE
[16:11:00.172] Value: 1.71 KiB of class ‘list’
[16:11:00.172] Early signaling: FALSE
[16:11:00.172] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.172] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.174] Chunk #1 of 1 ... DONE
[16:11:00.174] Launching 1 futures (chunks) ... DONE
[16:11:00.174] Resolving 1 futures (chunks) ...
[16:11:00.174] resolve() on list ...
[16:11:00.174]  recursive: 0
[16:11:00.174]  length: 1
[16:11:00.174] 
[16:11:00.174] resolved() for ‘SequentialFuture’ ...
[16:11:00.174] - state: ‘finished’
[16:11:00.174] - run: TRUE
[16:11:00.174] - result: ‘FutureResult’
[16:11:00.175] resolved() for ‘SequentialFuture’ ... done
[16:11:00.175] Future #1
[16:11:00.175] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.175] - nx: 1
[16:11:00.175] - relay: TRUE
[16:11:00.175] - stdout: TRUE
[16:11:00.175] - signal: TRUE
[16:11:00.175] - resignal: FALSE
[16:11:00.175] - force: TRUE
[16:11:00.175] - relayed: [n=1] FALSE
[16:11:00.175] - queued futures: [n=1] FALSE
[16:11:00.175]  - until=1
[16:11:00.176]  - relaying element #1
[16:11:00.177] - relayed: [n=1] TRUE
[16:11:00.177] - queued futures: [n=1] TRUE
[16:11:00.177] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.177]  length: 0 (resolved future 1)
[16:11:00.177] Relaying remaining futures
[16:11:00.177] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.177] - nx: 1
[16:11:00.177] - relay: TRUE
[16:11:00.177] - stdout: TRUE
[16:11:00.177] - signal: TRUE
[16:11:00.177] - resignal: FALSE
[16:11:00.177] - force: TRUE
[16:11:00.178] - relayed: [n=1] TRUE
[16:11:00.178] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.178] - relayed: [n=1] TRUE
[16:11:00.178] - queued futures: [n=1] TRUE
[16:11:00.178] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.178] resolve() on list ... DONE
[16:11:00.178]  - Number of value chunks collected: 1
[16:11:00.178] Resolving 1 futures (chunks) ... DONE
[16:11:00.178] Reducing values from 1 chunks ...
[16:11:00.178]  - Number of values collected after concatenation: 3
[16:11:00.179]  - Number of values expected: 3
[16:11:00.179] Reducing values from 1 chunks ... DONE
[16:11:00.179] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:11:00.180] future_lapply() ...
[16:11:00.184] Number of chunks: 1
[16:11:00.184] getGlobalsAndPackagesXApply() ...
[16:11:00.184]  - future.globals: TRUE
[16:11:00.184] getGlobalsAndPackages() ...
[16:11:00.184] Searching for globals...
[16:11:00.189] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:11:00.189] Searching for globals ... DONE
[16:11:00.189] Resolving globals: FALSE
[16:11:00.190] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:11:00.190] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:11:00.190] - globals: [1] ‘FUN’
[16:11:00.190] - packages: [1] ‘stats’
[16:11:00.190] getGlobalsAndPackages() ... DONE
[16:11:00.190]  - globals found/used: [n=1] ‘FUN’
[16:11:00.190]  - needed namespaces: [n=1] ‘stats’
[16:11:00.190] Finding globals ... DONE
[16:11:00.191]  - use_args: TRUE
[16:11:00.191]  - Getting '...' globals ...
[16:11:00.191] resolve() on list ...
[16:11:00.191]  recursive: 0
[16:11:00.191]  length: 1
[16:11:00.191]  elements: ‘...’
[16:11:00.191]  length: 0 (resolved future 1)
[16:11:00.191] resolve() on list ... DONE
[16:11:00.191]    - '...' content: [n=0] 
[16:11:00.192] List of 1
[16:11:00.192]  $ ...: list()
[16:11:00.192]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.192]  - attr(*, "where")=List of 1
[16:11:00.192]   ..$ ...:<environment: 0x561e88a890e8> 
[16:11:00.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.192]  - attr(*, "resolved")= logi TRUE
[16:11:00.192]  - attr(*, "total_size")= num NA
[16:11:00.194]  - Getting '...' globals ... DONE
[16:11:00.194] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:00.194] List of 2
[16:11:00.194]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:11:00.194]  $ ...          : list()
[16:11:00.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.194]  - attr(*, "where")=List of 2
[16:11:00.194]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.194]   ..$ ...          :<environment: 0x561e88a890e8> 
[16:11:00.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.194]  - attr(*, "resolved")= logi FALSE
[16:11:00.194]  - attr(*, "total_size")= num 46960
[16:11:00.198] Packages to be attached in all futures: [n=1] ‘stats’
[16:11:00.198] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.198] Number of futures (= number of chunks): 1
[16:11:00.198] Launching 1 futures (chunks) ...
[16:11:00.198] Chunk #1 of 1 ...
[16:11:00.198]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.198] getGlobalsAndPackages() ...
[16:11:00.198] Searching for globals...
[16:11:00.199] 
[16:11:00.199] Searching for globals ... DONE
[16:11:00.199] - globals: [0] <none>
[16:11:00.199] getGlobalsAndPackages() ... DONE
[16:11:00.199]    + additional globals found: [n=0] 
[16:11:00.199]    + additional namespaces needed: [n=0] 
[16:11:00.199]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.199]  - Adjusted option 'future.globals.maxSize': 524288000 -> 7 * 524288000 = 3670016000 (bytes)
[16:11:00.199]  - seeds: <none>
[16:11:00.199] getGlobalsAndPackages() ...
[16:11:00.200] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.200] Resolving globals: FALSE
[16:11:00.200] Tweak future expression to call with '...' arguments ...
[16:11:00.200] {
[16:11:00.200]     do.call(function(...) {
[16:11:00.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.200]             on.exit(options(oopts), add = TRUE)
[16:11:00.200]         }
[16:11:00.200]         {
[16:11:00.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.200]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.200]             })
[16:11:00.200]         }
[16:11:00.200]     }, args = future.call.arguments)
[16:11:00.200] }
[16:11:00.200] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.200] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.201] - packages: [1] ‘stats’
[16:11:00.201] getGlobalsAndPackages() ... DONE
[16:11:00.201] run() for ‘Future’ ...
[16:11:00.201] - state: ‘created’
[16:11:00.201] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.202]   - Field: ‘label’
[16:11:00.202]   - Field: ‘local’
[16:11:00.202]   - Field: ‘owner’
[16:11:00.202]   - Field: ‘envir’
[16:11:00.202]   - Field: ‘packages’
[16:11:00.202]   - Field: ‘gc’
[16:11:00.202]   - Field: ‘conditions’
[16:11:00.202]   - Field: ‘expr’
[16:11:00.202]   - Field: ‘uuid’
[16:11:00.202]   - Field: ‘seed’
[16:11:00.202]   - Field: ‘version’
[16:11:00.203]   - Field: ‘result’
[16:11:00.203]   - Field: ‘asynchronous’
[16:11:00.203]   - Field: ‘calls’
[16:11:00.203]   - Field: ‘globals’
[16:11:00.203]   - Field: ‘stdout’
[16:11:00.203]   - Field: ‘earlySignal’
[16:11:00.203]   - Field: ‘lazy’
[16:11:00.203]   - Field: ‘state’
[16:11:00.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.203] - Launch lazy future ...
[16:11:00.204] Packages needed by the future expression (n = 1): ‘stats’
[16:11:00.204] Packages needed by future strategies (n = 0): <none>
[16:11:00.204] {
[16:11:00.204]     {
[16:11:00.204]         {
[16:11:00.204]             ...future.startTime <- base::Sys.time()
[16:11:00.204]             {
[16:11:00.204]                 {
[16:11:00.204]                   {
[16:11:00.204]                     {
[16:11:00.204]                       base::local({
[16:11:00.204]                         has_future <- base::requireNamespace("future", 
[16:11:00.204]                           quietly = TRUE)
[16:11:00.204]                         if (has_future) {
[16:11:00.204]                           ns <- base::getNamespace("future")
[16:11:00.204]                           version <- ns[[".package"]][["version"]]
[16:11:00.204]                           if (is.null(version)) 
[16:11:00.204]                             version <- utils::packageVersion("future")
[16:11:00.204]                         }
[16:11:00.204]                         else {
[16:11:00.204]                           version <- NULL
[16:11:00.204]                         }
[16:11:00.204]                         if (!has_future || version < "1.8.0") {
[16:11:00.204]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.204]                             "", base::R.version$version.string), 
[16:11:00.204]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.204]                               "release", "version")], collapse = " "), 
[16:11:00.204]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.204]                             info)
[16:11:00.204]                           info <- base::paste(info, collapse = "; ")
[16:11:00.204]                           if (!has_future) {
[16:11:00.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.204]                               info)
[16:11:00.204]                           }
[16:11:00.204]                           else {
[16:11:00.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.204]                               info, version)
[16:11:00.204]                           }
[16:11:00.204]                           base::stop(msg)
[16:11:00.204]                         }
[16:11:00.204]                       })
[16:11:00.204]                     }
[16:11:00.204]                     base::local({
[16:11:00.204]                       for (pkg in "stats") {
[16:11:00.204]                         base::loadNamespace(pkg)
[16:11:00.204]                         base::library(pkg, character.only = TRUE)
[16:11:00.204]                       }
[16:11:00.204]                     })
[16:11:00.204]                   }
[16:11:00.204]                   options(future.plan = NULL)
[16:11:00.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.204]                 }
[16:11:00.204]                 ...future.workdir <- getwd()
[16:11:00.204]             }
[16:11:00.204]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.204]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.204]         }
[16:11:00.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.204]             future.globals.maxSize = 3670016000, future.globals.method = NULL, 
[16:11:00.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.204]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.204]             base::names(...future.oldOptions))
[16:11:00.204]     }
[16:11:00.204]     if (FALSE) {
[16:11:00.204]     }
[16:11:00.204]     else {
[16:11:00.204]         if (TRUE) {
[16:11:00.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.204]                 open = "w")
[16:11:00.204]         }
[16:11:00.204]         else {
[16:11:00.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.204]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.204]         }
[16:11:00.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.204]             base::sink(type = "output", split = FALSE)
[16:11:00.204]             base::close(...future.stdout)
[16:11:00.204]         }, add = TRUE)
[16:11:00.204]     }
[16:11:00.204]     ...future.frame <- base::sys.nframe()
[16:11:00.204]     ...future.conditions <- base::list()
[16:11:00.204]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.204]     if (FALSE) {
[16:11:00.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.204]     }
[16:11:00.204]     ...future.result <- base::tryCatch({
[16:11:00.204]         base::withCallingHandlers({
[16:11:00.204]             ...future.value <- base::withVisible(base::local({
[16:11:00.204]                 do.call(function(...) {
[16:11:00.204]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.204]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.204]                     ...future.globals.maxSize)) {
[16:11:00.204]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.204]                     on.exit(options(oopts), add = TRUE)
[16:11:00.204]                   }
[16:11:00.204]                   {
[16:11:00.204]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.204]                       FUN = function(jj) {
[16:11:00.204]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.204]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.204]                       })
[16:11:00.204]                   }
[16:11:00.204]                 }, args = future.call.arguments)
[16:11:00.204]             }))
[16:11:00.204]             future::FutureResult(value = ...future.value$value, 
[16:11:00.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.204]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.204]                     ...future.globalenv.names))
[16:11:00.204]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.204]         }, condition = base::local({
[16:11:00.204]             c <- base::c
[16:11:00.204]             inherits <- base::inherits
[16:11:00.204]             invokeRestart <- base::invokeRestart
[16:11:00.204]             length <- base::length
[16:11:00.204]             list <- base::list
[16:11:00.204]             seq.int <- base::seq.int
[16:11:00.204]             signalCondition <- base::signalCondition
[16:11:00.204]             sys.calls <- base::sys.calls
[16:11:00.204]             `[[` <- base::`[[`
[16:11:00.204]             `+` <- base::`+`
[16:11:00.204]             `<<-` <- base::`<<-`
[16:11:00.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.204]                   3L)]
[16:11:00.204]             }
[16:11:00.204]             function(cond) {
[16:11:00.204]                 is_error <- inherits(cond, "error")
[16:11:00.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.204]                   NULL)
[16:11:00.204]                 if (is_error) {
[16:11:00.204]                   sessionInformation <- function() {
[16:11:00.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.204]                       search = base::search(), system = base::Sys.info())
[16:11:00.204]                   }
[16:11:00.204]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.204]                     cond$call), session = sessionInformation(), 
[16:11:00.204]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.204]                   signalCondition(cond)
[16:11:00.204]                 }
[16:11:00.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.204]                 "immediateCondition"))) {
[16:11:00.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.204]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.204]                   if (TRUE && !signal) {
[16:11:00.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.204]                     {
[16:11:00.204]                       inherits <- base::inherits
[16:11:00.204]                       invokeRestart <- base::invokeRestart
[16:11:00.204]                       is.null <- base::is.null
[16:11:00.204]                       muffled <- FALSE
[16:11:00.204]                       if (inherits(cond, "message")) {
[16:11:00.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.204]                         if (muffled) 
[16:11:00.204]                           invokeRestart("muffleMessage")
[16:11:00.204]                       }
[16:11:00.204]                       else if (inherits(cond, "warning")) {
[16:11:00.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.204]                         if (muffled) 
[16:11:00.204]                           invokeRestart("muffleWarning")
[16:11:00.204]                       }
[16:11:00.204]                       else if (inherits(cond, "condition")) {
[16:11:00.204]                         if (!is.null(pattern)) {
[16:11:00.204]                           computeRestarts <- base::computeRestarts
[16:11:00.204]                           grepl <- base::grepl
[16:11:00.204]                           restarts <- computeRestarts(cond)
[16:11:00.204]                           for (restart in restarts) {
[16:11:00.204]                             name <- restart$name
[16:11:00.204]                             if (is.null(name)) 
[16:11:00.204]                               next
[16:11:00.204]                             if (!grepl(pattern, name)) 
[16:11:00.204]                               next
[16:11:00.204]                             invokeRestart(restart)
[16:11:00.204]                             muffled <- TRUE
[16:11:00.204]                             break
[16:11:00.204]                           }
[16:11:00.204]                         }
[16:11:00.204]                       }
[16:11:00.204]                       invisible(muffled)
[16:11:00.204]                     }
[16:11:00.204]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.204]                   }
[16:11:00.204]                 }
[16:11:00.204]                 else {
[16:11:00.204]                   if (TRUE) {
[16:11:00.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.204]                     {
[16:11:00.204]                       inherits <- base::inherits
[16:11:00.204]                       invokeRestart <- base::invokeRestart
[16:11:00.204]                       is.null <- base::is.null
[16:11:00.204]                       muffled <- FALSE
[16:11:00.204]                       if (inherits(cond, "message")) {
[16:11:00.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.204]                         if (muffled) 
[16:11:00.204]                           invokeRestart("muffleMessage")
[16:11:00.204]                       }
[16:11:00.204]                       else if (inherits(cond, "warning")) {
[16:11:00.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.204]                         if (muffled) 
[16:11:00.204]                           invokeRestart("muffleWarning")
[16:11:00.204]                       }
[16:11:00.204]                       else if (inherits(cond, "condition")) {
[16:11:00.204]                         if (!is.null(pattern)) {
[16:11:00.204]                           computeRestarts <- base::computeRestarts
[16:11:00.204]                           grepl <- base::grepl
[16:11:00.204]                           restarts <- computeRestarts(cond)
[16:11:00.204]                           for (restart in restarts) {
[16:11:00.204]                             name <- restart$name
[16:11:00.204]                             if (is.null(name)) 
[16:11:00.204]                               next
[16:11:00.204]                             if (!grepl(pattern, name)) 
[16:11:00.204]                               next
[16:11:00.204]                             invokeRestart(restart)
[16:11:00.204]                             muffled <- TRUE
[16:11:00.204]                             break
[16:11:00.204]                           }
[16:11:00.204]                         }
[16:11:00.204]                       }
[16:11:00.204]                       invisible(muffled)
[16:11:00.204]                     }
[16:11:00.204]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.204]                   }
[16:11:00.204]                 }
[16:11:00.204]             }
[16:11:00.204]         }))
[16:11:00.204]     }, error = function(ex) {
[16:11:00.204]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.204]                 ...future.rng), started = ...future.startTime, 
[16:11:00.204]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.204]             version = "1.8"), class = "FutureResult")
[16:11:00.204]     }, finally = {
[16:11:00.204]         if (!identical(...future.workdir, getwd())) 
[16:11:00.204]             setwd(...future.workdir)
[16:11:00.204]         {
[16:11:00.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.204]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.204]             }
[16:11:00.204]             base::options(...future.oldOptions)
[16:11:00.204]             if (.Platform$OS.type == "windows") {
[16:11:00.204]                 old_names <- names(...future.oldEnvVars)
[16:11:00.204]                 envs <- base::Sys.getenv()
[16:11:00.204]                 names <- names(envs)
[16:11:00.204]                 common <- intersect(names, old_names)
[16:11:00.204]                 added <- setdiff(names, old_names)
[16:11:00.204]                 removed <- setdiff(old_names, names)
[16:11:00.204]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.204]                   envs[common]]
[16:11:00.204]                 NAMES <- toupper(changed)
[16:11:00.204]                 args <- list()
[16:11:00.204]                 for (kk in seq_along(NAMES)) {
[16:11:00.204]                   name <- changed[[kk]]
[16:11:00.204]                   NAME <- NAMES[[kk]]
[16:11:00.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.204]                     next
[16:11:00.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.204]                 }
[16:11:00.204]                 NAMES <- toupper(added)
[16:11:00.204]                 for (kk in seq_along(NAMES)) {
[16:11:00.204]                   name <- added[[kk]]
[16:11:00.204]                   NAME <- NAMES[[kk]]
[16:11:00.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.204]                     next
[16:11:00.204]                   args[[name]] <- ""
[16:11:00.204]                 }
[16:11:00.204]                 NAMES <- toupper(removed)
[16:11:00.204]                 for (kk in seq_along(NAMES)) {
[16:11:00.204]                   name <- removed[[kk]]
[16:11:00.204]                   NAME <- NAMES[[kk]]
[16:11:00.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.204]                     next
[16:11:00.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.204]                 }
[16:11:00.204]                 if (length(args) > 0) 
[16:11:00.204]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.204]             }
[16:11:00.204]             else {
[16:11:00.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.204]             }
[16:11:00.204]             {
[16:11:00.204]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.204]                   0L) {
[16:11:00.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.204]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.204]                   base::options(opts)
[16:11:00.204]                 }
[16:11:00.204]                 {
[16:11:00.204]                   {
[16:11:00.204]                     NULL
[16:11:00.204]                     RNGkind("Mersenne-Twister")
[16:11:00.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.204]                       inherits = FALSE)
[16:11:00.204]                   }
[16:11:00.204]                   options(future.plan = NULL)
[16:11:00.204]                   if (is.na(NA_character_)) 
[16:11:00.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.204]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.204]                   {
[16:11:00.204]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.204]                     if (!future$lazy) 
[16:11:00.204]                       future <- run(future)
[16:11:00.204]                     invisible(future)
[16:11:00.204]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.204]                 }
[16:11:00.204]             }
[16:11:00.204]         }
[16:11:00.204]     })
[16:11:00.204]     if (TRUE) {
[16:11:00.204]         base::sink(type = "output", split = FALSE)
[16:11:00.204]         if (TRUE) {
[16:11:00.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.204]         }
[16:11:00.204]         else {
[16:11:00.204]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.204]         }
[16:11:00.204]         base::close(...future.stdout)
[16:11:00.204]         ...future.stdout <- NULL
[16:11:00.204]     }
[16:11:00.204]     ...future.result$conditions <- ...future.conditions
[16:11:00.204]     ...future.result$finished <- base::Sys.time()
[16:11:00.204]     ...future.result
[16:11:00.204] }
[16:11:00.206] assign_globals() ...
[16:11:00.206] List of 5
[16:11:00.206]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:11:00.206]  $ future.call.arguments    : list()
[16:11:00.206]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.206]  $ ...future.elements_ii    :List of 7
[16:11:00.206]   ..$ : int [1:3] 1 2 3
[16:11:00.206]   ..$ : int [1:4] 1 2 3 4
[16:11:00.206]   ..$ : int [1:5] 1 2 3 4 5
[16:11:00.206]   ..$ : int [1:6] 1 2 3 4 5 6
[16:11:00.206]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:11:00.206]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:11:00.206]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:11:00.206]  $ ...future.seeds_ii       : NULL
[16:11:00.206]  $ ...future.globals.maxSize: NULL
[16:11:00.206]  - attr(*, "resolved")= logi FALSE
[16:11:00.206]  - attr(*, "total_size")= num 46960
[16:11:00.206]  - attr(*, "where")=List of 5
[16:11:00.206]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.206]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.206]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.206]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.206]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.206]  - attr(*, "already-done")= logi TRUE
[16:11:00.212] - copied ‘...future.FUN’ to environment
[16:11:00.212] - copied ‘future.call.arguments’ to environment
[16:11:00.212] - copied ‘...future.elements_ii’ to environment
[16:11:00.212] - copied ‘...future.seeds_ii’ to environment
[16:11:00.212] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.212] assign_globals() ... done
[16:11:00.213] plan(): Setting new future strategy stack:
[16:11:00.213] List of future strategies:
[16:11:00.213] 1. sequential:
[16:11:00.213]    - args: function (..., envir = parent.frame())
[16:11:00.213]    - tweaked: FALSE
[16:11:00.213]    - call: NULL
[16:11:00.213] plan(): nbrOfWorkers() = 1
[16:11:00.214] plan(): Setting new future strategy stack:
[16:11:00.214] List of future strategies:
[16:11:00.214] 1. sequential:
[16:11:00.214]    - args: function (..., envir = parent.frame())
[16:11:00.214]    - tweaked: FALSE
[16:11:00.214]    - call: plan(strategy)
[16:11:00.214] plan(): nbrOfWorkers() = 1
[16:11:00.214] SequentialFuture started (and completed)
[16:11:00.215] - Launch lazy future ... done
[16:11:00.215] run() for ‘SequentialFuture’ ... done
[16:11:00.215] Created future:
[16:11:00.215] SequentialFuture:
[16:11:00.215] Label: ‘future_sapply-1’
[16:11:00.215] Expression:
[16:11:00.215] {
[16:11:00.215]     do.call(function(...) {
[16:11:00.215]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.215]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.215]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.215]             on.exit(options(oopts), add = TRUE)
[16:11:00.215]         }
[16:11:00.215]         {
[16:11:00.215]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.215]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.215]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.215]             })
[16:11:00.215]         }
[16:11:00.215]     }, args = future.call.arguments)
[16:11:00.215] }
[16:11:00.215] Lazy evaluation: FALSE
[16:11:00.215] Asynchronous evaluation: FALSE
[16:11:00.215] Local evaluation: TRUE
[16:11:00.215] Environment: R_GlobalEnv
[16:11:00.215] Capture standard output: TRUE
[16:11:00.215] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.215] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:00.215] Packages: 1 packages (‘stats’)
[16:11:00.215] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.215] Resolved: TRUE
[16:11:00.215] Value: 672 bytes of class ‘list’
[16:11:00.215] Early signaling: FALSE
[16:11:00.215] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.215] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.216] Chunk #1 of 1 ... DONE
[16:11:00.216] Launching 1 futures (chunks) ... DONE
[16:11:00.216] Resolving 1 futures (chunks) ...
[16:11:00.216] resolve() on list ...
[16:11:00.216]  recursive: 0
[16:11:00.216]  length: 1
[16:11:00.216] 
[16:11:00.217] resolved() for ‘SequentialFuture’ ...
[16:11:00.217] - state: ‘finished’
[16:11:00.218] - run: TRUE
[16:11:00.218] - result: ‘FutureResult’
[16:11:00.218] resolved() for ‘SequentialFuture’ ... done
[16:11:00.218] Future #1
[16:11:00.218] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.218] - nx: 1
[16:11:00.218] - relay: TRUE
[16:11:00.218] - stdout: TRUE
[16:11:00.218] - signal: TRUE
[16:11:00.218] - resignal: FALSE
[16:11:00.218] - force: TRUE
[16:11:00.219] - relayed: [n=1] FALSE
[16:11:00.219] - queued futures: [n=1] FALSE
[16:11:00.219]  - until=1
[16:11:00.219]  - relaying element #1
[16:11:00.219] - relayed: [n=1] TRUE
[16:11:00.219] - queued futures: [n=1] TRUE
[16:11:00.219] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.219]  length: 0 (resolved future 1)
[16:11:00.219] Relaying remaining futures
[16:11:00.219] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.219] - nx: 1
[16:11:00.220] - relay: TRUE
[16:11:00.220] - stdout: TRUE
[16:11:00.220] - signal: TRUE
[16:11:00.220] - resignal: FALSE
[16:11:00.220] - force: TRUE
[16:11:00.220] - relayed: [n=1] TRUE
[16:11:00.220] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.220] - relayed: [n=1] TRUE
[16:11:00.220] - queued futures: [n=1] TRUE
[16:11:00.220] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.220] resolve() on list ... DONE
[16:11:00.221]  - Number of value chunks collected: 1
[16:11:00.221] Resolving 1 futures (chunks) ... DONE
[16:11:00.221] Reducing values from 1 chunks ...
[16:11:00.221]  - Number of values collected after concatenation: 7
[16:11:00.221]  - Number of values expected: 7
[16:11:00.221] Reducing values from 1 chunks ... DONE
[16:11:00.221] future_lapply() ... DONE
[16:11:00.221] future_lapply() ...
[16:11:00.223] Number of chunks: 1
[16:11:00.223] getGlobalsAndPackagesXApply() ...
[16:11:00.223]  - future.globals: TRUE
[16:11:00.223] getGlobalsAndPackages() ...
[16:11:00.223] Searching for globals...
[16:11:00.230] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:11:00.230] Searching for globals ... DONE
[16:11:00.230] Resolving globals: FALSE
[16:11:00.231] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:11:00.232] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:11:00.232] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.232] - packages: [2] ‘stats’, ‘future.apply’
[16:11:00.232] getGlobalsAndPackages() ... DONE
[16:11:00.232]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.232]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:11:00.232] Finding globals ... DONE
[16:11:00.232]  - use_args: TRUE
[16:11:00.232]  - Getting '...' globals ...
[16:11:00.233] resolve() on list ...
[16:11:00.233]  recursive: 0
[16:11:00.233]  length: 1
[16:11:00.233]  elements: ‘...’
[16:11:00.233]  length: 0 (resolved future 1)
[16:11:00.233] resolve() on list ... DONE
[16:11:00.233]    - '...' content: [n=0] 
[16:11:00.233] List of 1
[16:11:00.233]  $ ...: list()
[16:11:00.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.233]  - attr(*, "where")=List of 1
[16:11:00.233]   ..$ ...:<environment: 0x561e88a2a230> 
[16:11:00.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.233]  - attr(*, "resolved")= logi TRUE
[16:11:00.233]  - attr(*, "total_size")= num NA
[16:11:00.237]  - Getting '...' globals ... DONE
[16:11:00.237] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.237] List of 8
[16:11:00.237]  $ ...future.FUN:function (x, ...)  
[16:11:00.237]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:11:00.237]  $ times        : int 5
[16:11:00.237]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.237]  $ stop_if_not  :function (...)  
[16:11:00.237]  $ dim          : NULL
[16:11:00.237]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:00.237]  $ ...          : list()
[16:11:00.237]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.237]  - attr(*, "where")=List of 8
[16:11:00.237]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.237]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.237]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.237]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.237]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.237]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.237]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.237]   ..$ ...          :<environment: 0x561e88a2a230> 
[16:11:00.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.237]  - attr(*, "resolved")= logi FALSE
[16:11:00.237]  - attr(*, "total_size")= num 141240
[16:11:00.242] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:11:00.242] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.242] Number of futures (= number of chunks): 1
[16:11:00.242] Launching 1 futures (chunks) ...
[16:11:00.243] Chunk #1 of 1 ...
[16:11:00.243]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.243] getGlobalsAndPackages() ...
[16:11:00.243] Searching for globals...
[16:11:00.243] 
[16:11:00.243] Searching for globals ... DONE
[16:11:00.243] - globals: [0] <none>
[16:11:00.243] getGlobalsAndPackages() ... DONE
[16:11:00.243]    + additional globals found: [n=0] 
[16:11:00.243]    + additional namespaces needed: [n=0] 
[16:11:00.244]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.244]  - Adjusted option 'future.globals.maxSize': 524288000 -> 7 * 524288000 = 3670016000 (bytes)
[16:11:00.244]  - seeds: <none>
[16:11:00.244] getGlobalsAndPackages() ...
[16:11:00.244] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.244] Resolving globals: FALSE
[16:11:00.244] Tweak future expression to call with '...' arguments ...
[16:11:00.244] {
[16:11:00.244]     do.call(function(...) {
[16:11:00.244]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.244]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.244]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.244]             on.exit(options(oopts), add = TRUE)
[16:11:00.244]         }
[16:11:00.244]         {
[16:11:00.244]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.244]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.244]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.244]             })
[16:11:00.244]         }
[16:11:00.244]     }, args = future.call.arguments)
[16:11:00.244] }
[16:11:00.245] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.245] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.245] - packages: [2] ‘stats’, ‘future.apply’
[16:11:00.245] getGlobalsAndPackages() ... DONE
[16:11:00.246] run() for ‘Future’ ...
[16:11:00.246] - state: ‘created’
[16:11:00.246] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.246] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.246]   - Field: ‘label’
[16:11:00.246]   - Field: ‘local’
[16:11:00.246]   - Field: ‘owner’
[16:11:00.246]   - Field: ‘envir’
[16:11:00.247]   - Field: ‘packages’
[16:11:00.247]   - Field: ‘gc’
[16:11:00.247]   - Field: ‘conditions’
[16:11:00.247]   - Field: ‘expr’
[16:11:00.247]   - Field: ‘uuid’
[16:11:00.247]   - Field: ‘seed’
[16:11:00.247]   - Field: ‘version’
[16:11:00.247]   - Field: ‘result’
[16:11:00.247]   - Field: ‘asynchronous’
[16:11:00.247]   - Field: ‘calls’
[16:11:00.247]   - Field: ‘globals’
[16:11:00.248]   - Field: ‘stdout’
[16:11:00.248]   - Field: ‘earlySignal’
[16:11:00.248]   - Field: ‘lazy’
[16:11:00.248]   - Field: ‘state’
[16:11:00.248] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.248] - Launch lazy future ...
[16:11:00.248] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:00.248] Packages needed by future strategies (n = 0): <none>
[16:11:00.249] {
[16:11:00.249]     {
[16:11:00.249]         {
[16:11:00.249]             ...future.startTime <- base::Sys.time()
[16:11:00.249]             {
[16:11:00.249]                 {
[16:11:00.249]                   {
[16:11:00.249]                     {
[16:11:00.249]                       base::local({
[16:11:00.249]                         has_future <- base::requireNamespace("future", 
[16:11:00.249]                           quietly = TRUE)
[16:11:00.249]                         if (has_future) {
[16:11:00.249]                           ns <- base::getNamespace("future")
[16:11:00.249]                           version <- ns[[".package"]][["version"]]
[16:11:00.249]                           if (is.null(version)) 
[16:11:00.249]                             version <- utils::packageVersion("future")
[16:11:00.249]                         }
[16:11:00.249]                         else {
[16:11:00.249]                           version <- NULL
[16:11:00.249]                         }
[16:11:00.249]                         if (!has_future || version < "1.8.0") {
[16:11:00.249]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.249]                             "", base::R.version$version.string), 
[16:11:00.249]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.249]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.249]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.249]                               "release", "version")], collapse = " "), 
[16:11:00.249]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.249]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.249]                             info)
[16:11:00.249]                           info <- base::paste(info, collapse = "; ")
[16:11:00.249]                           if (!has_future) {
[16:11:00.249]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.249]                               info)
[16:11:00.249]                           }
[16:11:00.249]                           else {
[16:11:00.249]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.249]                               info, version)
[16:11:00.249]                           }
[16:11:00.249]                           base::stop(msg)
[16:11:00.249]                         }
[16:11:00.249]                       })
[16:11:00.249]                     }
[16:11:00.249]                     base::local({
[16:11:00.249]                       for (pkg in c("stats", "future.apply")) {
[16:11:00.249]                         base::loadNamespace(pkg)
[16:11:00.249]                         base::library(pkg, character.only = TRUE)
[16:11:00.249]                       }
[16:11:00.249]                     })
[16:11:00.249]                   }
[16:11:00.249]                   options(future.plan = NULL)
[16:11:00.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.249]                 }
[16:11:00.249]                 ...future.workdir <- getwd()
[16:11:00.249]             }
[16:11:00.249]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.249]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.249]         }
[16:11:00.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.249]             future.globals.maxSize = 3670016000, future.globals.method = NULL, 
[16:11:00.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.249]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.249]             base::names(...future.oldOptions))
[16:11:00.249]     }
[16:11:00.249]     if (FALSE) {
[16:11:00.249]     }
[16:11:00.249]     else {
[16:11:00.249]         if (TRUE) {
[16:11:00.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.249]                 open = "w")
[16:11:00.249]         }
[16:11:00.249]         else {
[16:11:00.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.249]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.249]         }
[16:11:00.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.249]             base::sink(type = "output", split = FALSE)
[16:11:00.249]             base::close(...future.stdout)
[16:11:00.249]         }, add = TRUE)
[16:11:00.249]     }
[16:11:00.249]     ...future.frame <- base::sys.nframe()
[16:11:00.249]     ...future.conditions <- base::list()
[16:11:00.249]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.249]     if (FALSE) {
[16:11:00.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.249]     }
[16:11:00.249]     ...future.result <- base::tryCatch({
[16:11:00.249]         base::withCallingHandlers({
[16:11:00.249]             ...future.value <- base::withVisible(base::local({
[16:11:00.249]                 do.call(function(...) {
[16:11:00.249]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.249]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.249]                     ...future.globals.maxSize)) {
[16:11:00.249]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.249]                     on.exit(options(oopts), add = TRUE)
[16:11:00.249]                   }
[16:11:00.249]                   {
[16:11:00.249]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.249]                       FUN = function(jj) {
[16:11:00.249]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.249]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.249]                       })
[16:11:00.249]                   }
[16:11:00.249]                 }, args = future.call.arguments)
[16:11:00.249]             }))
[16:11:00.249]             future::FutureResult(value = ...future.value$value, 
[16:11:00.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.249]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.249]                     ...future.globalenv.names))
[16:11:00.249]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.249]         }, condition = base::local({
[16:11:00.249]             c <- base::c
[16:11:00.249]             inherits <- base::inherits
[16:11:00.249]             invokeRestart <- base::invokeRestart
[16:11:00.249]             length <- base::length
[16:11:00.249]             list <- base::list
[16:11:00.249]             seq.int <- base::seq.int
[16:11:00.249]             signalCondition <- base::signalCondition
[16:11:00.249]             sys.calls <- base::sys.calls
[16:11:00.249]             `[[` <- base::`[[`
[16:11:00.249]             `+` <- base::`+`
[16:11:00.249]             `<<-` <- base::`<<-`
[16:11:00.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.249]                   3L)]
[16:11:00.249]             }
[16:11:00.249]             function(cond) {
[16:11:00.249]                 is_error <- inherits(cond, "error")
[16:11:00.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.249]                   NULL)
[16:11:00.249]                 if (is_error) {
[16:11:00.249]                   sessionInformation <- function() {
[16:11:00.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.249]                       search = base::search(), system = base::Sys.info())
[16:11:00.249]                   }
[16:11:00.249]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.249]                     cond$call), session = sessionInformation(), 
[16:11:00.249]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.249]                   signalCondition(cond)
[16:11:00.249]                 }
[16:11:00.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.249]                 "immediateCondition"))) {
[16:11:00.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.249]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.249]                   if (TRUE && !signal) {
[16:11:00.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.249]                     {
[16:11:00.249]                       inherits <- base::inherits
[16:11:00.249]                       invokeRestart <- base::invokeRestart
[16:11:00.249]                       is.null <- base::is.null
[16:11:00.249]                       muffled <- FALSE
[16:11:00.249]                       if (inherits(cond, "message")) {
[16:11:00.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.249]                         if (muffled) 
[16:11:00.249]                           invokeRestart("muffleMessage")
[16:11:00.249]                       }
[16:11:00.249]                       else if (inherits(cond, "warning")) {
[16:11:00.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.249]                         if (muffled) 
[16:11:00.249]                           invokeRestart("muffleWarning")
[16:11:00.249]                       }
[16:11:00.249]                       else if (inherits(cond, "condition")) {
[16:11:00.249]                         if (!is.null(pattern)) {
[16:11:00.249]                           computeRestarts <- base::computeRestarts
[16:11:00.249]                           grepl <- base::grepl
[16:11:00.249]                           restarts <- computeRestarts(cond)
[16:11:00.249]                           for (restart in restarts) {
[16:11:00.249]                             name <- restart$name
[16:11:00.249]                             if (is.null(name)) 
[16:11:00.249]                               next
[16:11:00.249]                             if (!grepl(pattern, name)) 
[16:11:00.249]                               next
[16:11:00.249]                             invokeRestart(restart)
[16:11:00.249]                             muffled <- TRUE
[16:11:00.249]                             break
[16:11:00.249]                           }
[16:11:00.249]                         }
[16:11:00.249]                       }
[16:11:00.249]                       invisible(muffled)
[16:11:00.249]                     }
[16:11:00.249]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.249]                   }
[16:11:00.249]                 }
[16:11:00.249]                 else {
[16:11:00.249]                   if (TRUE) {
[16:11:00.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.249]                     {
[16:11:00.249]                       inherits <- base::inherits
[16:11:00.249]                       invokeRestart <- base::invokeRestart
[16:11:00.249]                       is.null <- base::is.null
[16:11:00.249]                       muffled <- FALSE
[16:11:00.249]                       if (inherits(cond, "message")) {
[16:11:00.249]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.249]                         if (muffled) 
[16:11:00.249]                           invokeRestart("muffleMessage")
[16:11:00.249]                       }
[16:11:00.249]                       else if (inherits(cond, "warning")) {
[16:11:00.249]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.249]                         if (muffled) 
[16:11:00.249]                           invokeRestart("muffleWarning")
[16:11:00.249]                       }
[16:11:00.249]                       else if (inherits(cond, "condition")) {
[16:11:00.249]                         if (!is.null(pattern)) {
[16:11:00.249]                           computeRestarts <- base::computeRestarts
[16:11:00.249]                           grepl <- base::grepl
[16:11:00.249]                           restarts <- computeRestarts(cond)
[16:11:00.249]                           for (restart in restarts) {
[16:11:00.249]                             name <- restart$name
[16:11:00.249]                             if (is.null(name)) 
[16:11:00.249]                               next
[16:11:00.249]                             if (!grepl(pattern, name)) 
[16:11:00.249]                               next
[16:11:00.249]                             invokeRestart(restart)
[16:11:00.249]                             muffled <- TRUE
[16:11:00.249]                             break
[16:11:00.249]                           }
[16:11:00.249]                         }
[16:11:00.249]                       }
[16:11:00.249]                       invisible(muffled)
[16:11:00.249]                     }
[16:11:00.249]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.249]                   }
[16:11:00.249]                 }
[16:11:00.249]             }
[16:11:00.249]         }))
[16:11:00.249]     }, error = function(ex) {
[16:11:00.249]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.249]                 ...future.rng), started = ...future.startTime, 
[16:11:00.249]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.249]             version = "1.8"), class = "FutureResult")
[16:11:00.249]     }, finally = {
[16:11:00.249]         if (!identical(...future.workdir, getwd())) 
[16:11:00.249]             setwd(...future.workdir)
[16:11:00.249]         {
[16:11:00.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.249]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.249]             }
[16:11:00.249]             base::options(...future.oldOptions)
[16:11:00.249]             if (.Platform$OS.type == "windows") {
[16:11:00.249]                 old_names <- names(...future.oldEnvVars)
[16:11:00.249]                 envs <- base::Sys.getenv()
[16:11:00.249]                 names <- names(envs)
[16:11:00.249]                 common <- intersect(names, old_names)
[16:11:00.249]                 added <- setdiff(names, old_names)
[16:11:00.249]                 removed <- setdiff(old_names, names)
[16:11:00.249]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.249]                   envs[common]]
[16:11:00.249]                 NAMES <- toupper(changed)
[16:11:00.249]                 args <- list()
[16:11:00.249]                 for (kk in seq_along(NAMES)) {
[16:11:00.249]                   name <- changed[[kk]]
[16:11:00.249]                   NAME <- NAMES[[kk]]
[16:11:00.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.249]                     next
[16:11:00.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.249]                 }
[16:11:00.249]                 NAMES <- toupper(added)
[16:11:00.249]                 for (kk in seq_along(NAMES)) {
[16:11:00.249]                   name <- added[[kk]]
[16:11:00.249]                   NAME <- NAMES[[kk]]
[16:11:00.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.249]                     next
[16:11:00.249]                   args[[name]] <- ""
[16:11:00.249]                 }
[16:11:00.249]                 NAMES <- toupper(removed)
[16:11:00.249]                 for (kk in seq_along(NAMES)) {
[16:11:00.249]                   name <- removed[[kk]]
[16:11:00.249]                   NAME <- NAMES[[kk]]
[16:11:00.249]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.249]                     next
[16:11:00.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.249]                 }
[16:11:00.249]                 if (length(args) > 0) 
[16:11:00.249]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.249]             }
[16:11:00.249]             else {
[16:11:00.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.249]             }
[16:11:00.249]             {
[16:11:00.249]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.249]                   0L) {
[16:11:00.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.249]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.249]                   base::options(opts)
[16:11:00.249]                 }
[16:11:00.249]                 {
[16:11:00.249]                   {
[16:11:00.249]                     NULL
[16:11:00.249]                     RNGkind("Mersenne-Twister")
[16:11:00.249]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.249]                       inherits = FALSE)
[16:11:00.249]                   }
[16:11:00.249]                   options(future.plan = NULL)
[16:11:00.249]                   if (is.na(NA_character_)) 
[16:11:00.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.249]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.249]                   {
[16:11:00.249]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.249]                     if (!future$lazy) 
[16:11:00.249]                       future <- run(future)
[16:11:00.249]                     invisible(future)
[16:11:00.249]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.249]                 }
[16:11:00.249]             }
[16:11:00.249]         }
[16:11:00.249]     })
[16:11:00.249]     if (TRUE) {
[16:11:00.249]         base::sink(type = "output", split = FALSE)
[16:11:00.249]         if (TRUE) {
[16:11:00.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.249]         }
[16:11:00.249]         else {
[16:11:00.249]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.249]         }
[16:11:00.249]         base::close(...future.stdout)
[16:11:00.249]         ...future.stdout <- NULL
[16:11:00.249]     }
[16:11:00.249]     ...future.result$conditions <- ...future.conditions
[16:11:00.249]     ...future.result$finished <- base::Sys.time()
[16:11:00.249]     ...future.result
[16:11:00.249] }
[16:11:00.250] assign_globals() ...
[16:11:00.251] List of 11
[16:11:00.251]  $ ...future.FUN            :function (x, ...)  
[16:11:00.251]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:11:00.251]  $ times                    : int 5
[16:11:00.251]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.251]  $ stop_if_not              :function (...)  
[16:11:00.251]  $ dim                      : NULL
[16:11:00.251]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.251]  $ future.call.arguments    : list()
[16:11:00.251]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.251]  $ ...future.elements_ii    :List of 7
[16:11:00.251]   ..$ : int [1:3] 1 2 3
[16:11:00.251]   ..$ : int [1:4] 1 2 3 4
[16:11:00.251]   ..$ : int [1:5] 1 2 3 4 5
[16:11:00.251]   ..$ : int [1:6] 1 2 3 4 5 6
[16:11:00.251]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:11:00.251]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:11:00.251]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:11:00.251]  $ ...future.seeds_ii       : NULL
[16:11:00.251]  $ ...future.globals.maxSize: NULL
[16:11:00.251]  - attr(*, "resolved")= logi FALSE
[16:11:00.251]  - attr(*, "total_size")= num 141240
[16:11:00.251]  - attr(*, "where")=List of 11
[16:11:00.251]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.251]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.251]  - attr(*, "already-done")= logi TRUE
[16:11:00.260] - copied ‘...future.FUN’ to environment
[16:11:00.260] - copied ‘x_FUN’ to environment
[16:11:00.260] - copied ‘times’ to environment
[16:11:00.260] - copied ‘stopf’ to environment
[16:11:00.260] - copied ‘stop_if_not’ to environment
[16:11:00.261] - copied ‘dim’ to environment
[16:11:00.261] - copied ‘valid_types’ to environment
[16:11:00.261] - copied ‘future.call.arguments’ to environment
[16:11:00.261] - copied ‘...future.elements_ii’ to environment
[16:11:00.261] - copied ‘...future.seeds_ii’ to environment
[16:11:00.261] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.261] assign_globals() ... done
[16:11:00.261] plan(): Setting new future strategy stack:
[16:11:00.262] List of future strategies:
[16:11:00.262] 1. sequential:
[16:11:00.262]    - args: function (..., envir = parent.frame())
[16:11:00.262]    - tweaked: FALSE
[16:11:00.262]    - call: NULL
[16:11:00.262] plan(): nbrOfWorkers() = 1
[16:11:00.263] plan(): Setting new future strategy stack:
[16:11:00.263] List of future strategies:
[16:11:00.263] 1. sequential:
[16:11:00.263]    - args: function (..., envir = parent.frame())
[16:11:00.263]    - tweaked: FALSE
[16:11:00.263]    - call: plan(strategy)
[16:11:00.263] plan(): nbrOfWorkers() = 1
[16:11:00.263] SequentialFuture started (and completed)
[16:11:00.263] - Launch lazy future ... done
[16:11:00.264] run() for ‘SequentialFuture’ ... done
[16:11:00.264] Created future:
[16:11:00.264] SequentialFuture:
[16:11:00.264] Label: ‘future_vapply-1’
[16:11:00.264] Expression:
[16:11:00.264] {
[16:11:00.264]     do.call(function(...) {
[16:11:00.264]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.264]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.264]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.264]             on.exit(options(oopts), add = TRUE)
[16:11:00.264]         }
[16:11:00.264]         {
[16:11:00.264]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.264]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.264]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.264]             })
[16:11:00.264]         }
[16:11:00.264]     }, args = future.call.arguments)
[16:11:00.264] }
[16:11:00.264] Lazy evaluation: FALSE
[16:11:00.264] Asynchronous evaluation: FALSE
[16:11:00.264] Local evaluation: TRUE
[16:11:00.264] Environment: R_GlobalEnv
[16:11:00.264] Capture standard output: TRUE
[16:11:00.264] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.264] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.264] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:00.264] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.264] Resolved: TRUE
[16:11:00.264] Value: 672 bytes of class ‘list’
[16:11:00.264] Early signaling: FALSE
[16:11:00.264] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.264] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.265] Chunk #1 of 1 ... DONE
[16:11:00.265] Launching 1 futures (chunks) ... DONE
[16:11:00.265] Resolving 1 futures (chunks) ...
[16:11:00.265] resolve() on list ...
[16:11:00.265]  recursive: 0
[16:11:00.265]  length: 1
[16:11:00.265] 
[16:11:00.266] resolved() for ‘SequentialFuture’ ...
[16:11:00.266] - state: ‘finished’
[16:11:00.266] - run: TRUE
[16:11:00.266] - result: ‘FutureResult’
[16:11:00.266] resolved() for ‘SequentialFuture’ ... done
[16:11:00.266] Future #1
[16:11:00.266] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.266] - nx: 1
[16:11:00.266] - relay: TRUE
[16:11:00.266] - stdout: TRUE
[16:11:00.266] - signal: TRUE
[16:11:00.267] - resignal: FALSE
[16:11:00.267] - force: TRUE
[16:11:00.267] - relayed: [n=1] FALSE
[16:11:00.267] - queued futures: [n=1] FALSE
[16:11:00.267]  - until=1
[16:11:00.267]  - relaying element #1
[16:11:00.267] - relayed: [n=1] TRUE
[16:11:00.267] - queued futures: [n=1] TRUE
[16:11:00.267] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.267]  length: 0 (resolved future 1)
[16:11:00.268] Relaying remaining futures
[16:11:00.268] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.268] - nx: 1
[16:11:00.268] - relay: TRUE
[16:11:00.268] - stdout: TRUE
[16:11:00.268] - signal: TRUE
[16:11:00.268] - resignal: FALSE
[16:11:00.268] - force: TRUE
[16:11:00.268] - relayed: [n=1] TRUE
[16:11:00.268] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.268] - relayed: [n=1] TRUE
[16:11:00.268] - queued futures: [n=1] TRUE
[16:11:00.269] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.269] resolve() on list ... DONE
[16:11:00.269]  - Number of value chunks collected: 1
[16:11:00.269] Resolving 1 futures (chunks) ... DONE
[16:11:00.269] Reducing values from 1 chunks ...
[16:11:00.269]  - Number of values collected after concatenation: 7
[16:11:00.269]  - Number of values expected: 7
[16:11:00.269] Reducing values from 1 chunks ... DONE
[16:11:00.269] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:11:00.271] future_lapply() ...
[16:11:00.271] Number of chunks: 1
[16:11:00.272] getGlobalsAndPackagesXApply() ...
[16:11:00.272]  - future.globals: TRUE
[16:11:00.272] getGlobalsAndPackages() ...
[16:11:00.272] Searching for globals...
[16:11:00.273] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:11:00.273] Searching for globals ... DONE
[16:11:00.273] Resolving globals: FALSE
[16:11:00.273] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:11:00.274] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:11:00.274] - globals: [1] ‘FUN’
[16:11:00.274] 
[16:11:00.274] getGlobalsAndPackages() ... DONE
[16:11:00.274]  - globals found/used: [n=1] ‘FUN’
[16:11:00.274]  - needed namespaces: [n=0] 
[16:11:00.274] Finding globals ... DONE
[16:11:00.274]  - use_args: TRUE
[16:11:00.275]  - Getting '...' globals ...
[16:11:00.275] resolve() on list ...
[16:11:00.275]  recursive: 0
[16:11:00.275]  length: 1
[16:11:00.275]  elements: ‘...’
[16:11:00.275]  length: 0 (resolved future 1)
[16:11:00.275] resolve() on list ... DONE
[16:11:00.275]    - '...' content: [n=1] ‘y’
[16:11:00.275] List of 1
[16:11:00.275]  $ ...:List of 1
[16:11:00.275]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:00.275]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.275]  - attr(*, "where")=List of 1
[16:11:00.275]   ..$ ...:<environment: 0x561e8a24fe38> 
[16:11:00.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.275]  - attr(*, "resolved")= logi TRUE
[16:11:00.275]  - attr(*, "total_size")= num NA
[16:11:00.279]  - Getting '...' globals ... DONE
[16:11:00.280] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:00.280] List of 2
[16:11:00.280]  $ ...future.FUN:function (x, y)  
[16:11:00.280]  $ ...          :List of 1
[16:11:00.280]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:00.280]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.280]  - attr(*, "where")=List of 2
[16:11:00.280]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.280]   ..$ ...          :<environment: 0x561e8a24fe38> 
[16:11:00.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.280]  - attr(*, "resolved")= logi FALSE
[16:11:00.280]  - attr(*, "total_size")= num 4264
[16:11:00.283] Packages to be attached in all futures: [n=0] 
[16:11:00.283] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.283] Number of futures (= number of chunks): 1
[16:11:00.283] Launching 1 futures (chunks) ...
[16:11:00.283] Chunk #1 of 1 ...
[16:11:00.283]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.283] getGlobalsAndPackages() ...
[16:11:00.283] Searching for globals...
[16:11:00.284] 
[16:11:00.284] Searching for globals ... DONE
[16:11:00.284] - globals: [0] <none>
[16:11:00.284] getGlobalsAndPackages() ... DONE
[16:11:00.284]    + additional globals found: [n=0] 
[16:11:00.284]    + additional namespaces needed: [n=0] 
[16:11:00.284]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.284]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[16:11:00.284]  - seeds: <none>
[16:11:00.285] getGlobalsAndPackages() ...
[16:11:00.285] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.285] Resolving globals: FALSE
[16:11:00.285] Tweak future expression to call with '...' arguments ...
[16:11:00.285] {
[16:11:00.285]     do.call(function(...) {
[16:11:00.285]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.285]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.285]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.285]             on.exit(options(oopts), add = TRUE)
[16:11:00.285]         }
[16:11:00.285]         {
[16:11:00.285]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.285]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.285]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.285]             })
[16:11:00.285]         }
[16:11:00.285]     }, args = future.call.arguments)
[16:11:00.285] }
[16:11:00.285] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.285] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.286] 
[16:11:00.286] getGlobalsAndPackages() ... DONE
[16:11:00.286] run() for ‘Future’ ...
[16:11:00.286] - state: ‘created’
[16:11:00.286] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.286] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.287] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.287]   - Field: ‘label’
[16:11:00.287]   - Field: ‘local’
[16:11:00.287]   - Field: ‘owner’
[16:11:00.287]   - Field: ‘envir’
[16:11:00.287]   - Field: ‘packages’
[16:11:00.287]   - Field: ‘gc’
[16:11:00.287]   - Field: ‘conditions’
[16:11:00.287]   - Field: ‘expr’
[16:11:00.287]   - Field: ‘uuid’
[16:11:00.287]   - Field: ‘seed’
[16:11:00.288]   - Field: ‘version’
[16:11:00.288]   - Field: ‘result’
[16:11:00.288]   - Field: ‘asynchronous’
[16:11:00.288]   - Field: ‘calls’
[16:11:00.288]   - Field: ‘globals’
[16:11:00.288]   - Field: ‘stdout’
[16:11:00.288]   - Field: ‘earlySignal’
[16:11:00.288]   - Field: ‘lazy’
[16:11:00.288]   - Field: ‘state’
[16:11:00.288] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.288] - Launch lazy future ...
[16:11:00.289] Packages needed by the future expression (n = 0): <none>
[16:11:00.289] Packages needed by future strategies (n = 0): <none>
[16:11:00.289] {
[16:11:00.289]     {
[16:11:00.289]         {
[16:11:00.289]             ...future.startTime <- base::Sys.time()
[16:11:00.289]             {
[16:11:00.289]                 {
[16:11:00.289]                   {
[16:11:00.289]                     base::local({
[16:11:00.289]                       has_future <- base::requireNamespace("future", 
[16:11:00.289]                         quietly = TRUE)
[16:11:00.289]                       if (has_future) {
[16:11:00.289]                         ns <- base::getNamespace("future")
[16:11:00.289]                         version <- ns[[".package"]][["version"]]
[16:11:00.289]                         if (is.null(version)) 
[16:11:00.289]                           version <- utils::packageVersion("future")
[16:11:00.289]                       }
[16:11:00.289]                       else {
[16:11:00.289]                         version <- NULL
[16:11:00.289]                       }
[16:11:00.289]                       if (!has_future || version < "1.8.0") {
[16:11:00.289]                         info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.289]                           "", base::R.version$version.string), 
[16:11:00.289]                           platform = base::sprintf("%s (%s-bit)", 
[16:11:00.289]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.289]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.289]                             "release", "version")], collapse = " "), 
[16:11:00.289]                           hostname = base::Sys.info()[["nodename"]])
[16:11:00.289]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.289]                           info)
[16:11:00.289]                         info <- base::paste(info, collapse = "; ")
[16:11:00.289]                         if (!has_future) {
[16:11:00.289]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.289]                             info)
[16:11:00.289]                         }
[16:11:00.289]                         else {
[16:11:00.289]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.289]                             info, version)
[16:11:00.289]                         }
[16:11:00.289]                         base::stop(msg)
[16:11:00.289]                       }
[16:11:00.289]                     })
[16:11:00.289]                   }
[16:11:00.289]                   options(future.plan = NULL)
[16:11:00.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.289]                 }
[16:11:00.289]                 ...future.workdir <- getwd()
[16:11:00.289]             }
[16:11:00.289]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.289]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.289]         }
[16:11:00.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.289]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[16:11:00.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.289]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.289]             base::names(...future.oldOptions))
[16:11:00.289]     }
[16:11:00.289]     if (FALSE) {
[16:11:00.289]     }
[16:11:00.289]     else {
[16:11:00.289]         if (TRUE) {
[16:11:00.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.289]                 open = "w")
[16:11:00.289]         }
[16:11:00.289]         else {
[16:11:00.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.289]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.289]         }
[16:11:00.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.289]             base::sink(type = "output", split = FALSE)
[16:11:00.289]             base::close(...future.stdout)
[16:11:00.289]         }, add = TRUE)
[16:11:00.289]     }
[16:11:00.289]     ...future.frame <- base::sys.nframe()
[16:11:00.289]     ...future.conditions <- base::list()
[16:11:00.289]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.289]     if (FALSE) {
[16:11:00.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.289]     }
[16:11:00.289]     ...future.result <- base::tryCatch({
[16:11:00.289]         base::withCallingHandlers({
[16:11:00.289]             ...future.value <- base::withVisible(base::local({
[16:11:00.289]                 do.call(function(...) {
[16:11:00.289]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.289]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.289]                     ...future.globals.maxSize)) {
[16:11:00.289]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.289]                     on.exit(options(oopts), add = TRUE)
[16:11:00.289]                   }
[16:11:00.289]                   {
[16:11:00.289]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.289]                       FUN = function(jj) {
[16:11:00.289]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.289]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.289]                       })
[16:11:00.289]                   }
[16:11:00.289]                 }, args = future.call.arguments)
[16:11:00.289]             }))
[16:11:00.289]             future::FutureResult(value = ...future.value$value, 
[16:11:00.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.289]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.289]                     ...future.globalenv.names))
[16:11:00.289]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.289]         }, condition = base::local({
[16:11:00.289]             c <- base::c
[16:11:00.289]             inherits <- base::inherits
[16:11:00.289]             invokeRestart <- base::invokeRestart
[16:11:00.289]             length <- base::length
[16:11:00.289]             list <- base::list
[16:11:00.289]             seq.int <- base::seq.int
[16:11:00.289]             signalCondition <- base::signalCondition
[16:11:00.289]             sys.calls <- base::sys.calls
[16:11:00.289]             `[[` <- base::`[[`
[16:11:00.289]             `+` <- base::`+`
[16:11:00.289]             `<<-` <- base::`<<-`
[16:11:00.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.289]                   3L)]
[16:11:00.289]             }
[16:11:00.289]             function(cond) {
[16:11:00.289]                 is_error <- inherits(cond, "error")
[16:11:00.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.289]                   NULL)
[16:11:00.289]                 if (is_error) {
[16:11:00.289]                   sessionInformation <- function() {
[16:11:00.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.289]                       search = base::search(), system = base::Sys.info())
[16:11:00.289]                   }
[16:11:00.289]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.289]                     cond$call), session = sessionInformation(), 
[16:11:00.289]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.289]                   signalCondition(cond)
[16:11:00.289]                 }
[16:11:00.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.289]                 "immediateCondition"))) {
[16:11:00.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.289]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.289]                   if (TRUE && !signal) {
[16:11:00.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.289]                     {
[16:11:00.289]                       inherits <- base::inherits
[16:11:00.289]                       invokeRestart <- base::invokeRestart
[16:11:00.289]                       is.null <- base::is.null
[16:11:00.289]                       muffled <- FALSE
[16:11:00.289]                       if (inherits(cond, "message")) {
[16:11:00.289]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.289]                         if (muffled) 
[16:11:00.289]                           invokeRestart("muffleMessage")
[16:11:00.289]                       }
[16:11:00.289]                       else if (inherits(cond, "warning")) {
[16:11:00.289]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.289]                         if (muffled) 
[16:11:00.289]                           invokeRestart("muffleWarning")
[16:11:00.289]                       }
[16:11:00.289]                       else if (inherits(cond, "condition")) {
[16:11:00.289]                         if (!is.null(pattern)) {
[16:11:00.289]                           computeRestarts <- base::computeRestarts
[16:11:00.289]                           grepl <- base::grepl
[16:11:00.289]                           restarts <- computeRestarts(cond)
[16:11:00.289]                           for (restart in restarts) {
[16:11:00.289]                             name <- restart$name
[16:11:00.289]                             if (is.null(name)) 
[16:11:00.289]                               next
[16:11:00.289]                             if (!grepl(pattern, name)) 
[16:11:00.289]                               next
[16:11:00.289]                             invokeRestart(restart)
[16:11:00.289]                             muffled <- TRUE
[16:11:00.289]                             break
[16:11:00.289]                           }
[16:11:00.289]                         }
[16:11:00.289]                       }
[16:11:00.289]                       invisible(muffled)
[16:11:00.289]                     }
[16:11:00.289]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.289]                   }
[16:11:00.289]                 }
[16:11:00.289]                 else {
[16:11:00.289]                   if (TRUE) {
[16:11:00.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.289]                     {
[16:11:00.289]                       inherits <- base::inherits
[16:11:00.289]                       invokeRestart <- base::invokeRestart
[16:11:00.289]                       is.null <- base::is.null
[16:11:00.289]                       muffled <- FALSE
[16:11:00.289]                       if (inherits(cond, "message")) {
[16:11:00.289]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.289]                         if (muffled) 
[16:11:00.289]                           invokeRestart("muffleMessage")
[16:11:00.289]                       }
[16:11:00.289]                       else if (inherits(cond, "warning")) {
[16:11:00.289]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.289]                         if (muffled) 
[16:11:00.289]                           invokeRestart("muffleWarning")
[16:11:00.289]                       }
[16:11:00.289]                       else if (inherits(cond, "condition")) {
[16:11:00.289]                         if (!is.null(pattern)) {
[16:11:00.289]                           computeRestarts <- base::computeRestarts
[16:11:00.289]                           grepl <- base::grepl
[16:11:00.289]                           restarts <- computeRestarts(cond)
[16:11:00.289]                           for (restart in restarts) {
[16:11:00.289]                             name <- restart$name
[16:11:00.289]                             if (is.null(name)) 
[16:11:00.289]                               next
[16:11:00.289]                             if (!grepl(pattern, name)) 
[16:11:00.289]                               next
[16:11:00.289]                             invokeRestart(restart)
[16:11:00.289]                             muffled <- TRUE
[16:11:00.289]                             break
[16:11:00.289]                           }
[16:11:00.289]                         }
[16:11:00.289]                       }
[16:11:00.289]                       invisible(muffled)
[16:11:00.289]                     }
[16:11:00.289]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.289]                   }
[16:11:00.289]                 }
[16:11:00.289]             }
[16:11:00.289]         }))
[16:11:00.289]     }, error = function(ex) {
[16:11:00.289]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.289]                 ...future.rng), started = ...future.startTime, 
[16:11:00.289]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.289]             version = "1.8"), class = "FutureResult")
[16:11:00.289]     }, finally = {
[16:11:00.289]         if (!identical(...future.workdir, getwd())) 
[16:11:00.289]             setwd(...future.workdir)
[16:11:00.289]         {
[16:11:00.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.289]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.289]             }
[16:11:00.289]             base::options(...future.oldOptions)
[16:11:00.289]             if (.Platform$OS.type == "windows") {
[16:11:00.289]                 old_names <- names(...future.oldEnvVars)
[16:11:00.289]                 envs <- base::Sys.getenv()
[16:11:00.289]                 names <- names(envs)
[16:11:00.289]                 common <- intersect(names, old_names)
[16:11:00.289]                 added <- setdiff(names, old_names)
[16:11:00.289]                 removed <- setdiff(old_names, names)
[16:11:00.289]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.289]                   envs[common]]
[16:11:00.289]                 NAMES <- toupper(changed)
[16:11:00.289]                 args <- list()
[16:11:00.289]                 for (kk in seq_along(NAMES)) {
[16:11:00.289]                   name <- changed[[kk]]
[16:11:00.289]                   NAME <- NAMES[[kk]]
[16:11:00.289]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.289]                     next
[16:11:00.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.289]                 }
[16:11:00.289]                 NAMES <- toupper(added)
[16:11:00.289]                 for (kk in seq_along(NAMES)) {
[16:11:00.289]                   name <- added[[kk]]
[16:11:00.289]                   NAME <- NAMES[[kk]]
[16:11:00.289]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.289]                     next
[16:11:00.289]                   args[[name]] <- ""
[16:11:00.289]                 }
[16:11:00.289]                 NAMES <- toupper(removed)
[16:11:00.289]                 for (kk in seq_along(NAMES)) {
[16:11:00.289]                   name <- removed[[kk]]
[16:11:00.289]                   NAME <- NAMES[[kk]]
[16:11:00.289]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.289]                     next
[16:11:00.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.289]                 }
[16:11:00.289]                 if (length(args) > 0) 
[16:11:00.289]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.289]             }
[16:11:00.289]             else {
[16:11:00.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.289]             }
[16:11:00.289]             {
[16:11:00.289]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.289]                   0L) {
[16:11:00.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.289]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.289]                   base::options(opts)
[16:11:00.289]                 }
[16:11:00.289]                 {
[16:11:00.289]                   {
[16:11:00.289]                     NULL
[16:11:00.289]                     RNGkind("Mersenne-Twister")
[16:11:00.289]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.289]                       inherits = FALSE)
[16:11:00.289]                   }
[16:11:00.289]                   options(future.plan = NULL)
[16:11:00.289]                   if (is.na(NA_character_)) 
[16:11:00.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.289]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.289]                   {
[16:11:00.289]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.289]                     if (!future$lazy) 
[16:11:00.289]                       future <- run(future)
[16:11:00.289]                     invisible(future)
[16:11:00.289]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.289]                 }
[16:11:00.289]             }
[16:11:00.289]         }
[16:11:00.289]     })
[16:11:00.289]     if (TRUE) {
[16:11:00.289]         base::sink(type = "output", split = FALSE)
[16:11:00.289]         if (TRUE) {
[16:11:00.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.289]         }
[16:11:00.289]         else {
[16:11:00.289]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.289]         }
[16:11:00.289]         base::close(...future.stdout)
[16:11:00.289]         ...future.stdout <- NULL
[16:11:00.289]     }
[16:11:00.289]     ...future.result$conditions <- ...future.conditions
[16:11:00.289]     ...future.result$finished <- base::Sys.time()
[16:11:00.289]     ...future.result
[16:11:00.289] }
[16:11:00.291] assign_globals() ...
[16:11:00.291] List of 5
[16:11:00.291]  $ ...future.FUN            :function (x, y)  
[16:11:00.291]  $ future.call.arguments    :List of 1
[16:11:00.291]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:00.291]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.291]  $ ...future.elements_ii    :List of 4
[16:11:00.291]   ..$ A: num 50
[16:11:00.291]   ..$ B: num 60
[16:11:00.291]   ..$ C: num 70
[16:11:00.291]   ..$ D: num 80
[16:11:00.291]  $ ...future.seeds_ii       : NULL
[16:11:00.291]  $ ...future.globals.maxSize: NULL
[16:11:00.291]  - attr(*, "resolved")= logi FALSE
[16:11:00.291]  - attr(*, "total_size")= num 4264
[16:11:00.291]  - attr(*, "where")=List of 5
[16:11:00.291]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.291]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.291]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.291]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.291]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.291]  - attr(*, "already-done")= logi TRUE
[16:11:00.296] - reassign environment for ‘...future.FUN’
[16:11:00.297] - copied ‘...future.FUN’ to environment
[16:11:00.297] - copied ‘future.call.arguments’ to environment
[16:11:00.297] - copied ‘...future.elements_ii’ to environment
[16:11:00.297] - copied ‘...future.seeds_ii’ to environment
[16:11:00.297] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.297] assign_globals() ... done
[16:11:00.297] plan(): Setting new future strategy stack:
[16:11:00.297] List of future strategies:
[16:11:00.297] 1. sequential:
[16:11:00.297]    - args: function (..., envir = parent.frame())
[16:11:00.297]    - tweaked: FALSE
[16:11:00.297]    - call: NULL
[16:11:00.298] plan(): nbrOfWorkers() = 1
[16:11:00.298] plan(): Setting new future strategy stack:
[16:11:00.299] List of future strategies:
[16:11:00.299] 1. sequential:
[16:11:00.299]    - args: function (..., envir = parent.frame())
[16:11:00.299]    - tweaked: FALSE
[16:11:00.299]    - call: plan(strategy)
[16:11:00.299] plan(): nbrOfWorkers() = 1
[16:11:00.299] SequentialFuture started (and completed)
[16:11:00.299] - Launch lazy future ... done
[16:11:00.300] run() for ‘SequentialFuture’ ... done
[16:11:00.300] Created future:
[16:11:00.300] SequentialFuture:
[16:11:00.300] Label: ‘future_sapply-1’
[16:11:00.300] Expression:
[16:11:00.300] {
[16:11:00.300]     do.call(function(...) {
[16:11:00.300]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.300]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.300]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.300]             on.exit(options(oopts), add = TRUE)
[16:11:00.300]         }
[16:11:00.300]         {
[16:11:00.300]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.300]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.300]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.300]             })
[16:11:00.300]         }
[16:11:00.300]     }, args = future.call.arguments)
[16:11:00.300] }
[16:11:00.300] Lazy evaluation: FALSE
[16:11:00.300] Asynchronous evaluation: FALSE
[16:11:00.300] Local evaluation: TRUE
[16:11:00.300] Environment: R_GlobalEnv
[16:11:00.300] Capture standard output: TRUE
[16:11:00.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.300] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:00.300] Packages: <none>
[16:11:00.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.300] Resolved: TRUE
[16:11:00.300] Value: 1.34 KiB of class ‘list’
[16:11:00.300] Early signaling: FALSE
[16:11:00.300] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.300] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.301] Chunk #1 of 1 ... DONE
[16:11:00.301] Launching 1 futures (chunks) ... DONE
[16:11:00.302] Resolving 1 futures (chunks) ...
[16:11:00.302] resolve() on list ...
[16:11:00.302]  recursive: 0
[16:11:00.302]  length: 1
[16:11:00.302] 
[16:11:00.302] resolved() for ‘SequentialFuture’ ...
[16:11:00.302] - state: ‘finished’
[16:11:00.302] - run: TRUE
[16:11:00.302] - result: ‘FutureResult’
[16:11:00.302] resolved() for ‘SequentialFuture’ ... done
[16:11:00.302] Future #1
[16:11:00.303] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.303] - nx: 1
[16:11:00.303] - relay: TRUE
[16:11:00.303] - stdout: TRUE
[16:11:00.303] - signal: TRUE
[16:11:00.303] - resignal: FALSE
[16:11:00.303] - force: TRUE
[16:11:00.303] - relayed: [n=1] FALSE
[16:11:00.303] - queued futures: [n=1] FALSE
[16:11:00.303]  - until=1
[16:11:00.303]  - relaying element #1
[16:11:00.304] - relayed: [n=1] TRUE
[16:11:00.304] - queued futures: [n=1] TRUE
[16:11:00.304] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.304]  length: 0 (resolved future 1)
[16:11:00.304] Relaying remaining futures
[16:11:00.304] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.304] - nx: 1
[16:11:00.304] - relay: TRUE
[16:11:00.304] - stdout: TRUE
[16:11:00.304] - signal: TRUE
[16:11:00.304] - resignal: FALSE
[16:11:00.305] - force: TRUE
[16:11:00.305] - relayed: [n=1] TRUE
[16:11:00.305] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.305] - relayed: [n=1] TRUE
[16:11:00.305] - queued futures: [n=1] TRUE
[16:11:00.305] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.305] resolve() on list ... DONE
[16:11:00.305]  - Number of value chunks collected: 1
[16:11:00.305] Resolving 1 futures (chunks) ... DONE
[16:11:00.305] Reducing values from 1 chunks ...
[16:11:00.305]  - Number of values collected after concatenation: 4
[16:11:00.306]  - Number of values expected: 4
[16:11:00.306] Reducing values from 1 chunks ... DONE
[16:11:00.306] future_lapply() ... DONE
[16:11:00.306] future_lapply() ...
[16:11:00.308] Number of chunks: 1
[16:11:00.308] getGlobalsAndPackagesXApply() ...
[16:11:00.308]  - future.globals: TRUE
[16:11:00.308] getGlobalsAndPackages() ...
[16:11:00.308] Searching for globals...
[16:11:00.311] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:11:00.312] Searching for globals ... DONE
[16:11:00.312] Resolving globals: FALSE
[16:11:00.312] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:11:00.313] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.313] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.313] - packages: [1] ‘future.apply’
[16:11:00.313] getGlobalsAndPackages() ... DONE
[16:11:00.313]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.313]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.313] Finding globals ... DONE
[16:11:00.314]  - use_args: TRUE
[16:11:00.314]  - Getting '...' globals ...
[16:11:00.314] resolve() on list ...
[16:11:00.314]  recursive: 0
[16:11:00.314]  length: 1
[16:11:00.314]  elements: ‘...’
[16:11:00.314]  length: 0 (resolved future 1)
[16:11:00.314] resolve() on list ... DONE
[16:11:00.314]    - '...' content: [n=1] ‘y’
[16:11:00.315] List of 1
[16:11:00.315]  $ ...:List of 1
[16:11:00.315]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:00.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.315]  - attr(*, "where")=List of 1
[16:11:00.315]   ..$ ...:<environment: 0x561e880ebe18> 
[16:11:00.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.315]  - attr(*, "resolved")= logi TRUE
[16:11:00.315]  - attr(*, "total_size")= num NA
[16:11:00.317]  - Getting '...' globals ... DONE
[16:11:00.317] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.318] List of 8
[16:11:00.318]  $ ...future.FUN:function (x, ...)  
[16:11:00.318]  $ x_FUN        :function (x, y)  
[16:11:00.318]  $ times        : int 15
[16:11:00.318]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.318]  $ stop_if_not  :function (...)  
[16:11:00.318]  $ dim          : int [1:2] 3 5
[16:11:00.318]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:00.318]  $ ...          :List of 1
[16:11:00.318]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:00.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.318]  - attr(*, "where")=List of 8
[16:11:00.318]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.318]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.318]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.318]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.318]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.318]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.318]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.318]   ..$ ...          :<environment: 0x561e880ebe18> 
[16:11:00.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.318]  - attr(*, "resolved")= logi FALSE
[16:11:00.318]  - attr(*, "total_size")= num 98600
[16:11:00.324] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.324] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.324] Number of futures (= number of chunks): 1
[16:11:00.325] Launching 1 futures (chunks) ...
[16:11:00.325] Chunk #1 of 1 ...
[16:11:00.325]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.325] getGlobalsAndPackages() ...
[16:11:00.325] Searching for globals...
[16:11:00.325] 
[16:11:00.325] Searching for globals ... DONE
[16:11:00.325] - globals: [0] <none>
[16:11:00.325] getGlobalsAndPackages() ... DONE
[16:11:00.326]    + additional globals found: [n=0] 
[16:11:00.326]    + additional namespaces needed: [n=0] 
[16:11:00.326]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.326]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[16:11:00.326]  - seeds: <none>
[16:11:00.326] getGlobalsAndPackages() ...
[16:11:00.326] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.326] Resolving globals: FALSE
[16:11:00.326] Tweak future expression to call with '...' arguments ...
[16:11:00.326] {
[16:11:00.326]     do.call(function(...) {
[16:11:00.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.326]             on.exit(options(oopts), add = TRUE)
[16:11:00.326]         }
[16:11:00.326]         {
[16:11:00.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.326]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.326]             })
[16:11:00.326]         }
[16:11:00.326]     }, args = future.call.arguments)
[16:11:00.326] }
[16:11:00.327] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.327] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.327] - packages: [1] ‘future.apply’
[16:11:00.327] getGlobalsAndPackages() ... DONE
[16:11:00.328] run() for ‘Future’ ...
[16:11:00.328] - state: ‘created’
[16:11:00.328] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.328] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.328]   - Field: ‘label’
[16:11:00.328]   - Field: ‘local’
[16:11:00.328]   - Field: ‘owner’
[16:11:00.329]   - Field: ‘envir’
[16:11:00.329]   - Field: ‘packages’
[16:11:00.329]   - Field: ‘gc’
[16:11:00.329]   - Field: ‘conditions’
[16:11:00.329]   - Field: ‘expr’
[16:11:00.329]   - Field: ‘uuid’
[16:11:00.329]   - Field: ‘seed’
[16:11:00.329]   - Field: ‘version’
[16:11:00.329]   - Field: ‘result’
[16:11:00.329]   - Field: ‘asynchronous’
[16:11:00.329]   - Field: ‘calls’
[16:11:00.330]   - Field: ‘globals’
[16:11:00.330]   - Field: ‘stdout’
[16:11:00.330]   - Field: ‘earlySignal’
[16:11:00.330]   - Field: ‘lazy’
[16:11:00.330]   - Field: ‘state’
[16:11:00.330] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.330] - Launch lazy future ...
[16:11:00.330] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.330] Packages needed by future strategies (n = 0): <none>
[16:11:00.331] {
[16:11:00.331]     {
[16:11:00.331]         {
[16:11:00.331]             ...future.startTime <- base::Sys.time()
[16:11:00.331]             {
[16:11:00.331]                 {
[16:11:00.331]                   {
[16:11:00.331]                     {
[16:11:00.331]                       base::local({
[16:11:00.331]                         has_future <- base::requireNamespace("future", 
[16:11:00.331]                           quietly = TRUE)
[16:11:00.331]                         if (has_future) {
[16:11:00.331]                           ns <- base::getNamespace("future")
[16:11:00.331]                           version <- ns[[".package"]][["version"]]
[16:11:00.331]                           if (is.null(version)) 
[16:11:00.331]                             version <- utils::packageVersion("future")
[16:11:00.331]                         }
[16:11:00.331]                         else {
[16:11:00.331]                           version <- NULL
[16:11:00.331]                         }
[16:11:00.331]                         if (!has_future || version < "1.8.0") {
[16:11:00.331]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.331]                             "", base::R.version$version.string), 
[16:11:00.331]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.331]                               "release", "version")], collapse = " "), 
[16:11:00.331]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.331]                             info)
[16:11:00.331]                           info <- base::paste(info, collapse = "; ")
[16:11:00.331]                           if (!has_future) {
[16:11:00.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.331]                               info)
[16:11:00.331]                           }
[16:11:00.331]                           else {
[16:11:00.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.331]                               info, version)
[16:11:00.331]                           }
[16:11:00.331]                           base::stop(msg)
[16:11:00.331]                         }
[16:11:00.331]                       })
[16:11:00.331]                     }
[16:11:00.331]                     base::local({
[16:11:00.331]                       for (pkg in "future.apply") {
[16:11:00.331]                         base::loadNamespace(pkg)
[16:11:00.331]                         base::library(pkg, character.only = TRUE)
[16:11:00.331]                       }
[16:11:00.331]                     })
[16:11:00.331]                   }
[16:11:00.331]                   options(future.plan = NULL)
[16:11:00.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.331]                 }
[16:11:00.331]                 ...future.workdir <- getwd()
[16:11:00.331]             }
[16:11:00.331]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.331]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.331]         }
[16:11:00.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.331]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[16:11:00.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.331]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.331]             base::names(...future.oldOptions))
[16:11:00.331]     }
[16:11:00.331]     if (FALSE) {
[16:11:00.331]     }
[16:11:00.331]     else {
[16:11:00.331]         if (TRUE) {
[16:11:00.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.331]                 open = "w")
[16:11:00.331]         }
[16:11:00.331]         else {
[16:11:00.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.331]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.331]         }
[16:11:00.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.331]             base::sink(type = "output", split = FALSE)
[16:11:00.331]             base::close(...future.stdout)
[16:11:00.331]         }, add = TRUE)
[16:11:00.331]     }
[16:11:00.331]     ...future.frame <- base::sys.nframe()
[16:11:00.331]     ...future.conditions <- base::list()
[16:11:00.331]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.331]     if (FALSE) {
[16:11:00.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.331]     }
[16:11:00.331]     ...future.result <- base::tryCatch({
[16:11:00.331]         base::withCallingHandlers({
[16:11:00.331]             ...future.value <- base::withVisible(base::local({
[16:11:00.331]                 do.call(function(...) {
[16:11:00.331]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.331]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.331]                     ...future.globals.maxSize)) {
[16:11:00.331]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.331]                     on.exit(options(oopts), add = TRUE)
[16:11:00.331]                   }
[16:11:00.331]                   {
[16:11:00.331]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.331]                       FUN = function(jj) {
[16:11:00.331]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.331]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.331]                       })
[16:11:00.331]                   }
[16:11:00.331]                 }, args = future.call.arguments)
[16:11:00.331]             }))
[16:11:00.331]             future::FutureResult(value = ...future.value$value, 
[16:11:00.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.331]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.331]                     ...future.globalenv.names))
[16:11:00.331]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.331]         }, condition = base::local({
[16:11:00.331]             c <- base::c
[16:11:00.331]             inherits <- base::inherits
[16:11:00.331]             invokeRestart <- base::invokeRestart
[16:11:00.331]             length <- base::length
[16:11:00.331]             list <- base::list
[16:11:00.331]             seq.int <- base::seq.int
[16:11:00.331]             signalCondition <- base::signalCondition
[16:11:00.331]             sys.calls <- base::sys.calls
[16:11:00.331]             `[[` <- base::`[[`
[16:11:00.331]             `+` <- base::`+`
[16:11:00.331]             `<<-` <- base::`<<-`
[16:11:00.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.331]                   3L)]
[16:11:00.331]             }
[16:11:00.331]             function(cond) {
[16:11:00.331]                 is_error <- inherits(cond, "error")
[16:11:00.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.331]                   NULL)
[16:11:00.331]                 if (is_error) {
[16:11:00.331]                   sessionInformation <- function() {
[16:11:00.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.331]                       search = base::search(), system = base::Sys.info())
[16:11:00.331]                   }
[16:11:00.331]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.331]                     cond$call), session = sessionInformation(), 
[16:11:00.331]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.331]                   signalCondition(cond)
[16:11:00.331]                 }
[16:11:00.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.331]                 "immediateCondition"))) {
[16:11:00.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.331]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.331]                   if (TRUE && !signal) {
[16:11:00.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.331]                     {
[16:11:00.331]                       inherits <- base::inherits
[16:11:00.331]                       invokeRestart <- base::invokeRestart
[16:11:00.331]                       is.null <- base::is.null
[16:11:00.331]                       muffled <- FALSE
[16:11:00.331]                       if (inherits(cond, "message")) {
[16:11:00.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.331]                         if (muffled) 
[16:11:00.331]                           invokeRestart("muffleMessage")
[16:11:00.331]                       }
[16:11:00.331]                       else if (inherits(cond, "warning")) {
[16:11:00.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.331]                         if (muffled) 
[16:11:00.331]                           invokeRestart("muffleWarning")
[16:11:00.331]                       }
[16:11:00.331]                       else if (inherits(cond, "condition")) {
[16:11:00.331]                         if (!is.null(pattern)) {
[16:11:00.331]                           computeRestarts <- base::computeRestarts
[16:11:00.331]                           grepl <- base::grepl
[16:11:00.331]                           restarts <- computeRestarts(cond)
[16:11:00.331]                           for (restart in restarts) {
[16:11:00.331]                             name <- restart$name
[16:11:00.331]                             if (is.null(name)) 
[16:11:00.331]                               next
[16:11:00.331]                             if (!grepl(pattern, name)) 
[16:11:00.331]                               next
[16:11:00.331]                             invokeRestart(restart)
[16:11:00.331]                             muffled <- TRUE
[16:11:00.331]                             break
[16:11:00.331]                           }
[16:11:00.331]                         }
[16:11:00.331]                       }
[16:11:00.331]                       invisible(muffled)
[16:11:00.331]                     }
[16:11:00.331]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.331]                   }
[16:11:00.331]                 }
[16:11:00.331]                 else {
[16:11:00.331]                   if (TRUE) {
[16:11:00.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.331]                     {
[16:11:00.331]                       inherits <- base::inherits
[16:11:00.331]                       invokeRestart <- base::invokeRestart
[16:11:00.331]                       is.null <- base::is.null
[16:11:00.331]                       muffled <- FALSE
[16:11:00.331]                       if (inherits(cond, "message")) {
[16:11:00.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.331]                         if (muffled) 
[16:11:00.331]                           invokeRestart("muffleMessage")
[16:11:00.331]                       }
[16:11:00.331]                       else if (inherits(cond, "warning")) {
[16:11:00.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.331]                         if (muffled) 
[16:11:00.331]                           invokeRestart("muffleWarning")
[16:11:00.331]                       }
[16:11:00.331]                       else if (inherits(cond, "condition")) {
[16:11:00.331]                         if (!is.null(pattern)) {
[16:11:00.331]                           computeRestarts <- base::computeRestarts
[16:11:00.331]                           grepl <- base::grepl
[16:11:00.331]                           restarts <- computeRestarts(cond)
[16:11:00.331]                           for (restart in restarts) {
[16:11:00.331]                             name <- restart$name
[16:11:00.331]                             if (is.null(name)) 
[16:11:00.331]                               next
[16:11:00.331]                             if (!grepl(pattern, name)) 
[16:11:00.331]                               next
[16:11:00.331]                             invokeRestart(restart)
[16:11:00.331]                             muffled <- TRUE
[16:11:00.331]                             break
[16:11:00.331]                           }
[16:11:00.331]                         }
[16:11:00.331]                       }
[16:11:00.331]                       invisible(muffled)
[16:11:00.331]                     }
[16:11:00.331]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.331]                   }
[16:11:00.331]                 }
[16:11:00.331]             }
[16:11:00.331]         }))
[16:11:00.331]     }, error = function(ex) {
[16:11:00.331]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.331]                 ...future.rng), started = ...future.startTime, 
[16:11:00.331]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.331]             version = "1.8"), class = "FutureResult")
[16:11:00.331]     }, finally = {
[16:11:00.331]         if (!identical(...future.workdir, getwd())) 
[16:11:00.331]             setwd(...future.workdir)
[16:11:00.331]         {
[16:11:00.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.331]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.331]             }
[16:11:00.331]             base::options(...future.oldOptions)
[16:11:00.331]             if (.Platform$OS.type == "windows") {
[16:11:00.331]                 old_names <- names(...future.oldEnvVars)
[16:11:00.331]                 envs <- base::Sys.getenv()
[16:11:00.331]                 names <- names(envs)
[16:11:00.331]                 common <- intersect(names, old_names)
[16:11:00.331]                 added <- setdiff(names, old_names)
[16:11:00.331]                 removed <- setdiff(old_names, names)
[16:11:00.331]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.331]                   envs[common]]
[16:11:00.331]                 NAMES <- toupper(changed)
[16:11:00.331]                 args <- list()
[16:11:00.331]                 for (kk in seq_along(NAMES)) {
[16:11:00.331]                   name <- changed[[kk]]
[16:11:00.331]                   NAME <- NAMES[[kk]]
[16:11:00.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.331]                     next
[16:11:00.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.331]                 }
[16:11:00.331]                 NAMES <- toupper(added)
[16:11:00.331]                 for (kk in seq_along(NAMES)) {
[16:11:00.331]                   name <- added[[kk]]
[16:11:00.331]                   NAME <- NAMES[[kk]]
[16:11:00.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.331]                     next
[16:11:00.331]                   args[[name]] <- ""
[16:11:00.331]                 }
[16:11:00.331]                 NAMES <- toupper(removed)
[16:11:00.331]                 for (kk in seq_along(NAMES)) {
[16:11:00.331]                   name <- removed[[kk]]
[16:11:00.331]                   NAME <- NAMES[[kk]]
[16:11:00.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.331]                     next
[16:11:00.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.331]                 }
[16:11:00.331]                 if (length(args) > 0) 
[16:11:00.331]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.331]             }
[16:11:00.331]             else {
[16:11:00.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.331]             }
[16:11:00.331]             {
[16:11:00.331]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.331]                   0L) {
[16:11:00.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.331]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.331]                   base::options(opts)
[16:11:00.331]                 }
[16:11:00.331]                 {
[16:11:00.331]                   {
[16:11:00.331]                     NULL
[16:11:00.331]                     RNGkind("Mersenne-Twister")
[16:11:00.331]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.331]                       inherits = FALSE)
[16:11:00.331]                   }
[16:11:00.331]                   options(future.plan = NULL)
[16:11:00.331]                   if (is.na(NA_character_)) 
[16:11:00.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.331]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.331]                   {
[16:11:00.331]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.331]                     if (!future$lazy) 
[16:11:00.331]                       future <- run(future)
[16:11:00.331]                     invisible(future)
[16:11:00.331]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.331]                 }
[16:11:00.331]             }
[16:11:00.331]         }
[16:11:00.331]     })
[16:11:00.331]     if (TRUE) {
[16:11:00.331]         base::sink(type = "output", split = FALSE)
[16:11:00.331]         if (TRUE) {
[16:11:00.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.331]         }
[16:11:00.331]         else {
[16:11:00.331]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.331]         }
[16:11:00.331]         base::close(...future.stdout)
[16:11:00.331]         ...future.stdout <- NULL
[16:11:00.331]     }
[16:11:00.331]     ...future.result$conditions <- ...future.conditions
[16:11:00.331]     ...future.result$finished <- base::Sys.time()
[16:11:00.331]     ...future.result
[16:11:00.331] }
[16:11:00.333] assign_globals() ...
[16:11:00.333] List of 11
[16:11:00.333]  $ ...future.FUN            :function (x, ...)  
[16:11:00.333]  $ x_FUN                    :function (x, y)  
[16:11:00.333]  $ times                    : int 15
[16:11:00.333]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.333]  $ stop_if_not              :function (...)  
[16:11:00.333]  $ dim                      : int [1:2] 3 5
[16:11:00.333]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.333]  $ future.call.arguments    :List of 1
[16:11:00.333]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:00.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.333]  $ ...future.elements_ii    :List of 4
[16:11:00.333]   ..$ A: num 50
[16:11:00.333]   ..$ B: num 60
[16:11:00.333]   ..$ C: num 70
[16:11:00.333]   ..$ D: num 80
[16:11:00.333]  $ ...future.seeds_ii       : NULL
[16:11:00.333]  $ ...future.globals.maxSize: NULL
[16:11:00.333]  - attr(*, "resolved")= logi FALSE
[16:11:00.333]  - attr(*, "total_size")= num 98600
[16:11:00.333]  - attr(*, "where")=List of 11
[16:11:00.333]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.333]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.333]  - attr(*, "already-done")= logi TRUE
[16:11:00.342] - copied ‘...future.FUN’ to environment
[16:11:00.342] - reassign environment for ‘x_FUN’
[16:11:00.342] - copied ‘x_FUN’ to environment
[16:11:00.342] - copied ‘times’ to environment
[16:11:00.342] - copied ‘stopf’ to environment
[16:11:00.342] - copied ‘stop_if_not’ to environment
[16:11:00.343] - copied ‘dim’ to environment
[16:11:00.343] - copied ‘valid_types’ to environment
[16:11:00.343] - copied ‘future.call.arguments’ to environment
[16:11:00.343] - copied ‘...future.elements_ii’ to environment
[16:11:00.343] - copied ‘...future.seeds_ii’ to environment
[16:11:00.343] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.343] assign_globals() ... done
[16:11:00.343] plan(): Setting new future strategy stack:
[16:11:00.344] List of future strategies:
[16:11:00.344] 1. sequential:
[16:11:00.344]    - args: function (..., envir = parent.frame())
[16:11:00.344]    - tweaked: FALSE
[16:11:00.344]    - call: NULL
[16:11:00.344] plan(): nbrOfWorkers() = 1
[16:11:00.345] plan(): Setting new future strategy stack:
[16:11:00.345] List of future strategies:
[16:11:00.345] 1. sequential:
[16:11:00.345]    - args: function (..., envir = parent.frame())
[16:11:00.345]    - tweaked: FALSE
[16:11:00.345]    - call: plan(strategy)
[16:11:00.345] plan(): nbrOfWorkers() = 1
[16:11:00.345] SequentialFuture started (and completed)
[16:11:00.345] - Launch lazy future ... done
[16:11:00.345] run() for ‘SequentialFuture’ ... done
[16:11:00.346] Created future:
[16:11:00.346] SequentialFuture:
[16:11:00.346] Label: ‘future_vapply-1’
[16:11:00.346] Expression:
[16:11:00.346] {
[16:11:00.346]     do.call(function(...) {
[16:11:00.346]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.346]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.346]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.346]             on.exit(options(oopts), add = TRUE)
[16:11:00.346]         }
[16:11:00.346]         {
[16:11:00.346]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.346]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.346]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.346]             })
[16:11:00.346]         }
[16:11:00.346]     }, args = future.call.arguments)
[16:11:00.346] }
[16:11:00.346] Lazy evaluation: FALSE
[16:11:00.346] Asynchronous evaluation: FALSE
[16:11:00.346] Local evaluation: TRUE
[16:11:00.346] Environment: R_GlobalEnv
[16:11:00.346] Capture standard output: TRUE
[16:11:00.346] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.346] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.346] Packages: 1 packages (‘future.apply’)
[16:11:00.346] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.346] Resolved: TRUE
[16:11:00.346] Value: 1.34 KiB of class ‘list’
[16:11:00.346] Early signaling: FALSE
[16:11:00.346] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.346] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.347] Chunk #1 of 1 ... DONE
[16:11:00.347] Launching 1 futures (chunks) ... DONE
[16:11:00.347] Resolving 1 futures (chunks) ...
[16:11:00.347] resolve() on list ...
[16:11:00.347]  recursive: 0
[16:11:00.347]  length: 1
[16:11:00.347] 
[16:11:00.347] resolved() for ‘SequentialFuture’ ...
[16:11:00.347] - state: ‘finished’
[16:11:00.348] - run: TRUE
[16:11:00.348] - result: ‘FutureResult’
[16:11:00.348] resolved() for ‘SequentialFuture’ ... done
[16:11:00.348] Future #1
[16:11:00.348] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.348] - nx: 1
[16:11:00.348] - relay: TRUE
[16:11:00.348] - stdout: TRUE
[16:11:00.348] - signal: TRUE
[16:11:00.348] - resignal: FALSE
[16:11:00.348] - force: TRUE
[16:11:00.348] - relayed: [n=1] FALSE
[16:11:00.349] - queued futures: [n=1] FALSE
[16:11:00.349]  - until=1
[16:11:00.349]  - relaying element #1
[16:11:00.349] - relayed: [n=1] TRUE
[16:11:00.349] - queued futures: [n=1] TRUE
[16:11:00.349] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.349]  length: 0 (resolved future 1)
[16:11:00.349] Relaying remaining futures
[16:11:00.349] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.349] - nx: 1
[16:11:00.350] - relay: TRUE
[16:11:00.350] - stdout: TRUE
[16:11:00.350] - signal: TRUE
[16:11:00.350] - resignal: FALSE
[16:11:00.350] - force: TRUE
[16:11:00.350] - relayed: [n=1] TRUE
[16:11:00.350] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.350] - relayed: [n=1] TRUE
[16:11:00.350] - queued futures: [n=1] TRUE
[16:11:00.350] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.350] resolve() on list ... DONE
[16:11:00.351]  - Number of value chunks collected: 1
[16:11:00.351] Resolving 1 futures (chunks) ... DONE
[16:11:00.351] Reducing values from 1 chunks ...
[16:11:00.351]  - Number of values collected after concatenation: 4
[16:11:00.351]  - Number of values expected: 4
[16:11:00.351] Reducing values from 1 chunks ... DONE
[16:11:00.351] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:11:00.353] future_lapply() ...
[16:11:00.354] Number of chunks: 1
[16:11:00.354] getGlobalsAndPackagesXApply() ...
[16:11:00.355]  - future.globals: TRUE
[16:11:00.355] getGlobalsAndPackages() ...
[16:11:00.355] Searching for globals...
[16:11:00.358] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:00.358] Searching for globals ... DONE
[16:11:00.358] Resolving globals: FALSE
[16:11:00.359] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:11:00.359] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.359] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.359] - packages: [1] ‘future.apply’
[16:11:00.359] getGlobalsAndPackages() ... DONE
[16:11:00.359]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.360]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.360] Finding globals ... DONE
[16:11:00.361]  - use_args: TRUE
[16:11:00.361]  - Getting '...' globals ...
[16:11:00.361] resolve() on list ...
[16:11:00.361]  recursive: 0
[16:11:00.361]  length: 1
[16:11:00.361]  elements: ‘...’
[16:11:00.361]  length: 0 (resolved future 1)
[16:11:00.361] resolve() on list ... DONE
[16:11:00.361]    - '...' content: [n=0] 
[16:11:00.362] List of 1
[16:11:00.362]  $ ...: list()
[16:11:00.362]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.362]  - attr(*, "where")=List of 1
[16:11:00.362]   ..$ ...:<environment: 0x561e8a0e6158> 
[16:11:00.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.362]  - attr(*, "resolved")= logi TRUE
[16:11:00.362]  - attr(*, "total_size")= num NA
[16:11:00.364]  - Getting '...' globals ... DONE
[16:11:00.364] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.364] List of 8
[16:11:00.364]  $ ...future.FUN:function (x, ...)  
[16:11:00.364]  $ x_FUN        :function (x)  
[16:11:00.364]  $ times        : int 1
[16:11:00.364]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.364]  $ stop_if_not  :function (...)  
[16:11:00.364]  $ dim          : NULL
[16:11:00.364]  $ valid_types  : chr "logical"
[16:11:00.364]  $ ...          : list()
[16:11:00.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.364]  - attr(*, "where")=List of 8
[16:11:00.364]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.364]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.364]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.364]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.364]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.364]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.364]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.364]   ..$ ...          :<environment: 0x561e8a0e6158> 
[16:11:00.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.364]  - attr(*, "resolved")= logi FALSE
[16:11:00.364]  - attr(*, "total_size")= num 94200
[16:11:00.369] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.369] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.370] Number of futures (= number of chunks): 1
[16:11:00.370] Launching 1 futures (chunks) ...
[16:11:00.370] Chunk #1 of 1 ...
[16:11:00.370]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.370] getGlobalsAndPackages() ...
[16:11:00.370] Searching for globals...
[16:11:00.370] 
[16:11:00.370] Searching for globals ... DONE
[16:11:00.370] - globals: [0] <none>
[16:11:00.371] getGlobalsAndPackages() ... DONE
[16:11:00.371]    + additional globals found: [n=0] 
[16:11:00.371]    + additional namespaces needed: [n=0] 
[16:11:00.371]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.371]  - Adjusted option 'future.globals.maxSize': 524288000 -> 11 * 524288000 = 5767168000 (bytes)
[16:11:00.371]  - seeds: <none>
[16:11:00.371] getGlobalsAndPackages() ...
[16:11:00.371] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.371] Resolving globals: FALSE
[16:11:00.371] Tweak future expression to call with '...' arguments ...
[16:11:00.371] {
[16:11:00.371]     do.call(function(...) {
[16:11:00.371]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.371]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.371]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.371]             on.exit(options(oopts), add = TRUE)
[16:11:00.371]         }
[16:11:00.371]         {
[16:11:00.371]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.371]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.371]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.371]             })
[16:11:00.371]         }
[16:11:00.371]     }, args = future.call.arguments)
[16:11:00.371] }
[16:11:00.372] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.372] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.372] - packages: [1] ‘future.apply’
[16:11:00.372] getGlobalsAndPackages() ... DONE
[16:11:00.373] run() for ‘Future’ ...
[16:11:00.373] - state: ‘created’
[16:11:00.373] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.373] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.373]   - Field: ‘label’
[16:11:00.373]   - Field: ‘local’
[16:11:00.374]   - Field: ‘owner’
[16:11:00.374]   - Field: ‘envir’
[16:11:00.374]   - Field: ‘packages’
[16:11:00.374]   - Field: ‘gc’
[16:11:00.374]   - Field: ‘conditions’
[16:11:00.374]   - Field: ‘expr’
[16:11:00.374]   - Field: ‘uuid’
[16:11:00.374]   - Field: ‘seed’
[16:11:00.374]   - Field: ‘version’
[16:11:00.374]   - Field: ‘result’
[16:11:00.374]   - Field: ‘asynchronous’
[16:11:00.375]   - Field: ‘calls’
[16:11:00.375]   - Field: ‘globals’
[16:11:00.375]   - Field: ‘stdout’
[16:11:00.375]   - Field: ‘earlySignal’
[16:11:00.375]   - Field: ‘lazy’
[16:11:00.375]   - Field: ‘state’
[16:11:00.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.375] - Launch lazy future ...
[16:11:00.375] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.375] Packages needed by future strategies (n = 0): <none>
[16:11:00.376] {
[16:11:00.376]     {
[16:11:00.376]         {
[16:11:00.376]             ...future.startTime <- base::Sys.time()
[16:11:00.376]             {
[16:11:00.376]                 {
[16:11:00.376]                   {
[16:11:00.376]                     {
[16:11:00.376]                       base::local({
[16:11:00.376]                         has_future <- base::requireNamespace("future", 
[16:11:00.376]                           quietly = TRUE)
[16:11:00.376]                         if (has_future) {
[16:11:00.376]                           ns <- base::getNamespace("future")
[16:11:00.376]                           version <- ns[[".package"]][["version"]]
[16:11:00.376]                           if (is.null(version)) 
[16:11:00.376]                             version <- utils::packageVersion("future")
[16:11:00.376]                         }
[16:11:00.376]                         else {
[16:11:00.376]                           version <- NULL
[16:11:00.376]                         }
[16:11:00.376]                         if (!has_future || version < "1.8.0") {
[16:11:00.376]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.376]                             "", base::R.version$version.string), 
[16:11:00.376]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.376]                               "release", "version")], collapse = " "), 
[16:11:00.376]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.376]                             info)
[16:11:00.376]                           info <- base::paste(info, collapse = "; ")
[16:11:00.376]                           if (!has_future) {
[16:11:00.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.376]                               info)
[16:11:00.376]                           }
[16:11:00.376]                           else {
[16:11:00.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.376]                               info, version)
[16:11:00.376]                           }
[16:11:00.376]                           base::stop(msg)
[16:11:00.376]                         }
[16:11:00.376]                       })
[16:11:00.376]                     }
[16:11:00.376]                     base::local({
[16:11:00.376]                       for (pkg in "future.apply") {
[16:11:00.376]                         base::loadNamespace(pkg)
[16:11:00.376]                         base::library(pkg, character.only = TRUE)
[16:11:00.376]                       }
[16:11:00.376]                     })
[16:11:00.376]                   }
[16:11:00.376]                   options(future.plan = NULL)
[16:11:00.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.376]                 }
[16:11:00.376]                 ...future.workdir <- getwd()
[16:11:00.376]             }
[16:11:00.376]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.376]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.376]         }
[16:11:00.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.376]             future.globals.maxSize = 5767168000, future.globals.method = NULL, 
[16:11:00.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.376]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.376]             base::names(...future.oldOptions))
[16:11:00.376]     }
[16:11:00.376]     if (FALSE) {
[16:11:00.376]     }
[16:11:00.376]     else {
[16:11:00.376]         if (TRUE) {
[16:11:00.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.376]                 open = "w")
[16:11:00.376]         }
[16:11:00.376]         else {
[16:11:00.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.376]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.376]         }
[16:11:00.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.376]             base::sink(type = "output", split = FALSE)
[16:11:00.376]             base::close(...future.stdout)
[16:11:00.376]         }, add = TRUE)
[16:11:00.376]     }
[16:11:00.376]     ...future.frame <- base::sys.nframe()
[16:11:00.376]     ...future.conditions <- base::list()
[16:11:00.376]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.376]     if (FALSE) {
[16:11:00.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.376]     }
[16:11:00.376]     ...future.result <- base::tryCatch({
[16:11:00.376]         base::withCallingHandlers({
[16:11:00.376]             ...future.value <- base::withVisible(base::local({
[16:11:00.376]                 do.call(function(...) {
[16:11:00.376]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.376]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.376]                     ...future.globals.maxSize)) {
[16:11:00.376]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.376]                     on.exit(options(oopts), add = TRUE)
[16:11:00.376]                   }
[16:11:00.376]                   {
[16:11:00.376]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.376]                       FUN = function(jj) {
[16:11:00.376]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.376]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.376]                       })
[16:11:00.376]                   }
[16:11:00.376]                 }, args = future.call.arguments)
[16:11:00.376]             }))
[16:11:00.376]             future::FutureResult(value = ...future.value$value, 
[16:11:00.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.376]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.376]                     ...future.globalenv.names))
[16:11:00.376]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.376]         }, condition = base::local({
[16:11:00.376]             c <- base::c
[16:11:00.376]             inherits <- base::inherits
[16:11:00.376]             invokeRestart <- base::invokeRestart
[16:11:00.376]             length <- base::length
[16:11:00.376]             list <- base::list
[16:11:00.376]             seq.int <- base::seq.int
[16:11:00.376]             signalCondition <- base::signalCondition
[16:11:00.376]             sys.calls <- base::sys.calls
[16:11:00.376]             `[[` <- base::`[[`
[16:11:00.376]             `+` <- base::`+`
[16:11:00.376]             `<<-` <- base::`<<-`
[16:11:00.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.376]                   3L)]
[16:11:00.376]             }
[16:11:00.376]             function(cond) {
[16:11:00.376]                 is_error <- inherits(cond, "error")
[16:11:00.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.376]                   NULL)
[16:11:00.376]                 if (is_error) {
[16:11:00.376]                   sessionInformation <- function() {
[16:11:00.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.376]                       search = base::search(), system = base::Sys.info())
[16:11:00.376]                   }
[16:11:00.376]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.376]                     cond$call), session = sessionInformation(), 
[16:11:00.376]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.376]                   signalCondition(cond)
[16:11:00.376]                 }
[16:11:00.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.376]                 "immediateCondition"))) {
[16:11:00.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.376]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.376]                   if (TRUE && !signal) {
[16:11:00.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.376]                     {
[16:11:00.376]                       inherits <- base::inherits
[16:11:00.376]                       invokeRestart <- base::invokeRestart
[16:11:00.376]                       is.null <- base::is.null
[16:11:00.376]                       muffled <- FALSE
[16:11:00.376]                       if (inherits(cond, "message")) {
[16:11:00.376]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.376]                         if (muffled) 
[16:11:00.376]                           invokeRestart("muffleMessage")
[16:11:00.376]                       }
[16:11:00.376]                       else if (inherits(cond, "warning")) {
[16:11:00.376]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.376]                         if (muffled) 
[16:11:00.376]                           invokeRestart("muffleWarning")
[16:11:00.376]                       }
[16:11:00.376]                       else if (inherits(cond, "condition")) {
[16:11:00.376]                         if (!is.null(pattern)) {
[16:11:00.376]                           computeRestarts <- base::computeRestarts
[16:11:00.376]                           grepl <- base::grepl
[16:11:00.376]                           restarts <- computeRestarts(cond)
[16:11:00.376]                           for (restart in restarts) {
[16:11:00.376]                             name <- restart$name
[16:11:00.376]                             if (is.null(name)) 
[16:11:00.376]                               next
[16:11:00.376]                             if (!grepl(pattern, name)) 
[16:11:00.376]                               next
[16:11:00.376]                             invokeRestart(restart)
[16:11:00.376]                             muffled <- TRUE
[16:11:00.376]                             break
[16:11:00.376]                           }
[16:11:00.376]                         }
[16:11:00.376]                       }
[16:11:00.376]                       invisible(muffled)
[16:11:00.376]                     }
[16:11:00.376]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.376]                   }
[16:11:00.376]                 }
[16:11:00.376]                 else {
[16:11:00.376]                   if (TRUE) {
[16:11:00.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.376]                     {
[16:11:00.376]                       inherits <- base::inherits
[16:11:00.376]                       invokeRestart <- base::invokeRestart
[16:11:00.376]                       is.null <- base::is.null
[16:11:00.376]                       muffled <- FALSE
[16:11:00.376]                       if (inherits(cond, "message")) {
[16:11:00.376]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.376]                         if (muffled) 
[16:11:00.376]                           invokeRestart("muffleMessage")
[16:11:00.376]                       }
[16:11:00.376]                       else if (inherits(cond, "warning")) {
[16:11:00.376]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.376]                         if (muffled) 
[16:11:00.376]                           invokeRestart("muffleWarning")
[16:11:00.376]                       }
[16:11:00.376]                       else if (inherits(cond, "condition")) {
[16:11:00.376]                         if (!is.null(pattern)) {
[16:11:00.376]                           computeRestarts <- base::computeRestarts
[16:11:00.376]                           grepl <- base::grepl
[16:11:00.376]                           restarts <- computeRestarts(cond)
[16:11:00.376]                           for (restart in restarts) {
[16:11:00.376]                             name <- restart$name
[16:11:00.376]                             if (is.null(name)) 
[16:11:00.376]                               next
[16:11:00.376]                             if (!grepl(pattern, name)) 
[16:11:00.376]                               next
[16:11:00.376]                             invokeRestart(restart)
[16:11:00.376]                             muffled <- TRUE
[16:11:00.376]                             break
[16:11:00.376]                           }
[16:11:00.376]                         }
[16:11:00.376]                       }
[16:11:00.376]                       invisible(muffled)
[16:11:00.376]                     }
[16:11:00.376]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.376]                   }
[16:11:00.376]                 }
[16:11:00.376]             }
[16:11:00.376]         }))
[16:11:00.376]     }, error = function(ex) {
[16:11:00.376]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.376]                 ...future.rng), started = ...future.startTime, 
[16:11:00.376]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.376]             version = "1.8"), class = "FutureResult")
[16:11:00.376]     }, finally = {
[16:11:00.376]         if (!identical(...future.workdir, getwd())) 
[16:11:00.376]             setwd(...future.workdir)
[16:11:00.376]         {
[16:11:00.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.376]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.376]             }
[16:11:00.376]             base::options(...future.oldOptions)
[16:11:00.376]             if (.Platform$OS.type == "windows") {
[16:11:00.376]                 old_names <- names(...future.oldEnvVars)
[16:11:00.376]                 envs <- base::Sys.getenv()
[16:11:00.376]                 names <- names(envs)
[16:11:00.376]                 common <- intersect(names, old_names)
[16:11:00.376]                 added <- setdiff(names, old_names)
[16:11:00.376]                 removed <- setdiff(old_names, names)
[16:11:00.376]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.376]                   envs[common]]
[16:11:00.376]                 NAMES <- toupper(changed)
[16:11:00.376]                 args <- list()
[16:11:00.376]                 for (kk in seq_along(NAMES)) {
[16:11:00.376]                   name <- changed[[kk]]
[16:11:00.376]                   NAME <- NAMES[[kk]]
[16:11:00.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.376]                     next
[16:11:00.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.376]                 }
[16:11:00.376]                 NAMES <- toupper(added)
[16:11:00.376]                 for (kk in seq_along(NAMES)) {
[16:11:00.376]                   name <- added[[kk]]
[16:11:00.376]                   NAME <- NAMES[[kk]]
[16:11:00.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.376]                     next
[16:11:00.376]                   args[[name]] <- ""
[16:11:00.376]                 }
[16:11:00.376]                 NAMES <- toupper(removed)
[16:11:00.376]                 for (kk in seq_along(NAMES)) {
[16:11:00.376]                   name <- removed[[kk]]
[16:11:00.376]                   NAME <- NAMES[[kk]]
[16:11:00.376]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.376]                     next
[16:11:00.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.376]                 }
[16:11:00.376]                 if (length(args) > 0) 
[16:11:00.376]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.376]             }
[16:11:00.376]             else {
[16:11:00.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.376]             }
[16:11:00.376]             {
[16:11:00.376]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.376]                   0L) {
[16:11:00.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.376]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.376]                   base::options(opts)
[16:11:00.376]                 }
[16:11:00.376]                 {
[16:11:00.376]                   {
[16:11:00.376]                     NULL
[16:11:00.376]                     RNGkind("Mersenne-Twister")
[16:11:00.376]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.376]                       inherits = FALSE)
[16:11:00.376]                   }
[16:11:00.376]                   options(future.plan = NULL)
[16:11:00.376]                   if (is.na(NA_character_)) 
[16:11:00.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.376]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.376]                   {
[16:11:00.376]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.376]                     if (!future$lazy) 
[16:11:00.376]                       future <- run(future)
[16:11:00.376]                     invisible(future)
[16:11:00.376]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.376]                 }
[16:11:00.376]             }
[16:11:00.376]         }
[16:11:00.376]     })
[16:11:00.376]     if (TRUE) {
[16:11:00.376]         base::sink(type = "output", split = FALSE)
[16:11:00.376]         if (TRUE) {
[16:11:00.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.376]         }
[16:11:00.376]         else {
[16:11:00.376]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.376]         }
[16:11:00.376]         base::close(...future.stdout)
[16:11:00.376]         ...future.stdout <- NULL
[16:11:00.376]     }
[16:11:00.376]     ...future.result$conditions <- ...future.conditions
[16:11:00.376]     ...future.result$finished <- base::Sys.time()
[16:11:00.376]     ...future.result
[16:11:00.376] }
[16:11:00.378] assign_globals() ...
[16:11:00.378] List of 11
[16:11:00.378]  $ ...future.FUN            :function (x, ...)  
[16:11:00.378]  $ x_FUN                    :function (x)  
[16:11:00.378]  $ times                    : int 1
[16:11:00.378]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.378]  $ stop_if_not              :function (...)  
[16:11:00.378]  $ dim                      : NULL
[16:11:00.378]  $ valid_types              : chr "logical"
[16:11:00.378]  $ future.call.arguments    : list()
[16:11:00.378]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.378]  $ ...future.elements_ii    :List of 11
[16:11:00.378]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[16:11:00.378]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[16:11:00.378]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[16:11:00.378]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[16:11:00.378]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[16:11:00.378]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[16:11:00.378]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[16:11:00.378]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[16:11:00.378]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[16:11:00.378]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[16:11:00.378]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[16:11:00.378]  $ ...future.seeds_ii       : NULL
[16:11:00.378]  $ ...future.globals.maxSize: NULL
[16:11:00.378]  - attr(*, "resolved")= logi FALSE
[16:11:00.378]  - attr(*, "total_size")= num 94200
[16:11:00.378]  - attr(*, "where")=List of 11
[16:11:00.378]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.378]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.378]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.378]  - attr(*, "already-done")= logi TRUE
[16:11:00.389] - copied ‘...future.FUN’ to environment
[16:11:00.389] - copied ‘x_FUN’ to environment
[16:11:00.389] - copied ‘times’ to environment
[16:11:00.389] - copied ‘stopf’ to environment
[16:11:00.389] - copied ‘stop_if_not’ to environment
[16:11:00.389] - copied ‘dim’ to environment
[16:11:00.390] - copied ‘valid_types’ to environment
[16:11:00.390] - copied ‘future.call.arguments’ to environment
[16:11:00.390] - copied ‘...future.elements_ii’ to environment
[16:11:00.390] - copied ‘...future.seeds_ii’ to environment
[16:11:00.390] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.390] assign_globals() ... done
[16:11:00.390] plan(): Setting new future strategy stack:
[16:11:00.390] List of future strategies:
[16:11:00.390] 1. sequential:
[16:11:00.390]    - args: function (..., envir = parent.frame())
[16:11:00.390]    - tweaked: FALSE
[16:11:00.390]    - call: NULL
[16:11:00.391] plan(): nbrOfWorkers() = 1
[16:11:00.391] plan(): Setting new future strategy stack:
[16:11:00.392] List of future strategies:
[16:11:00.392] 1. sequential:
[16:11:00.392]    - args: function (..., envir = parent.frame())
[16:11:00.392]    - tweaked: FALSE
[16:11:00.392]    - call: plan(strategy)
[16:11:00.392] plan(): nbrOfWorkers() = 1
[16:11:00.392] SequentialFuture started (and completed)
[16:11:00.392] - Launch lazy future ... done
[16:11:00.392] run() for ‘SequentialFuture’ ... done
[16:11:00.392] Created future:
[16:11:00.392] SequentialFuture:
[16:11:00.392] Label: ‘future_vapply-1’
[16:11:00.392] Expression:
[16:11:00.392] {
[16:11:00.392]     do.call(function(...) {
[16:11:00.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.392]             on.exit(options(oopts), add = TRUE)
[16:11:00.392]         }
[16:11:00.392]         {
[16:11:00.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.392]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.392]             })
[16:11:00.392]         }
[16:11:00.392]     }, args = future.call.arguments)
[16:11:00.392] }
[16:11:00.392] Lazy evaluation: FALSE
[16:11:00.392] Asynchronous evaluation: FALSE
[16:11:00.392] Local evaluation: TRUE
[16:11:00.392] Environment: R_GlobalEnv
[16:11:00.392] Capture standard output: TRUE
[16:11:00.392] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.392] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.392] Packages: 1 packages (‘future.apply’)
[16:11:00.392] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.392] Resolved: TRUE
[16:11:00.392] Value: 616 bytes of class ‘list’
[16:11:00.392] Early signaling: FALSE
[16:11:00.392] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.392] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.394] Chunk #1 of 1 ... DONE
[16:11:00.394] Launching 1 futures (chunks) ... DONE
[16:11:00.394] Resolving 1 futures (chunks) ...
[16:11:00.394] resolve() on list ...
[16:11:00.394]  recursive: 0
[16:11:00.394]  length: 1
[16:11:00.394] 
[16:11:00.394] resolved() for ‘SequentialFuture’ ...
[16:11:00.394] - state: ‘finished’
[16:11:00.394] - run: TRUE
[16:11:00.395] - result: ‘FutureResult’
[16:11:00.395] resolved() for ‘SequentialFuture’ ... done
[16:11:00.395] Future #1
[16:11:00.395] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.395] - nx: 1
[16:11:00.395] - relay: TRUE
[16:11:00.395] - stdout: TRUE
[16:11:00.395] - signal: TRUE
[16:11:00.395] - resignal: FALSE
[16:11:00.395] - force: TRUE
[16:11:00.395] - relayed: [n=1] FALSE
[16:11:00.396] - queued futures: [n=1] FALSE
[16:11:00.396]  - until=1
[16:11:00.396]  - relaying element #1
[16:11:00.396] - relayed: [n=1] TRUE
[16:11:00.396] - queued futures: [n=1] TRUE
[16:11:00.396] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.396]  length: 0 (resolved future 1)
[16:11:00.396] Relaying remaining futures
[16:11:00.396] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.396] - nx: 1
[16:11:00.396] - relay: TRUE
[16:11:00.397] - stdout: TRUE
[16:11:00.397] - signal: TRUE
[16:11:00.397] - resignal: FALSE
[16:11:00.397] - force: TRUE
[16:11:00.397] - relayed: [n=1] TRUE
[16:11:00.397] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.397] - relayed: [n=1] TRUE
[16:11:00.397] - queued futures: [n=1] TRUE
[16:11:00.397] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.397] resolve() on list ... DONE
[16:11:00.397]  - Number of value chunks collected: 1
[16:11:00.398] Resolving 1 futures (chunks) ... DONE
[16:11:00.398] Reducing values from 1 chunks ...
[16:11:00.398]  - Number of values collected after concatenation: 11
[16:11:00.398]  - Number of values expected: 11
[16:11:00.398] Reducing values from 1 chunks ... DONE
[16:11:00.398] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:11:00.399] future_lapply() ...
[16:11:00.401] Number of chunks: 1
[16:11:00.401] getGlobalsAndPackagesXApply() ...
[16:11:00.402]  - future.globals: TRUE
[16:11:00.402] getGlobalsAndPackages() ...
[16:11:00.402] Searching for globals...
[16:11:00.404] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:00.405] Searching for globals ... DONE
[16:11:00.405] Resolving globals: FALSE
[16:11:00.405] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:11:00.406] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.406] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.406] - packages: [1] ‘future.apply’
[16:11:00.406] getGlobalsAndPackages() ... DONE
[16:11:00.406]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.406]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.406] Finding globals ... DONE
[16:11:00.407]  - use_args: TRUE
[16:11:00.407]  - Getting '...' globals ...
[16:11:00.407] resolve() on list ...
[16:11:00.407]  recursive: 0
[16:11:00.407]  length: 1
[16:11:00.407]  elements: ‘...’
[16:11:00.407]  length: 0 (resolved future 1)
[16:11:00.407] resolve() on list ... DONE
[16:11:00.407]    - '...' content: [n=0] 
[16:11:00.408] List of 1
[16:11:00.408]  $ ...: list()
[16:11:00.408]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.408]  - attr(*, "where")=List of 1
[16:11:00.408]   ..$ ...:<environment: 0x561e8a8279a0> 
[16:11:00.408]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.408]  - attr(*, "resolved")= logi TRUE
[16:11:00.408]  - attr(*, "total_size")= num NA
[16:11:00.410]  - Getting '...' globals ... DONE
[16:11:00.410] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.410] List of 8
[16:11:00.410]  $ ...future.FUN:function (x, ...)  
[16:11:00.410]  $ x_FUN        :function (x)  
[16:11:00.410]  $ times        : int 1
[16:11:00.410]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.410]  $ stop_if_not  :function (...)  
[16:11:00.410]  $ dim          : NULL
[16:11:00.410]  $ valid_types  : chr [1:2] "logical" "integer"
[16:11:00.410]  $ ...          : list()
[16:11:00.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.410]  - attr(*, "where")=List of 8
[16:11:00.410]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.410]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.410]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.410]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.410]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.410]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.410]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.410]   ..$ ...          :<environment: 0x561e8a8279a0> 
[16:11:00.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.410]  - attr(*, "resolved")= logi FALSE
[16:11:00.410]  - attr(*, "total_size")= num 94264
[16:11:00.415] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.415] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.415] Number of futures (= number of chunks): 1
[16:11:00.415] Launching 1 futures (chunks) ...
[16:11:00.416] Chunk #1 of 1 ...
[16:11:00.416]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.416] getGlobalsAndPackages() ...
[16:11:00.416] Searching for globals...
[16:11:00.416] 
[16:11:00.416] Searching for globals ... DONE
[16:11:00.416] - globals: [0] <none>
[16:11:00.416] getGlobalsAndPackages() ... DONE
[16:11:00.416]    + additional globals found: [n=0] 
[16:11:00.417]    + additional namespaces needed: [n=0] 
[16:11:00.417]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.417]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:11:00.417]  - seeds: <none>
[16:11:00.417] getGlobalsAndPackages() ...
[16:11:00.417] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.417] Resolving globals: FALSE
[16:11:00.417] Tweak future expression to call with '...' arguments ...
[16:11:00.417] {
[16:11:00.417]     do.call(function(...) {
[16:11:00.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.417]             on.exit(options(oopts), add = TRUE)
[16:11:00.417]         }
[16:11:00.417]         {
[16:11:00.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.417]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.417]             })
[16:11:00.417]         }
[16:11:00.417]     }, args = future.call.arguments)
[16:11:00.417] }
[16:11:00.418] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.419] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.419] - packages: [1] ‘future.apply’
[16:11:00.419] getGlobalsAndPackages() ... DONE
[16:11:00.419] run() for ‘Future’ ...
[16:11:00.420] - state: ‘created’
[16:11:00.420] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.420] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.420]   - Field: ‘label’
[16:11:00.420]   - Field: ‘local’
[16:11:00.420]   - Field: ‘owner’
[16:11:00.420]   - Field: ‘envir’
[16:11:00.421]   - Field: ‘packages’
[16:11:00.421]   - Field: ‘gc’
[16:11:00.421]   - Field: ‘conditions’
[16:11:00.421]   - Field: ‘expr’
[16:11:00.421]   - Field: ‘uuid’
[16:11:00.421]   - Field: ‘seed’
[16:11:00.421]   - Field: ‘version’
[16:11:00.421]   - Field: ‘result’
[16:11:00.421]   - Field: ‘asynchronous’
[16:11:00.421]   - Field: ‘calls’
[16:11:00.421]   - Field: ‘globals’
[16:11:00.421]   - Field: ‘stdout’
[16:11:00.422]   - Field: ‘earlySignal’
[16:11:00.422]   - Field: ‘lazy’
[16:11:00.422]   - Field: ‘state’
[16:11:00.422] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.422] - Launch lazy future ...
[16:11:00.422] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.422] Packages needed by future strategies (n = 0): <none>
[16:11:00.423] {
[16:11:00.423]     {
[16:11:00.423]         {
[16:11:00.423]             ...future.startTime <- base::Sys.time()
[16:11:00.423]             {
[16:11:00.423]                 {
[16:11:00.423]                   {
[16:11:00.423]                     {
[16:11:00.423]                       base::local({
[16:11:00.423]                         has_future <- base::requireNamespace("future", 
[16:11:00.423]                           quietly = TRUE)
[16:11:00.423]                         if (has_future) {
[16:11:00.423]                           ns <- base::getNamespace("future")
[16:11:00.423]                           version <- ns[[".package"]][["version"]]
[16:11:00.423]                           if (is.null(version)) 
[16:11:00.423]                             version <- utils::packageVersion("future")
[16:11:00.423]                         }
[16:11:00.423]                         else {
[16:11:00.423]                           version <- NULL
[16:11:00.423]                         }
[16:11:00.423]                         if (!has_future || version < "1.8.0") {
[16:11:00.423]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.423]                             "", base::R.version$version.string), 
[16:11:00.423]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.423]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.423]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.423]                               "release", "version")], collapse = " "), 
[16:11:00.423]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.423]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.423]                             info)
[16:11:00.423]                           info <- base::paste(info, collapse = "; ")
[16:11:00.423]                           if (!has_future) {
[16:11:00.423]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.423]                               info)
[16:11:00.423]                           }
[16:11:00.423]                           else {
[16:11:00.423]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.423]                               info, version)
[16:11:00.423]                           }
[16:11:00.423]                           base::stop(msg)
[16:11:00.423]                         }
[16:11:00.423]                       })
[16:11:00.423]                     }
[16:11:00.423]                     base::local({
[16:11:00.423]                       for (pkg in "future.apply") {
[16:11:00.423]                         base::loadNamespace(pkg)
[16:11:00.423]                         base::library(pkg, character.only = TRUE)
[16:11:00.423]                       }
[16:11:00.423]                     })
[16:11:00.423]                   }
[16:11:00.423]                   options(future.plan = NULL)
[16:11:00.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.423]                 }
[16:11:00.423]                 ...future.workdir <- getwd()
[16:11:00.423]             }
[16:11:00.423]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.423]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.423]         }
[16:11:00.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.423]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:11:00.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.423]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.423]             base::names(...future.oldOptions))
[16:11:00.423]     }
[16:11:00.423]     if (FALSE) {
[16:11:00.423]     }
[16:11:00.423]     else {
[16:11:00.423]         if (TRUE) {
[16:11:00.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.423]                 open = "w")
[16:11:00.423]         }
[16:11:00.423]         else {
[16:11:00.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.423]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.423]         }
[16:11:00.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.423]             base::sink(type = "output", split = FALSE)
[16:11:00.423]             base::close(...future.stdout)
[16:11:00.423]         }, add = TRUE)
[16:11:00.423]     }
[16:11:00.423]     ...future.frame <- base::sys.nframe()
[16:11:00.423]     ...future.conditions <- base::list()
[16:11:00.423]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.423]     if (FALSE) {
[16:11:00.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.423]     }
[16:11:00.423]     ...future.result <- base::tryCatch({
[16:11:00.423]         base::withCallingHandlers({
[16:11:00.423]             ...future.value <- base::withVisible(base::local({
[16:11:00.423]                 do.call(function(...) {
[16:11:00.423]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.423]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.423]                     ...future.globals.maxSize)) {
[16:11:00.423]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.423]                     on.exit(options(oopts), add = TRUE)
[16:11:00.423]                   }
[16:11:00.423]                   {
[16:11:00.423]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.423]                       FUN = function(jj) {
[16:11:00.423]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.423]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.423]                       })
[16:11:00.423]                   }
[16:11:00.423]                 }, args = future.call.arguments)
[16:11:00.423]             }))
[16:11:00.423]             future::FutureResult(value = ...future.value$value, 
[16:11:00.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.423]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.423]                     ...future.globalenv.names))
[16:11:00.423]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.423]         }, condition = base::local({
[16:11:00.423]             c <- base::c
[16:11:00.423]             inherits <- base::inherits
[16:11:00.423]             invokeRestart <- base::invokeRestart
[16:11:00.423]             length <- base::length
[16:11:00.423]             list <- base::list
[16:11:00.423]             seq.int <- base::seq.int
[16:11:00.423]             signalCondition <- base::signalCondition
[16:11:00.423]             sys.calls <- base::sys.calls
[16:11:00.423]             `[[` <- base::`[[`
[16:11:00.423]             `+` <- base::`+`
[16:11:00.423]             `<<-` <- base::`<<-`
[16:11:00.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.423]                   3L)]
[16:11:00.423]             }
[16:11:00.423]             function(cond) {
[16:11:00.423]                 is_error <- inherits(cond, "error")
[16:11:00.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.423]                   NULL)
[16:11:00.423]                 if (is_error) {
[16:11:00.423]                   sessionInformation <- function() {
[16:11:00.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.423]                       search = base::search(), system = base::Sys.info())
[16:11:00.423]                   }
[16:11:00.423]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.423]                     cond$call), session = sessionInformation(), 
[16:11:00.423]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.423]                   signalCondition(cond)
[16:11:00.423]                 }
[16:11:00.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.423]                 "immediateCondition"))) {
[16:11:00.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.423]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.423]                   if (TRUE && !signal) {
[16:11:00.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.423]                     {
[16:11:00.423]                       inherits <- base::inherits
[16:11:00.423]                       invokeRestart <- base::invokeRestart
[16:11:00.423]                       is.null <- base::is.null
[16:11:00.423]                       muffled <- FALSE
[16:11:00.423]                       if (inherits(cond, "message")) {
[16:11:00.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.423]                         if (muffled) 
[16:11:00.423]                           invokeRestart("muffleMessage")
[16:11:00.423]                       }
[16:11:00.423]                       else if (inherits(cond, "warning")) {
[16:11:00.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.423]                         if (muffled) 
[16:11:00.423]                           invokeRestart("muffleWarning")
[16:11:00.423]                       }
[16:11:00.423]                       else if (inherits(cond, "condition")) {
[16:11:00.423]                         if (!is.null(pattern)) {
[16:11:00.423]                           computeRestarts <- base::computeRestarts
[16:11:00.423]                           grepl <- base::grepl
[16:11:00.423]                           restarts <- computeRestarts(cond)
[16:11:00.423]                           for (restart in restarts) {
[16:11:00.423]                             name <- restart$name
[16:11:00.423]                             if (is.null(name)) 
[16:11:00.423]                               next
[16:11:00.423]                             if (!grepl(pattern, name)) 
[16:11:00.423]                               next
[16:11:00.423]                             invokeRestart(restart)
[16:11:00.423]                             muffled <- TRUE
[16:11:00.423]                             break
[16:11:00.423]                           }
[16:11:00.423]                         }
[16:11:00.423]                       }
[16:11:00.423]                       invisible(muffled)
[16:11:00.423]                     }
[16:11:00.423]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.423]                   }
[16:11:00.423]                 }
[16:11:00.423]                 else {
[16:11:00.423]                   if (TRUE) {
[16:11:00.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.423]                     {
[16:11:00.423]                       inherits <- base::inherits
[16:11:00.423]                       invokeRestart <- base::invokeRestart
[16:11:00.423]                       is.null <- base::is.null
[16:11:00.423]                       muffled <- FALSE
[16:11:00.423]                       if (inherits(cond, "message")) {
[16:11:00.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.423]                         if (muffled) 
[16:11:00.423]                           invokeRestart("muffleMessage")
[16:11:00.423]                       }
[16:11:00.423]                       else if (inherits(cond, "warning")) {
[16:11:00.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.423]                         if (muffled) 
[16:11:00.423]                           invokeRestart("muffleWarning")
[16:11:00.423]                       }
[16:11:00.423]                       else if (inherits(cond, "condition")) {
[16:11:00.423]                         if (!is.null(pattern)) {
[16:11:00.423]                           computeRestarts <- base::computeRestarts
[16:11:00.423]                           grepl <- base::grepl
[16:11:00.423]                           restarts <- computeRestarts(cond)
[16:11:00.423]                           for (restart in restarts) {
[16:11:00.423]                             name <- restart$name
[16:11:00.423]                             if (is.null(name)) 
[16:11:00.423]                               next
[16:11:00.423]                             if (!grepl(pattern, name)) 
[16:11:00.423]                               next
[16:11:00.423]                             invokeRestart(restart)
[16:11:00.423]                             muffled <- TRUE
[16:11:00.423]                             break
[16:11:00.423]                           }
[16:11:00.423]                         }
[16:11:00.423]                       }
[16:11:00.423]                       invisible(muffled)
[16:11:00.423]                     }
[16:11:00.423]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.423]                   }
[16:11:00.423]                 }
[16:11:00.423]             }
[16:11:00.423]         }))
[16:11:00.423]     }, error = function(ex) {
[16:11:00.423]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.423]                 ...future.rng), started = ...future.startTime, 
[16:11:00.423]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.423]             version = "1.8"), class = "FutureResult")
[16:11:00.423]     }, finally = {
[16:11:00.423]         if (!identical(...future.workdir, getwd())) 
[16:11:00.423]             setwd(...future.workdir)
[16:11:00.423]         {
[16:11:00.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.423]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.423]             }
[16:11:00.423]             base::options(...future.oldOptions)
[16:11:00.423]             if (.Platform$OS.type == "windows") {
[16:11:00.423]                 old_names <- names(...future.oldEnvVars)
[16:11:00.423]                 envs <- base::Sys.getenv()
[16:11:00.423]                 names <- names(envs)
[16:11:00.423]                 common <- intersect(names, old_names)
[16:11:00.423]                 added <- setdiff(names, old_names)
[16:11:00.423]                 removed <- setdiff(old_names, names)
[16:11:00.423]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.423]                   envs[common]]
[16:11:00.423]                 NAMES <- toupper(changed)
[16:11:00.423]                 args <- list()
[16:11:00.423]                 for (kk in seq_along(NAMES)) {
[16:11:00.423]                   name <- changed[[kk]]
[16:11:00.423]                   NAME <- NAMES[[kk]]
[16:11:00.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.423]                     next
[16:11:00.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.423]                 }
[16:11:00.423]                 NAMES <- toupper(added)
[16:11:00.423]                 for (kk in seq_along(NAMES)) {
[16:11:00.423]                   name <- added[[kk]]
[16:11:00.423]                   NAME <- NAMES[[kk]]
[16:11:00.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.423]                     next
[16:11:00.423]                   args[[name]] <- ""
[16:11:00.423]                 }
[16:11:00.423]                 NAMES <- toupper(removed)
[16:11:00.423]                 for (kk in seq_along(NAMES)) {
[16:11:00.423]                   name <- removed[[kk]]
[16:11:00.423]                   NAME <- NAMES[[kk]]
[16:11:00.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.423]                     next
[16:11:00.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.423]                 }
[16:11:00.423]                 if (length(args) > 0) 
[16:11:00.423]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.423]             }
[16:11:00.423]             else {
[16:11:00.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.423]             }
[16:11:00.423]             {
[16:11:00.423]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.423]                   0L) {
[16:11:00.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.423]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.423]                   base::options(opts)
[16:11:00.423]                 }
[16:11:00.423]                 {
[16:11:00.423]                   {
[16:11:00.423]                     NULL
[16:11:00.423]                     RNGkind("Mersenne-Twister")
[16:11:00.423]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.423]                       inherits = FALSE)
[16:11:00.423]                   }
[16:11:00.423]                   options(future.plan = NULL)
[16:11:00.423]                   if (is.na(NA_character_)) 
[16:11:00.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.423]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.423]                   {
[16:11:00.423]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.423]                     if (!future$lazy) 
[16:11:00.423]                       future <- run(future)
[16:11:00.423]                     invisible(future)
[16:11:00.423]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.423]                 }
[16:11:00.423]             }
[16:11:00.423]         }
[16:11:00.423]     })
[16:11:00.423]     if (TRUE) {
[16:11:00.423]         base::sink(type = "output", split = FALSE)
[16:11:00.423]         if (TRUE) {
[16:11:00.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.423]         }
[16:11:00.423]         else {
[16:11:00.423]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.423]         }
[16:11:00.423]         base::close(...future.stdout)
[16:11:00.423]         ...future.stdout <- NULL
[16:11:00.423]     }
[16:11:00.423]     ...future.result$conditions <- ...future.conditions
[16:11:00.423]     ...future.result$finished <- base::Sys.time()
[16:11:00.423]     ...future.result
[16:11:00.423] }
[16:11:00.424] assign_globals() ...
[16:11:00.424] List of 11
[16:11:00.424]  $ ...future.FUN            :function (x, ...)  
[16:11:00.424]  $ x_FUN                    :function (x)  
[16:11:00.424]  $ times                    : int 1
[16:11:00.424]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.424]  $ stop_if_not              :function (...)  
[16:11:00.424]  $ dim                      : NULL
[16:11:00.424]  $ valid_types              : chr [1:2] "logical" "integer"
[16:11:00.424]  $ future.call.arguments    : list()
[16:11:00.424]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.424]  $ ...future.elements_ii    :List of 3
[16:11:00.424]   ..$ a: num 1
[16:11:00.424]   ..$ b: num 2
[16:11:00.424]   ..$ c: num 3
[16:11:00.424]  $ ...future.seeds_ii       : NULL
[16:11:00.424]  $ ...future.globals.maxSize: NULL
[16:11:00.424]  - attr(*, "resolved")= logi FALSE
[16:11:00.424]  - attr(*, "total_size")= num 94264
[16:11:00.424]  - attr(*, "where")=List of 11
[16:11:00.424]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.424]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.424]  - attr(*, "already-done")= logi TRUE
[16:11:00.432] - copied ‘...future.FUN’ to environment
[16:11:00.432] - copied ‘x_FUN’ to environment
[16:11:00.432] - copied ‘times’ to environment
[16:11:00.432] - copied ‘stopf’ to environment
[16:11:00.432] - copied ‘stop_if_not’ to environment
[16:11:00.432] - copied ‘dim’ to environment
[16:11:00.432] - copied ‘valid_types’ to environment
[16:11:00.433] - copied ‘future.call.arguments’ to environment
[16:11:00.433] - copied ‘...future.elements_ii’ to environment
[16:11:00.433] - copied ‘...future.seeds_ii’ to environment
[16:11:00.433] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.433] assign_globals() ... done
[16:11:00.433] plan(): Setting new future strategy stack:
[16:11:00.433] List of future strategies:
[16:11:00.433] 1. sequential:
[16:11:00.433]    - args: function (..., envir = parent.frame())
[16:11:00.433]    - tweaked: FALSE
[16:11:00.433]    - call: NULL
[16:11:00.434] plan(): nbrOfWorkers() = 1
[16:11:00.434] plan(): Setting new future strategy stack:
[16:11:00.434] List of future strategies:
[16:11:00.434] 1. sequential:
[16:11:00.434]    - args: function (..., envir = parent.frame())
[16:11:00.434]    - tweaked: FALSE
[16:11:00.434]    - call: plan(strategy)
[16:11:00.435] plan(): nbrOfWorkers() = 1
[16:11:00.435] SequentialFuture started (and completed)
[16:11:00.435] - Launch lazy future ... done
[16:11:00.435] run() for ‘SequentialFuture’ ... done
[16:11:00.435] Created future:
[16:11:00.435] SequentialFuture:
[16:11:00.435] Label: ‘future_vapply-1’
[16:11:00.435] Expression:
[16:11:00.435] {
[16:11:00.435]     do.call(function(...) {
[16:11:00.435]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.435]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.435]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.435]             on.exit(options(oopts), add = TRUE)
[16:11:00.435]         }
[16:11:00.435]         {
[16:11:00.435]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.435]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.435]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.435]             })
[16:11:00.435]         }
[16:11:00.435]     }, args = future.call.arguments)
[16:11:00.435] }
[16:11:00.435] Lazy evaluation: FALSE
[16:11:00.435] Asynchronous evaluation: FALSE
[16:11:00.435] Local evaluation: TRUE
[16:11:00.435] Environment: R_GlobalEnv
[16:11:00.435] Capture standard output: TRUE
[16:11:00.435] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.435] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.435] Packages: 1 packages (‘future.apply’)
[16:11:00.435] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.435] Resolved: TRUE
[16:11:00.435] Value: 168 bytes of class ‘list’
[16:11:00.435] Early signaling: FALSE
[16:11:00.435] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.435] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.436] Chunk #1 of 1 ... DONE
[16:11:00.436] Launching 1 futures (chunks) ... DONE
[16:11:00.437] Resolving 1 futures (chunks) ...
[16:11:00.437] resolve() on list ...
[16:11:00.437]  recursive: 0
[16:11:00.437]  length: 1
[16:11:00.437] 
[16:11:00.437] resolved() for ‘SequentialFuture’ ...
[16:11:00.437] - state: ‘finished’
[16:11:00.437] - run: TRUE
[16:11:00.437] - result: ‘FutureResult’
[16:11:00.437] resolved() for ‘SequentialFuture’ ... done
[16:11:00.437] Future #1
[16:11:00.438] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.438] - nx: 1
[16:11:00.438] - relay: TRUE
[16:11:00.438] - stdout: TRUE
[16:11:00.438] - signal: TRUE
[16:11:00.438] - resignal: FALSE
[16:11:00.438] - force: TRUE
[16:11:00.439] - relayed: [n=1] FALSE
[16:11:00.439] - queued futures: [n=1] FALSE
[16:11:00.439]  - until=1
[16:11:00.439]  - relaying element #1
[16:11:00.439] - relayed: [n=1] TRUE
[16:11:00.440] - queued futures: [n=1] TRUE
[16:11:00.440] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.440]  length: 0 (resolved future 1)
[16:11:00.440] Relaying remaining futures
[16:11:00.440] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.440] - nx: 1
[16:11:00.440] - relay: TRUE
[16:11:00.440] - stdout: TRUE
[16:11:00.440] - signal: TRUE
[16:11:00.440] - resignal: FALSE
[16:11:00.440] - force: TRUE
[16:11:00.440] - relayed: [n=1] TRUE
[16:11:00.441] - queued futures: [n=1] TRUE
 - flush all
[16:11:00.441] - relayed: [n=1] TRUE
[16:11:00.441] - queued futures: [n=1] TRUE
[16:11:00.441] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.441] resolve() on list ... DONE
[16:11:00.441]  - Number of value chunks collected: 1
[16:11:00.441] Resolving 1 futures (chunks) ... DONE
[16:11:00.441] Reducing values from 1 chunks ...
[16:11:00.441]  - Number of values collected after concatenation: 3
[16:11:00.441]  - Number of values expected: 3
[16:11:00.442] Reducing values from 1 chunks ... DONE
[16:11:00.442] future_lapply() ... DONE
- exceptions ...
[16:11:00.442] future_lapply() ...
[16:11:00.443] Number of chunks: 1
[16:11:00.444] getGlobalsAndPackagesXApply() ...
[16:11:00.444]  - future.globals: TRUE
[16:11:00.444] getGlobalsAndPackages() ...
[16:11:00.444] Searching for globals...
[16:11:00.447] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:00.447] Searching for globals ... DONE
[16:11:00.447] Resolving globals: FALSE
[16:11:00.448] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:11:00.448] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.448] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.448] - packages: [1] ‘future.apply’
[16:11:00.449] getGlobalsAndPackages() ... DONE
[16:11:00.449]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.449]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.449] Finding globals ... DONE
[16:11:00.449]  - use_args: TRUE
[16:11:00.449]  - Getting '...' globals ...
[16:11:00.449] resolve() on list ...
[16:11:00.449]  recursive: 0
[16:11:00.449]  length: 1
[16:11:00.450]  elements: ‘...’
[16:11:00.450]  length: 0 (resolved future 1)
[16:11:00.450] resolve() on list ... DONE
[16:11:00.450]    - '...' content: [n=0] 
[16:11:00.450] List of 1
[16:11:00.450]  $ ...: list()
[16:11:00.450]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.450]  - attr(*, "where")=List of 1
[16:11:00.450]   ..$ ...:<environment: 0x561e88d58428> 
[16:11:00.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.450]  - attr(*, "resolved")= logi TRUE
[16:11:00.450]  - attr(*, "total_size")= num NA
[16:11:00.452]  - Getting '...' globals ... DONE
[16:11:00.452] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.453] List of 8
[16:11:00.453]  $ ...future.FUN:function (x, ...)  
[16:11:00.453]  $ x_FUN        :function (x)  
[16:11:00.453]  $ times        : int 2
[16:11:00.453]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.453]  $ stop_if_not  :function (...)  
[16:11:00.453]  $ dim          : NULL
[16:11:00.453]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:00.453]  $ ...          : list()
[16:11:00.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.453]  - attr(*, "where")=List of 8
[16:11:00.453]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.453]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.453]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.453]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.453]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.453]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.453]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.453]   ..$ ...          :<environment: 0x561e88d58428> 
[16:11:00.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.453]  - attr(*, "resolved")= logi FALSE
[16:11:00.453]  - attr(*, "total_size")= num 95128
[16:11:00.458] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.459] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.459] Number of futures (= number of chunks): 1
[16:11:00.459] Launching 1 futures (chunks) ...
[16:11:00.459] Chunk #1 of 1 ...
[16:11:00.459]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.459] getGlobalsAndPackages() ...
[16:11:00.459] Searching for globals...
[16:11:00.459] 
[16:11:00.460] Searching for globals ... DONE
[16:11:00.460] - globals: [0] <none>
[16:11:00.460] getGlobalsAndPackages() ... DONE
[16:11:00.460]    + additional globals found: [n=0] 
[16:11:00.460]    + additional namespaces needed: [n=0] 
[16:11:00.460]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.460]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:11:00.460]  - seeds: <none>
[16:11:00.460] getGlobalsAndPackages() ...
[16:11:00.460] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.461] Resolving globals: FALSE
[16:11:00.461] Tweak future expression to call with '...' arguments ...
[16:11:00.461] {
[16:11:00.461]     do.call(function(...) {
[16:11:00.461]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.461]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.461]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.461]             on.exit(options(oopts), add = TRUE)
[16:11:00.461]         }
[16:11:00.461]         {
[16:11:00.461]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.461]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.461]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.461]             })
[16:11:00.461]         }
[16:11:00.461]     }, args = future.call.arguments)
[16:11:00.461] }
[16:11:00.461] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.461] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.462] - packages: [1] ‘future.apply’
[16:11:00.462] getGlobalsAndPackages() ... DONE
[16:11:00.462] run() for ‘Future’ ...
[16:11:00.462] - state: ‘created’
[16:11:00.462] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:11:00.462] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:11:00.463]   - Field: ‘label’
[16:11:00.463]   - Field: ‘local’
[16:11:00.463]   - Field: ‘owner’
[16:11:00.463]   - Field: ‘envir’
[16:11:00.463]   - Field: ‘packages’
[16:11:00.463]   - Field: ‘gc’
[16:11:00.463]   - Field: ‘conditions’
[16:11:00.463]   - Field: ‘expr’
[16:11:00.463]   - Field: ‘uuid’
[16:11:00.463]   - Field: ‘seed’
[16:11:00.463]   - Field: ‘version’
[16:11:00.464]   - Field: ‘result’
[16:11:00.464]   - Field: ‘asynchronous’
[16:11:00.464]   - Field: ‘calls’
[16:11:00.464]   - Field: ‘globals’
[16:11:00.464]   - Field: ‘stdout’
[16:11:00.464]   - Field: ‘earlySignal’
[16:11:00.464]   - Field: ‘lazy’
[16:11:00.464]   - Field: ‘state’
[16:11:00.464] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:11:00.464] - Launch lazy future ...
[16:11:00.465] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.465] Packages needed by future strategies (n = 0): <none>
[16:11:00.465] {
[16:11:00.465]     {
[16:11:00.465]         {
[16:11:00.465]             ...future.startTime <- base::Sys.time()
[16:11:00.465]             {
[16:11:00.465]                 {
[16:11:00.465]                   {
[16:11:00.465]                     {
[16:11:00.465]                       base::local({
[16:11:00.465]                         has_future <- base::requireNamespace("future", 
[16:11:00.465]                           quietly = TRUE)
[16:11:00.465]                         if (has_future) {
[16:11:00.465]                           ns <- base::getNamespace("future")
[16:11:00.465]                           version <- ns[[".package"]][["version"]]
[16:11:00.465]                           if (is.null(version)) 
[16:11:00.465]                             version <- utils::packageVersion("future")
[16:11:00.465]                         }
[16:11:00.465]                         else {
[16:11:00.465]                           version <- NULL
[16:11:00.465]                         }
[16:11:00.465]                         if (!has_future || version < "1.8.0") {
[16:11:00.465]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.465]                             "", base::R.version$version.string), 
[16:11:00.465]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:00.465]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:00.465]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.465]                               "release", "version")], collapse = " "), 
[16:11:00.465]                             hostname = base::Sys.info()[["nodename"]])
[16:11:00.465]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.465]                             info)
[16:11:00.465]                           info <- base::paste(info, collapse = "; ")
[16:11:00.465]                           if (!has_future) {
[16:11:00.465]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.465]                               info)
[16:11:00.465]                           }
[16:11:00.465]                           else {
[16:11:00.465]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.465]                               info, version)
[16:11:00.465]                           }
[16:11:00.465]                           base::stop(msg)
[16:11:00.465]                         }
[16:11:00.465]                       })
[16:11:00.465]                     }
[16:11:00.465]                     base::local({
[16:11:00.465]                       for (pkg in "future.apply") {
[16:11:00.465]                         base::loadNamespace(pkg)
[16:11:00.465]                         base::library(pkg, character.only = TRUE)
[16:11:00.465]                       }
[16:11:00.465]                     })
[16:11:00.465]                   }
[16:11:00.465]                   options(future.plan = NULL)
[16:11:00.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.465]                 }
[16:11:00.465]                 ...future.workdir <- getwd()
[16:11:00.465]             }
[16:11:00.465]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.465]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.465]         }
[16:11:00.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.465]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:11:00.465]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.465]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.465]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.465]             base::names(...future.oldOptions))
[16:11:00.465]     }
[16:11:00.465]     if (FALSE) {
[16:11:00.465]     }
[16:11:00.465]     else {
[16:11:00.465]         if (TRUE) {
[16:11:00.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.465]                 open = "w")
[16:11:00.465]         }
[16:11:00.465]         else {
[16:11:00.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.465]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.465]         }
[16:11:00.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.465]             base::sink(type = "output", split = FALSE)
[16:11:00.465]             base::close(...future.stdout)
[16:11:00.465]         }, add = TRUE)
[16:11:00.465]     }
[16:11:00.465]     ...future.frame <- base::sys.nframe()
[16:11:00.465]     ...future.conditions <- base::list()
[16:11:00.465]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.465]     if (FALSE) {
[16:11:00.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.465]     }
[16:11:00.465]     ...future.result <- base::tryCatch({
[16:11:00.465]         base::withCallingHandlers({
[16:11:00.465]             ...future.value <- base::withVisible(base::local({
[16:11:00.465]                 do.call(function(...) {
[16:11:00.465]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.465]                   if (!identical(...future.globals.maxSize.org, 
[16:11:00.465]                     ...future.globals.maxSize)) {
[16:11:00.465]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.465]                     on.exit(options(oopts), add = TRUE)
[16:11:00.465]                   }
[16:11:00.465]                   {
[16:11:00.465]                     lapply(seq_along(...future.elements_ii), 
[16:11:00.465]                       FUN = function(jj) {
[16:11:00.465]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.465]                         ...future.FUN(...future.X_jj, ...)
[16:11:00.465]                       })
[16:11:00.465]                   }
[16:11:00.465]                 }, args = future.call.arguments)
[16:11:00.465]             }))
[16:11:00.465]             future::FutureResult(value = ...future.value$value, 
[16:11:00.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.465]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.465]                     ...future.globalenv.names))
[16:11:00.465]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.465]         }, condition = base::local({
[16:11:00.465]             c <- base::c
[16:11:00.465]             inherits <- base::inherits
[16:11:00.465]             invokeRestart <- base::invokeRestart
[16:11:00.465]             length <- base::length
[16:11:00.465]             list <- base::list
[16:11:00.465]             seq.int <- base::seq.int
[16:11:00.465]             signalCondition <- base::signalCondition
[16:11:00.465]             sys.calls <- base::sys.calls
[16:11:00.465]             `[[` <- base::`[[`
[16:11:00.465]             `+` <- base::`+`
[16:11:00.465]             `<<-` <- base::`<<-`
[16:11:00.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.465]                   3L)]
[16:11:00.465]             }
[16:11:00.465]             function(cond) {
[16:11:00.465]                 is_error <- inherits(cond, "error")
[16:11:00.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.465]                   NULL)
[16:11:00.465]                 if (is_error) {
[16:11:00.465]                   sessionInformation <- function() {
[16:11:00.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.465]                       search = base::search(), system = base::Sys.info())
[16:11:00.465]                   }
[16:11:00.465]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.465]                     cond$call), session = sessionInformation(), 
[16:11:00.465]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.465]                   signalCondition(cond)
[16:11:00.465]                 }
[16:11:00.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.465]                 "immediateCondition"))) {
[16:11:00.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.465]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.465]                   if (TRUE && !signal) {
[16:11:00.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.465]                     {
[16:11:00.465]                       inherits <- base::inherits
[16:11:00.465]                       invokeRestart <- base::invokeRestart
[16:11:00.465]                       is.null <- base::is.null
[16:11:00.465]                       muffled <- FALSE
[16:11:00.465]                       if (inherits(cond, "message")) {
[16:11:00.465]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.465]                         if (muffled) 
[16:11:00.465]                           invokeRestart("muffleMessage")
[16:11:00.465]                       }
[16:11:00.465]                       else if (inherits(cond, "warning")) {
[16:11:00.465]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.465]                         if (muffled) 
[16:11:00.465]                           invokeRestart("muffleWarning")
[16:11:00.465]                       }
[16:11:00.465]                       else if (inherits(cond, "condition")) {
[16:11:00.465]                         if (!is.null(pattern)) {
[16:11:00.465]                           computeRestarts <- base::computeRestarts
[16:11:00.465]                           grepl <- base::grepl
[16:11:00.465]                           restarts <- computeRestarts(cond)
[16:11:00.465]                           for (restart in restarts) {
[16:11:00.465]                             name <- restart$name
[16:11:00.465]                             if (is.null(name)) 
[16:11:00.465]                               next
[16:11:00.465]                             if (!grepl(pattern, name)) 
[16:11:00.465]                               next
[16:11:00.465]                             invokeRestart(restart)
[16:11:00.465]                             muffled <- TRUE
[16:11:00.465]                             break
[16:11:00.465]                           }
[16:11:00.465]                         }
[16:11:00.465]                       }
[16:11:00.465]                       invisible(muffled)
[16:11:00.465]                     }
[16:11:00.465]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.465]                   }
[16:11:00.465]                 }
[16:11:00.465]                 else {
[16:11:00.465]                   if (TRUE) {
[16:11:00.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.465]                     {
[16:11:00.465]                       inherits <- base::inherits
[16:11:00.465]                       invokeRestart <- base::invokeRestart
[16:11:00.465]                       is.null <- base::is.null
[16:11:00.465]                       muffled <- FALSE
[16:11:00.465]                       if (inherits(cond, "message")) {
[16:11:00.465]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.465]                         if (muffled) 
[16:11:00.465]                           invokeRestart("muffleMessage")
[16:11:00.465]                       }
[16:11:00.465]                       else if (inherits(cond, "warning")) {
[16:11:00.465]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.465]                         if (muffled) 
[16:11:00.465]                           invokeRestart("muffleWarning")
[16:11:00.465]                       }
[16:11:00.465]                       else if (inherits(cond, "condition")) {
[16:11:00.465]                         if (!is.null(pattern)) {
[16:11:00.465]                           computeRestarts <- base::computeRestarts
[16:11:00.465]                           grepl <- base::grepl
[16:11:00.465]                           restarts <- computeRestarts(cond)
[16:11:00.465]                           for (restart in restarts) {
[16:11:00.465]                             name <- restart$name
[16:11:00.465]                             if (is.null(name)) 
[16:11:00.465]                               next
[16:11:00.465]                             if (!grepl(pattern, name)) 
[16:11:00.465]                               next
[16:11:00.465]                             invokeRestart(restart)
[16:11:00.465]                             muffled <- TRUE
[16:11:00.465]                             break
[16:11:00.465]                           }
[16:11:00.465]                         }
[16:11:00.465]                       }
[16:11:00.465]                       invisible(muffled)
[16:11:00.465]                     }
[16:11:00.465]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.465]                   }
[16:11:00.465]                 }
[16:11:00.465]             }
[16:11:00.465]         }))
[16:11:00.465]     }, error = function(ex) {
[16:11:00.465]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.465]                 ...future.rng), started = ...future.startTime, 
[16:11:00.465]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.465]             version = "1.8"), class = "FutureResult")
[16:11:00.465]     }, finally = {
[16:11:00.465]         if (!identical(...future.workdir, getwd())) 
[16:11:00.465]             setwd(...future.workdir)
[16:11:00.465]         {
[16:11:00.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.465]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.465]             }
[16:11:00.465]             base::options(...future.oldOptions)
[16:11:00.465]             if (.Platform$OS.type == "windows") {
[16:11:00.465]                 old_names <- names(...future.oldEnvVars)
[16:11:00.465]                 envs <- base::Sys.getenv()
[16:11:00.465]                 names <- names(envs)
[16:11:00.465]                 common <- intersect(names, old_names)
[16:11:00.465]                 added <- setdiff(names, old_names)
[16:11:00.465]                 removed <- setdiff(old_names, names)
[16:11:00.465]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.465]                   envs[common]]
[16:11:00.465]                 NAMES <- toupper(changed)
[16:11:00.465]                 args <- list()
[16:11:00.465]                 for (kk in seq_along(NAMES)) {
[16:11:00.465]                   name <- changed[[kk]]
[16:11:00.465]                   NAME <- NAMES[[kk]]
[16:11:00.465]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.465]                     next
[16:11:00.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.465]                 }
[16:11:00.465]                 NAMES <- toupper(added)
[16:11:00.465]                 for (kk in seq_along(NAMES)) {
[16:11:00.465]                   name <- added[[kk]]
[16:11:00.465]                   NAME <- NAMES[[kk]]
[16:11:00.465]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.465]                     next
[16:11:00.465]                   args[[name]] <- ""
[16:11:00.465]                 }
[16:11:00.465]                 NAMES <- toupper(removed)
[16:11:00.465]                 for (kk in seq_along(NAMES)) {
[16:11:00.465]                   name <- removed[[kk]]
[16:11:00.465]                   NAME <- NAMES[[kk]]
[16:11:00.465]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.465]                     next
[16:11:00.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.465]                 }
[16:11:00.465]                 if (length(args) > 0) 
[16:11:00.465]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.465]             }
[16:11:00.465]             else {
[16:11:00.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.465]             }
[16:11:00.465]             {
[16:11:00.465]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.465]                   0L) {
[16:11:00.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.465]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.465]                   base::options(opts)
[16:11:00.465]                 }
[16:11:00.465]                 {
[16:11:00.465]                   {
[16:11:00.465]                     NULL
[16:11:00.465]                     RNGkind("Mersenne-Twister")
[16:11:00.465]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:11:00.465]                       inherits = FALSE)
[16:11:00.465]                   }
[16:11:00.465]                   options(future.plan = NULL)
[16:11:00.465]                   if (is.na(NA_character_)) 
[16:11:00.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.465]                   future::plan(list(function (..., envir = parent.frame()) 
[16:11:00.465]                   {
[16:11:00.465]                     future <- SequentialFuture(..., envir = envir)
[16:11:00.465]                     if (!future$lazy) 
[16:11:00.465]                       future <- run(future)
[16:11:00.465]                     invisible(future)
[16:11:00.465]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.465]                 }
[16:11:00.465]             }
[16:11:00.465]         }
[16:11:00.465]     })
[16:11:00.465]     if (TRUE) {
[16:11:00.465]         base::sink(type = "output", split = FALSE)
[16:11:00.465]         if (TRUE) {
[16:11:00.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.465]         }
[16:11:00.465]         else {
[16:11:00.465]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.465]         }
[16:11:00.465]         base::close(...future.stdout)
[16:11:00.465]         ...future.stdout <- NULL
[16:11:00.465]     }
[16:11:00.465]     ...future.result$conditions <- ...future.conditions
[16:11:00.465]     ...future.result$finished <- base::Sys.time()
[16:11:00.465]     ...future.result
[16:11:00.465] }
[16:11:00.467] assign_globals() ...
[16:11:00.467] List of 11
[16:11:00.467]  $ ...future.FUN            :function (x, ...)  
[16:11:00.467]  $ x_FUN                    :function (x)  
[16:11:00.467]  $ times                    : int 2
[16:11:00.467]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.467]  $ stop_if_not              :function (...)  
[16:11:00.467]  $ dim                      : NULL
[16:11:00.467]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.467]  $ future.call.arguments    : list()
[16:11:00.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.467]  $ ...future.elements_ii    :List of 3
[16:11:00.467]   ..$ : int 1
[16:11:00.467]   ..$ : int 2
[16:11:00.467]   ..$ : int 3
[16:11:00.467]  $ ...future.seeds_ii       : NULL
[16:11:00.467]  $ ...future.globals.maxSize: NULL
[16:11:00.467]  - attr(*, "resolved")= logi FALSE
[16:11:00.467]  - attr(*, "total_size")= num 95128
[16:11:00.467]  - attr(*, "where")=List of 11
[16:11:00.467]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.467]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.467]  - attr(*, "already-done")= logi TRUE
[16:11:00.474] - copied ‘...future.FUN’ to environment
[16:11:00.474] - copied ‘x_FUN’ to environment
[16:11:00.474] - copied ‘times’ to environment
[16:11:00.475] - copied ‘stopf’ to environment
[16:11:00.475] - copied ‘stop_if_not’ to environment
[16:11:00.475] - copied ‘dim’ to environment
[16:11:00.475] - copied ‘valid_types’ to environment
[16:11:00.475] - copied ‘future.call.arguments’ to environment
[16:11:00.475] - copied ‘...future.elements_ii’ to environment
[16:11:00.475] - copied ‘...future.seeds_ii’ to environment
[16:11:00.475] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.475] assign_globals() ... done
[16:11:00.476] plan(): Setting new future strategy stack:
[16:11:00.476] List of future strategies:
[16:11:00.476] 1. sequential:
[16:11:00.476]    - args: function (..., envir = parent.frame())
[16:11:00.476]    - tweaked: FALSE
[16:11:00.476]    - call: NULL
[16:11:00.477] plan(): nbrOfWorkers() = 1
[16:11:00.478] plan(): Setting new future strategy stack:
[16:11:00.478] List of future strategies:
[16:11:00.478] 1. sequential:
[16:11:00.478]    - args: function (..., envir = parent.frame())
[16:11:00.478]    - tweaked: FALSE
[16:11:00.478]    - call: plan(strategy)
[16:11:00.478] plan(): nbrOfWorkers() = 1
[16:11:00.479] SequentialFuture started (and completed)
[16:11:00.479] signalConditions() ...
[16:11:00.479]  - include = ‘immediateCondition’
[16:11:00.479]  - exclude = 
[16:11:00.479]  - resignal = FALSE
[16:11:00.479]  - Number of conditions: 1
[16:11:00.479] signalConditions() ... done
[16:11:00.479] - Launch lazy future ... done
[16:11:00.479] run() for ‘SequentialFuture’ ... done
[16:11:00.479] Created future:
[16:11:00.479] SequentialFuture:
[16:11:00.479] Label: ‘future_vapply-1’
[16:11:00.479] Expression:
[16:11:00.479] {
[16:11:00.479]     do.call(function(...) {
[16:11:00.479]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.479]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.479]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.479]             on.exit(options(oopts), add = TRUE)
[16:11:00.479]         }
[16:11:00.479]         {
[16:11:00.479]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.479]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.479]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.479]             })
[16:11:00.479]         }
[16:11:00.479]     }, args = future.call.arguments)
[16:11:00.479] }
[16:11:00.479] Lazy evaluation: FALSE
[16:11:00.479] Asynchronous evaluation: FALSE
[16:11:00.479] Local evaluation: TRUE
[16:11:00.479] Environment: R_GlobalEnv
[16:11:00.479] Capture standard output: TRUE
[16:11:00.479] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.479] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.479] Packages: 1 packages (‘future.apply’)
[16:11:00.479] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.479] Resolved: TRUE
[16:11:00.479] Value: 0 bytes of class ‘NULL’
[16:11:00.479] Conditions captured: [n=1] ‘simpleError’
[16:11:00.479] Early signaling: FALSE
[16:11:00.479] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.479] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:11:00.481] Chunk #1 of 1 ... DONE
[16:11:00.481] Launching 1 futures (chunks) ... DONE
[16:11:00.481] Resolving 1 futures (chunks) ...
[16:11:00.481] resolve() on list ...
[16:11:00.481]  recursive: 0
[16:11:00.481]  length: 1
[16:11:00.481] 
[16:11:00.481] resolved() for ‘SequentialFuture’ ...
[16:11:00.481] - state: ‘finished’
[16:11:00.481] - run: TRUE
[16:11:00.481] - result: ‘FutureResult’
[16:11:00.482] resolved() for ‘SequentialFuture’ ... done
[16:11:00.482] Future #1
[16:11:00.482] signalConditions() ...
[16:11:00.482]  - include = ‘immediateCondition’
[16:11:00.482]  - exclude = 
[16:11:00.482]  - resignal = FALSE
[16:11:00.482]  - Number of conditions: 1
[16:11:00.482] signalConditions() ... done
[16:11:00.482] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:11:00.482] - nx: 1
[16:11:00.482] - relay: TRUE
[16:11:00.482] - stdout: TRUE
[16:11:00.483] - signal: TRUE
[16:11:00.483] - resignal: FALSE
[16:11:00.483] - force: TRUE
[16:11:00.483] - relayed: [n=1] FALSE
[16:11:00.483] - queued futures: [n=1] FALSE
[16:11:00.483]  - until=1
[16:11:00.483]  - relaying element #1
[16:11:00.483] signalConditions() ...
[16:11:00.483]  - include = ‘immediateCondition’
[16:11:00.483]  - exclude = 
[16:11:00.483]  - resignal = FALSE
[16:11:00.483]  - Number of conditions: 1
[16:11:00.484] signalConditions() ... done
[16:11:00.484] signalConditions() ...
[16:11:00.484]  - include = ‘immediateCondition’
[16:11:00.484]  - exclude = 
[16:11:00.484]  - resignal = FALSE
[16:11:00.484]  - Number of conditions: 1
[16:11:00.484] signalConditions() ... done
[16:11:00.484] signalConditions() ...
[16:11:00.484]  - include = ‘condition’
[16:11:00.484]  - exclude = ‘immediateCondition’
[16:11:00.484]  - resignal = TRUE
[16:11:00.485]  - Number of conditions: 1
[16:11:00.485]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:11:00.485] signalConditions() ... done
[16:11:00.485] - relayed: [n=1] FALSE
[16:11:00.485] - queued futures: [n=1] TRUE
[16:11:00.485] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:11:00.485] plan(): Setting new future strategy stack:
[16:11:00.485] List of future strategies:
[16:11:00.485] 1. sequential:
[16:11:00.485]    - args: function (..., envir = parent.frame())
[16:11:00.485]    - tweaked: FALSE
[16:11:00.485]    - call: plan(sequential)
[16:11:00.486] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:11:00.486] plan(): Setting new future strategy stack:
[16:11:00.486] List of future strategies:
[16:11:00.486] 1. multicore:
[16:11:00.486]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.486]    - tweaked: FALSE
[16:11:00.486]    - call: plan(strategy)
[16:11:00.490] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:11:00.492] future_lapply() ...
[16:11:00.497] Number of chunks: 2
[16:11:00.498] getGlobalsAndPackagesXApply() ...
[16:11:00.498]  - future.globals: TRUE
[16:11:00.498] getGlobalsAndPackages() ...
[16:11:00.498] Searching for globals...
[16:11:00.503] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:00.503] Searching for globals ... DONE
[16:11:00.503] Resolving globals: FALSE
[16:11:00.504] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:11:00.505] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.505] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.505] - packages: [1] ‘future.apply’
[16:11:00.505] getGlobalsAndPackages() ... DONE
[16:11:00.505]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.505]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.505] Finding globals ... DONE
[16:11:00.505]  - use_args: TRUE
[16:11:00.505]  - Getting '...' globals ...
[16:11:00.506] resolve() on list ...
[16:11:00.506]  recursive: 0
[16:11:00.506]  length: 1
[16:11:00.506]  elements: ‘...’
[16:11:00.506]  length: 0 (resolved future 1)
[16:11:00.506] resolve() on list ... DONE
[16:11:00.506]    - '...' content: [n=0] 
[16:11:00.506] List of 1
[16:11:00.506]  $ ...: list()
[16:11:00.506]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.506]  - attr(*, "where")=List of 1
[16:11:00.506]   ..$ ...:<environment: 0x561e8a129480> 
[16:11:00.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.506]  - attr(*, "resolved")= logi TRUE
[16:11:00.506]  - attr(*, "total_size")= num NA
[16:11:00.509]  - Getting '...' globals ... DONE
[16:11:00.509] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.509] List of 8
[16:11:00.509]  $ ...future.FUN:function (x, ...)  
[16:11:00.509]  $ x_FUN        :function (x)  
[16:11:00.509]  $ times        : int 1
[16:11:00.509]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.509]  $ stop_if_not  :function (...)  
[16:11:00.509]  $ dim          : NULL
[16:11:00.509]  $ valid_types  : chr "character"
[16:11:00.509]  $ ...          : list()
[16:11:00.509]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.509]  - attr(*, "where")=List of 8
[16:11:00.509]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.509]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.509]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.509]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.509]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.509]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.509]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.509]   ..$ ...          :<environment: 0x561e8a129480> 
[16:11:00.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.509]  - attr(*, "resolved")= logi FALSE
[16:11:00.509]  - attr(*, "total_size")= num 94208
[16:11:00.514] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.514] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.515] Number of futures (= number of chunks): 2
[16:11:00.515] Launching 2 futures (chunks) ...
[16:11:00.515] Chunk #1 of 2 ...
[16:11:00.515]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.515] getGlobalsAndPackages() ...
[16:11:00.515] Searching for globals...
[16:11:00.515] 
[16:11:00.515] Searching for globals ... DONE
[16:11:00.515] - globals: [0] <none>
[16:11:00.515] getGlobalsAndPackages() ... DONE
[16:11:00.516]    + additional globals found: [n=0] 
[16:11:00.516]    + additional namespaces needed: [n=0] 
[16:11:00.516]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.516]  - seeds: <none>
[16:11:00.516] getGlobalsAndPackages() ...
[16:11:00.516] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.516] Resolving globals: FALSE
[16:11:00.516] Tweak future expression to call with '...' arguments ...
[16:11:00.516] {
[16:11:00.516]     do.call(function(...) {
[16:11:00.516]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.516]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.516]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.516]             on.exit(options(oopts), add = TRUE)
[16:11:00.516]         }
[16:11:00.516]         {
[16:11:00.516]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.516]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.516]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.516]             })
[16:11:00.516]         }
[16:11:00.516]     }, args = future.call.arguments)
[16:11:00.516] }
[16:11:00.517] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.517] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.517] - packages: [1] ‘future.apply’
[16:11:00.517] getGlobalsAndPackages() ... DONE
[16:11:00.518] run() for ‘Future’ ...
[16:11:00.518] - state: ‘created’
[16:11:00.518] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:00.521] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.521] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:00.521]   - Field: ‘label’
[16:11:00.522]   - Field: ‘local’
[16:11:00.522]   - Field: ‘owner’
[16:11:00.522]   - Field: ‘envir’
[16:11:00.522]   - Field: ‘workers’
[16:11:00.522]   - Field: ‘packages’
[16:11:00.522]   - Field: ‘gc’
[16:11:00.522]   - Field: ‘job’
[16:11:00.522]   - Field: ‘conditions’
[16:11:00.522]   - Field: ‘expr’
[16:11:00.522]   - Field: ‘uuid’
[16:11:00.522]   - Field: ‘seed’
[16:11:00.523]   - Field: ‘version’
[16:11:00.523]   - Field: ‘result’
[16:11:00.523]   - Field: ‘asynchronous’
[16:11:00.523]   - Field: ‘calls’
[16:11:00.523]   - Field: ‘globals’
[16:11:00.523]   - Field: ‘stdout’
[16:11:00.523]   - Field: ‘earlySignal’
[16:11:00.523]   - Field: ‘lazy’
[16:11:00.523]   - Field: ‘state’
[16:11:00.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:00.523] - Launch lazy future ...
[16:11:00.525] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.525] Packages needed by future strategies (n = 0): <none>
[16:11:00.526] {
[16:11:00.526]     {
[16:11:00.526]         {
[16:11:00.526]             ...future.startTime <- base::Sys.time()
[16:11:00.526]             {
[16:11:00.526]                 {
[16:11:00.526]                   {
[16:11:00.526]                     {
[16:11:00.526]                       {
[16:11:00.526]                         base::local({
[16:11:00.526]                           has_future <- base::requireNamespace("future", 
[16:11:00.526]                             quietly = TRUE)
[16:11:00.526]                           if (has_future) {
[16:11:00.526]                             ns <- base::getNamespace("future")
[16:11:00.526]                             version <- ns[[".package"]][["version"]]
[16:11:00.526]                             if (is.null(version)) 
[16:11:00.526]                               version <- utils::packageVersion("future")
[16:11:00.526]                           }
[16:11:00.526]                           else {
[16:11:00.526]                             version <- NULL
[16:11:00.526]                           }
[16:11:00.526]                           if (!has_future || version < "1.8.0") {
[16:11:00.526]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.526]                               "", base::R.version$version.string), 
[16:11:00.526]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:00.526]                                 base::R.version$platform, 8 * 
[16:11:00.526]                                   base::.Machine$sizeof.pointer), 
[16:11:00.526]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.526]                                 "release", "version")], collapse = " "), 
[16:11:00.526]                               hostname = base::Sys.info()[["nodename"]])
[16:11:00.526]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.526]                               info)
[16:11:00.526]                             info <- base::paste(info, collapse = "; ")
[16:11:00.526]                             if (!has_future) {
[16:11:00.526]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.526]                                 info)
[16:11:00.526]                             }
[16:11:00.526]                             else {
[16:11:00.526]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.526]                                 info, version)
[16:11:00.526]                             }
[16:11:00.526]                             base::stop(msg)
[16:11:00.526]                           }
[16:11:00.526]                         })
[16:11:00.526]                       }
[16:11:00.526]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:00.526]                       base::options(mc.cores = 1L)
[16:11:00.526]                     }
[16:11:00.526]                     base::local({
[16:11:00.526]                       for (pkg in "future.apply") {
[16:11:00.526]                         base::loadNamespace(pkg)
[16:11:00.526]                         base::library(pkg, character.only = TRUE)
[16:11:00.526]                       }
[16:11:00.526]                     })
[16:11:00.526]                   }
[16:11:00.526]                   options(future.plan = NULL)
[16:11:00.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.526]                 }
[16:11:00.526]                 ...future.workdir <- getwd()
[16:11:00.526]             }
[16:11:00.526]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.526]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.526]         }
[16:11:00.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:00.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.526]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.526]             base::names(...future.oldOptions))
[16:11:00.526]     }
[16:11:00.526]     if (FALSE) {
[16:11:00.526]     }
[16:11:00.526]     else {
[16:11:00.526]         if (TRUE) {
[16:11:00.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.526]                 open = "w")
[16:11:00.526]         }
[16:11:00.526]         else {
[16:11:00.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.526]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.526]         }
[16:11:00.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.526]             base::sink(type = "output", split = FALSE)
[16:11:00.526]             base::close(...future.stdout)
[16:11:00.526]         }, add = TRUE)
[16:11:00.526]     }
[16:11:00.526]     ...future.frame <- base::sys.nframe()
[16:11:00.526]     ...future.conditions <- base::list()
[16:11:00.526]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.526]     if (FALSE) {
[16:11:00.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.526]     }
[16:11:00.526]     ...future.result <- base::tryCatch({
[16:11:00.526]         base::withCallingHandlers({
[16:11:00.526]             ...future.value <- base::withVisible(base::local({
[16:11:00.526]                 withCallingHandlers({
[16:11:00.526]                   {
[16:11:00.526]                     do.call(function(...) {
[16:11:00.526]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.526]                       if (!identical(...future.globals.maxSize.org, 
[16:11:00.526]                         ...future.globals.maxSize)) {
[16:11:00.526]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.526]                         on.exit(options(oopts), add = TRUE)
[16:11:00.526]                       }
[16:11:00.526]                       {
[16:11:00.526]                         lapply(seq_along(...future.elements_ii), 
[16:11:00.526]                           FUN = function(jj) {
[16:11:00.526]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.526]                             ...future.FUN(...future.X_jj, ...)
[16:11:00.526]                           })
[16:11:00.526]                       }
[16:11:00.526]                     }, args = future.call.arguments)
[16:11:00.526]                   }
[16:11:00.526]                 }, immediateCondition = function(cond) {
[16:11:00.526]                   save_rds <- function (object, pathname, ...) 
[16:11:00.526]                   {
[16:11:00.526]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:00.526]                     if (file_test("-f", pathname_tmp)) {
[16:11:00.526]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.526]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:00.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.526]                         fi_tmp[["mtime"]])
[16:11:00.526]                     }
[16:11:00.526]                     tryCatch({
[16:11:00.526]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:00.526]                     }, error = function(ex) {
[16:11:00.526]                       msg <- conditionMessage(ex)
[16:11:00.526]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.526]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:00.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.526]                         fi_tmp[["mtime"]], msg)
[16:11:00.526]                       ex$message <- msg
[16:11:00.526]                       stop(ex)
[16:11:00.526]                     })
[16:11:00.526]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:00.526]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:00.526]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:00.526]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.526]                       fi <- file.info(pathname)
[16:11:00.526]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:00.526]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.526]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:00.526]                         fi[["size"]], fi[["mtime"]])
[16:11:00.526]                       stop(msg)
[16:11:00.526]                     }
[16:11:00.526]                     invisible(pathname)
[16:11:00.526]                   }
[16:11:00.526]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:00.526]                     rootPath = tempdir()) 
[16:11:00.526]                   {
[16:11:00.526]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:00.526]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:00.526]                       tmpdir = path, fileext = ".rds")
[16:11:00.526]                     save_rds(obj, file)
[16:11:00.526]                   }
[16:11:00.526]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:00.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.526]                   {
[16:11:00.526]                     inherits <- base::inherits
[16:11:00.526]                     invokeRestart <- base::invokeRestart
[16:11:00.526]                     is.null <- base::is.null
[16:11:00.526]                     muffled <- FALSE
[16:11:00.526]                     if (inherits(cond, "message")) {
[16:11:00.526]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:00.526]                       if (muffled) 
[16:11:00.526]                         invokeRestart("muffleMessage")
[16:11:00.526]                     }
[16:11:00.526]                     else if (inherits(cond, "warning")) {
[16:11:00.526]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:00.526]                       if (muffled) 
[16:11:00.526]                         invokeRestart("muffleWarning")
[16:11:00.526]                     }
[16:11:00.526]                     else if (inherits(cond, "condition")) {
[16:11:00.526]                       if (!is.null(pattern)) {
[16:11:00.526]                         computeRestarts <- base::computeRestarts
[16:11:00.526]                         grepl <- base::grepl
[16:11:00.526]                         restarts <- computeRestarts(cond)
[16:11:00.526]                         for (restart in restarts) {
[16:11:00.526]                           name <- restart$name
[16:11:00.526]                           if (is.null(name)) 
[16:11:00.526]                             next
[16:11:00.526]                           if (!grepl(pattern, name)) 
[16:11:00.526]                             next
[16:11:00.526]                           invokeRestart(restart)
[16:11:00.526]                           muffled <- TRUE
[16:11:00.526]                           break
[16:11:00.526]                         }
[16:11:00.526]                       }
[16:11:00.526]                     }
[16:11:00.526]                     invisible(muffled)
[16:11:00.526]                   }
[16:11:00.526]                   muffleCondition(cond)
[16:11:00.526]                 })
[16:11:00.526]             }))
[16:11:00.526]             future::FutureResult(value = ...future.value$value, 
[16:11:00.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.526]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.526]                     ...future.globalenv.names))
[16:11:00.526]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.526]         }, condition = base::local({
[16:11:00.526]             c <- base::c
[16:11:00.526]             inherits <- base::inherits
[16:11:00.526]             invokeRestart <- base::invokeRestart
[16:11:00.526]             length <- base::length
[16:11:00.526]             list <- base::list
[16:11:00.526]             seq.int <- base::seq.int
[16:11:00.526]             signalCondition <- base::signalCondition
[16:11:00.526]             sys.calls <- base::sys.calls
[16:11:00.526]             `[[` <- base::`[[`
[16:11:00.526]             `+` <- base::`+`
[16:11:00.526]             `<<-` <- base::`<<-`
[16:11:00.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.526]                   3L)]
[16:11:00.526]             }
[16:11:00.526]             function(cond) {
[16:11:00.526]                 is_error <- inherits(cond, "error")
[16:11:00.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.526]                   NULL)
[16:11:00.526]                 if (is_error) {
[16:11:00.526]                   sessionInformation <- function() {
[16:11:00.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.526]                       search = base::search(), system = base::Sys.info())
[16:11:00.526]                   }
[16:11:00.526]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.526]                     cond$call), session = sessionInformation(), 
[16:11:00.526]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.526]                   signalCondition(cond)
[16:11:00.526]                 }
[16:11:00.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.526]                 "immediateCondition"))) {
[16:11:00.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.526]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.526]                   if (TRUE && !signal) {
[16:11:00.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.526]                     {
[16:11:00.526]                       inherits <- base::inherits
[16:11:00.526]                       invokeRestart <- base::invokeRestart
[16:11:00.526]                       is.null <- base::is.null
[16:11:00.526]                       muffled <- FALSE
[16:11:00.526]                       if (inherits(cond, "message")) {
[16:11:00.526]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.526]                         if (muffled) 
[16:11:00.526]                           invokeRestart("muffleMessage")
[16:11:00.526]                       }
[16:11:00.526]                       else if (inherits(cond, "warning")) {
[16:11:00.526]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.526]                         if (muffled) 
[16:11:00.526]                           invokeRestart("muffleWarning")
[16:11:00.526]                       }
[16:11:00.526]                       else if (inherits(cond, "condition")) {
[16:11:00.526]                         if (!is.null(pattern)) {
[16:11:00.526]                           computeRestarts <- base::computeRestarts
[16:11:00.526]                           grepl <- base::grepl
[16:11:00.526]                           restarts <- computeRestarts(cond)
[16:11:00.526]                           for (restart in restarts) {
[16:11:00.526]                             name <- restart$name
[16:11:00.526]                             if (is.null(name)) 
[16:11:00.526]                               next
[16:11:00.526]                             if (!grepl(pattern, name)) 
[16:11:00.526]                               next
[16:11:00.526]                             invokeRestart(restart)
[16:11:00.526]                             muffled <- TRUE
[16:11:00.526]                             break
[16:11:00.526]                           }
[16:11:00.526]                         }
[16:11:00.526]                       }
[16:11:00.526]                       invisible(muffled)
[16:11:00.526]                     }
[16:11:00.526]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.526]                   }
[16:11:00.526]                 }
[16:11:00.526]                 else {
[16:11:00.526]                   if (TRUE) {
[16:11:00.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.526]                     {
[16:11:00.526]                       inherits <- base::inherits
[16:11:00.526]                       invokeRestart <- base::invokeRestart
[16:11:00.526]                       is.null <- base::is.null
[16:11:00.526]                       muffled <- FALSE
[16:11:00.526]                       if (inherits(cond, "message")) {
[16:11:00.526]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.526]                         if (muffled) 
[16:11:00.526]                           invokeRestart("muffleMessage")
[16:11:00.526]                       }
[16:11:00.526]                       else if (inherits(cond, "warning")) {
[16:11:00.526]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.526]                         if (muffled) 
[16:11:00.526]                           invokeRestart("muffleWarning")
[16:11:00.526]                       }
[16:11:00.526]                       else if (inherits(cond, "condition")) {
[16:11:00.526]                         if (!is.null(pattern)) {
[16:11:00.526]                           computeRestarts <- base::computeRestarts
[16:11:00.526]                           grepl <- base::grepl
[16:11:00.526]                           restarts <- computeRestarts(cond)
[16:11:00.526]                           for (restart in restarts) {
[16:11:00.526]                             name <- restart$name
[16:11:00.526]                             if (is.null(name)) 
[16:11:00.526]                               next
[16:11:00.526]                             if (!grepl(pattern, name)) 
[16:11:00.526]                               next
[16:11:00.526]                             invokeRestart(restart)
[16:11:00.526]                             muffled <- TRUE
[16:11:00.526]                             break
[16:11:00.526]                           }
[16:11:00.526]                         }
[16:11:00.526]                       }
[16:11:00.526]                       invisible(muffled)
[16:11:00.526]                     }
[16:11:00.526]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.526]                   }
[16:11:00.526]                 }
[16:11:00.526]             }
[16:11:00.526]         }))
[16:11:00.526]     }, error = function(ex) {
[16:11:00.526]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.526]                 ...future.rng), started = ...future.startTime, 
[16:11:00.526]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.526]             version = "1.8"), class = "FutureResult")
[16:11:00.526]     }, finally = {
[16:11:00.526]         if (!identical(...future.workdir, getwd())) 
[16:11:00.526]             setwd(...future.workdir)
[16:11:00.526]         {
[16:11:00.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.526]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.526]             }
[16:11:00.526]             base::options(...future.oldOptions)
[16:11:00.526]             if (.Platform$OS.type == "windows") {
[16:11:00.526]                 old_names <- names(...future.oldEnvVars)
[16:11:00.526]                 envs <- base::Sys.getenv()
[16:11:00.526]                 names <- names(envs)
[16:11:00.526]                 common <- intersect(names, old_names)
[16:11:00.526]                 added <- setdiff(names, old_names)
[16:11:00.526]                 removed <- setdiff(old_names, names)
[16:11:00.526]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.526]                   envs[common]]
[16:11:00.526]                 NAMES <- toupper(changed)
[16:11:00.526]                 args <- list()
[16:11:00.526]                 for (kk in seq_along(NAMES)) {
[16:11:00.526]                   name <- changed[[kk]]
[16:11:00.526]                   NAME <- NAMES[[kk]]
[16:11:00.526]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.526]                     next
[16:11:00.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.526]                 }
[16:11:00.526]                 NAMES <- toupper(added)
[16:11:00.526]                 for (kk in seq_along(NAMES)) {
[16:11:00.526]                   name <- added[[kk]]
[16:11:00.526]                   NAME <- NAMES[[kk]]
[16:11:00.526]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.526]                     next
[16:11:00.526]                   args[[name]] <- ""
[16:11:00.526]                 }
[16:11:00.526]                 NAMES <- toupper(removed)
[16:11:00.526]                 for (kk in seq_along(NAMES)) {
[16:11:00.526]                   name <- removed[[kk]]
[16:11:00.526]                   NAME <- NAMES[[kk]]
[16:11:00.526]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.526]                     next
[16:11:00.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.526]                 }
[16:11:00.526]                 if (length(args) > 0) 
[16:11:00.526]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.526]             }
[16:11:00.526]             else {
[16:11:00.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.526]             }
[16:11:00.526]             {
[16:11:00.526]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.526]                   0L) {
[16:11:00.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.526]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.526]                   base::options(opts)
[16:11:00.526]                 }
[16:11:00.526]                 {
[16:11:00.526]                   {
[16:11:00.526]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:00.526]                     NULL
[16:11:00.526]                   }
[16:11:00.526]                   options(future.plan = NULL)
[16:11:00.526]                   if (is.na(NA_character_)) 
[16:11:00.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.526]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:00.526]                     envir = parent.frame()) 
[16:11:00.526]                   {
[16:11:00.526]                     default_workers <- missing(workers)
[16:11:00.526]                     if (is.function(workers)) 
[16:11:00.526]                       workers <- workers()
[16:11:00.526]                     workers <- structure(as.integer(workers), 
[16:11:00.526]                       class = class(workers))
[16:11:00.526]                     stop_if_not(is.finite(workers), workers >= 
[16:11:00.526]                       1L)
[16:11:00.526]                     if ((workers == 1L && !inherits(workers, 
[16:11:00.526]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:00.526]                       if (default_workers) 
[16:11:00.526]                         supportsMulticore(warn = TRUE)
[16:11:00.526]                       return(sequential(..., envir = envir))
[16:11:00.526]                     }
[16:11:00.526]                     oopts <- options(mc.cores = workers)
[16:11:00.526]                     on.exit(options(oopts))
[16:11:00.526]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:00.526]                       envir = envir)
[16:11:00.526]                     if (!future$lazy) 
[16:11:00.526]                       future <- run(future)
[16:11:00.526]                     invisible(future)
[16:11:00.526]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.526]                 }
[16:11:00.526]             }
[16:11:00.526]         }
[16:11:00.526]     })
[16:11:00.526]     if (TRUE) {
[16:11:00.526]         base::sink(type = "output", split = FALSE)
[16:11:00.526]         if (TRUE) {
[16:11:00.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.526]         }
[16:11:00.526]         else {
[16:11:00.526]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.526]         }
[16:11:00.526]         base::close(...future.stdout)
[16:11:00.526]         ...future.stdout <- NULL
[16:11:00.526]     }
[16:11:00.526]     ...future.result$conditions <- ...future.conditions
[16:11:00.526]     ...future.result$finished <- base::Sys.time()
[16:11:00.526]     ...future.result
[16:11:00.526] }
[16:11:00.529] assign_globals() ...
[16:11:00.529] List of 11
[16:11:00.529]  $ ...future.FUN            :function (x, ...)  
[16:11:00.529]  $ x_FUN                    :function (x)  
[16:11:00.529]  $ times                    : int 1
[16:11:00.529]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.529]  $ stop_if_not              :function (...)  
[16:11:00.529]  $ dim                      : NULL
[16:11:00.529]  $ valid_types              : chr "character"
[16:11:00.529]  $ future.call.arguments    : list()
[16:11:00.529]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.529]  $ ...future.elements_ii    :List of 1
[16:11:00.529]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:11:00.529]  $ ...future.seeds_ii       : NULL
[16:11:00.529]  $ ...future.globals.maxSize: NULL
[16:11:00.529]  - attr(*, "where")=List of 11
[16:11:00.529]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.529]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.529]  - attr(*, "resolved")= logi FALSE
[16:11:00.529]  - attr(*, "total_size")= num 94208
[16:11:00.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.529]  - attr(*, "already-done")= logi TRUE
[16:11:00.536] - copied ‘...future.FUN’ to environment
[16:11:00.536] - copied ‘x_FUN’ to environment
[16:11:00.536] - copied ‘times’ to environment
[16:11:00.537] - copied ‘stopf’ to environment
[16:11:00.537] - copied ‘stop_if_not’ to environment
[16:11:00.537] - copied ‘dim’ to environment
[16:11:00.537] - copied ‘valid_types’ to environment
[16:11:00.537] - copied ‘future.call.arguments’ to environment
[16:11:00.537] - copied ‘...future.elements_ii’ to environment
[16:11:00.537] - copied ‘...future.seeds_ii’ to environment
[16:11:00.537] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.537] assign_globals() ... done
[16:11:00.538] requestCore(): workers = 2
[16:11:00.541] MulticoreFuture started
[16:11:00.541] - Launch lazy future ... done
[16:11:00.542] run() for ‘MulticoreFuture’ ... done
[16:11:00.542] Created future:
[16:11:00.542] plan(): Setting new future strategy stack:
[16:11:00.543] List of future strategies:
[16:11:00.543] 1. sequential:
[16:11:00.543]    - args: function (..., envir = parent.frame())
[16:11:00.543]    - tweaked: FALSE
[16:11:00.543]    - call: NULL
[16:11:00.544] plan(): nbrOfWorkers() = 1
[16:11:00.547] plan(): Setting new future strategy stack:
[16:11:00.547] List of future strategies:
[16:11:00.547] 1. multicore:
[16:11:00.547]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.547]    - tweaked: FALSE
[16:11:00.547]    - call: plan(strategy)
[16:11:00.553] plan(): nbrOfWorkers() = 2
[16:11:00.543] MulticoreFuture:
[16:11:00.543] Label: ‘future_vapply-1’
[16:11:00.543] Expression:
[16:11:00.543] {
[16:11:00.543]     do.call(function(...) {
[16:11:00.543]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.543]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.543]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.543]             on.exit(options(oopts), add = TRUE)
[16:11:00.543]         }
[16:11:00.543]         {
[16:11:00.543]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.543]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.543]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.543]             })
[16:11:00.543]         }
[16:11:00.543]     }, args = future.call.arguments)
[16:11:00.543] }
[16:11:00.543] Lazy evaluation: FALSE
[16:11:00.543] Asynchronous evaluation: TRUE
[16:11:00.543] Local evaluation: TRUE
[16:11:00.543] Environment: R_GlobalEnv
[16:11:00.543] Capture standard output: TRUE
[16:11:00.543] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.543] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.543] Packages: 1 packages (‘future.apply’)
[16:11:00.543] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.543] Resolved: TRUE
[16:11:00.543] Value: <not collected>
[16:11:00.543] Conditions captured: <none>
[16:11:00.543] Early signaling: FALSE
[16:11:00.543] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.543] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.554] Chunk #1 of 2 ... DONE
[16:11:00.555] Chunk #2 of 2 ...
[16:11:00.555]  - Finding globals in 'X' for chunk #2 ...
[16:11:00.555] getGlobalsAndPackages() ...
[16:11:00.555] Searching for globals...
[16:11:00.556] 
[16:11:00.556] Searching for globals ... DONE
[16:11:00.556] - globals: [0] <none>
[16:11:00.556] getGlobalsAndPackages() ... DONE
[16:11:00.556]    + additional globals found: [n=0] 
[16:11:00.556]    + additional namespaces needed: [n=0] 
[16:11:00.557]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:00.557]  - seeds: <none>
[16:11:00.557] getGlobalsAndPackages() ...
[16:11:00.557] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.557] Resolving globals: FALSE
[16:11:00.557] Tweak future expression to call with '...' arguments ...
[16:11:00.558] {
[16:11:00.558]     do.call(function(...) {
[16:11:00.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.558]             on.exit(options(oopts), add = TRUE)
[16:11:00.558]         }
[16:11:00.558]         {
[16:11:00.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.558]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.558]             })
[16:11:00.558]         }
[16:11:00.558]     }, args = future.call.arguments)
[16:11:00.558] }
[16:11:00.558] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.559] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.559] - packages: [1] ‘future.apply’
[16:11:00.559] getGlobalsAndPackages() ... DONE
[16:11:00.560] run() for ‘Future’ ...
[16:11:00.560] - state: ‘created’
[16:11:00.560] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:00.565] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:00.565]   - Field: ‘label’
[16:11:00.565]   - Field: ‘local’
[16:11:00.566]   - Field: ‘owner’
[16:11:00.566]   - Field: ‘envir’
[16:11:00.566]   - Field: ‘workers’
[16:11:00.566]   - Field: ‘packages’
[16:11:00.566]   - Field: ‘gc’
[16:11:00.566]   - Field: ‘job’
[16:11:00.566]   - Field: ‘conditions’
[16:11:00.567]   - Field: ‘expr’
[16:11:00.567]   - Field: ‘uuid’
[16:11:00.567]   - Field: ‘seed’
[16:11:00.567]   - Field: ‘version’
[16:11:00.567]   - Field: ‘result’
[16:11:00.567]   - Field: ‘asynchronous’
[16:11:00.567]   - Field: ‘calls’
[16:11:00.568]   - Field: ‘globals’
[16:11:00.568]   - Field: ‘stdout’
[16:11:00.568]   - Field: ‘earlySignal’
[16:11:00.568]   - Field: ‘lazy’
[16:11:00.568]   - Field: ‘state’
[16:11:00.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:00.568] - Launch lazy future ...
[16:11:00.569] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.569] Packages needed by future strategies (n = 0): <none>
[16:11:00.570] {
[16:11:00.570]     {
[16:11:00.570]         {
[16:11:00.570]             ...future.startTime <- base::Sys.time()
[16:11:00.570]             {
[16:11:00.570]                 {
[16:11:00.570]                   {
[16:11:00.570]                     {
[16:11:00.570]                       {
[16:11:00.570]                         base::local({
[16:11:00.570]                           has_future <- base::requireNamespace("future", 
[16:11:00.570]                             quietly = TRUE)
[16:11:00.570]                           if (has_future) {
[16:11:00.570]                             ns <- base::getNamespace("future")
[16:11:00.570]                             version <- ns[[".package"]][["version"]]
[16:11:00.570]                             if (is.null(version)) 
[16:11:00.570]                               version <- utils::packageVersion("future")
[16:11:00.570]                           }
[16:11:00.570]                           else {
[16:11:00.570]                             version <- NULL
[16:11:00.570]                           }
[16:11:00.570]                           if (!has_future || version < "1.8.0") {
[16:11:00.570]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.570]                               "", base::R.version$version.string), 
[16:11:00.570]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:00.570]                                 base::R.version$platform, 8 * 
[16:11:00.570]                                   base::.Machine$sizeof.pointer), 
[16:11:00.570]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.570]                                 "release", "version")], collapse = " "), 
[16:11:00.570]                               hostname = base::Sys.info()[["nodename"]])
[16:11:00.570]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.570]                               info)
[16:11:00.570]                             info <- base::paste(info, collapse = "; ")
[16:11:00.570]                             if (!has_future) {
[16:11:00.570]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.570]                                 info)
[16:11:00.570]                             }
[16:11:00.570]                             else {
[16:11:00.570]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.570]                                 info, version)
[16:11:00.570]                             }
[16:11:00.570]                             base::stop(msg)
[16:11:00.570]                           }
[16:11:00.570]                         })
[16:11:00.570]                       }
[16:11:00.570]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:00.570]                       base::options(mc.cores = 1L)
[16:11:00.570]                     }
[16:11:00.570]                     base::local({
[16:11:00.570]                       for (pkg in "future.apply") {
[16:11:00.570]                         base::loadNamespace(pkg)
[16:11:00.570]                         base::library(pkg, character.only = TRUE)
[16:11:00.570]                       }
[16:11:00.570]                     })
[16:11:00.570]                   }
[16:11:00.570]                   options(future.plan = NULL)
[16:11:00.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.570]                 }
[16:11:00.570]                 ...future.workdir <- getwd()
[16:11:00.570]             }
[16:11:00.570]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.570]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.570]         }
[16:11:00.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:00.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.570]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.570]             base::names(...future.oldOptions))
[16:11:00.570]     }
[16:11:00.570]     if (FALSE) {
[16:11:00.570]     }
[16:11:00.570]     else {
[16:11:00.570]         if (TRUE) {
[16:11:00.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.570]                 open = "w")
[16:11:00.570]         }
[16:11:00.570]         else {
[16:11:00.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.570]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.570]         }
[16:11:00.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.570]             base::sink(type = "output", split = FALSE)
[16:11:00.570]             base::close(...future.stdout)
[16:11:00.570]         }, add = TRUE)
[16:11:00.570]     }
[16:11:00.570]     ...future.frame <- base::sys.nframe()
[16:11:00.570]     ...future.conditions <- base::list()
[16:11:00.570]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.570]     if (FALSE) {
[16:11:00.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.570]     }
[16:11:00.570]     ...future.result <- base::tryCatch({
[16:11:00.570]         base::withCallingHandlers({
[16:11:00.570]             ...future.value <- base::withVisible(base::local({
[16:11:00.570]                 withCallingHandlers({
[16:11:00.570]                   {
[16:11:00.570]                     do.call(function(...) {
[16:11:00.570]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.570]                       if (!identical(...future.globals.maxSize.org, 
[16:11:00.570]                         ...future.globals.maxSize)) {
[16:11:00.570]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.570]                         on.exit(options(oopts), add = TRUE)
[16:11:00.570]                       }
[16:11:00.570]                       {
[16:11:00.570]                         lapply(seq_along(...future.elements_ii), 
[16:11:00.570]                           FUN = function(jj) {
[16:11:00.570]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.570]                             ...future.FUN(...future.X_jj, ...)
[16:11:00.570]                           })
[16:11:00.570]                       }
[16:11:00.570]                     }, args = future.call.arguments)
[16:11:00.570]                   }
[16:11:00.570]                 }, immediateCondition = function(cond) {
[16:11:00.570]                   save_rds <- function (object, pathname, ...) 
[16:11:00.570]                   {
[16:11:00.570]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:00.570]                     if (file_test("-f", pathname_tmp)) {
[16:11:00.570]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.570]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:00.570]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.570]                         fi_tmp[["mtime"]])
[16:11:00.570]                     }
[16:11:00.570]                     tryCatch({
[16:11:00.570]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:00.570]                     }, error = function(ex) {
[16:11:00.570]                       msg <- conditionMessage(ex)
[16:11:00.570]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.570]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:00.570]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.570]                         fi_tmp[["mtime"]], msg)
[16:11:00.570]                       ex$message <- msg
[16:11:00.570]                       stop(ex)
[16:11:00.570]                     })
[16:11:00.570]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:00.570]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:00.570]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:00.570]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.570]                       fi <- file.info(pathname)
[16:11:00.570]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:00.570]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.570]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:00.570]                         fi[["size"]], fi[["mtime"]])
[16:11:00.570]                       stop(msg)
[16:11:00.570]                     }
[16:11:00.570]                     invisible(pathname)
[16:11:00.570]                   }
[16:11:00.570]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:00.570]                     rootPath = tempdir()) 
[16:11:00.570]                   {
[16:11:00.570]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:00.570]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:00.570]                       tmpdir = path, fileext = ".rds")
[16:11:00.570]                     save_rds(obj, file)
[16:11:00.570]                   }
[16:11:00.570]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:00.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.570]                   {
[16:11:00.570]                     inherits <- base::inherits
[16:11:00.570]                     invokeRestart <- base::invokeRestart
[16:11:00.570]                     is.null <- base::is.null
[16:11:00.570]                     muffled <- FALSE
[16:11:00.570]                     if (inherits(cond, "message")) {
[16:11:00.570]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:00.570]                       if (muffled) 
[16:11:00.570]                         invokeRestart("muffleMessage")
[16:11:00.570]                     }
[16:11:00.570]                     else if (inherits(cond, "warning")) {
[16:11:00.570]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:00.570]                       if (muffled) 
[16:11:00.570]                         invokeRestart("muffleWarning")
[16:11:00.570]                     }
[16:11:00.570]                     else if (inherits(cond, "condition")) {
[16:11:00.570]                       if (!is.null(pattern)) {
[16:11:00.570]                         computeRestarts <- base::computeRestarts
[16:11:00.570]                         grepl <- base::grepl
[16:11:00.570]                         restarts <- computeRestarts(cond)
[16:11:00.570]                         for (restart in restarts) {
[16:11:00.570]                           name <- restart$name
[16:11:00.570]                           if (is.null(name)) 
[16:11:00.570]                             next
[16:11:00.570]                           if (!grepl(pattern, name)) 
[16:11:00.570]                             next
[16:11:00.570]                           invokeRestart(restart)
[16:11:00.570]                           muffled <- TRUE
[16:11:00.570]                           break
[16:11:00.570]                         }
[16:11:00.570]                       }
[16:11:00.570]                     }
[16:11:00.570]                     invisible(muffled)
[16:11:00.570]                   }
[16:11:00.570]                   muffleCondition(cond)
[16:11:00.570]                 })
[16:11:00.570]             }))
[16:11:00.570]             future::FutureResult(value = ...future.value$value, 
[16:11:00.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.570]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.570]                     ...future.globalenv.names))
[16:11:00.570]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.570]         }, condition = base::local({
[16:11:00.570]             c <- base::c
[16:11:00.570]             inherits <- base::inherits
[16:11:00.570]             invokeRestart <- base::invokeRestart
[16:11:00.570]             length <- base::length
[16:11:00.570]             list <- base::list
[16:11:00.570]             seq.int <- base::seq.int
[16:11:00.570]             signalCondition <- base::signalCondition
[16:11:00.570]             sys.calls <- base::sys.calls
[16:11:00.570]             `[[` <- base::`[[`
[16:11:00.570]             `+` <- base::`+`
[16:11:00.570]             `<<-` <- base::`<<-`
[16:11:00.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.570]                   3L)]
[16:11:00.570]             }
[16:11:00.570]             function(cond) {
[16:11:00.570]                 is_error <- inherits(cond, "error")
[16:11:00.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.570]                   NULL)
[16:11:00.570]                 if (is_error) {
[16:11:00.570]                   sessionInformation <- function() {
[16:11:00.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.570]                       search = base::search(), system = base::Sys.info())
[16:11:00.570]                   }
[16:11:00.570]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.570]                     cond$call), session = sessionInformation(), 
[16:11:00.570]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.570]                   signalCondition(cond)
[16:11:00.570]                 }
[16:11:00.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.570]                 "immediateCondition"))) {
[16:11:00.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.570]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.570]                   if (TRUE && !signal) {
[16:11:00.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.570]                     {
[16:11:00.570]                       inherits <- base::inherits
[16:11:00.570]                       invokeRestart <- base::invokeRestart
[16:11:00.570]                       is.null <- base::is.null
[16:11:00.570]                       muffled <- FALSE
[16:11:00.570]                       if (inherits(cond, "message")) {
[16:11:00.570]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.570]                         if (muffled) 
[16:11:00.570]                           invokeRestart("muffleMessage")
[16:11:00.570]                       }
[16:11:00.570]                       else if (inherits(cond, "warning")) {
[16:11:00.570]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.570]                         if (muffled) 
[16:11:00.570]                           invokeRestart("muffleWarning")
[16:11:00.570]                       }
[16:11:00.570]                       else if (inherits(cond, "condition")) {
[16:11:00.570]                         if (!is.null(pattern)) {
[16:11:00.570]                           computeRestarts <- base::computeRestarts
[16:11:00.570]                           grepl <- base::grepl
[16:11:00.570]                           restarts <- computeRestarts(cond)
[16:11:00.570]                           for (restart in restarts) {
[16:11:00.570]                             name <- restart$name
[16:11:00.570]                             if (is.null(name)) 
[16:11:00.570]                               next
[16:11:00.570]                             if (!grepl(pattern, name)) 
[16:11:00.570]                               next
[16:11:00.570]                             invokeRestart(restart)
[16:11:00.570]                             muffled <- TRUE
[16:11:00.570]                             break
[16:11:00.570]                           }
[16:11:00.570]                         }
[16:11:00.570]                       }
[16:11:00.570]                       invisible(muffled)
[16:11:00.570]                     }
[16:11:00.570]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.570]                   }
[16:11:00.570]                 }
[16:11:00.570]                 else {
[16:11:00.570]                   if (TRUE) {
[16:11:00.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.570]                     {
[16:11:00.570]                       inherits <- base::inherits
[16:11:00.570]                       invokeRestart <- base::invokeRestart
[16:11:00.570]                       is.null <- base::is.null
[16:11:00.570]                       muffled <- FALSE
[16:11:00.570]                       if (inherits(cond, "message")) {
[16:11:00.570]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.570]                         if (muffled) 
[16:11:00.570]                           invokeRestart("muffleMessage")
[16:11:00.570]                       }
[16:11:00.570]                       else if (inherits(cond, "warning")) {
[16:11:00.570]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.570]                         if (muffled) 
[16:11:00.570]                           invokeRestart("muffleWarning")
[16:11:00.570]                       }
[16:11:00.570]                       else if (inherits(cond, "condition")) {
[16:11:00.570]                         if (!is.null(pattern)) {
[16:11:00.570]                           computeRestarts <- base::computeRestarts
[16:11:00.570]                           grepl <- base::grepl
[16:11:00.570]                           restarts <- computeRestarts(cond)
[16:11:00.570]                           for (restart in restarts) {
[16:11:00.570]                             name <- restart$name
[16:11:00.570]                             if (is.null(name)) 
[16:11:00.570]                               next
[16:11:00.570]                             if (!grepl(pattern, name)) 
[16:11:00.570]                               next
[16:11:00.570]                             invokeRestart(restart)
[16:11:00.570]                             muffled <- TRUE
[16:11:00.570]                             break
[16:11:00.570]                           }
[16:11:00.570]                         }
[16:11:00.570]                       }
[16:11:00.570]                       invisible(muffled)
[16:11:00.570]                     }
[16:11:00.570]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.570]                   }
[16:11:00.570]                 }
[16:11:00.570]             }
[16:11:00.570]         }))
[16:11:00.570]     }, error = function(ex) {
[16:11:00.570]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.570]                 ...future.rng), started = ...future.startTime, 
[16:11:00.570]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.570]             version = "1.8"), class = "FutureResult")
[16:11:00.570]     }, finally = {
[16:11:00.570]         if (!identical(...future.workdir, getwd())) 
[16:11:00.570]             setwd(...future.workdir)
[16:11:00.570]         {
[16:11:00.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.570]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.570]             }
[16:11:00.570]             base::options(...future.oldOptions)
[16:11:00.570]             if (.Platform$OS.type == "windows") {
[16:11:00.570]                 old_names <- names(...future.oldEnvVars)
[16:11:00.570]                 envs <- base::Sys.getenv()
[16:11:00.570]                 names <- names(envs)
[16:11:00.570]                 common <- intersect(names, old_names)
[16:11:00.570]                 added <- setdiff(names, old_names)
[16:11:00.570]                 removed <- setdiff(old_names, names)
[16:11:00.570]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.570]                   envs[common]]
[16:11:00.570]                 NAMES <- toupper(changed)
[16:11:00.570]                 args <- list()
[16:11:00.570]                 for (kk in seq_along(NAMES)) {
[16:11:00.570]                   name <- changed[[kk]]
[16:11:00.570]                   NAME <- NAMES[[kk]]
[16:11:00.570]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.570]                     next
[16:11:00.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.570]                 }
[16:11:00.570]                 NAMES <- toupper(added)
[16:11:00.570]                 for (kk in seq_along(NAMES)) {
[16:11:00.570]                   name <- added[[kk]]
[16:11:00.570]                   NAME <- NAMES[[kk]]
[16:11:00.570]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.570]                     next
[16:11:00.570]                   args[[name]] <- ""
[16:11:00.570]                 }
[16:11:00.570]                 NAMES <- toupper(removed)
[16:11:00.570]                 for (kk in seq_along(NAMES)) {
[16:11:00.570]                   name <- removed[[kk]]
[16:11:00.570]                   NAME <- NAMES[[kk]]
[16:11:00.570]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.570]                     next
[16:11:00.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.570]                 }
[16:11:00.570]                 if (length(args) > 0) 
[16:11:00.570]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.570]             }
[16:11:00.570]             else {
[16:11:00.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.570]             }
[16:11:00.570]             {
[16:11:00.570]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.570]                   0L) {
[16:11:00.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.570]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.570]                   base::options(opts)
[16:11:00.570]                 }
[16:11:00.570]                 {
[16:11:00.570]                   {
[16:11:00.570]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:00.570]                     NULL
[16:11:00.570]                   }
[16:11:00.570]                   options(future.plan = NULL)
[16:11:00.570]                   if (is.na(NA_character_)) 
[16:11:00.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.570]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:00.570]                     envir = parent.frame()) 
[16:11:00.570]                   {
[16:11:00.570]                     default_workers <- missing(workers)
[16:11:00.570]                     if (is.function(workers)) 
[16:11:00.570]                       workers <- workers()
[16:11:00.570]                     workers <- structure(as.integer(workers), 
[16:11:00.570]                       class = class(workers))
[16:11:00.570]                     stop_if_not(is.finite(workers), workers >= 
[16:11:00.570]                       1L)
[16:11:00.570]                     if ((workers == 1L && !inherits(workers, 
[16:11:00.570]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:00.570]                       if (default_workers) 
[16:11:00.570]                         supportsMulticore(warn = TRUE)
[16:11:00.570]                       return(sequential(..., envir = envir))
[16:11:00.570]                     }
[16:11:00.570]                     oopts <- options(mc.cores = workers)
[16:11:00.570]                     on.exit(options(oopts))
[16:11:00.570]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:00.570]                       envir = envir)
[16:11:00.570]                     if (!future$lazy) 
[16:11:00.570]                       future <- run(future)
[16:11:00.570]                     invisible(future)
[16:11:00.570]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.570]                 }
[16:11:00.570]             }
[16:11:00.570]         }
[16:11:00.570]     })
[16:11:00.570]     if (TRUE) {
[16:11:00.570]         base::sink(type = "output", split = FALSE)
[16:11:00.570]         if (TRUE) {
[16:11:00.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.570]         }
[16:11:00.570]         else {
[16:11:00.570]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.570]         }
[16:11:00.570]         base::close(...future.stdout)
[16:11:00.570]         ...future.stdout <- NULL
[16:11:00.570]     }
[16:11:00.570]     ...future.result$conditions <- ...future.conditions
[16:11:00.570]     ...future.result$finished <- base::Sys.time()
[16:11:00.570]     ...future.result
[16:11:00.570] }
[16:11:00.573] assign_globals() ...
[16:11:00.573] List of 11
[16:11:00.573]  $ ...future.FUN            :function (x, ...)  
[16:11:00.573]  $ x_FUN                    :function (x)  
[16:11:00.573]  $ times                    : int 1
[16:11:00.573]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.573]  $ stop_if_not              :function (...)  
[16:11:00.573]  $ dim                      : NULL
[16:11:00.573]  $ valid_types              : chr "character"
[16:11:00.573]  $ future.call.arguments    : list()
[16:11:00.573]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.573]  $ ...future.elements_ii    :List of 1
[16:11:00.573]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[16:11:00.573]  $ ...future.seeds_ii       : NULL
[16:11:00.573]  $ ...future.globals.maxSize: NULL
[16:11:00.573]  - attr(*, "where")=List of 11
[16:11:00.573]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.573]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.573]  - attr(*, "resolved")= logi FALSE
[16:11:00.573]  - attr(*, "total_size")= num 94208
[16:11:00.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.573]  - attr(*, "already-done")= logi TRUE
[16:11:00.590] - copied ‘...future.FUN’ to environment
[16:11:00.591] - copied ‘x_FUN’ to environment
[16:11:00.591] - copied ‘times’ to environment
[16:11:00.591] - copied ‘stopf’ to environment
[16:11:00.591] - copied ‘stop_if_not’ to environment
[16:11:00.591] - copied ‘dim’ to environment
[16:11:00.591] - copied ‘valid_types’ to environment
[16:11:00.591] - copied ‘future.call.arguments’ to environment
[16:11:00.592] - copied ‘...future.elements_ii’ to environment
[16:11:00.592] - copied ‘...future.seeds_ii’ to environment
[16:11:00.592] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.592] assign_globals() ... done
[16:11:00.592] requestCore(): workers = 2
[16:11:00.597] MulticoreFuture started
[16:11:00.597] - Launch lazy future ... done
[16:11:00.597] run() for ‘MulticoreFuture’ ... done
[16:11:00.598] Created future:
[16:11:00.598] plan(): Setting new future strategy stack:
[16:11:00.598] List of future strategies:
[16:11:00.598] 1. sequential:
[16:11:00.598]    - args: function (..., envir = parent.frame())
[16:11:00.598]    - tweaked: FALSE
[16:11:00.598]    - call: NULL
[16:11:00.599] plan(): nbrOfWorkers() = 1
[16:11:00.601] plan(): Setting new future strategy stack:
[16:11:00.601] List of future strategies:
[16:11:00.601] 1. multicore:
[16:11:00.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.601]    - tweaked: FALSE
[16:11:00.601]    - call: plan(strategy)
[16:11:00.606] plan(): nbrOfWorkers() = 2
[16:11:00.598] MulticoreFuture:
[16:11:00.598] Label: ‘future_vapply-2’
[16:11:00.598] Expression:
[16:11:00.598] {
[16:11:00.598]     do.call(function(...) {
[16:11:00.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.598]             on.exit(options(oopts), add = TRUE)
[16:11:00.598]         }
[16:11:00.598]         {
[16:11:00.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.598]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.598]             })
[16:11:00.598]         }
[16:11:00.598]     }, args = future.call.arguments)
[16:11:00.598] }
[16:11:00.598] Lazy evaluation: FALSE
[16:11:00.598] Asynchronous evaluation: TRUE
[16:11:00.598] Local evaluation: TRUE
[16:11:00.598] Environment: R_GlobalEnv
[16:11:00.598] Capture standard output: TRUE
[16:11:00.598] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.598] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.598] Packages: 1 packages (‘future.apply’)
[16:11:00.598] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.598] Resolved: TRUE
[16:11:00.598] Value: <not collected>
[16:11:00.598] Conditions captured: <none>
[16:11:00.598] Early signaling: FALSE
[16:11:00.598] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.598] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.607] Chunk #2 of 2 ... DONE
[16:11:00.608] Launching 2 futures (chunks) ... DONE
[16:11:00.608] Resolving 2 futures (chunks) ...
[16:11:00.608] resolve() on list ...
[16:11:00.608]  recursive: 0
[16:11:00.608]  length: 2
[16:11:00.608] 
[16:11:00.609] Future #1
[16:11:00.611] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:00.611] - nx: 2
[16:11:00.611] - relay: TRUE
[16:11:00.611] - stdout: TRUE
[16:11:00.612] - signal: TRUE
[16:11:00.612] - resignal: FALSE
[16:11:00.612] - force: TRUE
[16:11:00.612] - relayed: [n=2] FALSE, FALSE
[16:11:00.612] - queued futures: [n=2] FALSE, FALSE
[16:11:00.612]  - until=1
[16:11:00.612]  - relaying element #1
[16:11:00.613] - relayed: [n=2] TRUE, FALSE
[16:11:00.613] - queued futures: [n=2] TRUE, FALSE
[16:11:00.613] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:00.613]  length: 1 (resolved future 1)
[16:11:00.614] Future #2
[16:11:00.614] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:00.615] - nx: 2
[16:11:00.615] - relay: TRUE
[16:11:00.615] - stdout: TRUE
[16:11:00.615] - signal: TRUE
[16:11:00.615] - resignal: FALSE
[16:11:00.615] - force: TRUE
[16:11:00.615] - relayed: [n=2] TRUE, FALSE
[16:11:00.615] - queued futures: [n=2] TRUE, FALSE
[16:11:00.616]  - until=2
[16:11:00.616]  - relaying element #2
[16:11:00.616] - relayed: [n=2] TRUE, TRUE
[16:11:00.616] - queued futures: [n=2] TRUE, TRUE
[16:11:00.616] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:00.616]  length: 0 (resolved future 2)
[16:11:00.616] Relaying remaining futures
[16:11:00.617] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.617] - nx: 2
[16:11:00.617] - relay: TRUE
[16:11:00.617] - stdout: TRUE
[16:11:00.617] - signal: TRUE
[16:11:00.617] - resignal: FALSE
[16:11:00.617] - force: TRUE
[16:11:00.617] - relayed: [n=2] TRUE, TRUE
[16:11:00.617] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:00.618] - relayed: [n=2] TRUE, TRUE
[16:11:00.618] - queued futures: [n=2] TRUE, TRUE
[16:11:00.618] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.618] resolve() on list ... DONE
[16:11:00.620]  - Number of value chunks collected: 2
[16:11:00.620] Resolving 2 futures (chunks) ... DONE
[16:11:00.621] Reducing values from 2 chunks ...
[16:11:00.621]  - Number of values collected after concatenation: 2
[16:11:00.621]  - Number of values expected: 2
[16:11:00.621] Reducing values from 2 chunks ... DONE
[16:11:00.621] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:11:00.623] future_lapply() ...
[16:11:00.630] Number of chunks: 2
[16:11:00.630] getGlobalsAndPackagesXApply() ...
[16:11:00.630]  - future.globals: TRUE
[16:11:00.630] getGlobalsAndPackages() ...
[16:11:00.630] Searching for globals...
[16:11:00.634] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:11:00.635] Searching for globals ... DONE
[16:11:00.635] Resolving globals: FALSE
[16:11:00.636] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:11:00.636] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.636] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.636] - packages: [1] ‘future.apply’
[16:11:00.637] getGlobalsAndPackages() ... DONE
[16:11:00.637]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.637]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.637] Finding globals ... DONE
[16:11:00.637]  - use_args: TRUE
[16:11:00.637]  - Getting '...' globals ...
[16:11:00.637] resolve() on list ...
[16:11:00.638]  recursive: 0
[16:11:00.638]  length: 1
[16:11:00.638]  elements: ‘...’
[16:11:00.638]  length: 0 (resolved future 1)
[16:11:00.638] resolve() on list ... DONE
[16:11:00.638]    - '...' content: [n=0] 
[16:11:00.638] List of 1
[16:11:00.638]  $ ...: list()
[16:11:00.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.638]  - attr(*, "where")=List of 1
[16:11:00.638]   ..$ ...:<environment: 0x561e8a6d1598> 
[16:11:00.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.638]  - attr(*, "resolved")= logi TRUE
[16:11:00.638]  - attr(*, "total_size")= num NA
[16:11:00.641]  - Getting '...' globals ... DONE
[16:11:00.641] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.641] List of 8
[16:11:00.641]  $ ...future.FUN:function (x, ...)  
[16:11:00.641]  $ x_FUN        :function (x)  
[16:11:00.641]  $ times        : int 0
[16:11:00.641]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.641]  $ stop_if_not  :function (...)  
[16:11:00.641]  $ dim          : NULL
[16:11:00.641]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:00.641]  $ ...          : list()
[16:11:00.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.641]  - attr(*, "where")=List of 8
[16:11:00.641]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.641]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.641]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.641]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.641]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.641]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.641]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.641]   ..$ ...          :<environment: 0x561e8a6d1598> 
[16:11:00.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.641]  - attr(*, "resolved")= logi FALSE
[16:11:00.641]  - attr(*, "total_size")= num 95472
[16:11:00.648] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.648] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.649] Number of futures (= number of chunks): 2
[16:11:00.649] Launching 2 futures (chunks) ...
[16:11:00.649] Chunk #1 of 2 ...
[16:11:00.649]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.649] getGlobalsAndPackages() ...
[16:11:00.649] Searching for globals...
[16:11:00.649] 
[16:11:00.650] Searching for globals ... DONE
[16:11:00.650] - globals: [0] <none>
[16:11:00.650] getGlobalsAndPackages() ... DONE
[16:11:00.650]    + additional globals found: [n=0] 
[16:11:00.650]    + additional namespaces needed: [n=0] 
[16:11:00.650]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.650]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:00.650]  - seeds: <none>
[16:11:00.650] getGlobalsAndPackages() ...
[16:11:00.650] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.651] Resolving globals: FALSE
[16:11:00.651] Tweak future expression to call with '...' arguments ...
[16:11:00.651] {
[16:11:00.651]     do.call(function(...) {
[16:11:00.651]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.651]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.651]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.651]             on.exit(options(oopts), add = TRUE)
[16:11:00.651]         }
[16:11:00.651]         {
[16:11:00.651]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.651]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.651]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.651]             })
[16:11:00.651]         }
[16:11:00.651]     }, args = future.call.arguments)
[16:11:00.651] }
[16:11:00.651] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.651] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.652] - packages: [1] ‘future.apply’
[16:11:00.652] getGlobalsAndPackages() ... DONE
[16:11:00.652] run() for ‘Future’ ...
[16:11:00.652] - state: ‘created’
[16:11:00.652] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:00.656] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.656] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:00.656]   - Field: ‘label’
[16:11:00.656]   - Field: ‘local’
[16:11:00.656]   - Field: ‘owner’
[16:11:00.656]   - Field: ‘envir’
[16:11:00.657]   - Field: ‘workers’
[16:11:00.657]   - Field: ‘packages’
[16:11:00.657]   - Field: ‘gc’
[16:11:00.657]   - Field: ‘job’
[16:11:00.657]   - Field: ‘conditions’
[16:11:00.657]   - Field: ‘expr’
[16:11:00.657]   - Field: ‘uuid’
[16:11:00.657]   - Field: ‘seed’
[16:11:00.657]   - Field: ‘version’
[16:11:00.657]   - Field: ‘result’
[16:11:00.658]   - Field: ‘asynchronous’
[16:11:00.658]   - Field: ‘calls’
[16:11:00.658]   - Field: ‘globals’
[16:11:00.658]   - Field: ‘stdout’
[16:11:00.658]   - Field: ‘earlySignal’
[16:11:00.658]   - Field: ‘lazy’
[16:11:00.658]   - Field: ‘state’
[16:11:00.658] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:00.658] - Launch lazy future ...
[16:11:00.659] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.659] Packages needed by future strategies (n = 0): <none>
[16:11:00.659] {
[16:11:00.659]     {
[16:11:00.659]         {
[16:11:00.659]             ...future.startTime <- base::Sys.time()
[16:11:00.659]             {
[16:11:00.659]                 {
[16:11:00.659]                   {
[16:11:00.659]                     {
[16:11:00.659]                       {
[16:11:00.659]                         base::local({
[16:11:00.659]                           has_future <- base::requireNamespace("future", 
[16:11:00.659]                             quietly = TRUE)
[16:11:00.659]                           if (has_future) {
[16:11:00.659]                             ns <- base::getNamespace("future")
[16:11:00.659]                             version <- ns[[".package"]][["version"]]
[16:11:00.659]                             if (is.null(version)) 
[16:11:00.659]                               version <- utils::packageVersion("future")
[16:11:00.659]                           }
[16:11:00.659]                           else {
[16:11:00.659]                             version <- NULL
[16:11:00.659]                           }
[16:11:00.659]                           if (!has_future || version < "1.8.0") {
[16:11:00.659]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.659]                               "", base::R.version$version.string), 
[16:11:00.659]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:00.659]                                 base::R.version$platform, 8 * 
[16:11:00.659]                                   base::.Machine$sizeof.pointer), 
[16:11:00.659]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.659]                                 "release", "version")], collapse = " "), 
[16:11:00.659]                               hostname = base::Sys.info()[["nodename"]])
[16:11:00.659]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.659]                               info)
[16:11:00.659]                             info <- base::paste(info, collapse = "; ")
[16:11:00.659]                             if (!has_future) {
[16:11:00.659]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.659]                                 info)
[16:11:00.659]                             }
[16:11:00.659]                             else {
[16:11:00.659]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.659]                                 info, version)
[16:11:00.659]                             }
[16:11:00.659]                             base::stop(msg)
[16:11:00.659]                           }
[16:11:00.659]                         })
[16:11:00.659]                       }
[16:11:00.659]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:00.659]                       base::options(mc.cores = 1L)
[16:11:00.659]                     }
[16:11:00.659]                     base::local({
[16:11:00.659]                       for (pkg in "future.apply") {
[16:11:00.659]                         base::loadNamespace(pkg)
[16:11:00.659]                         base::library(pkg, character.only = TRUE)
[16:11:00.659]                       }
[16:11:00.659]                     })
[16:11:00.659]                   }
[16:11:00.659]                   options(future.plan = NULL)
[16:11:00.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.659]                 }
[16:11:00.659]                 ...future.workdir <- getwd()
[16:11:00.659]             }
[16:11:00.659]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.659]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.659]         }
[16:11:00.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.659]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:00.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.659]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.659]             base::names(...future.oldOptions))
[16:11:00.659]     }
[16:11:00.659]     if (FALSE) {
[16:11:00.659]     }
[16:11:00.659]     else {
[16:11:00.659]         if (TRUE) {
[16:11:00.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.659]                 open = "w")
[16:11:00.659]         }
[16:11:00.659]         else {
[16:11:00.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.659]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.659]         }
[16:11:00.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.659]             base::sink(type = "output", split = FALSE)
[16:11:00.659]             base::close(...future.stdout)
[16:11:00.659]         }, add = TRUE)
[16:11:00.659]     }
[16:11:00.659]     ...future.frame <- base::sys.nframe()
[16:11:00.659]     ...future.conditions <- base::list()
[16:11:00.659]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.659]     if (FALSE) {
[16:11:00.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.659]     }
[16:11:00.659]     ...future.result <- base::tryCatch({
[16:11:00.659]         base::withCallingHandlers({
[16:11:00.659]             ...future.value <- base::withVisible(base::local({
[16:11:00.659]                 withCallingHandlers({
[16:11:00.659]                   {
[16:11:00.659]                     do.call(function(...) {
[16:11:00.659]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.659]                       if (!identical(...future.globals.maxSize.org, 
[16:11:00.659]                         ...future.globals.maxSize)) {
[16:11:00.659]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.659]                         on.exit(options(oopts), add = TRUE)
[16:11:00.659]                       }
[16:11:00.659]                       {
[16:11:00.659]                         lapply(seq_along(...future.elements_ii), 
[16:11:00.659]                           FUN = function(jj) {
[16:11:00.659]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.659]                             ...future.FUN(...future.X_jj, ...)
[16:11:00.659]                           })
[16:11:00.659]                       }
[16:11:00.659]                     }, args = future.call.arguments)
[16:11:00.659]                   }
[16:11:00.659]                 }, immediateCondition = function(cond) {
[16:11:00.659]                   save_rds <- function (object, pathname, ...) 
[16:11:00.659]                   {
[16:11:00.659]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:00.659]                     if (file_test("-f", pathname_tmp)) {
[16:11:00.659]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.659]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:00.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.659]                         fi_tmp[["mtime"]])
[16:11:00.659]                     }
[16:11:00.659]                     tryCatch({
[16:11:00.659]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:00.659]                     }, error = function(ex) {
[16:11:00.659]                       msg <- conditionMessage(ex)
[16:11:00.659]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.659]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:00.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.659]                         fi_tmp[["mtime"]], msg)
[16:11:00.659]                       ex$message <- msg
[16:11:00.659]                       stop(ex)
[16:11:00.659]                     })
[16:11:00.659]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:00.659]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:00.659]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:00.659]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.659]                       fi <- file.info(pathname)
[16:11:00.659]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:00.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.659]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:00.659]                         fi[["size"]], fi[["mtime"]])
[16:11:00.659]                       stop(msg)
[16:11:00.659]                     }
[16:11:00.659]                     invisible(pathname)
[16:11:00.659]                   }
[16:11:00.659]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:00.659]                     rootPath = tempdir()) 
[16:11:00.659]                   {
[16:11:00.659]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:00.659]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:00.659]                       tmpdir = path, fileext = ".rds")
[16:11:00.659]                     save_rds(obj, file)
[16:11:00.659]                   }
[16:11:00.659]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:00.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.659]                   {
[16:11:00.659]                     inherits <- base::inherits
[16:11:00.659]                     invokeRestart <- base::invokeRestart
[16:11:00.659]                     is.null <- base::is.null
[16:11:00.659]                     muffled <- FALSE
[16:11:00.659]                     if (inherits(cond, "message")) {
[16:11:00.659]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:00.659]                       if (muffled) 
[16:11:00.659]                         invokeRestart("muffleMessage")
[16:11:00.659]                     }
[16:11:00.659]                     else if (inherits(cond, "warning")) {
[16:11:00.659]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:00.659]                       if (muffled) 
[16:11:00.659]                         invokeRestart("muffleWarning")
[16:11:00.659]                     }
[16:11:00.659]                     else if (inherits(cond, "condition")) {
[16:11:00.659]                       if (!is.null(pattern)) {
[16:11:00.659]                         computeRestarts <- base::computeRestarts
[16:11:00.659]                         grepl <- base::grepl
[16:11:00.659]                         restarts <- computeRestarts(cond)
[16:11:00.659]                         for (restart in restarts) {
[16:11:00.659]                           name <- restart$name
[16:11:00.659]                           if (is.null(name)) 
[16:11:00.659]                             next
[16:11:00.659]                           if (!grepl(pattern, name)) 
[16:11:00.659]                             next
[16:11:00.659]                           invokeRestart(restart)
[16:11:00.659]                           muffled <- TRUE
[16:11:00.659]                           break
[16:11:00.659]                         }
[16:11:00.659]                       }
[16:11:00.659]                     }
[16:11:00.659]                     invisible(muffled)
[16:11:00.659]                   }
[16:11:00.659]                   muffleCondition(cond)
[16:11:00.659]                 })
[16:11:00.659]             }))
[16:11:00.659]             future::FutureResult(value = ...future.value$value, 
[16:11:00.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.659]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.659]                     ...future.globalenv.names))
[16:11:00.659]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.659]         }, condition = base::local({
[16:11:00.659]             c <- base::c
[16:11:00.659]             inherits <- base::inherits
[16:11:00.659]             invokeRestart <- base::invokeRestart
[16:11:00.659]             length <- base::length
[16:11:00.659]             list <- base::list
[16:11:00.659]             seq.int <- base::seq.int
[16:11:00.659]             signalCondition <- base::signalCondition
[16:11:00.659]             sys.calls <- base::sys.calls
[16:11:00.659]             `[[` <- base::`[[`
[16:11:00.659]             `+` <- base::`+`
[16:11:00.659]             `<<-` <- base::`<<-`
[16:11:00.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.659]                   3L)]
[16:11:00.659]             }
[16:11:00.659]             function(cond) {
[16:11:00.659]                 is_error <- inherits(cond, "error")
[16:11:00.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.659]                   NULL)
[16:11:00.659]                 if (is_error) {
[16:11:00.659]                   sessionInformation <- function() {
[16:11:00.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.659]                       search = base::search(), system = base::Sys.info())
[16:11:00.659]                   }
[16:11:00.659]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.659]                     cond$call), session = sessionInformation(), 
[16:11:00.659]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.659]                   signalCondition(cond)
[16:11:00.659]                 }
[16:11:00.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.659]                 "immediateCondition"))) {
[16:11:00.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.659]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.659]                   if (TRUE && !signal) {
[16:11:00.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.659]                     {
[16:11:00.659]                       inherits <- base::inherits
[16:11:00.659]                       invokeRestart <- base::invokeRestart
[16:11:00.659]                       is.null <- base::is.null
[16:11:00.659]                       muffled <- FALSE
[16:11:00.659]                       if (inherits(cond, "message")) {
[16:11:00.659]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.659]                         if (muffled) 
[16:11:00.659]                           invokeRestart("muffleMessage")
[16:11:00.659]                       }
[16:11:00.659]                       else if (inherits(cond, "warning")) {
[16:11:00.659]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.659]                         if (muffled) 
[16:11:00.659]                           invokeRestart("muffleWarning")
[16:11:00.659]                       }
[16:11:00.659]                       else if (inherits(cond, "condition")) {
[16:11:00.659]                         if (!is.null(pattern)) {
[16:11:00.659]                           computeRestarts <- base::computeRestarts
[16:11:00.659]                           grepl <- base::grepl
[16:11:00.659]                           restarts <- computeRestarts(cond)
[16:11:00.659]                           for (restart in restarts) {
[16:11:00.659]                             name <- restart$name
[16:11:00.659]                             if (is.null(name)) 
[16:11:00.659]                               next
[16:11:00.659]                             if (!grepl(pattern, name)) 
[16:11:00.659]                               next
[16:11:00.659]                             invokeRestart(restart)
[16:11:00.659]                             muffled <- TRUE
[16:11:00.659]                             break
[16:11:00.659]                           }
[16:11:00.659]                         }
[16:11:00.659]                       }
[16:11:00.659]                       invisible(muffled)
[16:11:00.659]                     }
[16:11:00.659]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.659]                   }
[16:11:00.659]                 }
[16:11:00.659]                 else {
[16:11:00.659]                   if (TRUE) {
[16:11:00.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.659]                     {
[16:11:00.659]                       inherits <- base::inherits
[16:11:00.659]                       invokeRestart <- base::invokeRestart
[16:11:00.659]                       is.null <- base::is.null
[16:11:00.659]                       muffled <- FALSE
[16:11:00.659]                       if (inherits(cond, "message")) {
[16:11:00.659]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.659]                         if (muffled) 
[16:11:00.659]                           invokeRestart("muffleMessage")
[16:11:00.659]                       }
[16:11:00.659]                       else if (inherits(cond, "warning")) {
[16:11:00.659]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.659]                         if (muffled) 
[16:11:00.659]                           invokeRestart("muffleWarning")
[16:11:00.659]                       }
[16:11:00.659]                       else if (inherits(cond, "condition")) {
[16:11:00.659]                         if (!is.null(pattern)) {
[16:11:00.659]                           computeRestarts <- base::computeRestarts
[16:11:00.659]                           grepl <- base::grepl
[16:11:00.659]                           restarts <- computeRestarts(cond)
[16:11:00.659]                           for (restart in restarts) {
[16:11:00.659]                             name <- restart$name
[16:11:00.659]                             if (is.null(name)) 
[16:11:00.659]                               next
[16:11:00.659]                             if (!grepl(pattern, name)) 
[16:11:00.659]                               next
[16:11:00.659]                             invokeRestart(restart)
[16:11:00.659]                             muffled <- TRUE
[16:11:00.659]                             break
[16:11:00.659]                           }
[16:11:00.659]                         }
[16:11:00.659]                       }
[16:11:00.659]                       invisible(muffled)
[16:11:00.659]                     }
[16:11:00.659]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.659]                   }
[16:11:00.659]                 }
[16:11:00.659]             }
[16:11:00.659]         }))
[16:11:00.659]     }, error = function(ex) {
[16:11:00.659]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.659]                 ...future.rng), started = ...future.startTime, 
[16:11:00.659]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.659]             version = "1.8"), class = "FutureResult")
[16:11:00.659]     }, finally = {
[16:11:00.659]         if (!identical(...future.workdir, getwd())) 
[16:11:00.659]             setwd(...future.workdir)
[16:11:00.659]         {
[16:11:00.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.659]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.659]             }
[16:11:00.659]             base::options(...future.oldOptions)
[16:11:00.659]             if (.Platform$OS.type == "windows") {
[16:11:00.659]                 old_names <- names(...future.oldEnvVars)
[16:11:00.659]                 envs <- base::Sys.getenv()
[16:11:00.659]                 names <- names(envs)
[16:11:00.659]                 common <- intersect(names, old_names)
[16:11:00.659]                 added <- setdiff(names, old_names)
[16:11:00.659]                 removed <- setdiff(old_names, names)
[16:11:00.659]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.659]                   envs[common]]
[16:11:00.659]                 NAMES <- toupper(changed)
[16:11:00.659]                 args <- list()
[16:11:00.659]                 for (kk in seq_along(NAMES)) {
[16:11:00.659]                   name <- changed[[kk]]
[16:11:00.659]                   NAME <- NAMES[[kk]]
[16:11:00.659]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.659]                     next
[16:11:00.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.659]                 }
[16:11:00.659]                 NAMES <- toupper(added)
[16:11:00.659]                 for (kk in seq_along(NAMES)) {
[16:11:00.659]                   name <- added[[kk]]
[16:11:00.659]                   NAME <- NAMES[[kk]]
[16:11:00.659]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.659]                     next
[16:11:00.659]                   args[[name]] <- ""
[16:11:00.659]                 }
[16:11:00.659]                 NAMES <- toupper(removed)
[16:11:00.659]                 for (kk in seq_along(NAMES)) {
[16:11:00.659]                   name <- removed[[kk]]
[16:11:00.659]                   NAME <- NAMES[[kk]]
[16:11:00.659]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.659]                     next
[16:11:00.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.659]                 }
[16:11:00.659]                 if (length(args) > 0) 
[16:11:00.659]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.659]             }
[16:11:00.659]             else {
[16:11:00.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.659]             }
[16:11:00.659]             {
[16:11:00.659]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.659]                   0L) {
[16:11:00.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.659]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.659]                   base::options(opts)
[16:11:00.659]                 }
[16:11:00.659]                 {
[16:11:00.659]                   {
[16:11:00.659]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:00.659]                     NULL
[16:11:00.659]                   }
[16:11:00.659]                   options(future.plan = NULL)
[16:11:00.659]                   if (is.na(NA_character_)) 
[16:11:00.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.659]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:00.659]                     envir = parent.frame()) 
[16:11:00.659]                   {
[16:11:00.659]                     default_workers <- missing(workers)
[16:11:00.659]                     if (is.function(workers)) 
[16:11:00.659]                       workers <- workers()
[16:11:00.659]                     workers <- structure(as.integer(workers), 
[16:11:00.659]                       class = class(workers))
[16:11:00.659]                     stop_if_not(is.finite(workers), workers >= 
[16:11:00.659]                       1L)
[16:11:00.659]                     if ((workers == 1L && !inherits(workers, 
[16:11:00.659]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:00.659]                       if (default_workers) 
[16:11:00.659]                         supportsMulticore(warn = TRUE)
[16:11:00.659]                       return(sequential(..., envir = envir))
[16:11:00.659]                     }
[16:11:00.659]                     oopts <- options(mc.cores = workers)
[16:11:00.659]                     on.exit(options(oopts))
[16:11:00.659]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:00.659]                       envir = envir)
[16:11:00.659]                     if (!future$lazy) 
[16:11:00.659]                       future <- run(future)
[16:11:00.659]                     invisible(future)
[16:11:00.659]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.659]                 }
[16:11:00.659]             }
[16:11:00.659]         }
[16:11:00.659]     })
[16:11:00.659]     if (TRUE) {
[16:11:00.659]         base::sink(type = "output", split = FALSE)
[16:11:00.659]         if (TRUE) {
[16:11:00.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.659]         }
[16:11:00.659]         else {
[16:11:00.659]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.659]         }
[16:11:00.659]         base::close(...future.stdout)
[16:11:00.659]         ...future.stdout <- NULL
[16:11:00.659]     }
[16:11:00.659]     ...future.result$conditions <- ...future.conditions
[16:11:00.659]     ...future.result$finished <- base::Sys.time()
[16:11:00.659]     ...future.result
[16:11:00.659] }
[16:11:00.662] assign_globals() ...
[16:11:00.662] List of 11
[16:11:00.662]  $ ...future.FUN            :function (x, ...)  
[16:11:00.662]  $ x_FUN                    :function (x)  
[16:11:00.662]  $ times                    : int 0
[16:11:00.662]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.662]  $ stop_if_not              :function (...)  
[16:11:00.662]  $ dim                      : NULL
[16:11:00.662]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.662]  $ future.call.arguments    : list()
[16:11:00.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.662]  $ ...future.elements_ii    :List of 5
[16:11:00.662]   ..$ : int 1
[16:11:00.662]   ..$ : int 2
[16:11:00.662]   ..$ : int 3
[16:11:00.662]   ..$ : int 4
[16:11:00.662]   ..$ : int 5
[16:11:00.662]  $ ...future.seeds_ii       : NULL
[16:11:00.662]  $ ...future.globals.maxSize: NULL
[16:11:00.662]  - attr(*, "resolved")= logi FALSE
[16:11:00.662]  - attr(*, "total_size")= num 95472
[16:11:00.662]  - attr(*, "where")=List of 11
[16:11:00.662]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.662]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.662]  - attr(*, "already-done")= logi TRUE
[16:11:00.672] - copied ‘...future.FUN’ to environment
[16:11:00.672] - reassign environment for ‘x_FUN’
[16:11:00.672] - copied ‘x_FUN’ to environment
[16:11:00.672] - copied ‘times’ to environment
[16:11:00.672] - copied ‘stopf’ to environment
[16:11:00.673] - copied ‘stop_if_not’ to environment
[16:11:00.673] - copied ‘dim’ to environment
[16:11:00.673] - copied ‘valid_types’ to environment
[16:11:00.673] - copied ‘future.call.arguments’ to environment
[16:11:00.673] - copied ‘...future.elements_ii’ to environment
[16:11:00.673] - copied ‘...future.seeds_ii’ to environment
[16:11:00.673] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.673] assign_globals() ... done
[16:11:00.673] requestCore(): workers = 2
[16:11:00.676] MulticoreFuture started
[16:11:00.677] - Launch lazy future ... done
[16:11:00.677] run() for ‘MulticoreFuture’ ... done
[16:11:00.678] Created future:
[16:11:00.678] plan(): Setting new future strategy stack:
[16:11:00.678] List of future strategies:
[16:11:00.678] 1. sequential:
[16:11:00.678]    - args: function (..., envir = parent.frame())
[16:11:00.678]    - tweaked: FALSE
[16:11:00.678]    - call: NULL
[16:11:00.680] plan(): nbrOfWorkers() = 1
[16:11:00.682] plan(): Setting new future strategy stack:
[16:11:00.682] List of future strategies:
[16:11:00.682] 1. multicore:
[16:11:00.682]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.682]    - tweaked: FALSE
[16:11:00.682]    - call: plan(strategy)
[16:11:00.687] plan(): nbrOfWorkers() = 2
[16:11:00.678] MulticoreFuture:
[16:11:00.678] Label: ‘future_vapply-1’
[16:11:00.678] Expression:
[16:11:00.678] {
[16:11:00.678]     do.call(function(...) {
[16:11:00.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.678]             on.exit(options(oopts), add = TRUE)
[16:11:00.678]         }
[16:11:00.678]         {
[16:11:00.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.678]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.678]             })
[16:11:00.678]         }
[16:11:00.678]     }, args = future.call.arguments)
[16:11:00.678] }
[16:11:00.678] Lazy evaluation: FALSE
[16:11:00.678] Asynchronous evaluation: TRUE
[16:11:00.678] Local evaluation: TRUE
[16:11:00.678] Environment: R_GlobalEnv
[16:11:00.678] Capture standard output: TRUE
[16:11:00.678] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.678] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.678] Packages: 1 packages (‘future.apply’)
[16:11:00.678] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.678] Resolved: TRUE
[16:11:00.678] Value: <not collected>
[16:11:00.678] Conditions captured: <none>
[16:11:00.678] Early signaling: FALSE
[16:11:00.678] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.678] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.689] Chunk #1 of 2 ... DONE
[16:11:00.689] Chunk #2 of 2 ...
[16:11:00.689]  - Finding globals in 'X' for chunk #2 ...
[16:11:00.689] getGlobalsAndPackages() ...
[16:11:00.689] Searching for globals...
[16:11:00.690] 
[16:11:00.690] Searching for globals ... DONE
[16:11:00.690] - globals: [0] <none>
[16:11:00.690] getGlobalsAndPackages() ... DONE
[16:11:00.690]    + additional globals found: [n=0] 
[16:11:00.690]    + additional namespaces needed: [n=0] 
[16:11:00.691]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:00.691]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:00.691]  - seeds: <none>
[16:11:00.691] getGlobalsAndPackages() ...
[16:11:00.692] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.692] Resolving globals: FALSE
[16:11:00.692] Tweak future expression to call with '...' arguments ...
[16:11:00.692] {
[16:11:00.692]     do.call(function(...) {
[16:11:00.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.692]             on.exit(options(oopts), add = TRUE)
[16:11:00.692]         }
[16:11:00.692]         {
[16:11:00.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.692]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.692]             })
[16:11:00.692]         }
[16:11:00.692]     }, args = future.call.arguments)
[16:11:00.692] }
[16:11:00.693] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.694] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.694] - packages: [1] ‘future.apply’
[16:11:00.694] getGlobalsAndPackages() ... DONE
[16:11:00.695] run() for ‘Future’ ...
[16:11:00.695] - state: ‘created’
[16:11:00.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:00.700] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:00.700]   - Field: ‘label’
[16:11:00.700]   - Field: ‘local’
[16:11:00.700]   - Field: ‘owner’
[16:11:00.700]   - Field: ‘envir’
[16:11:00.701]   - Field: ‘workers’
[16:11:00.701]   - Field: ‘packages’
[16:11:00.701]   - Field: ‘gc’
[16:11:00.701]   - Field: ‘job’
[16:11:00.701]   - Field: ‘conditions’
[16:11:00.701]   - Field: ‘expr’
[16:11:00.701]   - Field: ‘uuid’
[16:11:00.702]   - Field: ‘seed’
[16:11:00.702]   - Field: ‘version’
[16:11:00.702]   - Field: ‘result’
[16:11:00.702]   - Field: ‘asynchronous’
[16:11:00.702]   - Field: ‘calls’
[16:11:00.702]   - Field: ‘globals’
[16:11:00.702]   - Field: ‘stdout’
[16:11:00.703]   - Field: ‘earlySignal’
[16:11:00.703]   - Field: ‘lazy’
[16:11:00.703]   - Field: ‘state’
[16:11:00.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:00.703] - Launch lazy future ...
[16:11:00.704] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.704] Packages needed by future strategies (n = 0): <none>
[16:11:00.705] {
[16:11:00.705]     {
[16:11:00.705]         {
[16:11:00.705]             ...future.startTime <- base::Sys.time()
[16:11:00.705]             {
[16:11:00.705]                 {
[16:11:00.705]                   {
[16:11:00.705]                     {
[16:11:00.705]                       {
[16:11:00.705]                         base::local({
[16:11:00.705]                           has_future <- base::requireNamespace("future", 
[16:11:00.705]                             quietly = TRUE)
[16:11:00.705]                           if (has_future) {
[16:11:00.705]                             ns <- base::getNamespace("future")
[16:11:00.705]                             version <- ns[[".package"]][["version"]]
[16:11:00.705]                             if (is.null(version)) 
[16:11:00.705]                               version <- utils::packageVersion("future")
[16:11:00.705]                           }
[16:11:00.705]                           else {
[16:11:00.705]                             version <- NULL
[16:11:00.705]                           }
[16:11:00.705]                           if (!has_future || version < "1.8.0") {
[16:11:00.705]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.705]                               "", base::R.version$version.string), 
[16:11:00.705]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:00.705]                                 base::R.version$platform, 8 * 
[16:11:00.705]                                   base::.Machine$sizeof.pointer), 
[16:11:00.705]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.705]                                 "release", "version")], collapse = " "), 
[16:11:00.705]                               hostname = base::Sys.info()[["nodename"]])
[16:11:00.705]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.705]                               info)
[16:11:00.705]                             info <- base::paste(info, collapse = "; ")
[16:11:00.705]                             if (!has_future) {
[16:11:00.705]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.705]                                 info)
[16:11:00.705]                             }
[16:11:00.705]                             else {
[16:11:00.705]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.705]                                 info, version)
[16:11:00.705]                             }
[16:11:00.705]                             base::stop(msg)
[16:11:00.705]                           }
[16:11:00.705]                         })
[16:11:00.705]                       }
[16:11:00.705]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:00.705]                       base::options(mc.cores = 1L)
[16:11:00.705]                     }
[16:11:00.705]                     base::local({
[16:11:00.705]                       for (pkg in "future.apply") {
[16:11:00.705]                         base::loadNamespace(pkg)
[16:11:00.705]                         base::library(pkg, character.only = TRUE)
[16:11:00.705]                       }
[16:11:00.705]                     })
[16:11:00.705]                   }
[16:11:00.705]                   options(future.plan = NULL)
[16:11:00.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.705]                 }
[16:11:00.705]                 ...future.workdir <- getwd()
[16:11:00.705]             }
[16:11:00.705]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.705]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.705]         }
[16:11:00.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.705]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:00.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.705]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.705]             base::names(...future.oldOptions))
[16:11:00.705]     }
[16:11:00.705]     if (FALSE) {
[16:11:00.705]     }
[16:11:00.705]     else {
[16:11:00.705]         if (TRUE) {
[16:11:00.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.705]                 open = "w")
[16:11:00.705]         }
[16:11:00.705]         else {
[16:11:00.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.705]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.705]         }
[16:11:00.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.705]             base::sink(type = "output", split = FALSE)
[16:11:00.705]             base::close(...future.stdout)
[16:11:00.705]         }, add = TRUE)
[16:11:00.705]     }
[16:11:00.705]     ...future.frame <- base::sys.nframe()
[16:11:00.705]     ...future.conditions <- base::list()
[16:11:00.705]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.705]     if (FALSE) {
[16:11:00.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.705]     }
[16:11:00.705]     ...future.result <- base::tryCatch({
[16:11:00.705]         base::withCallingHandlers({
[16:11:00.705]             ...future.value <- base::withVisible(base::local({
[16:11:00.705]                 withCallingHandlers({
[16:11:00.705]                   {
[16:11:00.705]                     do.call(function(...) {
[16:11:00.705]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.705]                       if (!identical(...future.globals.maxSize.org, 
[16:11:00.705]                         ...future.globals.maxSize)) {
[16:11:00.705]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.705]                         on.exit(options(oopts), add = TRUE)
[16:11:00.705]                       }
[16:11:00.705]                       {
[16:11:00.705]                         lapply(seq_along(...future.elements_ii), 
[16:11:00.705]                           FUN = function(jj) {
[16:11:00.705]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.705]                             ...future.FUN(...future.X_jj, ...)
[16:11:00.705]                           })
[16:11:00.705]                       }
[16:11:00.705]                     }, args = future.call.arguments)
[16:11:00.705]                   }
[16:11:00.705]                 }, immediateCondition = function(cond) {
[16:11:00.705]                   save_rds <- function (object, pathname, ...) 
[16:11:00.705]                   {
[16:11:00.705]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:00.705]                     if (file_test("-f", pathname_tmp)) {
[16:11:00.705]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.705]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:00.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.705]                         fi_tmp[["mtime"]])
[16:11:00.705]                     }
[16:11:00.705]                     tryCatch({
[16:11:00.705]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:00.705]                     }, error = function(ex) {
[16:11:00.705]                       msg <- conditionMessage(ex)
[16:11:00.705]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.705]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:00.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.705]                         fi_tmp[["mtime"]], msg)
[16:11:00.705]                       ex$message <- msg
[16:11:00.705]                       stop(ex)
[16:11:00.705]                     })
[16:11:00.705]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:00.705]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:00.705]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:00.705]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.705]                       fi <- file.info(pathname)
[16:11:00.705]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:00.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.705]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:00.705]                         fi[["size"]], fi[["mtime"]])
[16:11:00.705]                       stop(msg)
[16:11:00.705]                     }
[16:11:00.705]                     invisible(pathname)
[16:11:00.705]                   }
[16:11:00.705]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:00.705]                     rootPath = tempdir()) 
[16:11:00.705]                   {
[16:11:00.705]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:00.705]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:00.705]                       tmpdir = path, fileext = ".rds")
[16:11:00.705]                     save_rds(obj, file)
[16:11:00.705]                   }
[16:11:00.705]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:00.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.705]                   {
[16:11:00.705]                     inherits <- base::inherits
[16:11:00.705]                     invokeRestart <- base::invokeRestart
[16:11:00.705]                     is.null <- base::is.null
[16:11:00.705]                     muffled <- FALSE
[16:11:00.705]                     if (inherits(cond, "message")) {
[16:11:00.705]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:00.705]                       if (muffled) 
[16:11:00.705]                         invokeRestart("muffleMessage")
[16:11:00.705]                     }
[16:11:00.705]                     else if (inherits(cond, "warning")) {
[16:11:00.705]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:00.705]                       if (muffled) 
[16:11:00.705]                         invokeRestart("muffleWarning")
[16:11:00.705]                     }
[16:11:00.705]                     else if (inherits(cond, "condition")) {
[16:11:00.705]                       if (!is.null(pattern)) {
[16:11:00.705]                         computeRestarts <- base::computeRestarts
[16:11:00.705]                         grepl <- base::grepl
[16:11:00.705]                         restarts <- computeRestarts(cond)
[16:11:00.705]                         for (restart in restarts) {
[16:11:00.705]                           name <- restart$name
[16:11:00.705]                           if (is.null(name)) 
[16:11:00.705]                             next
[16:11:00.705]                           if (!grepl(pattern, name)) 
[16:11:00.705]                             next
[16:11:00.705]                           invokeRestart(restart)
[16:11:00.705]                           muffled <- TRUE
[16:11:00.705]                           break
[16:11:00.705]                         }
[16:11:00.705]                       }
[16:11:00.705]                     }
[16:11:00.705]                     invisible(muffled)
[16:11:00.705]                   }
[16:11:00.705]                   muffleCondition(cond)
[16:11:00.705]                 })
[16:11:00.705]             }))
[16:11:00.705]             future::FutureResult(value = ...future.value$value, 
[16:11:00.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.705]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.705]                     ...future.globalenv.names))
[16:11:00.705]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.705]         }, condition = base::local({
[16:11:00.705]             c <- base::c
[16:11:00.705]             inherits <- base::inherits
[16:11:00.705]             invokeRestart <- base::invokeRestart
[16:11:00.705]             length <- base::length
[16:11:00.705]             list <- base::list
[16:11:00.705]             seq.int <- base::seq.int
[16:11:00.705]             signalCondition <- base::signalCondition
[16:11:00.705]             sys.calls <- base::sys.calls
[16:11:00.705]             `[[` <- base::`[[`
[16:11:00.705]             `+` <- base::`+`
[16:11:00.705]             `<<-` <- base::`<<-`
[16:11:00.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.705]                   3L)]
[16:11:00.705]             }
[16:11:00.705]             function(cond) {
[16:11:00.705]                 is_error <- inherits(cond, "error")
[16:11:00.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.705]                   NULL)
[16:11:00.705]                 if (is_error) {
[16:11:00.705]                   sessionInformation <- function() {
[16:11:00.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.705]                       search = base::search(), system = base::Sys.info())
[16:11:00.705]                   }
[16:11:00.705]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.705]                     cond$call), session = sessionInformation(), 
[16:11:00.705]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.705]                   signalCondition(cond)
[16:11:00.705]                 }
[16:11:00.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.705]                 "immediateCondition"))) {
[16:11:00.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.705]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.705]                   if (TRUE && !signal) {
[16:11:00.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.705]                     {
[16:11:00.705]                       inherits <- base::inherits
[16:11:00.705]                       invokeRestart <- base::invokeRestart
[16:11:00.705]                       is.null <- base::is.null
[16:11:00.705]                       muffled <- FALSE
[16:11:00.705]                       if (inherits(cond, "message")) {
[16:11:00.705]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.705]                         if (muffled) 
[16:11:00.705]                           invokeRestart("muffleMessage")
[16:11:00.705]                       }
[16:11:00.705]                       else if (inherits(cond, "warning")) {
[16:11:00.705]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.705]                         if (muffled) 
[16:11:00.705]                           invokeRestart("muffleWarning")
[16:11:00.705]                       }
[16:11:00.705]                       else if (inherits(cond, "condition")) {
[16:11:00.705]                         if (!is.null(pattern)) {
[16:11:00.705]                           computeRestarts <- base::computeRestarts
[16:11:00.705]                           grepl <- base::grepl
[16:11:00.705]                           restarts <- computeRestarts(cond)
[16:11:00.705]                           for (restart in restarts) {
[16:11:00.705]                             name <- restart$name
[16:11:00.705]                             if (is.null(name)) 
[16:11:00.705]                               next
[16:11:00.705]                             if (!grepl(pattern, name)) 
[16:11:00.705]                               next
[16:11:00.705]                             invokeRestart(restart)
[16:11:00.705]                             muffled <- TRUE
[16:11:00.705]                             break
[16:11:00.705]                           }
[16:11:00.705]                         }
[16:11:00.705]                       }
[16:11:00.705]                       invisible(muffled)
[16:11:00.705]                     }
[16:11:00.705]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.705]                   }
[16:11:00.705]                 }
[16:11:00.705]                 else {
[16:11:00.705]                   if (TRUE) {
[16:11:00.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.705]                     {
[16:11:00.705]                       inherits <- base::inherits
[16:11:00.705]                       invokeRestart <- base::invokeRestart
[16:11:00.705]                       is.null <- base::is.null
[16:11:00.705]                       muffled <- FALSE
[16:11:00.705]                       if (inherits(cond, "message")) {
[16:11:00.705]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.705]                         if (muffled) 
[16:11:00.705]                           invokeRestart("muffleMessage")
[16:11:00.705]                       }
[16:11:00.705]                       else if (inherits(cond, "warning")) {
[16:11:00.705]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.705]                         if (muffled) 
[16:11:00.705]                           invokeRestart("muffleWarning")
[16:11:00.705]                       }
[16:11:00.705]                       else if (inherits(cond, "condition")) {
[16:11:00.705]                         if (!is.null(pattern)) {
[16:11:00.705]                           computeRestarts <- base::computeRestarts
[16:11:00.705]                           grepl <- base::grepl
[16:11:00.705]                           restarts <- computeRestarts(cond)
[16:11:00.705]                           for (restart in restarts) {
[16:11:00.705]                             name <- restart$name
[16:11:00.705]                             if (is.null(name)) 
[16:11:00.705]                               next
[16:11:00.705]                             if (!grepl(pattern, name)) 
[16:11:00.705]                               next
[16:11:00.705]                             invokeRestart(restart)
[16:11:00.705]                             muffled <- TRUE
[16:11:00.705]                             break
[16:11:00.705]                           }
[16:11:00.705]                         }
[16:11:00.705]                       }
[16:11:00.705]                       invisible(muffled)
[16:11:00.705]                     }
[16:11:00.705]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.705]                   }
[16:11:00.705]                 }
[16:11:00.705]             }
[16:11:00.705]         }))
[16:11:00.705]     }, error = function(ex) {
[16:11:00.705]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.705]                 ...future.rng), started = ...future.startTime, 
[16:11:00.705]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.705]             version = "1.8"), class = "FutureResult")
[16:11:00.705]     }, finally = {
[16:11:00.705]         if (!identical(...future.workdir, getwd())) 
[16:11:00.705]             setwd(...future.workdir)
[16:11:00.705]         {
[16:11:00.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.705]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.705]             }
[16:11:00.705]             base::options(...future.oldOptions)
[16:11:00.705]             if (.Platform$OS.type == "windows") {
[16:11:00.705]                 old_names <- names(...future.oldEnvVars)
[16:11:00.705]                 envs <- base::Sys.getenv()
[16:11:00.705]                 names <- names(envs)
[16:11:00.705]                 common <- intersect(names, old_names)
[16:11:00.705]                 added <- setdiff(names, old_names)
[16:11:00.705]                 removed <- setdiff(old_names, names)
[16:11:00.705]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.705]                   envs[common]]
[16:11:00.705]                 NAMES <- toupper(changed)
[16:11:00.705]                 args <- list()
[16:11:00.705]                 for (kk in seq_along(NAMES)) {
[16:11:00.705]                   name <- changed[[kk]]
[16:11:00.705]                   NAME <- NAMES[[kk]]
[16:11:00.705]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.705]                     next
[16:11:00.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.705]                 }
[16:11:00.705]                 NAMES <- toupper(added)
[16:11:00.705]                 for (kk in seq_along(NAMES)) {
[16:11:00.705]                   name <- added[[kk]]
[16:11:00.705]                   NAME <- NAMES[[kk]]
[16:11:00.705]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.705]                     next
[16:11:00.705]                   args[[name]] <- ""
[16:11:00.705]                 }
[16:11:00.705]                 NAMES <- toupper(removed)
[16:11:00.705]                 for (kk in seq_along(NAMES)) {
[16:11:00.705]                   name <- removed[[kk]]
[16:11:00.705]                   NAME <- NAMES[[kk]]
[16:11:00.705]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.705]                     next
[16:11:00.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.705]                 }
[16:11:00.705]                 if (length(args) > 0) 
[16:11:00.705]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.705]             }
[16:11:00.705]             else {
[16:11:00.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.705]             }
[16:11:00.705]             {
[16:11:00.705]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.705]                   0L) {
[16:11:00.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.705]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.705]                   base::options(opts)
[16:11:00.705]                 }
[16:11:00.705]                 {
[16:11:00.705]                   {
[16:11:00.705]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:00.705]                     NULL
[16:11:00.705]                   }
[16:11:00.705]                   options(future.plan = NULL)
[16:11:00.705]                   if (is.na(NA_character_)) 
[16:11:00.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.705]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:00.705]                     envir = parent.frame()) 
[16:11:00.705]                   {
[16:11:00.705]                     default_workers <- missing(workers)
[16:11:00.705]                     if (is.function(workers)) 
[16:11:00.705]                       workers <- workers()
[16:11:00.705]                     workers <- structure(as.integer(workers), 
[16:11:00.705]                       class = class(workers))
[16:11:00.705]                     stop_if_not(is.finite(workers), workers >= 
[16:11:00.705]                       1L)
[16:11:00.705]                     if ((workers == 1L && !inherits(workers, 
[16:11:00.705]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:00.705]                       if (default_workers) 
[16:11:00.705]                         supportsMulticore(warn = TRUE)
[16:11:00.705]                       return(sequential(..., envir = envir))
[16:11:00.705]                     }
[16:11:00.705]                     oopts <- options(mc.cores = workers)
[16:11:00.705]                     on.exit(options(oopts))
[16:11:00.705]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:00.705]                       envir = envir)
[16:11:00.705]                     if (!future$lazy) 
[16:11:00.705]                       future <- run(future)
[16:11:00.705]                     invisible(future)
[16:11:00.705]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.705]                 }
[16:11:00.705]             }
[16:11:00.705]         }
[16:11:00.705]     })
[16:11:00.705]     if (TRUE) {
[16:11:00.705]         base::sink(type = "output", split = FALSE)
[16:11:00.705]         if (TRUE) {
[16:11:00.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.705]         }
[16:11:00.705]         else {
[16:11:00.705]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.705]         }
[16:11:00.705]         base::close(...future.stdout)
[16:11:00.705]         ...future.stdout <- NULL
[16:11:00.705]     }
[16:11:00.705]     ...future.result$conditions <- ...future.conditions
[16:11:00.705]     ...future.result$finished <- base::Sys.time()
[16:11:00.705]     ...future.result
[16:11:00.705] }
[16:11:00.708] assign_globals() ...
[16:11:00.708] List of 11
[16:11:00.708]  $ ...future.FUN            :function (x, ...)  
[16:11:00.708]  $ x_FUN                    :function (x)  
[16:11:00.708]  $ times                    : int 0
[16:11:00.708]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.708]  $ stop_if_not              :function (...)  
[16:11:00.708]  $ dim                      : NULL
[16:11:00.708]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.708]  $ future.call.arguments    : list()
[16:11:00.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.708]  $ ...future.elements_ii    :List of 5
[16:11:00.708]   ..$ : int 6
[16:11:00.708]   ..$ : int 7
[16:11:00.708]   ..$ : int 8
[16:11:00.708]   ..$ : int 9
[16:11:00.708]   ..$ : int 10
[16:11:00.708]  $ ...future.seeds_ii       : NULL
[16:11:00.708]  $ ...future.globals.maxSize: NULL
[16:11:00.708]  - attr(*, "resolved")= logi FALSE
[16:11:00.708]  - attr(*, "total_size")= num 95472
[16:11:00.708]  - attr(*, "where")=List of 11
[16:11:00.708]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.708]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.708]  - attr(*, "already-done")= logi TRUE
[16:11:00.722] - copied ‘...future.FUN’ to environment
[16:11:00.723] - reassign environment for ‘x_FUN’
[16:11:00.723] - copied ‘x_FUN’ to environment
[16:11:00.723] - copied ‘times’ to environment
[16:11:00.723] - copied ‘stopf’ to environment
[16:11:00.723] - copied ‘stop_if_not’ to environment
[16:11:00.723] - copied ‘dim’ to environment
[16:11:00.723] - copied ‘valid_types’ to environment
[16:11:00.723] - copied ‘future.call.arguments’ to environment
[16:11:00.724] - copied ‘...future.elements_ii’ to environment
[16:11:00.724] - copied ‘...future.seeds_ii’ to environment
[16:11:00.724] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.724] assign_globals() ... done
[16:11:00.724] requestCore(): workers = 2
[16:11:00.726] MulticoreFuture started
[16:11:00.727] - Launch lazy future ... done
[16:11:00.727] run() for ‘MulticoreFuture’ ... done
[16:11:00.727] Created future:
[16:11:00.728] plan(): Setting new future strategy stack:
[16:11:00.728] List of future strategies:
[16:11:00.728] 1. sequential:
[16:11:00.728]    - args: function (..., envir = parent.frame())
[16:11:00.728]    - tweaked: FALSE
[16:11:00.728]    - call: NULL
[16:11:00.729] plan(): nbrOfWorkers() = 1
[16:11:00.731] plan(): Setting new future strategy stack:
[16:11:00.731] List of future strategies:
[16:11:00.731] 1. multicore:
[16:11:00.731]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.731]    - tweaked: FALSE
[16:11:00.731]    - call: plan(strategy)
[16:11:00.738] plan(): nbrOfWorkers() = 2
[16:11:00.728] MulticoreFuture:
[16:11:00.728] Label: ‘future_vapply-2’
[16:11:00.728] Expression:
[16:11:00.728] {
[16:11:00.728]     do.call(function(...) {
[16:11:00.728]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.728]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.728]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.728]             on.exit(options(oopts), add = TRUE)
[16:11:00.728]         }
[16:11:00.728]         {
[16:11:00.728]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.728]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.728]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.728]             })
[16:11:00.728]         }
[16:11:00.728]     }, args = future.call.arguments)
[16:11:00.728] }
[16:11:00.728] Lazy evaluation: FALSE
[16:11:00.728] Asynchronous evaluation: TRUE
[16:11:00.728] Local evaluation: TRUE
[16:11:00.728] Environment: R_GlobalEnv
[16:11:00.728] Capture standard output: TRUE
[16:11:00.728] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.728] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.728] Packages: 1 packages (‘future.apply’)
[16:11:00.728] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.728] Resolved: TRUE
[16:11:00.728] Value: <not collected>
[16:11:00.728] Conditions captured: <none>
[16:11:00.728] Early signaling: FALSE
[16:11:00.728] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.728] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.739] Chunk #2 of 2 ... DONE
[16:11:00.739] Launching 2 futures (chunks) ... DONE
[16:11:00.739] Resolving 2 futures (chunks) ...
[16:11:00.739] resolve() on list ...
[16:11:00.740]  recursive: 0
[16:11:00.740]  length: 2
[16:11:00.740] 
[16:11:00.740] Future #1
[16:11:00.742] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:00.742] - nx: 2
[16:11:00.742] - relay: TRUE
[16:11:00.742] - stdout: TRUE
[16:11:00.742] - signal: TRUE
[16:11:00.742] - resignal: FALSE
[16:11:00.743] - force: TRUE
[16:11:00.743] - relayed: [n=2] FALSE, FALSE
[16:11:00.743] - queued futures: [n=2] FALSE, FALSE
[16:11:00.744]  - until=1
[16:11:00.744]  - relaying element #1
[16:11:00.744] - relayed: [n=2] TRUE, FALSE
[16:11:00.744] - queued futures: [n=2] TRUE, FALSE
[16:11:00.745] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:00.745]  length: 1 (resolved future 1)
[16:11:00.745] Future #2
[16:11:00.746] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:00.747] - nx: 2
[16:11:00.747] - relay: TRUE
[16:11:00.747] - stdout: TRUE
[16:11:00.747] - signal: TRUE
[16:11:00.747] - resignal: FALSE
[16:11:00.747] - force: TRUE
[16:11:00.748] - relayed: [n=2] TRUE, FALSE
[16:11:00.748] - queued futures: [n=2] TRUE, FALSE
[16:11:00.748]  - until=2
[16:11:00.748]  - relaying element #2
[16:11:00.749] - relayed: [n=2] TRUE, TRUE
[16:11:00.749] - queued futures: [n=2] TRUE, TRUE
[16:11:00.749] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:00.749]  length: 0 (resolved future 2)
[16:11:00.749] Relaying remaining futures
[16:11:00.749] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.749] - nx: 2
[16:11:00.750] - relay: TRUE
[16:11:00.750] - stdout: TRUE
[16:11:00.750] - signal: TRUE
[16:11:00.750] - resignal: FALSE
[16:11:00.750] - force: TRUE
[16:11:00.750] - relayed: [n=2] TRUE, TRUE
[16:11:00.750] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:00.750] - relayed: [n=2] TRUE, TRUE
[16:11:00.750] - queued futures: [n=2] TRUE, TRUE
[16:11:00.751] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.751] resolve() on list ... DONE
[16:11:00.751]  - Number of value chunks collected: 2
[16:11:00.751] Resolving 2 futures (chunks) ... DONE
[16:11:00.751] Reducing values from 2 chunks ...
[16:11:00.751]  - Number of values collected after concatenation: 10
[16:11:00.751]  - Number of values expected: 10
[16:11:00.751] Reducing values from 2 chunks ... DONE
[16:11:00.752] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:11:00.753] future_lapply() ...
[16:11:00.759] Number of chunks: 2
[16:11:00.759] getGlobalsAndPackagesXApply() ...
[16:11:00.759]  - future.globals: TRUE
[16:11:00.759] getGlobalsAndPackages() ...
[16:11:00.759] Searching for globals...
[16:11:00.766] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:11:00.766] Searching for globals ... DONE
[16:11:00.766] Resolving globals: FALSE
[16:11:00.767] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:11:00.768] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.768] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.768] - packages: [1] ‘future.apply’
[16:11:00.768] getGlobalsAndPackages() ... DONE
[16:11:00.768]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.769]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.769] Finding globals ... DONE
[16:11:00.769]  - use_args: TRUE
[16:11:00.769]  - Getting '...' globals ...
[16:11:00.769] resolve() on list ...
[16:11:00.769]  recursive: 0
[16:11:00.769]  length: 1
[16:11:00.770]  elements: ‘...’
[16:11:00.770]  length: 0 (resolved future 1)
[16:11:00.770] resolve() on list ... DONE
[16:11:00.770]    - '...' content: [n=0] 
[16:11:00.770] List of 1
[16:11:00.770]  $ ...: list()
[16:11:00.770]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.770]  - attr(*, "where")=List of 1
[16:11:00.770]   ..$ ...:<environment: 0x561e89d096b8> 
[16:11:00.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.770]  - attr(*, "resolved")= logi TRUE
[16:11:00.770]  - attr(*, "total_size")= num NA
[16:11:00.773]  - Getting '...' globals ... DONE
[16:11:00.773] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.773] List of 8
[16:11:00.773]  $ ...future.FUN:function (x, ...)  
[16:11:00.773]  $ x_FUN        :function (x)  
[16:11:00.773]  $ times        : int 0
[16:11:00.773]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.773]  $ stop_if_not  :function (...)  
[16:11:00.773]  $ dim          : NULL
[16:11:00.773]  $ valid_types  : chr [1:2] "logical" "integer"
[16:11:00.773]  $ ...          : list()
[16:11:00.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.773]  - attr(*, "where")=List of 8
[16:11:00.773]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.773]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.773]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.773]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.773]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.773]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.773]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.773]   ..$ ...          :<environment: 0x561e89d096b8> 
[16:11:00.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.773]  - attr(*, "resolved")= logi FALSE
[16:11:00.773]  - attr(*, "total_size")= num 95400
[16:11:00.778] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.778] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.779] Number of futures (= number of chunks): 2
[16:11:00.779] Launching 2 futures (chunks) ...
[16:11:00.779] Chunk #1 of 2 ...
[16:11:00.779]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.779] getGlobalsAndPackages() ...
[16:11:00.779] Searching for globals...
[16:11:00.779] 
[16:11:00.779] Searching for globals ... DONE
[16:11:00.780] - globals: [0] <none>
[16:11:00.780] getGlobalsAndPackages() ... DONE
[16:11:00.780]    + additional globals found: [n=0] 
[16:11:00.780]    + additional namespaces needed: [n=0] 
[16:11:00.780]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.780]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:00.780]  - seeds: <none>
[16:11:00.780] getGlobalsAndPackages() ...
[16:11:00.780] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.780] Resolving globals: FALSE
[16:11:00.781] Tweak future expression to call with '...' arguments ...
[16:11:00.781] {
[16:11:00.781]     do.call(function(...) {
[16:11:00.781]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.781]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.781]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.781]             on.exit(options(oopts), add = TRUE)
[16:11:00.781]         }
[16:11:00.781]         {
[16:11:00.781]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.781]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.781]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.781]             })
[16:11:00.781]         }
[16:11:00.781]     }, args = future.call.arguments)
[16:11:00.781] }
[16:11:00.781] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.781] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.782] - packages: [1] ‘future.apply’
[16:11:00.782] getGlobalsAndPackages() ... DONE
[16:11:00.782] run() for ‘Future’ ...
[16:11:00.782] - state: ‘created’
[16:11:00.782] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:00.786] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:00.786]   - Field: ‘label’
[16:11:00.786]   - Field: ‘local’
[16:11:00.786]   - Field: ‘owner’
[16:11:00.786]   - Field: ‘envir’
[16:11:00.786]   - Field: ‘workers’
[16:11:00.786]   - Field: ‘packages’
[16:11:00.787]   - Field: ‘gc’
[16:11:00.787]   - Field: ‘job’
[16:11:00.787]   - Field: ‘conditions’
[16:11:00.787]   - Field: ‘expr’
[16:11:00.787]   - Field: ‘uuid’
[16:11:00.787]   - Field: ‘seed’
[16:11:00.787]   - Field: ‘version’
[16:11:00.789]   - Field: ‘result’
[16:11:00.789]   - Field: ‘asynchronous’
[16:11:00.789]   - Field: ‘calls’
[16:11:00.789]   - Field: ‘globals’
[16:11:00.789]   - Field: ‘stdout’
[16:11:00.789]   - Field: ‘earlySignal’
[16:11:00.789]   - Field: ‘lazy’
[16:11:00.790]   - Field: ‘state’
[16:11:00.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:00.790] - Launch lazy future ...
[16:11:00.790] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.790] Packages needed by future strategies (n = 0): <none>
[16:11:00.791] {
[16:11:00.791]     {
[16:11:00.791]         {
[16:11:00.791]             ...future.startTime <- base::Sys.time()
[16:11:00.791]             {
[16:11:00.791]                 {
[16:11:00.791]                   {
[16:11:00.791]                     {
[16:11:00.791]                       {
[16:11:00.791]                         base::local({
[16:11:00.791]                           has_future <- base::requireNamespace("future", 
[16:11:00.791]                             quietly = TRUE)
[16:11:00.791]                           if (has_future) {
[16:11:00.791]                             ns <- base::getNamespace("future")
[16:11:00.791]                             version <- ns[[".package"]][["version"]]
[16:11:00.791]                             if (is.null(version)) 
[16:11:00.791]                               version <- utils::packageVersion("future")
[16:11:00.791]                           }
[16:11:00.791]                           else {
[16:11:00.791]                             version <- NULL
[16:11:00.791]                           }
[16:11:00.791]                           if (!has_future || version < "1.8.0") {
[16:11:00.791]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.791]                               "", base::R.version$version.string), 
[16:11:00.791]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:00.791]                                 base::R.version$platform, 8 * 
[16:11:00.791]                                   base::.Machine$sizeof.pointer), 
[16:11:00.791]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.791]                                 "release", "version")], collapse = " "), 
[16:11:00.791]                               hostname = base::Sys.info()[["nodename"]])
[16:11:00.791]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.791]                               info)
[16:11:00.791]                             info <- base::paste(info, collapse = "; ")
[16:11:00.791]                             if (!has_future) {
[16:11:00.791]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.791]                                 info)
[16:11:00.791]                             }
[16:11:00.791]                             else {
[16:11:00.791]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.791]                                 info, version)
[16:11:00.791]                             }
[16:11:00.791]                             base::stop(msg)
[16:11:00.791]                           }
[16:11:00.791]                         })
[16:11:00.791]                       }
[16:11:00.791]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:00.791]                       base::options(mc.cores = 1L)
[16:11:00.791]                     }
[16:11:00.791]                     base::local({
[16:11:00.791]                       for (pkg in "future.apply") {
[16:11:00.791]                         base::loadNamespace(pkg)
[16:11:00.791]                         base::library(pkg, character.only = TRUE)
[16:11:00.791]                       }
[16:11:00.791]                     })
[16:11:00.791]                   }
[16:11:00.791]                   options(future.plan = NULL)
[16:11:00.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.791]                 }
[16:11:00.791]                 ...future.workdir <- getwd()
[16:11:00.791]             }
[16:11:00.791]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.791]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.791]         }
[16:11:00.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.791]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:00.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.791]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.791]             base::names(...future.oldOptions))
[16:11:00.791]     }
[16:11:00.791]     if (FALSE) {
[16:11:00.791]     }
[16:11:00.791]     else {
[16:11:00.791]         if (TRUE) {
[16:11:00.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.791]                 open = "w")
[16:11:00.791]         }
[16:11:00.791]         else {
[16:11:00.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.791]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.791]         }
[16:11:00.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.791]             base::sink(type = "output", split = FALSE)
[16:11:00.791]             base::close(...future.stdout)
[16:11:00.791]         }, add = TRUE)
[16:11:00.791]     }
[16:11:00.791]     ...future.frame <- base::sys.nframe()
[16:11:00.791]     ...future.conditions <- base::list()
[16:11:00.791]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.791]     if (FALSE) {
[16:11:00.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.791]     }
[16:11:00.791]     ...future.result <- base::tryCatch({
[16:11:00.791]         base::withCallingHandlers({
[16:11:00.791]             ...future.value <- base::withVisible(base::local({
[16:11:00.791]                 withCallingHandlers({
[16:11:00.791]                   {
[16:11:00.791]                     do.call(function(...) {
[16:11:00.791]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.791]                       if (!identical(...future.globals.maxSize.org, 
[16:11:00.791]                         ...future.globals.maxSize)) {
[16:11:00.791]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.791]                         on.exit(options(oopts), add = TRUE)
[16:11:00.791]                       }
[16:11:00.791]                       {
[16:11:00.791]                         lapply(seq_along(...future.elements_ii), 
[16:11:00.791]                           FUN = function(jj) {
[16:11:00.791]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.791]                             ...future.FUN(...future.X_jj, ...)
[16:11:00.791]                           })
[16:11:00.791]                       }
[16:11:00.791]                     }, args = future.call.arguments)
[16:11:00.791]                   }
[16:11:00.791]                 }, immediateCondition = function(cond) {
[16:11:00.791]                   save_rds <- function (object, pathname, ...) 
[16:11:00.791]                   {
[16:11:00.791]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:00.791]                     if (file_test("-f", pathname_tmp)) {
[16:11:00.791]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.791]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:00.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.791]                         fi_tmp[["mtime"]])
[16:11:00.791]                     }
[16:11:00.791]                     tryCatch({
[16:11:00.791]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:00.791]                     }, error = function(ex) {
[16:11:00.791]                       msg <- conditionMessage(ex)
[16:11:00.791]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.791]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:00.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.791]                         fi_tmp[["mtime"]], msg)
[16:11:00.791]                       ex$message <- msg
[16:11:00.791]                       stop(ex)
[16:11:00.791]                     })
[16:11:00.791]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:00.791]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:00.791]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:00.791]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.791]                       fi <- file.info(pathname)
[16:11:00.791]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:00.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.791]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:00.791]                         fi[["size"]], fi[["mtime"]])
[16:11:00.791]                       stop(msg)
[16:11:00.791]                     }
[16:11:00.791]                     invisible(pathname)
[16:11:00.791]                   }
[16:11:00.791]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:00.791]                     rootPath = tempdir()) 
[16:11:00.791]                   {
[16:11:00.791]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:00.791]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:00.791]                       tmpdir = path, fileext = ".rds")
[16:11:00.791]                     save_rds(obj, file)
[16:11:00.791]                   }
[16:11:00.791]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:00.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.791]                   {
[16:11:00.791]                     inherits <- base::inherits
[16:11:00.791]                     invokeRestart <- base::invokeRestart
[16:11:00.791]                     is.null <- base::is.null
[16:11:00.791]                     muffled <- FALSE
[16:11:00.791]                     if (inherits(cond, "message")) {
[16:11:00.791]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:00.791]                       if (muffled) 
[16:11:00.791]                         invokeRestart("muffleMessage")
[16:11:00.791]                     }
[16:11:00.791]                     else if (inherits(cond, "warning")) {
[16:11:00.791]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:00.791]                       if (muffled) 
[16:11:00.791]                         invokeRestart("muffleWarning")
[16:11:00.791]                     }
[16:11:00.791]                     else if (inherits(cond, "condition")) {
[16:11:00.791]                       if (!is.null(pattern)) {
[16:11:00.791]                         computeRestarts <- base::computeRestarts
[16:11:00.791]                         grepl <- base::grepl
[16:11:00.791]                         restarts <- computeRestarts(cond)
[16:11:00.791]                         for (restart in restarts) {
[16:11:00.791]                           name <- restart$name
[16:11:00.791]                           if (is.null(name)) 
[16:11:00.791]                             next
[16:11:00.791]                           if (!grepl(pattern, name)) 
[16:11:00.791]                             next
[16:11:00.791]                           invokeRestart(restart)
[16:11:00.791]                           muffled <- TRUE
[16:11:00.791]                           break
[16:11:00.791]                         }
[16:11:00.791]                       }
[16:11:00.791]                     }
[16:11:00.791]                     invisible(muffled)
[16:11:00.791]                   }
[16:11:00.791]                   muffleCondition(cond)
[16:11:00.791]                 })
[16:11:00.791]             }))
[16:11:00.791]             future::FutureResult(value = ...future.value$value, 
[16:11:00.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.791]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.791]                     ...future.globalenv.names))
[16:11:00.791]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.791]         }, condition = base::local({
[16:11:00.791]             c <- base::c
[16:11:00.791]             inherits <- base::inherits
[16:11:00.791]             invokeRestart <- base::invokeRestart
[16:11:00.791]             length <- base::length
[16:11:00.791]             list <- base::list
[16:11:00.791]             seq.int <- base::seq.int
[16:11:00.791]             signalCondition <- base::signalCondition
[16:11:00.791]             sys.calls <- base::sys.calls
[16:11:00.791]             `[[` <- base::`[[`
[16:11:00.791]             `+` <- base::`+`
[16:11:00.791]             `<<-` <- base::`<<-`
[16:11:00.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.791]                   3L)]
[16:11:00.791]             }
[16:11:00.791]             function(cond) {
[16:11:00.791]                 is_error <- inherits(cond, "error")
[16:11:00.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.791]                   NULL)
[16:11:00.791]                 if (is_error) {
[16:11:00.791]                   sessionInformation <- function() {
[16:11:00.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.791]                       search = base::search(), system = base::Sys.info())
[16:11:00.791]                   }
[16:11:00.791]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.791]                     cond$call), session = sessionInformation(), 
[16:11:00.791]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.791]                   signalCondition(cond)
[16:11:00.791]                 }
[16:11:00.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.791]                 "immediateCondition"))) {
[16:11:00.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.791]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.791]                   if (TRUE && !signal) {
[16:11:00.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.791]                     {
[16:11:00.791]                       inherits <- base::inherits
[16:11:00.791]                       invokeRestart <- base::invokeRestart
[16:11:00.791]                       is.null <- base::is.null
[16:11:00.791]                       muffled <- FALSE
[16:11:00.791]                       if (inherits(cond, "message")) {
[16:11:00.791]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.791]                         if (muffled) 
[16:11:00.791]                           invokeRestart("muffleMessage")
[16:11:00.791]                       }
[16:11:00.791]                       else if (inherits(cond, "warning")) {
[16:11:00.791]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.791]                         if (muffled) 
[16:11:00.791]                           invokeRestart("muffleWarning")
[16:11:00.791]                       }
[16:11:00.791]                       else if (inherits(cond, "condition")) {
[16:11:00.791]                         if (!is.null(pattern)) {
[16:11:00.791]                           computeRestarts <- base::computeRestarts
[16:11:00.791]                           grepl <- base::grepl
[16:11:00.791]                           restarts <- computeRestarts(cond)
[16:11:00.791]                           for (restart in restarts) {
[16:11:00.791]                             name <- restart$name
[16:11:00.791]                             if (is.null(name)) 
[16:11:00.791]                               next
[16:11:00.791]                             if (!grepl(pattern, name)) 
[16:11:00.791]                               next
[16:11:00.791]                             invokeRestart(restart)
[16:11:00.791]                             muffled <- TRUE
[16:11:00.791]                             break
[16:11:00.791]                           }
[16:11:00.791]                         }
[16:11:00.791]                       }
[16:11:00.791]                       invisible(muffled)
[16:11:00.791]                     }
[16:11:00.791]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.791]                   }
[16:11:00.791]                 }
[16:11:00.791]                 else {
[16:11:00.791]                   if (TRUE) {
[16:11:00.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.791]                     {
[16:11:00.791]                       inherits <- base::inherits
[16:11:00.791]                       invokeRestart <- base::invokeRestart
[16:11:00.791]                       is.null <- base::is.null
[16:11:00.791]                       muffled <- FALSE
[16:11:00.791]                       if (inherits(cond, "message")) {
[16:11:00.791]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.791]                         if (muffled) 
[16:11:00.791]                           invokeRestart("muffleMessage")
[16:11:00.791]                       }
[16:11:00.791]                       else if (inherits(cond, "warning")) {
[16:11:00.791]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.791]                         if (muffled) 
[16:11:00.791]                           invokeRestart("muffleWarning")
[16:11:00.791]                       }
[16:11:00.791]                       else if (inherits(cond, "condition")) {
[16:11:00.791]                         if (!is.null(pattern)) {
[16:11:00.791]                           computeRestarts <- base::computeRestarts
[16:11:00.791]                           grepl <- base::grepl
[16:11:00.791]                           restarts <- computeRestarts(cond)
[16:11:00.791]                           for (restart in restarts) {
[16:11:00.791]                             name <- restart$name
[16:11:00.791]                             if (is.null(name)) 
[16:11:00.791]                               next
[16:11:00.791]                             if (!grepl(pattern, name)) 
[16:11:00.791]                               next
[16:11:00.791]                             invokeRestart(restart)
[16:11:00.791]                             muffled <- TRUE
[16:11:00.791]                             break
[16:11:00.791]                           }
[16:11:00.791]                         }
[16:11:00.791]                       }
[16:11:00.791]                       invisible(muffled)
[16:11:00.791]                     }
[16:11:00.791]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.791]                   }
[16:11:00.791]                 }
[16:11:00.791]             }
[16:11:00.791]         }))
[16:11:00.791]     }, error = function(ex) {
[16:11:00.791]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.791]                 ...future.rng), started = ...future.startTime, 
[16:11:00.791]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.791]             version = "1.8"), class = "FutureResult")
[16:11:00.791]     }, finally = {
[16:11:00.791]         if (!identical(...future.workdir, getwd())) 
[16:11:00.791]             setwd(...future.workdir)
[16:11:00.791]         {
[16:11:00.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.791]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.791]             }
[16:11:00.791]             base::options(...future.oldOptions)
[16:11:00.791]             if (.Platform$OS.type == "windows") {
[16:11:00.791]                 old_names <- names(...future.oldEnvVars)
[16:11:00.791]                 envs <- base::Sys.getenv()
[16:11:00.791]                 names <- names(envs)
[16:11:00.791]                 common <- intersect(names, old_names)
[16:11:00.791]                 added <- setdiff(names, old_names)
[16:11:00.791]                 removed <- setdiff(old_names, names)
[16:11:00.791]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.791]                   envs[common]]
[16:11:00.791]                 NAMES <- toupper(changed)
[16:11:00.791]                 args <- list()
[16:11:00.791]                 for (kk in seq_along(NAMES)) {
[16:11:00.791]                   name <- changed[[kk]]
[16:11:00.791]                   NAME <- NAMES[[kk]]
[16:11:00.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.791]                     next
[16:11:00.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.791]                 }
[16:11:00.791]                 NAMES <- toupper(added)
[16:11:00.791]                 for (kk in seq_along(NAMES)) {
[16:11:00.791]                   name <- added[[kk]]
[16:11:00.791]                   NAME <- NAMES[[kk]]
[16:11:00.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.791]                     next
[16:11:00.791]                   args[[name]] <- ""
[16:11:00.791]                 }
[16:11:00.791]                 NAMES <- toupper(removed)
[16:11:00.791]                 for (kk in seq_along(NAMES)) {
[16:11:00.791]                   name <- removed[[kk]]
[16:11:00.791]                   NAME <- NAMES[[kk]]
[16:11:00.791]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.791]                     next
[16:11:00.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.791]                 }
[16:11:00.791]                 if (length(args) > 0) 
[16:11:00.791]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.791]             }
[16:11:00.791]             else {
[16:11:00.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.791]             }
[16:11:00.791]             {
[16:11:00.791]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.791]                   0L) {
[16:11:00.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.791]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.791]                   base::options(opts)
[16:11:00.791]                 }
[16:11:00.791]                 {
[16:11:00.791]                   {
[16:11:00.791]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:00.791]                     NULL
[16:11:00.791]                   }
[16:11:00.791]                   options(future.plan = NULL)
[16:11:00.791]                   if (is.na(NA_character_)) 
[16:11:00.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.791]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:00.791]                     envir = parent.frame()) 
[16:11:00.791]                   {
[16:11:00.791]                     default_workers <- missing(workers)
[16:11:00.791]                     if (is.function(workers)) 
[16:11:00.791]                       workers <- workers()
[16:11:00.791]                     workers <- structure(as.integer(workers), 
[16:11:00.791]                       class = class(workers))
[16:11:00.791]                     stop_if_not(is.finite(workers), workers >= 
[16:11:00.791]                       1L)
[16:11:00.791]                     if ((workers == 1L && !inherits(workers, 
[16:11:00.791]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:00.791]                       if (default_workers) 
[16:11:00.791]                         supportsMulticore(warn = TRUE)
[16:11:00.791]                       return(sequential(..., envir = envir))
[16:11:00.791]                     }
[16:11:00.791]                     oopts <- options(mc.cores = workers)
[16:11:00.791]                     on.exit(options(oopts))
[16:11:00.791]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:00.791]                       envir = envir)
[16:11:00.791]                     if (!future$lazy) 
[16:11:00.791]                       future <- run(future)
[16:11:00.791]                     invisible(future)
[16:11:00.791]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.791]                 }
[16:11:00.791]             }
[16:11:00.791]         }
[16:11:00.791]     })
[16:11:00.791]     if (TRUE) {
[16:11:00.791]         base::sink(type = "output", split = FALSE)
[16:11:00.791]         if (TRUE) {
[16:11:00.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.791]         }
[16:11:00.791]         else {
[16:11:00.791]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.791]         }
[16:11:00.791]         base::close(...future.stdout)
[16:11:00.791]         ...future.stdout <- NULL
[16:11:00.791]     }
[16:11:00.791]     ...future.result$conditions <- ...future.conditions
[16:11:00.791]     ...future.result$finished <- base::Sys.time()
[16:11:00.791]     ...future.result
[16:11:00.791] }
[16:11:00.793] assign_globals() ...
[16:11:00.794] List of 11
[16:11:00.794]  $ ...future.FUN            :function (x, ...)  
[16:11:00.794]  $ x_FUN                    :function (x)  
[16:11:00.794]  $ times                    : int 0
[16:11:00.794]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.794]  $ stop_if_not              :function (...)  
[16:11:00.794]  $ dim                      : NULL
[16:11:00.794]  $ valid_types              : chr [1:2] "logical" "integer"
[16:11:00.794]  $ future.call.arguments    : list()
[16:11:00.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.794]  $ ...future.elements_ii    :List of 5
[16:11:00.794]   ..$ : int 1
[16:11:00.794]   ..$ : int 2
[16:11:00.794]   ..$ : int 3
[16:11:00.794]   ..$ : int 4
[16:11:00.794]   ..$ : int 5
[16:11:00.794]  $ ...future.seeds_ii       : NULL
[16:11:00.794]  $ ...future.globals.maxSize: NULL
[16:11:00.794]  - attr(*, "resolved")= logi FALSE
[16:11:00.794]  - attr(*, "total_size")= num 95400
[16:11:00.794]  - attr(*, "where")=List of 11
[16:11:00.794]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.794]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.794]  - attr(*, "already-done")= logi TRUE
[16:11:00.802] - copied ‘...future.FUN’ to environment
[16:11:00.802] - reassign environment for ‘x_FUN’
[16:11:00.802] - copied ‘x_FUN’ to environment
[16:11:00.802] - copied ‘times’ to environment
[16:11:00.802] - copied ‘stopf’ to environment
[16:11:00.802] - copied ‘stop_if_not’ to environment
[16:11:00.802] - copied ‘dim’ to environment
[16:11:00.803] - copied ‘valid_types’ to environment
[16:11:00.803] - copied ‘future.call.arguments’ to environment
[16:11:00.803] - copied ‘...future.elements_ii’ to environment
[16:11:00.803] - copied ‘...future.seeds_ii’ to environment
[16:11:00.803] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.803] assign_globals() ... done
[16:11:00.803] requestCore(): workers = 2
[16:11:00.805] MulticoreFuture started
[16:11:00.805] - Launch lazy future ... done
[16:11:00.806] run() for ‘MulticoreFuture’ ... done
[16:11:00.806] Created future:
[16:11:00.806] plan(): Setting new future strategy stack:
[16:11:00.807] List of future strategies:
[16:11:00.807] 1. sequential:
[16:11:00.807]    - args: function (..., envir = parent.frame())
[16:11:00.807]    - tweaked: FALSE
[16:11:00.807]    - call: NULL
[16:11:00.808] plan(): nbrOfWorkers() = 1
[16:11:00.810] plan(): Setting new future strategy stack:
[16:11:00.810] List of future strategies:
[16:11:00.810] 1. multicore:
[16:11:00.810]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.810]    - tweaked: FALSE
[16:11:00.810]    - call: plan(strategy)
[16:11:00.815] plan(): nbrOfWorkers() = 2
[16:11:00.806] MulticoreFuture:
[16:11:00.806] Label: ‘future_vapply-1’
[16:11:00.806] Expression:
[16:11:00.806] {
[16:11:00.806]     do.call(function(...) {
[16:11:00.806]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.806]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.806]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.806]             on.exit(options(oopts), add = TRUE)
[16:11:00.806]         }
[16:11:00.806]         {
[16:11:00.806]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.806]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.806]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.806]             })
[16:11:00.806]         }
[16:11:00.806]     }, args = future.call.arguments)
[16:11:00.806] }
[16:11:00.806] Lazy evaluation: FALSE
[16:11:00.806] Asynchronous evaluation: TRUE
[16:11:00.806] Local evaluation: TRUE
[16:11:00.806] Environment: R_GlobalEnv
[16:11:00.806] Capture standard output: TRUE
[16:11:00.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.806] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.806] Packages: 1 packages (‘future.apply’)
[16:11:00.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.806] Resolved: TRUE
[16:11:00.806] Value: <not collected>
[16:11:00.806] Conditions captured: <none>
[16:11:00.806] Early signaling: FALSE
[16:11:00.806] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.806] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.816] Chunk #1 of 2 ... DONE
[16:11:00.816] Chunk #2 of 2 ...
[16:11:00.816]  - Finding globals in 'X' for chunk #2 ...
[16:11:00.816] getGlobalsAndPackages() ...
[16:11:00.817] Searching for globals...
[16:11:00.817] 
[16:11:00.817] Searching for globals ... DONE
[16:11:00.817] - globals: [0] <none>
[16:11:00.817] getGlobalsAndPackages() ... DONE
[16:11:00.818]    + additional globals found: [n=0] 
[16:11:00.818]    + additional namespaces needed: [n=0] 
[16:11:00.818]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:00.818]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:00.818]  - seeds: <none>
[16:11:00.818] getGlobalsAndPackages() ...
[16:11:00.818] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.819] Resolving globals: FALSE
[16:11:00.819] Tweak future expression to call with '...' arguments ...
[16:11:00.819] {
[16:11:00.819]     do.call(function(...) {
[16:11:00.819]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.819]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.819]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.819]             on.exit(options(oopts), add = TRUE)
[16:11:00.819]         }
[16:11:00.819]         {
[16:11:00.819]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.819]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.819]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.819]             })
[16:11:00.819]         }
[16:11:00.819]     }, args = future.call.arguments)
[16:11:00.819] }
[16:11:00.819] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.820] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.821] - packages: [1] ‘future.apply’
[16:11:00.821] getGlobalsAndPackages() ... DONE
[16:11:00.821] run() for ‘Future’ ...
[16:11:00.821] - state: ‘created’
[16:11:00.822] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:00.829] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:00.830]   - Field: ‘label’
[16:11:00.830]   - Field: ‘local’
[16:11:00.831]   - Field: ‘owner’
[16:11:00.831]   - Field: ‘envir’
[16:11:00.831]   - Field: ‘workers’
[16:11:00.832]   - Field: ‘packages’
[16:11:00.832]   - Field: ‘gc’
[16:11:00.832]   - Field: ‘job’
[16:11:00.832]   - Field: ‘conditions’
[16:11:00.833]   - Field: ‘expr’
[16:11:00.833]   - Field: ‘uuid’
[16:11:00.833]   - Field: ‘seed’
[16:11:00.833]   - Field: ‘version’
[16:11:00.834]   - Field: ‘result’
[16:11:00.834]   - Field: ‘asynchronous’
[16:11:00.834]   - Field: ‘calls’
[16:11:00.834]   - Field: ‘globals’
[16:11:00.834]   - Field: ‘stdout’
[16:11:00.835]   - Field: ‘earlySignal’
[16:11:00.835]   - Field: ‘lazy’
[16:11:00.835]   - Field: ‘state’
[16:11:00.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:00.835] - Launch lazy future ...
[16:11:00.836] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.836] Packages needed by future strategies (n = 0): <none>
[16:11:00.837] {
[16:11:00.837]     {
[16:11:00.837]         {
[16:11:00.837]             ...future.startTime <- base::Sys.time()
[16:11:00.837]             {
[16:11:00.837]                 {
[16:11:00.837]                   {
[16:11:00.837]                     {
[16:11:00.837]                       {
[16:11:00.837]                         base::local({
[16:11:00.837]                           has_future <- base::requireNamespace("future", 
[16:11:00.837]                             quietly = TRUE)
[16:11:00.837]                           if (has_future) {
[16:11:00.837]                             ns <- base::getNamespace("future")
[16:11:00.837]                             version <- ns[[".package"]][["version"]]
[16:11:00.837]                             if (is.null(version)) 
[16:11:00.837]                               version <- utils::packageVersion("future")
[16:11:00.837]                           }
[16:11:00.837]                           else {
[16:11:00.837]                             version <- NULL
[16:11:00.837]                           }
[16:11:00.837]                           if (!has_future || version < "1.8.0") {
[16:11:00.837]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.837]                               "", base::R.version$version.string), 
[16:11:00.837]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:00.837]                                 base::R.version$platform, 8 * 
[16:11:00.837]                                   base::.Machine$sizeof.pointer), 
[16:11:00.837]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.837]                                 "release", "version")], collapse = " "), 
[16:11:00.837]                               hostname = base::Sys.info()[["nodename"]])
[16:11:00.837]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.837]                               info)
[16:11:00.837]                             info <- base::paste(info, collapse = "; ")
[16:11:00.837]                             if (!has_future) {
[16:11:00.837]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.837]                                 info)
[16:11:00.837]                             }
[16:11:00.837]                             else {
[16:11:00.837]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.837]                                 info, version)
[16:11:00.837]                             }
[16:11:00.837]                             base::stop(msg)
[16:11:00.837]                           }
[16:11:00.837]                         })
[16:11:00.837]                       }
[16:11:00.837]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:00.837]                       base::options(mc.cores = 1L)
[16:11:00.837]                     }
[16:11:00.837]                     base::local({
[16:11:00.837]                       for (pkg in "future.apply") {
[16:11:00.837]                         base::loadNamespace(pkg)
[16:11:00.837]                         base::library(pkg, character.only = TRUE)
[16:11:00.837]                       }
[16:11:00.837]                     })
[16:11:00.837]                   }
[16:11:00.837]                   options(future.plan = NULL)
[16:11:00.837]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.837]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.837]                 }
[16:11:00.837]                 ...future.workdir <- getwd()
[16:11:00.837]             }
[16:11:00.837]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.837]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.837]         }
[16:11:00.837]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.837]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:00.837]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.837]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.837]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.837]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.837]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.837]             base::names(...future.oldOptions))
[16:11:00.837]     }
[16:11:00.837]     if (FALSE) {
[16:11:00.837]     }
[16:11:00.837]     else {
[16:11:00.837]         if (TRUE) {
[16:11:00.837]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.837]                 open = "w")
[16:11:00.837]         }
[16:11:00.837]         else {
[16:11:00.837]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.837]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.837]         }
[16:11:00.837]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.837]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.837]             base::sink(type = "output", split = FALSE)
[16:11:00.837]             base::close(...future.stdout)
[16:11:00.837]         }, add = TRUE)
[16:11:00.837]     }
[16:11:00.837]     ...future.frame <- base::sys.nframe()
[16:11:00.837]     ...future.conditions <- base::list()
[16:11:00.837]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.837]     if (FALSE) {
[16:11:00.837]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.837]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.837]     }
[16:11:00.837]     ...future.result <- base::tryCatch({
[16:11:00.837]         base::withCallingHandlers({
[16:11:00.837]             ...future.value <- base::withVisible(base::local({
[16:11:00.837]                 withCallingHandlers({
[16:11:00.837]                   {
[16:11:00.837]                     do.call(function(...) {
[16:11:00.837]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.837]                       if (!identical(...future.globals.maxSize.org, 
[16:11:00.837]                         ...future.globals.maxSize)) {
[16:11:00.837]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.837]                         on.exit(options(oopts), add = TRUE)
[16:11:00.837]                       }
[16:11:00.837]                       {
[16:11:00.837]                         lapply(seq_along(...future.elements_ii), 
[16:11:00.837]                           FUN = function(jj) {
[16:11:00.837]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.837]                             ...future.FUN(...future.X_jj, ...)
[16:11:00.837]                           })
[16:11:00.837]                       }
[16:11:00.837]                     }, args = future.call.arguments)
[16:11:00.837]                   }
[16:11:00.837]                 }, immediateCondition = function(cond) {
[16:11:00.837]                   save_rds <- function (object, pathname, ...) 
[16:11:00.837]                   {
[16:11:00.837]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:00.837]                     if (file_test("-f", pathname_tmp)) {
[16:11:00.837]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.837]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:00.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.837]                         fi_tmp[["mtime"]])
[16:11:00.837]                     }
[16:11:00.837]                     tryCatch({
[16:11:00.837]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:00.837]                     }, error = function(ex) {
[16:11:00.837]                       msg <- conditionMessage(ex)
[16:11:00.837]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.837]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:00.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.837]                         fi_tmp[["mtime"]], msg)
[16:11:00.837]                       ex$message <- msg
[16:11:00.837]                       stop(ex)
[16:11:00.837]                     })
[16:11:00.837]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:00.837]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:00.837]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:00.837]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.837]                       fi <- file.info(pathname)
[16:11:00.837]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:00.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.837]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:00.837]                         fi[["size"]], fi[["mtime"]])
[16:11:00.837]                       stop(msg)
[16:11:00.837]                     }
[16:11:00.837]                     invisible(pathname)
[16:11:00.837]                   }
[16:11:00.837]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:00.837]                     rootPath = tempdir()) 
[16:11:00.837]                   {
[16:11:00.837]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:00.837]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:00.837]                       tmpdir = path, fileext = ".rds")
[16:11:00.837]                     save_rds(obj, file)
[16:11:00.837]                   }
[16:11:00.837]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:00.837]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.837]                   {
[16:11:00.837]                     inherits <- base::inherits
[16:11:00.837]                     invokeRestart <- base::invokeRestart
[16:11:00.837]                     is.null <- base::is.null
[16:11:00.837]                     muffled <- FALSE
[16:11:00.837]                     if (inherits(cond, "message")) {
[16:11:00.837]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:00.837]                       if (muffled) 
[16:11:00.837]                         invokeRestart("muffleMessage")
[16:11:00.837]                     }
[16:11:00.837]                     else if (inherits(cond, "warning")) {
[16:11:00.837]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:00.837]                       if (muffled) 
[16:11:00.837]                         invokeRestart("muffleWarning")
[16:11:00.837]                     }
[16:11:00.837]                     else if (inherits(cond, "condition")) {
[16:11:00.837]                       if (!is.null(pattern)) {
[16:11:00.837]                         computeRestarts <- base::computeRestarts
[16:11:00.837]                         grepl <- base::grepl
[16:11:00.837]                         restarts <- computeRestarts(cond)
[16:11:00.837]                         for (restart in restarts) {
[16:11:00.837]                           name <- restart$name
[16:11:00.837]                           if (is.null(name)) 
[16:11:00.837]                             next
[16:11:00.837]                           if (!grepl(pattern, name)) 
[16:11:00.837]                             next
[16:11:00.837]                           invokeRestart(restart)
[16:11:00.837]                           muffled <- TRUE
[16:11:00.837]                           break
[16:11:00.837]                         }
[16:11:00.837]                       }
[16:11:00.837]                     }
[16:11:00.837]                     invisible(muffled)
[16:11:00.837]                   }
[16:11:00.837]                   muffleCondition(cond)
[16:11:00.837]                 })
[16:11:00.837]             }))
[16:11:00.837]             future::FutureResult(value = ...future.value$value, 
[16:11:00.837]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.837]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.837]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.837]                     ...future.globalenv.names))
[16:11:00.837]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.837]         }, condition = base::local({
[16:11:00.837]             c <- base::c
[16:11:00.837]             inherits <- base::inherits
[16:11:00.837]             invokeRestart <- base::invokeRestart
[16:11:00.837]             length <- base::length
[16:11:00.837]             list <- base::list
[16:11:00.837]             seq.int <- base::seq.int
[16:11:00.837]             signalCondition <- base::signalCondition
[16:11:00.837]             sys.calls <- base::sys.calls
[16:11:00.837]             `[[` <- base::`[[`
[16:11:00.837]             `+` <- base::`+`
[16:11:00.837]             `<<-` <- base::`<<-`
[16:11:00.837]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.837]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.837]                   3L)]
[16:11:00.837]             }
[16:11:00.837]             function(cond) {
[16:11:00.837]                 is_error <- inherits(cond, "error")
[16:11:00.837]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.837]                   NULL)
[16:11:00.837]                 if (is_error) {
[16:11:00.837]                   sessionInformation <- function() {
[16:11:00.837]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.837]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.837]                       search = base::search(), system = base::Sys.info())
[16:11:00.837]                   }
[16:11:00.837]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.837]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.837]                     cond$call), session = sessionInformation(), 
[16:11:00.837]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.837]                   signalCondition(cond)
[16:11:00.837]                 }
[16:11:00.837]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.837]                 "immediateCondition"))) {
[16:11:00.837]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.837]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.837]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.837]                   if (TRUE && !signal) {
[16:11:00.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.837]                     {
[16:11:00.837]                       inherits <- base::inherits
[16:11:00.837]                       invokeRestart <- base::invokeRestart
[16:11:00.837]                       is.null <- base::is.null
[16:11:00.837]                       muffled <- FALSE
[16:11:00.837]                       if (inherits(cond, "message")) {
[16:11:00.837]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.837]                         if (muffled) 
[16:11:00.837]                           invokeRestart("muffleMessage")
[16:11:00.837]                       }
[16:11:00.837]                       else if (inherits(cond, "warning")) {
[16:11:00.837]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.837]                         if (muffled) 
[16:11:00.837]                           invokeRestart("muffleWarning")
[16:11:00.837]                       }
[16:11:00.837]                       else if (inherits(cond, "condition")) {
[16:11:00.837]                         if (!is.null(pattern)) {
[16:11:00.837]                           computeRestarts <- base::computeRestarts
[16:11:00.837]                           grepl <- base::grepl
[16:11:00.837]                           restarts <- computeRestarts(cond)
[16:11:00.837]                           for (restart in restarts) {
[16:11:00.837]                             name <- restart$name
[16:11:00.837]                             if (is.null(name)) 
[16:11:00.837]                               next
[16:11:00.837]                             if (!grepl(pattern, name)) 
[16:11:00.837]                               next
[16:11:00.837]                             invokeRestart(restart)
[16:11:00.837]                             muffled <- TRUE
[16:11:00.837]                             break
[16:11:00.837]                           }
[16:11:00.837]                         }
[16:11:00.837]                       }
[16:11:00.837]                       invisible(muffled)
[16:11:00.837]                     }
[16:11:00.837]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.837]                   }
[16:11:00.837]                 }
[16:11:00.837]                 else {
[16:11:00.837]                   if (TRUE) {
[16:11:00.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.837]                     {
[16:11:00.837]                       inherits <- base::inherits
[16:11:00.837]                       invokeRestart <- base::invokeRestart
[16:11:00.837]                       is.null <- base::is.null
[16:11:00.837]                       muffled <- FALSE
[16:11:00.837]                       if (inherits(cond, "message")) {
[16:11:00.837]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.837]                         if (muffled) 
[16:11:00.837]                           invokeRestart("muffleMessage")
[16:11:00.837]                       }
[16:11:00.837]                       else if (inherits(cond, "warning")) {
[16:11:00.837]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.837]                         if (muffled) 
[16:11:00.837]                           invokeRestart("muffleWarning")
[16:11:00.837]                       }
[16:11:00.837]                       else if (inherits(cond, "condition")) {
[16:11:00.837]                         if (!is.null(pattern)) {
[16:11:00.837]                           computeRestarts <- base::computeRestarts
[16:11:00.837]                           grepl <- base::grepl
[16:11:00.837]                           restarts <- computeRestarts(cond)
[16:11:00.837]                           for (restart in restarts) {
[16:11:00.837]                             name <- restart$name
[16:11:00.837]                             if (is.null(name)) 
[16:11:00.837]                               next
[16:11:00.837]                             if (!grepl(pattern, name)) 
[16:11:00.837]                               next
[16:11:00.837]                             invokeRestart(restart)
[16:11:00.837]                             muffled <- TRUE
[16:11:00.837]                             break
[16:11:00.837]                           }
[16:11:00.837]                         }
[16:11:00.837]                       }
[16:11:00.837]                       invisible(muffled)
[16:11:00.837]                     }
[16:11:00.837]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.837]                   }
[16:11:00.837]                 }
[16:11:00.837]             }
[16:11:00.837]         }))
[16:11:00.837]     }, error = function(ex) {
[16:11:00.837]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.837]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.837]                 ...future.rng), started = ...future.startTime, 
[16:11:00.837]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.837]             version = "1.8"), class = "FutureResult")
[16:11:00.837]     }, finally = {
[16:11:00.837]         if (!identical(...future.workdir, getwd())) 
[16:11:00.837]             setwd(...future.workdir)
[16:11:00.837]         {
[16:11:00.837]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.837]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.837]             }
[16:11:00.837]             base::options(...future.oldOptions)
[16:11:00.837]             if (.Platform$OS.type == "windows") {
[16:11:00.837]                 old_names <- names(...future.oldEnvVars)
[16:11:00.837]                 envs <- base::Sys.getenv()
[16:11:00.837]                 names <- names(envs)
[16:11:00.837]                 common <- intersect(names, old_names)
[16:11:00.837]                 added <- setdiff(names, old_names)
[16:11:00.837]                 removed <- setdiff(old_names, names)
[16:11:00.837]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.837]                   envs[common]]
[16:11:00.837]                 NAMES <- toupper(changed)
[16:11:00.837]                 args <- list()
[16:11:00.837]                 for (kk in seq_along(NAMES)) {
[16:11:00.837]                   name <- changed[[kk]]
[16:11:00.837]                   NAME <- NAMES[[kk]]
[16:11:00.837]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.837]                     next
[16:11:00.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.837]                 }
[16:11:00.837]                 NAMES <- toupper(added)
[16:11:00.837]                 for (kk in seq_along(NAMES)) {
[16:11:00.837]                   name <- added[[kk]]
[16:11:00.837]                   NAME <- NAMES[[kk]]
[16:11:00.837]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.837]                     next
[16:11:00.837]                   args[[name]] <- ""
[16:11:00.837]                 }
[16:11:00.837]                 NAMES <- toupper(removed)
[16:11:00.837]                 for (kk in seq_along(NAMES)) {
[16:11:00.837]                   name <- removed[[kk]]
[16:11:00.837]                   NAME <- NAMES[[kk]]
[16:11:00.837]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.837]                     next
[16:11:00.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.837]                 }
[16:11:00.837]                 if (length(args) > 0) 
[16:11:00.837]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.837]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.837]             }
[16:11:00.837]             else {
[16:11:00.837]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.837]             }
[16:11:00.837]             {
[16:11:00.837]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.837]                   0L) {
[16:11:00.837]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.837]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.837]                   base::options(opts)
[16:11:00.837]                 }
[16:11:00.837]                 {
[16:11:00.837]                   {
[16:11:00.837]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:00.837]                     NULL
[16:11:00.837]                   }
[16:11:00.837]                   options(future.plan = NULL)
[16:11:00.837]                   if (is.na(NA_character_)) 
[16:11:00.837]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.837]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.837]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:00.837]                     envir = parent.frame()) 
[16:11:00.837]                   {
[16:11:00.837]                     default_workers <- missing(workers)
[16:11:00.837]                     if (is.function(workers)) 
[16:11:00.837]                       workers <- workers()
[16:11:00.837]                     workers <- structure(as.integer(workers), 
[16:11:00.837]                       class = class(workers))
[16:11:00.837]                     stop_if_not(is.finite(workers), workers >= 
[16:11:00.837]                       1L)
[16:11:00.837]                     if ((workers == 1L && !inherits(workers, 
[16:11:00.837]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:00.837]                       if (default_workers) 
[16:11:00.837]                         supportsMulticore(warn = TRUE)
[16:11:00.837]                       return(sequential(..., envir = envir))
[16:11:00.837]                     }
[16:11:00.837]                     oopts <- options(mc.cores = workers)
[16:11:00.837]                     on.exit(options(oopts))
[16:11:00.837]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:00.837]                       envir = envir)
[16:11:00.837]                     if (!future$lazy) 
[16:11:00.837]                       future <- run(future)
[16:11:00.837]                     invisible(future)
[16:11:00.837]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.837]                 }
[16:11:00.837]             }
[16:11:00.837]         }
[16:11:00.837]     })
[16:11:00.837]     if (TRUE) {
[16:11:00.837]         base::sink(type = "output", split = FALSE)
[16:11:00.837]         if (TRUE) {
[16:11:00.837]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.837]         }
[16:11:00.837]         else {
[16:11:00.837]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.837]         }
[16:11:00.837]         base::close(...future.stdout)
[16:11:00.837]         ...future.stdout <- NULL
[16:11:00.837]     }
[16:11:00.837]     ...future.result$conditions <- ...future.conditions
[16:11:00.837]     ...future.result$finished <- base::Sys.time()
[16:11:00.837]     ...future.result
[16:11:00.837] }
[16:11:00.840] assign_globals() ...
[16:11:00.840] List of 11
[16:11:00.840]  $ ...future.FUN            :function (x, ...)  
[16:11:00.840]  $ x_FUN                    :function (x)  
[16:11:00.840]  $ times                    : int 0
[16:11:00.840]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.840]  $ stop_if_not              :function (...)  
[16:11:00.840]  $ dim                      : NULL
[16:11:00.840]  $ valid_types              : chr [1:2] "logical" "integer"
[16:11:00.840]  $ future.call.arguments    : list()
[16:11:00.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.840]  $ ...future.elements_ii    :List of 5
[16:11:00.840]   ..$ : int 6
[16:11:00.840]   ..$ : int 7
[16:11:00.840]   ..$ : int 8
[16:11:00.840]   ..$ : int 9
[16:11:00.840]   ..$ : int 10
[16:11:00.840]  $ ...future.seeds_ii       : NULL
[16:11:00.840]  $ ...future.globals.maxSize: NULL
[16:11:00.840]  - attr(*, "resolved")= logi FALSE
[16:11:00.840]  - attr(*, "total_size")= num 95400
[16:11:00.840]  - attr(*, "where")=List of 11
[16:11:00.840]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.840]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.840]  - attr(*, "already-done")= logi TRUE
[16:11:00.852] - copied ‘...future.FUN’ to environment
[16:11:00.852] - reassign environment for ‘x_FUN’
[16:11:00.852] - copied ‘x_FUN’ to environment
[16:11:00.852] - copied ‘times’ to environment
[16:11:00.853] - copied ‘stopf’ to environment
[16:11:00.853] - copied ‘stop_if_not’ to environment
[16:11:00.853] - copied ‘dim’ to environment
[16:11:00.853] - copied ‘valid_types’ to environment
[16:11:00.853] - copied ‘future.call.arguments’ to environment
[16:11:00.853] - copied ‘...future.elements_ii’ to environment
[16:11:00.853] - copied ‘...future.seeds_ii’ to environment
[16:11:00.853] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.853] assign_globals() ... done
[16:11:00.853] requestCore(): workers = 2
[16:11:00.855] MulticoreFuture started
[16:11:00.856] - Launch lazy future ... done
[16:11:00.856] run() for ‘MulticoreFuture’ ... done
[16:11:00.856] Created future:
[16:11:00.857] plan(): Setting new future strategy stack:
[16:11:00.857] List of future strategies:
[16:11:00.857] 1. sequential:
[16:11:00.857]    - args: function (..., envir = parent.frame())
[16:11:00.857]    - tweaked: FALSE
[16:11:00.857]    - call: NULL
[16:11:00.858] plan(): nbrOfWorkers() = 1
[16:11:00.860] plan(): Setting new future strategy stack:
[16:11:00.860] List of future strategies:
[16:11:00.860] 1. multicore:
[16:11:00.860]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.860]    - tweaked: FALSE
[16:11:00.860]    - call: plan(strategy)
[16:11:00.865] plan(): nbrOfWorkers() = 2
[16:11:00.856] MulticoreFuture:
[16:11:00.856] Label: ‘future_vapply-2’
[16:11:00.856] Expression:
[16:11:00.856] {
[16:11:00.856]     do.call(function(...) {
[16:11:00.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.856]             on.exit(options(oopts), add = TRUE)
[16:11:00.856]         }
[16:11:00.856]         {
[16:11:00.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.856]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.856]             })
[16:11:00.856]         }
[16:11:00.856]     }, args = future.call.arguments)
[16:11:00.856] }
[16:11:00.856] Lazy evaluation: FALSE
[16:11:00.856] Asynchronous evaluation: TRUE
[16:11:00.856] Local evaluation: TRUE
[16:11:00.856] Environment: R_GlobalEnv
[16:11:00.856] Capture standard output: TRUE
[16:11:00.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.856] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.856] Packages: 1 packages (‘future.apply’)
[16:11:00.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.856] Resolved: TRUE
[16:11:00.856] Value: <not collected>
[16:11:00.856] Conditions captured: <none>
[16:11:00.856] Early signaling: FALSE
[16:11:00.856] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.856] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.866] Chunk #2 of 2 ... DONE
[16:11:00.866] Launching 2 futures (chunks) ... DONE
[16:11:00.867] Resolving 2 futures (chunks) ...
[16:11:00.867] resolve() on list ...
[16:11:00.867]  recursive: 0
[16:11:00.867]  length: 2
[16:11:00.867] 
[16:11:00.867] Future #1
[16:11:00.869] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:00.869] - nx: 2
[16:11:00.869] - relay: TRUE
[16:11:00.869] - stdout: TRUE
[16:11:00.869] - signal: TRUE
[16:11:00.869] - resignal: FALSE
[16:11:00.869] - force: TRUE
[16:11:00.870] - relayed: [n=2] FALSE, FALSE
[16:11:00.870] - queued futures: [n=2] FALSE, FALSE
[16:11:00.873]  - until=1
[16:11:00.874]  - relaying element #1
[16:11:00.874] - relayed: [n=2] TRUE, FALSE
[16:11:00.875] - queued futures: [n=2] TRUE, FALSE
[16:11:00.875] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:00.875]  length: 1 (resolved future 1)
[16:11:00.876] Future #2
[16:11:00.878] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:00.878] - nx: 2
[16:11:00.878] - relay: TRUE
[16:11:00.878] - stdout: TRUE
[16:11:00.878] - signal: TRUE
[16:11:00.879] - resignal: FALSE
[16:11:00.879] - force: TRUE
[16:11:00.879] - relayed: [n=2] TRUE, FALSE
[16:11:00.879] - queued futures: [n=2] TRUE, FALSE
[16:11:00.879]  - until=2
[16:11:00.880]  - relaying element #2
[16:11:00.880] - relayed: [n=2] TRUE, TRUE
[16:11:00.880] - queued futures: [n=2] TRUE, TRUE
[16:11:00.880] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:00.881]  length: 0 (resolved future 2)
[16:11:00.881] Relaying remaining futures
[16:11:00.881] signalConditionsASAP(NULL, pos=0) ...
[16:11:00.881] - nx: 2
[16:11:00.881] - relay: TRUE
[16:11:00.881] - stdout: TRUE
[16:11:00.881] - signal: TRUE
[16:11:00.881] - resignal: FALSE
[16:11:00.881] - force: TRUE
[16:11:00.882] - relayed: [n=2] TRUE, TRUE
[16:11:00.882] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:00.882] - relayed: [n=2] TRUE, TRUE
[16:11:00.882] - queued futures: [n=2] TRUE, TRUE
[16:11:00.882] signalConditionsASAP(NULL, pos=0) ... done
[16:11:00.882] resolve() on list ... DONE
[16:11:00.882]  - Number of value chunks collected: 2
[16:11:00.883] Resolving 2 futures (chunks) ... DONE
[16:11:00.883] Reducing values from 2 chunks ...
[16:11:00.883]  - Number of values collected after concatenation: 10
[16:11:00.883]  - Number of values expected: 10
[16:11:00.883] Reducing values from 2 chunks ... DONE
[16:11:00.883] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:11:00.885] future_lapply() ...
[16:11:00.891] Number of chunks: 2
[16:11:00.891] getGlobalsAndPackagesXApply() ...
[16:11:00.892]  - future.globals: TRUE
[16:11:00.892] getGlobalsAndPackages() ...
[16:11:00.892] Searching for globals...
[16:11:00.895] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:00.896] Searching for globals ... DONE
[16:11:00.896] Resolving globals: FALSE
[16:11:00.897] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:11:00.897] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:00.897] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.897] - packages: [1] ‘future.apply’
[16:11:00.898] getGlobalsAndPackages() ... DONE
[16:11:00.898]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:00.898]  - needed namespaces: [n=1] ‘future.apply’
[16:11:00.898] Finding globals ... DONE
[16:11:00.898]  - use_args: TRUE
[16:11:00.898]  - Getting '...' globals ...
[16:11:00.898] resolve() on list ...
[16:11:00.899]  recursive: 0
[16:11:00.899]  length: 1
[16:11:00.899]  elements: ‘...’
[16:11:00.899]  length: 0 (resolved future 1)
[16:11:00.899] resolve() on list ... DONE
[16:11:00.899]    - '...' content: [n=0] 
[16:11:00.899] List of 1
[16:11:00.899]  $ ...: list()
[16:11:00.899]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.899]  - attr(*, "where")=List of 1
[16:11:00.899]   ..$ ...:<environment: 0x561e88b652d8> 
[16:11:00.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.899]  - attr(*, "resolved")= logi TRUE
[16:11:00.899]  - attr(*, "total_size")= num NA
[16:11:00.902]  - Getting '...' globals ... DONE
[16:11:00.902] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:00.902] List of 8
[16:11:00.902]  $ ...future.FUN:function (x, ...)  
[16:11:00.902]  $ x_FUN        :function (x)  
[16:11:00.902]  $ times        : int 1
[16:11:00.902]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.902]  $ stop_if_not  :function (...)  
[16:11:00.902]  $ dim          : NULL
[16:11:00.902]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:00.902]  $ ...          : list()
[16:11:00.902]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.902]  - attr(*, "where")=List of 8
[16:11:00.902]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:00.902]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:00.902]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:00.902]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:00.902]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:00.902]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:00.902]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:00.902]   ..$ ...          :<environment: 0x561e88b652d8> 
[16:11:00.902]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.902]  - attr(*, "resolved")= logi FALSE
[16:11:00.902]  - attr(*, "total_size")= num 94336
[16:11:00.911] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:00.911] getGlobalsAndPackagesXApply() ... DONE
[16:11:00.911] Number of futures (= number of chunks): 2
[16:11:00.911] Launching 2 futures (chunks) ...
[16:11:00.911] Chunk #1 of 2 ...
[16:11:00.912]  - Finding globals in 'X' for chunk #1 ...
[16:11:00.912] getGlobalsAndPackages() ...
[16:11:00.912] Searching for globals...
[16:11:00.912] 
[16:11:00.912] Searching for globals ... DONE
[16:11:00.912] - globals: [0] <none>
[16:11:00.912] getGlobalsAndPackages() ... DONE
[16:11:00.912]    + additional globals found: [n=0] 
[16:11:00.913]    + additional namespaces needed: [n=0] 
[16:11:00.913]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:00.913]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:00.913]  - seeds: <none>
[16:11:00.913] getGlobalsAndPackages() ...
[16:11:00.913] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.913] Resolving globals: FALSE
[16:11:00.913] Tweak future expression to call with '...' arguments ...
[16:11:00.914] {
[16:11:00.914]     do.call(function(...) {
[16:11:00.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.914]             on.exit(options(oopts), add = TRUE)
[16:11:00.914]         }
[16:11:00.914]         {
[16:11:00.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.914]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.914]             })
[16:11:00.914]         }
[16:11:00.914]     }, args = future.call.arguments)
[16:11:00.914] }
[16:11:00.914] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.914] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.914] - packages: [1] ‘future.apply’
[16:11:00.915] getGlobalsAndPackages() ... DONE
[16:11:00.915] run() for ‘Future’ ...
[16:11:00.915] - state: ‘created’
[16:11:00.915] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:00.919] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:00.919]   - Field: ‘label’
[16:11:00.920]   - Field: ‘local’
[16:11:00.920]   - Field: ‘owner’
[16:11:00.920]   - Field: ‘envir’
[16:11:00.920]   - Field: ‘workers’
[16:11:00.920]   - Field: ‘packages’
[16:11:00.920]   - Field: ‘gc’
[16:11:00.920]   - Field: ‘job’
[16:11:00.920]   - Field: ‘conditions’
[16:11:00.920]   - Field: ‘expr’
[16:11:00.920]   - Field: ‘uuid’
[16:11:00.921]   - Field: ‘seed’
[16:11:00.921]   - Field: ‘version’
[16:11:00.921]   - Field: ‘result’
[16:11:00.921]   - Field: ‘asynchronous’
[16:11:00.921]   - Field: ‘calls’
[16:11:00.921]   - Field: ‘globals’
[16:11:00.921]   - Field: ‘stdout’
[16:11:00.921]   - Field: ‘earlySignal’
[16:11:00.921]   - Field: ‘lazy’
[16:11:00.921]   - Field: ‘state’
[16:11:00.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:00.922] - Launch lazy future ...
[16:11:00.922] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.922] Packages needed by future strategies (n = 0): <none>
[16:11:00.923] {
[16:11:00.923]     {
[16:11:00.923]         {
[16:11:00.923]             ...future.startTime <- base::Sys.time()
[16:11:00.923]             {
[16:11:00.923]                 {
[16:11:00.923]                   {
[16:11:00.923]                     {
[16:11:00.923]                       {
[16:11:00.923]                         base::local({
[16:11:00.923]                           has_future <- base::requireNamespace("future", 
[16:11:00.923]                             quietly = TRUE)
[16:11:00.923]                           if (has_future) {
[16:11:00.923]                             ns <- base::getNamespace("future")
[16:11:00.923]                             version <- ns[[".package"]][["version"]]
[16:11:00.923]                             if (is.null(version)) 
[16:11:00.923]                               version <- utils::packageVersion("future")
[16:11:00.923]                           }
[16:11:00.923]                           else {
[16:11:00.923]                             version <- NULL
[16:11:00.923]                           }
[16:11:00.923]                           if (!has_future || version < "1.8.0") {
[16:11:00.923]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.923]                               "", base::R.version$version.string), 
[16:11:00.923]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:00.923]                                 base::R.version$platform, 8 * 
[16:11:00.923]                                   base::.Machine$sizeof.pointer), 
[16:11:00.923]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.923]                                 "release", "version")], collapse = " "), 
[16:11:00.923]                               hostname = base::Sys.info()[["nodename"]])
[16:11:00.923]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.923]                               info)
[16:11:00.923]                             info <- base::paste(info, collapse = "; ")
[16:11:00.923]                             if (!has_future) {
[16:11:00.923]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.923]                                 info)
[16:11:00.923]                             }
[16:11:00.923]                             else {
[16:11:00.923]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.923]                                 info, version)
[16:11:00.923]                             }
[16:11:00.923]                             base::stop(msg)
[16:11:00.923]                           }
[16:11:00.923]                         })
[16:11:00.923]                       }
[16:11:00.923]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:00.923]                       base::options(mc.cores = 1L)
[16:11:00.923]                     }
[16:11:00.923]                     base::local({
[16:11:00.923]                       for (pkg in "future.apply") {
[16:11:00.923]                         base::loadNamespace(pkg)
[16:11:00.923]                         base::library(pkg, character.only = TRUE)
[16:11:00.923]                       }
[16:11:00.923]                     })
[16:11:00.923]                   }
[16:11:00.923]                   options(future.plan = NULL)
[16:11:00.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.923]                 }
[16:11:00.923]                 ...future.workdir <- getwd()
[16:11:00.923]             }
[16:11:00.923]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.923]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.923]         }
[16:11:00.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.923]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:00.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.923]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.923]             base::names(...future.oldOptions))
[16:11:00.923]     }
[16:11:00.923]     if (FALSE) {
[16:11:00.923]     }
[16:11:00.923]     else {
[16:11:00.923]         if (TRUE) {
[16:11:00.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.923]                 open = "w")
[16:11:00.923]         }
[16:11:00.923]         else {
[16:11:00.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.923]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.923]         }
[16:11:00.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.923]             base::sink(type = "output", split = FALSE)
[16:11:00.923]             base::close(...future.stdout)
[16:11:00.923]         }, add = TRUE)
[16:11:00.923]     }
[16:11:00.923]     ...future.frame <- base::sys.nframe()
[16:11:00.923]     ...future.conditions <- base::list()
[16:11:00.923]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.923]     if (FALSE) {
[16:11:00.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.923]     }
[16:11:00.923]     ...future.result <- base::tryCatch({
[16:11:00.923]         base::withCallingHandlers({
[16:11:00.923]             ...future.value <- base::withVisible(base::local({
[16:11:00.923]                 withCallingHandlers({
[16:11:00.923]                   {
[16:11:00.923]                     do.call(function(...) {
[16:11:00.923]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.923]                       if (!identical(...future.globals.maxSize.org, 
[16:11:00.923]                         ...future.globals.maxSize)) {
[16:11:00.923]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.923]                         on.exit(options(oopts), add = TRUE)
[16:11:00.923]                       }
[16:11:00.923]                       {
[16:11:00.923]                         lapply(seq_along(...future.elements_ii), 
[16:11:00.923]                           FUN = function(jj) {
[16:11:00.923]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.923]                             ...future.FUN(...future.X_jj, ...)
[16:11:00.923]                           })
[16:11:00.923]                       }
[16:11:00.923]                     }, args = future.call.arguments)
[16:11:00.923]                   }
[16:11:00.923]                 }, immediateCondition = function(cond) {
[16:11:00.923]                   save_rds <- function (object, pathname, ...) 
[16:11:00.923]                   {
[16:11:00.923]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:00.923]                     if (file_test("-f", pathname_tmp)) {
[16:11:00.923]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.923]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:00.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.923]                         fi_tmp[["mtime"]])
[16:11:00.923]                     }
[16:11:00.923]                     tryCatch({
[16:11:00.923]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:00.923]                     }, error = function(ex) {
[16:11:00.923]                       msg <- conditionMessage(ex)
[16:11:00.923]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.923]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:00.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.923]                         fi_tmp[["mtime"]], msg)
[16:11:00.923]                       ex$message <- msg
[16:11:00.923]                       stop(ex)
[16:11:00.923]                     })
[16:11:00.923]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:00.923]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:00.923]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:00.923]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.923]                       fi <- file.info(pathname)
[16:11:00.923]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:00.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.923]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:00.923]                         fi[["size"]], fi[["mtime"]])
[16:11:00.923]                       stop(msg)
[16:11:00.923]                     }
[16:11:00.923]                     invisible(pathname)
[16:11:00.923]                   }
[16:11:00.923]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:00.923]                     rootPath = tempdir()) 
[16:11:00.923]                   {
[16:11:00.923]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:00.923]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:00.923]                       tmpdir = path, fileext = ".rds")
[16:11:00.923]                     save_rds(obj, file)
[16:11:00.923]                   }
[16:11:00.923]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:00.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.923]                   {
[16:11:00.923]                     inherits <- base::inherits
[16:11:00.923]                     invokeRestart <- base::invokeRestart
[16:11:00.923]                     is.null <- base::is.null
[16:11:00.923]                     muffled <- FALSE
[16:11:00.923]                     if (inherits(cond, "message")) {
[16:11:00.923]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:00.923]                       if (muffled) 
[16:11:00.923]                         invokeRestart("muffleMessage")
[16:11:00.923]                     }
[16:11:00.923]                     else if (inherits(cond, "warning")) {
[16:11:00.923]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:00.923]                       if (muffled) 
[16:11:00.923]                         invokeRestart("muffleWarning")
[16:11:00.923]                     }
[16:11:00.923]                     else if (inherits(cond, "condition")) {
[16:11:00.923]                       if (!is.null(pattern)) {
[16:11:00.923]                         computeRestarts <- base::computeRestarts
[16:11:00.923]                         grepl <- base::grepl
[16:11:00.923]                         restarts <- computeRestarts(cond)
[16:11:00.923]                         for (restart in restarts) {
[16:11:00.923]                           name <- restart$name
[16:11:00.923]                           if (is.null(name)) 
[16:11:00.923]                             next
[16:11:00.923]                           if (!grepl(pattern, name)) 
[16:11:00.923]                             next
[16:11:00.923]                           invokeRestart(restart)
[16:11:00.923]                           muffled <- TRUE
[16:11:00.923]                           break
[16:11:00.923]                         }
[16:11:00.923]                       }
[16:11:00.923]                     }
[16:11:00.923]                     invisible(muffled)
[16:11:00.923]                   }
[16:11:00.923]                   muffleCondition(cond)
[16:11:00.923]                 })
[16:11:00.923]             }))
[16:11:00.923]             future::FutureResult(value = ...future.value$value, 
[16:11:00.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.923]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.923]                     ...future.globalenv.names))
[16:11:00.923]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.923]         }, condition = base::local({
[16:11:00.923]             c <- base::c
[16:11:00.923]             inherits <- base::inherits
[16:11:00.923]             invokeRestart <- base::invokeRestart
[16:11:00.923]             length <- base::length
[16:11:00.923]             list <- base::list
[16:11:00.923]             seq.int <- base::seq.int
[16:11:00.923]             signalCondition <- base::signalCondition
[16:11:00.923]             sys.calls <- base::sys.calls
[16:11:00.923]             `[[` <- base::`[[`
[16:11:00.923]             `+` <- base::`+`
[16:11:00.923]             `<<-` <- base::`<<-`
[16:11:00.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.923]                   3L)]
[16:11:00.923]             }
[16:11:00.923]             function(cond) {
[16:11:00.923]                 is_error <- inherits(cond, "error")
[16:11:00.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.923]                   NULL)
[16:11:00.923]                 if (is_error) {
[16:11:00.923]                   sessionInformation <- function() {
[16:11:00.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.923]                       search = base::search(), system = base::Sys.info())
[16:11:00.923]                   }
[16:11:00.923]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.923]                     cond$call), session = sessionInformation(), 
[16:11:00.923]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.923]                   signalCondition(cond)
[16:11:00.923]                 }
[16:11:00.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.923]                 "immediateCondition"))) {
[16:11:00.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.923]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.923]                   if (TRUE && !signal) {
[16:11:00.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.923]                     {
[16:11:00.923]                       inherits <- base::inherits
[16:11:00.923]                       invokeRestart <- base::invokeRestart
[16:11:00.923]                       is.null <- base::is.null
[16:11:00.923]                       muffled <- FALSE
[16:11:00.923]                       if (inherits(cond, "message")) {
[16:11:00.923]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.923]                         if (muffled) 
[16:11:00.923]                           invokeRestart("muffleMessage")
[16:11:00.923]                       }
[16:11:00.923]                       else if (inherits(cond, "warning")) {
[16:11:00.923]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.923]                         if (muffled) 
[16:11:00.923]                           invokeRestart("muffleWarning")
[16:11:00.923]                       }
[16:11:00.923]                       else if (inherits(cond, "condition")) {
[16:11:00.923]                         if (!is.null(pattern)) {
[16:11:00.923]                           computeRestarts <- base::computeRestarts
[16:11:00.923]                           grepl <- base::grepl
[16:11:00.923]                           restarts <- computeRestarts(cond)
[16:11:00.923]                           for (restart in restarts) {
[16:11:00.923]                             name <- restart$name
[16:11:00.923]                             if (is.null(name)) 
[16:11:00.923]                               next
[16:11:00.923]                             if (!grepl(pattern, name)) 
[16:11:00.923]                               next
[16:11:00.923]                             invokeRestart(restart)
[16:11:00.923]                             muffled <- TRUE
[16:11:00.923]                             break
[16:11:00.923]                           }
[16:11:00.923]                         }
[16:11:00.923]                       }
[16:11:00.923]                       invisible(muffled)
[16:11:00.923]                     }
[16:11:00.923]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.923]                   }
[16:11:00.923]                 }
[16:11:00.923]                 else {
[16:11:00.923]                   if (TRUE) {
[16:11:00.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.923]                     {
[16:11:00.923]                       inherits <- base::inherits
[16:11:00.923]                       invokeRestart <- base::invokeRestart
[16:11:00.923]                       is.null <- base::is.null
[16:11:00.923]                       muffled <- FALSE
[16:11:00.923]                       if (inherits(cond, "message")) {
[16:11:00.923]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.923]                         if (muffled) 
[16:11:00.923]                           invokeRestart("muffleMessage")
[16:11:00.923]                       }
[16:11:00.923]                       else if (inherits(cond, "warning")) {
[16:11:00.923]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.923]                         if (muffled) 
[16:11:00.923]                           invokeRestart("muffleWarning")
[16:11:00.923]                       }
[16:11:00.923]                       else if (inherits(cond, "condition")) {
[16:11:00.923]                         if (!is.null(pattern)) {
[16:11:00.923]                           computeRestarts <- base::computeRestarts
[16:11:00.923]                           grepl <- base::grepl
[16:11:00.923]                           restarts <- computeRestarts(cond)
[16:11:00.923]                           for (restart in restarts) {
[16:11:00.923]                             name <- restart$name
[16:11:00.923]                             if (is.null(name)) 
[16:11:00.923]                               next
[16:11:00.923]                             if (!grepl(pattern, name)) 
[16:11:00.923]                               next
[16:11:00.923]                             invokeRestart(restart)
[16:11:00.923]                             muffled <- TRUE
[16:11:00.923]                             break
[16:11:00.923]                           }
[16:11:00.923]                         }
[16:11:00.923]                       }
[16:11:00.923]                       invisible(muffled)
[16:11:00.923]                     }
[16:11:00.923]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.923]                   }
[16:11:00.923]                 }
[16:11:00.923]             }
[16:11:00.923]         }))
[16:11:00.923]     }, error = function(ex) {
[16:11:00.923]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.923]                 ...future.rng), started = ...future.startTime, 
[16:11:00.923]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.923]             version = "1.8"), class = "FutureResult")
[16:11:00.923]     }, finally = {
[16:11:00.923]         if (!identical(...future.workdir, getwd())) 
[16:11:00.923]             setwd(...future.workdir)
[16:11:00.923]         {
[16:11:00.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.923]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.923]             }
[16:11:00.923]             base::options(...future.oldOptions)
[16:11:00.923]             if (.Platform$OS.type == "windows") {
[16:11:00.923]                 old_names <- names(...future.oldEnvVars)
[16:11:00.923]                 envs <- base::Sys.getenv()
[16:11:00.923]                 names <- names(envs)
[16:11:00.923]                 common <- intersect(names, old_names)
[16:11:00.923]                 added <- setdiff(names, old_names)
[16:11:00.923]                 removed <- setdiff(old_names, names)
[16:11:00.923]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.923]                   envs[common]]
[16:11:00.923]                 NAMES <- toupper(changed)
[16:11:00.923]                 args <- list()
[16:11:00.923]                 for (kk in seq_along(NAMES)) {
[16:11:00.923]                   name <- changed[[kk]]
[16:11:00.923]                   NAME <- NAMES[[kk]]
[16:11:00.923]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.923]                     next
[16:11:00.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.923]                 }
[16:11:00.923]                 NAMES <- toupper(added)
[16:11:00.923]                 for (kk in seq_along(NAMES)) {
[16:11:00.923]                   name <- added[[kk]]
[16:11:00.923]                   NAME <- NAMES[[kk]]
[16:11:00.923]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.923]                     next
[16:11:00.923]                   args[[name]] <- ""
[16:11:00.923]                 }
[16:11:00.923]                 NAMES <- toupper(removed)
[16:11:00.923]                 for (kk in seq_along(NAMES)) {
[16:11:00.923]                   name <- removed[[kk]]
[16:11:00.923]                   NAME <- NAMES[[kk]]
[16:11:00.923]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.923]                     next
[16:11:00.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.923]                 }
[16:11:00.923]                 if (length(args) > 0) 
[16:11:00.923]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.923]             }
[16:11:00.923]             else {
[16:11:00.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.923]             }
[16:11:00.923]             {
[16:11:00.923]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.923]                   0L) {
[16:11:00.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.923]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.923]                   base::options(opts)
[16:11:00.923]                 }
[16:11:00.923]                 {
[16:11:00.923]                   {
[16:11:00.923]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:00.923]                     NULL
[16:11:00.923]                   }
[16:11:00.923]                   options(future.plan = NULL)
[16:11:00.923]                   if (is.na(NA_character_)) 
[16:11:00.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.923]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:00.923]                     envir = parent.frame()) 
[16:11:00.923]                   {
[16:11:00.923]                     default_workers <- missing(workers)
[16:11:00.923]                     if (is.function(workers)) 
[16:11:00.923]                       workers <- workers()
[16:11:00.923]                     workers <- structure(as.integer(workers), 
[16:11:00.923]                       class = class(workers))
[16:11:00.923]                     stop_if_not(is.finite(workers), workers >= 
[16:11:00.923]                       1L)
[16:11:00.923]                     if ((workers == 1L && !inherits(workers, 
[16:11:00.923]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:00.923]                       if (default_workers) 
[16:11:00.923]                         supportsMulticore(warn = TRUE)
[16:11:00.923]                       return(sequential(..., envir = envir))
[16:11:00.923]                     }
[16:11:00.923]                     oopts <- options(mc.cores = workers)
[16:11:00.923]                     on.exit(options(oopts))
[16:11:00.923]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:00.923]                       envir = envir)
[16:11:00.923]                     if (!future$lazy) 
[16:11:00.923]                       future <- run(future)
[16:11:00.923]                     invisible(future)
[16:11:00.923]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.923]                 }
[16:11:00.923]             }
[16:11:00.923]         }
[16:11:00.923]     })
[16:11:00.923]     if (TRUE) {
[16:11:00.923]         base::sink(type = "output", split = FALSE)
[16:11:00.923]         if (TRUE) {
[16:11:00.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.923]         }
[16:11:00.923]         else {
[16:11:00.923]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.923]         }
[16:11:00.923]         base::close(...future.stdout)
[16:11:00.923]         ...future.stdout <- NULL
[16:11:00.923]     }
[16:11:00.923]     ...future.result$conditions <- ...future.conditions
[16:11:00.923]     ...future.result$finished <- base::Sys.time()
[16:11:00.923]     ...future.result
[16:11:00.923] }
[16:11:00.925] assign_globals() ...
[16:11:00.925] List of 11
[16:11:00.925]  $ ...future.FUN            :function (x, ...)  
[16:11:00.925]  $ x_FUN                    :function (x)  
[16:11:00.925]  $ times                    : int 1
[16:11:00.925]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.925]  $ stop_if_not              :function (...)  
[16:11:00.925]  $ dim                      : NULL
[16:11:00.925]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.925]  $ future.call.arguments    : list()
[16:11:00.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.925]  $ ...future.elements_ii    :List of 5
[16:11:00.925]   ..$ : int 1
[16:11:00.925]   ..$ : int 2
[16:11:00.925]   ..$ : int 3
[16:11:00.925]   ..$ : int 4
[16:11:00.925]   ..$ : int 5
[16:11:00.925]  $ ...future.seeds_ii       : NULL
[16:11:00.925]  $ ...future.globals.maxSize: NULL
[16:11:00.925]  - attr(*, "resolved")= logi FALSE
[16:11:00.925]  - attr(*, "total_size")= num 94336
[16:11:00.925]  - attr(*, "where")=List of 11
[16:11:00.925]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.925]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.925]  - attr(*, "already-done")= logi TRUE
[16:11:00.937] - copied ‘...future.FUN’ to environment
[16:11:00.937] - copied ‘x_FUN’ to environment
[16:11:00.937] - copied ‘times’ to environment
[16:11:00.937] - copied ‘stopf’ to environment
[16:11:00.937] - copied ‘stop_if_not’ to environment
[16:11:00.937] - copied ‘dim’ to environment
[16:11:00.938] - copied ‘valid_types’ to environment
[16:11:00.938] - copied ‘future.call.arguments’ to environment
[16:11:00.938] - copied ‘...future.elements_ii’ to environment
[16:11:00.938] - copied ‘...future.seeds_ii’ to environment
[16:11:00.938] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.938] assign_globals() ... done
[16:11:00.938] requestCore(): workers = 2
[16:11:00.940] MulticoreFuture started
[16:11:00.941] - Launch lazy future ... done
[16:11:00.941] run() for ‘MulticoreFuture’ ... done
[16:11:00.941] Created future:
[16:11:00.942] plan(): Setting new future strategy stack:
[16:11:00.942] List of future strategies:
[16:11:00.942] 1. sequential:
[16:11:00.942]    - args: function (..., envir = parent.frame())
[16:11:00.942]    - tweaked: FALSE
[16:11:00.942]    - call: NULL
[16:11:00.943] plan(): nbrOfWorkers() = 1
[16:11:00.945] plan(): Setting new future strategy stack:
[16:11:00.945] List of future strategies:
[16:11:00.945] 1. multicore:
[16:11:00.945]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.945]    - tweaked: FALSE
[16:11:00.945]    - call: plan(strategy)
[16:11:00.951] plan(): nbrOfWorkers() = 2
[16:11:00.942] MulticoreFuture:
[16:11:00.942] Label: ‘future_vapply-1’
[16:11:00.942] Expression:
[16:11:00.942] {
[16:11:00.942]     do.call(function(...) {
[16:11:00.942]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.942]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.942]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.942]             on.exit(options(oopts), add = TRUE)
[16:11:00.942]         }
[16:11:00.942]         {
[16:11:00.942]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.942]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.942]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.942]             })
[16:11:00.942]         }
[16:11:00.942]     }, args = future.call.arguments)
[16:11:00.942] }
[16:11:00.942] Lazy evaluation: FALSE
[16:11:00.942] Asynchronous evaluation: TRUE
[16:11:00.942] Local evaluation: TRUE
[16:11:00.942] Environment: R_GlobalEnv
[16:11:00.942] Capture standard output: TRUE
[16:11:00.942] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.942] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.942] Packages: 1 packages (‘future.apply’)
[16:11:00.942] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.942] Resolved: TRUE
[16:11:00.942] Value: <not collected>
[16:11:00.942] Conditions captured: <none>
[16:11:00.942] Early signaling: FALSE
[16:11:00.942] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.942] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.952] Chunk #1 of 2 ... DONE
[16:11:00.952] Chunk #2 of 2 ...
[16:11:00.953]  - Finding globals in 'X' for chunk #2 ...
[16:11:00.953] getGlobalsAndPackages() ...
[16:11:00.953] Searching for globals...
[16:11:00.953] 
[16:11:00.953] Searching for globals ... DONE
[16:11:00.954] - globals: [0] <none>
[16:11:00.954] getGlobalsAndPackages() ... DONE
[16:11:00.954]    + additional globals found: [n=0] 
[16:11:00.954]    + additional namespaces needed: [n=0] 
[16:11:00.954]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:00.954]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:00.954]  - seeds: <none>
[16:11:00.955] getGlobalsAndPackages() ...
[16:11:00.955] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.955] Resolving globals: FALSE
[16:11:00.955] Tweak future expression to call with '...' arguments ...
[16:11:00.955] {
[16:11:00.955]     do.call(function(...) {
[16:11:00.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.955]             on.exit(options(oopts), add = TRUE)
[16:11:00.955]         }
[16:11:00.955]         {
[16:11:00.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.955]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.955]             })
[16:11:00.955]         }
[16:11:00.955]     }, args = future.call.arguments)
[16:11:00.955] }
[16:11:00.956] Tweak future expression to call with '...' arguments ... DONE
[16:11:00.957] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:00.957] - packages: [1] ‘future.apply’
[16:11:00.957] getGlobalsAndPackages() ... DONE
[16:11:00.958] run() for ‘Future’ ...
[16:11:00.958] - state: ‘created’
[16:11:00.958] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:00.963] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:00.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:00.963]   - Field: ‘label’
[16:11:00.963]   - Field: ‘local’
[16:11:00.963]   - Field: ‘owner’
[16:11:00.964]   - Field: ‘envir’
[16:11:00.964]   - Field: ‘workers’
[16:11:00.964]   - Field: ‘packages’
[16:11:00.964]   - Field: ‘gc’
[16:11:00.964]   - Field: ‘job’
[16:11:00.964]   - Field: ‘conditions’
[16:11:00.964]   - Field: ‘expr’
[16:11:00.965]   - Field: ‘uuid’
[16:11:00.965]   - Field: ‘seed’
[16:11:00.965]   - Field: ‘version’
[16:11:00.965]   - Field: ‘result’
[16:11:00.965]   - Field: ‘asynchronous’
[16:11:00.965]   - Field: ‘calls’
[16:11:00.966]   - Field: ‘globals’
[16:11:00.966]   - Field: ‘stdout’
[16:11:00.966]   - Field: ‘earlySignal’
[16:11:00.966]   - Field: ‘lazy’
[16:11:00.966]   - Field: ‘state’
[16:11:00.966] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:00.967] - Launch lazy future ...
[16:11:00.967] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:00.967] Packages needed by future strategies (n = 0): <none>
[16:11:00.968] {
[16:11:00.968]     {
[16:11:00.968]         {
[16:11:00.968]             ...future.startTime <- base::Sys.time()
[16:11:00.968]             {
[16:11:00.968]                 {
[16:11:00.968]                   {
[16:11:00.968]                     {
[16:11:00.968]                       {
[16:11:00.968]                         base::local({
[16:11:00.968]                           has_future <- base::requireNamespace("future", 
[16:11:00.968]                             quietly = TRUE)
[16:11:00.968]                           if (has_future) {
[16:11:00.968]                             ns <- base::getNamespace("future")
[16:11:00.968]                             version <- ns[[".package"]][["version"]]
[16:11:00.968]                             if (is.null(version)) 
[16:11:00.968]                               version <- utils::packageVersion("future")
[16:11:00.968]                           }
[16:11:00.968]                           else {
[16:11:00.968]                             version <- NULL
[16:11:00.968]                           }
[16:11:00.968]                           if (!has_future || version < "1.8.0") {
[16:11:00.968]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:00.968]                               "", base::R.version$version.string), 
[16:11:00.968]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:00.968]                                 base::R.version$platform, 8 * 
[16:11:00.968]                                   base::.Machine$sizeof.pointer), 
[16:11:00.968]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:00.968]                                 "release", "version")], collapse = " "), 
[16:11:00.968]                               hostname = base::Sys.info()[["nodename"]])
[16:11:00.968]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:00.968]                               info)
[16:11:00.968]                             info <- base::paste(info, collapse = "; ")
[16:11:00.968]                             if (!has_future) {
[16:11:00.968]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:00.968]                                 info)
[16:11:00.968]                             }
[16:11:00.968]                             else {
[16:11:00.968]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:00.968]                                 info, version)
[16:11:00.968]                             }
[16:11:00.968]                             base::stop(msg)
[16:11:00.968]                           }
[16:11:00.968]                         })
[16:11:00.968]                       }
[16:11:00.968]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:00.968]                       base::options(mc.cores = 1L)
[16:11:00.968]                     }
[16:11:00.968]                     base::local({
[16:11:00.968]                       for (pkg in "future.apply") {
[16:11:00.968]                         base::loadNamespace(pkg)
[16:11:00.968]                         base::library(pkg, character.only = TRUE)
[16:11:00.968]                       }
[16:11:00.968]                     })
[16:11:00.968]                   }
[16:11:00.968]                   options(future.plan = NULL)
[16:11:00.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:00.968]                 }
[16:11:00.968]                 ...future.workdir <- getwd()
[16:11:00.968]             }
[16:11:00.968]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:00.968]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:00.968]         }
[16:11:00.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:00.968]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:00.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:00.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:00.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:00.968]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:00.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:00.968]             base::names(...future.oldOptions))
[16:11:00.968]     }
[16:11:00.968]     if (FALSE) {
[16:11:00.968]     }
[16:11:00.968]     else {
[16:11:00.968]         if (TRUE) {
[16:11:00.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:00.968]                 open = "w")
[16:11:00.968]         }
[16:11:00.968]         else {
[16:11:00.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:00.968]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:00.968]         }
[16:11:00.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:00.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:00.968]             base::sink(type = "output", split = FALSE)
[16:11:00.968]             base::close(...future.stdout)
[16:11:00.968]         }, add = TRUE)
[16:11:00.968]     }
[16:11:00.968]     ...future.frame <- base::sys.nframe()
[16:11:00.968]     ...future.conditions <- base::list()
[16:11:00.968]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:00.968]     if (FALSE) {
[16:11:00.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:00.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:00.968]     }
[16:11:00.968]     ...future.result <- base::tryCatch({
[16:11:00.968]         base::withCallingHandlers({
[16:11:00.968]             ...future.value <- base::withVisible(base::local({
[16:11:00.968]                 withCallingHandlers({
[16:11:00.968]                   {
[16:11:00.968]                     do.call(function(...) {
[16:11:00.968]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.968]                       if (!identical(...future.globals.maxSize.org, 
[16:11:00.968]                         ...future.globals.maxSize)) {
[16:11:00.968]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.968]                         on.exit(options(oopts), add = TRUE)
[16:11:00.968]                       }
[16:11:00.968]                       {
[16:11:00.968]                         lapply(seq_along(...future.elements_ii), 
[16:11:00.968]                           FUN = function(jj) {
[16:11:00.968]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.968]                             ...future.FUN(...future.X_jj, ...)
[16:11:00.968]                           })
[16:11:00.968]                       }
[16:11:00.968]                     }, args = future.call.arguments)
[16:11:00.968]                   }
[16:11:00.968]                 }, immediateCondition = function(cond) {
[16:11:00.968]                   save_rds <- function (object, pathname, ...) 
[16:11:00.968]                   {
[16:11:00.968]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:00.968]                     if (file_test("-f", pathname_tmp)) {
[16:11:00.968]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.968]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:00.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.968]                         fi_tmp[["mtime"]])
[16:11:00.968]                     }
[16:11:00.968]                     tryCatch({
[16:11:00.968]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:00.968]                     }, error = function(ex) {
[16:11:00.968]                       msg <- conditionMessage(ex)
[16:11:00.968]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.968]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:00.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.968]                         fi_tmp[["mtime"]], msg)
[16:11:00.968]                       ex$message <- msg
[16:11:00.968]                       stop(ex)
[16:11:00.968]                     })
[16:11:00.968]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:00.968]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:00.968]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:00.968]                       fi_tmp <- file.info(pathname_tmp)
[16:11:00.968]                       fi <- file.info(pathname)
[16:11:00.968]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:00.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:00.968]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:00.968]                         fi[["size"]], fi[["mtime"]])
[16:11:00.968]                       stop(msg)
[16:11:00.968]                     }
[16:11:00.968]                     invisible(pathname)
[16:11:00.968]                   }
[16:11:00.968]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:00.968]                     rootPath = tempdir()) 
[16:11:00.968]                   {
[16:11:00.968]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:00.968]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:00.968]                       tmpdir = path, fileext = ".rds")
[16:11:00.968]                     save_rds(obj, file)
[16:11:00.968]                   }
[16:11:00.968]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:00.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.968]                   {
[16:11:00.968]                     inherits <- base::inherits
[16:11:00.968]                     invokeRestart <- base::invokeRestart
[16:11:00.968]                     is.null <- base::is.null
[16:11:00.968]                     muffled <- FALSE
[16:11:00.968]                     if (inherits(cond, "message")) {
[16:11:00.968]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:00.968]                       if (muffled) 
[16:11:00.968]                         invokeRestart("muffleMessage")
[16:11:00.968]                     }
[16:11:00.968]                     else if (inherits(cond, "warning")) {
[16:11:00.968]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:00.968]                       if (muffled) 
[16:11:00.968]                         invokeRestart("muffleWarning")
[16:11:00.968]                     }
[16:11:00.968]                     else if (inherits(cond, "condition")) {
[16:11:00.968]                       if (!is.null(pattern)) {
[16:11:00.968]                         computeRestarts <- base::computeRestarts
[16:11:00.968]                         grepl <- base::grepl
[16:11:00.968]                         restarts <- computeRestarts(cond)
[16:11:00.968]                         for (restart in restarts) {
[16:11:00.968]                           name <- restart$name
[16:11:00.968]                           if (is.null(name)) 
[16:11:00.968]                             next
[16:11:00.968]                           if (!grepl(pattern, name)) 
[16:11:00.968]                             next
[16:11:00.968]                           invokeRestart(restart)
[16:11:00.968]                           muffled <- TRUE
[16:11:00.968]                           break
[16:11:00.968]                         }
[16:11:00.968]                       }
[16:11:00.968]                     }
[16:11:00.968]                     invisible(muffled)
[16:11:00.968]                   }
[16:11:00.968]                   muffleCondition(cond)
[16:11:00.968]                 })
[16:11:00.968]             }))
[16:11:00.968]             future::FutureResult(value = ...future.value$value, 
[16:11:00.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.968]                   ...future.rng), globalenv = if (FALSE) 
[16:11:00.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:00.968]                     ...future.globalenv.names))
[16:11:00.968]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:00.968]         }, condition = base::local({
[16:11:00.968]             c <- base::c
[16:11:00.968]             inherits <- base::inherits
[16:11:00.968]             invokeRestart <- base::invokeRestart
[16:11:00.968]             length <- base::length
[16:11:00.968]             list <- base::list
[16:11:00.968]             seq.int <- base::seq.int
[16:11:00.968]             signalCondition <- base::signalCondition
[16:11:00.968]             sys.calls <- base::sys.calls
[16:11:00.968]             `[[` <- base::`[[`
[16:11:00.968]             `+` <- base::`+`
[16:11:00.968]             `<<-` <- base::`<<-`
[16:11:00.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:00.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:00.968]                   3L)]
[16:11:00.968]             }
[16:11:00.968]             function(cond) {
[16:11:00.968]                 is_error <- inherits(cond, "error")
[16:11:00.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:00.968]                   NULL)
[16:11:00.968]                 if (is_error) {
[16:11:00.968]                   sessionInformation <- function() {
[16:11:00.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:00.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:00.968]                       search = base::search(), system = base::Sys.info())
[16:11:00.968]                   }
[16:11:00.968]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:00.968]                     cond$call), session = sessionInformation(), 
[16:11:00.968]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:00.968]                   signalCondition(cond)
[16:11:00.968]                 }
[16:11:00.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:00.968]                 "immediateCondition"))) {
[16:11:00.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:00.968]                   ...future.conditions[[length(...future.conditions) + 
[16:11:00.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:00.968]                   if (TRUE && !signal) {
[16:11:00.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.968]                     {
[16:11:00.968]                       inherits <- base::inherits
[16:11:00.968]                       invokeRestart <- base::invokeRestart
[16:11:00.968]                       is.null <- base::is.null
[16:11:00.968]                       muffled <- FALSE
[16:11:00.968]                       if (inherits(cond, "message")) {
[16:11:00.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.968]                         if (muffled) 
[16:11:00.968]                           invokeRestart("muffleMessage")
[16:11:00.968]                       }
[16:11:00.968]                       else if (inherits(cond, "warning")) {
[16:11:00.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.968]                         if (muffled) 
[16:11:00.968]                           invokeRestart("muffleWarning")
[16:11:00.968]                       }
[16:11:00.968]                       else if (inherits(cond, "condition")) {
[16:11:00.968]                         if (!is.null(pattern)) {
[16:11:00.968]                           computeRestarts <- base::computeRestarts
[16:11:00.968]                           grepl <- base::grepl
[16:11:00.968]                           restarts <- computeRestarts(cond)
[16:11:00.968]                           for (restart in restarts) {
[16:11:00.968]                             name <- restart$name
[16:11:00.968]                             if (is.null(name)) 
[16:11:00.968]                               next
[16:11:00.968]                             if (!grepl(pattern, name)) 
[16:11:00.968]                               next
[16:11:00.968]                             invokeRestart(restart)
[16:11:00.968]                             muffled <- TRUE
[16:11:00.968]                             break
[16:11:00.968]                           }
[16:11:00.968]                         }
[16:11:00.968]                       }
[16:11:00.968]                       invisible(muffled)
[16:11:00.968]                     }
[16:11:00.968]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.968]                   }
[16:11:00.968]                 }
[16:11:00.968]                 else {
[16:11:00.968]                   if (TRUE) {
[16:11:00.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:00.968]                     {
[16:11:00.968]                       inherits <- base::inherits
[16:11:00.968]                       invokeRestart <- base::invokeRestart
[16:11:00.968]                       is.null <- base::is.null
[16:11:00.968]                       muffled <- FALSE
[16:11:00.968]                       if (inherits(cond, "message")) {
[16:11:00.968]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:00.968]                         if (muffled) 
[16:11:00.968]                           invokeRestart("muffleMessage")
[16:11:00.968]                       }
[16:11:00.968]                       else if (inherits(cond, "warning")) {
[16:11:00.968]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:00.968]                         if (muffled) 
[16:11:00.968]                           invokeRestart("muffleWarning")
[16:11:00.968]                       }
[16:11:00.968]                       else if (inherits(cond, "condition")) {
[16:11:00.968]                         if (!is.null(pattern)) {
[16:11:00.968]                           computeRestarts <- base::computeRestarts
[16:11:00.968]                           grepl <- base::grepl
[16:11:00.968]                           restarts <- computeRestarts(cond)
[16:11:00.968]                           for (restart in restarts) {
[16:11:00.968]                             name <- restart$name
[16:11:00.968]                             if (is.null(name)) 
[16:11:00.968]                               next
[16:11:00.968]                             if (!grepl(pattern, name)) 
[16:11:00.968]                               next
[16:11:00.968]                             invokeRestart(restart)
[16:11:00.968]                             muffled <- TRUE
[16:11:00.968]                             break
[16:11:00.968]                           }
[16:11:00.968]                         }
[16:11:00.968]                       }
[16:11:00.968]                       invisible(muffled)
[16:11:00.968]                     }
[16:11:00.968]                     muffleCondition(cond, pattern = "^muffle")
[16:11:00.968]                   }
[16:11:00.968]                 }
[16:11:00.968]             }
[16:11:00.968]         }))
[16:11:00.968]     }, error = function(ex) {
[16:11:00.968]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:00.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:00.968]                 ...future.rng), started = ...future.startTime, 
[16:11:00.968]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:00.968]             version = "1.8"), class = "FutureResult")
[16:11:00.968]     }, finally = {
[16:11:00.968]         if (!identical(...future.workdir, getwd())) 
[16:11:00.968]             setwd(...future.workdir)
[16:11:00.968]         {
[16:11:00.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:00.968]                 ...future.oldOptions$nwarnings <- NULL
[16:11:00.968]             }
[16:11:00.968]             base::options(...future.oldOptions)
[16:11:00.968]             if (.Platform$OS.type == "windows") {
[16:11:00.968]                 old_names <- names(...future.oldEnvVars)
[16:11:00.968]                 envs <- base::Sys.getenv()
[16:11:00.968]                 names <- names(envs)
[16:11:00.968]                 common <- intersect(names, old_names)
[16:11:00.968]                 added <- setdiff(names, old_names)
[16:11:00.968]                 removed <- setdiff(old_names, names)
[16:11:00.968]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:00.968]                   envs[common]]
[16:11:00.968]                 NAMES <- toupper(changed)
[16:11:00.968]                 args <- list()
[16:11:00.968]                 for (kk in seq_along(NAMES)) {
[16:11:00.968]                   name <- changed[[kk]]
[16:11:00.968]                   NAME <- NAMES[[kk]]
[16:11:00.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.968]                     next
[16:11:00.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.968]                 }
[16:11:00.968]                 NAMES <- toupper(added)
[16:11:00.968]                 for (kk in seq_along(NAMES)) {
[16:11:00.968]                   name <- added[[kk]]
[16:11:00.968]                   NAME <- NAMES[[kk]]
[16:11:00.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.968]                     next
[16:11:00.968]                   args[[name]] <- ""
[16:11:00.968]                 }
[16:11:00.968]                 NAMES <- toupper(removed)
[16:11:00.968]                 for (kk in seq_along(NAMES)) {
[16:11:00.968]                   name <- removed[[kk]]
[16:11:00.968]                   NAME <- NAMES[[kk]]
[16:11:00.968]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:00.968]                     next
[16:11:00.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:00.968]                 }
[16:11:00.968]                 if (length(args) > 0) 
[16:11:00.968]                   base::do.call(base::Sys.setenv, args = args)
[16:11:00.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:00.968]             }
[16:11:00.968]             else {
[16:11:00.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:00.968]             }
[16:11:00.968]             {
[16:11:00.968]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:00.968]                   0L) {
[16:11:00.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:00.968]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:00.968]                   base::options(opts)
[16:11:00.968]                 }
[16:11:00.968]                 {
[16:11:00.968]                   {
[16:11:00.968]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:00.968]                     NULL
[16:11:00.968]                   }
[16:11:00.968]                   options(future.plan = NULL)
[16:11:00.968]                   if (is.na(NA_character_)) 
[16:11:00.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:00.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:00.968]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:00.968]                     envir = parent.frame()) 
[16:11:00.968]                   {
[16:11:00.968]                     default_workers <- missing(workers)
[16:11:00.968]                     if (is.function(workers)) 
[16:11:00.968]                       workers <- workers()
[16:11:00.968]                     workers <- structure(as.integer(workers), 
[16:11:00.968]                       class = class(workers))
[16:11:00.968]                     stop_if_not(is.finite(workers), workers >= 
[16:11:00.968]                       1L)
[16:11:00.968]                     if ((workers == 1L && !inherits(workers, 
[16:11:00.968]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:00.968]                       if (default_workers) 
[16:11:00.968]                         supportsMulticore(warn = TRUE)
[16:11:00.968]                       return(sequential(..., envir = envir))
[16:11:00.968]                     }
[16:11:00.968]                     oopts <- options(mc.cores = workers)
[16:11:00.968]                     on.exit(options(oopts))
[16:11:00.968]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:00.968]                       envir = envir)
[16:11:00.968]                     if (!future$lazy) 
[16:11:00.968]                       future <- run(future)
[16:11:00.968]                     invisible(future)
[16:11:00.968]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:00.968]                 }
[16:11:00.968]             }
[16:11:00.968]         }
[16:11:00.968]     })
[16:11:00.968]     if (TRUE) {
[16:11:00.968]         base::sink(type = "output", split = FALSE)
[16:11:00.968]         if (TRUE) {
[16:11:00.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:00.968]         }
[16:11:00.968]         else {
[16:11:00.968]             ...future.result["stdout"] <- base::list(NULL)
[16:11:00.968]         }
[16:11:00.968]         base::close(...future.stdout)
[16:11:00.968]         ...future.stdout <- NULL
[16:11:00.968]     }
[16:11:00.968]     ...future.result$conditions <- ...future.conditions
[16:11:00.968]     ...future.result$finished <- base::Sys.time()
[16:11:00.968]     ...future.result
[16:11:00.968] }
[16:11:00.972] assign_globals() ...
[16:11:00.972] List of 11
[16:11:00.972]  $ ...future.FUN            :function (x, ...)  
[16:11:00.972]  $ x_FUN                    :function (x)  
[16:11:00.972]  $ times                    : int 1
[16:11:00.972]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:00.972]  $ stop_if_not              :function (...)  
[16:11:00.972]  $ dim                      : NULL
[16:11:00.972]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:00.972]  $ future.call.arguments    : list()
[16:11:00.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:00.972]  $ ...future.elements_ii    :List of 5
[16:11:00.972]   ..$ : int 6
[16:11:00.972]   ..$ : int 7
[16:11:00.972]   ..$ : int 8
[16:11:00.972]   ..$ : int 9
[16:11:00.972]   ..$ : int 10
[16:11:00.972]  $ ...future.seeds_ii       : NULL
[16:11:00.972]  $ ...future.globals.maxSize: NULL
[16:11:00.972]  - attr(*, "resolved")= logi FALSE
[16:11:00.972]  - attr(*, "total_size")= num 94336
[16:11:00.972]  - attr(*, "where")=List of 11
[16:11:00.972]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:00.972]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:00.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:00.972]  - attr(*, "already-done")= logi TRUE
[16:11:00.989] - copied ‘...future.FUN’ to environment
[16:11:00.989] - copied ‘x_FUN’ to environment
[16:11:00.989] - copied ‘times’ to environment
[16:11:00.989] - copied ‘stopf’ to environment
[16:11:00.989] - copied ‘stop_if_not’ to environment
[16:11:00.989] - copied ‘dim’ to environment
[16:11:00.990] - copied ‘valid_types’ to environment
[16:11:00.990] - copied ‘future.call.arguments’ to environment
[16:11:00.990] - copied ‘...future.elements_ii’ to environment
[16:11:00.990] - copied ‘...future.seeds_ii’ to environment
[16:11:00.990] - copied ‘...future.globals.maxSize’ to environment
[16:11:00.990] assign_globals() ... done
[16:11:00.990] requestCore(): workers = 2
[16:11:00.992] MulticoreFuture started
[16:11:00.993] - Launch lazy future ... done
[16:11:00.993] run() for ‘MulticoreFuture’ ... done
[16:11:00.993] Created future:
[16:11:00.994] plan(): Setting new future strategy stack:
[16:11:00.994] List of future strategies:
[16:11:00.994] 1. sequential:
[16:11:00.994]    - args: function (..., envir = parent.frame())
[16:11:00.994]    - tweaked: FALSE
[16:11:00.994]    - call: NULL
[16:11:00.995] plan(): nbrOfWorkers() = 1
[16:11:00.997] plan(): Setting new future strategy stack:
[16:11:00.997] List of future strategies:
[16:11:00.997] 1. multicore:
[16:11:00.997]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:00.997]    - tweaked: FALSE
[16:11:00.997]    - call: plan(strategy)
[16:11:01.003] plan(): nbrOfWorkers() = 2
[16:11:00.993] MulticoreFuture:
[16:11:00.993] Label: ‘future_vapply-2’
[16:11:00.993] Expression:
[16:11:00.993] {
[16:11:00.993]     do.call(function(...) {
[16:11:00.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:00.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:00.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:00.993]             on.exit(options(oopts), add = TRUE)
[16:11:00.993]         }
[16:11:00.993]         {
[16:11:00.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:00.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:00.993]                 ...future.FUN(...future.X_jj, ...)
[16:11:00.993]             })
[16:11:00.993]         }
[16:11:00.993]     }, args = future.call.arguments)
[16:11:00.993] }
[16:11:00.993] Lazy evaluation: FALSE
[16:11:00.993] Asynchronous evaluation: TRUE
[16:11:00.993] Local evaluation: TRUE
[16:11:00.993] Environment: R_GlobalEnv
[16:11:00.993] Capture standard output: TRUE
[16:11:00.993] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:00.993] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:00.993] Packages: 1 packages (‘future.apply’)
[16:11:00.993] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:00.993] Resolved: TRUE
[16:11:00.993] Value: <not collected>
[16:11:00.993] Conditions captured: <none>
[16:11:00.993] Early signaling: FALSE
[16:11:00.993] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:00.993] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.004] Chunk #2 of 2 ... DONE
[16:11:01.004] Launching 2 futures (chunks) ... DONE
[16:11:01.004] Resolving 2 futures (chunks) ...
[16:11:01.004] resolve() on list ...
[16:11:01.004]  recursive: 0
[16:11:01.005]  length: 2
[16:11:01.005] 
[16:11:01.005] Future #1
[16:11:01.006] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:01.006] - nx: 2
[16:11:01.006] - relay: TRUE
[16:11:01.006] - stdout: TRUE
[16:11:01.006] - signal: TRUE
[16:11:01.007] - resignal: FALSE
[16:11:01.007] - force: TRUE
[16:11:01.007] - relayed: [n=2] FALSE, FALSE
[16:11:01.007] - queued futures: [n=2] FALSE, FALSE
[16:11:01.007]  - until=1
[16:11:01.007]  - relaying element #1
[16:11:01.008] - relayed: [n=2] TRUE, FALSE
[16:11:01.008] - queued futures: [n=2] TRUE, FALSE
[16:11:01.008] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:01.008]  length: 1 (resolved future 1)
[16:11:01.009] Future #2
[16:11:01.009] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:01.010] - nx: 2
[16:11:01.010] - relay: TRUE
[16:11:01.010] - stdout: TRUE
[16:11:01.010] - signal: TRUE
[16:11:01.010] - resignal: FALSE
[16:11:01.010] - force: TRUE
[16:11:01.010] - relayed: [n=2] TRUE, FALSE
[16:11:01.011] - queued futures: [n=2] TRUE, FALSE
[16:11:01.011]  - until=2
[16:11:01.011]  - relaying element #2
[16:11:01.011] - relayed: [n=2] TRUE, TRUE
[16:11:01.011] - queued futures: [n=2] TRUE, TRUE
[16:11:01.011] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:01.012]  length: 0 (resolved future 2)
[16:11:01.012] Relaying remaining futures
[16:11:01.012] signalConditionsASAP(NULL, pos=0) ...
[16:11:01.012] - nx: 2
[16:11:01.012] - relay: TRUE
[16:11:01.012] - stdout: TRUE
[16:11:01.012] - signal: TRUE
[16:11:01.012] - resignal: FALSE
[16:11:01.012] - force: TRUE
[16:11:01.013] - relayed: [n=2] TRUE, TRUE
[16:11:01.013] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:01.013] - relayed: [n=2] TRUE, TRUE
[16:11:01.013] - queued futures: [n=2] TRUE, TRUE
[16:11:01.013] signalConditionsASAP(NULL, pos=0) ... done
[16:11:01.013] resolve() on list ... DONE
[16:11:01.013]  - Number of value chunks collected: 2
[16:11:01.014] Resolving 2 futures (chunks) ... DONE
[16:11:01.014] Reducing values from 2 chunks ...
[16:11:01.014]  - Number of values collected after concatenation: 10
[16:11:01.014]  - Number of values expected: 10
[16:11:01.014] Reducing values from 2 chunks ... DONE
[16:11:01.014] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:11:01.015] future_lapply() ...
[16:11:01.024] Number of chunks: 2
[16:11:01.025] getGlobalsAndPackagesXApply() ...
[16:11:01.025]  - future.globals: TRUE
[16:11:01.025] getGlobalsAndPackages() ...
[16:11:01.025] Searching for globals...
[16:11:01.030] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:11:01.030] Searching for globals ... DONE
[16:11:01.030] Resolving globals: FALSE
[16:11:01.031] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:11:01.031] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:01.031] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.032] - packages: [1] ‘future.apply’
[16:11:01.032] getGlobalsAndPackages() ... DONE
[16:11:01.032]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.032]  - needed namespaces: [n=1] ‘future.apply’
[16:11:01.032] Finding globals ... DONE
[16:11:01.032]  - use_args: TRUE
[16:11:01.032]  - Getting '...' globals ...
[16:11:01.033] resolve() on list ...
[16:11:01.033]  recursive: 0
[16:11:01.033]  length: 1
[16:11:01.033]  elements: ‘...’
[16:11:01.033]  length: 0 (resolved future 1)
[16:11:01.033] resolve() on list ... DONE
[16:11:01.033]    - '...' content: [n=0] 
[16:11:01.033] List of 1
[16:11:01.033]  $ ...: list()
[16:11:01.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.033]  - attr(*, "where")=List of 1
[16:11:01.033]   ..$ ...:<environment: 0x561e8a6bc940> 
[16:11:01.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.033]  - attr(*, "resolved")= logi TRUE
[16:11:01.033]  - attr(*, "total_size")= num NA
[16:11:01.036]  - Getting '...' globals ... DONE
[16:11:01.036] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:01.036] List of 8
[16:11:01.036]  $ ...future.FUN:function (x, ...)  
[16:11:01.036]  $ x_FUN        :function (x)  
[16:11:01.036]  $ times        : int 2
[16:11:01.036]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.036]  $ stop_if_not  :function (...)  
[16:11:01.036]  $ dim          : NULL
[16:11:01.036]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:01.036]  $ ...          : list()
[16:11:01.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.036]  - attr(*, "where")=List of 8
[16:11:01.036]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:01.036]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:01.036]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:01.036]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:01.036]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:01.036]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:01.036]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:01.036]   ..$ ...          :<environment: 0x561e8a6bc940> 
[16:11:01.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.036]  - attr(*, "resolved")= logi FALSE
[16:11:01.036]  - attr(*, "total_size")= num 96456
[16:11:01.044] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:01.044] getGlobalsAndPackagesXApply() ... DONE
[16:11:01.044] Number of futures (= number of chunks): 2
[16:11:01.044] Launching 2 futures (chunks) ...
[16:11:01.044] Chunk #1 of 2 ...
[16:11:01.044]  - Finding globals in 'X' for chunk #1 ...
[16:11:01.045] getGlobalsAndPackages() ...
[16:11:01.045] Searching for globals...
[16:11:01.045] 
[16:11:01.045] Searching for globals ... DONE
[16:11:01.045] - globals: [0] <none>
[16:11:01.045] getGlobalsAndPackages() ... DONE
[16:11:01.045]    + additional globals found: [n=0] 
[16:11:01.045]    + additional namespaces needed: [n=0] 
[16:11:01.045]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:01.046]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:01.046]  - seeds: <none>
[16:11:01.046] getGlobalsAndPackages() ...
[16:11:01.046] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.046] Resolving globals: FALSE
[16:11:01.046] Tweak future expression to call with '...' arguments ...
[16:11:01.046] {
[16:11:01.046]     do.call(function(...) {
[16:11:01.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.046]             on.exit(options(oopts), add = TRUE)
[16:11:01.046]         }
[16:11:01.046]         {
[16:11:01.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.046]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.046]             })
[16:11:01.046]         }
[16:11:01.046]     }, args = future.call.arguments)
[16:11:01.046] }
[16:11:01.046] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.047] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.047] - packages: [1] ‘future.apply’
[16:11:01.047] getGlobalsAndPackages() ... DONE
[16:11:01.047] run() for ‘Future’ ...
[16:11:01.048] - state: ‘created’
[16:11:01.048] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.051] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.051]   - Field: ‘label’
[16:11:01.052]   - Field: ‘local’
[16:11:01.052]   - Field: ‘owner’
[16:11:01.052]   - Field: ‘envir’
[16:11:01.052]   - Field: ‘workers’
[16:11:01.052]   - Field: ‘packages’
[16:11:01.052]   - Field: ‘gc’
[16:11:01.052]   - Field: ‘job’
[16:11:01.052]   - Field: ‘conditions’
[16:11:01.052]   - Field: ‘expr’
[16:11:01.052]   - Field: ‘uuid’
[16:11:01.053]   - Field: ‘seed’
[16:11:01.053]   - Field: ‘version’
[16:11:01.053]   - Field: ‘result’
[16:11:01.053]   - Field: ‘asynchronous’
[16:11:01.053]   - Field: ‘calls’
[16:11:01.053]   - Field: ‘globals’
[16:11:01.053]   - Field: ‘stdout’
[16:11:01.053]   - Field: ‘earlySignal’
[16:11:01.053]   - Field: ‘lazy’
[16:11:01.053]   - Field: ‘state’
[16:11:01.053] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.054] - Launch lazy future ...
[16:11:01.054] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:01.054] Packages needed by future strategies (n = 0): <none>
[16:11:01.054] {
[16:11:01.054]     {
[16:11:01.054]         {
[16:11:01.054]             ...future.startTime <- base::Sys.time()
[16:11:01.054]             {
[16:11:01.054]                 {
[16:11:01.054]                   {
[16:11:01.054]                     {
[16:11:01.054]                       {
[16:11:01.054]                         base::local({
[16:11:01.054]                           has_future <- base::requireNamespace("future", 
[16:11:01.054]                             quietly = TRUE)
[16:11:01.054]                           if (has_future) {
[16:11:01.054]                             ns <- base::getNamespace("future")
[16:11:01.054]                             version <- ns[[".package"]][["version"]]
[16:11:01.054]                             if (is.null(version)) 
[16:11:01.054]                               version <- utils::packageVersion("future")
[16:11:01.054]                           }
[16:11:01.054]                           else {
[16:11:01.054]                             version <- NULL
[16:11:01.054]                           }
[16:11:01.054]                           if (!has_future || version < "1.8.0") {
[16:11:01.054]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.054]                               "", base::R.version$version.string), 
[16:11:01.054]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.054]                                 base::R.version$platform, 8 * 
[16:11:01.054]                                   base::.Machine$sizeof.pointer), 
[16:11:01.054]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.054]                                 "release", "version")], collapse = " "), 
[16:11:01.054]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.054]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.054]                               info)
[16:11:01.054]                             info <- base::paste(info, collapse = "; ")
[16:11:01.054]                             if (!has_future) {
[16:11:01.054]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.054]                                 info)
[16:11:01.054]                             }
[16:11:01.054]                             else {
[16:11:01.054]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.054]                                 info, version)
[16:11:01.054]                             }
[16:11:01.054]                             base::stop(msg)
[16:11:01.054]                           }
[16:11:01.054]                         })
[16:11:01.054]                       }
[16:11:01.054]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.054]                       base::options(mc.cores = 1L)
[16:11:01.054]                     }
[16:11:01.054]                     base::local({
[16:11:01.054]                       for (pkg in "future.apply") {
[16:11:01.054]                         base::loadNamespace(pkg)
[16:11:01.054]                         base::library(pkg, character.only = TRUE)
[16:11:01.054]                       }
[16:11:01.054]                     })
[16:11:01.054]                   }
[16:11:01.054]                   options(future.plan = NULL)
[16:11:01.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.054]                 }
[16:11:01.054]                 ...future.workdir <- getwd()
[16:11:01.054]             }
[16:11:01.054]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.054]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.054]         }
[16:11:01.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.054]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:01.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.054]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.054]             base::names(...future.oldOptions))
[16:11:01.054]     }
[16:11:01.054]     if (FALSE) {
[16:11:01.054]     }
[16:11:01.054]     else {
[16:11:01.054]         if (TRUE) {
[16:11:01.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.054]                 open = "w")
[16:11:01.054]         }
[16:11:01.054]         else {
[16:11:01.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.054]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.054]         }
[16:11:01.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.054]             base::sink(type = "output", split = FALSE)
[16:11:01.054]             base::close(...future.stdout)
[16:11:01.054]         }, add = TRUE)
[16:11:01.054]     }
[16:11:01.054]     ...future.frame <- base::sys.nframe()
[16:11:01.054]     ...future.conditions <- base::list()
[16:11:01.054]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.054]     if (FALSE) {
[16:11:01.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.054]     }
[16:11:01.054]     ...future.result <- base::tryCatch({
[16:11:01.054]         base::withCallingHandlers({
[16:11:01.054]             ...future.value <- base::withVisible(base::local({
[16:11:01.054]                 withCallingHandlers({
[16:11:01.054]                   {
[16:11:01.054]                     do.call(function(...) {
[16:11:01.054]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.054]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.054]                         ...future.globals.maxSize)) {
[16:11:01.054]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.054]                         on.exit(options(oopts), add = TRUE)
[16:11:01.054]                       }
[16:11:01.054]                       {
[16:11:01.054]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.054]                           FUN = function(jj) {
[16:11:01.054]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.054]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.054]                           })
[16:11:01.054]                       }
[16:11:01.054]                     }, args = future.call.arguments)
[16:11:01.054]                   }
[16:11:01.054]                 }, immediateCondition = function(cond) {
[16:11:01.054]                   save_rds <- function (object, pathname, ...) 
[16:11:01.054]                   {
[16:11:01.054]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.054]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.054]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.054]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.054]                         fi_tmp[["mtime"]])
[16:11:01.054]                     }
[16:11:01.054]                     tryCatch({
[16:11:01.054]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.054]                     }, error = function(ex) {
[16:11:01.054]                       msg <- conditionMessage(ex)
[16:11:01.054]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.054]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.054]                         fi_tmp[["mtime"]], msg)
[16:11:01.054]                       ex$message <- msg
[16:11:01.054]                       stop(ex)
[16:11:01.054]                     })
[16:11:01.054]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.054]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.054]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.054]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.054]                       fi <- file.info(pathname)
[16:11:01.054]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.054]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.054]                         fi[["size"]], fi[["mtime"]])
[16:11:01.054]                       stop(msg)
[16:11:01.054]                     }
[16:11:01.054]                     invisible(pathname)
[16:11:01.054]                   }
[16:11:01.054]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.054]                     rootPath = tempdir()) 
[16:11:01.054]                   {
[16:11:01.054]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.054]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.054]                       tmpdir = path, fileext = ".rds")
[16:11:01.054]                     save_rds(obj, file)
[16:11:01.054]                   }
[16:11:01.054]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.054]                   {
[16:11:01.054]                     inherits <- base::inherits
[16:11:01.054]                     invokeRestart <- base::invokeRestart
[16:11:01.054]                     is.null <- base::is.null
[16:11:01.054]                     muffled <- FALSE
[16:11:01.054]                     if (inherits(cond, "message")) {
[16:11:01.054]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.054]                       if (muffled) 
[16:11:01.054]                         invokeRestart("muffleMessage")
[16:11:01.054]                     }
[16:11:01.054]                     else if (inherits(cond, "warning")) {
[16:11:01.054]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.054]                       if (muffled) 
[16:11:01.054]                         invokeRestart("muffleWarning")
[16:11:01.054]                     }
[16:11:01.054]                     else if (inherits(cond, "condition")) {
[16:11:01.054]                       if (!is.null(pattern)) {
[16:11:01.054]                         computeRestarts <- base::computeRestarts
[16:11:01.054]                         grepl <- base::grepl
[16:11:01.054]                         restarts <- computeRestarts(cond)
[16:11:01.054]                         for (restart in restarts) {
[16:11:01.054]                           name <- restart$name
[16:11:01.054]                           if (is.null(name)) 
[16:11:01.054]                             next
[16:11:01.054]                           if (!grepl(pattern, name)) 
[16:11:01.054]                             next
[16:11:01.054]                           invokeRestart(restart)
[16:11:01.054]                           muffled <- TRUE
[16:11:01.054]                           break
[16:11:01.054]                         }
[16:11:01.054]                       }
[16:11:01.054]                     }
[16:11:01.054]                     invisible(muffled)
[16:11:01.054]                   }
[16:11:01.054]                   muffleCondition(cond)
[16:11:01.054]                 })
[16:11:01.054]             }))
[16:11:01.054]             future::FutureResult(value = ...future.value$value, 
[16:11:01.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.054]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.054]                     ...future.globalenv.names))
[16:11:01.054]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.054]         }, condition = base::local({
[16:11:01.054]             c <- base::c
[16:11:01.054]             inherits <- base::inherits
[16:11:01.054]             invokeRestart <- base::invokeRestart
[16:11:01.054]             length <- base::length
[16:11:01.054]             list <- base::list
[16:11:01.054]             seq.int <- base::seq.int
[16:11:01.054]             signalCondition <- base::signalCondition
[16:11:01.054]             sys.calls <- base::sys.calls
[16:11:01.054]             `[[` <- base::`[[`
[16:11:01.054]             `+` <- base::`+`
[16:11:01.054]             `<<-` <- base::`<<-`
[16:11:01.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.054]                   3L)]
[16:11:01.054]             }
[16:11:01.054]             function(cond) {
[16:11:01.054]                 is_error <- inherits(cond, "error")
[16:11:01.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.054]                   NULL)
[16:11:01.054]                 if (is_error) {
[16:11:01.054]                   sessionInformation <- function() {
[16:11:01.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.054]                       search = base::search(), system = base::Sys.info())
[16:11:01.054]                   }
[16:11:01.054]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.054]                     cond$call), session = sessionInformation(), 
[16:11:01.054]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.054]                   signalCondition(cond)
[16:11:01.054]                 }
[16:11:01.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.054]                 "immediateCondition"))) {
[16:11:01.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.054]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.054]                   if (TRUE && !signal) {
[16:11:01.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.054]                     {
[16:11:01.054]                       inherits <- base::inherits
[16:11:01.054]                       invokeRestart <- base::invokeRestart
[16:11:01.054]                       is.null <- base::is.null
[16:11:01.054]                       muffled <- FALSE
[16:11:01.054]                       if (inherits(cond, "message")) {
[16:11:01.054]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.054]                         if (muffled) 
[16:11:01.054]                           invokeRestart("muffleMessage")
[16:11:01.054]                       }
[16:11:01.054]                       else if (inherits(cond, "warning")) {
[16:11:01.054]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.054]                         if (muffled) 
[16:11:01.054]                           invokeRestart("muffleWarning")
[16:11:01.054]                       }
[16:11:01.054]                       else if (inherits(cond, "condition")) {
[16:11:01.054]                         if (!is.null(pattern)) {
[16:11:01.054]                           computeRestarts <- base::computeRestarts
[16:11:01.054]                           grepl <- base::grepl
[16:11:01.054]                           restarts <- computeRestarts(cond)
[16:11:01.054]                           for (restart in restarts) {
[16:11:01.054]                             name <- restart$name
[16:11:01.054]                             if (is.null(name)) 
[16:11:01.054]                               next
[16:11:01.054]                             if (!grepl(pattern, name)) 
[16:11:01.054]                               next
[16:11:01.054]                             invokeRestart(restart)
[16:11:01.054]                             muffled <- TRUE
[16:11:01.054]                             break
[16:11:01.054]                           }
[16:11:01.054]                         }
[16:11:01.054]                       }
[16:11:01.054]                       invisible(muffled)
[16:11:01.054]                     }
[16:11:01.054]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.054]                   }
[16:11:01.054]                 }
[16:11:01.054]                 else {
[16:11:01.054]                   if (TRUE) {
[16:11:01.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.054]                     {
[16:11:01.054]                       inherits <- base::inherits
[16:11:01.054]                       invokeRestart <- base::invokeRestart
[16:11:01.054]                       is.null <- base::is.null
[16:11:01.054]                       muffled <- FALSE
[16:11:01.054]                       if (inherits(cond, "message")) {
[16:11:01.054]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.054]                         if (muffled) 
[16:11:01.054]                           invokeRestart("muffleMessage")
[16:11:01.054]                       }
[16:11:01.054]                       else if (inherits(cond, "warning")) {
[16:11:01.054]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.054]                         if (muffled) 
[16:11:01.054]                           invokeRestart("muffleWarning")
[16:11:01.054]                       }
[16:11:01.054]                       else if (inherits(cond, "condition")) {
[16:11:01.054]                         if (!is.null(pattern)) {
[16:11:01.054]                           computeRestarts <- base::computeRestarts
[16:11:01.054]                           grepl <- base::grepl
[16:11:01.054]                           restarts <- computeRestarts(cond)
[16:11:01.054]                           for (restart in restarts) {
[16:11:01.054]                             name <- restart$name
[16:11:01.054]                             if (is.null(name)) 
[16:11:01.054]                               next
[16:11:01.054]                             if (!grepl(pattern, name)) 
[16:11:01.054]                               next
[16:11:01.054]                             invokeRestart(restart)
[16:11:01.054]                             muffled <- TRUE
[16:11:01.054]                             break
[16:11:01.054]                           }
[16:11:01.054]                         }
[16:11:01.054]                       }
[16:11:01.054]                       invisible(muffled)
[16:11:01.054]                     }
[16:11:01.054]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.054]                   }
[16:11:01.054]                 }
[16:11:01.054]             }
[16:11:01.054]         }))
[16:11:01.054]     }, error = function(ex) {
[16:11:01.054]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.054]                 ...future.rng), started = ...future.startTime, 
[16:11:01.054]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.054]             version = "1.8"), class = "FutureResult")
[16:11:01.054]     }, finally = {
[16:11:01.054]         if (!identical(...future.workdir, getwd())) 
[16:11:01.054]             setwd(...future.workdir)
[16:11:01.054]         {
[16:11:01.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.054]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.054]             }
[16:11:01.054]             base::options(...future.oldOptions)
[16:11:01.054]             if (.Platform$OS.type == "windows") {
[16:11:01.054]                 old_names <- names(...future.oldEnvVars)
[16:11:01.054]                 envs <- base::Sys.getenv()
[16:11:01.054]                 names <- names(envs)
[16:11:01.054]                 common <- intersect(names, old_names)
[16:11:01.054]                 added <- setdiff(names, old_names)
[16:11:01.054]                 removed <- setdiff(old_names, names)
[16:11:01.054]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.054]                   envs[common]]
[16:11:01.054]                 NAMES <- toupper(changed)
[16:11:01.054]                 args <- list()
[16:11:01.054]                 for (kk in seq_along(NAMES)) {
[16:11:01.054]                   name <- changed[[kk]]
[16:11:01.054]                   NAME <- NAMES[[kk]]
[16:11:01.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.054]                     next
[16:11:01.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.054]                 }
[16:11:01.054]                 NAMES <- toupper(added)
[16:11:01.054]                 for (kk in seq_along(NAMES)) {
[16:11:01.054]                   name <- added[[kk]]
[16:11:01.054]                   NAME <- NAMES[[kk]]
[16:11:01.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.054]                     next
[16:11:01.054]                   args[[name]] <- ""
[16:11:01.054]                 }
[16:11:01.054]                 NAMES <- toupper(removed)
[16:11:01.054]                 for (kk in seq_along(NAMES)) {
[16:11:01.054]                   name <- removed[[kk]]
[16:11:01.054]                   NAME <- NAMES[[kk]]
[16:11:01.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.054]                     next
[16:11:01.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.054]                 }
[16:11:01.054]                 if (length(args) > 0) 
[16:11:01.054]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.054]             }
[16:11:01.054]             else {
[16:11:01.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.054]             }
[16:11:01.054]             {
[16:11:01.054]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.054]                   0L) {
[16:11:01.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.054]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.054]                   base::options(opts)
[16:11:01.054]                 }
[16:11:01.054]                 {
[16:11:01.054]                   {
[16:11:01.054]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.054]                     NULL
[16:11:01.054]                   }
[16:11:01.054]                   options(future.plan = NULL)
[16:11:01.054]                   if (is.na(NA_character_)) 
[16:11:01.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.054]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.054]                     envir = parent.frame()) 
[16:11:01.054]                   {
[16:11:01.054]                     default_workers <- missing(workers)
[16:11:01.054]                     if (is.function(workers)) 
[16:11:01.054]                       workers <- workers()
[16:11:01.054]                     workers <- structure(as.integer(workers), 
[16:11:01.054]                       class = class(workers))
[16:11:01.054]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.054]                       1L)
[16:11:01.054]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.054]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.054]                       if (default_workers) 
[16:11:01.054]                         supportsMulticore(warn = TRUE)
[16:11:01.054]                       return(sequential(..., envir = envir))
[16:11:01.054]                     }
[16:11:01.054]                     oopts <- options(mc.cores = workers)
[16:11:01.054]                     on.exit(options(oopts))
[16:11:01.054]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.054]                       envir = envir)
[16:11:01.054]                     if (!future$lazy) 
[16:11:01.054]                       future <- run(future)
[16:11:01.054]                     invisible(future)
[16:11:01.054]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.054]                 }
[16:11:01.054]             }
[16:11:01.054]         }
[16:11:01.054]     })
[16:11:01.054]     if (TRUE) {
[16:11:01.054]         base::sink(type = "output", split = FALSE)
[16:11:01.054]         if (TRUE) {
[16:11:01.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.054]         }
[16:11:01.054]         else {
[16:11:01.054]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.054]         }
[16:11:01.054]         base::close(...future.stdout)
[16:11:01.054]         ...future.stdout <- NULL
[16:11:01.054]     }
[16:11:01.054]     ...future.result$conditions <- ...future.conditions
[16:11:01.054]     ...future.result$finished <- base::Sys.time()
[16:11:01.054]     ...future.result
[16:11:01.054] }
[16:11:01.057] assign_globals() ...
[16:11:01.057] List of 11
[16:11:01.057]  $ ...future.FUN            :function (x, ...)  
[16:11:01.057]  $ x_FUN                    :function (x)  
[16:11:01.057]  $ times                    : int 2
[16:11:01.057]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.057]  $ stop_if_not              :function (...)  
[16:11:01.057]  $ dim                      : NULL
[16:11:01.057]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.057]  $ future.call.arguments    : list()
[16:11:01.057]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.057]  $ ...future.elements_ii    :List of 5
[16:11:01.057]   ..$ : int 1
[16:11:01.057]   ..$ : int 2
[16:11:01.057]   ..$ : int 3
[16:11:01.057]   ..$ : int 4
[16:11:01.057]   ..$ : int 5
[16:11:01.057]  $ ...future.seeds_ii       : NULL
[16:11:01.057]  $ ...future.globals.maxSize: NULL
[16:11:01.057]  - attr(*, "resolved")= logi FALSE
[16:11:01.057]  - attr(*, "total_size")= num 96456
[16:11:01.057]  - attr(*, "where")=List of 11
[16:11:01.057]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.057]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.057]  - attr(*, "already-done")= logi TRUE
[16:11:01.068] - copied ‘...future.FUN’ to environment
[16:11:01.069] - reassign environment for ‘x_FUN’
[16:11:01.069] - copied ‘x_FUN’ to environment
[16:11:01.069] - copied ‘times’ to environment
[16:11:01.069] - copied ‘stopf’ to environment
[16:11:01.069] - copied ‘stop_if_not’ to environment
[16:11:01.069] - copied ‘dim’ to environment
[16:11:01.069] - copied ‘valid_types’ to environment
[16:11:01.069] - copied ‘future.call.arguments’ to environment
[16:11:01.069] - copied ‘...future.elements_ii’ to environment
[16:11:01.070] - copied ‘...future.seeds_ii’ to environment
[16:11:01.070] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.070] assign_globals() ... done
[16:11:01.070] requestCore(): workers = 2
[16:11:01.072] MulticoreFuture started
[16:11:01.073] - Launch lazy future ... done
[16:11:01.073] run() for ‘MulticoreFuture’ ... done
[16:11:01.073] Created future:
[16:11:01.074] plan(): Setting new future strategy stack:
[16:11:01.074] List of future strategies:
[16:11:01.074] 1. sequential:
[16:11:01.074]    - args: function (..., envir = parent.frame())
[16:11:01.074]    - tweaked: FALSE
[16:11:01.074]    - call: NULL
[16:11:01.075] plan(): nbrOfWorkers() = 1
[16:11:01.078] plan(): Setting new future strategy stack:
[16:11:01.078] List of future strategies:
[16:11:01.078] 1. multicore:
[16:11:01.078]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.078]    - tweaked: FALSE
[16:11:01.078]    - call: plan(strategy)
[16:11:01.084] plan(): nbrOfWorkers() = 2
[16:11:01.074] MulticoreFuture:
[16:11:01.074] Label: ‘future_vapply-1’
[16:11:01.074] Expression:
[16:11:01.074] {
[16:11:01.074]     do.call(function(...) {
[16:11:01.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.074]             on.exit(options(oopts), add = TRUE)
[16:11:01.074]         }
[16:11:01.074]         {
[16:11:01.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.074]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.074]             })
[16:11:01.074]         }
[16:11:01.074]     }, args = future.call.arguments)
[16:11:01.074] }
[16:11:01.074] Lazy evaluation: FALSE
[16:11:01.074] Asynchronous evaluation: TRUE
[16:11:01.074] Local evaluation: TRUE
[16:11:01.074] Environment: R_GlobalEnv
[16:11:01.074] Capture standard output: TRUE
[16:11:01.074] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.074] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.074] Packages: 1 packages (‘future.apply’)
[16:11:01.074] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.074] Resolved: TRUE
[16:11:01.074] Value: <not collected>
[16:11:01.074] Conditions captured: <none>
[16:11:01.074] Early signaling: FALSE
[16:11:01.074] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.074] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.085] Chunk #1 of 2 ... DONE
[16:11:01.085] Chunk #2 of 2 ...
[16:11:01.086]  - Finding globals in 'X' for chunk #2 ...
[16:11:01.086] getGlobalsAndPackages() ...
[16:11:01.086] Searching for globals...
[16:11:01.086] 
[16:11:01.086] Searching for globals ... DONE
[16:11:01.087] - globals: [0] <none>
[16:11:01.087] getGlobalsAndPackages() ... DONE
[16:11:01.087]    + additional globals found: [n=0] 
[16:11:01.087]    + additional namespaces needed: [n=0] 
[16:11:01.087]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:01.087]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:01.088]  - seeds: <none>
[16:11:01.088] getGlobalsAndPackages() ...
[16:11:01.088] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.088] Resolving globals: FALSE
[16:11:01.088] Tweak future expression to call with '...' arguments ...
[16:11:01.089] {
[16:11:01.089]     do.call(function(...) {
[16:11:01.089]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.089]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.089]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.089]             on.exit(options(oopts), add = TRUE)
[16:11:01.089]         }
[16:11:01.089]         {
[16:11:01.089]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.089]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.089]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.089]             })
[16:11:01.089]         }
[16:11:01.089]     }, args = future.call.arguments)
[16:11:01.089] }
[16:11:01.089] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.090] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.090] - packages: [1] ‘future.apply’
[16:11:01.090] getGlobalsAndPackages() ... DONE
[16:11:01.091] run() for ‘Future’ ...
[16:11:01.091] - state: ‘created’
[16:11:01.091] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.096] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.096] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.096]   - Field: ‘label’
[16:11:01.096]   - Field: ‘local’
[16:11:01.097]   - Field: ‘owner’
[16:11:01.097]   - Field: ‘envir’
[16:11:01.097]   - Field: ‘workers’
[16:11:01.097]   - Field: ‘packages’
[16:11:01.097]   - Field: ‘gc’
[16:11:01.097]   - Field: ‘job’
[16:11:01.098]   - Field: ‘conditions’
[16:11:01.098]   - Field: ‘expr’
[16:11:01.098]   - Field: ‘uuid’
[16:11:01.098]   - Field: ‘seed’
[16:11:01.098]   - Field: ‘version’
[16:11:01.098]   - Field: ‘result’
[16:11:01.098]   - Field: ‘asynchronous’
[16:11:01.099]   - Field: ‘calls’
[16:11:01.099]   - Field: ‘globals’
[16:11:01.099]   - Field: ‘stdout’
[16:11:01.099]   - Field: ‘earlySignal’
[16:11:01.099]   - Field: ‘lazy’
[16:11:01.099]   - Field: ‘state’
[16:11:01.099] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.100] - Launch lazy future ...
[16:11:01.100] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:01.100] Packages needed by future strategies (n = 0): <none>
[16:11:01.101] {
[16:11:01.101]     {
[16:11:01.101]         {
[16:11:01.101]             ...future.startTime <- base::Sys.time()
[16:11:01.101]             {
[16:11:01.101]                 {
[16:11:01.101]                   {
[16:11:01.101]                     {
[16:11:01.101]                       {
[16:11:01.101]                         base::local({
[16:11:01.101]                           has_future <- base::requireNamespace("future", 
[16:11:01.101]                             quietly = TRUE)
[16:11:01.101]                           if (has_future) {
[16:11:01.101]                             ns <- base::getNamespace("future")
[16:11:01.101]                             version <- ns[[".package"]][["version"]]
[16:11:01.101]                             if (is.null(version)) 
[16:11:01.101]                               version <- utils::packageVersion("future")
[16:11:01.101]                           }
[16:11:01.101]                           else {
[16:11:01.101]                             version <- NULL
[16:11:01.101]                           }
[16:11:01.101]                           if (!has_future || version < "1.8.0") {
[16:11:01.101]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.101]                               "", base::R.version$version.string), 
[16:11:01.101]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.101]                                 base::R.version$platform, 8 * 
[16:11:01.101]                                   base::.Machine$sizeof.pointer), 
[16:11:01.101]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.101]                                 "release", "version")], collapse = " "), 
[16:11:01.101]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.101]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.101]                               info)
[16:11:01.101]                             info <- base::paste(info, collapse = "; ")
[16:11:01.101]                             if (!has_future) {
[16:11:01.101]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.101]                                 info)
[16:11:01.101]                             }
[16:11:01.101]                             else {
[16:11:01.101]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.101]                                 info, version)
[16:11:01.101]                             }
[16:11:01.101]                             base::stop(msg)
[16:11:01.101]                           }
[16:11:01.101]                         })
[16:11:01.101]                       }
[16:11:01.101]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.101]                       base::options(mc.cores = 1L)
[16:11:01.101]                     }
[16:11:01.101]                     base::local({
[16:11:01.101]                       for (pkg in "future.apply") {
[16:11:01.101]                         base::loadNamespace(pkg)
[16:11:01.101]                         base::library(pkg, character.only = TRUE)
[16:11:01.101]                       }
[16:11:01.101]                     })
[16:11:01.101]                   }
[16:11:01.101]                   options(future.plan = NULL)
[16:11:01.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.101]                 }
[16:11:01.101]                 ...future.workdir <- getwd()
[16:11:01.101]             }
[16:11:01.101]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.101]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.101]         }
[16:11:01.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.101]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:01.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.101]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.101]             base::names(...future.oldOptions))
[16:11:01.101]     }
[16:11:01.101]     if (FALSE) {
[16:11:01.101]     }
[16:11:01.101]     else {
[16:11:01.101]         if (TRUE) {
[16:11:01.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.101]                 open = "w")
[16:11:01.101]         }
[16:11:01.101]         else {
[16:11:01.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.101]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.101]         }
[16:11:01.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.101]             base::sink(type = "output", split = FALSE)
[16:11:01.101]             base::close(...future.stdout)
[16:11:01.101]         }, add = TRUE)
[16:11:01.101]     }
[16:11:01.101]     ...future.frame <- base::sys.nframe()
[16:11:01.101]     ...future.conditions <- base::list()
[16:11:01.101]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.101]     if (FALSE) {
[16:11:01.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.101]     }
[16:11:01.101]     ...future.result <- base::tryCatch({
[16:11:01.101]         base::withCallingHandlers({
[16:11:01.101]             ...future.value <- base::withVisible(base::local({
[16:11:01.101]                 withCallingHandlers({
[16:11:01.101]                   {
[16:11:01.101]                     do.call(function(...) {
[16:11:01.101]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.101]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.101]                         ...future.globals.maxSize)) {
[16:11:01.101]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.101]                         on.exit(options(oopts), add = TRUE)
[16:11:01.101]                       }
[16:11:01.101]                       {
[16:11:01.101]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.101]                           FUN = function(jj) {
[16:11:01.101]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.101]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.101]                           })
[16:11:01.101]                       }
[16:11:01.101]                     }, args = future.call.arguments)
[16:11:01.101]                   }
[16:11:01.101]                 }, immediateCondition = function(cond) {
[16:11:01.101]                   save_rds <- function (object, pathname, ...) 
[16:11:01.101]                   {
[16:11:01.101]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.101]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.101]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.101]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.101]                         fi_tmp[["mtime"]])
[16:11:01.101]                     }
[16:11:01.101]                     tryCatch({
[16:11:01.101]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.101]                     }, error = function(ex) {
[16:11:01.101]                       msg <- conditionMessage(ex)
[16:11:01.101]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.101]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.101]                         fi_tmp[["mtime"]], msg)
[16:11:01.101]                       ex$message <- msg
[16:11:01.101]                       stop(ex)
[16:11:01.101]                     })
[16:11:01.101]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.101]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.101]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.101]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.101]                       fi <- file.info(pathname)
[16:11:01.101]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.101]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.101]                         fi[["size"]], fi[["mtime"]])
[16:11:01.101]                       stop(msg)
[16:11:01.101]                     }
[16:11:01.101]                     invisible(pathname)
[16:11:01.101]                   }
[16:11:01.101]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.101]                     rootPath = tempdir()) 
[16:11:01.101]                   {
[16:11:01.101]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.101]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.101]                       tmpdir = path, fileext = ".rds")
[16:11:01.101]                     save_rds(obj, file)
[16:11:01.101]                   }
[16:11:01.101]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.101]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.101]                   {
[16:11:01.101]                     inherits <- base::inherits
[16:11:01.101]                     invokeRestart <- base::invokeRestart
[16:11:01.101]                     is.null <- base::is.null
[16:11:01.101]                     muffled <- FALSE
[16:11:01.101]                     if (inherits(cond, "message")) {
[16:11:01.101]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.101]                       if (muffled) 
[16:11:01.101]                         invokeRestart("muffleMessage")
[16:11:01.101]                     }
[16:11:01.101]                     else if (inherits(cond, "warning")) {
[16:11:01.101]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.101]                       if (muffled) 
[16:11:01.101]                         invokeRestart("muffleWarning")
[16:11:01.101]                     }
[16:11:01.101]                     else if (inherits(cond, "condition")) {
[16:11:01.101]                       if (!is.null(pattern)) {
[16:11:01.101]                         computeRestarts <- base::computeRestarts
[16:11:01.101]                         grepl <- base::grepl
[16:11:01.101]                         restarts <- computeRestarts(cond)
[16:11:01.101]                         for (restart in restarts) {
[16:11:01.101]                           name <- restart$name
[16:11:01.101]                           if (is.null(name)) 
[16:11:01.101]                             next
[16:11:01.101]                           if (!grepl(pattern, name)) 
[16:11:01.101]                             next
[16:11:01.101]                           invokeRestart(restart)
[16:11:01.101]                           muffled <- TRUE
[16:11:01.101]                           break
[16:11:01.101]                         }
[16:11:01.101]                       }
[16:11:01.101]                     }
[16:11:01.101]                     invisible(muffled)
[16:11:01.101]                   }
[16:11:01.101]                   muffleCondition(cond)
[16:11:01.101]                 })
[16:11:01.101]             }))
[16:11:01.101]             future::FutureResult(value = ...future.value$value, 
[16:11:01.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.101]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.101]                     ...future.globalenv.names))
[16:11:01.101]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.101]         }, condition = base::local({
[16:11:01.101]             c <- base::c
[16:11:01.101]             inherits <- base::inherits
[16:11:01.101]             invokeRestart <- base::invokeRestart
[16:11:01.101]             length <- base::length
[16:11:01.101]             list <- base::list
[16:11:01.101]             seq.int <- base::seq.int
[16:11:01.101]             signalCondition <- base::signalCondition
[16:11:01.101]             sys.calls <- base::sys.calls
[16:11:01.101]             `[[` <- base::`[[`
[16:11:01.101]             `+` <- base::`+`
[16:11:01.101]             `<<-` <- base::`<<-`
[16:11:01.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.101]                   3L)]
[16:11:01.101]             }
[16:11:01.101]             function(cond) {
[16:11:01.101]                 is_error <- inherits(cond, "error")
[16:11:01.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.101]                   NULL)
[16:11:01.101]                 if (is_error) {
[16:11:01.101]                   sessionInformation <- function() {
[16:11:01.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.101]                       search = base::search(), system = base::Sys.info())
[16:11:01.101]                   }
[16:11:01.101]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.101]                     cond$call), session = sessionInformation(), 
[16:11:01.101]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.101]                   signalCondition(cond)
[16:11:01.101]                 }
[16:11:01.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.101]                 "immediateCondition"))) {
[16:11:01.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.101]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.101]                   if (TRUE && !signal) {
[16:11:01.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.101]                     {
[16:11:01.101]                       inherits <- base::inherits
[16:11:01.101]                       invokeRestart <- base::invokeRestart
[16:11:01.101]                       is.null <- base::is.null
[16:11:01.101]                       muffled <- FALSE
[16:11:01.101]                       if (inherits(cond, "message")) {
[16:11:01.101]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.101]                         if (muffled) 
[16:11:01.101]                           invokeRestart("muffleMessage")
[16:11:01.101]                       }
[16:11:01.101]                       else if (inherits(cond, "warning")) {
[16:11:01.101]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.101]                         if (muffled) 
[16:11:01.101]                           invokeRestart("muffleWarning")
[16:11:01.101]                       }
[16:11:01.101]                       else if (inherits(cond, "condition")) {
[16:11:01.101]                         if (!is.null(pattern)) {
[16:11:01.101]                           computeRestarts <- base::computeRestarts
[16:11:01.101]                           grepl <- base::grepl
[16:11:01.101]                           restarts <- computeRestarts(cond)
[16:11:01.101]                           for (restart in restarts) {
[16:11:01.101]                             name <- restart$name
[16:11:01.101]                             if (is.null(name)) 
[16:11:01.101]                               next
[16:11:01.101]                             if (!grepl(pattern, name)) 
[16:11:01.101]                               next
[16:11:01.101]                             invokeRestart(restart)
[16:11:01.101]                             muffled <- TRUE
[16:11:01.101]                             break
[16:11:01.101]                           }
[16:11:01.101]                         }
[16:11:01.101]                       }
[16:11:01.101]                       invisible(muffled)
[16:11:01.101]                     }
[16:11:01.101]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.101]                   }
[16:11:01.101]                 }
[16:11:01.101]                 else {
[16:11:01.101]                   if (TRUE) {
[16:11:01.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.101]                     {
[16:11:01.101]                       inherits <- base::inherits
[16:11:01.101]                       invokeRestart <- base::invokeRestart
[16:11:01.101]                       is.null <- base::is.null
[16:11:01.101]                       muffled <- FALSE
[16:11:01.101]                       if (inherits(cond, "message")) {
[16:11:01.101]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.101]                         if (muffled) 
[16:11:01.101]                           invokeRestart("muffleMessage")
[16:11:01.101]                       }
[16:11:01.101]                       else if (inherits(cond, "warning")) {
[16:11:01.101]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.101]                         if (muffled) 
[16:11:01.101]                           invokeRestart("muffleWarning")
[16:11:01.101]                       }
[16:11:01.101]                       else if (inherits(cond, "condition")) {
[16:11:01.101]                         if (!is.null(pattern)) {
[16:11:01.101]                           computeRestarts <- base::computeRestarts
[16:11:01.101]                           grepl <- base::grepl
[16:11:01.101]                           restarts <- computeRestarts(cond)
[16:11:01.101]                           for (restart in restarts) {
[16:11:01.101]                             name <- restart$name
[16:11:01.101]                             if (is.null(name)) 
[16:11:01.101]                               next
[16:11:01.101]                             if (!grepl(pattern, name)) 
[16:11:01.101]                               next
[16:11:01.101]                             invokeRestart(restart)
[16:11:01.101]                             muffled <- TRUE
[16:11:01.101]                             break
[16:11:01.101]                           }
[16:11:01.101]                         }
[16:11:01.101]                       }
[16:11:01.101]                       invisible(muffled)
[16:11:01.101]                     }
[16:11:01.101]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.101]                   }
[16:11:01.101]                 }
[16:11:01.101]             }
[16:11:01.101]         }))
[16:11:01.101]     }, error = function(ex) {
[16:11:01.101]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.101]                 ...future.rng), started = ...future.startTime, 
[16:11:01.101]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.101]             version = "1.8"), class = "FutureResult")
[16:11:01.101]     }, finally = {
[16:11:01.101]         if (!identical(...future.workdir, getwd())) 
[16:11:01.101]             setwd(...future.workdir)
[16:11:01.101]         {
[16:11:01.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.101]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.101]             }
[16:11:01.101]             base::options(...future.oldOptions)
[16:11:01.101]             if (.Platform$OS.type == "windows") {
[16:11:01.101]                 old_names <- names(...future.oldEnvVars)
[16:11:01.101]                 envs <- base::Sys.getenv()
[16:11:01.101]                 names <- names(envs)
[16:11:01.101]                 common <- intersect(names, old_names)
[16:11:01.101]                 added <- setdiff(names, old_names)
[16:11:01.101]                 removed <- setdiff(old_names, names)
[16:11:01.101]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.101]                   envs[common]]
[16:11:01.101]                 NAMES <- toupper(changed)
[16:11:01.101]                 args <- list()
[16:11:01.101]                 for (kk in seq_along(NAMES)) {
[16:11:01.101]                   name <- changed[[kk]]
[16:11:01.101]                   NAME <- NAMES[[kk]]
[16:11:01.101]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.101]                     next
[16:11:01.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.101]                 }
[16:11:01.101]                 NAMES <- toupper(added)
[16:11:01.101]                 for (kk in seq_along(NAMES)) {
[16:11:01.101]                   name <- added[[kk]]
[16:11:01.101]                   NAME <- NAMES[[kk]]
[16:11:01.101]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.101]                     next
[16:11:01.101]                   args[[name]] <- ""
[16:11:01.101]                 }
[16:11:01.101]                 NAMES <- toupper(removed)
[16:11:01.101]                 for (kk in seq_along(NAMES)) {
[16:11:01.101]                   name <- removed[[kk]]
[16:11:01.101]                   NAME <- NAMES[[kk]]
[16:11:01.101]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.101]                     next
[16:11:01.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.101]                 }
[16:11:01.101]                 if (length(args) > 0) 
[16:11:01.101]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.101]             }
[16:11:01.101]             else {
[16:11:01.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.101]             }
[16:11:01.101]             {
[16:11:01.101]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.101]                   0L) {
[16:11:01.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.101]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.101]                   base::options(opts)
[16:11:01.101]                 }
[16:11:01.101]                 {
[16:11:01.101]                   {
[16:11:01.101]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.101]                     NULL
[16:11:01.101]                   }
[16:11:01.101]                   options(future.plan = NULL)
[16:11:01.101]                   if (is.na(NA_character_)) 
[16:11:01.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.101]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.101]                     envir = parent.frame()) 
[16:11:01.101]                   {
[16:11:01.101]                     default_workers <- missing(workers)
[16:11:01.101]                     if (is.function(workers)) 
[16:11:01.101]                       workers <- workers()
[16:11:01.101]                     workers <- structure(as.integer(workers), 
[16:11:01.101]                       class = class(workers))
[16:11:01.101]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.101]                       1L)
[16:11:01.101]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.101]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.101]                       if (default_workers) 
[16:11:01.101]                         supportsMulticore(warn = TRUE)
[16:11:01.101]                       return(sequential(..., envir = envir))
[16:11:01.101]                     }
[16:11:01.101]                     oopts <- options(mc.cores = workers)
[16:11:01.101]                     on.exit(options(oopts))
[16:11:01.101]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.101]                       envir = envir)
[16:11:01.101]                     if (!future$lazy) 
[16:11:01.101]                       future <- run(future)
[16:11:01.101]                     invisible(future)
[16:11:01.101]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.101]                 }
[16:11:01.101]             }
[16:11:01.101]         }
[16:11:01.101]     })
[16:11:01.101]     if (TRUE) {
[16:11:01.101]         base::sink(type = "output", split = FALSE)
[16:11:01.101]         if (TRUE) {
[16:11:01.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.101]         }
[16:11:01.101]         else {
[16:11:01.101]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.101]         }
[16:11:01.101]         base::close(...future.stdout)
[16:11:01.101]         ...future.stdout <- NULL
[16:11:01.101]     }
[16:11:01.101]     ...future.result$conditions <- ...future.conditions
[16:11:01.101]     ...future.result$finished <- base::Sys.time()
[16:11:01.101]     ...future.result
[16:11:01.101] }
[16:11:01.105] assign_globals() ...
[16:11:01.105] List of 11
[16:11:01.105]  $ ...future.FUN            :function (x, ...)  
[16:11:01.105]  $ x_FUN                    :function (x)  
[16:11:01.105]  $ times                    : int 2
[16:11:01.105]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.105]  $ stop_if_not              :function (...)  
[16:11:01.105]  $ dim                      : NULL
[16:11:01.105]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.105]  $ future.call.arguments    : list()
[16:11:01.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.105]  $ ...future.elements_ii    :List of 5
[16:11:01.105]   ..$ : int 6
[16:11:01.105]   ..$ : int 7
[16:11:01.105]   ..$ : int 8
[16:11:01.105]   ..$ : int 9
[16:11:01.105]   ..$ : int 10
[16:11:01.105]  $ ...future.seeds_ii       : NULL
[16:11:01.105]  $ ...future.globals.maxSize: NULL
[16:11:01.105]  - attr(*, "resolved")= logi FALSE
[16:11:01.105]  - attr(*, "total_size")= num 96456
[16:11:01.105]  - attr(*, "where")=List of 11
[16:11:01.105]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.105]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.105]  - attr(*, "already-done")= logi TRUE
[16:11:01.121] - copied ‘...future.FUN’ to environment
[16:11:01.122] - reassign environment for ‘x_FUN’
[16:11:01.122] - copied ‘x_FUN’ to environment
[16:11:01.122] - copied ‘times’ to environment
[16:11:01.122] - copied ‘stopf’ to environment
[16:11:01.122] - copied ‘stop_if_not’ to environment
[16:11:01.122] - copied ‘dim’ to environment
[16:11:01.122] - copied ‘valid_types’ to environment
[16:11:01.122] - copied ‘future.call.arguments’ to environment
[16:11:01.122] - copied ‘...future.elements_ii’ to environment
[16:11:01.123] - copied ‘...future.seeds_ii’ to environment
[16:11:01.123] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.123] assign_globals() ... done
[16:11:01.123] requestCore(): workers = 2
[16:11:01.125] MulticoreFuture started
[16:11:01.126] - Launch lazy future ... done
[16:11:01.126] run() for ‘MulticoreFuture’ ... done
[16:11:01.126] Created future:
[16:11:01.127] plan(): Setting new future strategy stack:
[16:11:01.127] List of future strategies:
[16:11:01.127] 1. sequential:
[16:11:01.127]    - args: function (..., envir = parent.frame())
[16:11:01.127]    - tweaked: FALSE
[16:11:01.127]    - call: NULL
[16:11:01.128] plan(): nbrOfWorkers() = 1
[16:11:01.130] plan(): Setting new future strategy stack:
[16:11:01.130] List of future strategies:
[16:11:01.130] 1. multicore:
[16:11:01.130]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.130]    - tweaked: FALSE
[16:11:01.130]    - call: plan(strategy)
[16:11:01.136] plan(): nbrOfWorkers() = 2
[16:11:01.126] MulticoreFuture:
[16:11:01.126] Label: ‘future_vapply-2’
[16:11:01.126] Expression:
[16:11:01.126] {
[16:11:01.126]     do.call(function(...) {
[16:11:01.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.126]             on.exit(options(oopts), add = TRUE)
[16:11:01.126]         }
[16:11:01.126]         {
[16:11:01.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.126]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.126]             })
[16:11:01.126]         }
[16:11:01.126]     }, args = future.call.arguments)
[16:11:01.126] }
[16:11:01.126] Lazy evaluation: FALSE
[16:11:01.126] Asynchronous evaluation: TRUE
[16:11:01.126] Local evaluation: TRUE
[16:11:01.126] Environment: R_GlobalEnv
[16:11:01.126] Capture standard output: TRUE
[16:11:01.126] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.126] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.126] Packages: 1 packages (‘future.apply’)
[16:11:01.126] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.126] Resolved: TRUE
[16:11:01.126] Value: <not collected>
[16:11:01.126] Conditions captured: <none>
[16:11:01.126] Early signaling: FALSE
[16:11:01.126] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.126] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.137] Chunk #2 of 2 ... DONE
[16:11:01.137] Launching 2 futures (chunks) ... DONE
[16:11:01.137] Resolving 2 futures (chunks) ...
[16:11:01.137] resolve() on list ...
[16:11:01.137]  recursive: 0
[16:11:01.137]  length: 2
[16:11:01.138] 
[16:11:01.138] Future #1
[16:11:01.139] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:01.139] - nx: 2
[16:11:01.139] - relay: TRUE
[16:11:01.139] - stdout: TRUE
[16:11:01.139] - signal: TRUE
[16:11:01.140] - resignal: FALSE
[16:11:01.140] - force: TRUE
[16:11:01.140] - relayed: [n=2] FALSE, FALSE
[16:11:01.140] - queued futures: [n=2] FALSE, FALSE
[16:11:01.140]  - until=1
[16:11:01.140]  - relaying element #1
[16:11:01.141] - relayed: [n=2] TRUE, FALSE
[16:11:01.141] - queued futures: [n=2] TRUE, FALSE
[16:11:01.141] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:01.141]  length: 1 (resolved future 1)
[16:11:01.142] Future #2
[16:11:01.142] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:01.143] - nx: 2
[16:11:01.143] - relay: TRUE
[16:11:01.143] - stdout: TRUE
[16:11:01.143] - signal: TRUE
[16:11:01.143] - resignal: FALSE
[16:11:01.143] - force: TRUE
[16:11:01.143] - relayed: [n=2] TRUE, FALSE
[16:11:01.143] - queued futures: [n=2] TRUE, FALSE
[16:11:01.144]  - until=2
[16:11:01.144]  - relaying element #2
[16:11:01.144] - relayed: [n=2] TRUE, TRUE
[16:11:01.144] - queued futures: [n=2] TRUE, TRUE
[16:11:01.144] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:01.144]  length: 0 (resolved future 2)
[16:11:01.145] Relaying remaining futures
[16:11:01.145] signalConditionsASAP(NULL, pos=0) ...
[16:11:01.145] - nx: 2
[16:11:01.145] - relay: TRUE
[16:11:01.145] - stdout: TRUE
[16:11:01.145] - signal: TRUE
[16:11:01.145] - resignal: FALSE
[16:11:01.145] - force: TRUE
[16:11:01.145] - relayed: [n=2] TRUE, TRUE
[16:11:01.145] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:01.146] - relayed: [n=2] TRUE, TRUE
[16:11:01.146] - queued futures: [n=2] TRUE, TRUE
[16:11:01.146] signalConditionsASAP(NULL, pos=0) ... done
[16:11:01.146] resolve() on list ... DONE
[16:11:01.146]  - Number of value chunks collected: 2
[16:11:01.146] Resolving 2 futures (chunks) ... DONE
[16:11:01.147] Reducing values from 2 chunks ...
[16:11:01.147]  - Number of values collected after concatenation: 10
[16:11:01.147]  - Number of values expected: 10
[16:11:01.147] Reducing values from 2 chunks ... DONE
[16:11:01.147] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:11:01.148] future_lapply() ...
[16:11:01.157] Number of chunks: 2
[16:11:01.157] getGlobalsAndPackagesXApply() ...
[16:11:01.157]  - future.globals: TRUE
[16:11:01.158] getGlobalsAndPackages() ...
[16:11:01.158] Searching for globals...
[16:11:01.162] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:11:01.163] Searching for globals ... DONE
[16:11:01.163] Resolving globals: FALSE
[16:11:01.164] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:11:01.164] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:01.164] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.165] - packages: [1] ‘future.apply’
[16:11:01.165] getGlobalsAndPackages() ... DONE
[16:11:01.165]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.165]  - needed namespaces: [n=1] ‘future.apply’
[16:11:01.165] Finding globals ... DONE
[16:11:01.165]  - use_args: TRUE
[16:11:01.165]  - Getting '...' globals ...
[16:11:01.166] resolve() on list ...
[16:11:01.166]  recursive: 0
[16:11:01.166]  length: 1
[16:11:01.166]  elements: ‘...’
[16:11:01.166]  length: 0 (resolved future 1)
[16:11:01.166] resolve() on list ... DONE
[16:11:01.166]    - '...' content: [n=0] 
[16:11:01.166] List of 1
[16:11:01.166]  $ ...: list()
[16:11:01.166]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.166]  - attr(*, "where")=List of 1
[16:11:01.166]   ..$ ...:<environment: 0x561e8a4e9890> 
[16:11:01.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.166]  - attr(*, "resolved")= logi TRUE
[16:11:01.166]  - attr(*, "total_size")= num NA
[16:11:01.169]  - Getting '...' globals ... DONE
[16:11:01.169] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:01.169] List of 8
[16:11:01.169]  $ ...future.FUN:function (x, ...)  
[16:11:01.169]  $ x_FUN        :function (x)  
[16:11:01.169]  $ times        : int 4
[16:11:01.169]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.169]  $ stop_if_not  :function (...)  
[16:11:01.169]  $ dim          : int [1:2] 2 2
[16:11:01.169]  $ valid_types  : chr [1:2] "logical" "integer"
[16:11:01.169]  $ ...          : list()
[16:11:01.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.169]  - attr(*, "where")=List of 8
[16:11:01.169]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:01.169]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:01.169]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:01.169]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:01.169]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:01.169]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:01.169]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:01.169]   ..$ ...          :<environment: 0x561e8a4e9890> 
[16:11:01.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.169]  - attr(*, "resolved")= logi FALSE
[16:11:01.169]  - attr(*, "total_size")= num 97232
[16:11:01.177] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:01.177] getGlobalsAndPackagesXApply() ... DONE
[16:11:01.177] Number of futures (= number of chunks): 2
[16:11:01.177] Launching 2 futures (chunks) ...
[16:11:01.177] Chunk #1 of 2 ...
[16:11:01.177]  - Finding globals in 'X' for chunk #1 ...
[16:11:01.177] getGlobalsAndPackages() ...
[16:11:01.177] Searching for globals...
[16:11:01.178] 
[16:11:01.178] Searching for globals ... DONE
[16:11:01.178] - globals: [0] <none>
[16:11:01.178] getGlobalsAndPackages() ... DONE
[16:11:01.178]    + additional globals found: [n=0] 
[16:11:01.178]    + additional namespaces needed: [n=0] 
[16:11:01.178]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:01.178]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:01.179]  - seeds: <none>
[16:11:01.179] getGlobalsAndPackages() ...
[16:11:01.179] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.179] Resolving globals: FALSE
[16:11:01.179] Tweak future expression to call with '...' arguments ...
[16:11:01.179] {
[16:11:01.179]     do.call(function(...) {
[16:11:01.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.179]             on.exit(options(oopts), add = TRUE)
[16:11:01.179]         }
[16:11:01.179]         {
[16:11:01.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.179]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.179]             })
[16:11:01.179]         }
[16:11:01.179]     }, args = future.call.arguments)
[16:11:01.179] }
[16:11:01.179] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.180] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.180] - packages: [1] ‘future.apply’
[16:11:01.180] getGlobalsAndPackages() ... DONE
[16:11:01.180] run() for ‘Future’ ...
[16:11:01.181] - state: ‘created’
[16:11:01.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.184] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.185]   - Field: ‘label’
[16:11:01.185]   - Field: ‘local’
[16:11:01.185]   - Field: ‘owner’
[16:11:01.185]   - Field: ‘envir’
[16:11:01.185]   - Field: ‘workers’
[16:11:01.185]   - Field: ‘packages’
[16:11:01.185]   - Field: ‘gc’
[16:11:01.185]   - Field: ‘job’
[16:11:01.185]   - Field: ‘conditions’
[16:11:01.185]   - Field: ‘expr’
[16:11:01.186]   - Field: ‘uuid’
[16:11:01.186]   - Field: ‘seed’
[16:11:01.186]   - Field: ‘version’
[16:11:01.186]   - Field: ‘result’
[16:11:01.186]   - Field: ‘asynchronous’
[16:11:01.186]   - Field: ‘calls’
[16:11:01.186]   - Field: ‘globals’
[16:11:01.186]   - Field: ‘stdout’
[16:11:01.186]   - Field: ‘earlySignal’
[16:11:01.186]   - Field: ‘lazy’
[16:11:01.186]   - Field: ‘state’
[16:11:01.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.187] - Launch lazy future ...
[16:11:01.187] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:01.187] Packages needed by future strategies (n = 0): <none>
[16:11:01.188] {
[16:11:01.188]     {
[16:11:01.188]         {
[16:11:01.188]             ...future.startTime <- base::Sys.time()
[16:11:01.188]             {
[16:11:01.188]                 {
[16:11:01.188]                   {
[16:11:01.188]                     {
[16:11:01.188]                       {
[16:11:01.188]                         base::local({
[16:11:01.188]                           has_future <- base::requireNamespace("future", 
[16:11:01.188]                             quietly = TRUE)
[16:11:01.188]                           if (has_future) {
[16:11:01.188]                             ns <- base::getNamespace("future")
[16:11:01.188]                             version <- ns[[".package"]][["version"]]
[16:11:01.188]                             if (is.null(version)) 
[16:11:01.188]                               version <- utils::packageVersion("future")
[16:11:01.188]                           }
[16:11:01.188]                           else {
[16:11:01.188]                             version <- NULL
[16:11:01.188]                           }
[16:11:01.188]                           if (!has_future || version < "1.8.0") {
[16:11:01.188]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.188]                               "", base::R.version$version.string), 
[16:11:01.188]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.188]                                 base::R.version$platform, 8 * 
[16:11:01.188]                                   base::.Machine$sizeof.pointer), 
[16:11:01.188]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.188]                                 "release", "version")], collapse = " "), 
[16:11:01.188]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.188]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.188]                               info)
[16:11:01.188]                             info <- base::paste(info, collapse = "; ")
[16:11:01.188]                             if (!has_future) {
[16:11:01.188]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.188]                                 info)
[16:11:01.188]                             }
[16:11:01.188]                             else {
[16:11:01.188]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.188]                                 info, version)
[16:11:01.188]                             }
[16:11:01.188]                             base::stop(msg)
[16:11:01.188]                           }
[16:11:01.188]                         })
[16:11:01.188]                       }
[16:11:01.188]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.188]                       base::options(mc.cores = 1L)
[16:11:01.188]                     }
[16:11:01.188]                     base::local({
[16:11:01.188]                       for (pkg in "future.apply") {
[16:11:01.188]                         base::loadNamespace(pkg)
[16:11:01.188]                         base::library(pkg, character.only = TRUE)
[16:11:01.188]                       }
[16:11:01.188]                     })
[16:11:01.188]                   }
[16:11:01.188]                   options(future.plan = NULL)
[16:11:01.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.188]                 }
[16:11:01.188]                 ...future.workdir <- getwd()
[16:11:01.188]             }
[16:11:01.188]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.188]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.188]         }
[16:11:01.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.188]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:01.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.188]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.188]             base::names(...future.oldOptions))
[16:11:01.188]     }
[16:11:01.188]     if (FALSE) {
[16:11:01.188]     }
[16:11:01.188]     else {
[16:11:01.188]         if (TRUE) {
[16:11:01.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.188]                 open = "w")
[16:11:01.188]         }
[16:11:01.188]         else {
[16:11:01.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.188]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.188]         }
[16:11:01.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.188]             base::sink(type = "output", split = FALSE)
[16:11:01.188]             base::close(...future.stdout)
[16:11:01.188]         }, add = TRUE)
[16:11:01.188]     }
[16:11:01.188]     ...future.frame <- base::sys.nframe()
[16:11:01.188]     ...future.conditions <- base::list()
[16:11:01.188]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.188]     if (FALSE) {
[16:11:01.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.188]     }
[16:11:01.188]     ...future.result <- base::tryCatch({
[16:11:01.188]         base::withCallingHandlers({
[16:11:01.188]             ...future.value <- base::withVisible(base::local({
[16:11:01.188]                 withCallingHandlers({
[16:11:01.188]                   {
[16:11:01.188]                     do.call(function(...) {
[16:11:01.188]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.188]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.188]                         ...future.globals.maxSize)) {
[16:11:01.188]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.188]                         on.exit(options(oopts), add = TRUE)
[16:11:01.188]                       }
[16:11:01.188]                       {
[16:11:01.188]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.188]                           FUN = function(jj) {
[16:11:01.188]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.188]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.188]                           })
[16:11:01.188]                       }
[16:11:01.188]                     }, args = future.call.arguments)
[16:11:01.188]                   }
[16:11:01.188]                 }, immediateCondition = function(cond) {
[16:11:01.188]                   save_rds <- function (object, pathname, ...) 
[16:11:01.188]                   {
[16:11:01.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.188]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.188]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.188]                         fi_tmp[["mtime"]])
[16:11:01.188]                     }
[16:11:01.188]                     tryCatch({
[16:11:01.188]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.188]                     }, error = function(ex) {
[16:11:01.188]                       msg <- conditionMessage(ex)
[16:11:01.188]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.188]                         fi_tmp[["mtime"]], msg)
[16:11:01.188]                       ex$message <- msg
[16:11:01.188]                       stop(ex)
[16:11:01.188]                     })
[16:11:01.188]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.188]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.188]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.188]                       fi <- file.info(pathname)
[16:11:01.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.188]                         fi[["size"]], fi[["mtime"]])
[16:11:01.188]                       stop(msg)
[16:11:01.188]                     }
[16:11:01.188]                     invisible(pathname)
[16:11:01.188]                   }
[16:11:01.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.188]                     rootPath = tempdir()) 
[16:11:01.188]                   {
[16:11:01.188]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.188]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.188]                       tmpdir = path, fileext = ".rds")
[16:11:01.188]                     save_rds(obj, file)
[16:11:01.188]                   }
[16:11:01.188]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.188]                   {
[16:11:01.188]                     inherits <- base::inherits
[16:11:01.188]                     invokeRestart <- base::invokeRestart
[16:11:01.188]                     is.null <- base::is.null
[16:11:01.188]                     muffled <- FALSE
[16:11:01.188]                     if (inherits(cond, "message")) {
[16:11:01.188]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.188]                       if (muffled) 
[16:11:01.188]                         invokeRestart("muffleMessage")
[16:11:01.188]                     }
[16:11:01.188]                     else if (inherits(cond, "warning")) {
[16:11:01.188]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.188]                       if (muffled) 
[16:11:01.188]                         invokeRestart("muffleWarning")
[16:11:01.188]                     }
[16:11:01.188]                     else if (inherits(cond, "condition")) {
[16:11:01.188]                       if (!is.null(pattern)) {
[16:11:01.188]                         computeRestarts <- base::computeRestarts
[16:11:01.188]                         grepl <- base::grepl
[16:11:01.188]                         restarts <- computeRestarts(cond)
[16:11:01.188]                         for (restart in restarts) {
[16:11:01.188]                           name <- restart$name
[16:11:01.188]                           if (is.null(name)) 
[16:11:01.188]                             next
[16:11:01.188]                           if (!grepl(pattern, name)) 
[16:11:01.188]                             next
[16:11:01.188]                           invokeRestart(restart)
[16:11:01.188]                           muffled <- TRUE
[16:11:01.188]                           break
[16:11:01.188]                         }
[16:11:01.188]                       }
[16:11:01.188]                     }
[16:11:01.188]                     invisible(muffled)
[16:11:01.188]                   }
[16:11:01.188]                   muffleCondition(cond)
[16:11:01.188]                 })
[16:11:01.188]             }))
[16:11:01.188]             future::FutureResult(value = ...future.value$value, 
[16:11:01.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.188]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.188]                     ...future.globalenv.names))
[16:11:01.188]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.188]         }, condition = base::local({
[16:11:01.188]             c <- base::c
[16:11:01.188]             inherits <- base::inherits
[16:11:01.188]             invokeRestart <- base::invokeRestart
[16:11:01.188]             length <- base::length
[16:11:01.188]             list <- base::list
[16:11:01.188]             seq.int <- base::seq.int
[16:11:01.188]             signalCondition <- base::signalCondition
[16:11:01.188]             sys.calls <- base::sys.calls
[16:11:01.188]             `[[` <- base::`[[`
[16:11:01.188]             `+` <- base::`+`
[16:11:01.188]             `<<-` <- base::`<<-`
[16:11:01.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.188]                   3L)]
[16:11:01.188]             }
[16:11:01.188]             function(cond) {
[16:11:01.188]                 is_error <- inherits(cond, "error")
[16:11:01.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.188]                   NULL)
[16:11:01.188]                 if (is_error) {
[16:11:01.188]                   sessionInformation <- function() {
[16:11:01.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.188]                       search = base::search(), system = base::Sys.info())
[16:11:01.188]                   }
[16:11:01.188]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.188]                     cond$call), session = sessionInformation(), 
[16:11:01.188]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.188]                   signalCondition(cond)
[16:11:01.188]                 }
[16:11:01.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.188]                 "immediateCondition"))) {
[16:11:01.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.188]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.188]                   if (TRUE && !signal) {
[16:11:01.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.188]                     {
[16:11:01.188]                       inherits <- base::inherits
[16:11:01.188]                       invokeRestart <- base::invokeRestart
[16:11:01.188]                       is.null <- base::is.null
[16:11:01.188]                       muffled <- FALSE
[16:11:01.188]                       if (inherits(cond, "message")) {
[16:11:01.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.188]                         if (muffled) 
[16:11:01.188]                           invokeRestart("muffleMessage")
[16:11:01.188]                       }
[16:11:01.188]                       else if (inherits(cond, "warning")) {
[16:11:01.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.188]                         if (muffled) 
[16:11:01.188]                           invokeRestart("muffleWarning")
[16:11:01.188]                       }
[16:11:01.188]                       else if (inherits(cond, "condition")) {
[16:11:01.188]                         if (!is.null(pattern)) {
[16:11:01.188]                           computeRestarts <- base::computeRestarts
[16:11:01.188]                           grepl <- base::grepl
[16:11:01.188]                           restarts <- computeRestarts(cond)
[16:11:01.188]                           for (restart in restarts) {
[16:11:01.188]                             name <- restart$name
[16:11:01.188]                             if (is.null(name)) 
[16:11:01.188]                               next
[16:11:01.188]                             if (!grepl(pattern, name)) 
[16:11:01.188]                               next
[16:11:01.188]                             invokeRestart(restart)
[16:11:01.188]                             muffled <- TRUE
[16:11:01.188]                             break
[16:11:01.188]                           }
[16:11:01.188]                         }
[16:11:01.188]                       }
[16:11:01.188]                       invisible(muffled)
[16:11:01.188]                     }
[16:11:01.188]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.188]                   }
[16:11:01.188]                 }
[16:11:01.188]                 else {
[16:11:01.188]                   if (TRUE) {
[16:11:01.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.188]                     {
[16:11:01.188]                       inherits <- base::inherits
[16:11:01.188]                       invokeRestart <- base::invokeRestart
[16:11:01.188]                       is.null <- base::is.null
[16:11:01.188]                       muffled <- FALSE
[16:11:01.188]                       if (inherits(cond, "message")) {
[16:11:01.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.188]                         if (muffled) 
[16:11:01.188]                           invokeRestart("muffleMessage")
[16:11:01.188]                       }
[16:11:01.188]                       else if (inherits(cond, "warning")) {
[16:11:01.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.188]                         if (muffled) 
[16:11:01.188]                           invokeRestart("muffleWarning")
[16:11:01.188]                       }
[16:11:01.188]                       else if (inherits(cond, "condition")) {
[16:11:01.188]                         if (!is.null(pattern)) {
[16:11:01.188]                           computeRestarts <- base::computeRestarts
[16:11:01.188]                           grepl <- base::grepl
[16:11:01.188]                           restarts <- computeRestarts(cond)
[16:11:01.188]                           for (restart in restarts) {
[16:11:01.188]                             name <- restart$name
[16:11:01.188]                             if (is.null(name)) 
[16:11:01.188]                               next
[16:11:01.188]                             if (!grepl(pattern, name)) 
[16:11:01.188]                               next
[16:11:01.188]                             invokeRestart(restart)
[16:11:01.188]                             muffled <- TRUE
[16:11:01.188]                             break
[16:11:01.188]                           }
[16:11:01.188]                         }
[16:11:01.188]                       }
[16:11:01.188]                       invisible(muffled)
[16:11:01.188]                     }
[16:11:01.188]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.188]                   }
[16:11:01.188]                 }
[16:11:01.188]             }
[16:11:01.188]         }))
[16:11:01.188]     }, error = function(ex) {
[16:11:01.188]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.188]                 ...future.rng), started = ...future.startTime, 
[16:11:01.188]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.188]             version = "1.8"), class = "FutureResult")
[16:11:01.188]     }, finally = {
[16:11:01.188]         if (!identical(...future.workdir, getwd())) 
[16:11:01.188]             setwd(...future.workdir)
[16:11:01.188]         {
[16:11:01.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.188]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.188]             }
[16:11:01.188]             base::options(...future.oldOptions)
[16:11:01.188]             if (.Platform$OS.type == "windows") {
[16:11:01.188]                 old_names <- names(...future.oldEnvVars)
[16:11:01.188]                 envs <- base::Sys.getenv()
[16:11:01.188]                 names <- names(envs)
[16:11:01.188]                 common <- intersect(names, old_names)
[16:11:01.188]                 added <- setdiff(names, old_names)
[16:11:01.188]                 removed <- setdiff(old_names, names)
[16:11:01.188]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.188]                   envs[common]]
[16:11:01.188]                 NAMES <- toupper(changed)
[16:11:01.188]                 args <- list()
[16:11:01.188]                 for (kk in seq_along(NAMES)) {
[16:11:01.188]                   name <- changed[[kk]]
[16:11:01.188]                   NAME <- NAMES[[kk]]
[16:11:01.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.188]                     next
[16:11:01.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.188]                 }
[16:11:01.188]                 NAMES <- toupper(added)
[16:11:01.188]                 for (kk in seq_along(NAMES)) {
[16:11:01.188]                   name <- added[[kk]]
[16:11:01.188]                   NAME <- NAMES[[kk]]
[16:11:01.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.188]                     next
[16:11:01.188]                   args[[name]] <- ""
[16:11:01.188]                 }
[16:11:01.188]                 NAMES <- toupper(removed)
[16:11:01.188]                 for (kk in seq_along(NAMES)) {
[16:11:01.188]                   name <- removed[[kk]]
[16:11:01.188]                   NAME <- NAMES[[kk]]
[16:11:01.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.188]                     next
[16:11:01.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.188]                 }
[16:11:01.188]                 if (length(args) > 0) 
[16:11:01.188]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.188]             }
[16:11:01.188]             else {
[16:11:01.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.188]             }
[16:11:01.188]             {
[16:11:01.188]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.188]                   0L) {
[16:11:01.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.188]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.188]                   base::options(opts)
[16:11:01.188]                 }
[16:11:01.188]                 {
[16:11:01.188]                   {
[16:11:01.188]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.188]                     NULL
[16:11:01.188]                   }
[16:11:01.188]                   options(future.plan = NULL)
[16:11:01.188]                   if (is.na(NA_character_)) 
[16:11:01.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.188]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.188]                     envir = parent.frame()) 
[16:11:01.188]                   {
[16:11:01.188]                     default_workers <- missing(workers)
[16:11:01.188]                     if (is.function(workers)) 
[16:11:01.188]                       workers <- workers()
[16:11:01.188]                     workers <- structure(as.integer(workers), 
[16:11:01.188]                       class = class(workers))
[16:11:01.188]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.188]                       1L)
[16:11:01.188]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.188]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.188]                       if (default_workers) 
[16:11:01.188]                         supportsMulticore(warn = TRUE)
[16:11:01.188]                       return(sequential(..., envir = envir))
[16:11:01.188]                     }
[16:11:01.188]                     oopts <- options(mc.cores = workers)
[16:11:01.188]                     on.exit(options(oopts))
[16:11:01.188]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.188]                       envir = envir)
[16:11:01.188]                     if (!future$lazy) 
[16:11:01.188]                       future <- run(future)
[16:11:01.188]                     invisible(future)
[16:11:01.188]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.188]                 }
[16:11:01.188]             }
[16:11:01.188]         }
[16:11:01.188]     })
[16:11:01.188]     if (TRUE) {
[16:11:01.188]         base::sink(type = "output", split = FALSE)
[16:11:01.188]         if (TRUE) {
[16:11:01.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.188]         }
[16:11:01.188]         else {
[16:11:01.188]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.188]         }
[16:11:01.188]         base::close(...future.stdout)
[16:11:01.188]         ...future.stdout <- NULL
[16:11:01.188]     }
[16:11:01.188]     ...future.result$conditions <- ...future.conditions
[16:11:01.188]     ...future.result$finished <- base::Sys.time()
[16:11:01.188]     ...future.result
[16:11:01.188] }
[16:11:01.190] assign_globals() ...
[16:11:01.190] List of 11
[16:11:01.190]  $ ...future.FUN            :function (x, ...)  
[16:11:01.190]  $ x_FUN                    :function (x)  
[16:11:01.190]  $ times                    : int 4
[16:11:01.190]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.190]  $ stop_if_not              :function (...)  
[16:11:01.190]  $ dim                      : int [1:2] 2 2
[16:11:01.190]  $ valid_types              : chr [1:2] "logical" "integer"
[16:11:01.190]  $ future.call.arguments    : list()
[16:11:01.190]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.190]  $ ...future.elements_ii    :List of 5
[16:11:01.190]   ..$ : int 1
[16:11:01.190]   ..$ : int 2
[16:11:01.190]   ..$ : int 3
[16:11:01.190]   ..$ : int 4
[16:11:01.190]   ..$ : int 5
[16:11:01.190]  $ ...future.seeds_ii       : NULL
[16:11:01.190]  $ ...future.globals.maxSize: NULL
[16:11:01.190]  - attr(*, "resolved")= logi FALSE
[16:11:01.190]  - attr(*, "total_size")= num 97232
[16:11:01.190]  - attr(*, "where")=List of 11
[16:11:01.190]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.190]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.190]  - attr(*, "already-done")= logi TRUE
[16:11:01.201] - copied ‘...future.FUN’ to environment
[16:11:01.201] - reassign environment for ‘x_FUN’
[16:11:01.201] - copied ‘x_FUN’ to environment
[16:11:01.201] - copied ‘times’ to environment
[16:11:01.201] - copied ‘stopf’ to environment
[16:11:01.201] - copied ‘stop_if_not’ to environment
[16:11:01.201] - copied ‘dim’ to environment
[16:11:01.201] - copied ‘valid_types’ to environment
[16:11:01.201] - copied ‘future.call.arguments’ to environment
[16:11:01.202] - copied ‘...future.elements_ii’ to environment
[16:11:01.202] - copied ‘...future.seeds_ii’ to environment
[16:11:01.202] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.202] assign_globals() ... done
[16:11:01.202] requestCore(): workers = 2
[16:11:01.204] MulticoreFuture started
[16:11:01.205] - Launch lazy future ... done
[16:11:01.205] run() for ‘MulticoreFuture’ ... done
[16:11:01.205] Created future:
[16:11:01.206] plan(): Setting new future strategy stack:
[16:11:01.206] List of future strategies:
[16:11:01.206] 1. sequential:
[16:11:01.206]    - args: function (..., envir = parent.frame())
[16:11:01.206]    - tweaked: FALSE
[16:11:01.206]    - call: NULL
[16:11:01.207] plan(): nbrOfWorkers() = 1
[16:11:01.209] plan(): Setting new future strategy stack:
[16:11:01.209] List of future strategies:
[16:11:01.209] 1. multicore:
[16:11:01.209]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.209]    - tweaked: FALSE
[16:11:01.209]    - call: plan(strategy)
[16:11:01.215] plan(): nbrOfWorkers() = 2
[16:11:01.206] MulticoreFuture:
[16:11:01.206] Label: ‘future_vapply-1’
[16:11:01.206] Expression:
[16:11:01.206] {
[16:11:01.206]     do.call(function(...) {
[16:11:01.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.206]             on.exit(options(oopts), add = TRUE)
[16:11:01.206]         }
[16:11:01.206]         {
[16:11:01.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.206]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.206]             })
[16:11:01.206]         }
[16:11:01.206]     }, args = future.call.arguments)
[16:11:01.206] }
[16:11:01.206] Lazy evaluation: FALSE
[16:11:01.206] Asynchronous evaluation: TRUE
[16:11:01.206] Local evaluation: TRUE
[16:11:01.206] Environment: R_GlobalEnv
[16:11:01.206] Capture standard output: TRUE
[16:11:01.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.206] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.206] Packages: 1 packages (‘future.apply’)
[16:11:01.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.206] Resolved: TRUE
[16:11:01.206] Value: <not collected>
[16:11:01.206] Conditions captured: <none>
[16:11:01.206] Early signaling: FALSE
[16:11:01.206] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.206] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.216] Chunk #1 of 2 ... DONE
[16:11:01.217] Chunk #2 of 2 ...
[16:11:01.217]  - Finding globals in 'X' for chunk #2 ...
[16:11:01.217] getGlobalsAndPackages() ...
[16:11:01.217] Searching for globals...
[16:11:01.218] 
[16:11:01.218] Searching for globals ... DONE
[16:11:01.218] - globals: [0] <none>
[16:11:01.218] getGlobalsAndPackages() ... DONE
[16:11:01.218]    + additional globals found: [n=0] 
[16:11:01.219]    + additional namespaces needed: [n=0] 
[16:11:01.219]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:01.219]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:01.219]  - seeds: <none>
[16:11:01.219] getGlobalsAndPackages() ...
[16:11:01.220] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.220] Resolving globals: FALSE
[16:11:01.220] Tweak future expression to call with '...' arguments ...
[16:11:01.220] {
[16:11:01.220]     do.call(function(...) {
[16:11:01.220]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.220]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.220]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.220]             on.exit(options(oopts), add = TRUE)
[16:11:01.220]         }
[16:11:01.220]         {
[16:11:01.220]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.220]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.220]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.220]             })
[16:11:01.220]         }
[16:11:01.220]     }, args = future.call.arguments)
[16:11:01.220] }
[16:11:01.221] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.222] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.222] - packages: [1] ‘future.apply’
[16:11:01.222] getGlobalsAndPackages() ... DONE
[16:11:01.223] run() for ‘Future’ ...
[16:11:01.223] - state: ‘created’
[16:11:01.223] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.228] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.228]   - Field: ‘label’
[16:11:01.228]   - Field: ‘local’
[16:11:01.228]   - Field: ‘owner’
[16:11:01.228]   - Field: ‘envir’
[16:11:01.229]   - Field: ‘workers’
[16:11:01.229]   - Field: ‘packages’
[16:11:01.229]   - Field: ‘gc’
[16:11:01.229]   - Field: ‘job’
[16:11:01.229]   - Field: ‘conditions’
[16:11:01.229]   - Field: ‘expr’
[16:11:01.229]   - Field: ‘uuid’
[16:11:01.230]   - Field: ‘seed’
[16:11:01.230]   - Field: ‘version’
[16:11:01.230]   - Field: ‘result’
[16:11:01.230]   - Field: ‘asynchronous’
[16:11:01.230]   - Field: ‘calls’
[16:11:01.230]   - Field: ‘globals’
[16:11:01.230]   - Field: ‘stdout’
[16:11:01.231]   - Field: ‘earlySignal’
[16:11:01.231]   - Field: ‘lazy’
[16:11:01.231]   - Field: ‘state’
[16:11:01.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.231] - Launch lazy future ...
[16:11:01.232] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:01.232] Packages needed by future strategies (n = 0): <none>
[16:11:01.233] {
[16:11:01.233]     {
[16:11:01.233]         {
[16:11:01.233]             ...future.startTime <- base::Sys.time()
[16:11:01.233]             {
[16:11:01.233]                 {
[16:11:01.233]                   {
[16:11:01.233]                     {
[16:11:01.233]                       {
[16:11:01.233]                         base::local({
[16:11:01.233]                           has_future <- base::requireNamespace("future", 
[16:11:01.233]                             quietly = TRUE)
[16:11:01.233]                           if (has_future) {
[16:11:01.233]                             ns <- base::getNamespace("future")
[16:11:01.233]                             version <- ns[[".package"]][["version"]]
[16:11:01.233]                             if (is.null(version)) 
[16:11:01.233]                               version <- utils::packageVersion("future")
[16:11:01.233]                           }
[16:11:01.233]                           else {
[16:11:01.233]                             version <- NULL
[16:11:01.233]                           }
[16:11:01.233]                           if (!has_future || version < "1.8.0") {
[16:11:01.233]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.233]                               "", base::R.version$version.string), 
[16:11:01.233]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.233]                                 base::R.version$platform, 8 * 
[16:11:01.233]                                   base::.Machine$sizeof.pointer), 
[16:11:01.233]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.233]                                 "release", "version")], collapse = " "), 
[16:11:01.233]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.233]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.233]                               info)
[16:11:01.233]                             info <- base::paste(info, collapse = "; ")
[16:11:01.233]                             if (!has_future) {
[16:11:01.233]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.233]                                 info)
[16:11:01.233]                             }
[16:11:01.233]                             else {
[16:11:01.233]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.233]                                 info, version)
[16:11:01.233]                             }
[16:11:01.233]                             base::stop(msg)
[16:11:01.233]                           }
[16:11:01.233]                         })
[16:11:01.233]                       }
[16:11:01.233]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.233]                       base::options(mc.cores = 1L)
[16:11:01.233]                     }
[16:11:01.233]                     base::local({
[16:11:01.233]                       for (pkg in "future.apply") {
[16:11:01.233]                         base::loadNamespace(pkg)
[16:11:01.233]                         base::library(pkg, character.only = TRUE)
[16:11:01.233]                       }
[16:11:01.233]                     })
[16:11:01.233]                   }
[16:11:01.233]                   options(future.plan = NULL)
[16:11:01.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.233]                 }
[16:11:01.233]                 ...future.workdir <- getwd()
[16:11:01.233]             }
[16:11:01.233]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.233]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.233]         }
[16:11:01.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.233]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:01.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.233]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.233]             base::names(...future.oldOptions))
[16:11:01.233]     }
[16:11:01.233]     if (FALSE) {
[16:11:01.233]     }
[16:11:01.233]     else {
[16:11:01.233]         if (TRUE) {
[16:11:01.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.233]                 open = "w")
[16:11:01.233]         }
[16:11:01.233]         else {
[16:11:01.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.233]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.233]         }
[16:11:01.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.233]             base::sink(type = "output", split = FALSE)
[16:11:01.233]             base::close(...future.stdout)
[16:11:01.233]         }, add = TRUE)
[16:11:01.233]     }
[16:11:01.233]     ...future.frame <- base::sys.nframe()
[16:11:01.233]     ...future.conditions <- base::list()
[16:11:01.233]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.233]     if (FALSE) {
[16:11:01.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.233]     }
[16:11:01.233]     ...future.result <- base::tryCatch({
[16:11:01.233]         base::withCallingHandlers({
[16:11:01.233]             ...future.value <- base::withVisible(base::local({
[16:11:01.233]                 withCallingHandlers({
[16:11:01.233]                   {
[16:11:01.233]                     do.call(function(...) {
[16:11:01.233]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.233]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.233]                         ...future.globals.maxSize)) {
[16:11:01.233]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.233]                         on.exit(options(oopts), add = TRUE)
[16:11:01.233]                       }
[16:11:01.233]                       {
[16:11:01.233]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.233]                           FUN = function(jj) {
[16:11:01.233]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.233]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.233]                           })
[16:11:01.233]                       }
[16:11:01.233]                     }, args = future.call.arguments)
[16:11:01.233]                   }
[16:11:01.233]                 }, immediateCondition = function(cond) {
[16:11:01.233]                   save_rds <- function (object, pathname, ...) 
[16:11:01.233]                   {
[16:11:01.233]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.233]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.233]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.233]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.233]                         fi_tmp[["mtime"]])
[16:11:01.233]                     }
[16:11:01.233]                     tryCatch({
[16:11:01.233]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.233]                     }, error = function(ex) {
[16:11:01.233]                       msg <- conditionMessage(ex)
[16:11:01.233]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.233]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.233]                         fi_tmp[["mtime"]], msg)
[16:11:01.233]                       ex$message <- msg
[16:11:01.233]                       stop(ex)
[16:11:01.233]                     })
[16:11:01.233]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.233]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.233]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.233]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.233]                       fi <- file.info(pathname)
[16:11:01.233]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.233]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.233]                         fi[["size"]], fi[["mtime"]])
[16:11:01.233]                       stop(msg)
[16:11:01.233]                     }
[16:11:01.233]                     invisible(pathname)
[16:11:01.233]                   }
[16:11:01.233]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.233]                     rootPath = tempdir()) 
[16:11:01.233]                   {
[16:11:01.233]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.233]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.233]                       tmpdir = path, fileext = ".rds")
[16:11:01.233]                     save_rds(obj, file)
[16:11:01.233]                   }
[16:11:01.233]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.233]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.233]                   {
[16:11:01.233]                     inherits <- base::inherits
[16:11:01.233]                     invokeRestart <- base::invokeRestart
[16:11:01.233]                     is.null <- base::is.null
[16:11:01.233]                     muffled <- FALSE
[16:11:01.233]                     if (inherits(cond, "message")) {
[16:11:01.233]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.233]                       if (muffled) 
[16:11:01.233]                         invokeRestart("muffleMessage")
[16:11:01.233]                     }
[16:11:01.233]                     else if (inherits(cond, "warning")) {
[16:11:01.233]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.233]                       if (muffled) 
[16:11:01.233]                         invokeRestart("muffleWarning")
[16:11:01.233]                     }
[16:11:01.233]                     else if (inherits(cond, "condition")) {
[16:11:01.233]                       if (!is.null(pattern)) {
[16:11:01.233]                         computeRestarts <- base::computeRestarts
[16:11:01.233]                         grepl <- base::grepl
[16:11:01.233]                         restarts <- computeRestarts(cond)
[16:11:01.233]                         for (restart in restarts) {
[16:11:01.233]                           name <- restart$name
[16:11:01.233]                           if (is.null(name)) 
[16:11:01.233]                             next
[16:11:01.233]                           if (!grepl(pattern, name)) 
[16:11:01.233]                             next
[16:11:01.233]                           invokeRestart(restart)
[16:11:01.233]                           muffled <- TRUE
[16:11:01.233]                           break
[16:11:01.233]                         }
[16:11:01.233]                       }
[16:11:01.233]                     }
[16:11:01.233]                     invisible(muffled)
[16:11:01.233]                   }
[16:11:01.233]                   muffleCondition(cond)
[16:11:01.233]                 })
[16:11:01.233]             }))
[16:11:01.233]             future::FutureResult(value = ...future.value$value, 
[16:11:01.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.233]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.233]                     ...future.globalenv.names))
[16:11:01.233]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.233]         }, condition = base::local({
[16:11:01.233]             c <- base::c
[16:11:01.233]             inherits <- base::inherits
[16:11:01.233]             invokeRestart <- base::invokeRestart
[16:11:01.233]             length <- base::length
[16:11:01.233]             list <- base::list
[16:11:01.233]             seq.int <- base::seq.int
[16:11:01.233]             signalCondition <- base::signalCondition
[16:11:01.233]             sys.calls <- base::sys.calls
[16:11:01.233]             `[[` <- base::`[[`
[16:11:01.233]             `+` <- base::`+`
[16:11:01.233]             `<<-` <- base::`<<-`
[16:11:01.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.233]                   3L)]
[16:11:01.233]             }
[16:11:01.233]             function(cond) {
[16:11:01.233]                 is_error <- inherits(cond, "error")
[16:11:01.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.233]                   NULL)
[16:11:01.233]                 if (is_error) {
[16:11:01.233]                   sessionInformation <- function() {
[16:11:01.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.233]                       search = base::search(), system = base::Sys.info())
[16:11:01.233]                   }
[16:11:01.233]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.233]                     cond$call), session = sessionInformation(), 
[16:11:01.233]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.233]                   signalCondition(cond)
[16:11:01.233]                 }
[16:11:01.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.233]                 "immediateCondition"))) {
[16:11:01.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.233]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.233]                   if (TRUE && !signal) {
[16:11:01.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.233]                     {
[16:11:01.233]                       inherits <- base::inherits
[16:11:01.233]                       invokeRestart <- base::invokeRestart
[16:11:01.233]                       is.null <- base::is.null
[16:11:01.233]                       muffled <- FALSE
[16:11:01.233]                       if (inherits(cond, "message")) {
[16:11:01.233]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.233]                         if (muffled) 
[16:11:01.233]                           invokeRestart("muffleMessage")
[16:11:01.233]                       }
[16:11:01.233]                       else if (inherits(cond, "warning")) {
[16:11:01.233]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.233]                         if (muffled) 
[16:11:01.233]                           invokeRestart("muffleWarning")
[16:11:01.233]                       }
[16:11:01.233]                       else if (inherits(cond, "condition")) {
[16:11:01.233]                         if (!is.null(pattern)) {
[16:11:01.233]                           computeRestarts <- base::computeRestarts
[16:11:01.233]                           grepl <- base::grepl
[16:11:01.233]                           restarts <- computeRestarts(cond)
[16:11:01.233]                           for (restart in restarts) {
[16:11:01.233]                             name <- restart$name
[16:11:01.233]                             if (is.null(name)) 
[16:11:01.233]                               next
[16:11:01.233]                             if (!grepl(pattern, name)) 
[16:11:01.233]                               next
[16:11:01.233]                             invokeRestart(restart)
[16:11:01.233]                             muffled <- TRUE
[16:11:01.233]                             break
[16:11:01.233]                           }
[16:11:01.233]                         }
[16:11:01.233]                       }
[16:11:01.233]                       invisible(muffled)
[16:11:01.233]                     }
[16:11:01.233]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.233]                   }
[16:11:01.233]                 }
[16:11:01.233]                 else {
[16:11:01.233]                   if (TRUE) {
[16:11:01.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.233]                     {
[16:11:01.233]                       inherits <- base::inherits
[16:11:01.233]                       invokeRestart <- base::invokeRestart
[16:11:01.233]                       is.null <- base::is.null
[16:11:01.233]                       muffled <- FALSE
[16:11:01.233]                       if (inherits(cond, "message")) {
[16:11:01.233]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.233]                         if (muffled) 
[16:11:01.233]                           invokeRestart("muffleMessage")
[16:11:01.233]                       }
[16:11:01.233]                       else if (inherits(cond, "warning")) {
[16:11:01.233]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.233]                         if (muffled) 
[16:11:01.233]                           invokeRestart("muffleWarning")
[16:11:01.233]                       }
[16:11:01.233]                       else if (inherits(cond, "condition")) {
[16:11:01.233]                         if (!is.null(pattern)) {
[16:11:01.233]                           computeRestarts <- base::computeRestarts
[16:11:01.233]                           grepl <- base::grepl
[16:11:01.233]                           restarts <- computeRestarts(cond)
[16:11:01.233]                           for (restart in restarts) {
[16:11:01.233]                             name <- restart$name
[16:11:01.233]                             if (is.null(name)) 
[16:11:01.233]                               next
[16:11:01.233]                             if (!grepl(pattern, name)) 
[16:11:01.233]                               next
[16:11:01.233]                             invokeRestart(restart)
[16:11:01.233]                             muffled <- TRUE
[16:11:01.233]                             break
[16:11:01.233]                           }
[16:11:01.233]                         }
[16:11:01.233]                       }
[16:11:01.233]                       invisible(muffled)
[16:11:01.233]                     }
[16:11:01.233]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.233]                   }
[16:11:01.233]                 }
[16:11:01.233]             }
[16:11:01.233]         }))
[16:11:01.233]     }, error = function(ex) {
[16:11:01.233]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.233]                 ...future.rng), started = ...future.startTime, 
[16:11:01.233]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.233]             version = "1.8"), class = "FutureResult")
[16:11:01.233]     }, finally = {
[16:11:01.233]         if (!identical(...future.workdir, getwd())) 
[16:11:01.233]             setwd(...future.workdir)
[16:11:01.233]         {
[16:11:01.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.233]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.233]             }
[16:11:01.233]             base::options(...future.oldOptions)
[16:11:01.233]             if (.Platform$OS.type == "windows") {
[16:11:01.233]                 old_names <- names(...future.oldEnvVars)
[16:11:01.233]                 envs <- base::Sys.getenv()
[16:11:01.233]                 names <- names(envs)
[16:11:01.233]                 common <- intersect(names, old_names)
[16:11:01.233]                 added <- setdiff(names, old_names)
[16:11:01.233]                 removed <- setdiff(old_names, names)
[16:11:01.233]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.233]                   envs[common]]
[16:11:01.233]                 NAMES <- toupper(changed)
[16:11:01.233]                 args <- list()
[16:11:01.233]                 for (kk in seq_along(NAMES)) {
[16:11:01.233]                   name <- changed[[kk]]
[16:11:01.233]                   NAME <- NAMES[[kk]]
[16:11:01.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.233]                     next
[16:11:01.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.233]                 }
[16:11:01.233]                 NAMES <- toupper(added)
[16:11:01.233]                 for (kk in seq_along(NAMES)) {
[16:11:01.233]                   name <- added[[kk]]
[16:11:01.233]                   NAME <- NAMES[[kk]]
[16:11:01.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.233]                     next
[16:11:01.233]                   args[[name]] <- ""
[16:11:01.233]                 }
[16:11:01.233]                 NAMES <- toupper(removed)
[16:11:01.233]                 for (kk in seq_along(NAMES)) {
[16:11:01.233]                   name <- removed[[kk]]
[16:11:01.233]                   NAME <- NAMES[[kk]]
[16:11:01.233]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.233]                     next
[16:11:01.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.233]                 }
[16:11:01.233]                 if (length(args) > 0) 
[16:11:01.233]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.233]             }
[16:11:01.233]             else {
[16:11:01.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.233]             }
[16:11:01.233]             {
[16:11:01.233]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.233]                   0L) {
[16:11:01.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.233]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.233]                   base::options(opts)
[16:11:01.233]                 }
[16:11:01.233]                 {
[16:11:01.233]                   {
[16:11:01.233]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.233]                     NULL
[16:11:01.233]                   }
[16:11:01.233]                   options(future.plan = NULL)
[16:11:01.233]                   if (is.na(NA_character_)) 
[16:11:01.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.233]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.233]                     envir = parent.frame()) 
[16:11:01.233]                   {
[16:11:01.233]                     default_workers <- missing(workers)
[16:11:01.233]                     if (is.function(workers)) 
[16:11:01.233]                       workers <- workers()
[16:11:01.233]                     workers <- structure(as.integer(workers), 
[16:11:01.233]                       class = class(workers))
[16:11:01.233]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.233]                       1L)
[16:11:01.233]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.233]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.233]                       if (default_workers) 
[16:11:01.233]                         supportsMulticore(warn = TRUE)
[16:11:01.233]                       return(sequential(..., envir = envir))
[16:11:01.233]                     }
[16:11:01.233]                     oopts <- options(mc.cores = workers)
[16:11:01.233]                     on.exit(options(oopts))
[16:11:01.233]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.233]                       envir = envir)
[16:11:01.233]                     if (!future$lazy) 
[16:11:01.233]                       future <- run(future)
[16:11:01.233]                     invisible(future)
[16:11:01.233]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.233]                 }
[16:11:01.233]             }
[16:11:01.233]         }
[16:11:01.233]     })
[16:11:01.233]     if (TRUE) {
[16:11:01.233]         base::sink(type = "output", split = FALSE)
[16:11:01.233]         if (TRUE) {
[16:11:01.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.233]         }
[16:11:01.233]         else {
[16:11:01.233]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.233]         }
[16:11:01.233]         base::close(...future.stdout)
[16:11:01.233]         ...future.stdout <- NULL
[16:11:01.233]     }
[16:11:01.233]     ...future.result$conditions <- ...future.conditions
[16:11:01.233]     ...future.result$finished <- base::Sys.time()
[16:11:01.233]     ...future.result
[16:11:01.233] }
[16:11:01.236] assign_globals() ...
[16:11:01.237] List of 11
[16:11:01.237]  $ ...future.FUN            :function (x, ...)  
[16:11:01.237]  $ x_FUN                    :function (x)  
[16:11:01.237]  $ times                    : int 4
[16:11:01.237]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.237]  $ stop_if_not              :function (...)  
[16:11:01.237]  $ dim                      : int [1:2] 2 2
[16:11:01.237]  $ valid_types              : chr [1:2] "logical" "integer"
[16:11:01.237]  $ future.call.arguments    : list()
[16:11:01.237]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.237]  $ ...future.elements_ii    :List of 5
[16:11:01.237]   ..$ : int 6
[16:11:01.237]   ..$ : int 7
[16:11:01.237]   ..$ : int 8
[16:11:01.237]   ..$ : int 9
[16:11:01.237]   ..$ : int 10
[16:11:01.237]  $ ...future.seeds_ii       : NULL
[16:11:01.237]  $ ...future.globals.maxSize: NULL
[16:11:01.237]  - attr(*, "resolved")= logi FALSE
[16:11:01.237]  - attr(*, "total_size")= num 97232
[16:11:01.237]  - attr(*, "where")=List of 11
[16:11:01.237]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.237]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.237]  - attr(*, "already-done")= logi TRUE
[16:11:01.255] - copied ‘...future.FUN’ to environment
[16:11:01.255] - reassign environment for ‘x_FUN’
[16:11:01.255] - copied ‘x_FUN’ to environment
[16:11:01.256] - copied ‘times’ to environment
[16:11:01.256] - copied ‘stopf’ to environment
[16:11:01.256] - copied ‘stop_if_not’ to environment
[16:11:01.256] - copied ‘dim’ to environment
[16:11:01.256] - copied ‘valid_types’ to environment
[16:11:01.256] - copied ‘future.call.arguments’ to environment
[16:11:01.256] - copied ‘...future.elements_ii’ to environment
[16:11:01.256] - copied ‘...future.seeds_ii’ to environment
[16:11:01.256] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.256] assign_globals() ... done
[16:11:01.257] requestCore(): workers = 2
[16:11:01.259] MulticoreFuture started
[16:11:01.259] - Launch lazy future ... done
[16:11:01.259] run() for ‘MulticoreFuture’ ... done
[16:11:01.260] Created future:
[16:11:01.260] plan(): Setting new future strategy stack:
[16:11:01.261] List of future strategies:
[16:11:01.261] 1. sequential:
[16:11:01.261]    - args: function (..., envir = parent.frame())
[16:11:01.261]    - tweaked: FALSE
[16:11:01.261]    - call: NULL
[16:11:01.262] plan(): nbrOfWorkers() = 1
[16:11:01.264] plan(): Setting new future strategy stack:
[16:11:01.264] List of future strategies:
[16:11:01.264] 1. multicore:
[16:11:01.264]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.264]    - tweaked: FALSE
[16:11:01.264]    - call: plan(strategy)
[16:11:01.269] plan(): nbrOfWorkers() = 2
[16:11:01.260] MulticoreFuture:
[16:11:01.260] Label: ‘future_vapply-2’
[16:11:01.260] Expression:
[16:11:01.260] {
[16:11:01.260]     do.call(function(...) {
[16:11:01.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.260]             on.exit(options(oopts), add = TRUE)
[16:11:01.260]         }
[16:11:01.260]         {
[16:11:01.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.260]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.260]             })
[16:11:01.260]         }
[16:11:01.260]     }, args = future.call.arguments)
[16:11:01.260] }
[16:11:01.260] Lazy evaluation: FALSE
[16:11:01.260] Asynchronous evaluation: TRUE
[16:11:01.260] Local evaluation: TRUE
[16:11:01.260] Environment: R_GlobalEnv
[16:11:01.260] Capture standard output: TRUE
[16:11:01.260] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.260] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.260] Packages: 1 packages (‘future.apply’)
[16:11:01.260] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.260] Resolved: TRUE
[16:11:01.260] Value: <not collected>
[16:11:01.260] Conditions captured: <none>
[16:11:01.260] Early signaling: FALSE
[16:11:01.260] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.260] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.271] Chunk #2 of 2 ... DONE
[16:11:01.271] Launching 2 futures (chunks) ... DONE
[16:11:01.271] Resolving 2 futures (chunks) ...
[16:11:01.271] resolve() on list ...
[16:11:01.271]  recursive: 0
[16:11:01.271]  length: 2
[16:11:01.272] 
[16:11:01.272] Future #1
[16:11:01.273] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:01.273] - nx: 2
[16:11:01.273] - relay: TRUE
[16:11:01.273] - stdout: TRUE
[16:11:01.274] - signal: TRUE
[16:11:01.274] - resignal: FALSE
[16:11:01.274] - force: TRUE
[16:11:01.274] - relayed: [n=2] FALSE, FALSE
[16:11:01.274] - queued futures: [n=2] FALSE, FALSE
[16:11:01.274]  - until=1
[16:11:01.275]  - relaying element #1
[16:11:01.275] - relayed: [n=2] TRUE, FALSE
[16:11:01.275] - queued futures: [n=2] TRUE, FALSE
[16:11:01.275] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:01.275]  length: 1 (resolved future 1)
[16:11:01.276] Future #2
[16:11:01.277] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:01.277] - nx: 2
[16:11:01.277] - relay: TRUE
[16:11:01.277] - stdout: TRUE
[16:11:01.277] - signal: TRUE
[16:11:01.278] - resignal: FALSE
[16:11:01.278] - force: TRUE
[16:11:01.278] - relayed: [n=2] TRUE, FALSE
[16:11:01.278] - queued futures: [n=2] TRUE, FALSE
[16:11:01.278]  - until=2
[16:11:01.278]  - relaying element #2
[16:11:01.278] - relayed: [n=2] TRUE, TRUE
[16:11:01.279] - queued futures: [n=2] TRUE, TRUE
[16:11:01.279] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:01.279]  length: 0 (resolved future 2)
[16:11:01.279] Relaying remaining futures
[16:11:01.279] signalConditionsASAP(NULL, pos=0) ...
[16:11:01.279] - nx: 2
[16:11:01.279] - relay: TRUE
[16:11:01.279] - stdout: TRUE
[16:11:01.279] - signal: TRUE
[16:11:01.279] - resignal: FALSE
[16:11:01.280] - force: TRUE
[16:11:01.280] - relayed: [n=2] TRUE, TRUE
[16:11:01.280] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:01.280] - relayed: [n=2] TRUE, TRUE
[16:11:01.280] - queued futures: [n=2] TRUE, TRUE
[16:11:01.280] signalConditionsASAP(NULL, pos=0) ... done
[16:11:01.280] resolve() on list ... DONE
[16:11:01.281]  - Number of value chunks collected: 2
[16:11:01.281] Resolving 2 futures (chunks) ... DONE
[16:11:01.281] Reducing values from 2 chunks ...
[16:11:01.281]  - Number of values collected after concatenation: 10
[16:11:01.281]  - Number of values expected: 10
[16:11:01.281] Reducing values from 2 chunks ... DONE
[16:11:01.281] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:11:01.283] future_lapply() ...
[16:11:01.291] Number of chunks: 2
[16:11:01.291] getGlobalsAndPackagesXApply() ...
[16:11:01.292]  - future.globals: TRUE
[16:11:01.292] getGlobalsAndPackages() ...
[16:11:01.292] Searching for globals...
[16:11:01.297] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:11:01.297] Searching for globals ... DONE
[16:11:01.297] Resolving globals: FALSE
[16:11:01.298] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:11:01.299] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:01.299] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.299] - packages: [1] ‘future.apply’
[16:11:01.299] getGlobalsAndPackages() ... DONE
[16:11:01.299]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.299]  - needed namespaces: [n=1] ‘future.apply’
[16:11:01.300] Finding globals ... DONE
[16:11:01.300]  - use_args: TRUE
[16:11:01.300]  - Getting '...' globals ...
[16:11:01.300] resolve() on list ...
[16:11:01.300]  recursive: 0
[16:11:01.300]  length: 1
[16:11:01.300]  elements: ‘...’
[16:11:01.301]  length: 0 (resolved future 1)
[16:11:01.301] resolve() on list ... DONE
[16:11:01.301]    - '...' content: [n=0] 
[16:11:01.301] List of 1
[16:11:01.301]  $ ...: list()
[16:11:01.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.301]  - attr(*, "where")=List of 1
[16:11:01.301]   ..$ ...:<environment: 0x561e8a2a3210> 
[16:11:01.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.301]  - attr(*, "resolved")= logi TRUE
[16:11:01.301]  - attr(*, "total_size")= num NA
[16:11:01.303]  - Getting '...' globals ... DONE
[16:11:01.304] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:01.304] List of 8
[16:11:01.304]  $ ...future.FUN:function (x, ...)  
[16:11:01.304]  $ x_FUN        :function (x)  
[16:11:01.304]  $ times        : int 4
[16:11:01.304]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.304]  $ stop_if_not  :function (...)  
[16:11:01.304]  $ dim          : int [1:2] 2 2
[16:11:01.304]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:01.304]  $ ...          : list()
[16:11:01.304]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.304]  - attr(*, "where")=List of 8
[16:11:01.304]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:01.304]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:01.304]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:01.304]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:01.304]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:01.304]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:01.304]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:01.304]   ..$ ...          :<environment: 0x561e8a2a3210> 
[16:11:01.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.304]  - attr(*, "resolved")= logi FALSE
[16:11:01.304]  - attr(*, "total_size")= num 97304
[16:11:01.309] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:01.309] getGlobalsAndPackagesXApply() ... DONE
[16:11:01.310] Number of futures (= number of chunks): 2
[16:11:01.310] Launching 2 futures (chunks) ...
[16:11:01.310] Chunk #1 of 2 ...
[16:11:01.310]  - Finding globals in 'X' for chunk #1 ...
[16:11:01.310] getGlobalsAndPackages() ...
[16:11:01.310] Searching for globals...
[16:11:01.310] 
[16:11:01.311] Searching for globals ... DONE
[16:11:01.311] - globals: [0] <none>
[16:11:01.311] getGlobalsAndPackages() ... DONE
[16:11:01.311]    + additional globals found: [n=0] 
[16:11:01.311]    + additional namespaces needed: [n=0] 
[16:11:01.311]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:01.311]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:01.311]  - seeds: <none>
[16:11:01.311] getGlobalsAndPackages() ...
[16:11:01.311] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.313] Resolving globals: FALSE
[16:11:01.313] Tweak future expression to call with '...' arguments ...
[16:11:01.314] {
[16:11:01.314]     do.call(function(...) {
[16:11:01.314]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.314]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.314]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.314]             on.exit(options(oopts), add = TRUE)
[16:11:01.314]         }
[16:11:01.314]         {
[16:11:01.314]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.314]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.314]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.314]             })
[16:11:01.314]         }
[16:11:01.314]     }, args = future.call.arguments)
[16:11:01.314] }
[16:11:01.314] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.314] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.315] - packages: [1] ‘future.apply’
[16:11:01.315] getGlobalsAndPackages() ... DONE
[16:11:01.315] run() for ‘Future’ ...
[16:11:01.315] - state: ‘created’
[16:11:01.315] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.319] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.319]   - Field: ‘label’
[16:11:01.319]   - Field: ‘local’
[16:11:01.320]   - Field: ‘owner’
[16:11:01.320]   - Field: ‘envir’
[16:11:01.320]   - Field: ‘workers’
[16:11:01.320]   - Field: ‘packages’
[16:11:01.320]   - Field: ‘gc’
[16:11:01.320]   - Field: ‘job’
[16:11:01.320]   - Field: ‘conditions’
[16:11:01.320]   - Field: ‘expr’
[16:11:01.321]   - Field: ‘uuid’
[16:11:01.321]   - Field: ‘seed’
[16:11:01.321]   - Field: ‘version’
[16:11:01.321]   - Field: ‘result’
[16:11:01.321]   - Field: ‘asynchronous’
[16:11:01.321]   - Field: ‘calls’
[16:11:01.321]   - Field: ‘globals’
[16:11:01.321]   - Field: ‘stdout’
[16:11:01.321]   - Field: ‘earlySignal’
[16:11:01.321]   - Field: ‘lazy’
[16:11:01.322]   - Field: ‘state’
[16:11:01.322] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.322] - Launch lazy future ...
[16:11:01.322] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:01.322] Packages needed by future strategies (n = 0): <none>
[16:11:01.323] {
[16:11:01.323]     {
[16:11:01.323]         {
[16:11:01.323]             ...future.startTime <- base::Sys.time()
[16:11:01.323]             {
[16:11:01.323]                 {
[16:11:01.323]                   {
[16:11:01.323]                     {
[16:11:01.323]                       {
[16:11:01.323]                         base::local({
[16:11:01.323]                           has_future <- base::requireNamespace("future", 
[16:11:01.323]                             quietly = TRUE)
[16:11:01.323]                           if (has_future) {
[16:11:01.323]                             ns <- base::getNamespace("future")
[16:11:01.323]                             version <- ns[[".package"]][["version"]]
[16:11:01.323]                             if (is.null(version)) 
[16:11:01.323]                               version <- utils::packageVersion("future")
[16:11:01.323]                           }
[16:11:01.323]                           else {
[16:11:01.323]                             version <- NULL
[16:11:01.323]                           }
[16:11:01.323]                           if (!has_future || version < "1.8.0") {
[16:11:01.323]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.323]                               "", base::R.version$version.string), 
[16:11:01.323]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.323]                                 base::R.version$platform, 8 * 
[16:11:01.323]                                   base::.Machine$sizeof.pointer), 
[16:11:01.323]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.323]                                 "release", "version")], collapse = " "), 
[16:11:01.323]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.323]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.323]                               info)
[16:11:01.323]                             info <- base::paste(info, collapse = "; ")
[16:11:01.323]                             if (!has_future) {
[16:11:01.323]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.323]                                 info)
[16:11:01.323]                             }
[16:11:01.323]                             else {
[16:11:01.323]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.323]                                 info, version)
[16:11:01.323]                             }
[16:11:01.323]                             base::stop(msg)
[16:11:01.323]                           }
[16:11:01.323]                         })
[16:11:01.323]                       }
[16:11:01.323]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.323]                       base::options(mc.cores = 1L)
[16:11:01.323]                     }
[16:11:01.323]                     base::local({
[16:11:01.323]                       for (pkg in "future.apply") {
[16:11:01.323]                         base::loadNamespace(pkg)
[16:11:01.323]                         base::library(pkg, character.only = TRUE)
[16:11:01.323]                       }
[16:11:01.323]                     })
[16:11:01.323]                   }
[16:11:01.323]                   options(future.plan = NULL)
[16:11:01.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.323]                 }
[16:11:01.323]                 ...future.workdir <- getwd()
[16:11:01.323]             }
[16:11:01.323]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.323]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.323]         }
[16:11:01.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.323]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:01.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.323]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.323]             base::names(...future.oldOptions))
[16:11:01.323]     }
[16:11:01.323]     if (FALSE) {
[16:11:01.323]     }
[16:11:01.323]     else {
[16:11:01.323]         if (TRUE) {
[16:11:01.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.323]                 open = "w")
[16:11:01.323]         }
[16:11:01.323]         else {
[16:11:01.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.323]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.323]         }
[16:11:01.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.323]             base::sink(type = "output", split = FALSE)
[16:11:01.323]             base::close(...future.stdout)
[16:11:01.323]         }, add = TRUE)
[16:11:01.323]     }
[16:11:01.323]     ...future.frame <- base::sys.nframe()
[16:11:01.323]     ...future.conditions <- base::list()
[16:11:01.323]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.323]     if (FALSE) {
[16:11:01.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.323]     }
[16:11:01.323]     ...future.result <- base::tryCatch({
[16:11:01.323]         base::withCallingHandlers({
[16:11:01.323]             ...future.value <- base::withVisible(base::local({
[16:11:01.323]                 withCallingHandlers({
[16:11:01.323]                   {
[16:11:01.323]                     do.call(function(...) {
[16:11:01.323]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.323]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.323]                         ...future.globals.maxSize)) {
[16:11:01.323]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.323]                         on.exit(options(oopts), add = TRUE)
[16:11:01.323]                       }
[16:11:01.323]                       {
[16:11:01.323]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.323]                           FUN = function(jj) {
[16:11:01.323]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.323]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.323]                           })
[16:11:01.323]                       }
[16:11:01.323]                     }, args = future.call.arguments)
[16:11:01.323]                   }
[16:11:01.323]                 }, immediateCondition = function(cond) {
[16:11:01.323]                   save_rds <- function (object, pathname, ...) 
[16:11:01.323]                   {
[16:11:01.323]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.323]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.323]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.323]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.323]                         fi_tmp[["mtime"]])
[16:11:01.323]                     }
[16:11:01.323]                     tryCatch({
[16:11:01.323]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.323]                     }, error = function(ex) {
[16:11:01.323]                       msg <- conditionMessage(ex)
[16:11:01.323]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.323]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.323]                         fi_tmp[["mtime"]], msg)
[16:11:01.323]                       ex$message <- msg
[16:11:01.323]                       stop(ex)
[16:11:01.323]                     })
[16:11:01.323]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.323]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.323]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.323]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.323]                       fi <- file.info(pathname)
[16:11:01.323]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.323]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.323]                         fi[["size"]], fi[["mtime"]])
[16:11:01.323]                       stop(msg)
[16:11:01.323]                     }
[16:11:01.323]                     invisible(pathname)
[16:11:01.323]                   }
[16:11:01.323]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.323]                     rootPath = tempdir()) 
[16:11:01.323]                   {
[16:11:01.323]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.323]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.323]                       tmpdir = path, fileext = ".rds")
[16:11:01.323]                     save_rds(obj, file)
[16:11:01.323]                   }
[16:11:01.323]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.323]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.323]                   {
[16:11:01.323]                     inherits <- base::inherits
[16:11:01.323]                     invokeRestart <- base::invokeRestart
[16:11:01.323]                     is.null <- base::is.null
[16:11:01.323]                     muffled <- FALSE
[16:11:01.323]                     if (inherits(cond, "message")) {
[16:11:01.323]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.323]                       if (muffled) 
[16:11:01.323]                         invokeRestart("muffleMessage")
[16:11:01.323]                     }
[16:11:01.323]                     else if (inherits(cond, "warning")) {
[16:11:01.323]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.323]                       if (muffled) 
[16:11:01.323]                         invokeRestart("muffleWarning")
[16:11:01.323]                     }
[16:11:01.323]                     else if (inherits(cond, "condition")) {
[16:11:01.323]                       if (!is.null(pattern)) {
[16:11:01.323]                         computeRestarts <- base::computeRestarts
[16:11:01.323]                         grepl <- base::grepl
[16:11:01.323]                         restarts <- computeRestarts(cond)
[16:11:01.323]                         for (restart in restarts) {
[16:11:01.323]                           name <- restart$name
[16:11:01.323]                           if (is.null(name)) 
[16:11:01.323]                             next
[16:11:01.323]                           if (!grepl(pattern, name)) 
[16:11:01.323]                             next
[16:11:01.323]                           invokeRestart(restart)
[16:11:01.323]                           muffled <- TRUE
[16:11:01.323]                           break
[16:11:01.323]                         }
[16:11:01.323]                       }
[16:11:01.323]                     }
[16:11:01.323]                     invisible(muffled)
[16:11:01.323]                   }
[16:11:01.323]                   muffleCondition(cond)
[16:11:01.323]                 })
[16:11:01.323]             }))
[16:11:01.323]             future::FutureResult(value = ...future.value$value, 
[16:11:01.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.323]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.323]                     ...future.globalenv.names))
[16:11:01.323]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.323]         }, condition = base::local({
[16:11:01.323]             c <- base::c
[16:11:01.323]             inherits <- base::inherits
[16:11:01.323]             invokeRestart <- base::invokeRestart
[16:11:01.323]             length <- base::length
[16:11:01.323]             list <- base::list
[16:11:01.323]             seq.int <- base::seq.int
[16:11:01.323]             signalCondition <- base::signalCondition
[16:11:01.323]             sys.calls <- base::sys.calls
[16:11:01.323]             `[[` <- base::`[[`
[16:11:01.323]             `+` <- base::`+`
[16:11:01.323]             `<<-` <- base::`<<-`
[16:11:01.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.323]                   3L)]
[16:11:01.323]             }
[16:11:01.323]             function(cond) {
[16:11:01.323]                 is_error <- inherits(cond, "error")
[16:11:01.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.323]                   NULL)
[16:11:01.323]                 if (is_error) {
[16:11:01.323]                   sessionInformation <- function() {
[16:11:01.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.323]                       search = base::search(), system = base::Sys.info())
[16:11:01.323]                   }
[16:11:01.323]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.323]                     cond$call), session = sessionInformation(), 
[16:11:01.323]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.323]                   signalCondition(cond)
[16:11:01.323]                 }
[16:11:01.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.323]                 "immediateCondition"))) {
[16:11:01.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.323]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.323]                   if (TRUE && !signal) {
[16:11:01.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.323]                     {
[16:11:01.323]                       inherits <- base::inherits
[16:11:01.323]                       invokeRestart <- base::invokeRestart
[16:11:01.323]                       is.null <- base::is.null
[16:11:01.323]                       muffled <- FALSE
[16:11:01.323]                       if (inherits(cond, "message")) {
[16:11:01.323]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.323]                         if (muffled) 
[16:11:01.323]                           invokeRestart("muffleMessage")
[16:11:01.323]                       }
[16:11:01.323]                       else if (inherits(cond, "warning")) {
[16:11:01.323]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.323]                         if (muffled) 
[16:11:01.323]                           invokeRestart("muffleWarning")
[16:11:01.323]                       }
[16:11:01.323]                       else if (inherits(cond, "condition")) {
[16:11:01.323]                         if (!is.null(pattern)) {
[16:11:01.323]                           computeRestarts <- base::computeRestarts
[16:11:01.323]                           grepl <- base::grepl
[16:11:01.323]                           restarts <- computeRestarts(cond)
[16:11:01.323]                           for (restart in restarts) {
[16:11:01.323]                             name <- restart$name
[16:11:01.323]                             if (is.null(name)) 
[16:11:01.323]                               next
[16:11:01.323]                             if (!grepl(pattern, name)) 
[16:11:01.323]                               next
[16:11:01.323]                             invokeRestart(restart)
[16:11:01.323]                             muffled <- TRUE
[16:11:01.323]                             break
[16:11:01.323]                           }
[16:11:01.323]                         }
[16:11:01.323]                       }
[16:11:01.323]                       invisible(muffled)
[16:11:01.323]                     }
[16:11:01.323]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.323]                   }
[16:11:01.323]                 }
[16:11:01.323]                 else {
[16:11:01.323]                   if (TRUE) {
[16:11:01.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.323]                     {
[16:11:01.323]                       inherits <- base::inherits
[16:11:01.323]                       invokeRestart <- base::invokeRestart
[16:11:01.323]                       is.null <- base::is.null
[16:11:01.323]                       muffled <- FALSE
[16:11:01.323]                       if (inherits(cond, "message")) {
[16:11:01.323]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.323]                         if (muffled) 
[16:11:01.323]                           invokeRestart("muffleMessage")
[16:11:01.323]                       }
[16:11:01.323]                       else if (inherits(cond, "warning")) {
[16:11:01.323]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.323]                         if (muffled) 
[16:11:01.323]                           invokeRestart("muffleWarning")
[16:11:01.323]                       }
[16:11:01.323]                       else if (inherits(cond, "condition")) {
[16:11:01.323]                         if (!is.null(pattern)) {
[16:11:01.323]                           computeRestarts <- base::computeRestarts
[16:11:01.323]                           grepl <- base::grepl
[16:11:01.323]                           restarts <- computeRestarts(cond)
[16:11:01.323]                           for (restart in restarts) {
[16:11:01.323]                             name <- restart$name
[16:11:01.323]                             if (is.null(name)) 
[16:11:01.323]                               next
[16:11:01.323]                             if (!grepl(pattern, name)) 
[16:11:01.323]                               next
[16:11:01.323]                             invokeRestart(restart)
[16:11:01.323]                             muffled <- TRUE
[16:11:01.323]                             break
[16:11:01.323]                           }
[16:11:01.323]                         }
[16:11:01.323]                       }
[16:11:01.323]                       invisible(muffled)
[16:11:01.323]                     }
[16:11:01.323]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.323]                   }
[16:11:01.323]                 }
[16:11:01.323]             }
[16:11:01.323]         }))
[16:11:01.323]     }, error = function(ex) {
[16:11:01.323]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.323]                 ...future.rng), started = ...future.startTime, 
[16:11:01.323]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.323]             version = "1.8"), class = "FutureResult")
[16:11:01.323]     }, finally = {
[16:11:01.323]         if (!identical(...future.workdir, getwd())) 
[16:11:01.323]             setwd(...future.workdir)
[16:11:01.323]         {
[16:11:01.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.323]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.323]             }
[16:11:01.323]             base::options(...future.oldOptions)
[16:11:01.323]             if (.Platform$OS.type == "windows") {
[16:11:01.323]                 old_names <- names(...future.oldEnvVars)
[16:11:01.323]                 envs <- base::Sys.getenv()
[16:11:01.323]                 names <- names(envs)
[16:11:01.323]                 common <- intersect(names, old_names)
[16:11:01.323]                 added <- setdiff(names, old_names)
[16:11:01.323]                 removed <- setdiff(old_names, names)
[16:11:01.323]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.323]                   envs[common]]
[16:11:01.323]                 NAMES <- toupper(changed)
[16:11:01.323]                 args <- list()
[16:11:01.323]                 for (kk in seq_along(NAMES)) {
[16:11:01.323]                   name <- changed[[kk]]
[16:11:01.323]                   NAME <- NAMES[[kk]]
[16:11:01.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.323]                     next
[16:11:01.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.323]                 }
[16:11:01.323]                 NAMES <- toupper(added)
[16:11:01.323]                 for (kk in seq_along(NAMES)) {
[16:11:01.323]                   name <- added[[kk]]
[16:11:01.323]                   NAME <- NAMES[[kk]]
[16:11:01.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.323]                     next
[16:11:01.323]                   args[[name]] <- ""
[16:11:01.323]                 }
[16:11:01.323]                 NAMES <- toupper(removed)
[16:11:01.323]                 for (kk in seq_along(NAMES)) {
[16:11:01.323]                   name <- removed[[kk]]
[16:11:01.323]                   NAME <- NAMES[[kk]]
[16:11:01.323]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.323]                     next
[16:11:01.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.323]                 }
[16:11:01.323]                 if (length(args) > 0) 
[16:11:01.323]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.323]             }
[16:11:01.323]             else {
[16:11:01.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.323]             }
[16:11:01.323]             {
[16:11:01.323]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.323]                   0L) {
[16:11:01.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.323]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.323]                   base::options(opts)
[16:11:01.323]                 }
[16:11:01.323]                 {
[16:11:01.323]                   {
[16:11:01.323]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.323]                     NULL
[16:11:01.323]                   }
[16:11:01.323]                   options(future.plan = NULL)
[16:11:01.323]                   if (is.na(NA_character_)) 
[16:11:01.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.323]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.323]                     envir = parent.frame()) 
[16:11:01.323]                   {
[16:11:01.323]                     default_workers <- missing(workers)
[16:11:01.323]                     if (is.function(workers)) 
[16:11:01.323]                       workers <- workers()
[16:11:01.323]                     workers <- structure(as.integer(workers), 
[16:11:01.323]                       class = class(workers))
[16:11:01.323]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.323]                       1L)
[16:11:01.323]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.323]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.323]                       if (default_workers) 
[16:11:01.323]                         supportsMulticore(warn = TRUE)
[16:11:01.323]                       return(sequential(..., envir = envir))
[16:11:01.323]                     }
[16:11:01.323]                     oopts <- options(mc.cores = workers)
[16:11:01.323]                     on.exit(options(oopts))
[16:11:01.323]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.323]                       envir = envir)
[16:11:01.323]                     if (!future$lazy) 
[16:11:01.323]                       future <- run(future)
[16:11:01.323]                     invisible(future)
[16:11:01.323]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.323]                 }
[16:11:01.323]             }
[16:11:01.323]         }
[16:11:01.323]     })
[16:11:01.323]     if (TRUE) {
[16:11:01.323]         base::sink(type = "output", split = FALSE)
[16:11:01.323]         if (TRUE) {
[16:11:01.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.323]         }
[16:11:01.323]         else {
[16:11:01.323]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.323]         }
[16:11:01.323]         base::close(...future.stdout)
[16:11:01.323]         ...future.stdout <- NULL
[16:11:01.323]     }
[16:11:01.323]     ...future.result$conditions <- ...future.conditions
[16:11:01.323]     ...future.result$finished <- base::Sys.time()
[16:11:01.323]     ...future.result
[16:11:01.323] }
[16:11:01.325] assign_globals() ...
[16:11:01.326] List of 11
[16:11:01.326]  $ ...future.FUN            :function (x, ...)  
[16:11:01.326]  $ x_FUN                    :function (x)  
[16:11:01.326]  $ times                    : int 4
[16:11:01.326]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.326]  $ stop_if_not              :function (...)  
[16:11:01.326]  $ dim                      : int [1:2] 2 2
[16:11:01.326]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.326]  $ future.call.arguments    : list()
[16:11:01.326]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.326]  $ ...future.elements_ii    :List of 5
[16:11:01.326]   ..$ : int 1
[16:11:01.326]   ..$ : int 2
[16:11:01.326]   ..$ : int 3
[16:11:01.326]   ..$ : int 4
[16:11:01.326]   ..$ : int 5
[16:11:01.326]  $ ...future.seeds_ii       : NULL
[16:11:01.326]  $ ...future.globals.maxSize: NULL
[16:11:01.326]  - attr(*, "resolved")= logi FALSE
[16:11:01.326]  - attr(*, "total_size")= num 97304
[16:11:01.326]  - attr(*, "where")=List of 11
[16:11:01.326]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.326]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.326]  - attr(*, "already-done")= logi TRUE
[16:11:01.334] - copied ‘...future.FUN’ to environment
[16:11:01.334] - reassign environment for ‘x_FUN’
[16:11:01.334] - copied ‘x_FUN’ to environment
[16:11:01.335] - copied ‘times’ to environment
[16:11:01.335] - copied ‘stopf’ to environment
[16:11:01.335] - copied ‘stop_if_not’ to environment
[16:11:01.335] - copied ‘dim’ to environment
[16:11:01.335] - copied ‘valid_types’ to environment
[16:11:01.335] - copied ‘future.call.arguments’ to environment
[16:11:01.335] - copied ‘...future.elements_ii’ to environment
[16:11:01.335] - copied ‘...future.seeds_ii’ to environment
[16:11:01.335] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.335] assign_globals() ... done
[16:11:01.336] requestCore(): workers = 2
[16:11:01.338] MulticoreFuture started
[16:11:01.338] - Launch lazy future ... done
[16:11:01.338] run() for ‘MulticoreFuture’ ... done
[16:11:01.339] Created future:
[16:11:01.339] plan(): Setting new future strategy stack:
[16:11:01.340] List of future strategies:
[16:11:01.340] 1. sequential:
[16:11:01.340]    - args: function (..., envir = parent.frame())
[16:11:01.340]    - tweaked: FALSE
[16:11:01.340]    - call: NULL
[16:11:01.340] plan(): nbrOfWorkers() = 1
[16:11:01.346] plan(): Setting new future strategy stack:
[16:11:01.347] List of future strategies:
[16:11:01.347] 1. multicore:
[16:11:01.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.347]    - tweaked: FALSE
[16:11:01.347]    - call: plan(strategy)
[16:11:01.354] plan(): nbrOfWorkers() = 2
[16:11:01.339] MulticoreFuture:
[16:11:01.339] Label: ‘future_vapply-1’
[16:11:01.339] Expression:
[16:11:01.339] {
[16:11:01.339]     do.call(function(...) {
[16:11:01.339]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.339]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.339]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.339]             on.exit(options(oopts), add = TRUE)
[16:11:01.339]         }
[16:11:01.339]         {
[16:11:01.339]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.339]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.339]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.339]             })
[16:11:01.339]         }
[16:11:01.339]     }, args = future.call.arguments)
[16:11:01.339] }
[16:11:01.339] Lazy evaluation: FALSE
[16:11:01.339] Asynchronous evaluation: TRUE
[16:11:01.339] Local evaluation: TRUE
[16:11:01.339] Environment: R_GlobalEnv
[16:11:01.339] Capture standard output: TRUE
[16:11:01.339] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.339] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.339] Packages: 1 packages (‘future.apply’)
[16:11:01.339] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.339] Resolved: TRUE
[16:11:01.339] Value: <not collected>
[16:11:01.339] Conditions captured: <none>
[16:11:01.339] Early signaling: FALSE
[16:11:01.339] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.339] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.355] Chunk #1 of 2 ... DONE
[16:11:01.355] Chunk #2 of 2 ...
[16:11:01.355]  - Finding globals in 'X' for chunk #2 ...
[16:11:01.356] getGlobalsAndPackages() ...
[16:11:01.356] Searching for globals...
[16:11:01.357] 
[16:11:01.357] Searching for globals ... DONE
[16:11:01.357] - globals: [0] <none>
[16:11:01.357] getGlobalsAndPackages() ... DONE
[16:11:01.357]    + additional globals found: [n=0] 
[16:11:01.357]    + additional namespaces needed: [n=0] 
[16:11:01.358]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:01.358]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:01.358]  - seeds: <none>
[16:11:01.358] getGlobalsAndPackages() ...
[16:11:01.359] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.359] Resolving globals: FALSE
[16:11:01.359] Tweak future expression to call with '...' arguments ...
[16:11:01.360] {
[16:11:01.360]     do.call(function(...) {
[16:11:01.360]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.360]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.360]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.360]             on.exit(options(oopts), add = TRUE)
[16:11:01.360]         }
[16:11:01.360]         {
[16:11:01.360]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.360]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.360]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.360]             })
[16:11:01.360]         }
[16:11:01.360]     }, args = future.call.arguments)
[16:11:01.360] }
[16:11:01.360] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.361] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.362] - packages: [1] ‘future.apply’
[16:11:01.362] getGlobalsAndPackages() ... DONE
[16:11:01.363] run() for ‘Future’ ...
[16:11:01.363] - state: ‘created’
[16:11:01.363] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.368] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.369]   - Field: ‘label’
[16:11:01.369]   - Field: ‘local’
[16:11:01.369]   - Field: ‘owner’
[16:11:01.369]   - Field: ‘envir’
[16:11:01.369]   - Field: ‘workers’
[16:11:01.369]   - Field: ‘packages’
[16:11:01.369]   - Field: ‘gc’
[16:11:01.370]   - Field: ‘job’
[16:11:01.370]   - Field: ‘conditions’
[16:11:01.370]   - Field: ‘expr’
[16:11:01.370]   - Field: ‘uuid’
[16:11:01.370]   - Field: ‘seed’
[16:11:01.371]   - Field: ‘version’
[16:11:01.371]   - Field: ‘result’
[16:11:01.371]   - Field: ‘asynchronous’
[16:11:01.371]   - Field: ‘calls’
[16:11:01.371]   - Field: ‘globals’
[16:11:01.371]   - Field: ‘stdout’
[16:11:01.372]   - Field: ‘earlySignal’
[16:11:01.372]   - Field: ‘lazy’
[16:11:01.372]   - Field: ‘state’
[16:11:01.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.372] - Launch lazy future ...
[16:11:01.373] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:01.373] Packages needed by future strategies (n = 0): <none>
[16:11:01.374] {
[16:11:01.374]     {
[16:11:01.374]         {
[16:11:01.374]             ...future.startTime <- base::Sys.time()
[16:11:01.374]             {
[16:11:01.374]                 {
[16:11:01.374]                   {
[16:11:01.374]                     {
[16:11:01.374]                       {
[16:11:01.374]                         base::local({
[16:11:01.374]                           has_future <- base::requireNamespace("future", 
[16:11:01.374]                             quietly = TRUE)
[16:11:01.374]                           if (has_future) {
[16:11:01.374]                             ns <- base::getNamespace("future")
[16:11:01.374]                             version <- ns[[".package"]][["version"]]
[16:11:01.374]                             if (is.null(version)) 
[16:11:01.374]                               version <- utils::packageVersion("future")
[16:11:01.374]                           }
[16:11:01.374]                           else {
[16:11:01.374]                             version <- NULL
[16:11:01.374]                           }
[16:11:01.374]                           if (!has_future || version < "1.8.0") {
[16:11:01.374]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.374]                               "", base::R.version$version.string), 
[16:11:01.374]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.374]                                 base::R.version$platform, 8 * 
[16:11:01.374]                                   base::.Machine$sizeof.pointer), 
[16:11:01.374]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.374]                                 "release", "version")], collapse = " "), 
[16:11:01.374]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.374]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.374]                               info)
[16:11:01.374]                             info <- base::paste(info, collapse = "; ")
[16:11:01.374]                             if (!has_future) {
[16:11:01.374]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.374]                                 info)
[16:11:01.374]                             }
[16:11:01.374]                             else {
[16:11:01.374]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.374]                                 info, version)
[16:11:01.374]                             }
[16:11:01.374]                             base::stop(msg)
[16:11:01.374]                           }
[16:11:01.374]                         })
[16:11:01.374]                       }
[16:11:01.374]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.374]                       base::options(mc.cores = 1L)
[16:11:01.374]                     }
[16:11:01.374]                     base::local({
[16:11:01.374]                       for (pkg in "future.apply") {
[16:11:01.374]                         base::loadNamespace(pkg)
[16:11:01.374]                         base::library(pkg, character.only = TRUE)
[16:11:01.374]                       }
[16:11:01.374]                     })
[16:11:01.374]                   }
[16:11:01.374]                   options(future.plan = NULL)
[16:11:01.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.374]                 }
[16:11:01.374]                 ...future.workdir <- getwd()
[16:11:01.374]             }
[16:11:01.374]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.374]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.374]         }
[16:11:01.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.374]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:01.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.374]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.374]             base::names(...future.oldOptions))
[16:11:01.374]     }
[16:11:01.374]     if (FALSE) {
[16:11:01.374]     }
[16:11:01.374]     else {
[16:11:01.374]         if (TRUE) {
[16:11:01.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.374]                 open = "w")
[16:11:01.374]         }
[16:11:01.374]         else {
[16:11:01.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.374]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.374]         }
[16:11:01.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.374]             base::sink(type = "output", split = FALSE)
[16:11:01.374]             base::close(...future.stdout)
[16:11:01.374]         }, add = TRUE)
[16:11:01.374]     }
[16:11:01.374]     ...future.frame <- base::sys.nframe()
[16:11:01.374]     ...future.conditions <- base::list()
[16:11:01.374]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.374]     if (FALSE) {
[16:11:01.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.374]     }
[16:11:01.374]     ...future.result <- base::tryCatch({
[16:11:01.374]         base::withCallingHandlers({
[16:11:01.374]             ...future.value <- base::withVisible(base::local({
[16:11:01.374]                 withCallingHandlers({
[16:11:01.374]                   {
[16:11:01.374]                     do.call(function(...) {
[16:11:01.374]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.374]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.374]                         ...future.globals.maxSize)) {
[16:11:01.374]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.374]                         on.exit(options(oopts), add = TRUE)
[16:11:01.374]                       }
[16:11:01.374]                       {
[16:11:01.374]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.374]                           FUN = function(jj) {
[16:11:01.374]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.374]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.374]                           })
[16:11:01.374]                       }
[16:11:01.374]                     }, args = future.call.arguments)
[16:11:01.374]                   }
[16:11:01.374]                 }, immediateCondition = function(cond) {
[16:11:01.374]                   save_rds <- function (object, pathname, ...) 
[16:11:01.374]                   {
[16:11:01.374]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.374]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.374]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.374]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.374]                         fi_tmp[["mtime"]])
[16:11:01.374]                     }
[16:11:01.374]                     tryCatch({
[16:11:01.374]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.374]                     }, error = function(ex) {
[16:11:01.374]                       msg <- conditionMessage(ex)
[16:11:01.374]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.374]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.374]                         fi_tmp[["mtime"]], msg)
[16:11:01.374]                       ex$message <- msg
[16:11:01.374]                       stop(ex)
[16:11:01.374]                     })
[16:11:01.374]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.374]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.374]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.374]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.374]                       fi <- file.info(pathname)
[16:11:01.374]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.374]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.374]                         fi[["size"]], fi[["mtime"]])
[16:11:01.374]                       stop(msg)
[16:11:01.374]                     }
[16:11:01.374]                     invisible(pathname)
[16:11:01.374]                   }
[16:11:01.374]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.374]                     rootPath = tempdir()) 
[16:11:01.374]                   {
[16:11:01.374]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.374]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.374]                       tmpdir = path, fileext = ".rds")
[16:11:01.374]                     save_rds(obj, file)
[16:11:01.374]                   }
[16:11:01.374]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.374]                   {
[16:11:01.374]                     inherits <- base::inherits
[16:11:01.374]                     invokeRestart <- base::invokeRestart
[16:11:01.374]                     is.null <- base::is.null
[16:11:01.374]                     muffled <- FALSE
[16:11:01.374]                     if (inherits(cond, "message")) {
[16:11:01.374]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.374]                       if (muffled) 
[16:11:01.374]                         invokeRestart("muffleMessage")
[16:11:01.374]                     }
[16:11:01.374]                     else if (inherits(cond, "warning")) {
[16:11:01.374]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.374]                       if (muffled) 
[16:11:01.374]                         invokeRestart("muffleWarning")
[16:11:01.374]                     }
[16:11:01.374]                     else if (inherits(cond, "condition")) {
[16:11:01.374]                       if (!is.null(pattern)) {
[16:11:01.374]                         computeRestarts <- base::computeRestarts
[16:11:01.374]                         grepl <- base::grepl
[16:11:01.374]                         restarts <- computeRestarts(cond)
[16:11:01.374]                         for (restart in restarts) {
[16:11:01.374]                           name <- restart$name
[16:11:01.374]                           if (is.null(name)) 
[16:11:01.374]                             next
[16:11:01.374]                           if (!grepl(pattern, name)) 
[16:11:01.374]                             next
[16:11:01.374]                           invokeRestart(restart)
[16:11:01.374]                           muffled <- TRUE
[16:11:01.374]                           break
[16:11:01.374]                         }
[16:11:01.374]                       }
[16:11:01.374]                     }
[16:11:01.374]                     invisible(muffled)
[16:11:01.374]                   }
[16:11:01.374]                   muffleCondition(cond)
[16:11:01.374]                 })
[16:11:01.374]             }))
[16:11:01.374]             future::FutureResult(value = ...future.value$value, 
[16:11:01.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.374]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.374]                     ...future.globalenv.names))
[16:11:01.374]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.374]         }, condition = base::local({
[16:11:01.374]             c <- base::c
[16:11:01.374]             inherits <- base::inherits
[16:11:01.374]             invokeRestart <- base::invokeRestart
[16:11:01.374]             length <- base::length
[16:11:01.374]             list <- base::list
[16:11:01.374]             seq.int <- base::seq.int
[16:11:01.374]             signalCondition <- base::signalCondition
[16:11:01.374]             sys.calls <- base::sys.calls
[16:11:01.374]             `[[` <- base::`[[`
[16:11:01.374]             `+` <- base::`+`
[16:11:01.374]             `<<-` <- base::`<<-`
[16:11:01.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.374]                   3L)]
[16:11:01.374]             }
[16:11:01.374]             function(cond) {
[16:11:01.374]                 is_error <- inherits(cond, "error")
[16:11:01.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.374]                   NULL)
[16:11:01.374]                 if (is_error) {
[16:11:01.374]                   sessionInformation <- function() {
[16:11:01.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.374]                       search = base::search(), system = base::Sys.info())
[16:11:01.374]                   }
[16:11:01.374]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.374]                     cond$call), session = sessionInformation(), 
[16:11:01.374]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.374]                   signalCondition(cond)
[16:11:01.374]                 }
[16:11:01.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.374]                 "immediateCondition"))) {
[16:11:01.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.374]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.374]                   if (TRUE && !signal) {
[16:11:01.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.374]                     {
[16:11:01.374]                       inherits <- base::inherits
[16:11:01.374]                       invokeRestart <- base::invokeRestart
[16:11:01.374]                       is.null <- base::is.null
[16:11:01.374]                       muffled <- FALSE
[16:11:01.374]                       if (inherits(cond, "message")) {
[16:11:01.374]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.374]                         if (muffled) 
[16:11:01.374]                           invokeRestart("muffleMessage")
[16:11:01.374]                       }
[16:11:01.374]                       else if (inherits(cond, "warning")) {
[16:11:01.374]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.374]                         if (muffled) 
[16:11:01.374]                           invokeRestart("muffleWarning")
[16:11:01.374]                       }
[16:11:01.374]                       else if (inherits(cond, "condition")) {
[16:11:01.374]                         if (!is.null(pattern)) {
[16:11:01.374]                           computeRestarts <- base::computeRestarts
[16:11:01.374]                           grepl <- base::grepl
[16:11:01.374]                           restarts <- computeRestarts(cond)
[16:11:01.374]                           for (restart in restarts) {
[16:11:01.374]                             name <- restart$name
[16:11:01.374]                             if (is.null(name)) 
[16:11:01.374]                               next
[16:11:01.374]                             if (!grepl(pattern, name)) 
[16:11:01.374]                               next
[16:11:01.374]                             invokeRestart(restart)
[16:11:01.374]                             muffled <- TRUE
[16:11:01.374]                             break
[16:11:01.374]                           }
[16:11:01.374]                         }
[16:11:01.374]                       }
[16:11:01.374]                       invisible(muffled)
[16:11:01.374]                     }
[16:11:01.374]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.374]                   }
[16:11:01.374]                 }
[16:11:01.374]                 else {
[16:11:01.374]                   if (TRUE) {
[16:11:01.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.374]                     {
[16:11:01.374]                       inherits <- base::inherits
[16:11:01.374]                       invokeRestart <- base::invokeRestart
[16:11:01.374]                       is.null <- base::is.null
[16:11:01.374]                       muffled <- FALSE
[16:11:01.374]                       if (inherits(cond, "message")) {
[16:11:01.374]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.374]                         if (muffled) 
[16:11:01.374]                           invokeRestart("muffleMessage")
[16:11:01.374]                       }
[16:11:01.374]                       else if (inherits(cond, "warning")) {
[16:11:01.374]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.374]                         if (muffled) 
[16:11:01.374]                           invokeRestart("muffleWarning")
[16:11:01.374]                       }
[16:11:01.374]                       else if (inherits(cond, "condition")) {
[16:11:01.374]                         if (!is.null(pattern)) {
[16:11:01.374]                           computeRestarts <- base::computeRestarts
[16:11:01.374]                           grepl <- base::grepl
[16:11:01.374]                           restarts <- computeRestarts(cond)
[16:11:01.374]                           for (restart in restarts) {
[16:11:01.374]                             name <- restart$name
[16:11:01.374]                             if (is.null(name)) 
[16:11:01.374]                               next
[16:11:01.374]                             if (!grepl(pattern, name)) 
[16:11:01.374]                               next
[16:11:01.374]                             invokeRestart(restart)
[16:11:01.374]                             muffled <- TRUE
[16:11:01.374]                             break
[16:11:01.374]                           }
[16:11:01.374]                         }
[16:11:01.374]                       }
[16:11:01.374]                       invisible(muffled)
[16:11:01.374]                     }
[16:11:01.374]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.374]                   }
[16:11:01.374]                 }
[16:11:01.374]             }
[16:11:01.374]         }))
[16:11:01.374]     }, error = function(ex) {
[16:11:01.374]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.374]                 ...future.rng), started = ...future.startTime, 
[16:11:01.374]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.374]             version = "1.8"), class = "FutureResult")
[16:11:01.374]     }, finally = {
[16:11:01.374]         if (!identical(...future.workdir, getwd())) 
[16:11:01.374]             setwd(...future.workdir)
[16:11:01.374]         {
[16:11:01.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.374]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.374]             }
[16:11:01.374]             base::options(...future.oldOptions)
[16:11:01.374]             if (.Platform$OS.type == "windows") {
[16:11:01.374]                 old_names <- names(...future.oldEnvVars)
[16:11:01.374]                 envs <- base::Sys.getenv()
[16:11:01.374]                 names <- names(envs)
[16:11:01.374]                 common <- intersect(names, old_names)
[16:11:01.374]                 added <- setdiff(names, old_names)
[16:11:01.374]                 removed <- setdiff(old_names, names)
[16:11:01.374]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.374]                   envs[common]]
[16:11:01.374]                 NAMES <- toupper(changed)
[16:11:01.374]                 args <- list()
[16:11:01.374]                 for (kk in seq_along(NAMES)) {
[16:11:01.374]                   name <- changed[[kk]]
[16:11:01.374]                   NAME <- NAMES[[kk]]
[16:11:01.374]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.374]                     next
[16:11:01.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.374]                 }
[16:11:01.374]                 NAMES <- toupper(added)
[16:11:01.374]                 for (kk in seq_along(NAMES)) {
[16:11:01.374]                   name <- added[[kk]]
[16:11:01.374]                   NAME <- NAMES[[kk]]
[16:11:01.374]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.374]                     next
[16:11:01.374]                   args[[name]] <- ""
[16:11:01.374]                 }
[16:11:01.374]                 NAMES <- toupper(removed)
[16:11:01.374]                 for (kk in seq_along(NAMES)) {
[16:11:01.374]                   name <- removed[[kk]]
[16:11:01.374]                   NAME <- NAMES[[kk]]
[16:11:01.374]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.374]                     next
[16:11:01.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.374]                 }
[16:11:01.374]                 if (length(args) > 0) 
[16:11:01.374]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.374]             }
[16:11:01.374]             else {
[16:11:01.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.374]             }
[16:11:01.374]             {
[16:11:01.374]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.374]                   0L) {
[16:11:01.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.374]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.374]                   base::options(opts)
[16:11:01.374]                 }
[16:11:01.374]                 {
[16:11:01.374]                   {
[16:11:01.374]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.374]                     NULL
[16:11:01.374]                   }
[16:11:01.374]                   options(future.plan = NULL)
[16:11:01.374]                   if (is.na(NA_character_)) 
[16:11:01.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.374]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.374]                     envir = parent.frame()) 
[16:11:01.374]                   {
[16:11:01.374]                     default_workers <- missing(workers)
[16:11:01.374]                     if (is.function(workers)) 
[16:11:01.374]                       workers <- workers()
[16:11:01.374]                     workers <- structure(as.integer(workers), 
[16:11:01.374]                       class = class(workers))
[16:11:01.374]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.374]                       1L)
[16:11:01.374]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.374]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.374]                       if (default_workers) 
[16:11:01.374]                         supportsMulticore(warn = TRUE)
[16:11:01.374]                       return(sequential(..., envir = envir))
[16:11:01.374]                     }
[16:11:01.374]                     oopts <- options(mc.cores = workers)
[16:11:01.374]                     on.exit(options(oopts))
[16:11:01.374]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.374]                       envir = envir)
[16:11:01.374]                     if (!future$lazy) 
[16:11:01.374]                       future <- run(future)
[16:11:01.374]                     invisible(future)
[16:11:01.374]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.374]                 }
[16:11:01.374]             }
[16:11:01.374]         }
[16:11:01.374]     })
[16:11:01.374]     if (TRUE) {
[16:11:01.374]         base::sink(type = "output", split = FALSE)
[16:11:01.374]         if (TRUE) {
[16:11:01.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.374]         }
[16:11:01.374]         else {
[16:11:01.374]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.374]         }
[16:11:01.374]         base::close(...future.stdout)
[16:11:01.374]         ...future.stdout <- NULL
[16:11:01.374]     }
[16:11:01.374]     ...future.result$conditions <- ...future.conditions
[16:11:01.374]     ...future.result$finished <- base::Sys.time()
[16:11:01.374]     ...future.result
[16:11:01.374] }
[16:11:01.376] assign_globals() ...
[16:11:01.377] List of 11
[16:11:01.377]  $ ...future.FUN            :function (x, ...)  
[16:11:01.377]  $ x_FUN                    :function (x)  
[16:11:01.377]  $ times                    : int 4
[16:11:01.377]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.377]  $ stop_if_not              :function (...)  
[16:11:01.377]  $ dim                      : int [1:2] 2 2
[16:11:01.377]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.377]  $ future.call.arguments    : list()
[16:11:01.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.377]  $ ...future.elements_ii    :List of 5
[16:11:01.377]   ..$ : int 6
[16:11:01.377]   ..$ : int 7
[16:11:01.377]   ..$ : int 8
[16:11:01.377]   ..$ : int 9
[16:11:01.377]   ..$ : int 10
[16:11:01.377]  $ ...future.seeds_ii       : NULL
[16:11:01.377]  $ ...future.globals.maxSize: NULL
[16:11:01.377]  - attr(*, "resolved")= logi FALSE
[16:11:01.377]  - attr(*, "total_size")= num 97304
[16:11:01.377]  - attr(*, "where")=List of 11
[16:11:01.377]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.377]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.377]  - attr(*, "already-done")= logi TRUE
[16:11:01.387] - copied ‘...future.FUN’ to environment
[16:11:01.387] - reassign environment for ‘x_FUN’
[16:11:01.387] - copied ‘x_FUN’ to environment
[16:11:01.388] - copied ‘times’ to environment
[16:11:01.388] - copied ‘stopf’ to environment
[16:11:01.388] - copied ‘stop_if_not’ to environment
[16:11:01.390] - copied ‘dim’ to environment
[16:11:01.390] - copied ‘valid_types’ to environment
[16:11:01.390] - copied ‘future.call.arguments’ to environment
[16:11:01.390] - copied ‘...future.elements_ii’ to environment
[16:11:01.391] - copied ‘...future.seeds_ii’ to environment
[16:11:01.391] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.391] assign_globals() ... done
[16:11:01.391] requestCore(): workers = 2
[16:11:01.394] MulticoreFuture started
[16:11:01.394] - Launch lazy future ... done
[16:11:01.395] run() for ‘MulticoreFuture’ ... done
[16:11:01.395] Created future:
[16:11:01.395] plan(): Setting new future strategy stack:
[16:11:01.396] List of future strategies:
[16:11:01.396] 1. sequential:
[16:11:01.396]    - args: function (..., envir = parent.frame())
[16:11:01.396]    - tweaked: FALSE
[16:11:01.396]    - call: NULL
[16:11:01.397] plan(): nbrOfWorkers() = 1
[16:11:01.400] plan(): Setting new future strategy stack:
[16:11:01.401] List of future strategies:
[16:11:01.401] 1. multicore:
[16:11:01.401]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.401]    - tweaked: FALSE
[16:11:01.401]    - call: plan(strategy)
[16:11:01.407] plan(): nbrOfWorkers() = 2
[16:11:01.396] MulticoreFuture:
[16:11:01.396] Label: ‘future_vapply-2’
[16:11:01.396] Expression:
[16:11:01.396] {
[16:11:01.396]     do.call(function(...) {
[16:11:01.396]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.396]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.396]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.396]             on.exit(options(oopts), add = TRUE)
[16:11:01.396]         }
[16:11:01.396]         {
[16:11:01.396]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.396]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.396]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.396]             })
[16:11:01.396]         }
[16:11:01.396]     }, args = future.call.arguments)
[16:11:01.396] }
[16:11:01.396] Lazy evaluation: FALSE
[16:11:01.396] Asynchronous evaluation: TRUE
[16:11:01.396] Local evaluation: TRUE
[16:11:01.396] Environment: R_GlobalEnv
[16:11:01.396] Capture standard output: TRUE
[16:11:01.396] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.396] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.396] Packages: 1 packages (‘future.apply’)
[16:11:01.396] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.396] Resolved: TRUE
[16:11:01.396] Value: <not collected>
[16:11:01.396] Conditions captured: <none>
[16:11:01.396] Early signaling: FALSE
[16:11:01.396] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.396] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.409] Chunk #2 of 2 ... DONE
[16:11:01.409] Launching 2 futures (chunks) ... DONE
[16:11:01.409] Resolving 2 futures (chunks) ...
[16:11:01.410] resolve() on list ...
[16:11:01.410]  recursive: 0
[16:11:01.410]  length: 2
[16:11:01.410] 
[16:11:01.411] Future #1
[16:11:01.412] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:01.412] - nx: 2
[16:11:01.412] - relay: TRUE
[16:11:01.412] - stdout: TRUE
[16:11:01.413] - signal: TRUE
[16:11:01.413] - resignal: FALSE
[16:11:01.413] - force: TRUE
[16:11:01.413] - relayed: [n=2] FALSE, FALSE
[16:11:01.413] - queued futures: [n=2] FALSE, FALSE
[16:11:01.414]  - until=1
[16:11:01.414]  - relaying element #1
[16:11:01.414] - relayed: [n=2] TRUE, FALSE
[16:11:01.415] - queued futures: [n=2] TRUE, FALSE
[16:11:01.415] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:01.415]  length: 1 (resolved future 1)
[16:11:01.415] Future #2
[16:11:01.416] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:01.416] - nx: 2
[16:11:01.416] - relay: TRUE
[16:11:01.417] - stdout: TRUE
[16:11:01.417] - signal: TRUE
[16:11:01.417] - resignal: FALSE
[16:11:01.417] - force: TRUE
[16:11:01.417] - relayed: [n=2] TRUE, FALSE
[16:11:01.417] - queued futures: [n=2] TRUE, FALSE
[16:11:01.417]  - until=2
[16:11:01.418]  - relaying element #2
[16:11:01.418] - relayed: [n=2] TRUE, TRUE
[16:11:01.418] - queued futures: [n=2] TRUE, TRUE
[16:11:01.418] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:01.418]  length: 0 (resolved future 2)
[16:11:01.418] Relaying remaining futures
[16:11:01.419] signalConditionsASAP(NULL, pos=0) ...
[16:11:01.419] - nx: 2
[16:11:01.419] - relay: TRUE
[16:11:01.419] - stdout: TRUE
[16:11:01.419] - signal: TRUE
[16:11:01.419] - resignal: FALSE
[16:11:01.419] - force: TRUE
[16:11:01.419] - relayed: [n=2] TRUE, TRUE
[16:11:01.419] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:01.420] - relayed: [n=2] TRUE, TRUE
[16:11:01.420] - queued futures: [n=2] TRUE, TRUE
[16:11:01.420] signalConditionsASAP(NULL, pos=0) ... done
[16:11:01.420] resolve() on list ... DONE
[16:11:01.420]  - Number of value chunks collected: 2
[16:11:01.420] Resolving 2 futures (chunks) ... DONE
[16:11:01.420] Reducing values from 2 chunks ...
[16:11:01.421]  - Number of values collected after concatenation: 10
[16:11:01.421]  - Number of values expected: 10
[16:11:01.421] Reducing values from 2 chunks ... DONE
[16:11:01.421] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:11:01.423] future_lapply() ...
[16:11:01.429] Number of chunks: 2
[16:11:01.430] getGlobalsAndPackagesXApply() ...
[16:11:01.430]  - future.globals: TRUE
[16:11:01.430] getGlobalsAndPackages() ...
[16:11:01.430] Searching for globals...
[16:11:01.436] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:11:01.437] Searching for globals ... DONE
[16:11:01.437] Resolving globals: FALSE
[16:11:01.438] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:11:01.438] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:01.438] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.439] - packages: [1] ‘future.apply’
[16:11:01.439] getGlobalsAndPackages() ... DONE
[16:11:01.439]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.439]  - needed namespaces: [n=1] ‘future.apply’
[16:11:01.439] Finding globals ... DONE
[16:11:01.439]  - use_args: TRUE
[16:11:01.439]  - Getting '...' globals ...
[16:11:01.440] resolve() on list ...
[16:11:01.440]  recursive: 0
[16:11:01.440]  length: 1
[16:11:01.440]  elements: ‘...’
[16:11:01.440]  length: 0 (resolved future 1)
[16:11:01.440] resolve() on list ... DONE
[16:11:01.440]    - '...' content: [n=0] 
[16:11:01.440] List of 1
[16:11:01.440]  $ ...: list()
[16:11:01.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.440]  - attr(*, "where")=List of 1
[16:11:01.440]   ..$ ...:<environment: 0x561e896d34b0> 
[16:11:01.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.440]  - attr(*, "resolved")= logi TRUE
[16:11:01.440]  - attr(*, "total_size")= num NA
[16:11:01.443]  - Getting '...' globals ... DONE
[16:11:01.443] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:01.443] List of 8
[16:11:01.443]  $ ...future.FUN:function (x, ...)  
[16:11:01.443]  $ x_FUN        :function (x)  
[16:11:01.443]  $ times        : int 4
[16:11:01.443]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.443]  $ stop_if_not  :function (...)  
[16:11:01.443]  $ dim          : int [1:2] 2 2
[16:11:01.443]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:01.443]  $ ...          : list()
[16:11:01.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.443]  - attr(*, "where")=List of 8
[16:11:01.443]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:01.443]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:01.443]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:01.443]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:01.443]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:01.443]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:01.443]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:01.443]   ..$ ...          :<environment: 0x561e896d34b0> 
[16:11:01.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.443]  - attr(*, "resolved")= logi FALSE
[16:11:01.443]  - attr(*, "total_size")= num 105552
[16:11:01.449] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:01.450] getGlobalsAndPackagesXApply() ... DONE
[16:11:01.450] Number of futures (= number of chunks): 2
[16:11:01.450] Launching 2 futures (chunks) ...
[16:11:01.450] Chunk #1 of 2 ...
[16:11:01.450]  - Finding globals in 'X' for chunk #1 ...
[16:11:01.450] getGlobalsAndPackages() ...
[16:11:01.450] Searching for globals...
[16:11:01.451] 
[16:11:01.451] Searching for globals ... DONE
[16:11:01.451] - globals: [0] <none>
[16:11:01.451] getGlobalsAndPackages() ... DONE
[16:11:01.451]    + additional globals found: [n=0] 
[16:11:01.451]    + additional namespaces needed: [n=0] 
[16:11:01.451]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:01.451]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:01.451]  - seeds: <none>
[16:11:01.451] getGlobalsAndPackages() ...
[16:11:01.452] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.452] Resolving globals: FALSE
[16:11:01.452] Tweak future expression to call with '...' arguments ...
[16:11:01.452] {
[16:11:01.452]     do.call(function(...) {
[16:11:01.452]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.452]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.452]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.452]             on.exit(options(oopts), add = TRUE)
[16:11:01.452]         }
[16:11:01.452]         {
[16:11:01.452]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.452]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.452]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.452]             })
[16:11:01.452]         }
[16:11:01.452]     }, args = future.call.arguments)
[16:11:01.452] }
[16:11:01.452] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.453] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.453] - packages: [1] ‘future.apply’
[16:11:01.453] getGlobalsAndPackages() ... DONE
[16:11:01.453] run() for ‘Future’ ...
[16:11:01.453] - state: ‘created’
[16:11:01.453] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.457] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.457]   - Field: ‘label’
[16:11:01.457]   - Field: ‘local’
[16:11:01.457]   - Field: ‘owner’
[16:11:01.458]   - Field: ‘envir’
[16:11:01.458]   - Field: ‘workers’
[16:11:01.458]   - Field: ‘packages’
[16:11:01.458]   - Field: ‘gc’
[16:11:01.458]   - Field: ‘job’
[16:11:01.460]   - Field: ‘conditions’
[16:11:01.460]   - Field: ‘expr’
[16:11:01.460]   - Field: ‘uuid’
[16:11:01.460]   - Field: ‘seed’
[16:11:01.460]   - Field: ‘version’
[16:11:01.460]   - Field: ‘result’
[16:11:01.461]   - Field: ‘asynchronous’
[16:11:01.461]   - Field: ‘calls’
[16:11:01.461]   - Field: ‘globals’
[16:11:01.461]   - Field: ‘stdout’
[16:11:01.461]   - Field: ‘earlySignal’
[16:11:01.461]   - Field: ‘lazy’
[16:11:01.461]   - Field: ‘state’
[16:11:01.461] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.461] - Launch lazy future ...
[16:11:01.462] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:01.462] Packages needed by future strategies (n = 0): <none>
[16:11:01.462] {
[16:11:01.462]     {
[16:11:01.462]         {
[16:11:01.462]             ...future.startTime <- base::Sys.time()
[16:11:01.462]             {
[16:11:01.462]                 {
[16:11:01.462]                   {
[16:11:01.462]                     {
[16:11:01.462]                       {
[16:11:01.462]                         base::local({
[16:11:01.462]                           has_future <- base::requireNamespace("future", 
[16:11:01.462]                             quietly = TRUE)
[16:11:01.462]                           if (has_future) {
[16:11:01.462]                             ns <- base::getNamespace("future")
[16:11:01.462]                             version <- ns[[".package"]][["version"]]
[16:11:01.462]                             if (is.null(version)) 
[16:11:01.462]                               version <- utils::packageVersion("future")
[16:11:01.462]                           }
[16:11:01.462]                           else {
[16:11:01.462]                             version <- NULL
[16:11:01.462]                           }
[16:11:01.462]                           if (!has_future || version < "1.8.0") {
[16:11:01.462]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.462]                               "", base::R.version$version.string), 
[16:11:01.462]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.462]                                 base::R.version$platform, 8 * 
[16:11:01.462]                                   base::.Machine$sizeof.pointer), 
[16:11:01.462]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.462]                                 "release", "version")], collapse = " "), 
[16:11:01.462]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.462]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.462]                               info)
[16:11:01.462]                             info <- base::paste(info, collapse = "; ")
[16:11:01.462]                             if (!has_future) {
[16:11:01.462]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.462]                                 info)
[16:11:01.462]                             }
[16:11:01.462]                             else {
[16:11:01.462]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.462]                                 info, version)
[16:11:01.462]                             }
[16:11:01.462]                             base::stop(msg)
[16:11:01.462]                           }
[16:11:01.462]                         })
[16:11:01.462]                       }
[16:11:01.462]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.462]                       base::options(mc.cores = 1L)
[16:11:01.462]                     }
[16:11:01.462]                     base::local({
[16:11:01.462]                       for (pkg in "future.apply") {
[16:11:01.462]                         base::loadNamespace(pkg)
[16:11:01.462]                         base::library(pkg, character.only = TRUE)
[16:11:01.462]                       }
[16:11:01.462]                     })
[16:11:01.462]                   }
[16:11:01.462]                   options(future.plan = NULL)
[16:11:01.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.462]                 }
[16:11:01.462]                 ...future.workdir <- getwd()
[16:11:01.462]             }
[16:11:01.462]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.462]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.462]         }
[16:11:01.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.462]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:01.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.462]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.462]             base::names(...future.oldOptions))
[16:11:01.462]     }
[16:11:01.462]     if (FALSE) {
[16:11:01.462]     }
[16:11:01.462]     else {
[16:11:01.462]         if (TRUE) {
[16:11:01.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.462]                 open = "w")
[16:11:01.462]         }
[16:11:01.462]         else {
[16:11:01.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.462]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.462]         }
[16:11:01.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.462]             base::sink(type = "output", split = FALSE)
[16:11:01.462]             base::close(...future.stdout)
[16:11:01.462]         }, add = TRUE)
[16:11:01.462]     }
[16:11:01.462]     ...future.frame <- base::sys.nframe()
[16:11:01.462]     ...future.conditions <- base::list()
[16:11:01.462]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.462]     if (FALSE) {
[16:11:01.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.462]     }
[16:11:01.462]     ...future.result <- base::tryCatch({
[16:11:01.462]         base::withCallingHandlers({
[16:11:01.462]             ...future.value <- base::withVisible(base::local({
[16:11:01.462]                 withCallingHandlers({
[16:11:01.462]                   {
[16:11:01.462]                     do.call(function(...) {
[16:11:01.462]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.462]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.462]                         ...future.globals.maxSize)) {
[16:11:01.462]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.462]                         on.exit(options(oopts), add = TRUE)
[16:11:01.462]                       }
[16:11:01.462]                       {
[16:11:01.462]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.462]                           FUN = function(jj) {
[16:11:01.462]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.462]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.462]                           })
[16:11:01.462]                       }
[16:11:01.462]                     }, args = future.call.arguments)
[16:11:01.462]                   }
[16:11:01.462]                 }, immediateCondition = function(cond) {
[16:11:01.462]                   save_rds <- function (object, pathname, ...) 
[16:11:01.462]                   {
[16:11:01.462]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.462]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.462]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.462]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.462]                         fi_tmp[["mtime"]])
[16:11:01.462]                     }
[16:11:01.462]                     tryCatch({
[16:11:01.462]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.462]                     }, error = function(ex) {
[16:11:01.462]                       msg <- conditionMessage(ex)
[16:11:01.462]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.462]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.462]                         fi_tmp[["mtime"]], msg)
[16:11:01.462]                       ex$message <- msg
[16:11:01.462]                       stop(ex)
[16:11:01.462]                     })
[16:11:01.462]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.462]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.462]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.462]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.462]                       fi <- file.info(pathname)
[16:11:01.462]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.462]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.462]                         fi[["size"]], fi[["mtime"]])
[16:11:01.462]                       stop(msg)
[16:11:01.462]                     }
[16:11:01.462]                     invisible(pathname)
[16:11:01.462]                   }
[16:11:01.462]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.462]                     rootPath = tempdir()) 
[16:11:01.462]                   {
[16:11:01.462]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.462]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.462]                       tmpdir = path, fileext = ".rds")
[16:11:01.462]                     save_rds(obj, file)
[16:11:01.462]                   }
[16:11:01.462]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.462]                   {
[16:11:01.462]                     inherits <- base::inherits
[16:11:01.462]                     invokeRestart <- base::invokeRestart
[16:11:01.462]                     is.null <- base::is.null
[16:11:01.462]                     muffled <- FALSE
[16:11:01.462]                     if (inherits(cond, "message")) {
[16:11:01.462]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.462]                       if (muffled) 
[16:11:01.462]                         invokeRestart("muffleMessage")
[16:11:01.462]                     }
[16:11:01.462]                     else if (inherits(cond, "warning")) {
[16:11:01.462]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.462]                       if (muffled) 
[16:11:01.462]                         invokeRestart("muffleWarning")
[16:11:01.462]                     }
[16:11:01.462]                     else if (inherits(cond, "condition")) {
[16:11:01.462]                       if (!is.null(pattern)) {
[16:11:01.462]                         computeRestarts <- base::computeRestarts
[16:11:01.462]                         grepl <- base::grepl
[16:11:01.462]                         restarts <- computeRestarts(cond)
[16:11:01.462]                         for (restart in restarts) {
[16:11:01.462]                           name <- restart$name
[16:11:01.462]                           if (is.null(name)) 
[16:11:01.462]                             next
[16:11:01.462]                           if (!grepl(pattern, name)) 
[16:11:01.462]                             next
[16:11:01.462]                           invokeRestart(restart)
[16:11:01.462]                           muffled <- TRUE
[16:11:01.462]                           break
[16:11:01.462]                         }
[16:11:01.462]                       }
[16:11:01.462]                     }
[16:11:01.462]                     invisible(muffled)
[16:11:01.462]                   }
[16:11:01.462]                   muffleCondition(cond)
[16:11:01.462]                 })
[16:11:01.462]             }))
[16:11:01.462]             future::FutureResult(value = ...future.value$value, 
[16:11:01.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.462]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.462]                     ...future.globalenv.names))
[16:11:01.462]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.462]         }, condition = base::local({
[16:11:01.462]             c <- base::c
[16:11:01.462]             inherits <- base::inherits
[16:11:01.462]             invokeRestart <- base::invokeRestart
[16:11:01.462]             length <- base::length
[16:11:01.462]             list <- base::list
[16:11:01.462]             seq.int <- base::seq.int
[16:11:01.462]             signalCondition <- base::signalCondition
[16:11:01.462]             sys.calls <- base::sys.calls
[16:11:01.462]             `[[` <- base::`[[`
[16:11:01.462]             `+` <- base::`+`
[16:11:01.462]             `<<-` <- base::`<<-`
[16:11:01.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.462]                   3L)]
[16:11:01.462]             }
[16:11:01.462]             function(cond) {
[16:11:01.462]                 is_error <- inherits(cond, "error")
[16:11:01.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.462]                   NULL)
[16:11:01.462]                 if (is_error) {
[16:11:01.462]                   sessionInformation <- function() {
[16:11:01.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.462]                       search = base::search(), system = base::Sys.info())
[16:11:01.462]                   }
[16:11:01.462]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.462]                     cond$call), session = sessionInformation(), 
[16:11:01.462]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.462]                   signalCondition(cond)
[16:11:01.462]                 }
[16:11:01.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.462]                 "immediateCondition"))) {
[16:11:01.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.462]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.462]                   if (TRUE && !signal) {
[16:11:01.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.462]                     {
[16:11:01.462]                       inherits <- base::inherits
[16:11:01.462]                       invokeRestart <- base::invokeRestart
[16:11:01.462]                       is.null <- base::is.null
[16:11:01.462]                       muffled <- FALSE
[16:11:01.462]                       if (inherits(cond, "message")) {
[16:11:01.462]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.462]                         if (muffled) 
[16:11:01.462]                           invokeRestart("muffleMessage")
[16:11:01.462]                       }
[16:11:01.462]                       else if (inherits(cond, "warning")) {
[16:11:01.462]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.462]                         if (muffled) 
[16:11:01.462]                           invokeRestart("muffleWarning")
[16:11:01.462]                       }
[16:11:01.462]                       else if (inherits(cond, "condition")) {
[16:11:01.462]                         if (!is.null(pattern)) {
[16:11:01.462]                           computeRestarts <- base::computeRestarts
[16:11:01.462]                           grepl <- base::grepl
[16:11:01.462]                           restarts <- computeRestarts(cond)
[16:11:01.462]                           for (restart in restarts) {
[16:11:01.462]                             name <- restart$name
[16:11:01.462]                             if (is.null(name)) 
[16:11:01.462]                               next
[16:11:01.462]                             if (!grepl(pattern, name)) 
[16:11:01.462]                               next
[16:11:01.462]                             invokeRestart(restart)
[16:11:01.462]                             muffled <- TRUE
[16:11:01.462]                             break
[16:11:01.462]                           }
[16:11:01.462]                         }
[16:11:01.462]                       }
[16:11:01.462]                       invisible(muffled)
[16:11:01.462]                     }
[16:11:01.462]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.462]                   }
[16:11:01.462]                 }
[16:11:01.462]                 else {
[16:11:01.462]                   if (TRUE) {
[16:11:01.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.462]                     {
[16:11:01.462]                       inherits <- base::inherits
[16:11:01.462]                       invokeRestart <- base::invokeRestart
[16:11:01.462]                       is.null <- base::is.null
[16:11:01.462]                       muffled <- FALSE
[16:11:01.462]                       if (inherits(cond, "message")) {
[16:11:01.462]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.462]                         if (muffled) 
[16:11:01.462]                           invokeRestart("muffleMessage")
[16:11:01.462]                       }
[16:11:01.462]                       else if (inherits(cond, "warning")) {
[16:11:01.462]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.462]                         if (muffled) 
[16:11:01.462]                           invokeRestart("muffleWarning")
[16:11:01.462]                       }
[16:11:01.462]                       else if (inherits(cond, "condition")) {
[16:11:01.462]                         if (!is.null(pattern)) {
[16:11:01.462]                           computeRestarts <- base::computeRestarts
[16:11:01.462]                           grepl <- base::grepl
[16:11:01.462]                           restarts <- computeRestarts(cond)
[16:11:01.462]                           for (restart in restarts) {
[16:11:01.462]                             name <- restart$name
[16:11:01.462]                             if (is.null(name)) 
[16:11:01.462]                               next
[16:11:01.462]                             if (!grepl(pattern, name)) 
[16:11:01.462]                               next
[16:11:01.462]                             invokeRestart(restart)
[16:11:01.462]                             muffled <- TRUE
[16:11:01.462]                             break
[16:11:01.462]                           }
[16:11:01.462]                         }
[16:11:01.462]                       }
[16:11:01.462]                       invisible(muffled)
[16:11:01.462]                     }
[16:11:01.462]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.462]                   }
[16:11:01.462]                 }
[16:11:01.462]             }
[16:11:01.462]         }))
[16:11:01.462]     }, error = function(ex) {
[16:11:01.462]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.462]                 ...future.rng), started = ...future.startTime, 
[16:11:01.462]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.462]             version = "1.8"), class = "FutureResult")
[16:11:01.462]     }, finally = {
[16:11:01.462]         if (!identical(...future.workdir, getwd())) 
[16:11:01.462]             setwd(...future.workdir)
[16:11:01.462]         {
[16:11:01.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.462]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.462]             }
[16:11:01.462]             base::options(...future.oldOptions)
[16:11:01.462]             if (.Platform$OS.type == "windows") {
[16:11:01.462]                 old_names <- names(...future.oldEnvVars)
[16:11:01.462]                 envs <- base::Sys.getenv()
[16:11:01.462]                 names <- names(envs)
[16:11:01.462]                 common <- intersect(names, old_names)
[16:11:01.462]                 added <- setdiff(names, old_names)
[16:11:01.462]                 removed <- setdiff(old_names, names)
[16:11:01.462]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.462]                   envs[common]]
[16:11:01.462]                 NAMES <- toupper(changed)
[16:11:01.462]                 args <- list()
[16:11:01.462]                 for (kk in seq_along(NAMES)) {
[16:11:01.462]                   name <- changed[[kk]]
[16:11:01.462]                   NAME <- NAMES[[kk]]
[16:11:01.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.462]                     next
[16:11:01.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.462]                 }
[16:11:01.462]                 NAMES <- toupper(added)
[16:11:01.462]                 for (kk in seq_along(NAMES)) {
[16:11:01.462]                   name <- added[[kk]]
[16:11:01.462]                   NAME <- NAMES[[kk]]
[16:11:01.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.462]                     next
[16:11:01.462]                   args[[name]] <- ""
[16:11:01.462]                 }
[16:11:01.462]                 NAMES <- toupper(removed)
[16:11:01.462]                 for (kk in seq_along(NAMES)) {
[16:11:01.462]                   name <- removed[[kk]]
[16:11:01.462]                   NAME <- NAMES[[kk]]
[16:11:01.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.462]                     next
[16:11:01.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.462]                 }
[16:11:01.462]                 if (length(args) > 0) 
[16:11:01.462]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.462]             }
[16:11:01.462]             else {
[16:11:01.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.462]             }
[16:11:01.462]             {
[16:11:01.462]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.462]                   0L) {
[16:11:01.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.462]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.462]                   base::options(opts)
[16:11:01.462]                 }
[16:11:01.462]                 {
[16:11:01.462]                   {
[16:11:01.462]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.462]                     NULL
[16:11:01.462]                   }
[16:11:01.462]                   options(future.plan = NULL)
[16:11:01.462]                   if (is.na(NA_character_)) 
[16:11:01.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.462]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.462]                     envir = parent.frame()) 
[16:11:01.462]                   {
[16:11:01.462]                     default_workers <- missing(workers)
[16:11:01.462]                     if (is.function(workers)) 
[16:11:01.462]                       workers <- workers()
[16:11:01.462]                     workers <- structure(as.integer(workers), 
[16:11:01.462]                       class = class(workers))
[16:11:01.462]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.462]                       1L)
[16:11:01.462]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.462]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.462]                       if (default_workers) 
[16:11:01.462]                         supportsMulticore(warn = TRUE)
[16:11:01.462]                       return(sequential(..., envir = envir))
[16:11:01.462]                     }
[16:11:01.462]                     oopts <- options(mc.cores = workers)
[16:11:01.462]                     on.exit(options(oopts))
[16:11:01.462]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.462]                       envir = envir)
[16:11:01.462]                     if (!future$lazy) 
[16:11:01.462]                       future <- run(future)
[16:11:01.462]                     invisible(future)
[16:11:01.462]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.462]                 }
[16:11:01.462]             }
[16:11:01.462]         }
[16:11:01.462]     })
[16:11:01.462]     if (TRUE) {
[16:11:01.462]         base::sink(type = "output", split = FALSE)
[16:11:01.462]         if (TRUE) {
[16:11:01.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.462]         }
[16:11:01.462]         else {
[16:11:01.462]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.462]         }
[16:11:01.462]         base::close(...future.stdout)
[16:11:01.462]         ...future.stdout <- NULL
[16:11:01.462]     }
[16:11:01.462]     ...future.result$conditions <- ...future.conditions
[16:11:01.462]     ...future.result$finished <- base::Sys.time()
[16:11:01.462]     ...future.result
[16:11:01.462] }
[16:11:01.465] assign_globals() ...
[16:11:01.465] List of 11
[16:11:01.465]  $ ...future.FUN            :function (x, ...)  
[16:11:01.465]  $ x_FUN                    :function (x)  
[16:11:01.465]  $ times                    : int 4
[16:11:01.465]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.465]  $ stop_if_not              :function (...)  
[16:11:01.465]  $ dim                      : int [1:2] 2 2
[16:11:01.465]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.465]  $ future.call.arguments    : list()
[16:11:01.465]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.465]  $ ...future.elements_ii    :List of 5
[16:11:01.465]   ..$ : int 1
[16:11:01.465]   ..$ : int 2
[16:11:01.465]   ..$ : int 3
[16:11:01.465]   ..$ : int 4
[16:11:01.465]   ..$ : int 5
[16:11:01.465]  $ ...future.seeds_ii       : NULL
[16:11:01.465]  $ ...future.globals.maxSize: NULL
[16:11:01.465]  - attr(*, "resolved")= logi FALSE
[16:11:01.465]  - attr(*, "total_size")= num 105552
[16:11:01.465]  - attr(*, "where")=List of 11
[16:11:01.465]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.465]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.465]  - attr(*, "already-done")= logi TRUE
[16:11:01.474] - copied ‘...future.FUN’ to environment
[16:11:01.474] - reassign environment for ‘x_FUN’
[16:11:01.474] - copied ‘x_FUN’ to environment
[16:11:01.474] - copied ‘times’ to environment
[16:11:01.474] - copied ‘stopf’ to environment
[16:11:01.474] - copied ‘stop_if_not’ to environment
[16:11:01.475] - copied ‘dim’ to environment
[16:11:01.475] - copied ‘valid_types’ to environment
[16:11:01.475] - copied ‘future.call.arguments’ to environment
[16:11:01.475] - copied ‘...future.elements_ii’ to environment
[16:11:01.475] - copied ‘...future.seeds_ii’ to environment
[16:11:01.475] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.475] assign_globals() ... done
[16:11:01.475] requestCore(): workers = 2
[16:11:01.477] MulticoreFuture started
[16:11:01.478] - Launch lazy future ... done
[16:11:01.478] run() for ‘MulticoreFuture’ ... done
[16:11:01.478] Created future:
[16:11:01.479] plan(): Setting new future strategy stack:
[16:11:01.479] List of future strategies:
[16:11:01.479] 1. sequential:
[16:11:01.479]    - args: function (..., envir = parent.frame())
[16:11:01.479]    - tweaked: FALSE
[16:11:01.479]    - call: NULL
[16:11:01.480] plan(): nbrOfWorkers() = 1
[16:11:01.482] plan(): Setting new future strategy stack:
[16:11:01.482] List of future strategies:
[16:11:01.482] 1. multicore:
[16:11:01.482]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.482]    - tweaked: FALSE
[16:11:01.482]    - call: plan(strategy)
[16:11:01.487] plan(): nbrOfWorkers() = 2
[16:11:01.478] MulticoreFuture:
[16:11:01.478] Label: ‘future_vapply-1’
[16:11:01.478] Expression:
[16:11:01.478] {
[16:11:01.478]     do.call(function(...) {
[16:11:01.478]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.478]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.478]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.478]             on.exit(options(oopts), add = TRUE)
[16:11:01.478]         }
[16:11:01.478]         {
[16:11:01.478]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.478]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.478]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.478]             })
[16:11:01.478]         }
[16:11:01.478]     }, args = future.call.arguments)
[16:11:01.478] }
[16:11:01.478] Lazy evaluation: FALSE
[16:11:01.478] Asynchronous evaluation: TRUE
[16:11:01.478] Local evaluation: TRUE
[16:11:01.478] Environment: R_GlobalEnv
[16:11:01.478] Capture standard output: TRUE
[16:11:01.478] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.478] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.478] Packages: 1 packages (‘future.apply’)
[16:11:01.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.478] Resolved: TRUE
[16:11:01.478] Value: <not collected>
[16:11:01.478] Conditions captured: <none>
[16:11:01.478] Early signaling: FALSE
[16:11:01.478] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.478] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.488] Chunk #1 of 2 ... DONE
[16:11:01.488] Chunk #2 of 2 ...
[16:11:01.489]  - Finding globals in 'X' for chunk #2 ...
[16:11:01.489] getGlobalsAndPackages() ...
[16:11:01.489] Searching for globals...
[16:11:01.489] 
[16:11:01.489] Searching for globals ... DONE
[16:11:01.490] - globals: [0] <none>
[16:11:01.490] getGlobalsAndPackages() ... DONE
[16:11:01.490]    + additional globals found: [n=0] 
[16:11:01.490]    + additional namespaces needed: [n=0] 
[16:11:01.490]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:01.490]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:01.491]  - seeds: <none>
[16:11:01.491] getGlobalsAndPackages() ...
[16:11:01.491] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.491] Resolving globals: FALSE
[16:11:01.491] Tweak future expression to call with '...' arguments ...
[16:11:01.491] {
[16:11:01.491]     do.call(function(...) {
[16:11:01.491]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.491]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.491]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.491]             on.exit(options(oopts), add = TRUE)
[16:11:01.491]         }
[16:11:01.491]         {
[16:11:01.491]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.491]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.491]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.491]             })
[16:11:01.491]         }
[16:11:01.491]     }, args = future.call.arguments)
[16:11:01.491] }
[16:11:01.492] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.493] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.493] - packages: [1] ‘future.apply’
[16:11:01.493] getGlobalsAndPackages() ... DONE
[16:11:01.497] run() for ‘Future’ ...
[16:11:01.497] - state: ‘created’
[16:11:01.498] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.504] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.505]   - Field: ‘label’
[16:11:01.505]   - Field: ‘local’
[16:11:01.505]   - Field: ‘owner’
[16:11:01.505]   - Field: ‘envir’
[16:11:01.506]   - Field: ‘workers’
[16:11:01.506]   - Field: ‘packages’
[16:11:01.506]   - Field: ‘gc’
[16:11:01.506]   - Field: ‘job’
[16:11:01.507]   - Field: ‘conditions’
[16:11:01.507]   - Field: ‘expr’
[16:11:01.507]   - Field: ‘uuid’
[16:11:01.507]   - Field: ‘seed’
[16:11:01.507]   - Field: ‘version’
[16:11:01.508]   - Field: ‘result’
[16:11:01.508]   - Field: ‘asynchronous’
[16:11:01.508]   - Field: ‘calls’
[16:11:01.508]   - Field: ‘globals’
[16:11:01.508]   - Field: ‘stdout’
[16:11:01.509]   - Field: ‘earlySignal’
[16:11:01.509]   - Field: ‘lazy’
[16:11:01.509]   - Field: ‘state’
[16:11:01.509] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.510] - Launch lazy future ...
[16:11:01.510] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:01.510] Packages needed by future strategies (n = 0): <none>
[16:11:01.511] {
[16:11:01.511]     {
[16:11:01.511]         {
[16:11:01.511]             ...future.startTime <- base::Sys.time()
[16:11:01.511]             {
[16:11:01.511]                 {
[16:11:01.511]                   {
[16:11:01.511]                     {
[16:11:01.511]                       {
[16:11:01.511]                         base::local({
[16:11:01.511]                           has_future <- base::requireNamespace("future", 
[16:11:01.511]                             quietly = TRUE)
[16:11:01.511]                           if (has_future) {
[16:11:01.511]                             ns <- base::getNamespace("future")
[16:11:01.511]                             version <- ns[[".package"]][["version"]]
[16:11:01.511]                             if (is.null(version)) 
[16:11:01.511]                               version <- utils::packageVersion("future")
[16:11:01.511]                           }
[16:11:01.511]                           else {
[16:11:01.511]                             version <- NULL
[16:11:01.511]                           }
[16:11:01.511]                           if (!has_future || version < "1.8.0") {
[16:11:01.511]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.511]                               "", base::R.version$version.string), 
[16:11:01.511]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.511]                                 base::R.version$platform, 8 * 
[16:11:01.511]                                   base::.Machine$sizeof.pointer), 
[16:11:01.511]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.511]                                 "release", "version")], collapse = " "), 
[16:11:01.511]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.511]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.511]                               info)
[16:11:01.511]                             info <- base::paste(info, collapse = "; ")
[16:11:01.511]                             if (!has_future) {
[16:11:01.511]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.511]                                 info)
[16:11:01.511]                             }
[16:11:01.511]                             else {
[16:11:01.511]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.511]                                 info, version)
[16:11:01.511]                             }
[16:11:01.511]                             base::stop(msg)
[16:11:01.511]                           }
[16:11:01.511]                         })
[16:11:01.511]                       }
[16:11:01.511]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.511]                       base::options(mc.cores = 1L)
[16:11:01.511]                     }
[16:11:01.511]                     base::local({
[16:11:01.511]                       for (pkg in "future.apply") {
[16:11:01.511]                         base::loadNamespace(pkg)
[16:11:01.511]                         base::library(pkg, character.only = TRUE)
[16:11:01.511]                       }
[16:11:01.511]                     })
[16:11:01.511]                   }
[16:11:01.511]                   options(future.plan = NULL)
[16:11:01.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.511]                 }
[16:11:01.511]                 ...future.workdir <- getwd()
[16:11:01.511]             }
[16:11:01.511]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.511]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.511]         }
[16:11:01.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.511]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:01.511]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.511]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.511]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.511]             base::names(...future.oldOptions))
[16:11:01.511]     }
[16:11:01.511]     if (FALSE) {
[16:11:01.511]     }
[16:11:01.511]     else {
[16:11:01.511]         if (TRUE) {
[16:11:01.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.511]                 open = "w")
[16:11:01.511]         }
[16:11:01.511]         else {
[16:11:01.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.511]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.511]         }
[16:11:01.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.511]             base::sink(type = "output", split = FALSE)
[16:11:01.511]             base::close(...future.stdout)
[16:11:01.511]         }, add = TRUE)
[16:11:01.511]     }
[16:11:01.511]     ...future.frame <- base::sys.nframe()
[16:11:01.511]     ...future.conditions <- base::list()
[16:11:01.511]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.511]     if (FALSE) {
[16:11:01.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.511]     }
[16:11:01.511]     ...future.result <- base::tryCatch({
[16:11:01.511]         base::withCallingHandlers({
[16:11:01.511]             ...future.value <- base::withVisible(base::local({
[16:11:01.511]                 withCallingHandlers({
[16:11:01.511]                   {
[16:11:01.511]                     do.call(function(...) {
[16:11:01.511]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.511]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.511]                         ...future.globals.maxSize)) {
[16:11:01.511]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.511]                         on.exit(options(oopts), add = TRUE)
[16:11:01.511]                       }
[16:11:01.511]                       {
[16:11:01.511]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.511]                           FUN = function(jj) {
[16:11:01.511]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.511]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.511]                           })
[16:11:01.511]                       }
[16:11:01.511]                     }, args = future.call.arguments)
[16:11:01.511]                   }
[16:11:01.511]                 }, immediateCondition = function(cond) {
[16:11:01.511]                   save_rds <- function (object, pathname, ...) 
[16:11:01.511]                   {
[16:11:01.511]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.511]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.511]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.511]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.511]                         fi_tmp[["mtime"]])
[16:11:01.511]                     }
[16:11:01.511]                     tryCatch({
[16:11:01.511]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.511]                     }, error = function(ex) {
[16:11:01.511]                       msg <- conditionMessage(ex)
[16:11:01.511]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.511]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.511]                         fi_tmp[["mtime"]], msg)
[16:11:01.511]                       ex$message <- msg
[16:11:01.511]                       stop(ex)
[16:11:01.511]                     })
[16:11:01.511]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.511]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.511]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.511]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.511]                       fi <- file.info(pathname)
[16:11:01.511]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.511]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.511]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.511]                         fi[["size"]], fi[["mtime"]])
[16:11:01.511]                       stop(msg)
[16:11:01.511]                     }
[16:11:01.511]                     invisible(pathname)
[16:11:01.511]                   }
[16:11:01.511]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.511]                     rootPath = tempdir()) 
[16:11:01.511]                   {
[16:11:01.511]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.511]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.511]                       tmpdir = path, fileext = ".rds")
[16:11:01.511]                     save_rds(obj, file)
[16:11:01.511]                   }
[16:11:01.511]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.511]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.511]                   {
[16:11:01.511]                     inherits <- base::inherits
[16:11:01.511]                     invokeRestart <- base::invokeRestart
[16:11:01.511]                     is.null <- base::is.null
[16:11:01.511]                     muffled <- FALSE
[16:11:01.511]                     if (inherits(cond, "message")) {
[16:11:01.511]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.511]                       if (muffled) 
[16:11:01.511]                         invokeRestart("muffleMessage")
[16:11:01.511]                     }
[16:11:01.511]                     else if (inherits(cond, "warning")) {
[16:11:01.511]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.511]                       if (muffled) 
[16:11:01.511]                         invokeRestart("muffleWarning")
[16:11:01.511]                     }
[16:11:01.511]                     else if (inherits(cond, "condition")) {
[16:11:01.511]                       if (!is.null(pattern)) {
[16:11:01.511]                         computeRestarts <- base::computeRestarts
[16:11:01.511]                         grepl <- base::grepl
[16:11:01.511]                         restarts <- computeRestarts(cond)
[16:11:01.511]                         for (restart in restarts) {
[16:11:01.511]                           name <- restart$name
[16:11:01.511]                           if (is.null(name)) 
[16:11:01.511]                             next
[16:11:01.511]                           if (!grepl(pattern, name)) 
[16:11:01.511]                             next
[16:11:01.511]                           invokeRestart(restart)
[16:11:01.511]                           muffled <- TRUE
[16:11:01.511]                           break
[16:11:01.511]                         }
[16:11:01.511]                       }
[16:11:01.511]                     }
[16:11:01.511]                     invisible(muffled)
[16:11:01.511]                   }
[16:11:01.511]                   muffleCondition(cond)
[16:11:01.511]                 })
[16:11:01.511]             }))
[16:11:01.511]             future::FutureResult(value = ...future.value$value, 
[16:11:01.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.511]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.511]                     ...future.globalenv.names))
[16:11:01.511]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.511]         }, condition = base::local({
[16:11:01.511]             c <- base::c
[16:11:01.511]             inherits <- base::inherits
[16:11:01.511]             invokeRestart <- base::invokeRestart
[16:11:01.511]             length <- base::length
[16:11:01.511]             list <- base::list
[16:11:01.511]             seq.int <- base::seq.int
[16:11:01.511]             signalCondition <- base::signalCondition
[16:11:01.511]             sys.calls <- base::sys.calls
[16:11:01.511]             `[[` <- base::`[[`
[16:11:01.511]             `+` <- base::`+`
[16:11:01.511]             `<<-` <- base::`<<-`
[16:11:01.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.511]                   3L)]
[16:11:01.511]             }
[16:11:01.511]             function(cond) {
[16:11:01.511]                 is_error <- inherits(cond, "error")
[16:11:01.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.511]                   NULL)
[16:11:01.511]                 if (is_error) {
[16:11:01.511]                   sessionInformation <- function() {
[16:11:01.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.511]                       search = base::search(), system = base::Sys.info())
[16:11:01.511]                   }
[16:11:01.511]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.511]                     cond$call), session = sessionInformation(), 
[16:11:01.511]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.511]                   signalCondition(cond)
[16:11:01.511]                 }
[16:11:01.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.511]                 "immediateCondition"))) {
[16:11:01.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.511]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.511]                   if (TRUE && !signal) {
[16:11:01.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.511]                     {
[16:11:01.511]                       inherits <- base::inherits
[16:11:01.511]                       invokeRestart <- base::invokeRestart
[16:11:01.511]                       is.null <- base::is.null
[16:11:01.511]                       muffled <- FALSE
[16:11:01.511]                       if (inherits(cond, "message")) {
[16:11:01.511]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.511]                         if (muffled) 
[16:11:01.511]                           invokeRestart("muffleMessage")
[16:11:01.511]                       }
[16:11:01.511]                       else if (inherits(cond, "warning")) {
[16:11:01.511]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.511]                         if (muffled) 
[16:11:01.511]                           invokeRestart("muffleWarning")
[16:11:01.511]                       }
[16:11:01.511]                       else if (inherits(cond, "condition")) {
[16:11:01.511]                         if (!is.null(pattern)) {
[16:11:01.511]                           computeRestarts <- base::computeRestarts
[16:11:01.511]                           grepl <- base::grepl
[16:11:01.511]                           restarts <- computeRestarts(cond)
[16:11:01.511]                           for (restart in restarts) {
[16:11:01.511]                             name <- restart$name
[16:11:01.511]                             if (is.null(name)) 
[16:11:01.511]                               next
[16:11:01.511]                             if (!grepl(pattern, name)) 
[16:11:01.511]                               next
[16:11:01.511]                             invokeRestart(restart)
[16:11:01.511]                             muffled <- TRUE
[16:11:01.511]                             break
[16:11:01.511]                           }
[16:11:01.511]                         }
[16:11:01.511]                       }
[16:11:01.511]                       invisible(muffled)
[16:11:01.511]                     }
[16:11:01.511]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.511]                   }
[16:11:01.511]                 }
[16:11:01.511]                 else {
[16:11:01.511]                   if (TRUE) {
[16:11:01.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.511]                     {
[16:11:01.511]                       inherits <- base::inherits
[16:11:01.511]                       invokeRestart <- base::invokeRestart
[16:11:01.511]                       is.null <- base::is.null
[16:11:01.511]                       muffled <- FALSE
[16:11:01.511]                       if (inherits(cond, "message")) {
[16:11:01.511]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.511]                         if (muffled) 
[16:11:01.511]                           invokeRestart("muffleMessage")
[16:11:01.511]                       }
[16:11:01.511]                       else if (inherits(cond, "warning")) {
[16:11:01.511]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.511]                         if (muffled) 
[16:11:01.511]                           invokeRestart("muffleWarning")
[16:11:01.511]                       }
[16:11:01.511]                       else if (inherits(cond, "condition")) {
[16:11:01.511]                         if (!is.null(pattern)) {
[16:11:01.511]                           computeRestarts <- base::computeRestarts
[16:11:01.511]                           grepl <- base::grepl
[16:11:01.511]                           restarts <- computeRestarts(cond)
[16:11:01.511]                           for (restart in restarts) {
[16:11:01.511]                             name <- restart$name
[16:11:01.511]                             if (is.null(name)) 
[16:11:01.511]                               next
[16:11:01.511]                             if (!grepl(pattern, name)) 
[16:11:01.511]                               next
[16:11:01.511]                             invokeRestart(restart)
[16:11:01.511]                             muffled <- TRUE
[16:11:01.511]                             break
[16:11:01.511]                           }
[16:11:01.511]                         }
[16:11:01.511]                       }
[16:11:01.511]                       invisible(muffled)
[16:11:01.511]                     }
[16:11:01.511]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.511]                   }
[16:11:01.511]                 }
[16:11:01.511]             }
[16:11:01.511]         }))
[16:11:01.511]     }, error = function(ex) {
[16:11:01.511]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.511]                 ...future.rng), started = ...future.startTime, 
[16:11:01.511]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.511]             version = "1.8"), class = "FutureResult")
[16:11:01.511]     }, finally = {
[16:11:01.511]         if (!identical(...future.workdir, getwd())) 
[16:11:01.511]             setwd(...future.workdir)
[16:11:01.511]         {
[16:11:01.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.511]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.511]             }
[16:11:01.511]             base::options(...future.oldOptions)
[16:11:01.511]             if (.Platform$OS.type == "windows") {
[16:11:01.511]                 old_names <- names(...future.oldEnvVars)
[16:11:01.511]                 envs <- base::Sys.getenv()
[16:11:01.511]                 names <- names(envs)
[16:11:01.511]                 common <- intersect(names, old_names)
[16:11:01.511]                 added <- setdiff(names, old_names)
[16:11:01.511]                 removed <- setdiff(old_names, names)
[16:11:01.511]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.511]                   envs[common]]
[16:11:01.511]                 NAMES <- toupper(changed)
[16:11:01.511]                 args <- list()
[16:11:01.511]                 for (kk in seq_along(NAMES)) {
[16:11:01.511]                   name <- changed[[kk]]
[16:11:01.511]                   NAME <- NAMES[[kk]]
[16:11:01.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.511]                     next
[16:11:01.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.511]                 }
[16:11:01.511]                 NAMES <- toupper(added)
[16:11:01.511]                 for (kk in seq_along(NAMES)) {
[16:11:01.511]                   name <- added[[kk]]
[16:11:01.511]                   NAME <- NAMES[[kk]]
[16:11:01.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.511]                     next
[16:11:01.511]                   args[[name]] <- ""
[16:11:01.511]                 }
[16:11:01.511]                 NAMES <- toupper(removed)
[16:11:01.511]                 for (kk in seq_along(NAMES)) {
[16:11:01.511]                   name <- removed[[kk]]
[16:11:01.511]                   NAME <- NAMES[[kk]]
[16:11:01.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.511]                     next
[16:11:01.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.511]                 }
[16:11:01.511]                 if (length(args) > 0) 
[16:11:01.511]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.511]             }
[16:11:01.511]             else {
[16:11:01.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.511]             }
[16:11:01.511]             {
[16:11:01.511]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.511]                   0L) {
[16:11:01.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.511]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.511]                   base::options(opts)
[16:11:01.511]                 }
[16:11:01.511]                 {
[16:11:01.511]                   {
[16:11:01.511]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.511]                     NULL
[16:11:01.511]                   }
[16:11:01.511]                   options(future.plan = NULL)
[16:11:01.511]                   if (is.na(NA_character_)) 
[16:11:01.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.511]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.511]                     envir = parent.frame()) 
[16:11:01.511]                   {
[16:11:01.511]                     default_workers <- missing(workers)
[16:11:01.511]                     if (is.function(workers)) 
[16:11:01.511]                       workers <- workers()
[16:11:01.511]                     workers <- structure(as.integer(workers), 
[16:11:01.511]                       class = class(workers))
[16:11:01.511]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.511]                       1L)
[16:11:01.511]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.511]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.511]                       if (default_workers) 
[16:11:01.511]                         supportsMulticore(warn = TRUE)
[16:11:01.511]                       return(sequential(..., envir = envir))
[16:11:01.511]                     }
[16:11:01.511]                     oopts <- options(mc.cores = workers)
[16:11:01.511]                     on.exit(options(oopts))
[16:11:01.511]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.511]                       envir = envir)
[16:11:01.511]                     if (!future$lazy) 
[16:11:01.511]                       future <- run(future)
[16:11:01.511]                     invisible(future)
[16:11:01.511]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.511]                 }
[16:11:01.511]             }
[16:11:01.511]         }
[16:11:01.511]     })
[16:11:01.511]     if (TRUE) {
[16:11:01.511]         base::sink(type = "output", split = FALSE)
[16:11:01.511]         if (TRUE) {
[16:11:01.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.511]         }
[16:11:01.511]         else {
[16:11:01.511]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.511]         }
[16:11:01.511]         base::close(...future.stdout)
[16:11:01.511]         ...future.stdout <- NULL
[16:11:01.511]     }
[16:11:01.511]     ...future.result$conditions <- ...future.conditions
[16:11:01.511]     ...future.result$finished <- base::Sys.time()
[16:11:01.511]     ...future.result
[16:11:01.511] }
[16:11:01.514] assign_globals() ...
[16:11:01.515] List of 11
[16:11:01.515]  $ ...future.FUN            :function (x, ...)  
[16:11:01.515]  $ x_FUN                    :function (x)  
[16:11:01.515]  $ times                    : int 4
[16:11:01.515]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.515]  $ stop_if_not              :function (...)  
[16:11:01.515]  $ dim                      : int [1:2] 2 2
[16:11:01.515]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.515]  $ future.call.arguments    : list()
[16:11:01.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.515]  $ ...future.elements_ii    :List of 5
[16:11:01.515]   ..$ : int 6
[16:11:01.515]   ..$ : int 7
[16:11:01.515]   ..$ : int 8
[16:11:01.515]   ..$ : int 9
[16:11:01.515]   ..$ : int 10
[16:11:01.515]  $ ...future.seeds_ii       : NULL
[16:11:01.515]  $ ...future.globals.maxSize: NULL
[16:11:01.515]  - attr(*, "resolved")= logi FALSE
[16:11:01.515]  - attr(*, "total_size")= num 105552
[16:11:01.515]  - attr(*, "where")=List of 11
[16:11:01.515]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.515]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.515]  - attr(*, "already-done")= logi TRUE
[16:11:01.526] - copied ‘...future.FUN’ to environment
[16:11:01.527] - reassign environment for ‘x_FUN’
[16:11:01.527] - copied ‘x_FUN’ to environment
[16:11:01.527] - copied ‘times’ to environment
[16:11:01.527] - copied ‘stopf’ to environment
[16:11:01.527] - copied ‘stop_if_not’ to environment
[16:11:01.527] - copied ‘dim’ to environment
[16:11:01.527] - copied ‘valid_types’ to environment
[16:11:01.527] - copied ‘future.call.arguments’ to environment
[16:11:01.527] - copied ‘...future.elements_ii’ to environment
[16:11:01.528] - copied ‘...future.seeds_ii’ to environment
[16:11:01.528] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.528] assign_globals() ... done
[16:11:01.528] requestCore(): workers = 2
[16:11:01.530] MulticoreFuture started
[16:11:01.530] - Launch lazy future ... done
[16:11:01.531] run() for ‘MulticoreFuture’ ... done
[16:11:01.531] Created future:
[16:11:01.532] plan(): Setting new future strategy stack:
[16:11:01.532] List of future strategies:
[16:11:01.532] 1. sequential:
[16:11:01.532]    - args: function (..., envir = parent.frame())
[16:11:01.532]    - tweaked: FALSE
[16:11:01.532]    - call: NULL
[16:11:01.533] plan(): nbrOfWorkers() = 1
[16:11:01.535] plan(): Setting new future strategy stack:
[16:11:01.535] List of future strategies:
[16:11:01.535] 1. multicore:
[16:11:01.535]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.535]    - tweaked: FALSE
[16:11:01.535]    - call: plan(strategy)
[16:11:01.531] MulticoreFuture:
[16:11:01.531] Label: ‘future_vapply-2’
[16:11:01.531] Expression:
[16:11:01.531] {
[16:11:01.531]     do.call(function(...) {
[16:11:01.531]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.531]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.531]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.531]             on.exit(options(oopts), add = TRUE)
[16:11:01.531]         }
[16:11:01.531]         {
[16:11:01.531]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.531]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.531]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.531]             })
[16:11:01.531]         }
[16:11:01.531]     }, args = future.call.arguments)
[16:11:01.531] }
[16:11:01.531] Lazy evaluation: FALSE
[16:11:01.531] Asynchronous evaluation: TRUE
[16:11:01.531] Local evaluation: TRUE
[16:11:01.531] Environment: R_GlobalEnv
[16:11:01.531] Capture standard output: TRUE
[16:11:01.531] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.531] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.531] Packages: 1 packages (‘future.apply’)
[16:11:01.531] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.531] Resolved: FALSE
[16:11:01.531] Value: <not collected>
[16:11:01.531] Conditions captured: <none>
[16:11:01.531] Early signaling: FALSE
[16:11:01.531] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.531] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.545] Chunk #2 of 2 ... DONE
[16:11:01.545] Launching 2 futures (chunks) ... DONE
[16:11:01.545] Resolving 2 futures (chunks) ...
[16:11:01.545] resolve() on list ...
[16:11:01.546] plan(): nbrOfWorkers() = 2
[16:11:01.548]  recursive: 0
[16:11:01.548]  length: 2
[16:11:01.548] 
[16:11:01.549] Future #1
[16:11:01.550] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:01.551] - nx: 2
[16:11:01.551] - relay: TRUE
[16:11:01.551] - stdout: TRUE
[16:11:01.551] - signal: TRUE
[16:11:01.552] - resignal: FALSE
[16:11:01.552] - force: TRUE
[16:11:01.552] - relayed: [n=2] FALSE, FALSE
[16:11:01.552] - queued futures: [n=2] FALSE, FALSE
[16:11:01.553]  - until=1
[16:11:01.553]  - relaying element #1
[16:11:01.553] - relayed: [n=2] TRUE, FALSE
[16:11:01.554] - queued futures: [n=2] TRUE, FALSE
[16:11:01.554] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:01.554]  length: 1 (resolved future 1)
[16:11:01.555] Future #2
[16:11:01.556] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:01.556] - nx: 2
[16:11:01.556] - relay: TRUE
[16:11:01.557] - stdout: TRUE
[16:11:01.557] - signal: TRUE
[16:11:01.557] - resignal: FALSE
[16:11:01.557] - force: TRUE
[16:11:01.557] - relayed: [n=2] TRUE, FALSE
[16:11:01.557] - queued futures: [n=2] TRUE, FALSE
[16:11:01.558]  - until=2
[16:11:01.558]  - relaying element #2
[16:11:01.558] - relayed: [n=2] TRUE, TRUE
[16:11:01.559] - queued futures: [n=2] TRUE, TRUE
[16:11:01.559] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:01.559]  length: 0 (resolved future 2)
[16:11:01.559] Relaying remaining futures
[16:11:01.559] signalConditionsASAP(NULL, pos=0) ...
[16:11:01.559] - nx: 2
[16:11:01.560] - relay: TRUE
[16:11:01.560] - stdout: TRUE
[16:11:01.560] - signal: TRUE
[16:11:01.560] - resignal: FALSE
[16:11:01.560] - force: TRUE
[16:11:01.560] - relayed: [n=2] TRUE, TRUE
[16:11:01.561] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:01.561] - relayed: [n=2] TRUE, TRUE
[16:11:01.561] - queued futures: [n=2] TRUE, TRUE
[16:11:01.561] signalConditionsASAP(NULL, pos=0) ... done
[16:11:01.561] resolve() on list ... DONE
[16:11:01.562]  - Number of value chunks collected: 2
[16:11:01.562] Resolving 2 futures (chunks) ... DONE
[16:11:01.562] Reducing values from 2 chunks ...
[16:11:01.562]  - Number of values collected after concatenation: 10
[16:11:01.562]  - Number of values expected: 10
[16:11:01.562] Reducing values from 2 chunks ... DONE
[16:11:01.563] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:11:01.567] future_lapply() ...
[16:11:01.573] Number of chunks: 2
[16:11:01.573] getGlobalsAndPackagesXApply() ...
[16:11:01.573]  - future.globals: TRUE
[16:11:01.574] getGlobalsAndPackages() ...
[16:11:01.574] Searching for globals...
[16:11:01.578] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:11:01.578] Searching for globals ... DONE
[16:11:01.578] Resolving globals: FALSE
[16:11:01.579] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:11:01.579] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:01.579] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.580] - packages: [2] ‘stats’, ‘future.apply’
[16:11:01.580] getGlobalsAndPackages() ... DONE
[16:11:01.580]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.580]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:11:01.580] Finding globals ... DONE
[16:11:01.580]  - use_args: TRUE
[16:11:01.580]  - Getting '...' globals ...
[16:11:01.583] resolve() on list ...
[16:11:01.583]  recursive: 0
[16:11:01.583]  length: 1
[16:11:01.583]  elements: ‘...’
[16:11:01.583]  length: 0 (resolved future 1)
[16:11:01.583] resolve() on list ... DONE
[16:11:01.583]    - '...' content: [n=0] 
[16:11:01.584] List of 1
[16:11:01.584]  $ ...: list()
[16:11:01.584]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.584]  - attr(*, "where")=List of 1
[16:11:01.584]   ..$ ...:<environment: 0x561e88712b60> 
[16:11:01.584]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.584]  - attr(*, "resolved")= logi TRUE
[16:11:01.584]  - attr(*, "total_size")= num NA
[16:11:01.587]  - Getting '...' globals ... DONE
[16:11:01.587] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:01.587] List of 8
[16:11:01.587]  $ ...future.FUN:function (x, ...)  
[16:11:01.587]  $ x_FUN        :function (x, ...)  
[16:11:01.587]  $ times        : int 5
[16:11:01.587]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.587]  $ stop_if_not  :function (...)  
[16:11:01.587]  $ dim          : NULL
[16:11:01.587]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:01.587]  $ ...          : list()
[16:11:01.587]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.587]  - attr(*, "where")=List of 8
[16:11:01.587]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:01.587]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:01.587]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:01.587]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:01.587]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:01.587]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:01.587]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:01.587]   ..$ ...          :<environment: 0x561e88712b60> 
[16:11:01.587]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.587]  - attr(*, "resolved")= logi FALSE
[16:11:01.587]  - attr(*, "total_size")= num 95528
[16:11:01.593] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:11:01.593] getGlobalsAndPackagesXApply() ... DONE
[16:11:01.593] Number of futures (= number of chunks): 2
[16:11:01.593] Launching 2 futures (chunks) ...
[16:11:01.593] Chunk #1 of 2 ...
[16:11:01.593]  - Finding globals in 'X' for chunk #1 ...
[16:11:01.594] getGlobalsAndPackages() ...
[16:11:01.594] Searching for globals...
[16:11:01.594] 
[16:11:01.594] Searching for globals ... DONE
[16:11:01.594] - globals: [0] <none>
[16:11:01.594] getGlobalsAndPackages() ... DONE
[16:11:01.594]    + additional globals found: [n=0] 
[16:11:01.594]    + additional namespaces needed: [n=0] 
[16:11:01.594]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:01.594]  - seeds: <none>
[16:11:01.595] getGlobalsAndPackages() ...
[16:11:01.595] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.595] Resolving globals: FALSE
[16:11:01.595] Tweak future expression to call with '...' arguments ...
[16:11:01.595] {
[16:11:01.595]     do.call(function(...) {
[16:11:01.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.595]             on.exit(options(oopts), add = TRUE)
[16:11:01.595]         }
[16:11:01.595]         {
[16:11:01.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.595]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.595]             })
[16:11:01.595]         }
[16:11:01.595]     }, args = future.call.arguments)
[16:11:01.595] }
[16:11:01.595] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.596] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.596] - packages: [2] ‘stats’, ‘future.apply’
[16:11:01.596] getGlobalsAndPackages() ... DONE
[16:11:01.596] run() for ‘Future’ ...
[16:11:01.596] - state: ‘created’
[16:11:01.597] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.600] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.601]   - Field: ‘label’
[16:11:01.601]   - Field: ‘local’
[16:11:01.601]   - Field: ‘owner’
[16:11:01.601]   - Field: ‘envir’
[16:11:01.601]   - Field: ‘workers’
[16:11:01.601]   - Field: ‘packages’
[16:11:01.601]   - Field: ‘gc’
[16:11:01.601]   - Field: ‘job’
[16:11:01.601]   - Field: ‘conditions’
[16:11:01.601]   - Field: ‘expr’
[16:11:01.602]   - Field: ‘uuid’
[16:11:01.602]   - Field: ‘seed’
[16:11:01.602]   - Field: ‘version’
[16:11:01.602]   - Field: ‘result’
[16:11:01.602]   - Field: ‘asynchronous’
[16:11:01.602]   - Field: ‘calls’
[16:11:01.602]   - Field: ‘globals’
[16:11:01.602]   - Field: ‘stdout’
[16:11:01.602]   - Field: ‘earlySignal’
[16:11:01.602]   - Field: ‘lazy’
[16:11:01.602]   - Field: ‘state’
[16:11:01.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.603] - Launch lazy future ...
[16:11:01.603] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:01.603] Packages needed by future strategies (n = 0): <none>
[16:11:01.604] {
[16:11:01.604]     {
[16:11:01.604]         {
[16:11:01.604]             ...future.startTime <- base::Sys.time()
[16:11:01.604]             {
[16:11:01.604]                 {
[16:11:01.604]                   {
[16:11:01.604]                     {
[16:11:01.604]                       {
[16:11:01.604]                         base::local({
[16:11:01.604]                           has_future <- base::requireNamespace("future", 
[16:11:01.604]                             quietly = TRUE)
[16:11:01.604]                           if (has_future) {
[16:11:01.604]                             ns <- base::getNamespace("future")
[16:11:01.604]                             version <- ns[[".package"]][["version"]]
[16:11:01.604]                             if (is.null(version)) 
[16:11:01.604]                               version <- utils::packageVersion("future")
[16:11:01.604]                           }
[16:11:01.604]                           else {
[16:11:01.604]                             version <- NULL
[16:11:01.604]                           }
[16:11:01.604]                           if (!has_future || version < "1.8.0") {
[16:11:01.604]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.604]                               "", base::R.version$version.string), 
[16:11:01.604]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.604]                                 base::R.version$platform, 8 * 
[16:11:01.604]                                   base::.Machine$sizeof.pointer), 
[16:11:01.604]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.604]                                 "release", "version")], collapse = " "), 
[16:11:01.604]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.604]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.604]                               info)
[16:11:01.604]                             info <- base::paste(info, collapse = "; ")
[16:11:01.604]                             if (!has_future) {
[16:11:01.604]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.604]                                 info)
[16:11:01.604]                             }
[16:11:01.604]                             else {
[16:11:01.604]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.604]                                 info, version)
[16:11:01.604]                             }
[16:11:01.604]                             base::stop(msg)
[16:11:01.604]                           }
[16:11:01.604]                         })
[16:11:01.604]                       }
[16:11:01.604]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.604]                       base::options(mc.cores = 1L)
[16:11:01.604]                     }
[16:11:01.604]                     base::local({
[16:11:01.604]                       for (pkg in c("stats", "future.apply")) {
[16:11:01.604]                         base::loadNamespace(pkg)
[16:11:01.604]                         base::library(pkg, character.only = TRUE)
[16:11:01.604]                       }
[16:11:01.604]                     })
[16:11:01.604]                   }
[16:11:01.604]                   options(future.plan = NULL)
[16:11:01.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.604]                 }
[16:11:01.604]                 ...future.workdir <- getwd()
[16:11:01.604]             }
[16:11:01.604]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.604]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.604]         }
[16:11:01.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.604]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:01.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.604]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.604]             base::names(...future.oldOptions))
[16:11:01.604]     }
[16:11:01.604]     if (FALSE) {
[16:11:01.604]     }
[16:11:01.604]     else {
[16:11:01.604]         if (TRUE) {
[16:11:01.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.604]                 open = "w")
[16:11:01.604]         }
[16:11:01.604]         else {
[16:11:01.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.604]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.604]         }
[16:11:01.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.604]             base::sink(type = "output", split = FALSE)
[16:11:01.604]             base::close(...future.stdout)
[16:11:01.604]         }, add = TRUE)
[16:11:01.604]     }
[16:11:01.604]     ...future.frame <- base::sys.nframe()
[16:11:01.604]     ...future.conditions <- base::list()
[16:11:01.604]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.604]     if (FALSE) {
[16:11:01.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.604]     }
[16:11:01.604]     ...future.result <- base::tryCatch({
[16:11:01.604]         base::withCallingHandlers({
[16:11:01.604]             ...future.value <- base::withVisible(base::local({
[16:11:01.604]                 withCallingHandlers({
[16:11:01.604]                   {
[16:11:01.604]                     do.call(function(...) {
[16:11:01.604]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.604]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.604]                         ...future.globals.maxSize)) {
[16:11:01.604]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.604]                         on.exit(options(oopts), add = TRUE)
[16:11:01.604]                       }
[16:11:01.604]                       {
[16:11:01.604]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.604]                           FUN = function(jj) {
[16:11:01.604]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.604]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.604]                           })
[16:11:01.604]                       }
[16:11:01.604]                     }, args = future.call.arguments)
[16:11:01.604]                   }
[16:11:01.604]                 }, immediateCondition = function(cond) {
[16:11:01.604]                   save_rds <- function (object, pathname, ...) 
[16:11:01.604]                   {
[16:11:01.604]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.604]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.604]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.604]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.604]                         fi_tmp[["mtime"]])
[16:11:01.604]                     }
[16:11:01.604]                     tryCatch({
[16:11:01.604]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.604]                     }, error = function(ex) {
[16:11:01.604]                       msg <- conditionMessage(ex)
[16:11:01.604]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.604]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.604]                         fi_tmp[["mtime"]], msg)
[16:11:01.604]                       ex$message <- msg
[16:11:01.604]                       stop(ex)
[16:11:01.604]                     })
[16:11:01.604]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.604]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.604]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.604]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.604]                       fi <- file.info(pathname)
[16:11:01.604]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.604]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.604]                         fi[["size"]], fi[["mtime"]])
[16:11:01.604]                       stop(msg)
[16:11:01.604]                     }
[16:11:01.604]                     invisible(pathname)
[16:11:01.604]                   }
[16:11:01.604]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.604]                     rootPath = tempdir()) 
[16:11:01.604]                   {
[16:11:01.604]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.604]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.604]                       tmpdir = path, fileext = ".rds")
[16:11:01.604]                     save_rds(obj, file)
[16:11:01.604]                   }
[16:11:01.604]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.604]                   {
[16:11:01.604]                     inherits <- base::inherits
[16:11:01.604]                     invokeRestart <- base::invokeRestart
[16:11:01.604]                     is.null <- base::is.null
[16:11:01.604]                     muffled <- FALSE
[16:11:01.604]                     if (inherits(cond, "message")) {
[16:11:01.604]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.604]                       if (muffled) 
[16:11:01.604]                         invokeRestart("muffleMessage")
[16:11:01.604]                     }
[16:11:01.604]                     else if (inherits(cond, "warning")) {
[16:11:01.604]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.604]                       if (muffled) 
[16:11:01.604]                         invokeRestart("muffleWarning")
[16:11:01.604]                     }
[16:11:01.604]                     else if (inherits(cond, "condition")) {
[16:11:01.604]                       if (!is.null(pattern)) {
[16:11:01.604]                         computeRestarts <- base::computeRestarts
[16:11:01.604]                         grepl <- base::grepl
[16:11:01.604]                         restarts <- computeRestarts(cond)
[16:11:01.604]                         for (restart in restarts) {
[16:11:01.604]                           name <- restart$name
[16:11:01.604]                           if (is.null(name)) 
[16:11:01.604]                             next
[16:11:01.604]                           if (!grepl(pattern, name)) 
[16:11:01.604]                             next
[16:11:01.604]                           invokeRestart(restart)
[16:11:01.604]                           muffled <- TRUE
[16:11:01.604]                           break
[16:11:01.604]                         }
[16:11:01.604]                       }
[16:11:01.604]                     }
[16:11:01.604]                     invisible(muffled)
[16:11:01.604]                   }
[16:11:01.604]                   muffleCondition(cond)
[16:11:01.604]                 })
[16:11:01.604]             }))
[16:11:01.604]             future::FutureResult(value = ...future.value$value, 
[16:11:01.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.604]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.604]                     ...future.globalenv.names))
[16:11:01.604]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.604]         }, condition = base::local({
[16:11:01.604]             c <- base::c
[16:11:01.604]             inherits <- base::inherits
[16:11:01.604]             invokeRestart <- base::invokeRestart
[16:11:01.604]             length <- base::length
[16:11:01.604]             list <- base::list
[16:11:01.604]             seq.int <- base::seq.int
[16:11:01.604]             signalCondition <- base::signalCondition
[16:11:01.604]             sys.calls <- base::sys.calls
[16:11:01.604]             `[[` <- base::`[[`
[16:11:01.604]             `+` <- base::`+`
[16:11:01.604]             `<<-` <- base::`<<-`
[16:11:01.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.604]                   3L)]
[16:11:01.604]             }
[16:11:01.604]             function(cond) {
[16:11:01.604]                 is_error <- inherits(cond, "error")
[16:11:01.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.604]                   NULL)
[16:11:01.604]                 if (is_error) {
[16:11:01.604]                   sessionInformation <- function() {
[16:11:01.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.604]                       search = base::search(), system = base::Sys.info())
[16:11:01.604]                   }
[16:11:01.604]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.604]                     cond$call), session = sessionInformation(), 
[16:11:01.604]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.604]                   signalCondition(cond)
[16:11:01.604]                 }
[16:11:01.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.604]                 "immediateCondition"))) {
[16:11:01.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.604]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.604]                   if (TRUE && !signal) {
[16:11:01.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.604]                     {
[16:11:01.604]                       inherits <- base::inherits
[16:11:01.604]                       invokeRestart <- base::invokeRestart
[16:11:01.604]                       is.null <- base::is.null
[16:11:01.604]                       muffled <- FALSE
[16:11:01.604]                       if (inherits(cond, "message")) {
[16:11:01.604]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.604]                         if (muffled) 
[16:11:01.604]                           invokeRestart("muffleMessage")
[16:11:01.604]                       }
[16:11:01.604]                       else if (inherits(cond, "warning")) {
[16:11:01.604]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.604]                         if (muffled) 
[16:11:01.604]                           invokeRestart("muffleWarning")
[16:11:01.604]                       }
[16:11:01.604]                       else if (inherits(cond, "condition")) {
[16:11:01.604]                         if (!is.null(pattern)) {
[16:11:01.604]                           computeRestarts <- base::computeRestarts
[16:11:01.604]                           grepl <- base::grepl
[16:11:01.604]                           restarts <- computeRestarts(cond)
[16:11:01.604]                           for (restart in restarts) {
[16:11:01.604]                             name <- restart$name
[16:11:01.604]                             if (is.null(name)) 
[16:11:01.604]                               next
[16:11:01.604]                             if (!grepl(pattern, name)) 
[16:11:01.604]                               next
[16:11:01.604]                             invokeRestart(restart)
[16:11:01.604]                             muffled <- TRUE
[16:11:01.604]                             break
[16:11:01.604]                           }
[16:11:01.604]                         }
[16:11:01.604]                       }
[16:11:01.604]                       invisible(muffled)
[16:11:01.604]                     }
[16:11:01.604]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.604]                   }
[16:11:01.604]                 }
[16:11:01.604]                 else {
[16:11:01.604]                   if (TRUE) {
[16:11:01.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.604]                     {
[16:11:01.604]                       inherits <- base::inherits
[16:11:01.604]                       invokeRestart <- base::invokeRestart
[16:11:01.604]                       is.null <- base::is.null
[16:11:01.604]                       muffled <- FALSE
[16:11:01.604]                       if (inherits(cond, "message")) {
[16:11:01.604]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.604]                         if (muffled) 
[16:11:01.604]                           invokeRestart("muffleMessage")
[16:11:01.604]                       }
[16:11:01.604]                       else if (inherits(cond, "warning")) {
[16:11:01.604]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.604]                         if (muffled) 
[16:11:01.604]                           invokeRestart("muffleWarning")
[16:11:01.604]                       }
[16:11:01.604]                       else if (inherits(cond, "condition")) {
[16:11:01.604]                         if (!is.null(pattern)) {
[16:11:01.604]                           computeRestarts <- base::computeRestarts
[16:11:01.604]                           grepl <- base::grepl
[16:11:01.604]                           restarts <- computeRestarts(cond)
[16:11:01.604]                           for (restart in restarts) {
[16:11:01.604]                             name <- restart$name
[16:11:01.604]                             if (is.null(name)) 
[16:11:01.604]                               next
[16:11:01.604]                             if (!grepl(pattern, name)) 
[16:11:01.604]                               next
[16:11:01.604]                             invokeRestart(restart)
[16:11:01.604]                             muffled <- TRUE
[16:11:01.604]                             break
[16:11:01.604]                           }
[16:11:01.604]                         }
[16:11:01.604]                       }
[16:11:01.604]                       invisible(muffled)
[16:11:01.604]                     }
[16:11:01.604]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.604]                   }
[16:11:01.604]                 }
[16:11:01.604]             }
[16:11:01.604]         }))
[16:11:01.604]     }, error = function(ex) {
[16:11:01.604]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.604]                 ...future.rng), started = ...future.startTime, 
[16:11:01.604]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.604]             version = "1.8"), class = "FutureResult")
[16:11:01.604]     }, finally = {
[16:11:01.604]         if (!identical(...future.workdir, getwd())) 
[16:11:01.604]             setwd(...future.workdir)
[16:11:01.604]         {
[16:11:01.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.604]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.604]             }
[16:11:01.604]             base::options(...future.oldOptions)
[16:11:01.604]             if (.Platform$OS.type == "windows") {
[16:11:01.604]                 old_names <- names(...future.oldEnvVars)
[16:11:01.604]                 envs <- base::Sys.getenv()
[16:11:01.604]                 names <- names(envs)
[16:11:01.604]                 common <- intersect(names, old_names)
[16:11:01.604]                 added <- setdiff(names, old_names)
[16:11:01.604]                 removed <- setdiff(old_names, names)
[16:11:01.604]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.604]                   envs[common]]
[16:11:01.604]                 NAMES <- toupper(changed)
[16:11:01.604]                 args <- list()
[16:11:01.604]                 for (kk in seq_along(NAMES)) {
[16:11:01.604]                   name <- changed[[kk]]
[16:11:01.604]                   NAME <- NAMES[[kk]]
[16:11:01.604]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.604]                     next
[16:11:01.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.604]                 }
[16:11:01.604]                 NAMES <- toupper(added)
[16:11:01.604]                 for (kk in seq_along(NAMES)) {
[16:11:01.604]                   name <- added[[kk]]
[16:11:01.604]                   NAME <- NAMES[[kk]]
[16:11:01.604]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.604]                     next
[16:11:01.604]                   args[[name]] <- ""
[16:11:01.604]                 }
[16:11:01.604]                 NAMES <- toupper(removed)
[16:11:01.604]                 for (kk in seq_along(NAMES)) {
[16:11:01.604]                   name <- removed[[kk]]
[16:11:01.604]                   NAME <- NAMES[[kk]]
[16:11:01.604]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.604]                     next
[16:11:01.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.604]                 }
[16:11:01.604]                 if (length(args) > 0) 
[16:11:01.604]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.604]             }
[16:11:01.604]             else {
[16:11:01.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.604]             }
[16:11:01.604]             {
[16:11:01.604]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.604]                   0L) {
[16:11:01.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.604]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.604]                   base::options(opts)
[16:11:01.604]                 }
[16:11:01.604]                 {
[16:11:01.604]                   {
[16:11:01.604]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.604]                     NULL
[16:11:01.604]                   }
[16:11:01.604]                   options(future.plan = NULL)
[16:11:01.604]                   if (is.na(NA_character_)) 
[16:11:01.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.604]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.604]                     envir = parent.frame()) 
[16:11:01.604]                   {
[16:11:01.604]                     default_workers <- missing(workers)
[16:11:01.604]                     if (is.function(workers)) 
[16:11:01.604]                       workers <- workers()
[16:11:01.604]                     workers <- structure(as.integer(workers), 
[16:11:01.604]                       class = class(workers))
[16:11:01.604]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.604]                       1L)
[16:11:01.604]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.604]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.604]                       if (default_workers) 
[16:11:01.604]                         supportsMulticore(warn = TRUE)
[16:11:01.604]                       return(sequential(..., envir = envir))
[16:11:01.604]                     }
[16:11:01.604]                     oopts <- options(mc.cores = workers)
[16:11:01.604]                     on.exit(options(oopts))
[16:11:01.604]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.604]                       envir = envir)
[16:11:01.604]                     if (!future$lazy) 
[16:11:01.604]                       future <- run(future)
[16:11:01.604]                     invisible(future)
[16:11:01.604]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.604]                 }
[16:11:01.604]             }
[16:11:01.604]         }
[16:11:01.604]     })
[16:11:01.604]     if (TRUE) {
[16:11:01.604]         base::sink(type = "output", split = FALSE)
[16:11:01.604]         if (TRUE) {
[16:11:01.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.604]         }
[16:11:01.604]         else {
[16:11:01.604]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.604]         }
[16:11:01.604]         base::close(...future.stdout)
[16:11:01.604]         ...future.stdout <- NULL
[16:11:01.604]     }
[16:11:01.604]     ...future.result$conditions <- ...future.conditions
[16:11:01.604]     ...future.result$finished <- base::Sys.time()
[16:11:01.604]     ...future.result
[16:11:01.604] }
[16:11:01.608] assign_globals() ...
[16:11:01.608] List of 11
[16:11:01.608]  $ ...future.FUN            :function (x, ...)  
[16:11:01.608]  $ x_FUN                    :function (x, ...)  
[16:11:01.608]  $ times                    : int 5
[16:11:01.608]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.608]  $ stop_if_not              :function (...)  
[16:11:01.608]  $ dim                      : NULL
[16:11:01.608]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.608]  $ future.call.arguments    : list()
[16:11:01.608]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.608]  $ ...future.elements_ii    :List of 1
[16:11:01.608]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:11:01.608]  $ ...future.seeds_ii       : NULL
[16:11:01.608]  $ ...future.globals.maxSize: NULL
[16:11:01.608]  - attr(*, "where")=List of 11
[16:11:01.608]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.608]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.608]  - attr(*, "resolved")= logi FALSE
[16:11:01.608]  - attr(*, "total_size")= num 95528
[16:11:01.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.608]  - attr(*, "already-done")= logi TRUE
[16:11:01.616] - copied ‘...future.FUN’ to environment
[16:11:01.617] - copied ‘x_FUN’ to environment
[16:11:01.617] - copied ‘times’ to environment
[16:11:01.617] - copied ‘stopf’ to environment
[16:11:01.617] - copied ‘stop_if_not’ to environment
[16:11:01.617] - copied ‘dim’ to environment
[16:11:01.617] - copied ‘valid_types’ to environment
[16:11:01.617] - copied ‘future.call.arguments’ to environment
[16:11:01.617] - copied ‘...future.elements_ii’ to environment
[16:11:01.617] - copied ‘...future.seeds_ii’ to environment
[16:11:01.617] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.618] assign_globals() ... done
[16:11:01.618] requestCore(): workers = 2
[16:11:01.620] MulticoreFuture started
[16:11:01.620] - Launch lazy future ... done
[16:11:01.621] run() for ‘MulticoreFuture’ ... done
[16:11:01.621] Created future:
[16:11:01.622] plan(): Setting new future strategy stack:
[16:11:01.622] List of future strategies:
[16:11:01.622] 1. sequential:
[16:11:01.622]    - args: function (..., envir = parent.frame())
[16:11:01.622]    - tweaked: FALSE
[16:11:01.622]    - call: NULL
[16:11:01.623] plan(): nbrOfWorkers() = 1
[16:11:01.625] plan(): Setting new future strategy stack:
[16:11:01.626] List of future strategies:
[16:11:01.626] 1. multicore:
[16:11:01.626]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.626]    - tweaked: FALSE
[16:11:01.626]    - call: plan(strategy)
[16:11:01.631] plan(): nbrOfWorkers() = 2
[16:11:01.621] MulticoreFuture:
[16:11:01.621] Label: ‘future_vapply-1’
[16:11:01.621] Expression:
[16:11:01.621] {
[16:11:01.621]     do.call(function(...) {
[16:11:01.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.621]             on.exit(options(oopts), add = TRUE)
[16:11:01.621]         }
[16:11:01.621]         {
[16:11:01.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.621]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.621]             })
[16:11:01.621]         }
[16:11:01.621]     }, args = future.call.arguments)
[16:11:01.621] }
[16:11:01.621] Lazy evaluation: FALSE
[16:11:01.621] Asynchronous evaluation: TRUE
[16:11:01.621] Local evaluation: TRUE
[16:11:01.621] Environment: R_GlobalEnv
[16:11:01.621] Capture standard output: TRUE
[16:11:01.621] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.621] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.621] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:01.621] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.621] Resolved: TRUE
[16:11:01.621] Value: <not collected>
[16:11:01.621] Conditions captured: <none>
[16:11:01.621] Early signaling: FALSE
[16:11:01.621] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.621] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.632] Chunk #1 of 2 ... DONE
[16:11:01.632] Chunk #2 of 2 ...
[16:11:01.632]  - Finding globals in 'X' for chunk #2 ...
[16:11:01.632] getGlobalsAndPackages() ...
[16:11:01.633] Searching for globals...
[16:11:01.633] 
[16:11:01.633] Searching for globals ... DONE
[16:11:01.633] - globals: [0] <none>
[16:11:01.633] getGlobalsAndPackages() ... DONE
[16:11:01.634]    + additional globals found: [n=0] 
[16:11:01.634]    + additional namespaces needed: [n=0] 
[16:11:01.634]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:01.634]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:01.634]  - seeds: <none>
[16:11:01.634] getGlobalsAndPackages() ...
[16:11:01.634] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.635] Resolving globals: FALSE
[16:11:01.635] Tweak future expression to call with '...' arguments ...
[16:11:01.635] {
[16:11:01.635]     do.call(function(...) {
[16:11:01.635]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.635]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.635]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.635]             on.exit(options(oopts), add = TRUE)
[16:11:01.635]         }
[16:11:01.635]         {
[16:11:01.635]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.635]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.635]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.635]             })
[16:11:01.635]         }
[16:11:01.635]     }, args = future.call.arguments)
[16:11:01.635] }
[16:11:01.635] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.636] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.637] - packages: [2] ‘stats’, ‘future.apply’
[16:11:01.637] getGlobalsAndPackages() ... DONE
[16:11:01.637] run() for ‘Future’ ...
[16:11:01.637] - state: ‘created’
[16:11:01.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.642] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.643]   - Field: ‘label’
[16:11:01.643]   - Field: ‘local’
[16:11:01.643]   - Field: ‘owner’
[16:11:01.643]   - Field: ‘envir’
[16:11:01.643]   - Field: ‘workers’
[16:11:01.644]   - Field: ‘packages’
[16:11:01.644]   - Field: ‘gc’
[16:11:01.644]   - Field: ‘job’
[16:11:01.644]   - Field: ‘conditions’
[16:11:01.644]   - Field: ‘expr’
[16:11:01.644]   - Field: ‘uuid’
[16:11:01.645]   - Field: ‘seed’
[16:11:01.645]   - Field: ‘version’
[16:11:01.645]   - Field: ‘result’
[16:11:01.645]   - Field: ‘asynchronous’
[16:11:01.645]   - Field: ‘calls’
[16:11:01.645]   - Field: ‘globals’
[16:11:01.646]   - Field: ‘stdout’
[16:11:01.646]   - Field: ‘earlySignal’
[16:11:01.646]   - Field: ‘lazy’
[16:11:01.648]   - Field: ‘state’
[16:11:01.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.649] - Launch lazy future ...
[16:11:01.650] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:01.650] Packages needed by future strategies (n = 0): <none>
[16:11:01.652] {
[16:11:01.652]     {
[16:11:01.652]         {
[16:11:01.652]             ...future.startTime <- base::Sys.time()
[16:11:01.652]             {
[16:11:01.652]                 {
[16:11:01.652]                   {
[16:11:01.652]                     {
[16:11:01.652]                       {
[16:11:01.652]                         base::local({
[16:11:01.652]                           has_future <- base::requireNamespace("future", 
[16:11:01.652]                             quietly = TRUE)
[16:11:01.652]                           if (has_future) {
[16:11:01.652]                             ns <- base::getNamespace("future")
[16:11:01.652]                             version <- ns[[".package"]][["version"]]
[16:11:01.652]                             if (is.null(version)) 
[16:11:01.652]                               version <- utils::packageVersion("future")
[16:11:01.652]                           }
[16:11:01.652]                           else {
[16:11:01.652]                             version <- NULL
[16:11:01.652]                           }
[16:11:01.652]                           if (!has_future || version < "1.8.0") {
[16:11:01.652]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.652]                               "", base::R.version$version.string), 
[16:11:01.652]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.652]                                 base::R.version$platform, 8 * 
[16:11:01.652]                                   base::.Machine$sizeof.pointer), 
[16:11:01.652]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.652]                                 "release", "version")], collapse = " "), 
[16:11:01.652]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.652]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.652]                               info)
[16:11:01.652]                             info <- base::paste(info, collapse = "; ")
[16:11:01.652]                             if (!has_future) {
[16:11:01.652]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.652]                                 info)
[16:11:01.652]                             }
[16:11:01.652]                             else {
[16:11:01.652]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.652]                                 info, version)
[16:11:01.652]                             }
[16:11:01.652]                             base::stop(msg)
[16:11:01.652]                           }
[16:11:01.652]                         })
[16:11:01.652]                       }
[16:11:01.652]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.652]                       base::options(mc.cores = 1L)
[16:11:01.652]                     }
[16:11:01.652]                     base::local({
[16:11:01.652]                       for (pkg in c("stats", "future.apply")) {
[16:11:01.652]                         base::loadNamespace(pkg)
[16:11:01.652]                         base::library(pkg, character.only = TRUE)
[16:11:01.652]                       }
[16:11:01.652]                     })
[16:11:01.652]                   }
[16:11:01.652]                   options(future.plan = NULL)
[16:11:01.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.652]                 }
[16:11:01.652]                 ...future.workdir <- getwd()
[16:11:01.652]             }
[16:11:01.652]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.652]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.652]         }
[16:11:01.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.652]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:01.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.652]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.652]             base::names(...future.oldOptions))
[16:11:01.652]     }
[16:11:01.652]     if (FALSE) {
[16:11:01.652]     }
[16:11:01.652]     else {
[16:11:01.652]         if (TRUE) {
[16:11:01.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.652]                 open = "w")
[16:11:01.652]         }
[16:11:01.652]         else {
[16:11:01.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.652]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.652]         }
[16:11:01.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.652]             base::sink(type = "output", split = FALSE)
[16:11:01.652]             base::close(...future.stdout)
[16:11:01.652]         }, add = TRUE)
[16:11:01.652]     }
[16:11:01.652]     ...future.frame <- base::sys.nframe()
[16:11:01.652]     ...future.conditions <- base::list()
[16:11:01.652]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.652]     if (FALSE) {
[16:11:01.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.652]     }
[16:11:01.652]     ...future.result <- base::tryCatch({
[16:11:01.652]         base::withCallingHandlers({
[16:11:01.652]             ...future.value <- base::withVisible(base::local({
[16:11:01.652]                 withCallingHandlers({
[16:11:01.652]                   {
[16:11:01.652]                     do.call(function(...) {
[16:11:01.652]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.652]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.652]                         ...future.globals.maxSize)) {
[16:11:01.652]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.652]                         on.exit(options(oopts), add = TRUE)
[16:11:01.652]                       }
[16:11:01.652]                       {
[16:11:01.652]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.652]                           FUN = function(jj) {
[16:11:01.652]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.652]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.652]                           })
[16:11:01.652]                       }
[16:11:01.652]                     }, args = future.call.arguments)
[16:11:01.652]                   }
[16:11:01.652]                 }, immediateCondition = function(cond) {
[16:11:01.652]                   save_rds <- function (object, pathname, ...) 
[16:11:01.652]                   {
[16:11:01.652]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.652]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.652]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.652]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.652]                         fi_tmp[["mtime"]])
[16:11:01.652]                     }
[16:11:01.652]                     tryCatch({
[16:11:01.652]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.652]                     }, error = function(ex) {
[16:11:01.652]                       msg <- conditionMessage(ex)
[16:11:01.652]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.652]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.652]                         fi_tmp[["mtime"]], msg)
[16:11:01.652]                       ex$message <- msg
[16:11:01.652]                       stop(ex)
[16:11:01.652]                     })
[16:11:01.652]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.652]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.652]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.652]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.652]                       fi <- file.info(pathname)
[16:11:01.652]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.652]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.652]                         fi[["size"]], fi[["mtime"]])
[16:11:01.652]                       stop(msg)
[16:11:01.652]                     }
[16:11:01.652]                     invisible(pathname)
[16:11:01.652]                   }
[16:11:01.652]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.652]                     rootPath = tempdir()) 
[16:11:01.652]                   {
[16:11:01.652]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.652]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.652]                       tmpdir = path, fileext = ".rds")
[16:11:01.652]                     save_rds(obj, file)
[16:11:01.652]                   }
[16:11:01.652]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.652]                   {
[16:11:01.652]                     inherits <- base::inherits
[16:11:01.652]                     invokeRestart <- base::invokeRestart
[16:11:01.652]                     is.null <- base::is.null
[16:11:01.652]                     muffled <- FALSE
[16:11:01.652]                     if (inherits(cond, "message")) {
[16:11:01.652]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.652]                       if (muffled) 
[16:11:01.652]                         invokeRestart("muffleMessage")
[16:11:01.652]                     }
[16:11:01.652]                     else if (inherits(cond, "warning")) {
[16:11:01.652]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.652]                       if (muffled) 
[16:11:01.652]                         invokeRestart("muffleWarning")
[16:11:01.652]                     }
[16:11:01.652]                     else if (inherits(cond, "condition")) {
[16:11:01.652]                       if (!is.null(pattern)) {
[16:11:01.652]                         computeRestarts <- base::computeRestarts
[16:11:01.652]                         grepl <- base::grepl
[16:11:01.652]                         restarts <- computeRestarts(cond)
[16:11:01.652]                         for (restart in restarts) {
[16:11:01.652]                           name <- restart$name
[16:11:01.652]                           if (is.null(name)) 
[16:11:01.652]                             next
[16:11:01.652]                           if (!grepl(pattern, name)) 
[16:11:01.652]                             next
[16:11:01.652]                           invokeRestart(restart)
[16:11:01.652]                           muffled <- TRUE
[16:11:01.652]                           break
[16:11:01.652]                         }
[16:11:01.652]                       }
[16:11:01.652]                     }
[16:11:01.652]                     invisible(muffled)
[16:11:01.652]                   }
[16:11:01.652]                   muffleCondition(cond)
[16:11:01.652]                 })
[16:11:01.652]             }))
[16:11:01.652]             future::FutureResult(value = ...future.value$value, 
[16:11:01.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.652]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.652]                     ...future.globalenv.names))
[16:11:01.652]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.652]         }, condition = base::local({
[16:11:01.652]             c <- base::c
[16:11:01.652]             inherits <- base::inherits
[16:11:01.652]             invokeRestart <- base::invokeRestart
[16:11:01.652]             length <- base::length
[16:11:01.652]             list <- base::list
[16:11:01.652]             seq.int <- base::seq.int
[16:11:01.652]             signalCondition <- base::signalCondition
[16:11:01.652]             sys.calls <- base::sys.calls
[16:11:01.652]             `[[` <- base::`[[`
[16:11:01.652]             `+` <- base::`+`
[16:11:01.652]             `<<-` <- base::`<<-`
[16:11:01.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.652]                   3L)]
[16:11:01.652]             }
[16:11:01.652]             function(cond) {
[16:11:01.652]                 is_error <- inherits(cond, "error")
[16:11:01.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.652]                   NULL)
[16:11:01.652]                 if (is_error) {
[16:11:01.652]                   sessionInformation <- function() {
[16:11:01.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.652]                       search = base::search(), system = base::Sys.info())
[16:11:01.652]                   }
[16:11:01.652]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.652]                     cond$call), session = sessionInformation(), 
[16:11:01.652]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.652]                   signalCondition(cond)
[16:11:01.652]                 }
[16:11:01.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.652]                 "immediateCondition"))) {
[16:11:01.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.652]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.652]                   if (TRUE && !signal) {
[16:11:01.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.652]                     {
[16:11:01.652]                       inherits <- base::inherits
[16:11:01.652]                       invokeRestart <- base::invokeRestart
[16:11:01.652]                       is.null <- base::is.null
[16:11:01.652]                       muffled <- FALSE
[16:11:01.652]                       if (inherits(cond, "message")) {
[16:11:01.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.652]                         if (muffled) 
[16:11:01.652]                           invokeRestart("muffleMessage")
[16:11:01.652]                       }
[16:11:01.652]                       else if (inherits(cond, "warning")) {
[16:11:01.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.652]                         if (muffled) 
[16:11:01.652]                           invokeRestart("muffleWarning")
[16:11:01.652]                       }
[16:11:01.652]                       else if (inherits(cond, "condition")) {
[16:11:01.652]                         if (!is.null(pattern)) {
[16:11:01.652]                           computeRestarts <- base::computeRestarts
[16:11:01.652]                           grepl <- base::grepl
[16:11:01.652]                           restarts <- computeRestarts(cond)
[16:11:01.652]                           for (restart in restarts) {
[16:11:01.652]                             name <- restart$name
[16:11:01.652]                             if (is.null(name)) 
[16:11:01.652]                               next
[16:11:01.652]                             if (!grepl(pattern, name)) 
[16:11:01.652]                               next
[16:11:01.652]                             invokeRestart(restart)
[16:11:01.652]                             muffled <- TRUE
[16:11:01.652]                             break
[16:11:01.652]                           }
[16:11:01.652]                         }
[16:11:01.652]                       }
[16:11:01.652]                       invisible(muffled)
[16:11:01.652]                     }
[16:11:01.652]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.652]                   }
[16:11:01.652]                 }
[16:11:01.652]                 else {
[16:11:01.652]                   if (TRUE) {
[16:11:01.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.652]                     {
[16:11:01.652]                       inherits <- base::inherits
[16:11:01.652]                       invokeRestart <- base::invokeRestart
[16:11:01.652]                       is.null <- base::is.null
[16:11:01.652]                       muffled <- FALSE
[16:11:01.652]                       if (inherits(cond, "message")) {
[16:11:01.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.652]                         if (muffled) 
[16:11:01.652]                           invokeRestart("muffleMessage")
[16:11:01.652]                       }
[16:11:01.652]                       else if (inherits(cond, "warning")) {
[16:11:01.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.652]                         if (muffled) 
[16:11:01.652]                           invokeRestart("muffleWarning")
[16:11:01.652]                       }
[16:11:01.652]                       else if (inherits(cond, "condition")) {
[16:11:01.652]                         if (!is.null(pattern)) {
[16:11:01.652]                           computeRestarts <- base::computeRestarts
[16:11:01.652]                           grepl <- base::grepl
[16:11:01.652]                           restarts <- computeRestarts(cond)
[16:11:01.652]                           for (restart in restarts) {
[16:11:01.652]                             name <- restart$name
[16:11:01.652]                             if (is.null(name)) 
[16:11:01.652]                               next
[16:11:01.652]                             if (!grepl(pattern, name)) 
[16:11:01.652]                               next
[16:11:01.652]                             invokeRestart(restart)
[16:11:01.652]                             muffled <- TRUE
[16:11:01.652]                             break
[16:11:01.652]                           }
[16:11:01.652]                         }
[16:11:01.652]                       }
[16:11:01.652]                       invisible(muffled)
[16:11:01.652]                     }
[16:11:01.652]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.652]                   }
[16:11:01.652]                 }
[16:11:01.652]             }
[16:11:01.652]         }))
[16:11:01.652]     }, error = function(ex) {
[16:11:01.652]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.652]                 ...future.rng), started = ...future.startTime, 
[16:11:01.652]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.652]             version = "1.8"), class = "FutureResult")
[16:11:01.652]     }, finally = {
[16:11:01.652]         if (!identical(...future.workdir, getwd())) 
[16:11:01.652]             setwd(...future.workdir)
[16:11:01.652]         {
[16:11:01.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.652]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.652]             }
[16:11:01.652]             base::options(...future.oldOptions)
[16:11:01.652]             if (.Platform$OS.type == "windows") {
[16:11:01.652]                 old_names <- names(...future.oldEnvVars)
[16:11:01.652]                 envs <- base::Sys.getenv()
[16:11:01.652]                 names <- names(envs)
[16:11:01.652]                 common <- intersect(names, old_names)
[16:11:01.652]                 added <- setdiff(names, old_names)
[16:11:01.652]                 removed <- setdiff(old_names, names)
[16:11:01.652]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.652]                   envs[common]]
[16:11:01.652]                 NAMES <- toupper(changed)
[16:11:01.652]                 args <- list()
[16:11:01.652]                 for (kk in seq_along(NAMES)) {
[16:11:01.652]                   name <- changed[[kk]]
[16:11:01.652]                   NAME <- NAMES[[kk]]
[16:11:01.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.652]                     next
[16:11:01.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.652]                 }
[16:11:01.652]                 NAMES <- toupper(added)
[16:11:01.652]                 for (kk in seq_along(NAMES)) {
[16:11:01.652]                   name <- added[[kk]]
[16:11:01.652]                   NAME <- NAMES[[kk]]
[16:11:01.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.652]                     next
[16:11:01.652]                   args[[name]] <- ""
[16:11:01.652]                 }
[16:11:01.652]                 NAMES <- toupper(removed)
[16:11:01.652]                 for (kk in seq_along(NAMES)) {
[16:11:01.652]                   name <- removed[[kk]]
[16:11:01.652]                   NAME <- NAMES[[kk]]
[16:11:01.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.652]                     next
[16:11:01.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.652]                 }
[16:11:01.652]                 if (length(args) > 0) 
[16:11:01.652]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.652]             }
[16:11:01.652]             else {
[16:11:01.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.652]             }
[16:11:01.652]             {
[16:11:01.652]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.652]                   0L) {
[16:11:01.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.652]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.652]                   base::options(opts)
[16:11:01.652]                 }
[16:11:01.652]                 {
[16:11:01.652]                   {
[16:11:01.652]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.652]                     NULL
[16:11:01.652]                   }
[16:11:01.652]                   options(future.plan = NULL)
[16:11:01.652]                   if (is.na(NA_character_)) 
[16:11:01.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.652]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.652]                     envir = parent.frame()) 
[16:11:01.652]                   {
[16:11:01.652]                     default_workers <- missing(workers)
[16:11:01.652]                     if (is.function(workers)) 
[16:11:01.652]                       workers <- workers()
[16:11:01.652]                     workers <- structure(as.integer(workers), 
[16:11:01.652]                       class = class(workers))
[16:11:01.652]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.652]                       1L)
[16:11:01.652]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.652]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.652]                       if (default_workers) 
[16:11:01.652]                         supportsMulticore(warn = TRUE)
[16:11:01.652]                       return(sequential(..., envir = envir))
[16:11:01.652]                     }
[16:11:01.652]                     oopts <- options(mc.cores = workers)
[16:11:01.652]                     on.exit(options(oopts))
[16:11:01.652]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.652]                       envir = envir)
[16:11:01.652]                     if (!future$lazy) 
[16:11:01.652]                       future <- run(future)
[16:11:01.652]                     invisible(future)
[16:11:01.652]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.652]                 }
[16:11:01.652]             }
[16:11:01.652]         }
[16:11:01.652]     })
[16:11:01.652]     if (TRUE) {
[16:11:01.652]         base::sink(type = "output", split = FALSE)
[16:11:01.652]         if (TRUE) {
[16:11:01.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.652]         }
[16:11:01.652]         else {
[16:11:01.652]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.652]         }
[16:11:01.652]         base::close(...future.stdout)
[16:11:01.652]         ...future.stdout <- NULL
[16:11:01.652]     }
[16:11:01.652]     ...future.result$conditions <- ...future.conditions
[16:11:01.652]     ...future.result$finished <- base::Sys.time()
[16:11:01.652]     ...future.result
[16:11:01.652] }
[16:11:01.656] assign_globals() ...
[16:11:01.656] List of 11
[16:11:01.656]  $ ...future.FUN            :function (x, ...)  
[16:11:01.656]  $ x_FUN                    :function (x, ...)  
[16:11:01.656]  $ times                    : int 5
[16:11:01.656]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.656]  $ stop_if_not              :function (...)  
[16:11:01.656]  $ dim                      : NULL
[16:11:01.656]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.656]  $ future.call.arguments    : list()
[16:11:01.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.656]  $ ...future.elements_ii    :List of 2
[16:11:01.656]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:11:01.656]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:11:01.656]  $ ...future.seeds_ii       : NULL
[16:11:01.656]  $ ...future.globals.maxSize: NULL
[16:11:01.656]  - attr(*, "resolved")= logi FALSE
[16:11:01.656]  - attr(*, "total_size")= num 95528
[16:11:01.656]  - attr(*, "where")=List of 11
[16:11:01.656]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.656]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.656]  - attr(*, "already-done")= logi TRUE
[16:11:01.669] - copied ‘...future.FUN’ to environment
[16:11:01.670] - copied ‘x_FUN’ to environment
[16:11:01.670] - copied ‘times’ to environment
[16:11:01.670] - copied ‘stopf’ to environment
[16:11:01.670] - copied ‘stop_if_not’ to environment
[16:11:01.670] - copied ‘dim’ to environment
[16:11:01.670] - copied ‘valid_types’ to environment
[16:11:01.670] - copied ‘future.call.arguments’ to environment
[16:11:01.670] - copied ‘...future.elements_ii’ to environment
[16:11:01.670] - copied ‘...future.seeds_ii’ to environment
[16:11:01.671] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.671] assign_globals() ... done
[16:11:01.671] requestCore(): workers = 2
[16:11:01.673] MulticoreFuture started
[16:11:01.674] - Launch lazy future ... done
[16:11:01.674] run() for ‘MulticoreFuture’ ... done
[16:11:01.674] Created future:
[16:11:01.675] plan(): Setting new future strategy stack:
[16:11:01.675] List of future strategies:
[16:11:01.675] 1. sequential:
[16:11:01.675]    - args: function (..., envir = parent.frame())
[16:11:01.675]    - tweaked: FALSE
[16:11:01.675]    - call: NULL
[16:11:01.676] plan(): nbrOfWorkers() = 1
[16:11:01.679] plan(): Setting new future strategy stack:
[16:11:01.679] List of future strategies:
[16:11:01.679] 1. multicore:
[16:11:01.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.679]    - tweaked: FALSE
[16:11:01.679]    - call: plan(strategy)
[16:11:01.685] plan(): nbrOfWorkers() = 2
[16:11:01.674] MulticoreFuture:
[16:11:01.674] Label: ‘future_vapply-2’
[16:11:01.674] Expression:
[16:11:01.674] {
[16:11:01.674]     do.call(function(...) {
[16:11:01.674]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.674]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.674]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.674]             on.exit(options(oopts), add = TRUE)
[16:11:01.674]         }
[16:11:01.674]         {
[16:11:01.674]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.674]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.674]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.674]             })
[16:11:01.674]         }
[16:11:01.674]     }, args = future.call.arguments)
[16:11:01.674] }
[16:11:01.674] Lazy evaluation: FALSE
[16:11:01.674] Asynchronous evaluation: TRUE
[16:11:01.674] Local evaluation: TRUE
[16:11:01.674] Environment: R_GlobalEnv
[16:11:01.674] Capture standard output: TRUE
[16:11:01.674] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.674] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.674] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:01.674] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.674] Resolved: TRUE
[16:11:01.674] Value: <not collected>
[16:11:01.674] Conditions captured: <none>
[16:11:01.674] Early signaling: FALSE
[16:11:01.674] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.674] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.686] Chunk #2 of 2 ... DONE
[16:11:01.686] Launching 2 futures (chunks) ... DONE
[16:11:01.686] Resolving 2 futures (chunks) ...
[16:11:01.687] resolve() on list ...
[16:11:01.687]  recursive: 0
[16:11:01.687]  length: 2
[16:11:01.687] 
[16:11:01.687] Future #1
[16:11:01.689] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:01.689] - nx: 2
[16:11:01.689] - relay: TRUE
[16:11:01.689] - stdout: TRUE
[16:11:01.689] - signal: TRUE
[16:11:01.689] - resignal: FALSE
[16:11:01.689] - force: TRUE
[16:11:01.689] - relayed: [n=2] FALSE, FALSE
[16:11:01.689] - queued futures: [n=2] FALSE, FALSE
[16:11:01.690]  - until=1
[16:11:01.690]  - relaying element #1
[16:11:01.690] - relayed: [n=2] TRUE, FALSE
[16:11:01.690] - queued futures: [n=2] TRUE, FALSE
[16:11:01.690] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:01.691]  length: 1 (resolved future 1)
[16:11:01.691] Future #2
[16:11:01.692] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:01.692] - nx: 2
[16:11:01.693] - relay: TRUE
[16:11:01.693] - stdout: TRUE
[16:11:01.693] - signal: TRUE
[16:11:01.693] - resignal: FALSE
[16:11:01.693] - force: TRUE
[16:11:01.693] - relayed: [n=2] TRUE, FALSE
[16:11:01.694] - queued futures: [n=2] TRUE, FALSE
[16:11:01.694]  - until=2
[16:11:01.694]  - relaying element #2
[16:11:01.695] - relayed: [n=2] TRUE, TRUE
[16:11:01.695] - queued futures: [n=2] TRUE, TRUE
[16:11:01.695] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:01.695]  length: 0 (resolved future 2)
[16:11:01.695] Relaying remaining futures
[16:11:01.695] signalConditionsASAP(NULL, pos=0) ...
[16:11:01.698] - nx: 2
[16:11:01.698] - relay: TRUE
[16:11:01.699] - stdout: TRUE
[16:11:01.699] - signal: TRUE
[16:11:01.699] - resignal: FALSE
[16:11:01.699] - force: TRUE
[16:11:01.699] - relayed: [n=2] TRUE, TRUE
[16:11:01.699] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:01.700] - relayed: [n=2] TRUE, TRUE
[16:11:01.700] - queued futures: [n=2] TRUE, TRUE
[16:11:01.700] signalConditionsASAP(NULL, pos=0) ... done
[16:11:01.700] resolve() on list ... DONE
[16:11:01.701]  - Number of value chunks collected: 2
[16:11:01.701] Resolving 2 futures (chunks) ... DONE
[16:11:01.701] Reducing values from 2 chunks ...
[16:11:01.701]  - Number of values collected after concatenation: 3
[16:11:01.701]  - Number of values expected: 3
[16:11:01.701] Reducing values from 2 chunks ... DONE
[16:11:01.702] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:11:01.705] future_lapply() ...
[16:11:01.714] Number of chunks: 2
[16:11:01.714] getGlobalsAndPackagesXApply() ...
[16:11:01.714]  - future.globals: TRUE
[16:11:01.714] getGlobalsAndPackages() ...
[16:11:01.714] Searching for globals...
[16:11:01.720] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:11:01.720] Searching for globals ... DONE
[16:11:01.720] Resolving globals: FALSE
[16:11:01.721] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:11:01.721] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:11:01.721] - globals: [1] ‘FUN’
[16:11:01.721] - packages: [1] ‘stats’
[16:11:01.721] getGlobalsAndPackages() ... DONE
[16:11:01.722]  - globals found/used: [n=1] ‘FUN’
[16:11:01.722]  - needed namespaces: [n=1] ‘stats’
[16:11:01.722] Finding globals ... DONE
[16:11:01.722]  - use_args: TRUE
[16:11:01.722]  - Getting '...' globals ...
[16:11:01.724] resolve() on list ...
[16:11:01.725]  recursive: 0
[16:11:01.725]  length: 1
[16:11:01.725]  elements: ‘...’
[16:11:01.725]  length: 0 (resolved future 1)
[16:11:01.725] resolve() on list ... DONE
[16:11:01.725]    - '...' content: [n=0] 
[16:11:01.725] List of 1
[16:11:01.725]  $ ...: list()
[16:11:01.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.725]  - attr(*, "where")=List of 1
[16:11:01.725]   ..$ ...:<environment: 0x561e8805f5e0> 
[16:11:01.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.725]  - attr(*, "resolved")= logi TRUE
[16:11:01.725]  - attr(*, "total_size")= num NA
[16:11:01.728]  - Getting '...' globals ... DONE
[16:11:01.729] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:01.729] List of 2
[16:11:01.729]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:11:01.729]  $ ...          : list()
[16:11:01.729]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.729]  - attr(*, "where")=List of 2
[16:11:01.729]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:01.729]   ..$ ...          :<environment: 0x561e8805f5e0> 
[16:11:01.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.729]  - attr(*, "resolved")= logi FALSE
[16:11:01.729]  - attr(*, "total_size")= num 46960
[16:11:01.732] Packages to be attached in all futures: [n=1] ‘stats’
[16:11:01.732] getGlobalsAndPackagesXApply() ... DONE
[16:11:01.732] Number of futures (= number of chunks): 2
[16:11:01.732] Launching 2 futures (chunks) ...
[16:11:01.732] Chunk #1 of 2 ...
[16:11:01.732]  - Finding globals in 'X' for chunk #1 ...
[16:11:01.732] getGlobalsAndPackages() ...
[16:11:01.733] Searching for globals...
[16:11:01.733] 
[16:11:01.733] Searching for globals ... DONE
[16:11:01.733] - globals: [0] <none>
[16:11:01.733] getGlobalsAndPackages() ... DONE
[16:11:01.733]    + additional globals found: [n=0] 
[16:11:01.733]    + additional namespaces needed: [n=0] 
[16:11:01.733]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:01.733]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[16:11:01.734]  - seeds: <none>
[16:11:01.734] getGlobalsAndPackages() ...
[16:11:01.734] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.734] Resolving globals: FALSE
[16:11:01.734] Tweak future expression to call with '...' arguments ...
[16:11:01.734] {
[16:11:01.734]     do.call(function(...) {
[16:11:01.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.734]             on.exit(options(oopts), add = TRUE)
[16:11:01.734]         }
[16:11:01.734]         {
[16:11:01.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.734]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.734]             })
[16:11:01.734]         }
[16:11:01.734]     }, args = future.call.arguments)
[16:11:01.734] }
[16:11:01.734] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.735] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.735] - packages: [1] ‘stats’
[16:11:01.735] getGlobalsAndPackages() ... DONE
[16:11:01.735] run() for ‘Future’ ...
[16:11:01.735] - state: ‘created’
[16:11:01.736] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.739] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.740] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.740]   - Field: ‘label’
[16:11:01.740]   - Field: ‘local’
[16:11:01.740]   - Field: ‘owner’
[16:11:01.740]   - Field: ‘envir’
[16:11:01.740]   - Field: ‘workers’
[16:11:01.740]   - Field: ‘packages’
[16:11:01.741]   - Field: ‘gc’
[16:11:01.741]   - Field: ‘job’
[16:11:01.741]   - Field: ‘conditions’
[16:11:01.741]   - Field: ‘expr’
[16:11:01.741]   - Field: ‘uuid’
[16:11:01.741]   - Field: ‘seed’
[16:11:01.741]   - Field: ‘version’
[16:11:01.741]   - Field: ‘result’
[16:11:01.741]   - Field: ‘asynchronous’
[16:11:01.742]   - Field: ‘calls’
[16:11:01.742]   - Field: ‘globals’
[16:11:01.742]   - Field: ‘stdout’
[16:11:01.742]   - Field: ‘earlySignal’
[16:11:01.742]   - Field: ‘lazy’
[16:11:01.742]   - Field: ‘state’
[16:11:01.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.742] - Launch lazy future ...
[16:11:01.743] Packages needed by the future expression (n = 1): ‘stats’
[16:11:01.743] Packages needed by future strategies (n = 0): <none>
[16:11:01.743] {
[16:11:01.743]     {
[16:11:01.743]         {
[16:11:01.743]             ...future.startTime <- base::Sys.time()
[16:11:01.743]             {
[16:11:01.743]                 {
[16:11:01.743]                   {
[16:11:01.743]                     {
[16:11:01.743]                       {
[16:11:01.743]                         base::local({
[16:11:01.743]                           has_future <- base::requireNamespace("future", 
[16:11:01.743]                             quietly = TRUE)
[16:11:01.743]                           if (has_future) {
[16:11:01.743]                             ns <- base::getNamespace("future")
[16:11:01.743]                             version <- ns[[".package"]][["version"]]
[16:11:01.743]                             if (is.null(version)) 
[16:11:01.743]                               version <- utils::packageVersion("future")
[16:11:01.743]                           }
[16:11:01.743]                           else {
[16:11:01.743]                             version <- NULL
[16:11:01.743]                           }
[16:11:01.743]                           if (!has_future || version < "1.8.0") {
[16:11:01.743]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.743]                               "", base::R.version$version.string), 
[16:11:01.743]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.743]                                 base::R.version$platform, 8 * 
[16:11:01.743]                                   base::.Machine$sizeof.pointer), 
[16:11:01.743]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.743]                                 "release", "version")], collapse = " "), 
[16:11:01.743]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.743]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.743]                               info)
[16:11:01.743]                             info <- base::paste(info, collapse = "; ")
[16:11:01.743]                             if (!has_future) {
[16:11:01.743]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.743]                                 info)
[16:11:01.743]                             }
[16:11:01.743]                             else {
[16:11:01.743]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.743]                                 info, version)
[16:11:01.743]                             }
[16:11:01.743]                             base::stop(msg)
[16:11:01.743]                           }
[16:11:01.743]                         })
[16:11:01.743]                       }
[16:11:01.743]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.743]                       base::options(mc.cores = 1L)
[16:11:01.743]                     }
[16:11:01.743]                     base::local({
[16:11:01.743]                       for (pkg in "stats") {
[16:11:01.743]                         base::loadNamespace(pkg)
[16:11:01.743]                         base::library(pkg, character.only = TRUE)
[16:11:01.743]                       }
[16:11:01.743]                     })
[16:11:01.743]                   }
[16:11:01.743]                   options(future.plan = NULL)
[16:11:01.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.743]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.743]                 }
[16:11:01.743]                 ...future.workdir <- getwd()
[16:11:01.743]             }
[16:11:01.743]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.743]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.743]         }
[16:11:01.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.743]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[16:11:01.743]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.743]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.743]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.743]             base::names(...future.oldOptions))
[16:11:01.743]     }
[16:11:01.743]     if (FALSE) {
[16:11:01.743]     }
[16:11:01.743]     else {
[16:11:01.743]         if (TRUE) {
[16:11:01.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.743]                 open = "w")
[16:11:01.743]         }
[16:11:01.743]         else {
[16:11:01.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.743]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.743]         }
[16:11:01.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.743]             base::sink(type = "output", split = FALSE)
[16:11:01.743]             base::close(...future.stdout)
[16:11:01.743]         }, add = TRUE)
[16:11:01.743]     }
[16:11:01.743]     ...future.frame <- base::sys.nframe()
[16:11:01.743]     ...future.conditions <- base::list()
[16:11:01.743]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.743]     if (FALSE) {
[16:11:01.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.743]     }
[16:11:01.743]     ...future.result <- base::tryCatch({
[16:11:01.743]         base::withCallingHandlers({
[16:11:01.743]             ...future.value <- base::withVisible(base::local({
[16:11:01.743]                 withCallingHandlers({
[16:11:01.743]                   {
[16:11:01.743]                     do.call(function(...) {
[16:11:01.743]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.743]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.743]                         ...future.globals.maxSize)) {
[16:11:01.743]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.743]                         on.exit(options(oopts), add = TRUE)
[16:11:01.743]                       }
[16:11:01.743]                       {
[16:11:01.743]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.743]                           FUN = function(jj) {
[16:11:01.743]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.743]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.743]                           })
[16:11:01.743]                       }
[16:11:01.743]                     }, args = future.call.arguments)
[16:11:01.743]                   }
[16:11:01.743]                 }, immediateCondition = function(cond) {
[16:11:01.743]                   save_rds <- function (object, pathname, ...) 
[16:11:01.743]                   {
[16:11:01.743]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.743]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.743]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.743]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.743]                         fi_tmp[["mtime"]])
[16:11:01.743]                     }
[16:11:01.743]                     tryCatch({
[16:11:01.743]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.743]                     }, error = function(ex) {
[16:11:01.743]                       msg <- conditionMessage(ex)
[16:11:01.743]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.743]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.743]                         fi_tmp[["mtime"]], msg)
[16:11:01.743]                       ex$message <- msg
[16:11:01.743]                       stop(ex)
[16:11:01.743]                     })
[16:11:01.743]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.743]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.743]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.743]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.743]                       fi <- file.info(pathname)
[16:11:01.743]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.743]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.743]                         fi[["size"]], fi[["mtime"]])
[16:11:01.743]                       stop(msg)
[16:11:01.743]                     }
[16:11:01.743]                     invisible(pathname)
[16:11:01.743]                   }
[16:11:01.743]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.743]                     rootPath = tempdir()) 
[16:11:01.743]                   {
[16:11:01.743]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.743]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.743]                       tmpdir = path, fileext = ".rds")
[16:11:01.743]                     save_rds(obj, file)
[16:11:01.743]                   }
[16:11:01.743]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.743]                   {
[16:11:01.743]                     inherits <- base::inherits
[16:11:01.743]                     invokeRestart <- base::invokeRestart
[16:11:01.743]                     is.null <- base::is.null
[16:11:01.743]                     muffled <- FALSE
[16:11:01.743]                     if (inherits(cond, "message")) {
[16:11:01.743]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.743]                       if (muffled) 
[16:11:01.743]                         invokeRestart("muffleMessage")
[16:11:01.743]                     }
[16:11:01.743]                     else if (inherits(cond, "warning")) {
[16:11:01.743]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.743]                       if (muffled) 
[16:11:01.743]                         invokeRestart("muffleWarning")
[16:11:01.743]                     }
[16:11:01.743]                     else if (inherits(cond, "condition")) {
[16:11:01.743]                       if (!is.null(pattern)) {
[16:11:01.743]                         computeRestarts <- base::computeRestarts
[16:11:01.743]                         grepl <- base::grepl
[16:11:01.743]                         restarts <- computeRestarts(cond)
[16:11:01.743]                         for (restart in restarts) {
[16:11:01.743]                           name <- restart$name
[16:11:01.743]                           if (is.null(name)) 
[16:11:01.743]                             next
[16:11:01.743]                           if (!grepl(pattern, name)) 
[16:11:01.743]                             next
[16:11:01.743]                           invokeRestart(restart)
[16:11:01.743]                           muffled <- TRUE
[16:11:01.743]                           break
[16:11:01.743]                         }
[16:11:01.743]                       }
[16:11:01.743]                     }
[16:11:01.743]                     invisible(muffled)
[16:11:01.743]                   }
[16:11:01.743]                   muffleCondition(cond)
[16:11:01.743]                 })
[16:11:01.743]             }))
[16:11:01.743]             future::FutureResult(value = ...future.value$value, 
[16:11:01.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.743]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.743]                     ...future.globalenv.names))
[16:11:01.743]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.743]         }, condition = base::local({
[16:11:01.743]             c <- base::c
[16:11:01.743]             inherits <- base::inherits
[16:11:01.743]             invokeRestart <- base::invokeRestart
[16:11:01.743]             length <- base::length
[16:11:01.743]             list <- base::list
[16:11:01.743]             seq.int <- base::seq.int
[16:11:01.743]             signalCondition <- base::signalCondition
[16:11:01.743]             sys.calls <- base::sys.calls
[16:11:01.743]             `[[` <- base::`[[`
[16:11:01.743]             `+` <- base::`+`
[16:11:01.743]             `<<-` <- base::`<<-`
[16:11:01.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.743]                   3L)]
[16:11:01.743]             }
[16:11:01.743]             function(cond) {
[16:11:01.743]                 is_error <- inherits(cond, "error")
[16:11:01.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.743]                   NULL)
[16:11:01.743]                 if (is_error) {
[16:11:01.743]                   sessionInformation <- function() {
[16:11:01.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.743]                       search = base::search(), system = base::Sys.info())
[16:11:01.743]                   }
[16:11:01.743]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.743]                     cond$call), session = sessionInformation(), 
[16:11:01.743]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.743]                   signalCondition(cond)
[16:11:01.743]                 }
[16:11:01.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.743]                 "immediateCondition"))) {
[16:11:01.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.743]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.743]                   if (TRUE && !signal) {
[16:11:01.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.743]                     {
[16:11:01.743]                       inherits <- base::inherits
[16:11:01.743]                       invokeRestart <- base::invokeRestart
[16:11:01.743]                       is.null <- base::is.null
[16:11:01.743]                       muffled <- FALSE
[16:11:01.743]                       if (inherits(cond, "message")) {
[16:11:01.743]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.743]                         if (muffled) 
[16:11:01.743]                           invokeRestart("muffleMessage")
[16:11:01.743]                       }
[16:11:01.743]                       else if (inherits(cond, "warning")) {
[16:11:01.743]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.743]                         if (muffled) 
[16:11:01.743]                           invokeRestart("muffleWarning")
[16:11:01.743]                       }
[16:11:01.743]                       else if (inherits(cond, "condition")) {
[16:11:01.743]                         if (!is.null(pattern)) {
[16:11:01.743]                           computeRestarts <- base::computeRestarts
[16:11:01.743]                           grepl <- base::grepl
[16:11:01.743]                           restarts <- computeRestarts(cond)
[16:11:01.743]                           for (restart in restarts) {
[16:11:01.743]                             name <- restart$name
[16:11:01.743]                             if (is.null(name)) 
[16:11:01.743]                               next
[16:11:01.743]                             if (!grepl(pattern, name)) 
[16:11:01.743]                               next
[16:11:01.743]                             invokeRestart(restart)
[16:11:01.743]                             muffled <- TRUE
[16:11:01.743]                             break
[16:11:01.743]                           }
[16:11:01.743]                         }
[16:11:01.743]                       }
[16:11:01.743]                       invisible(muffled)
[16:11:01.743]                     }
[16:11:01.743]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.743]                   }
[16:11:01.743]                 }
[16:11:01.743]                 else {
[16:11:01.743]                   if (TRUE) {
[16:11:01.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.743]                     {
[16:11:01.743]                       inherits <- base::inherits
[16:11:01.743]                       invokeRestart <- base::invokeRestart
[16:11:01.743]                       is.null <- base::is.null
[16:11:01.743]                       muffled <- FALSE
[16:11:01.743]                       if (inherits(cond, "message")) {
[16:11:01.743]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.743]                         if (muffled) 
[16:11:01.743]                           invokeRestart("muffleMessage")
[16:11:01.743]                       }
[16:11:01.743]                       else if (inherits(cond, "warning")) {
[16:11:01.743]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.743]                         if (muffled) 
[16:11:01.743]                           invokeRestart("muffleWarning")
[16:11:01.743]                       }
[16:11:01.743]                       else if (inherits(cond, "condition")) {
[16:11:01.743]                         if (!is.null(pattern)) {
[16:11:01.743]                           computeRestarts <- base::computeRestarts
[16:11:01.743]                           grepl <- base::grepl
[16:11:01.743]                           restarts <- computeRestarts(cond)
[16:11:01.743]                           for (restart in restarts) {
[16:11:01.743]                             name <- restart$name
[16:11:01.743]                             if (is.null(name)) 
[16:11:01.743]                               next
[16:11:01.743]                             if (!grepl(pattern, name)) 
[16:11:01.743]                               next
[16:11:01.743]                             invokeRestart(restart)
[16:11:01.743]                             muffled <- TRUE
[16:11:01.743]                             break
[16:11:01.743]                           }
[16:11:01.743]                         }
[16:11:01.743]                       }
[16:11:01.743]                       invisible(muffled)
[16:11:01.743]                     }
[16:11:01.743]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.743]                   }
[16:11:01.743]                 }
[16:11:01.743]             }
[16:11:01.743]         }))
[16:11:01.743]     }, error = function(ex) {
[16:11:01.743]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.743]                 ...future.rng), started = ...future.startTime, 
[16:11:01.743]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.743]             version = "1.8"), class = "FutureResult")
[16:11:01.743]     }, finally = {
[16:11:01.743]         if (!identical(...future.workdir, getwd())) 
[16:11:01.743]             setwd(...future.workdir)
[16:11:01.743]         {
[16:11:01.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.743]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.743]             }
[16:11:01.743]             base::options(...future.oldOptions)
[16:11:01.743]             if (.Platform$OS.type == "windows") {
[16:11:01.743]                 old_names <- names(...future.oldEnvVars)
[16:11:01.743]                 envs <- base::Sys.getenv()
[16:11:01.743]                 names <- names(envs)
[16:11:01.743]                 common <- intersect(names, old_names)
[16:11:01.743]                 added <- setdiff(names, old_names)
[16:11:01.743]                 removed <- setdiff(old_names, names)
[16:11:01.743]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.743]                   envs[common]]
[16:11:01.743]                 NAMES <- toupper(changed)
[16:11:01.743]                 args <- list()
[16:11:01.743]                 for (kk in seq_along(NAMES)) {
[16:11:01.743]                   name <- changed[[kk]]
[16:11:01.743]                   NAME <- NAMES[[kk]]
[16:11:01.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.743]                     next
[16:11:01.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.743]                 }
[16:11:01.743]                 NAMES <- toupper(added)
[16:11:01.743]                 for (kk in seq_along(NAMES)) {
[16:11:01.743]                   name <- added[[kk]]
[16:11:01.743]                   NAME <- NAMES[[kk]]
[16:11:01.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.743]                     next
[16:11:01.743]                   args[[name]] <- ""
[16:11:01.743]                 }
[16:11:01.743]                 NAMES <- toupper(removed)
[16:11:01.743]                 for (kk in seq_along(NAMES)) {
[16:11:01.743]                   name <- removed[[kk]]
[16:11:01.743]                   NAME <- NAMES[[kk]]
[16:11:01.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.743]                     next
[16:11:01.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.743]                 }
[16:11:01.743]                 if (length(args) > 0) 
[16:11:01.743]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.743]             }
[16:11:01.743]             else {
[16:11:01.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.743]             }
[16:11:01.743]             {
[16:11:01.743]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.743]                   0L) {
[16:11:01.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.743]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.743]                   base::options(opts)
[16:11:01.743]                 }
[16:11:01.743]                 {
[16:11:01.743]                   {
[16:11:01.743]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.743]                     NULL
[16:11:01.743]                   }
[16:11:01.743]                   options(future.plan = NULL)
[16:11:01.743]                   if (is.na(NA_character_)) 
[16:11:01.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.743]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.743]                     envir = parent.frame()) 
[16:11:01.743]                   {
[16:11:01.743]                     default_workers <- missing(workers)
[16:11:01.743]                     if (is.function(workers)) 
[16:11:01.743]                       workers <- workers()
[16:11:01.743]                     workers <- structure(as.integer(workers), 
[16:11:01.743]                       class = class(workers))
[16:11:01.743]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.743]                       1L)
[16:11:01.743]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.743]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.743]                       if (default_workers) 
[16:11:01.743]                         supportsMulticore(warn = TRUE)
[16:11:01.743]                       return(sequential(..., envir = envir))
[16:11:01.743]                     }
[16:11:01.743]                     oopts <- options(mc.cores = workers)
[16:11:01.743]                     on.exit(options(oopts))
[16:11:01.743]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.743]                       envir = envir)
[16:11:01.743]                     if (!future$lazy) 
[16:11:01.743]                       future <- run(future)
[16:11:01.743]                     invisible(future)
[16:11:01.743]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.743]                 }
[16:11:01.743]             }
[16:11:01.743]         }
[16:11:01.743]     })
[16:11:01.743]     if (TRUE) {
[16:11:01.743]         base::sink(type = "output", split = FALSE)
[16:11:01.743]         if (TRUE) {
[16:11:01.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.743]         }
[16:11:01.743]         else {
[16:11:01.743]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.743]         }
[16:11:01.743]         base::close(...future.stdout)
[16:11:01.743]         ...future.stdout <- NULL
[16:11:01.743]     }
[16:11:01.743]     ...future.result$conditions <- ...future.conditions
[16:11:01.743]     ...future.result$finished <- base::Sys.time()
[16:11:01.743]     ...future.result
[16:11:01.743] }
[16:11:01.746] assign_globals() ...
[16:11:01.746] List of 5
[16:11:01.746]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:11:01.746]  $ future.call.arguments    : list()
[16:11:01.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.746]  $ ...future.elements_ii    :List of 4
[16:11:01.746]   ..$ : int [1:3] 1 2 3
[16:11:01.746]   ..$ : int [1:4] 1 2 3 4
[16:11:01.746]   ..$ : int [1:5] 1 2 3 4 5
[16:11:01.746]   ..$ : int [1:6] 1 2 3 4 5 6
[16:11:01.746]  $ ...future.seeds_ii       : NULL
[16:11:01.746]  $ ...future.globals.maxSize: NULL
[16:11:01.746]  - attr(*, "resolved")= logi FALSE
[16:11:01.746]  - attr(*, "total_size")= num 46960
[16:11:01.746]  - attr(*, "where")=List of 5
[16:11:01.746]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.746]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.746]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.746]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.746]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.746]  - attr(*, "already-done")= logi TRUE
[16:11:01.754] - copied ‘...future.FUN’ to environment
[16:11:01.754] - copied ‘future.call.arguments’ to environment
[16:11:01.754] - copied ‘...future.elements_ii’ to environment
[16:11:01.754] - copied ‘...future.seeds_ii’ to environment
[16:11:01.754] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.755] assign_globals() ... done
[16:11:01.755] requestCore(): workers = 2
[16:11:01.757] MulticoreFuture started
[16:11:01.758] - Launch lazy future ... done
[16:11:01.758] run() for ‘MulticoreFuture’ ... done
[16:11:01.759] Created future:
[16:11:01.759] plan(): Setting new future strategy stack:
[16:11:01.759] List of future strategies:
[16:11:01.759] 1. sequential:
[16:11:01.759]    - args: function (..., envir = parent.frame())
[16:11:01.759]    - tweaked: FALSE
[16:11:01.759]    - call: NULL
[16:11:01.760] plan(): nbrOfWorkers() = 1
[16:11:01.762] plan(): Setting new future strategy stack:
[16:11:01.763] List of future strategies:
[16:11:01.763] 1. multicore:
[16:11:01.763]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.763]    - tweaked: FALSE
[16:11:01.763]    - call: plan(strategy)
[16:11:01.768] plan(): nbrOfWorkers() = 2
[16:11:01.759] MulticoreFuture:
[16:11:01.759] Label: ‘future_sapply-1’
[16:11:01.759] Expression:
[16:11:01.759] {
[16:11:01.759]     do.call(function(...) {
[16:11:01.759]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.759]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.759]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.759]             on.exit(options(oopts), add = TRUE)
[16:11:01.759]         }
[16:11:01.759]         {
[16:11:01.759]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.759]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.759]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.759]             })
[16:11:01.759]         }
[16:11:01.759]     }, args = future.call.arguments)
[16:11:01.759] }
[16:11:01.759] Lazy evaluation: FALSE
[16:11:01.759] Asynchronous evaluation: TRUE
[16:11:01.759] Local evaluation: TRUE
[16:11:01.759] Environment: R_GlobalEnv
[16:11:01.759] Capture standard output: TRUE
[16:11:01.759] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.759] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:01.759] Packages: 1 packages (‘stats’)
[16:11:01.759] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.759] Resolved: TRUE
[16:11:01.759] Value: <not collected>
[16:11:01.759] Conditions captured: <none>
[16:11:01.759] Early signaling: FALSE
[16:11:01.759] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.759] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.769] Chunk #1 of 2 ... DONE
[16:11:01.770] Chunk #2 of 2 ...
[16:11:01.770]  - Finding globals in 'X' for chunk #2 ...
[16:11:01.770] getGlobalsAndPackages() ...
[16:11:01.770] Searching for globals...
[16:11:01.770] 
[16:11:01.771] Searching for globals ... DONE
[16:11:01.771] - globals: [0] <none>
[16:11:01.771] getGlobalsAndPackages() ... DONE
[16:11:01.771]    + additional globals found: [n=0] 
[16:11:01.771]    + additional namespaces needed: [n=0] 
[16:11:01.771]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:01.772]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:11:01.772]  - seeds: <none>
[16:11:01.772] getGlobalsAndPackages() ...
[16:11:01.772] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.772] Resolving globals: FALSE
[16:11:01.773] Tweak future expression to call with '...' arguments ...
[16:11:01.773] {
[16:11:01.773]     do.call(function(...) {
[16:11:01.773]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.773]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.773]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.773]             on.exit(options(oopts), add = TRUE)
[16:11:01.773]         }
[16:11:01.773]         {
[16:11:01.773]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.773]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.773]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.773]             })
[16:11:01.773]         }
[16:11:01.773]     }, args = future.call.arguments)
[16:11:01.773] }
[16:11:01.773] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.774] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.774] - packages: [1] ‘stats’
[16:11:01.775] getGlobalsAndPackages() ... DONE
[16:11:01.775] run() for ‘Future’ ...
[16:11:01.775] - state: ‘created’
[16:11:01.776] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.780] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.780]   - Field: ‘label’
[16:11:01.781]   - Field: ‘local’
[16:11:01.781]   - Field: ‘owner’
[16:11:01.781]   - Field: ‘envir’
[16:11:01.781]   - Field: ‘workers’
[16:11:01.781]   - Field: ‘packages’
[16:11:01.781]   - Field: ‘gc’
[16:11:01.781]   - Field: ‘job’
[16:11:01.782]   - Field: ‘conditions’
[16:11:01.782]   - Field: ‘expr’
[16:11:01.782]   - Field: ‘uuid’
[16:11:01.782]   - Field: ‘seed’
[16:11:01.782]   - Field: ‘version’
[16:11:01.782]   - Field: ‘result’
[16:11:01.782]   - Field: ‘asynchronous’
[16:11:01.783]   - Field: ‘calls’
[16:11:01.783]   - Field: ‘globals’
[16:11:01.783]   - Field: ‘stdout’
[16:11:01.783]   - Field: ‘earlySignal’
[16:11:01.783]   - Field: ‘lazy’
[16:11:01.783]   - Field: ‘state’
[16:11:01.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.784] - Launch lazy future ...
[16:11:01.784] Packages needed by the future expression (n = 1): ‘stats’
[16:11:01.784] Packages needed by future strategies (n = 0): <none>
[16:11:01.785] {
[16:11:01.785]     {
[16:11:01.785]         {
[16:11:01.785]             ...future.startTime <- base::Sys.time()
[16:11:01.785]             {
[16:11:01.785]                 {
[16:11:01.785]                   {
[16:11:01.785]                     {
[16:11:01.785]                       {
[16:11:01.785]                         base::local({
[16:11:01.785]                           has_future <- base::requireNamespace("future", 
[16:11:01.785]                             quietly = TRUE)
[16:11:01.785]                           if (has_future) {
[16:11:01.785]                             ns <- base::getNamespace("future")
[16:11:01.785]                             version <- ns[[".package"]][["version"]]
[16:11:01.785]                             if (is.null(version)) 
[16:11:01.785]                               version <- utils::packageVersion("future")
[16:11:01.785]                           }
[16:11:01.785]                           else {
[16:11:01.785]                             version <- NULL
[16:11:01.785]                           }
[16:11:01.785]                           if (!has_future || version < "1.8.0") {
[16:11:01.785]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.785]                               "", base::R.version$version.string), 
[16:11:01.785]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.785]                                 base::R.version$platform, 8 * 
[16:11:01.785]                                   base::.Machine$sizeof.pointer), 
[16:11:01.785]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.785]                                 "release", "version")], collapse = " "), 
[16:11:01.785]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.785]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.785]                               info)
[16:11:01.785]                             info <- base::paste(info, collapse = "; ")
[16:11:01.785]                             if (!has_future) {
[16:11:01.785]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.785]                                 info)
[16:11:01.785]                             }
[16:11:01.785]                             else {
[16:11:01.785]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.785]                                 info, version)
[16:11:01.785]                             }
[16:11:01.785]                             base::stop(msg)
[16:11:01.785]                           }
[16:11:01.785]                         })
[16:11:01.785]                       }
[16:11:01.785]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.785]                       base::options(mc.cores = 1L)
[16:11:01.785]                     }
[16:11:01.785]                     base::local({
[16:11:01.785]                       for (pkg in "stats") {
[16:11:01.785]                         base::loadNamespace(pkg)
[16:11:01.785]                         base::library(pkg, character.only = TRUE)
[16:11:01.785]                       }
[16:11:01.785]                     })
[16:11:01.785]                   }
[16:11:01.785]                   options(future.plan = NULL)
[16:11:01.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.785]                 }
[16:11:01.785]                 ...future.workdir <- getwd()
[16:11:01.785]             }
[16:11:01.785]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.785]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.785]         }
[16:11:01.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.785]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:11:01.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.785]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.785]             base::names(...future.oldOptions))
[16:11:01.785]     }
[16:11:01.785]     if (FALSE) {
[16:11:01.785]     }
[16:11:01.785]     else {
[16:11:01.785]         if (TRUE) {
[16:11:01.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.785]                 open = "w")
[16:11:01.785]         }
[16:11:01.785]         else {
[16:11:01.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.785]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.785]         }
[16:11:01.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.785]             base::sink(type = "output", split = FALSE)
[16:11:01.785]             base::close(...future.stdout)
[16:11:01.785]         }, add = TRUE)
[16:11:01.785]     }
[16:11:01.785]     ...future.frame <- base::sys.nframe()
[16:11:01.785]     ...future.conditions <- base::list()
[16:11:01.785]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.785]     if (FALSE) {
[16:11:01.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.785]     }
[16:11:01.785]     ...future.result <- base::tryCatch({
[16:11:01.785]         base::withCallingHandlers({
[16:11:01.785]             ...future.value <- base::withVisible(base::local({
[16:11:01.785]                 withCallingHandlers({
[16:11:01.785]                   {
[16:11:01.785]                     do.call(function(...) {
[16:11:01.785]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.785]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.785]                         ...future.globals.maxSize)) {
[16:11:01.785]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.785]                         on.exit(options(oopts), add = TRUE)
[16:11:01.785]                       }
[16:11:01.785]                       {
[16:11:01.785]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.785]                           FUN = function(jj) {
[16:11:01.785]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.785]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.785]                           })
[16:11:01.785]                       }
[16:11:01.785]                     }, args = future.call.arguments)
[16:11:01.785]                   }
[16:11:01.785]                 }, immediateCondition = function(cond) {
[16:11:01.785]                   save_rds <- function (object, pathname, ...) 
[16:11:01.785]                   {
[16:11:01.785]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.785]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.785]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.785]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.785]                         fi_tmp[["mtime"]])
[16:11:01.785]                     }
[16:11:01.785]                     tryCatch({
[16:11:01.785]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.785]                     }, error = function(ex) {
[16:11:01.785]                       msg <- conditionMessage(ex)
[16:11:01.785]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.785]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.785]                         fi_tmp[["mtime"]], msg)
[16:11:01.785]                       ex$message <- msg
[16:11:01.785]                       stop(ex)
[16:11:01.785]                     })
[16:11:01.785]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.785]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.785]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.785]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.785]                       fi <- file.info(pathname)
[16:11:01.785]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.785]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.785]                         fi[["size"]], fi[["mtime"]])
[16:11:01.785]                       stop(msg)
[16:11:01.785]                     }
[16:11:01.785]                     invisible(pathname)
[16:11:01.785]                   }
[16:11:01.785]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.785]                     rootPath = tempdir()) 
[16:11:01.785]                   {
[16:11:01.785]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.785]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.785]                       tmpdir = path, fileext = ".rds")
[16:11:01.785]                     save_rds(obj, file)
[16:11:01.785]                   }
[16:11:01.785]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.785]                   {
[16:11:01.785]                     inherits <- base::inherits
[16:11:01.785]                     invokeRestart <- base::invokeRestart
[16:11:01.785]                     is.null <- base::is.null
[16:11:01.785]                     muffled <- FALSE
[16:11:01.785]                     if (inherits(cond, "message")) {
[16:11:01.785]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.785]                       if (muffled) 
[16:11:01.785]                         invokeRestart("muffleMessage")
[16:11:01.785]                     }
[16:11:01.785]                     else if (inherits(cond, "warning")) {
[16:11:01.785]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.785]                       if (muffled) 
[16:11:01.785]                         invokeRestart("muffleWarning")
[16:11:01.785]                     }
[16:11:01.785]                     else if (inherits(cond, "condition")) {
[16:11:01.785]                       if (!is.null(pattern)) {
[16:11:01.785]                         computeRestarts <- base::computeRestarts
[16:11:01.785]                         grepl <- base::grepl
[16:11:01.785]                         restarts <- computeRestarts(cond)
[16:11:01.785]                         for (restart in restarts) {
[16:11:01.785]                           name <- restart$name
[16:11:01.785]                           if (is.null(name)) 
[16:11:01.785]                             next
[16:11:01.785]                           if (!grepl(pattern, name)) 
[16:11:01.785]                             next
[16:11:01.785]                           invokeRestart(restart)
[16:11:01.785]                           muffled <- TRUE
[16:11:01.785]                           break
[16:11:01.785]                         }
[16:11:01.785]                       }
[16:11:01.785]                     }
[16:11:01.785]                     invisible(muffled)
[16:11:01.785]                   }
[16:11:01.785]                   muffleCondition(cond)
[16:11:01.785]                 })
[16:11:01.785]             }))
[16:11:01.785]             future::FutureResult(value = ...future.value$value, 
[16:11:01.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.785]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.785]                     ...future.globalenv.names))
[16:11:01.785]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.785]         }, condition = base::local({
[16:11:01.785]             c <- base::c
[16:11:01.785]             inherits <- base::inherits
[16:11:01.785]             invokeRestart <- base::invokeRestart
[16:11:01.785]             length <- base::length
[16:11:01.785]             list <- base::list
[16:11:01.785]             seq.int <- base::seq.int
[16:11:01.785]             signalCondition <- base::signalCondition
[16:11:01.785]             sys.calls <- base::sys.calls
[16:11:01.785]             `[[` <- base::`[[`
[16:11:01.785]             `+` <- base::`+`
[16:11:01.785]             `<<-` <- base::`<<-`
[16:11:01.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.785]                   3L)]
[16:11:01.785]             }
[16:11:01.785]             function(cond) {
[16:11:01.785]                 is_error <- inherits(cond, "error")
[16:11:01.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.785]                   NULL)
[16:11:01.785]                 if (is_error) {
[16:11:01.785]                   sessionInformation <- function() {
[16:11:01.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.785]                       search = base::search(), system = base::Sys.info())
[16:11:01.785]                   }
[16:11:01.785]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.785]                     cond$call), session = sessionInformation(), 
[16:11:01.785]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.785]                   signalCondition(cond)
[16:11:01.785]                 }
[16:11:01.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.785]                 "immediateCondition"))) {
[16:11:01.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.785]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.785]                   if (TRUE && !signal) {
[16:11:01.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.785]                     {
[16:11:01.785]                       inherits <- base::inherits
[16:11:01.785]                       invokeRestart <- base::invokeRestart
[16:11:01.785]                       is.null <- base::is.null
[16:11:01.785]                       muffled <- FALSE
[16:11:01.785]                       if (inherits(cond, "message")) {
[16:11:01.785]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.785]                         if (muffled) 
[16:11:01.785]                           invokeRestart("muffleMessage")
[16:11:01.785]                       }
[16:11:01.785]                       else if (inherits(cond, "warning")) {
[16:11:01.785]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.785]                         if (muffled) 
[16:11:01.785]                           invokeRestart("muffleWarning")
[16:11:01.785]                       }
[16:11:01.785]                       else if (inherits(cond, "condition")) {
[16:11:01.785]                         if (!is.null(pattern)) {
[16:11:01.785]                           computeRestarts <- base::computeRestarts
[16:11:01.785]                           grepl <- base::grepl
[16:11:01.785]                           restarts <- computeRestarts(cond)
[16:11:01.785]                           for (restart in restarts) {
[16:11:01.785]                             name <- restart$name
[16:11:01.785]                             if (is.null(name)) 
[16:11:01.785]                               next
[16:11:01.785]                             if (!grepl(pattern, name)) 
[16:11:01.785]                               next
[16:11:01.785]                             invokeRestart(restart)
[16:11:01.785]                             muffled <- TRUE
[16:11:01.785]                             break
[16:11:01.785]                           }
[16:11:01.785]                         }
[16:11:01.785]                       }
[16:11:01.785]                       invisible(muffled)
[16:11:01.785]                     }
[16:11:01.785]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.785]                   }
[16:11:01.785]                 }
[16:11:01.785]                 else {
[16:11:01.785]                   if (TRUE) {
[16:11:01.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.785]                     {
[16:11:01.785]                       inherits <- base::inherits
[16:11:01.785]                       invokeRestart <- base::invokeRestart
[16:11:01.785]                       is.null <- base::is.null
[16:11:01.785]                       muffled <- FALSE
[16:11:01.785]                       if (inherits(cond, "message")) {
[16:11:01.785]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.785]                         if (muffled) 
[16:11:01.785]                           invokeRestart("muffleMessage")
[16:11:01.785]                       }
[16:11:01.785]                       else if (inherits(cond, "warning")) {
[16:11:01.785]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.785]                         if (muffled) 
[16:11:01.785]                           invokeRestart("muffleWarning")
[16:11:01.785]                       }
[16:11:01.785]                       else if (inherits(cond, "condition")) {
[16:11:01.785]                         if (!is.null(pattern)) {
[16:11:01.785]                           computeRestarts <- base::computeRestarts
[16:11:01.785]                           grepl <- base::grepl
[16:11:01.785]                           restarts <- computeRestarts(cond)
[16:11:01.785]                           for (restart in restarts) {
[16:11:01.785]                             name <- restart$name
[16:11:01.785]                             if (is.null(name)) 
[16:11:01.785]                               next
[16:11:01.785]                             if (!grepl(pattern, name)) 
[16:11:01.785]                               next
[16:11:01.785]                             invokeRestart(restart)
[16:11:01.785]                             muffled <- TRUE
[16:11:01.785]                             break
[16:11:01.785]                           }
[16:11:01.785]                         }
[16:11:01.785]                       }
[16:11:01.785]                       invisible(muffled)
[16:11:01.785]                     }
[16:11:01.785]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.785]                   }
[16:11:01.785]                 }
[16:11:01.785]             }
[16:11:01.785]         }))
[16:11:01.785]     }, error = function(ex) {
[16:11:01.785]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.785]                 ...future.rng), started = ...future.startTime, 
[16:11:01.785]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.785]             version = "1.8"), class = "FutureResult")
[16:11:01.785]     }, finally = {
[16:11:01.785]         if (!identical(...future.workdir, getwd())) 
[16:11:01.785]             setwd(...future.workdir)
[16:11:01.785]         {
[16:11:01.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.785]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.785]             }
[16:11:01.785]             base::options(...future.oldOptions)
[16:11:01.785]             if (.Platform$OS.type == "windows") {
[16:11:01.785]                 old_names <- names(...future.oldEnvVars)
[16:11:01.785]                 envs <- base::Sys.getenv()
[16:11:01.785]                 names <- names(envs)
[16:11:01.785]                 common <- intersect(names, old_names)
[16:11:01.785]                 added <- setdiff(names, old_names)
[16:11:01.785]                 removed <- setdiff(old_names, names)
[16:11:01.785]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.785]                   envs[common]]
[16:11:01.785]                 NAMES <- toupper(changed)
[16:11:01.785]                 args <- list()
[16:11:01.785]                 for (kk in seq_along(NAMES)) {
[16:11:01.785]                   name <- changed[[kk]]
[16:11:01.785]                   NAME <- NAMES[[kk]]
[16:11:01.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.785]                     next
[16:11:01.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.785]                 }
[16:11:01.785]                 NAMES <- toupper(added)
[16:11:01.785]                 for (kk in seq_along(NAMES)) {
[16:11:01.785]                   name <- added[[kk]]
[16:11:01.785]                   NAME <- NAMES[[kk]]
[16:11:01.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.785]                     next
[16:11:01.785]                   args[[name]] <- ""
[16:11:01.785]                 }
[16:11:01.785]                 NAMES <- toupper(removed)
[16:11:01.785]                 for (kk in seq_along(NAMES)) {
[16:11:01.785]                   name <- removed[[kk]]
[16:11:01.785]                   NAME <- NAMES[[kk]]
[16:11:01.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.785]                     next
[16:11:01.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.785]                 }
[16:11:01.785]                 if (length(args) > 0) 
[16:11:01.785]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.785]             }
[16:11:01.785]             else {
[16:11:01.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.785]             }
[16:11:01.785]             {
[16:11:01.785]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.785]                   0L) {
[16:11:01.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.785]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.785]                   base::options(opts)
[16:11:01.785]                 }
[16:11:01.785]                 {
[16:11:01.785]                   {
[16:11:01.785]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.785]                     NULL
[16:11:01.785]                   }
[16:11:01.785]                   options(future.plan = NULL)
[16:11:01.785]                   if (is.na(NA_character_)) 
[16:11:01.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.785]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.785]                     envir = parent.frame()) 
[16:11:01.785]                   {
[16:11:01.785]                     default_workers <- missing(workers)
[16:11:01.785]                     if (is.function(workers)) 
[16:11:01.785]                       workers <- workers()
[16:11:01.785]                     workers <- structure(as.integer(workers), 
[16:11:01.785]                       class = class(workers))
[16:11:01.785]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.785]                       1L)
[16:11:01.785]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.785]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.785]                       if (default_workers) 
[16:11:01.785]                         supportsMulticore(warn = TRUE)
[16:11:01.785]                       return(sequential(..., envir = envir))
[16:11:01.785]                     }
[16:11:01.785]                     oopts <- options(mc.cores = workers)
[16:11:01.785]                     on.exit(options(oopts))
[16:11:01.785]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.785]                       envir = envir)
[16:11:01.785]                     if (!future$lazy) 
[16:11:01.785]                       future <- run(future)
[16:11:01.785]                     invisible(future)
[16:11:01.785]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.785]                 }
[16:11:01.785]             }
[16:11:01.785]         }
[16:11:01.785]     })
[16:11:01.785]     if (TRUE) {
[16:11:01.785]         base::sink(type = "output", split = FALSE)
[16:11:01.785]         if (TRUE) {
[16:11:01.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.785]         }
[16:11:01.785]         else {
[16:11:01.785]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.785]         }
[16:11:01.785]         base::close(...future.stdout)
[16:11:01.785]         ...future.stdout <- NULL
[16:11:01.785]     }
[16:11:01.785]     ...future.result$conditions <- ...future.conditions
[16:11:01.785]     ...future.result$finished <- base::Sys.time()
[16:11:01.785]     ...future.result
[16:11:01.785] }
[16:11:01.789] assign_globals() ...
[16:11:01.789] List of 5
[16:11:01.789]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[16:11:01.789]  $ future.call.arguments    : list()
[16:11:01.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.789]  $ ...future.elements_ii    :List of 3
[16:11:01.789]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:11:01.789]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:11:01.789]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:11:01.789]  $ ...future.seeds_ii       : NULL
[16:11:01.789]  $ ...future.globals.maxSize: NULL
[16:11:01.789]  - attr(*, "resolved")= logi FALSE
[16:11:01.789]  - attr(*, "total_size")= num 46960
[16:11:01.789]  - attr(*, "where")=List of 5
[16:11:01.789]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.789]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.789]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.789]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.789]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.789]  - attr(*, "already-done")= logi TRUE
[16:11:01.800] - copied ‘...future.FUN’ to environment
[16:11:01.801] - copied ‘future.call.arguments’ to environment
[16:11:01.801] - copied ‘...future.elements_ii’ to environment
[16:11:01.801] - copied ‘...future.seeds_ii’ to environment
[16:11:01.801] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.801] assign_globals() ... done
[16:11:01.801] requestCore(): workers = 2
[16:11:01.804] MulticoreFuture started
[16:11:01.805] - Launch lazy future ... done
[16:11:01.805] run() for ‘MulticoreFuture’ ... done
[16:11:01.806] Created future:
[16:11:01.806] plan(): Setting new future strategy stack:
[16:11:01.807] List of future strategies:
[16:11:01.807] 1. sequential:
[16:11:01.807]    - args: function (..., envir = parent.frame())
[16:11:01.807]    - tweaked: FALSE
[16:11:01.807]    - call: NULL
[16:11:01.809] plan(): nbrOfWorkers() = 1
[16:11:01.812] plan(): Setting new future strategy stack:
[16:11:01.813] List of future strategies:
[16:11:01.813] 1. multicore:
[16:11:01.813]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.813]    - tweaked: FALSE
[16:11:01.813]    - call: plan(strategy)
[16:11:01.820] plan(): nbrOfWorkers() = 2
[16:11:01.807] MulticoreFuture:
[16:11:01.807] Label: ‘future_sapply-2’
[16:11:01.807] Expression:
[16:11:01.807] {
[16:11:01.807]     do.call(function(...) {
[16:11:01.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.807]             on.exit(options(oopts), add = TRUE)
[16:11:01.807]         }
[16:11:01.807]         {
[16:11:01.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.807]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.807]             })
[16:11:01.807]         }
[16:11:01.807]     }, args = future.call.arguments)
[16:11:01.807] }
[16:11:01.807] Lazy evaluation: FALSE
[16:11:01.807] Asynchronous evaluation: TRUE
[16:11:01.807] Local evaluation: TRUE
[16:11:01.807] Environment: R_GlobalEnv
[16:11:01.807] Capture standard output: TRUE
[16:11:01.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.807] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:01.807] Packages: 1 packages (‘stats’)
[16:11:01.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.807] Resolved: TRUE
[16:11:01.807] Value: <not collected>
[16:11:01.807] Conditions captured: <none>
[16:11:01.807] Early signaling: FALSE
[16:11:01.807] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.807] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.822] Chunk #2 of 2 ... DONE
[16:11:01.822] Launching 2 futures (chunks) ... DONE
[16:11:01.823] Resolving 2 futures (chunks) ...
[16:11:01.823] resolve() on list ...
[16:11:01.823]  recursive: 0
[16:11:01.824]  length: 2
[16:11:01.824] 
[16:11:01.825] Future #1
[16:11:01.826] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:01.826] - nx: 2
[16:11:01.827] - relay: TRUE
[16:11:01.827] - stdout: TRUE
[16:11:01.827] - signal: TRUE
[16:11:01.827] - resignal: FALSE
[16:11:01.827] - force: TRUE
[16:11:01.828] - relayed: [n=2] FALSE, FALSE
[16:11:01.828] - queued futures: [n=2] FALSE, FALSE
[16:11:01.828]  - until=1
[16:11:01.829]  - relaying element #1
[16:11:01.829] - relayed: [n=2] TRUE, FALSE
[16:11:01.830] - queued futures: [n=2] TRUE, FALSE
[16:11:01.830] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:01.831]  length: 1 (resolved future 1)
[16:11:01.831] Future #2
[16:11:01.833] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:01.833] - nx: 2
[16:11:01.833] - relay: TRUE
[16:11:01.833] - stdout: TRUE
[16:11:01.834] - signal: TRUE
[16:11:01.834] - resignal: FALSE
[16:11:01.834] - force: TRUE
[16:11:01.834] - relayed: [n=2] TRUE, FALSE
[16:11:01.834] - queued futures: [n=2] TRUE, FALSE
[16:11:01.835]  - until=2
[16:11:01.835]  - relaying element #2
[16:11:01.835] - relayed: [n=2] TRUE, TRUE
[16:11:01.836] - queued futures: [n=2] TRUE, TRUE
[16:11:01.836] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:01.836]  length: 0 (resolved future 2)
[16:11:01.836] Relaying remaining futures
[16:11:01.837] signalConditionsASAP(NULL, pos=0) ...
[16:11:01.837] - nx: 2
[16:11:01.837] - relay: TRUE
[16:11:01.837] - stdout: TRUE
[16:11:01.837] - signal: TRUE
[16:11:01.837] - resignal: FALSE
[16:11:01.838] - force: TRUE
[16:11:01.838] - relayed: [n=2] TRUE, TRUE
[16:11:01.838] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:01.838] - relayed: [n=2] TRUE, TRUE
[16:11:01.839] - queued futures: [n=2] TRUE, TRUE
[16:11:01.839] signalConditionsASAP(NULL, pos=0) ... done
[16:11:01.839] resolve() on list ... DONE
[16:11:01.839]  - Number of value chunks collected: 2
[16:11:01.840] Resolving 2 futures (chunks) ... DONE
[16:11:01.840] Reducing values from 2 chunks ...
[16:11:01.840]  - Number of values collected after concatenation: 7
[16:11:01.840]  - Number of values expected: 7
[16:11:01.840] Reducing values from 2 chunks ... DONE
[16:11:01.841] future_lapply() ... DONE
[16:11:01.842] future_lapply() ...
[16:11:01.850] Number of chunks: 2
[16:11:01.851] getGlobalsAndPackagesXApply() ...
[16:11:01.851]  - future.globals: TRUE
[16:11:01.851] getGlobalsAndPackages() ...
[16:11:01.851] Searching for globals...
[16:11:01.862] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:11:01.863] Searching for globals ... DONE
[16:11:01.863] Resolving globals: FALSE
[16:11:01.864] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:11:01.864] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:11:01.865] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.865] - packages: [2] ‘stats’, ‘future.apply’
[16:11:01.865] getGlobalsAndPackages() ... DONE
[16:11:01.865]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:01.865]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:11:01.865] Finding globals ... DONE
[16:11:01.865]  - use_args: TRUE
[16:11:01.865]  - Getting '...' globals ...
[16:11:01.866] resolve() on list ...
[16:11:01.866]  recursive: 0
[16:11:01.866]  length: 1
[16:11:01.866]  elements: ‘...’
[16:11:01.866]  length: 0 (resolved future 1)
[16:11:01.866] resolve() on list ... DONE
[16:11:01.866]    - '...' content: [n=0] 
[16:11:01.866] List of 1
[16:11:01.866]  $ ...: list()
[16:11:01.866]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.866]  - attr(*, "where")=List of 1
[16:11:01.866]   ..$ ...:<environment: 0x561e88eccd28> 
[16:11:01.866]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.866]  - attr(*, "resolved")= logi TRUE
[16:11:01.866]  - attr(*, "total_size")= num NA
[16:11:01.869]  - Getting '...' globals ... DONE
[16:11:01.869] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:01.869] List of 8
[16:11:01.869]  $ ...future.FUN:function (x, ...)  
[16:11:01.869]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:11:01.869]  $ times        : int 5
[16:11:01.869]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.869]  $ stop_if_not  :function (...)  
[16:11:01.869]  $ dim          : NULL
[16:11:01.869]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:01.869]  $ ...          : list()
[16:11:01.869]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.869]  - attr(*, "where")=List of 8
[16:11:01.869]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:01.869]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:01.869]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:01.869]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:01.869]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:01.869]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:01.869]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:01.869]   ..$ ...          :<environment: 0x561e88eccd28> 
[16:11:01.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.869]  - attr(*, "resolved")= logi FALSE
[16:11:01.869]  - attr(*, "total_size")= num 141240
[16:11:01.877] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:11:01.877] getGlobalsAndPackagesXApply() ... DONE
[16:11:01.877] Number of futures (= number of chunks): 2
[16:11:01.877] Launching 2 futures (chunks) ...
[16:11:01.877] Chunk #1 of 2 ...
[16:11:01.878]  - Finding globals in 'X' for chunk #1 ...
[16:11:01.878] getGlobalsAndPackages() ...
[16:11:01.878] Searching for globals...
[16:11:01.878] 
[16:11:01.878] Searching for globals ... DONE
[16:11:01.878] - globals: [0] <none>
[16:11:01.878] getGlobalsAndPackages() ... DONE
[16:11:01.878]    + additional globals found: [n=0] 
[16:11:01.879]    + additional namespaces needed: [n=0] 
[16:11:01.879]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:01.879]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[16:11:01.879]  - seeds: <none>
[16:11:01.879] getGlobalsAndPackages() ...
[16:11:01.879] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.879] Resolving globals: FALSE
[16:11:01.879] Tweak future expression to call with '...' arguments ...
[16:11:01.880] {
[16:11:01.880]     do.call(function(...) {
[16:11:01.880]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.880]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.880]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.880]             on.exit(options(oopts), add = TRUE)
[16:11:01.880]         }
[16:11:01.880]         {
[16:11:01.880]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.880]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.880]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.880]             })
[16:11:01.880]         }
[16:11:01.880]     }, args = future.call.arguments)
[16:11:01.880] }
[16:11:01.880] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.880] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.880] - packages: [2] ‘stats’, ‘future.apply’
[16:11:01.881] getGlobalsAndPackages() ... DONE
[16:11:01.881] run() for ‘Future’ ...
[16:11:01.881] - state: ‘created’
[16:11:01.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.885] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.885]   - Field: ‘label’
[16:11:01.885]   - Field: ‘local’
[16:11:01.885]   - Field: ‘owner’
[16:11:01.885]   - Field: ‘envir’
[16:11:01.886]   - Field: ‘workers’
[16:11:01.886]   - Field: ‘packages’
[16:11:01.886]   - Field: ‘gc’
[16:11:01.886]   - Field: ‘job’
[16:11:01.886]   - Field: ‘conditions’
[16:11:01.886]   - Field: ‘expr’
[16:11:01.886]   - Field: ‘uuid’
[16:11:01.886]   - Field: ‘seed’
[16:11:01.886]   - Field: ‘version’
[16:11:01.886]   - Field: ‘result’
[16:11:01.886]   - Field: ‘asynchronous’
[16:11:01.887]   - Field: ‘calls’
[16:11:01.887]   - Field: ‘globals’
[16:11:01.887]   - Field: ‘stdout’
[16:11:01.887]   - Field: ‘earlySignal’
[16:11:01.887]   - Field: ‘lazy’
[16:11:01.887]   - Field: ‘state’
[16:11:01.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.887] - Launch lazy future ...
[16:11:01.887] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:01.888] Packages needed by future strategies (n = 0): <none>
[16:11:01.888] {
[16:11:01.888]     {
[16:11:01.888]         {
[16:11:01.888]             ...future.startTime <- base::Sys.time()
[16:11:01.888]             {
[16:11:01.888]                 {
[16:11:01.888]                   {
[16:11:01.888]                     {
[16:11:01.888]                       {
[16:11:01.888]                         base::local({
[16:11:01.888]                           has_future <- base::requireNamespace("future", 
[16:11:01.888]                             quietly = TRUE)
[16:11:01.888]                           if (has_future) {
[16:11:01.888]                             ns <- base::getNamespace("future")
[16:11:01.888]                             version <- ns[[".package"]][["version"]]
[16:11:01.888]                             if (is.null(version)) 
[16:11:01.888]                               version <- utils::packageVersion("future")
[16:11:01.888]                           }
[16:11:01.888]                           else {
[16:11:01.888]                             version <- NULL
[16:11:01.888]                           }
[16:11:01.888]                           if (!has_future || version < "1.8.0") {
[16:11:01.888]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.888]                               "", base::R.version$version.string), 
[16:11:01.888]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.888]                                 base::R.version$platform, 8 * 
[16:11:01.888]                                   base::.Machine$sizeof.pointer), 
[16:11:01.888]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.888]                                 "release", "version")], collapse = " "), 
[16:11:01.888]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.888]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.888]                               info)
[16:11:01.888]                             info <- base::paste(info, collapse = "; ")
[16:11:01.888]                             if (!has_future) {
[16:11:01.888]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.888]                                 info)
[16:11:01.888]                             }
[16:11:01.888]                             else {
[16:11:01.888]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.888]                                 info, version)
[16:11:01.888]                             }
[16:11:01.888]                             base::stop(msg)
[16:11:01.888]                           }
[16:11:01.888]                         })
[16:11:01.888]                       }
[16:11:01.888]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.888]                       base::options(mc.cores = 1L)
[16:11:01.888]                     }
[16:11:01.888]                     base::local({
[16:11:01.888]                       for (pkg in c("stats", "future.apply")) {
[16:11:01.888]                         base::loadNamespace(pkg)
[16:11:01.888]                         base::library(pkg, character.only = TRUE)
[16:11:01.888]                       }
[16:11:01.888]                     })
[16:11:01.888]                   }
[16:11:01.888]                   options(future.plan = NULL)
[16:11:01.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.888]                 }
[16:11:01.888]                 ...future.workdir <- getwd()
[16:11:01.888]             }
[16:11:01.888]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.888]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.888]         }
[16:11:01.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.888]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[16:11:01.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.888]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.888]             base::names(...future.oldOptions))
[16:11:01.888]     }
[16:11:01.888]     if (FALSE) {
[16:11:01.888]     }
[16:11:01.888]     else {
[16:11:01.888]         if (TRUE) {
[16:11:01.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.888]                 open = "w")
[16:11:01.888]         }
[16:11:01.888]         else {
[16:11:01.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.888]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.888]         }
[16:11:01.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.888]             base::sink(type = "output", split = FALSE)
[16:11:01.888]             base::close(...future.stdout)
[16:11:01.888]         }, add = TRUE)
[16:11:01.888]     }
[16:11:01.888]     ...future.frame <- base::sys.nframe()
[16:11:01.888]     ...future.conditions <- base::list()
[16:11:01.888]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.888]     if (FALSE) {
[16:11:01.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.888]     }
[16:11:01.888]     ...future.result <- base::tryCatch({
[16:11:01.888]         base::withCallingHandlers({
[16:11:01.888]             ...future.value <- base::withVisible(base::local({
[16:11:01.888]                 withCallingHandlers({
[16:11:01.888]                   {
[16:11:01.888]                     do.call(function(...) {
[16:11:01.888]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.888]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.888]                         ...future.globals.maxSize)) {
[16:11:01.888]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.888]                         on.exit(options(oopts), add = TRUE)
[16:11:01.888]                       }
[16:11:01.888]                       {
[16:11:01.888]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.888]                           FUN = function(jj) {
[16:11:01.888]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.888]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.888]                           })
[16:11:01.888]                       }
[16:11:01.888]                     }, args = future.call.arguments)
[16:11:01.888]                   }
[16:11:01.888]                 }, immediateCondition = function(cond) {
[16:11:01.888]                   save_rds <- function (object, pathname, ...) 
[16:11:01.888]                   {
[16:11:01.888]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.888]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.888]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.888]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.888]                         fi_tmp[["mtime"]])
[16:11:01.888]                     }
[16:11:01.888]                     tryCatch({
[16:11:01.888]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.888]                     }, error = function(ex) {
[16:11:01.888]                       msg <- conditionMessage(ex)
[16:11:01.888]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.888]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.888]                         fi_tmp[["mtime"]], msg)
[16:11:01.888]                       ex$message <- msg
[16:11:01.888]                       stop(ex)
[16:11:01.888]                     })
[16:11:01.888]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.888]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.888]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.888]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.888]                       fi <- file.info(pathname)
[16:11:01.888]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.888]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.888]                         fi[["size"]], fi[["mtime"]])
[16:11:01.888]                       stop(msg)
[16:11:01.888]                     }
[16:11:01.888]                     invisible(pathname)
[16:11:01.888]                   }
[16:11:01.888]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.888]                     rootPath = tempdir()) 
[16:11:01.888]                   {
[16:11:01.888]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.888]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.888]                       tmpdir = path, fileext = ".rds")
[16:11:01.888]                     save_rds(obj, file)
[16:11:01.888]                   }
[16:11:01.888]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.888]                   {
[16:11:01.888]                     inherits <- base::inherits
[16:11:01.888]                     invokeRestart <- base::invokeRestart
[16:11:01.888]                     is.null <- base::is.null
[16:11:01.888]                     muffled <- FALSE
[16:11:01.888]                     if (inherits(cond, "message")) {
[16:11:01.888]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.888]                       if (muffled) 
[16:11:01.888]                         invokeRestart("muffleMessage")
[16:11:01.888]                     }
[16:11:01.888]                     else if (inherits(cond, "warning")) {
[16:11:01.888]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.888]                       if (muffled) 
[16:11:01.888]                         invokeRestart("muffleWarning")
[16:11:01.888]                     }
[16:11:01.888]                     else if (inherits(cond, "condition")) {
[16:11:01.888]                       if (!is.null(pattern)) {
[16:11:01.888]                         computeRestarts <- base::computeRestarts
[16:11:01.888]                         grepl <- base::grepl
[16:11:01.888]                         restarts <- computeRestarts(cond)
[16:11:01.888]                         for (restart in restarts) {
[16:11:01.888]                           name <- restart$name
[16:11:01.888]                           if (is.null(name)) 
[16:11:01.888]                             next
[16:11:01.888]                           if (!grepl(pattern, name)) 
[16:11:01.888]                             next
[16:11:01.888]                           invokeRestart(restart)
[16:11:01.888]                           muffled <- TRUE
[16:11:01.888]                           break
[16:11:01.888]                         }
[16:11:01.888]                       }
[16:11:01.888]                     }
[16:11:01.888]                     invisible(muffled)
[16:11:01.888]                   }
[16:11:01.888]                   muffleCondition(cond)
[16:11:01.888]                 })
[16:11:01.888]             }))
[16:11:01.888]             future::FutureResult(value = ...future.value$value, 
[16:11:01.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.888]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.888]                     ...future.globalenv.names))
[16:11:01.888]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.888]         }, condition = base::local({
[16:11:01.888]             c <- base::c
[16:11:01.888]             inherits <- base::inherits
[16:11:01.888]             invokeRestart <- base::invokeRestart
[16:11:01.888]             length <- base::length
[16:11:01.888]             list <- base::list
[16:11:01.888]             seq.int <- base::seq.int
[16:11:01.888]             signalCondition <- base::signalCondition
[16:11:01.888]             sys.calls <- base::sys.calls
[16:11:01.888]             `[[` <- base::`[[`
[16:11:01.888]             `+` <- base::`+`
[16:11:01.888]             `<<-` <- base::`<<-`
[16:11:01.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.888]                   3L)]
[16:11:01.888]             }
[16:11:01.888]             function(cond) {
[16:11:01.888]                 is_error <- inherits(cond, "error")
[16:11:01.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.888]                   NULL)
[16:11:01.888]                 if (is_error) {
[16:11:01.888]                   sessionInformation <- function() {
[16:11:01.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.888]                       search = base::search(), system = base::Sys.info())
[16:11:01.888]                   }
[16:11:01.888]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.888]                     cond$call), session = sessionInformation(), 
[16:11:01.888]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.888]                   signalCondition(cond)
[16:11:01.888]                 }
[16:11:01.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.888]                 "immediateCondition"))) {
[16:11:01.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.888]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.888]                   if (TRUE && !signal) {
[16:11:01.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.888]                     {
[16:11:01.888]                       inherits <- base::inherits
[16:11:01.888]                       invokeRestart <- base::invokeRestart
[16:11:01.888]                       is.null <- base::is.null
[16:11:01.888]                       muffled <- FALSE
[16:11:01.888]                       if (inherits(cond, "message")) {
[16:11:01.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.888]                         if (muffled) 
[16:11:01.888]                           invokeRestart("muffleMessage")
[16:11:01.888]                       }
[16:11:01.888]                       else if (inherits(cond, "warning")) {
[16:11:01.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.888]                         if (muffled) 
[16:11:01.888]                           invokeRestart("muffleWarning")
[16:11:01.888]                       }
[16:11:01.888]                       else if (inherits(cond, "condition")) {
[16:11:01.888]                         if (!is.null(pattern)) {
[16:11:01.888]                           computeRestarts <- base::computeRestarts
[16:11:01.888]                           grepl <- base::grepl
[16:11:01.888]                           restarts <- computeRestarts(cond)
[16:11:01.888]                           for (restart in restarts) {
[16:11:01.888]                             name <- restart$name
[16:11:01.888]                             if (is.null(name)) 
[16:11:01.888]                               next
[16:11:01.888]                             if (!grepl(pattern, name)) 
[16:11:01.888]                               next
[16:11:01.888]                             invokeRestart(restart)
[16:11:01.888]                             muffled <- TRUE
[16:11:01.888]                             break
[16:11:01.888]                           }
[16:11:01.888]                         }
[16:11:01.888]                       }
[16:11:01.888]                       invisible(muffled)
[16:11:01.888]                     }
[16:11:01.888]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.888]                   }
[16:11:01.888]                 }
[16:11:01.888]                 else {
[16:11:01.888]                   if (TRUE) {
[16:11:01.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.888]                     {
[16:11:01.888]                       inherits <- base::inherits
[16:11:01.888]                       invokeRestart <- base::invokeRestart
[16:11:01.888]                       is.null <- base::is.null
[16:11:01.888]                       muffled <- FALSE
[16:11:01.888]                       if (inherits(cond, "message")) {
[16:11:01.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.888]                         if (muffled) 
[16:11:01.888]                           invokeRestart("muffleMessage")
[16:11:01.888]                       }
[16:11:01.888]                       else if (inherits(cond, "warning")) {
[16:11:01.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.888]                         if (muffled) 
[16:11:01.888]                           invokeRestart("muffleWarning")
[16:11:01.888]                       }
[16:11:01.888]                       else if (inherits(cond, "condition")) {
[16:11:01.888]                         if (!is.null(pattern)) {
[16:11:01.888]                           computeRestarts <- base::computeRestarts
[16:11:01.888]                           grepl <- base::grepl
[16:11:01.888]                           restarts <- computeRestarts(cond)
[16:11:01.888]                           for (restart in restarts) {
[16:11:01.888]                             name <- restart$name
[16:11:01.888]                             if (is.null(name)) 
[16:11:01.888]                               next
[16:11:01.888]                             if (!grepl(pattern, name)) 
[16:11:01.888]                               next
[16:11:01.888]                             invokeRestart(restart)
[16:11:01.888]                             muffled <- TRUE
[16:11:01.888]                             break
[16:11:01.888]                           }
[16:11:01.888]                         }
[16:11:01.888]                       }
[16:11:01.888]                       invisible(muffled)
[16:11:01.888]                     }
[16:11:01.888]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.888]                   }
[16:11:01.888]                 }
[16:11:01.888]             }
[16:11:01.888]         }))
[16:11:01.888]     }, error = function(ex) {
[16:11:01.888]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.888]                 ...future.rng), started = ...future.startTime, 
[16:11:01.888]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.888]             version = "1.8"), class = "FutureResult")
[16:11:01.888]     }, finally = {
[16:11:01.888]         if (!identical(...future.workdir, getwd())) 
[16:11:01.888]             setwd(...future.workdir)
[16:11:01.888]         {
[16:11:01.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.888]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.888]             }
[16:11:01.888]             base::options(...future.oldOptions)
[16:11:01.888]             if (.Platform$OS.type == "windows") {
[16:11:01.888]                 old_names <- names(...future.oldEnvVars)
[16:11:01.888]                 envs <- base::Sys.getenv()
[16:11:01.888]                 names <- names(envs)
[16:11:01.888]                 common <- intersect(names, old_names)
[16:11:01.888]                 added <- setdiff(names, old_names)
[16:11:01.888]                 removed <- setdiff(old_names, names)
[16:11:01.888]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.888]                   envs[common]]
[16:11:01.888]                 NAMES <- toupper(changed)
[16:11:01.888]                 args <- list()
[16:11:01.888]                 for (kk in seq_along(NAMES)) {
[16:11:01.888]                   name <- changed[[kk]]
[16:11:01.888]                   NAME <- NAMES[[kk]]
[16:11:01.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.888]                     next
[16:11:01.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.888]                 }
[16:11:01.888]                 NAMES <- toupper(added)
[16:11:01.888]                 for (kk in seq_along(NAMES)) {
[16:11:01.888]                   name <- added[[kk]]
[16:11:01.888]                   NAME <- NAMES[[kk]]
[16:11:01.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.888]                     next
[16:11:01.888]                   args[[name]] <- ""
[16:11:01.888]                 }
[16:11:01.888]                 NAMES <- toupper(removed)
[16:11:01.888]                 for (kk in seq_along(NAMES)) {
[16:11:01.888]                   name <- removed[[kk]]
[16:11:01.888]                   NAME <- NAMES[[kk]]
[16:11:01.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.888]                     next
[16:11:01.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.888]                 }
[16:11:01.888]                 if (length(args) > 0) 
[16:11:01.888]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.888]             }
[16:11:01.888]             else {
[16:11:01.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.888]             }
[16:11:01.888]             {
[16:11:01.888]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.888]                   0L) {
[16:11:01.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.888]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.888]                   base::options(opts)
[16:11:01.888]                 }
[16:11:01.888]                 {
[16:11:01.888]                   {
[16:11:01.888]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.888]                     NULL
[16:11:01.888]                   }
[16:11:01.888]                   options(future.plan = NULL)
[16:11:01.888]                   if (is.na(NA_character_)) 
[16:11:01.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.888]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.888]                     envir = parent.frame()) 
[16:11:01.888]                   {
[16:11:01.888]                     default_workers <- missing(workers)
[16:11:01.888]                     if (is.function(workers)) 
[16:11:01.888]                       workers <- workers()
[16:11:01.888]                     workers <- structure(as.integer(workers), 
[16:11:01.888]                       class = class(workers))
[16:11:01.888]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.888]                       1L)
[16:11:01.888]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.888]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.888]                       if (default_workers) 
[16:11:01.888]                         supportsMulticore(warn = TRUE)
[16:11:01.888]                       return(sequential(..., envir = envir))
[16:11:01.888]                     }
[16:11:01.888]                     oopts <- options(mc.cores = workers)
[16:11:01.888]                     on.exit(options(oopts))
[16:11:01.888]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.888]                       envir = envir)
[16:11:01.888]                     if (!future$lazy) 
[16:11:01.888]                       future <- run(future)
[16:11:01.888]                     invisible(future)
[16:11:01.888]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.888]                 }
[16:11:01.888]             }
[16:11:01.888]         }
[16:11:01.888]     })
[16:11:01.888]     if (TRUE) {
[16:11:01.888]         base::sink(type = "output", split = FALSE)
[16:11:01.888]         if (TRUE) {
[16:11:01.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.888]         }
[16:11:01.888]         else {
[16:11:01.888]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.888]         }
[16:11:01.888]         base::close(...future.stdout)
[16:11:01.888]         ...future.stdout <- NULL
[16:11:01.888]     }
[16:11:01.888]     ...future.result$conditions <- ...future.conditions
[16:11:01.888]     ...future.result$finished <- base::Sys.time()
[16:11:01.888]     ...future.result
[16:11:01.888] }
[16:11:01.891] assign_globals() ...
[16:11:01.891] List of 11
[16:11:01.891]  $ ...future.FUN            :function (x, ...)  
[16:11:01.891]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:11:01.891]  $ times                    : int 5
[16:11:01.891]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.891]  $ stop_if_not              :function (...)  
[16:11:01.891]  $ dim                      : NULL
[16:11:01.891]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.891]  $ future.call.arguments    : list()
[16:11:01.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.891]  $ ...future.elements_ii    :List of 4
[16:11:01.891]   ..$ : int [1:3] 1 2 3
[16:11:01.891]   ..$ : int [1:4] 1 2 3 4
[16:11:01.891]   ..$ : int [1:5] 1 2 3 4 5
[16:11:01.891]   ..$ : int [1:6] 1 2 3 4 5 6
[16:11:01.891]  $ ...future.seeds_ii       : NULL
[16:11:01.891]  $ ...future.globals.maxSize: NULL
[16:11:01.891]  - attr(*, "resolved")= logi FALSE
[16:11:01.891]  - attr(*, "total_size")= num 141240
[16:11:01.891]  - attr(*, "where")=List of 11
[16:11:01.891]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.891]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.891]  - attr(*, "already-done")= logi TRUE
[16:11:01.902] - copied ‘...future.FUN’ to environment
[16:11:01.902] - copied ‘x_FUN’ to environment
[16:11:01.902] - copied ‘times’ to environment
[16:11:01.902] - copied ‘stopf’ to environment
[16:11:01.902] - copied ‘stop_if_not’ to environment
[16:11:01.902] - copied ‘dim’ to environment
[16:11:01.902] - copied ‘valid_types’ to environment
[16:11:01.902] - copied ‘future.call.arguments’ to environment
[16:11:01.902] - copied ‘...future.elements_ii’ to environment
[16:11:01.903] - copied ‘...future.seeds_ii’ to environment
[16:11:01.903] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.903] assign_globals() ... done
[16:11:01.903] requestCore(): workers = 2
[16:11:01.905] MulticoreFuture started
[16:11:01.906] - Launch lazy future ... done
[16:11:01.907] run() for ‘MulticoreFuture’ ... done
[16:11:01.907] Created future:
[16:11:01.908] plan(): Setting new future strategy stack:
[16:11:01.908] List of future strategies:
[16:11:01.908] 1. sequential:
[16:11:01.908]    - args: function (..., envir = parent.frame())
[16:11:01.908]    - tweaked: FALSE
[16:11:01.908]    - call: NULL
[16:11:01.909] plan(): nbrOfWorkers() = 1
[16:11:01.911] plan(): Setting new future strategy stack:
[16:11:01.912] List of future strategies:
[16:11:01.912] 1. multicore:
[16:11:01.912]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.912]    - tweaked: FALSE
[16:11:01.912]    - call: plan(strategy)
[16:11:01.918] plan(): nbrOfWorkers() = 2
[16:11:01.908] MulticoreFuture:
[16:11:01.908] Label: ‘future_vapply-1’
[16:11:01.908] Expression:
[16:11:01.908] {
[16:11:01.908]     do.call(function(...) {
[16:11:01.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.908]             on.exit(options(oopts), add = TRUE)
[16:11:01.908]         }
[16:11:01.908]         {
[16:11:01.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.908]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.908]             })
[16:11:01.908]         }
[16:11:01.908]     }, args = future.call.arguments)
[16:11:01.908] }
[16:11:01.908] Lazy evaluation: FALSE
[16:11:01.908] Asynchronous evaluation: TRUE
[16:11:01.908] Local evaluation: TRUE
[16:11:01.908] Environment: R_GlobalEnv
[16:11:01.908] Capture standard output: TRUE
[16:11:01.908] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.908] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.908] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:01.908] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.908] Resolved: TRUE
[16:11:01.908] Value: <not collected>
[16:11:01.908] Conditions captured: <none>
[16:11:01.908] Early signaling: FALSE
[16:11:01.908] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.908] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.919] Chunk #1 of 2 ... DONE
[16:11:01.919] Chunk #2 of 2 ...
[16:11:01.919]  - Finding globals in 'X' for chunk #2 ...
[16:11:01.920] getGlobalsAndPackages() ...
[16:11:01.920] Searching for globals...
[16:11:01.920] 
[16:11:01.920] Searching for globals ... DONE
[16:11:01.921] - globals: [0] <none>
[16:11:01.921] getGlobalsAndPackages() ... DONE
[16:11:01.921]    + additional globals found: [n=0] 
[16:11:01.921]    + additional namespaces needed: [n=0] 
[16:11:01.921]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:01.921]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:11:01.922]  - seeds: <none>
[16:11:01.922] getGlobalsAndPackages() ...
[16:11:01.922] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.922] Resolving globals: FALSE
[16:11:01.922] Tweak future expression to call with '...' arguments ...
[16:11:01.923] {
[16:11:01.923]     do.call(function(...) {
[16:11:01.923]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.923]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.923]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.923]             on.exit(options(oopts), add = TRUE)
[16:11:01.923]         }
[16:11:01.923]         {
[16:11:01.923]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.923]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.923]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.923]             })
[16:11:01.923]         }
[16:11:01.923]     }, args = future.call.arguments)
[16:11:01.923] }
[16:11:01.923] Tweak future expression to call with '...' arguments ... DONE
[16:11:01.924] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:01.924] - packages: [2] ‘stats’, ‘future.apply’
[16:11:01.925] getGlobalsAndPackages() ... DONE
[16:11:01.925] run() for ‘Future’ ...
[16:11:01.925] - state: ‘created’
[16:11:01.926] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:01.930] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.930] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:01.930]   - Field: ‘label’
[16:11:01.931]   - Field: ‘local’
[16:11:01.931]   - Field: ‘owner’
[16:11:01.931]   - Field: ‘envir’
[16:11:01.931]   - Field: ‘workers’
[16:11:01.931]   - Field: ‘packages’
[16:11:01.931]   - Field: ‘gc’
[16:11:01.931]   - Field: ‘job’
[16:11:01.932]   - Field: ‘conditions’
[16:11:01.932]   - Field: ‘expr’
[16:11:01.932]   - Field: ‘uuid’
[16:11:01.932]   - Field: ‘seed’
[16:11:01.932]   - Field: ‘version’
[16:11:01.932]   - Field: ‘result’
[16:11:01.933]   - Field: ‘asynchronous’
[16:11:01.933]   - Field: ‘calls’
[16:11:01.933]   - Field: ‘globals’
[16:11:01.933]   - Field: ‘stdout’
[16:11:01.933]   - Field: ‘earlySignal’
[16:11:01.933]   - Field: ‘lazy’
[16:11:01.933]   - Field: ‘state’
[16:11:01.933] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:01.934] - Launch lazy future ...
[16:11:01.934] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:01.934] Packages needed by future strategies (n = 0): <none>
[16:11:01.935] {
[16:11:01.935]     {
[16:11:01.935]         {
[16:11:01.935]             ...future.startTime <- base::Sys.time()
[16:11:01.935]             {
[16:11:01.935]                 {
[16:11:01.935]                   {
[16:11:01.935]                     {
[16:11:01.935]                       {
[16:11:01.935]                         base::local({
[16:11:01.935]                           has_future <- base::requireNamespace("future", 
[16:11:01.935]                             quietly = TRUE)
[16:11:01.935]                           if (has_future) {
[16:11:01.935]                             ns <- base::getNamespace("future")
[16:11:01.935]                             version <- ns[[".package"]][["version"]]
[16:11:01.935]                             if (is.null(version)) 
[16:11:01.935]                               version <- utils::packageVersion("future")
[16:11:01.935]                           }
[16:11:01.935]                           else {
[16:11:01.935]                             version <- NULL
[16:11:01.935]                           }
[16:11:01.935]                           if (!has_future || version < "1.8.0") {
[16:11:01.935]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:01.935]                               "", base::R.version$version.string), 
[16:11:01.935]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:01.935]                                 base::R.version$platform, 8 * 
[16:11:01.935]                                   base::.Machine$sizeof.pointer), 
[16:11:01.935]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:01.935]                                 "release", "version")], collapse = " "), 
[16:11:01.935]                               hostname = base::Sys.info()[["nodename"]])
[16:11:01.935]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:01.935]                               info)
[16:11:01.935]                             info <- base::paste(info, collapse = "; ")
[16:11:01.935]                             if (!has_future) {
[16:11:01.935]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:01.935]                                 info)
[16:11:01.935]                             }
[16:11:01.935]                             else {
[16:11:01.935]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:01.935]                                 info, version)
[16:11:01.935]                             }
[16:11:01.935]                             base::stop(msg)
[16:11:01.935]                           }
[16:11:01.935]                         })
[16:11:01.935]                       }
[16:11:01.935]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:01.935]                       base::options(mc.cores = 1L)
[16:11:01.935]                     }
[16:11:01.935]                     base::local({
[16:11:01.935]                       for (pkg in c("stats", "future.apply")) {
[16:11:01.935]                         base::loadNamespace(pkg)
[16:11:01.935]                         base::library(pkg, character.only = TRUE)
[16:11:01.935]                       }
[16:11:01.935]                     })
[16:11:01.935]                   }
[16:11:01.935]                   options(future.plan = NULL)
[16:11:01.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:01.935]                 }
[16:11:01.935]                 ...future.workdir <- getwd()
[16:11:01.935]             }
[16:11:01.935]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:01.935]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:01.935]         }
[16:11:01.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:01.935]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:11:01.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:01.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:01.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:01.935]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:01.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:01.935]             base::names(...future.oldOptions))
[16:11:01.935]     }
[16:11:01.935]     if (FALSE) {
[16:11:01.935]     }
[16:11:01.935]     else {
[16:11:01.935]         if (TRUE) {
[16:11:01.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:01.935]                 open = "w")
[16:11:01.935]         }
[16:11:01.935]         else {
[16:11:01.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:01.935]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:01.935]         }
[16:11:01.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:01.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:01.935]             base::sink(type = "output", split = FALSE)
[16:11:01.935]             base::close(...future.stdout)
[16:11:01.935]         }, add = TRUE)
[16:11:01.935]     }
[16:11:01.935]     ...future.frame <- base::sys.nframe()
[16:11:01.935]     ...future.conditions <- base::list()
[16:11:01.935]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:01.935]     if (FALSE) {
[16:11:01.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:01.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:01.935]     }
[16:11:01.935]     ...future.result <- base::tryCatch({
[16:11:01.935]         base::withCallingHandlers({
[16:11:01.935]             ...future.value <- base::withVisible(base::local({
[16:11:01.935]                 withCallingHandlers({
[16:11:01.935]                   {
[16:11:01.935]                     do.call(function(...) {
[16:11:01.935]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.935]                       if (!identical(...future.globals.maxSize.org, 
[16:11:01.935]                         ...future.globals.maxSize)) {
[16:11:01.935]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.935]                         on.exit(options(oopts), add = TRUE)
[16:11:01.935]                       }
[16:11:01.935]                       {
[16:11:01.935]                         lapply(seq_along(...future.elements_ii), 
[16:11:01.935]                           FUN = function(jj) {
[16:11:01.935]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.935]                             ...future.FUN(...future.X_jj, ...)
[16:11:01.935]                           })
[16:11:01.935]                       }
[16:11:01.935]                     }, args = future.call.arguments)
[16:11:01.935]                   }
[16:11:01.935]                 }, immediateCondition = function(cond) {
[16:11:01.935]                   save_rds <- function (object, pathname, ...) 
[16:11:01.935]                   {
[16:11:01.935]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:01.935]                     if (file_test("-f", pathname_tmp)) {
[16:11:01.935]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.935]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:01.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.935]                         fi_tmp[["mtime"]])
[16:11:01.935]                     }
[16:11:01.935]                     tryCatch({
[16:11:01.935]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:01.935]                     }, error = function(ex) {
[16:11:01.935]                       msg <- conditionMessage(ex)
[16:11:01.935]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.935]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:01.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.935]                         fi_tmp[["mtime"]], msg)
[16:11:01.935]                       ex$message <- msg
[16:11:01.935]                       stop(ex)
[16:11:01.935]                     })
[16:11:01.935]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:01.935]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:01.935]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:01.935]                       fi_tmp <- file.info(pathname_tmp)
[16:11:01.935]                       fi <- file.info(pathname)
[16:11:01.935]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:01.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:01.935]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:01.935]                         fi[["size"]], fi[["mtime"]])
[16:11:01.935]                       stop(msg)
[16:11:01.935]                     }
[16:11:01.935]                     invisible(pathname)
[16:11:01.935]                   }
[16:11:01.935]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:01.935]                     rootPath = tempdir()) 
[16:11:01.935]                   {
[16:11:01.935]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:01.935]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:01.935]                       tmpdir = path, fileext = ".rds")
[16:11:01.935]                     save_rds(obj, file)
[16:11:01.935]                   }
[16:11:01.935]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:01.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.935]                   {
[16:11:01.935]                     inherits <- base::inherits
[16:11:01.935]                     invokeRestart <- base::invokeRestart
[16:11:01.935]                     is.null <- base::is.null
[16:11:01.935]                     muffled <- FALSE
[16:11:01.935]                     if (inherits(cond, "message")) {
[16:11:01.935]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:01.935]                       if (muffled) 
[16:11:01.935]                         invokeRestart("muffleMessage")
[16:11:01.935]                     }
[16:11:01.935]                     else if (inherits(cond, "warning")) {
[16:11:01.935]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:01.935]                       if (muffled) 
[16:11:01.935]                         invokeRestart("muffleWarning")
[16:11:01.935]                     }
[16:11:01.935]                     else if (inherits(cond, "condition")) {
[16:11:01.935]                       if (!is.null(pattern)) {
[16:11:01.935]                         computeRestarts <- base::computeRestarts
[16:11:01.935]                         grepl <- base::grepl
[16:11:01.935]                         restarts <- computeRestarts(cond)
[16:11:01.935]                         for (restart in restarts) {
[16:11:01.935]                           name <- restart$name
[16:11:01.935]                           if (is.null(name)) 
[16:11:01.935]                             next
[16:11:01.935]                           if (!grepl(pattern, name)) 
[16:11:01.935]                             next
[16:11:01.935]                           invokeRestart(restart)
[16:11:01.935]                           muffled <- TRUE
[16:11:01.935]                           break
[16:11:01.935]                         }
[16:11:01.935]                       }
[16:11:01.935]                     }
[16:11:01.935]                     invisible(muffled)
[16:11:01.935]                   }
[16:11:01.935]                   muffleCondition(cond)
[16:11:01.935]                 })
[16:11:01.935]             }))
[16:11:01.935]             future::FutureResult(value = ...future.value$value, 
[16:11:01.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.935]                   ...future.rng), globalenv = if (FALSE) 
[16:11:01.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:01.935]                     ...future.globalenv.names))
[16:11:01.935]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:01.935]         }, condition = base::local({
[16:11:01.935]             c <- base::c
[16:11:01.935]             inherits <- base::inherits
[16:11:01.935]             invokeRestart <- base::invokeRestart
[16:11:01.935]             length <- base::length
[16:11:01.935]             list <- base::list
[16:11:01.935]             seq.int <- base::seq.int
[16:11:01.935]             signalCondition <- base::signalCondition
[16:11:01.935]             sys.calls <- base::sys.calls
[16:11:01.935]             `[[` <- base::`[[`
[16:11:01.935]             `+` <- base::`+`
[16:11:01.935]             `<<-` <- base::`<<-`
[16:11:01.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:01.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:01.935]                   3L)]
[16:11:01.935]             }
[16:11:01.935]             function(cond) {
[16:11:01.935]                 is_error <- inherits(cond, "error")
[16:11:01.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:01.935]                   NULL)
[16:11:01.935]                 if (is_error) {
[16:11:01.935]                   sessionInformation <- function() {
[16:11:01.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:01.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:01.935]                       search = base::search(), system = base::Sys.info())
[16:11:01.935]                   }
[16:11:01.935]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:01.935]                     cond$call), session = sessionInformation(), 
[16:11:01.935]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:01.935]                   signalCondition(cond)
[16:11:01.935]                 }
[16:11:01.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:01.935]                 "immediateCondition"))) {
[16:11:01.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:01.935]                   ...future.conditions[[length(...future.conditions) + 
[16:11:01.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:01.935]                   if (TRUE && !signal) {
[16:11:01.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.935]                     {
[16:11:01.935]                       inherits <- base::inherits
[16:11:01.935]                       invokeRestart <- base::invokeRestart
[16:11:01.935]                       is.null <- base::is.null
[16:11:01.935]                       muffled <- FALSE
[16:11:01.935]                       if (inherits(cond, "message")) {
[16:11:01.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.935]                         if (muffled) 
[16:11:01.935]                           invokeRestart("muffleMessage")
[16:11:01.935]                       }
[16:11:01.935]                       else if (inherits(cond, "warning")) {
[16:11:01.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.935]                         if (muffled) 
[16:11:01.935]                           invokeRestart("muffleWarning")
[16:11:01.935]                       }
[16:11:01.935]                       else if (inherits(cond, "condition")) {
[16:11:01.935]                         if (!is.null(pattern)) {
[16:11:01.935]                           computeRestarts <- base::computeRestarts
[16:11:01.935]                           grepl <- base::grepl
[16:11:01.935]                           restarts <- computeRestarts(cond)
[16:11:01.935]                           for (restart in restarts) {
[16:11:01.935]                             name <- restart$name
[16:11:01.935]                             if (is.null(name)) 
[16:11:01.935]                               next
[16:11:01.935]                             if (!grepl(pattern, name)) 
[16:11:01.935]                               next
[16:11:01.935]                             invokeRestart(restart)
[16:11:01.935]                             muffled <- TRUE
[16:11:01.935]                             break
[16:11:01.935]                           }
[16:11:01.935]                         }
[16:11:01.935]                       }
[16:11:01.935]                       invisible(muffled)
[16:11:01.935]                     }
[16:11:01.935]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.935]                   }
[16:11:01.935]                 }
[16:11:01.935]                 else {
[16:11:01.935]                   if (TRUE) {
[16:11:01.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:01.935]                     {
[16:11:01.935]                       inherits <- base::inherits
[16:11:01.935]                       invokeRestart <- base::invokeRestart
[16:11:01.935]                       is.null <- base::is.null
[16:11:01.935]                       muffled <- FALSE
[16:11:01.935]                       if (inherits(cond, "message")) {
[16:11:01.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:01.935]                         if (muffled) 
[16:11:01.935]                           invokeRestart("muffleMessage")
[16:11:01.935]                       }
[16:11:01.935]                       else if (inherits(cond, "warning")) {
[16:11:01.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:01.935]                         if (muffled) 
[16:11:01.935]                           invokeRestart("muffleWarning")
[16:11:01.935]                       }
[16:11:01.935]                       else if (inherits(cond, "condition")) {
[16:11:01.935]                         if (!is.null(pattern)) {
[16:11:01.935]                           computeRestarts <- base::computeRestarts
[16:11:01.935]                           grepl <- base::grepl
[16:11:01.935]                           restarts <- computeRestarts(cond)
[16:11:01.935]                           for (restart in restarts) {
[16:11:01.935]                             name <- restart$name
[16:11:01.935]                             if (is.null(name)) 
[16:11:01.935]                               next
[16:11:01.935]                             if (!grepl(pattern, name)) 
[16:11:01.935]                               next
[16:11:01.935]                             invokeRestart(restart)
[16:11:01.935]                             muffled <- TRUE
[16:11:01.935]                             break
[16:11:01.935]                           }
[16:11:01.935]                         }
[16:11:01.935]                       }
[16:11:01.935]                       invisible(muffled)
[16:11:01.935]                     }
[16:11:01.935]                     muffleCondition(cond, pattern = "^muffle")
[16:11:01.935]                   }
[16:11:01.935]                 }
[16:11:01.935]             }
[16:11:01.935]         }))
[16:11:01.935]     }, error = function(ex) {
[16:11:01.935]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:01.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:01.935]                 ...future.rng), started = ...future.startTime, 
[16:11:01.935]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:01.935]             version = "1.8"), class = "FutureResult")
[16:11:01.935]     }, finally = {
[16:11:01.935]         if (!identical(...future.workdir, getwd())) 
[16:11:01.935]             setwd(...future.workdir)
[16:11:01.935]         {
[16:11:01.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:01.935]                 ...future.oldOptions$nwarnings <- NULL
[16:11:01.935]             }
[16:11:01.935]             base::options(...future.oldOptions)
[16:11:01.935]             if (.Platform$OS.type == "windows") {
[16:11:01.935]                 old_names <- names(...future.oldEnvVars)
[16:11:01.935]                 envs <- base::Sys.getenv()
[16:11:01.935]                 names <- names(envs)
[16:11:01.935]                 common <- intersect(names, old_names)
[16:11:01.935]                 added <- setdiff(names, old_names)
[16:11:01.935]                 removed <- setdiff(old_names, names)
[16:11:01.935]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:01.935]                   envs[common]]
[16:11:01.935]                 NAMES <- toupper(changed)
[16:11:01.935]                 args <- list()
[16:11:01.935]                 for (kk in seq_along(NAMES)) {
[16:11:01.935]                   name <- changed[[kk]]
[16:11:01.935]                   NAME <- NAMES[[kk]]
[16:11:01.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.935]                     next
[16:11:01.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.935]                 }
[16:11:01.935]                 NAMES <- toupper(added)
[16:11:01.935]                 for (kk in seq_along(NAMES)) {
[16:11:01.935]                   name <- added[[kk]]
[16:11:01.935]                   NAME <- NAMES[[kk]]
[16:11:01.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.935]                     next
[16:11:01.935]                   args[[name]] <- ""
[16:11:01.935]                 }
[16:11:01.935]                 NAMES <- toupper(removed)
[16:11:01.935]                 for (kk in seq_along(NAMES)) {
[16:11:01.935]                   name <- removed[[kk]]
[16:11:01.935]                   NAME <- NAMES[[kk]]
[16:11:01.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:01.935]                     next
[16:11:01.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:01.935]                 }
[16:11:01.935]                 if (length(args) > 0) 
[16:11:01.935]                   base::do.call(base::Sys.setenv, args = args)
[16:11:01.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:01.935]             }
[16:11:01.935]             else {
[16:11:01.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:01.935]             }
[16:11:01.935]             {
[16:11:01.935]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:01.935]                   0L) {
[16:11:01.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:01.935]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:01.935]                   base::options(opts)
[16:11:01.935]                 }
[16:11:01.935]                 {
[16:11:01.935]                   {
[16:11:01.935]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:01.935]                     NULL
[16:11:01.935]                   }
[16:11:01.935]                   options(future.plan = NULL)
[16:11:01.935]                   if (is.na(NA_character_)) 
[16:11:01.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:01.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:01.935]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:01.935]                     envir = parent.frame()) 
[16:11:01.935]                   {
[16:11:01.935]                     default_workers <- missing(workers)
[16:11:01.935]                     if (is.function(workers)) 
[16:11:01.935]                       workers <- workers()
[16:11:01.935]                     workers <- structure(as.integer(workers), 
[16:11:01.935]                       class = class(workers))
[16:11:01.935]                     stop_if_not(is.finite(workers), workers >= 
[16:11:01.935]                       1L)
[16:11:01.935]                     if ((workers == 1L && !inherits(workers, 
[16:11:01.935]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:01.935]                       if (default_workers) 
[16:11:01.935]                         supportsMulticore(warn = TRUE)
[16:11:01.935]                       return(sequential(..., envir = envir))
[16:11:01.935]                     }
[16:11:01.935]                     oopts <- options(mc.cores = workers)
[16:11:01.935]                     on.exit(options(oopts))
[16:11:01.935]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:01.935]                       envir = envir)
[16:11:01.935]                     if (!future$lazy) 
[16:11:01.935]                       future <- run(future)
[16:11:01.935]                     invisible(future)
[16:11:01.935]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:01.935]                 }
[16:11:01.935]             }
[16:11:01.935]         }
[16:11:01.935]     })
[16:11:01.935]     if (TRUE) {
[16:11:01.935]         base::sink(type = "output", split = FALSE)
[16:11:01.935]         if (TRUE) {
[16:11:01.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:01.935]         }
[16:11:01.935]         else {
[16:11:01.935]             ...future.result["stdout"] <- base::list(NULL)
[16:11:01.935]         }
[16:11:01.935]         base::close(...future.stdout)
[16:11:01.935]         ...future.stdout <- NULL
[16:11:01.935]     }
[16:11:01.935]     ...future.result$conditions <- ...future.conditions
[16:11:01.935]     ...future.result$finished <- base::Sys.time()
[16:11:01.935]     ...future.result
[16:11:01.935] }
[16:11:01.939] assign_globals() ...
[16:11:01.939] List of 11
[16:11:01.939]  $ ...future.FUN            :function (x, ...)  
[16:11:01.939]  $ x_FUN                    :function (x, na.rm = TRUE)  
[16:11:01.939]  $ times                    : int 5
[16:11:01.939]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:01.939]  $ stop_if_not              :function (...)  
[16:11:01.939]  $ dim                      : NULL
[16:11:01.939]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:01.939]  $ future.call.arguments    : list()
[16:11:01.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.939]  $ ...future.elements_ii    :List of 3
[16:11:01.939]   ..$ : int [1:7] 1 2 3 4 5 6 7
[16:11:01.939]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[16:11:01.939]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[16:11:01.939]  $ ...future.seeds_ii       : NULL
[16:11:01.939]  $ ...future.globals.maxSize: NULL
[16:11:01.939]  - attr(*, "resolved")= logi FALSE
[16:11:01.939]  - attr(*, "total_size")= num 141240
[16:11:01.939]  - attr(*, "where")=List of 11
[16:11:01.939]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:01.939]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:01.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.939]  - attr(*, "already-done")= logi TRUE
[16:11:01.954] - copied ‘...future.FUN’ to environment
[16:11:01.954] - copied ‘x_FUN’ to environment
[16:11:01.954] - copied ‘times’ to environment
[16:11:01.955] - copied ‘stopf’ to environment
[16:11:01.955] - copied ‘stop_if_not’ to environment
[16:11:01.955] - copied ‘dim’ to environment
[16:11:01.955] - copied ‘valid_types’ to environment
[16:11:01.955] - copied ‘future.call.arguments’ to environment
[16:11:01.955] - copied ‘...future.elements_ii’ to environment
[16:11:01.955] - copied ‘...future.seeds_ii’ to environment
[16:11:01.955] - copied ‘...future.globals.maxSize’ to environment
[16:11:01.955] assign_globals() ... done
[16:11:01.955] requestCore(): workers = 2
[16:11:01.958] MulticoreFuture started
[16:11:01.958] - Launch lazy future ... done
[16:11:01.959] run() for ‘MulticoreFuture’ ... done
[16:11:01.959] Created future:
[16:11:01.959] plan(): Setting new future strategy stack:
[16:11:01.960] List of future strategies:
[16:11:01.960] 1. sequential:
[16:11:01.960]    - args: function (..., envir = parent.frame())
[16:11:01.960]    - tweaked: FALSE
[16:11:01.960]    - call: NULL
[16:11:01.961] plan(): nbrOfWorkers() = 1
[16:11:01.963] plan(): Setting new future strategy stack:
[16:11:01.963] List of future strategies:
[16:11:01.963] 1. multicore:
[16:11:01.963]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:01.963]    - tweaked: FALSE
[16:11:01.963]    - call: plan(strategy)
[16:11:01.968] plan(): nbrOfWorkers() = 2
[16:11:01.959] MulticoreFuture:
[16:11:01.959] Label: ‘future_vapply-2’
[16:11:01.959] Expression:
[16:11:01.959] {
[16:11:01.959]     do.call(function(...) {
[16:11:01.959]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:01.959]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:01.959]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:01.959]             on.exit(options(oopts), add = TRUE)
[16:11:01.959]         }
[16:11:01.959]         {
[16:11:01.959]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:01.959]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:01.959]                 ...future.FUN(...future.X_jj, ...)
[16:11:01.959]             })
[16:11:01.959]         }
[16:11:01.959]     }, args = future.call.arguments)
[16:11:01.959] }
[16:11:01.959] Lazy evaluation: FALSE
[16:11:01.959] Asynchronous evaluation: TRUE
[16:11:01.959] Local evaluation: TRUE
[16:11:01.959] Environment: R_GlobalEnv
[16:11:01.959] Capture standard output: TRUE
[16:11:01.959] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:01.959] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:01.959] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:01.959] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:01.959] Resolved: TRUE
[16:11:01.959] Value: <not collected>
[16:11:01.959] Conditions captured: <none>
[16:11:01.959] Early signaling: FALSE
[16:11:01.959] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:01.959] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:01.969] Chunk #2 of 2 ... DONE
[16:11:01.970] Launching 2 futures (chunks) ... DONE
[16:11:01.970] Resolving 2 futures (chunks) ...
[16:11:01.970] resolve() on list ...
[16:11:01.970]  recursive: 0
[16:11:01.970]  length: 2
[16:11:01.970] 
[16:11:01.971] Future #1
[16:11:01.972] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:01.972] - nx: 2
[16:11:01.972] - relay: TRUE
[16:11:01.972] - stdout: TRUE
[16:11:01.972] - signal: TRUE
[16:11:01.972] - resignal: FALSE
[16:11:01.973] - force: TRUE
[16:11:01.973] - relayed: [n=2] FALSE, FALSE
[16:11:01.973] - queued futures: [n=2] FALSE, FALSE
[16:11:01.973]  - until=1
[16:11:01.973]  - relaying element #1
[16:11:01.973] - relayed: [n=2] TRUE, FALSE
[16:11:01.974] - queued futures: [n=2] TRUE, FALSE
[16:11:01.974] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:01.974]  length: 1 (resolved future 1)
[16:11:01.974] Future #2
[16:11:01.975] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:01.975] - nx: 2
[16:11:01.976] - relay: TRUE
[16:11:01.976] - stdout: TRUE
[16:11:01.976] - signal: TRUE
[16:11:01.976] - resignal: FALSE
[16:11:01.976] - force: TRUE
[16:11:01.976] - relayed: [n=2] TRUE, FALSE
[16:11:01.976] - queued futures: [n=2] TRUE, FALSE
[16:11:01.976]  - until=2
[16:11:01.977]  - relaying element #2
[16:11:01.977] - relayed: [n=2] TRUE, TRUE
[16:11:01.977] - queued futures: [n=2] TRUE, TRUE
[16:11:01.977] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:01.977]  length: 0 (resolved future 2)
[16:11:01.977] Relaying remaining futures
[16:11:01.977] signalConditionsASAP(NULL, pos=0) ...
[16:11:01.978] - nx: 2
[16:11:01.978] - relay: TRUE
[16:11:01.978] - stdout: TRUE
[16:11:01.978] - signal: TRUE
[16:11:01.978] - resignal: FALSE
[16:11:01.978] - force: TRUE
[16:11:01.978] - relayed: [n=2] TRUE, TRUE
[16:11:01.978] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:01.979] - relayed: [n=2] TRUE, TRUE
[16:11:01.979] - queued futures: [n=2] TRUE, TRUE
[16:11:01.979] signalConditionsASAP(NULL, pos=0) ... done
[16:11:01.979] resolve() on list ... DONE
[16:11:01.979]  - Number of value chunks collected: 2
[16:11:01.979] Resolving 2 futures (chunks) ... DONE
[16:11:01.979] Reducing values from 2 chunks ...
[16:11:01.980]  - Number of values collected after concatenation: 7
[16:11:01.980]  - Number of values expected: 7
[16:11:01.980] Reducing values from 2 chunks ... DONE
[16:11:01.980] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:11:01.985] future_lapply() ...
[16:11:01.990] Number of chunks: 2
[16:11:01.990] getGlobalsAndPackagesXApply() ...
[16:11:01.990]  - future.globals: TRUE
[16:11:01.991] getGlobalsAndPackages() ...
[16:11:01.991] Searching for globals...
[16:11:01.993] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:11:01.993] Searching for globals ... DONE
[16:11:01.993] Resolving globals: FALSE
[16:11:01.993] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:11:01.994] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:11:01.994] - globals: [1] ‘FUN’
[16:11:01.994] 
[16:11:01.994] getGlobalsAndPackages() ... DONE
[16:11:01.994]  - globals found/used: [n=1] ‘FUN’
[16:11:01.994]  - needed namespaces: [n=0] 
[16:11:01.995] Finding globals ... DONE
[16:11:01.995]  - use_args: TRUE
[16:11:01.995]  - Getting '...' globals ...
[16:11:01.995] resolve() on list ...
[16:11:01.995]  recursive: 0
[16:11:01.995]  length: 1
[16:11:01.995]  elements: ‘...’
[16:11:01.996]  length: 0 (resolved future 1)
[16:11:01.996] resolve() on list ... DONE
[16:11:01.996]    - '...' content: [n=1] ‘y’
[16:11:01.996] List of 1
[16:11:01.996]  $ ...:List of 1
[16:11:01.996]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:01.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.996]  - attr(*, "where")=List of 1
[16:11:01.996]   ..$ ...:<environment: 0x561e8a221af8> 
[16:11:01.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.996]  - attr(*, "resolved")= logi TRUE
[16:11:01.996]  - attr(*, "total_size")= num NA
[16:11:01.999]  - Getting '...' globals ... DONE
[16:11:01.999] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:01.999] List of 2
[16:11:01.999]  $ ...future.FUN:function (x, y)  
[16:11:01.999]  $ ...          :List of 1
[16:11:01.999]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:01.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:01.999]  - attr(*, "where")=List of 2
[16:11:01.999]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:01.999]   ..$ ...          :<environment: 0x561e8a221af8> 
[16:11:01.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:01.999]  - attr(*, "resolved")= logi FALSE
[16:11:01.999]  - attr(*, "total_size")= num 4264
[16:11:02.003] Packages to be attached in all futures: [n=0] 
[16:11:02.003] getGlobalsAndPackagesXApply() ... DONE
[16:11:02.003] Number of futures (= number of chunks): 2
[16:11:02.003] Launching 2 futures (chunks) ...
[16:11:02.003] Chunk #1 of 2 ...
[16:11:02.003]  - Finding globals in 'X' for chunk #1 ...
[16:11:02.003] getGlobalsAndPackages() ...
[16:11:02.003] Searching for globals...
[16:11:02.004] 
[16:11:02.004] Searching for globals ... DONE
[16:11:02.004] - globals: [0] <none>
[16:11:02.004] getGlobalsAndPackages() ... DONE
[16:11:02.004]    + additional globals found: [n=0] 
[16:11:02.004]    + additional namespaces needed: [n=0] 
[16:11:02.004]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:02.004]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:02.004]  - seeds: <none>
[16:11:02.005] getGlobalsAndPackages() ...
[16:11:02.005] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.005] Resolving globals: FALSE
[16:11:02.005] Tweak future expression to call with '...' arguments ...
[16:11:02.005] {
[16:11:02.005]     do.call(function(...) {
[16:11:02.005]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.005]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.005]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.005]             on.exit(options(oopts), add = TRUE)
[16:11:02.005]         }
[16:11:02.005]         {
[16:11:02.005]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.005]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.005]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.005]             })
[16:11:02.005]         }
[16:11:02.005]     }, args = future.call.arguments)
[16:11:02.005] }
[16:11:02.005] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.006] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.006] 
[16:11:02.006] getGlobalsAndPackages() ... DONE
[16:11:02.006] run() for ‘Future’ ...
[16:11:02.006] - state: ‘created’
[16:11:02.006] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.014] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.014]   - Field: ‘label’
[16:11:02.014]   - Field: ‘local’
[16:11:02.014]   - Field: ‘owner’
[16:11:02.014]   - Field: ‘envir’
[16:11:02.014]   - Field: ‘workers’
[16:11:02.014]   - Field: ‘packages’
[16:11:02.014]   - Field: ‘gc’
[16:11:02.015]   - Field: ‘job’
[16:11:02.015]   - Field: ‘conditions’
[16:11:02.015]   - Field: ‘expr’
[16:11:02.015]   - Field: ‘uuid’
[16:11:02.015]   - Field: ‘seed’
[16:11:02.015]   - Field: ‘version’
[16:11:02.015]   - Field: ‘result’
[16:11:02.015]   - Field: ‘asynchronous’
[16:11:02.015]   - Field: ‘calls’
[16:11:02.016]   - Field: ‘globals’
[16:11:02.016]   - Field: ‘stdout’
[16:11:02.016]   - Field: ‘earlySignal’
[16:11:02.016]   - Field: ‘lazy’
[16:11:02.016]   - Field: ‘state’
[16:11:02.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.016] - Launch lazy future ...
[16:11:02.016] Packages needed by the future expression (n = 0): <none>
[16:11:02.017] Packages needed by future strategies (n = 0): <none>
[16:11:02.017] {
[16:11:02.017]     {
[16:11:02.017]         {
[16:11:02.017]             ...future.startTime <- base::Sys.time()
[16:11:02.017]             {
[16:11:02.017]                 {
[16:11:02.017]                   {
[16:11:02.017]                     {
[16:11:02.017]                       base::local({
[16:11:02.017]                         has_future <- base::requireNamespace("future", 
[16:11:02.017]                           quietly = TRUE)
[16:11:02.017]                         if (has_future) {
[16:11:02.017]                           ns <- base::getNamespace("future")
[16:11:02.017]                           version <- ns[[".package"]][["version"]]
[16:11:02.017]                           if (is.null(version)) 
[16:11:02.017]                             version <- utils::packageVersion("future")
[16:11:02.017]                         }
[16:11:02.017]                         else {
[16:11:02.017]                           version <- NULL
[16:11:02.017]                         }
[16:11:02.017]                         if (!has_future || version < "1.8.0") {
[16:11:02.017]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.017]                             "", base::R.version$version.string), 
[16:11:02.017]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:02.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:02.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.017]                               "release", "version")], collapse = " "), 
[16:11:02.017]                             hostname = base::Sys.info()[["nodename"]])
[16:11:02.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.017]                             info)
[16:11:02.017]                           info <- base::paste(info, collapse = "; ")
[16:11:02.017]                           if (!has_future) {
[16:11:02.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.017]                               info)
[16:11:02.017]                           }
[16:11:02.017]                           else {
[16:11:02.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.017]                               info, version)
[16:11:02.017]                           }
[16:11:02.017]                           base::stop(msg)
[16:11:02.017]                         }
[16:11:02.017]                       })
[16:11:02.017]                     }
[16:11:02.017]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.017]                     base::options(mc.cores = 1L)
[16:11:02.017]                   }
[16:11:02.017]                   options(future.plan = NULL)
[16:11:02.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.017]                 }
[16:11:02.017]                 ...future.workdir <- getwd()
[16:11:02.017]             }
[16:11:02.017]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.017]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.017]         }
[16:11:02.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.017]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:02.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.017]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.017]             base::names(...future.oldOptions))
[16:11:02.017]     }
[16:11:02.017]     if (FALSE) {
[16:11:02.017]     }
[16:11:02.017]     else {
[16:11:02.017]         if (TRUE) {
[16:11:02.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.017]                 open = "w")
[16:11:02.017]         }
[16:11:02.017]         else {
[16:11:02.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.017]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.017]         }
[16:11:02.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.017]             base::sink(type = "output", split = FALSE)
[16:11:02.017]             base::close(...future.stdout)
[16:11:02.017]         }, add = TRUE)
[16:11:02.017]     }
[16:11:02.017]     ...future.frame <- base::sys.nframe()
[16:11:02.017]     ...future.conditions <- base::list()
[16:11:02.017]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.017]     if (FALSE) {
[16:11:02.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.017]     }
[16:11:02.017]     ...future.result <- base::tryCatch({
[16:11:02.017]         base::withCallingHandlers({
[16:11:02.017]             ...future.value <- base::withVisible(base::local({
[16:11:02.017]                 withCallingHandlers({
[16:11:02.017]                   {
[16:11:02.017]                     do.call(function(...) {
[16:11:02.017]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.017]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.017]                         ...future.globals.maxSize)) {
[16:11:02.017]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.017]                         on.exit(options(oopts), add = TRUE)
[16:11:02.017]                       }
[16:11:02.017]                       {
[16:11:02.017]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.017]                           FUN = function(jj) {
[16:11:02.017]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.017]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.017]                           })
[16:11:02.017]                       }
[16:11:02.017]                     }, args = future.call.arguments)
[16:11:02.017]                   }
[16:11:02.017]                 }, immediateCondition = function(cond) {
[16:11:02.017]                   save_rds <- function (object, pathname, ...) 
[16:11:02.017]                   {
[16:11:02.017]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.017]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.017]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.017]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.017]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.017]                         fi_tmp[["mtime"]])
[16:11:02.017]                     }
[16:11:02.017]                     tryCatch({
[16:11:02.017]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.017]                     }, error = function(ex) {
[16:11:02.017]                       msg <- conditionMessage(ex)
[16:11:02.017]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.017]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.017]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.017]                         fi_tmp[["mtime"]], msg)
[16:11:02.017]                       ex$message <- msg
[16:11:02.017]                       stop(ex)
[16:11:02.017]                     })
[16:11:02.017]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.017]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.017]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.017]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.017]                       fi <- file.info(pathname)
[16:11:02.017]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.017]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.017]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.017]                         fi[["size"]], fi[["mtime"]])
[16:11:02.017]                       stop(msg)
[16:11:02.017]                     }
[16:11:02.017]                     invisible(pathname)
[16:11:02.017]                   }
[16:11:02.017]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.017]                     rootPath = tempdir()) 
[16:11:02.017]                   {
[16:11:02.017]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.017]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.017]                       tmpdir = path, fileext = ".rds")
[16:11:02.017]                     save_rds(obj, file)
[16:11:02.017]                   }
[16:11:02.017]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.017]                   {
[16:11:02.017]                     inherits <- base::inherits
[16:11:02.017]                     invokeRestart <- base::invokeRestart
[16:11:02.017]                     is.null <- base::is.null
[16:11:02.017]                     muffled <- FALSE
[16:11:02.017]                     if (inherits(cond, "message")) {
[16:11:02.017]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.017]                       if (muffled) 
[16:11:02.017]                         invokeRestart("muffleMessage")
[16:11:02.017]                     }
[16:11:02.017]                     else if (inherits(cond, "warning")) {
[16:11:02.017]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.017]                       if (muffled) 
[16:11:02.017]                         invokeRestart("muffleWarning")
[16:11:02.017]                     }
[16:11:02.017]                     else if (inherits(cond, "condition")) {
[16:11:02.017]                       if (!is.null(pattern)) {
[16:11:02.017]                         computeRestarts <- base::computeRestarts
[16:11:02.017]                         grepl <- base::grepl
[16:11:02.017]                         restarts <- computeRestarts(cond)
[16:11:02.017]                         for (restart in restarts) {
[16:11:02.017]                           name <- restart$name
[16:11:02.017]                           if (is.null(name)) 
[16:11:02.017]                             next
[16:11:02.017]                           if (!grepl(pattern, name)) 
[16:11:02.017]                             next
[16:11:02.017]                           invokeRestart(restart)
[16:11:02.017]                           muffled <- TRUE
[16:11:02.017]                           break
[16:11:02.017]                         }
[16:11:02.017]                       }
[16:11:02.017]                     }
[16:11:02.017]                     invisible(muffled)
[16:11:02.017]                   }
[16:11:02.017]                   muffleCondition(cond)
[16:11:02.017]                 })
[16:11:02.017]             }))
[16:11:02.017]             future::FutureResult(value = ...future.value$value, 
[16:11:02.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.017]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.017]                     ...future.globalenv.names))
[16:11:02.017]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.017]         }, condition = base::local({
[16:11:02.017]             c <- base::c
[16:11:02.017]             inherits <- base::inherits
[16:11:02.017]             invokeRestart <- base::invokeRestart
[16:11:02.017]             length <- base::length
[16:11:02.017]             list <- base::list
[16:11:02.017]             seq.int <- base::seq.int
[16:11:02.017]             signalCondition <- base::signalCondition
[16:11:02.017]             sys.calls <- base::sys.calls
[16:11:02.017]             `[[` <- base::`[[`
[16:11:02.017]             `+` <- base::`+`
[16:11:02.017]             `<<-` <- base::`<<-`
[16:11:02.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.017]                   3L)]
[16:11:02.017]             }
[16:11:02.017]             function(cond) {
[16:11:02.017]                 is_error <- inherits(cond, "error")
[16:11:02.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.017]                   NULL)
[16:11:02.017]                 if (is_error) {
[16:11:02.017]                   sessionInformation <- function() {
[16:11:02.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.017]                       search = base::search(), system = base::Sys.info())
[16:11:02.017]                   }
[16:11:02.017]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.017]                     cond$call), session = sessionInformation(), 
[16:11:02.017]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.017]                   signalCondition(cond)
[16:11:02.017]                 }
[16:11:02.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.017]                 "immediateCondition"))) {
[16:11:02.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.017]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.017]                   if (TRUE && !signal) {
[16:11:02.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.017]                     {
[16:11:02.017]                       inherits <- base::inherits
[16:11:02.017]                       invokeRestart <- base::invokeRestart
[16:11:02.017]                       is.null <- base::is.null
[16:11:02.017]                       muffled <- FALSE
[16:11:02.017]                       if (inherits(cond, "message")) {
[16:11:02.017]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.017]                         if (muffled) 
[16:11:02.017]                           invokeRestart("muffleMessage")
[16:11:02.017]                       }
[16:11:02.017]                       else if (inherits(cond, "warning")) {
[16:11:02.017]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.017]                         if (muffled) 
[16:11:02.017]                           invokeRestart("muffleWarning")
[16:11:02.017]                       }
[16:11:02.017]                       else if (inherits(cond, "condition")) {
[16:11:02.017]                         if (!is.null(pattern)) {
[16:11:02.017]                           computeRestarts <- base::computeRestarts
[16:11:02.017]                           grepl <- base::grepl
[16:11:02.017]                           restarts <- computeRestarts(cond)
[16:11:02.017]                           for (restart in restarts) {
[16:11:02.017]                             name <- restart$name
[16:11:02.017]                             if (is.null(name)) 
[16:11:02.017]                               next
[16:11:02.017]                             if (!grepl(pattern, name)) 
[16:11:02.017]                               next
[16:11:02.017]                             invokeRestart(restart)
[16:11:02.017]                             muffled <- TRUE
[16:11:02.017]                             break
[16:11:02.017]                           }
[16:11:02.017]                         }
[16:11:02.017]                       }
[16:11:02.017]                       invisible(muffled)
[16:11:02.017]                     }
[16:11:02.017]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.017]                   }
[16:11:02.017]                 }
[16:11:02.017]                 else {
[16:11:02.017]                   if (TRUE) {
[16:11:02.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.017]                     {
[16:11:02.017]                       inherits <- base::inherits
[16:11:02.017]                       invokeRestart <- base::invokeRestart
[16:11:02.017]                       is.null <- base::is.null
[16:11:02.017]                       muffled <- FALSE
[16:11:02.017]                       if (inherits(cond, "message")) {
[16:11:02.017]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.017]                         if (muffled) 
[16:11:02.017]                           invokeRestart("muffleMessage")
[16:11:02.017]                       }
[16:11:02.017]                       else if (inherits(cond, "warning")) {
[16:11:02.017]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.017]                         if (muffled) 
[16:11:02.017]                           invokeRestart("muffleWarning")
[16:11:02.017]                       }
[16:11:02.017]                       else if (inherits(cond, "condition")) {
[16:11:02.017]                         if (!is.null(pattern)) {
[16:11:02.017]                           computeRestarts <- base::computeRestarts
[16:11:02.017]                           grepl <- base::grepl
[16:11:02.017]                           restarts <- computeRestarts(cond)
[16:11:02.017]                           for (restart in restarts) {
[16:11:02.017]                             name <- restart$name
[16:11:02.017]                             if (is.null(name)) 
[16:11:02.017]                               next
[16:11:02.017]                             if (!grepl(pattern, name)) 
[16:11:02.017]                               next
[16:11:02.017]                             invokeRestart(restart)
[16:11:02.017]                             muffled <- TRUE
[16:11:02.017]                             break
[16:11:02.017]                           }
[16:11:02.017]                         }
[16:11:02.017]                       }
[16:11:02.017]                       invisible(muffled)
[16:11:02.017]                     }
[16:11:02.017]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.017]                   }
[16:11:02.017]                 }
[16:11:02.017]             }
[16:11:02.017]         }))
[16:11:02.017]     }, error = function(ex) {
[16:11:02.017]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.017]                 ...future.rng), started = ...future.startTime, 
[16:11:02.017]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.017]             version = "1.8"), class = "FutureResult")
[16:11:02.017]     }, finally = {
[16:11:02.017]         if (!identical(...future.workdir, getwd())) 
[16:11:02.017]             setwd(...future.workdir)
[16:11:02.017]         {
[16:11:02.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.017]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.017]             }
[16:11:02.017]             base::options(...future.oldOptions)
[16:11:02.017]             if (.Platform$OS.type == "windows") {
[16:11:02.017]                 old_names <- names(...future.oldEnvVars)
[16:11:02.017]                 envs <- base::Sys.getenv()
[16:11:02.017]                 names <- names(envs)
[16:11:02.017]                 common <- intersect(names, old_names)
[16:11:02.017]                 added <- setdiff(names, old_names)
[16:11:02.017]                 removed <- setdiff(old_names, names)
[16:11:02.017]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.017]                   envs[common]]
[16:11:02.017]                 NAMES <- toupper(changed)
[16:11:02.017]                 args <- list()
[16:11:02.017]                 for (kk in seq_along(NAMES)) {
[16:11:02.017]                   name <- changed[[kk]]
[16:11:02.017]                   NAME <- NAMES[[kk]]
[16:11:02.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.017]                     next
[16:11:02.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.017]                 }
[16:11:02.017]                 NAMES <- toupper(added)
[16:11:02.017]                 for (kk in seq_along(NAMES)) {
[16:11:02.017]                   name <- added[[kk]]
[16:11:02.017]                   NAME <- NAMES[[kk]]
[16:11:02.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.017]                     next
[16:11:02.017]                   args[[name]] <- ""
[16:11:02.017]                 }
[16:11:02.017]                 NAMES <- toupper(removed)
[16:11:02.017]                 for (kk in seq_along(NAMES)) {
[16:11:02.017]                   name <- removed[[kk]]
[16:11:02.017]                   NAME <- NAMES[[kk]]
[16:11:02.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.017]                     next
[16:11:02.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.017]                 }
[16:11:02.017]                 if (length(args) > 0) 
[16:11:02.017]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.017]             }
[16:11:02.017]             else {
[16:11:02.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.017]             }
[16:11:02.017]             {
[16:11:02.017]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.017]                   0L) {
[16:11:02.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.017]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.017]                   base::options(opts)
[16:11:02.017]                 }
[16:11:02.017]                 {
[16:11:02.017]                   {
[16:11:02.017]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.017]                     NULL
[16:11:02.017]                   }
[16:11:02.017]                   options(future.plan = NULL)
[16:11:02.017]                   if (is.na(NA_character_)) 
[16:11:02.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.017]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.017]                     envir = parent.frame()) 
[16:11:02.017]                   {
[16:11:02.017]                     default_workers <- missing(workers)
[16:11:02.017]                     if (is.function(workers)) 
[16:11:02.017]                       workers <- workers()
[16:11:02.017]                     workers <- structure(as.integer(workers), 
[16:11:02.017]                       class = class(workers))
[16:11:02.017]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.017]                       1L)
[16:11:02.017]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.017]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.017]                       if (default_workers) 
[16:11:02.017]                         supportsMulticore(warn = TRUE)
[16:11:02.017]                       return(sequential(..., envir = envir))
[16:11:02.017]                     }
[16:11:02.017]                     oopts <- options(mc.cores = workers)
[16:11:02.017]                     on.exit(options(oopts))
[16:11:02.017]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.017]                       envir = envir)
[16:11:02.017]                     if (!future$lazy) 
[16:11:02.017]                       future <- run(future)
[16:11:02.017]                     invisible(future)
[16:11:02.017]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.017]                 }
[16:11:02.017]             }
[16:11:02.017]         }
[16:11:02.017]     })
[16:11:02.017]     if (TRUE) {
[16:11:02.017]         base::sink(type = "output", split = FALSE)
[16:11:02.017]         if (TRUE) {
[16:11:02.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.017]         }
[16:11:02.017]         else {
[16:11:02.017]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.017]         }
[16:11:02.017]         base::close(...future.stdout)
[16:11:02.017]         ...future.stdout <- NULL
[16:11:02.017]     }
[16:11:02.017]     ...future.result$conditions <- ...future.conditions
[16:11:02.017]     ...future.result$finished <- base::Sys.time()
[16:11:02.017]     ...future.result
[16:11:02.017] }
[16:11:02.020] assign_globals() ...
[16:11:02.020] List of 5
[16:11:02.020]  $ ...future.FUN            :function (x, y)  
[16:11:02.020]  $ future.call.arguments    :List of 1
[16:11:02.020]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:02.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.020]  $ ...future.elements_ii    :List of 2
[16:11:02.020]   ..$ A: num 50
[16:11:02.020]   ..$ B: num 60
[16:11:02.020]  $ ...future.seeds_ii       : NULL
[16:11:02.020]  $ ...future.globals.maxSize: NULL
[16:11:02.020]  - attr(*, "resolved")= logi FALSE
[16:11:02.020]  - attr(*, "total_size")= num 4264
[16:11:02.020]  - attr(*, "where")=List of 5
[16:11:02.020]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.020]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.020]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.020]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.020]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.020]  - attr(*, "already-done")= logi TRUE
[16:11:02.025] - reassign environment for ‘...future.FUN’
[16:11:02.026] - copied ‘...future.FUN’ to environment
[16:11:02.026] - copied ‘future.call.arguments’ to environment
[16:11:02.026] - copied ‘...future.elements_ii’ to environment
[16:11:02.026] - copied ‘...future.seeds_ii’ to environment
[16:11:02.026] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.026] assign_globals() ... done
[16:11:02.026] requestCore(): workers = 2
[16:11:02.028] MulticoreFuture started
[16:11:02.029] - Launch lazy future ... done
[16:11:02.029] run() for ‘MulticoreFuture’ ... done
[16:11:02.029] Created future:
[16:11:02.029] plan(): Setting new future strategy stack:
[16:11:02.030] List of future strategies:
[16:11:02.030] 1. sequential:
[16:11:02.030]    - args: function (..., envir = parent.frame())
[16:11:02.030]    - tweaked: FALSE
[16:11:02.030]    - call: NULL
[16:11:02.030] plan(): nbrOfWorkers() = 1
[16:11:02.033] plan(): Setting new future strategy stack:
[16:11:02.033] List of future strategies:
[16:11:02.033] 1. multicore:
[16:11:02.033]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.033]    - tweaked: FALSE
[16:11:02.033]    - call: plan(strategy)
[16:11:02.038] plan(): nbrOfWorkers() = 2
[16:11:02.029] MulticoreFuture:
[16:11:02.029] Label: ‘future_sapply-1’
[16:11:02.029] Expression:
[16:11:02.029] {
[16:11:02.029]     do.call(function(...) {
[16:11:02.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.029]             on.exit(options(oopts), add = TRUE)
[16:11:02.029]         }
[16:11:02.029]         {
[16:11:02.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.029]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.029]             })
[16:11:02.029]         }
[16:11:02.029]     }, args = future.call.arguments)
[16:11:02.029] }
[16:11:02.029] Lazy evaluation: FALSE
[16:11:02.029] Asynchronous evaluation: TRUE
[16:11:02.029] Local evaluation: TRUE
[16:11:02.029] Environment: R_GlobalEnv
[16:11:02.029] Capture standard output: TRUE
[16:11:02.029] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.029] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:02.029] Packages: <none>
[16:11:02.029] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.029] Resolved: TRUE
[16:11:02.029] Value: <not collected>
[16:11:02.029] Conditions captured: <none>
[16:11:02.029] Early signaling: FALSE
[16:11:02.029] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.029] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.039] Chunk #1 of 2 ... DONE
[16:11:02.039] Chunk #2 of 2 ...
[16:11:02.040]  - Finding globals in 'X' for chunk #2 ...
[16:11:02.040] getGlobalsAndPackages() ...
[16:11:02.040] Searching for globals...
[16:11:02.041] 
[16:11:02.041] Searching for globals ... DONE
[16:11:02.041] - globals: [0] <none>
[16:11:02.041] getGlobalsAndPackages() ... DONE
[16:11:02.041]    + additional globals found: [n=0] 
[16:11:02.041]    + additional namespaces needed: [n=0] 
[16:11:02.041]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:02.042]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:02.042]  - seeds: <none>
[16:11:02.042] getGlobalsAndPackages() ...
[16:11:02.042] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.042] Resolving globals: FALSE
[16:11:02.042] Tweak future expression to call with '...' arguments ...
[16:11:02.043] {
[16:11:02.043]     do.call(function(...) {
[16:11:02.043]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.043]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.043]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.043]             on.exit(options(oopts), add = TRUE)
[16:11:02.043]         }
[16:11:02.043]         {
[16:11:02.043]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.043]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.043]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.043]             })
[16:11:02.043]         }
[16:11:02.043]     }, args = future.call.arguments)
[16:11:02.043] }
[16:11:02.043] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.044] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.044] 
[16:11:02.044] getGlobalsAndPackages() ... DONE
[16:11:02.045] run() for ‘Future’ ...
[16:11:02.045] - state: ‘created’
[16:11:02.045] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.050] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.050]   - Field: ‘label’
[16:11:02.050]   - Field: ‘local’
[16:11:02.051]   - Field: ‘owner’
[16:11:02.051]   - Field: ‘envir’
[16:11:02.051]   - Field: ‘workers’
[16:11:02.051]   - Field: ‘packages’
[16:11:02.051]   - Field: ‘gc’
[16:11:02.051]   - Field: ‘job’
[16:11:02.052]   - Field: ‘conditions’
[16:11:02.055]   - Field: ‘expr’
[16:11:02.056]   - Field: ‘uuid’
[16:11:02.056]   - Field: ‘seed’
[16:11:02.057]   - Field: ‘version’
[16:11:02.057]   - Field: ‘result’
[16:11:02.057]   - Field: ‘asynchronous’
[16:11:02.057]   - Field: ‘calls’
[16:11:02.058]   - Field: ‘globals’
[16:11:02.058]   - Field: ‘stdout’
[16:11:02.058]   - Field: ‘earlySignal’
[16:11:02.058]   - Field: ‘lazy’
[16:11:02.058]   - Field: ‘state’
[16:11:02.059] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.059] - Launch lazy future ...
[16:11:02.060] Packages needed by the future expression (n = 0): <none>
[16:11:02.060] Packages needed by future strategies (n = 0): <none>
[16:11:02.061] {
[16:11:02.061]     {
[16:11:02.061]         {
[16:11:02.061]             ...future.startTime <- base::Sys.time()
[16:11:02.061]             {
[16:11:02.061]                 {
[16:11:02.061]                   {
[16:11:02.061]                     {
[16:11:02.061]                       base::local({
[16:11:02.061]                         has_future <- base::requireNamespace("future", 
[16:11:02.061]                           quietly = TRUE)
[16:11:02.061]                         if (has_future) {
[16:11:02.061]                           ns <- base::getNamespace("future")
[16:11:02.061]                           version <- ns[[".package"]][["version"]]
[16:11:02.061]                           if (is.null(version)) 
[16:11:02.061]                             version <- utils::packageVersion("future")
[16:11:02.061]                         }
[16:11:02.061]                         else {
[16:11:02.061]                           version <- NULL
[16:11:02.061]                         }
[16:11:02.061]                         if (!has_future || version < "1.8.0") {
[16:11:02.061]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.061]                             "", base::R.version$version.string), 
[16:11:02.061]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:02.061]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:02.061]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.061]                               "release", "version")], collapse = " "), 
[16:11:02.061]                             hostname = base::Sys.info()[["nodename"]])
[16:11:02.061]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.061]                             info)
[16:11:02.061]                           info <- base::paste(info, collapse = "; ")
[16:11:02.061]                           if (!has_future) {
[16:11:02.061]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.061]                               info)
[16:11:02.061]                           }
[16:11:02.061]                           else {
[16:11:02.061]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.061]                               info, version)
[16:11:02.061]                           }
[16:11:02.061]                           base::stop(msg)
[16:11:02.061]                         }
[16:11:02.061]                       })
[16:11:02.061]                     }
[16:11:02.061]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.061]                     base::options(mc.cores = 1L)
[16:11:02.061]                   }
[16:11:02.061]                   options(future.plan = NULL)
[16:11:02.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.061]                 }
[16:11:02.061]                 ...future.workdir <- getwd()
[16:11:02.061]             }
[16:11:02.061]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.061]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.061]         }
[16:11:02.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.061]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:02.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.061]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.061]             base::names(...future.oldOptions))
[16:11:02.061]     }
[16:11:02.061]     if (FALSE) {
[16:11:02.061]     }
[16:11:02.061]     else {
[16:11:02.061]         if (TRUE) {
[16:11:02.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.061]                 open = "w")
[16:11:02.061]         }
[16:11:02.061]         else {
[16:11:02.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.061]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.061]         }
[16:11:02.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.061]             base::sink(type = "output", split = FALSE)
[16:11:02.061]             base::close(...future.stdout)
[16:11:02.061]         }, add = TRUE)
[16:11:02.061]     }
[16:11:02.061]     ...future.frame <- base::sys.nframe()
[16:11:02.061]     ...future.conditions <- base::list()
[16:11:02.061]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.061]     if (FALSE) {
[16:11:02.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.061]     }
[16:11:02.061]     ...future.result <- base::tryCatch({
[16:11:02.061]         base::withCallingHandlers({
[16:11:02.061]             ...future.value <- base::withVisible(base::local({
[16:11:02.061]                 withCallingHandlers({
[16:11:02.061]                   {
[16:11:02.061]                     do.call(function(...) {
[16:11:02.061]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.061]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.061]                         ...future.globals.maxSize)) {
[16:11:02.061]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.061]                         on.exit(options(oopts), add = TRUE)
[16:11:02.061]                       }
[16:11:02.061]                       {
[16:11:02.061]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.061]                           FUN = function(jj) {
[16:11:02.061]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.061]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.061]                           })
[16:11:02.061]                       }
[16:11:02.061]                     }, args = future.call.arguments)
[16:11:02.061]                   }
[16:11:02.061]                 }, immediateCondition = function(cond) {
[16:11:02.061]                   save_rds <- function (object, pathname, ...) 
[16:11:02.061]                   {
[16:11:02.061]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.061]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.061]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.061]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.061]                         fi_tmp[["mtime"]])
[16:11:02.061]                     }
[16:11:02.061]                     tryCatch({
[16:11:02.061]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.061]                     }, error = function(ex) {
[16:11:02.061]                       msg <- conditionMessage(ex)
[16:11:02.061]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.061]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.061]                         fi_tmp[["mtime"]], msg)
[16:11:02.061]                       ex$message <- msg
[16:11:02.061]                       stop(ex)
[16:11:02.061]                     })
[16:11:02.061]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.061]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.061]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.061]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.061]                       fi <- file.info(pathname)
[16:11:02.061]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.061]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.061]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.061]                         fi[["size"]], fi[["mtime"]])
[16:11:02.061]                       stop(msg)
[16:11:02.061]                     }
[16:11:02.061]                     invisible(pathname)
[16:11:02.061]                   }
[16:11:02.061]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.061]                     rootPath = tempdir()) 
[16:11:02.061]                   {
[16:11:02.061]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.061]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.061]                       tmpdir = path, fileext = ".rds")
[16:11:02.061]                     save_rds(obj, file)
[16:11:02.061]                   }
[16:11:02.061]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.061]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.061]                   {
[16:11:02.061]                     inherits <- base::inherits
[16:11:02.061]                     invokeRestart <- base::invokeRestart
[16:11:02.061]                     is.null <- base::is.null
[16:11:02.061]                     muffled <- FALSE
[16:11:02.061]                     if (inherits(cond, "message")) {
[16:11:02.061]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.061]                       if (muffled) 
[16:11:02.061]                         invokeRestart("muffleMessage")
[16:11:02.061]                     }
[16:11:02.061]                     else if (inherits(cond, "warning")) {
[16:11:02.061]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.061]                       if (muffled) 
[16:11:02.061]                         invokeRestart("muffleWarning")
[16:11:02.061]                     }
[16:11:02.061]                     else if (inherits(cond, "condition")) {
[16:11:02.061]                       if (!is.null(pattern)) {
[16:11:02.061]                         computeRestarts <- base::computeRestarts
[16:11:02.061]                         grepl <- base::grepl
[16:11:02.061]                         restarts <- computeRestarts(cond)
[16:11:02.061]                         for (restart in restarts) {
[16:11:02.061]                           name <- restart$name
[16:11:02.061]                           if (is.null(name)) 
[16:11:02.061]                             next
[16:11:02.061]                           if (!grepl(pattern, name)) 
[16:11:02.061]                             next
[16:11:02.061]                           invokeRestart(restart)
[16:11:02.061]                           muffled <- TRUE
[16:11:02.061]                           break
[16:11:02.061]                         }
[16:11:02.061]                       }
[16:11:02.061]                     }
[16:11:02.061]                     invisible(muffled)
[16:11:02.061]                   }
[16:11:02.061]                   muffleCondition(cond)
[16:11:02.061]                 })
[16:11:02.061]             }))
[16:11:02.061]             future::FutureResult(value = ...future.value$value, 
[16:11:02.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.061]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.061]                     ...future.globalenv.names))
[16:11:02.061]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.061]         }, condition = base::local({
[16:11:02.061]             c <- base::c
[16:11:02.061]             inherits <- base::inherits
[16:11:02.061]             invokeRestart <- base::invokeRestart
[16:11:02.061]             length <- base::length
[16:11:02.061]             list <- base::list
[16:11:02.061]             seq.int <- base::seq.int
[16:11:02.061]             signalCondition <- base::signalCondition
[16:11:02.061]             sys.calls <- base::sys.calls
[16:11:02.061]             `[[` <- base::`[[`
[16:11:02.061]             `+` <- base::`+`
[16:11:02.061]             `<<-` <- base::`<<-`
[16:11:02.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.061]                   3L)]
[16:11:02.061]             }
[16:11:02.061]             function(cond) {
[16:11:02.061]                 is_error <- inherits(cond, "error")
[16:11:02.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.061]                   NULL)
[16:11:02.061]                 if (is_error) {
[16:11:02.061]                   sessionInformation <- function() {
[16:11:02.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.061]                       search = base::search(), system = base::Sys.info())
[16:11:02.061]                   }
[16:11:02.061]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.061]                     cond$call), session = sessionInformation(), 
[16:11:02.061]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.061]                   signalCondition(cond)
[16:11:02.061]                 }
[16:11:02.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.061]                 "immediateCondition"))) {
[16:11:02.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.061]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.061]                   if (TRUE && !signal) {
[16:11:02.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.061]                     {
[16:11:02.061]                       inherits <- base::inherits
[16:11:02.061]                       invokeRestart <- base::invokeRestart
[16:11:02.061]                       is.null <- base::is.null
[16:11:02.061]                       muffled <- FALSE
[16:11:02.061]                       if (inherits(cond, "message")) {
[16:11:02.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.061]                         if (muffled) 
[16:11:02.061]                           invokeRestart("muffleMessage")
[16:11:02.061]                       }
[16:11:02.061]                       else if (inherits(cond, "warning")) {
[16:11:02.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.061]                         if (muffled) 
[16:11:02.061]                           invokeRestart("muffleWarning")
[16:11:02.061]                       }
[16:11:02.061]                       else if (inherits(cond, "condition")) {
[16:11:02.061]                         if (!is.null(pattern)) {
[16:11:02.061]                           computeRestarts <- base::computeRestarts
[16:11:02.061]                           grepl <- base::grepl
[16:11:02.061]                           restarts <- computeRestarts(cond)
[16:11:02.061]                           for (restart in restarts) {
[16:11:02.061]                             name <- restart$name
[16:11:02.061]                             if (is.null(name)) 
[16:11:02.061]                               next
[16:11:02.061]                             if (!grepl(pattern, name)) 
[16:11:02.061]                               next
[16:11:02.061]                             invokeRestart(restart)
[16:11:02.061]                             muffled <- TRUE
[16:11:02.061]                             break
[16:11:02.061]                           }
[16:11:02.061]                         }
[16:11:02.061]                       }
[16:11:02.061]                       invisible(muffled)
[16:11:02.061]                     }
[16:11:02.061]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.061]                   }
[16:11:02.061]                 }
[16:11:02.061]                 else {
[16:11:02.061]                   if (TRUE) {
[16:11:02.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.061]                     {
[16:11:02.061]                       inherits <- base::inherits
[16:11:02.061]                       invokeRestart <- base::invokeRestart
[16:11:02.061]                       is.null <- base::is.null
[16:11:02.061]                       muffled <- FALSE
[16:11:02.061]                       if (inherits(cond, "message")) {
[16:11:02.061]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.061]                         if (muffled) 
[16:11:02.061]                           invokeRestart("muffleMessage")
[16:11:02.061]                       }
[16:11:02.061]                       else if (inherits(cond, "warning")) {
[16:11:02.061]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.061]                         if (muffled) 
[16:11:02.061]                           invokeRestart("muffleWarning")
[16:11:02.061]                       }
[16:11:02.061]                       else if (inherits(cond, "condition")) {
[16:11:02.061]                         if (!is.null(pattern)) {
[16:11:02.061]                           computeRestarts <- base::computeRestarts
[16:11:02.061]                           grepl <- base::grepl
[16:11:02.061]                           restarts <- computeRestarts(cond)
[16:11:02.061]                           for (restart in restarts) {
[16:11:02.061]                             name <- restart$name
[16:11:02.061]                             if (is.null(name)) 
[16:11:02.061]                               next
[16:11:02.061]                             if (!grepl(pattern, name)) 
[16:11:02.061]                               next
[16:11:02.061]                             invokeRestart(restart)
[16:11:02.061]                             muffled <- TRUE
[16:11:02.061]                             break
[16:11:02.061]                           }
[16:11:02.061]                         }
[16:11:02.061]                       }
[16:11:02.061]                       invisible(muffled)
[16:11:02.061]                     }
[16:11:02.061]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.061]                   }
[16:11:02.061]                 }
[16:11:02.061]             }
[16:11:02.061]         }))
[16:11:02.061]     }, error = function(ex) {
[16:11:02.061]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.061]                 ...future.rng), started = ...future.startTime, 
[16:11:02.061]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.061]             version = "1.8"), class = "FutureResult")
[16:11:02.061]     }, finally = {
[16:11:02.061]         if (!identical(...future.workdir, getwd())) 
[16:11:02.061]             setwd(...future.workdir)
[16:11:02.061]         {
[16:11:02.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.061]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.061]             }
[16:11:02.061]             base::options(...future.oldOptions)
[16:11:02.061]             if (.Platform$OS.type == "windows") {
[16:11:02.061]                 old_names <- names(...future.oldEnvVars)
[16:11:02.061]                 envs <- base::Sys.getenv()
[16:11:02.061]                 names <- names(envs)
[16:11:02.061]                 common <- intersect(names, old_names)
[16:11:02.061]                 added <- setdiff(names, old_names)
[16:11:02.061]                 removed <- setdiff(old_names, names)
[16:11:02.061]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.061]                   envs[common]]
[16:11:02.061]                 NAMES <- toupper(changed)
[16:11:02.061]                 args <- list()
[16:11:02.061]                 for (kk in seq_along(NAMES)) {
[16:11:02.061]                   name <- changed[[kk]]
[16:11:02.061]                   NAME <- NAMES[[kk]]
[16:11:02.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.061]                     next
[16:11:02.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.061]                 }
[16:11:02.061]                 NAMES <- toupper(added)
[16:11:02.061]                 for (kk in seq_along(NAMES)) {
[16:11:02.061]                   name <- added[[kk]]
[16:11:02.061]                   NAME <- NAMES[[kk]]
[16:11:02.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.061]                     next
[16:11:02.061]                   args[[name]] <- ""
[16:11:02.061]                 }
[16:11:02.061]                 NAMES <- toupper(removed)
[16:11:02.061]                 for (kk in seq_along(NAMES)) {
[16:11:02.061]                   name <- removed[[kk]]
[16:11:02.061]                   NAME <- NAMES[[kk]]
[16:11:02.061]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.061]                     next
[16:11:02.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.061]                 }
[16:11:02.061]                 if (length(args) > 0) 
[16:11:02.061]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.061]             }
[16:11:02.061]             else {
[16:11:02.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.061]             }
[16:11:02.061]             {
[16:11:02.061]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.061]                   0L) {
[16:11:02.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.061]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.061]                   base::options(opts)
[16:11:02.061]                 }
[16:11:02.061]                 {
[16:11:02.061]                   {
[16:11:02.061]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.061]                     NULL
[16:11:02.061]                   }
[16:11:02.061]                   options(future.plan = NULL)
[16:11:02.061]                   if (is.na(NA_character_)) 
[16:11:02.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.061]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.061]                     envir = parent.frame()) 
[16:11:02.061]                   {
[16:11:02.061]                     default_workers <- missing(workers)
[16:11:02.061]                     if (is.function(workers)) 
[16:11:02.061]                       workers <- workers()
[16:11:02.061]                     workers <- structure(as.integer(workers), 
[16:11:02.061]                       class = class(workers))
[16:11:02.061]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.061]                       1L)
[16:11:02.061]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.061]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.061]                       if (default_workers) 
[16:11:02.061]                         supportsMulticore(warn = TRUE)
[16:11:02.061]                       return(sequential(..., envir = envir))
[16:11:02.061]                     }
[16:11:02.061]                     oopts <- options(mc.cores = workers)
[16:11:02.061]                     on.exit(options(oopts))
[16:11:02.061]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.061]                       envir = envir)
[16:11:02.061]                     if (!future$lazy) 
[16:11:02.061]                       future <- run(future)
[16:11:02.061]                     invisible(future)
[16:11:02.061]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.061]                 }
[16:11:02.061]             }
[16:11:02.061]         }
[16:11:02.061]     })
[16:11:02.061]     if (TRUE) {
[16:11:02.061]         base::sink(type = "output", split = FALSE)
[16:11:02.061]         if (TRUE) {
[16:11:02.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.061]         }
[16:11:02.061]         else {
[16:11:02.061]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.061]         }
[16:11:02.061]         base::close(...future.stdout)
[16:11:02.061]         ...future.stdout <- NULL
[16:11:02.061]     }
[16:11:02.061]     ...future.result$conditions <- ...future.conditions
[16:11:02.061]     ...future.result$finished <- base::Sys.time()
[16:11:02.061]     ...future.result
[16:11:02.061] }
[16:11:02.064] assign_globals() ...
[16:11:02.064] List of 5
[16:11:02.064]  $ ...future.FUN            :function (x, y)  
[16:11:02.064]  $ future.call.arguments    :List of 1
[16:11:02.064]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:02.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.064]  $ ...future.elements_ii    :List of 2
[16:11:02.064]   ..$ C: num 70
[16:11:02.064]   ..$ D: num 80
[16:11:02.064]  $ ...future.seeds_ii       : NULL
[16:11:02.064]  $ ...future.globals.maxSize: NULL
[16:11:02.064]  - attr(*, "resolved")= logi FALSE
[16:11:02.064]  - attr(*, "total_size")= num 4264
[16:11:02.064]  - attr(*, "where")=List of 5
[16:11:02.064]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.064]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.064]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.064]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.064]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.064]  - attr(*, "already-done")= logi TRUE
[16:11:02.074] - reassign environment for ‘...future.FUN’
[16:11:02.074] - copied ‘...future.FUN’ to environment
[16:11:02.074] - copied ‘future.call.arguments’ to environment
[16:11:02.075] - copied ‘...future.elements_ii’ to environment
[16:11:02.075] - copied ‘...future.seeds_ii’ to environment
[16:11:02.075] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.075] assign_globals() ... done
[16:11:02.076] requestCore(): workers = 2
[16:11:02.078] MulticoreFuture started
[16:11:02.078] - Launch lazy future ... done
[16:11:02.078] run() for ‘MulticoreFuture’ ... done
[16:11:02.079] Created future:
[16:11:02.079] plan(): Setting new future strategy stack:
[16:11:02.079] List of future strategies:
[16:11:02.079] 1. sequential:
[16:11:02.079]    - args: function (..., envir = parent.frame())
[16:11:02.079]    - tweaked: FALSE
[16:11:02.079]    - call: NULL
[16:11:02.080] plan(): nbrOfWorkers() = 1
[16:11:02.082] plan(): Setting new future strategy stack:
[16:11:02.083] List of future strategies:
[16:11:02.083] 1. multicore:
[16:11:02.083]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.083]    - tweaked: FALSE
[16:11:02.083]    - call: plan(strategy)
[16:11:02.088] plan(): nbrOfWorkers() = 2
[16:11:02.079] MulticoreFuture:
[16:11:02.079] Label: ‘future_sapply-2’
[16:11:02.079] Expression:
[16:11:02.079] {
[16:11:02.079]     do.call(function(...) {
[16:11:02.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.079]             on.exit(options(oopts), add = TRUE)
[16:11:02.079]         }
[16:11:02.079]         {
[16:11:02.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.079]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.079]             })
[16:11:02.079]         }
[16:11:02.079]     }, args = future.call.arguments)
[16:11:02.079] }
[16:11:02.079] Lazy evaluation: FALSE
[16:11:02.079] Asynchronous evaluation: TRUE
[16:11:02.079] Local evaluation: TRUE
[16:11:02.079] Environment: R_GlobalEnv
[16:11:02.079] Capture standard output: TRUE
[16:11:02.079] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.079] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:02.079] Packages: <none>
[16:11:02.079] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.079] Resolved: TRUE
[16:11:02.079] Value: <not collected>
[16:11:02.079] Conditions captured: <none>
[16:11:02.079] Early signaling: FALSE
[16:11:02.079] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.079] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.089] Chunk #2 of 2 ... DONE
[16:11:02.089] Launching 2 futures (chunks) ... DONE
[16:11:02.089] Resolving 2 futures (chunks) ...
[16:11:02.090] resolve() on list ...
[16:11:02.090]  recursive: 0
[16:11:02.090]  length: 2
[16:11:02.090] 
[16:11:02.090] Future #1
[16:11:02.091] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:02.092] - nx: 2
[16:11:02.092] - relay: TRUE
[16:11:02.092] - stdout: TRUE
[16:11:02.092] - signal: TRUE
[16:11:02.092] - resignal: FALSE
[16:11:02.092] - force: TRUE
[16:11:02.092] - relayed: [n=2] FALSE, FALSE
[16:11:02.093] - queued futures: [n=2] FALSE, FALSE
[16:11:02.093]  - until=1
[16:11:02.093]  - relaying element #1
[16:11:02.093] - relayed: [n=2] TRUE, FALSE
[16:11:02.093] - queued futures: [n=2] TRUE, FALSE
[16:11:02.094] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:02.094]  length: 1 (resolved future 1)
[16:11:02.094] Future #2
[16:11:02.095] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:02.095] - nx: 2
[16:11:02.095] - relay: TRUE
[16:11:02.095] - stdout: TRUE
[16:11:02.096] - signal: TRUE
[16:11:02.096] - resignal: FALSE
[16:11:02.096] - force: TRUE
[16:11:02.096] - relayed: [n=2] TRUE, FALSE
[16:11:02.096] - queued futures: [n=2] TRUE, FALSE
[16:11:02.096]  - until=2
[16:11:02.096]  - relaying element #2
[16:11:02.097] - relayed: [n=2] TRUE, TRUE
[16:11:02.097] - queued futures: [n=2] TRUE, TRUE
[16:11:02.097] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:02.097]  length: 0 (resolved future 2)
[16:11:02.097] Relaying remaining futures
[16:11:02.097] signalConditionsASAP(NULL, pos=0) ...
[16:11:02.097] - nx: 2
[16:11:02.097] - relay: TRUE
[16:11:02.098] - stdout: TRUE
[16:11:02.098] - signal: TRUE
[16:11:02.098] - resignal: FALSE
[16:11:02.098] - force: TRUE
[16:11:02.098] - relayed: [n=2] TRUE, TRUE
[16:11:02.098] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:02.098] - relayed: [n=2] TRUE, TRUE
[16:11:02.098] - queued futures: [n=2] TRUE, TRUE
[16:11:02.099] signalConditionsASAP(NULL, pos=0) ... done
[16:11:02.099] resolve() on list ... DONE
[16:11:02.099]  - Number of value chunks collected: 2
[16:11:02.099] Resolving 2 futures (chunks) ... DONE
[16:11:02.099] Reducing values from 2 chunks ...
[16:11:02.099]  - Number of values collected after concatenation: 4
[16:11:02.099]  - Number of values expected: 4
[16:11:02.100] Reducing values from 2 chunks ... DONE
[16:11:02.100] future_lapply() ... DONE
[16:11:02.100] future_lapply() ...
[16:11:02.110] Number of chunks: 2
[16:11:02.110] getGlobalsAndPackagesXApply() ...
[16:11:02.110]  - future.globals: TRUE
[16:11:02.110] getGlobalsAndPackages() ...
[16:11:02.111] Searching for globals...
[16:11:02.116] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:11:02.116] Searching for globals ... DONE
[16:11:02.116] Resolving globals: FALSE
[16:11:02.117] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:11:02.118] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:02.118] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:02.118] - packages: [1] ‘future.apply’
[16:11:02.118] getGlobalsAndPackages() ... DONE
[16:11:02.118]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:02.118]  - needed namespaces: [n=1] ‘future.apply’
[16:11:02.118] Finding globals ... DONE
[16:11:02.118]  - use_args: TRUE
[16:11:02.119]  - Getting '...' globals ...
[16:11:02.119] resolve() on list ...
[16:11:02.119]  recursive: 0
[16:11:02.119]  length: 1
[16:11:02.119]  elements: ‘...’
[16:11:02.119]  length: 0 (resolved future 1)
[16:11:02.119] resolve() on list ... DONE
[16:11:02.119]    - '...' content: [n=1] ‘y’
[16:11:02.120] List of 1
[16:11:02.120]  $ ...:List of 1
[16:11:02.120]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:02.120]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.120]  - attr(*, "where")=List of 1
[16:11:02.120]   ..$ ...:<environment: 0x561e8a3c1e30> 
[16:11:02.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.120]  - attr(*, "resolved")= logi TRUE
[16:11:02.120]  - attr(*, "total_size")= num NA
[16:11:02.123]  - Getting '...' globals ... DONE
[16:11:02.123] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:02.123] List of 8
[16:11:02.123]  $ ...future.FUN:function (x, ...)  
[16:11:02.123]  $ x_FUN        :function (x, y)  
[16:11:02.123]  $ times        : int 15
[16:11:02.123]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.123]  $ stop_if_not  :function (...)  
[16:11:02.123]  $ dim          : int [1:2] 3 5
[16:11:02.123]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:02.123]  $ ...          :List of 1
[16:11:02.123]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:02.123]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.123]  - attr(*, "where")=List of 8
[16:11:02.123]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:02.123]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:02.123]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:02.123]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:02.123]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:02.123]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:02.123]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:02.123]   ..$ ...          :<environment: 0x561e8a3c1e30> 
[16:11:02.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.123]  - attr(*, "resolved")= logi FALSE
[16:11:02.123]  - attr(*, "total_size")= num 98600
[16:11:02.131] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:02.132] getGlobalsAndPackagesXApply() ... DONE
[16:11:02.132] Number of futures (= number of chunks): 2
[16:11:02.132] Launching 2 futures (chunks) ...
[16:11:02.132] Chunk #1 of 2 ...
[16:11:02.132]  - Finding globals in 'X' for chunk #1 ...
[16:11:02.132] getGlobalsAndPackages() ...
[16:11:02.132] Searching for globals...
[16:11:02.133] 
[16:11:02.133] Searching for globals ... DONE
[16:11:02.133] - globals: [0] <none>
[16:11:02.133] getGlobalsAndPackages() ... DONE
[16:11:02.133]    + additional globals found: [n=0] 
[16:11:02.133]    + additional namespaces needed: [n=0] 
[16:11:02.133]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:02.133]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:02.134]  - seeds: <none>
[16:11:02.134] getGlobalsAndPackages() ...
[16:11:02.134] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.134] Resolving globals: FALSE
[16:11:02.134] Tweak future expression to call with '...' arguments ...
[16:11:02.134] {
[16:11:02.134]     do.call(function(...) {
[16:11:02.134]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.134]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.134]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.134]             on.exit(options(oopts), add = TRUE)
[16:11:02.134]         }
[16:11:02.134]         {
[16:11:02.134]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.134]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.134]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.134]             })
[16:11:02.134]         }
[16:11:02.134]     }, args = future.call.arguments)
[16:11:02.134] }
[16:11:02.134] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.135] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.135] - packages: [1] ‘future.apply’
[16:11:02.135] getGlobalsAndPackages() ... DONE
[16:11:02.136] run() for ‘Future’ ...
[16:11:02.136] - state: ‘created’
[16:11:02.136] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.139] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.140]   - Field: ‘label’
[16:11:02.140]   - Field: ‘local’
[16:11:02.140]   - Field: ‘owner’
[16:11:02.140]   - Field: ‘envir’
[16:11:02.140]   - Field: ‘workers’
[16:11:02.140]   - Field: ‘packages’
[16:11:02.140]   - Field: ‘gc’
[16:11:02.140]   - Field: ‘job’
[16:11:02.140]   - Field: ‘conditions’
[16:11:02.141]   - Field: ‘expr’
[16:11:02.141]   - Field: ‘uuid’
[16:11:02.141]   - Field: ‘seed’
[16:11:02.141]   - Field: ‘version’
[16:11:02.141]   - Field: ‘result’
[16:11:02.141]   - Field: ‘asynchronous’
[16:11:02.141]   - Field: ‘calls’
[16:11:02.141]   - Field: ‘globals’
[16:11:02.141]   - Field: ‘stdout’
[16:11:02.141]   - Field: ‘earlySignal’
[16:11:02.141]   - Field: ‘lazy’
[16:11:02.142]   - Field: ‘state’
[16:11:02.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.142] - Launch lazy future ...
[16:11:02.142] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:02.142] Packages needed by future strategies (n = 0): <none>
[16:11:02.143] {
[16:11:02.143]     {
[16:11:02.143]         {
[16:11:02.143]             ...future.startTime <- base::Sys.time()
[16:11:02.143]             {
[16:11:02.143]                 {
[16:11:02.143]                   {
[16:11:02.143]                     {
[16:11:02.143]                       {
[16:11:02.143]                         base::local({
[16:11:02.143]                           has_future <- base::requireNamespace("future", 
[16:11:02.143]                             quietly = TRUE)
[16:11:02.143]                           if (has_future) {
[16:11:02.143]                             ns <- base::getNamespace("future")
[16:11:02.143]                             version <- ns[[".package"]][["version"]]
[16:11:02.143]                             if (is.null(version)) 
[16:11:02.143]                               version <- utils::packageVersion("future")
[16:11:02.143]                           }
[16:11:02.143]                           else {
[16:11:02.143]                             version <- NULL
[16:11:02.143]                           }
[16:11:02.143]                           if (!has_future || version < "1.8.0") {
[16:11:02.143]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.143]                               "", base::R.version$version.string), 
[16:11:02.143]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:02.143]                                 base::R.version$platform, 8 * 
[16:11:02.143]                                   base::.Machine$sizeof.pointer), 
[16:11:02.143]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.143]                                 "release", "version")], collapse = " "), 
[16:11:02.143]                               hostname = base::Sys.info()[["nodename"]])
[16:11:02.143]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.143]                               info)
[16:11:02.143]                             info <- base::paste(info, collapse = "; ")
[16:11:02.143]                             if (!has_future) {
[16:11:02.143]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.143]                                 info)
[16:11:02.143]                             }
[16:11:02.143]                             else {
[16:11:02.143]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.143]                                 info, version)
[16:11:02.143]                             }
[16:11:02.143]                             base::stop(msg)
[16:11:02.143]                           }
[16:11:02.143]                         })
[16:11:02.143]                       }
[16:11:02.143]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.143]                       base::options(mc.cores = 1L)
[16:11:02.143]                     }
[16:11:02.143]                     base::local({
[16:11:02.143]                       for (pkg in "future.apply") {
[16:11:02.143]                         base::loadNamespace(pkg)
[16:11:02.143]                         base::library(pkg, character.only = TRUE)
[16:11:02.143]                       }
[16:11:02.143]                     })
[16:11:02.143]                   }
[16:11:02.143]                   options(future.plan = NULL)
[16:11:02.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.143]                 }
[16:11:02.143]                 ...future.workdir <- getwd()
[16:11:02.143]             }
[16:11:02.143]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.143]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.143]         }
[16:11:02.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.143]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:02.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.143]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.143]             base::names(...future.oldOptions))
[16:11:02.143]     }
[16:11:02.143]     if (FALSE) {
[16:11:02.143]     }
[16:11:02.143]     else {
[16:11:02.143]         if (TRUE) {
[16:11:02.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.143]                 open = "w")
[16:11:02.143]         }
[16:11:02.143]         else {
[16:11:02.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.143]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.143]         }
[16:11:02.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.143]             base::sink(type = "output", split = FALSE)
[16:11:02.143]             base::close(...future.stdout)
[16:11:02.143]         }, add = TRUE)
[16:11:02.143]     }
[16:11:02.143]     ...future.frame <- base::sys.nframe()
[16:11:02.143]     ...future.conditions <- base::list()
[16:11:02.143]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.143]     if (FALSE) {
[16:11:02.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.143]     }
[16:11:02.143]     ...future.result <- base::tryCatch({
[16:11:02.143]         base::withCallingHandlers({
[16:11:02.143]             ...future.value <- base::withVisible(base::local({
[16:11:02.143]                 withCallingHandlers({
[16:11:02.143]                   {
[16:11:02.143]                     do.call(function(...) {
[16:11:02.143]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.143]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.143]                         ...future.globals.maxSize)) {
[16:11:02.143]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.143]                         on.exit(options(oopts), add = TRUE)
[16:11:02.143]                       }
[16:11:02.143]                       {
[16:11:02.143]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.143]                           FUN = function(jj) {
[16:11:02.143]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.143]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.143]                           })
[16:11:02.143]                       }
[16:11:02.143]                     }, args = future.call.arguments)
[16:11:02.143]                   }
[16:11:02.143]                 }, immediateCondition = function(cond) {
[16:11:02.143]                   save_rds <- function (object, pathname, ...) 
[16:11:02.143]                   {
[16:11:02.143]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.143]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.143]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.143]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.143]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.143]                         fi_tmp[["mtime"]])
[16:11:02.143]                     }
[16:11:02.143]                     tryCatch({
[16:11:02.143]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.143]                     }, error = function(ex) {
[16:11:02.143]                       msg <- conditionMessage(ex)
[16:11:02.143]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.143]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.143]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.143]                         fi_tmp[["mtime"]], msg)
[16:11:02.143]                       ex$message <- msg
[16:11:02.143]                       stop(ex)
[16:11:02.143]                     })
[16:11:02.143]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.143]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.143]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.143]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.143]                       fi <- file.info(pathname)
[16:11:02.143]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.143]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.143]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.143]                         fi[["size"]], fi[["mtime"]])
[16:11:02.143]                       stop(msg)
[16:11:02.143]                     }
[16:11:02.143]                     invisible(pathname)
[16:11:02.143]                   }
[16:11:02.143]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.143]                     rootPath = tempdir()) 
[16:11:02.143]                   {
[16:11:02.143]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.143]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.143]                       tmpdir = path, fileext = ".rds")
[16:11:02.143]                     save_rds(obj, file)
[16:11:02.143]                   }
[16:11:02.143]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.143]                   {
[16:11:02.143]                     inherits <- base::inherits
[16:11:02.143]                     invokeRestart <- base::invokeRestart
[16:11:02.143]                     is.null <- base::is.null
[16:11:02.143]                     muffled <- FALSE
[16:11:02.143]                     if (inherits(cond, "message")) {
[16:11:02.143]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.143]                       if (muffled) 
[16:11:02.143]                         invokeRestart("muffleMessage")
[16:11:02.143]                     }
[16:11:02.143]                     else if (inherits(cond, "warning")) {
[16:11:02.143]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.143]                       if (muffled) 
[16:11:02.143]                         invokeRestart("muffleWarning")
[16:11:02.143]                     }
[16:11:02.143]                     else if (inherits(cond, "condition")) {
[16:11:02.143]                       if (!is.null(pattern)) {
[16:11:02.143]                         computeRestarts <- base::computeRestarts
[16:11:02.143]                         grepl <- base::grepl
[16:11:02.143]                         restarts <- computeRestarts(cond)
[16:11:02.143]                         for (restart in restarts) {
[16:11:02.143]                           name <- restart$name
[16:11:02.143]                           if (is.null(name)) 
[16:11:02.143]                             next
[16:11:02.143]                           if (!grepl(pattern, name)) 
[16:11:02.143]                             next
[16:11:02.143]                           invokeRestart(restart)
[16:11:02.143]                           muffled <- TRUE
[16:11:02.143]                           break
[16:11:02.143]                         }
[16:11:02.143]                       }
[16:11:02.143]                     }
[16:11:02.143]                     invisible(muffled)
[16:11:02.143]                   }
[16:11:02.143]                   muffleCondition(cond)
[16:11:02.143]                 })
[16:11:02.143]             }))
[16:11:02.143]             future::FutureResult(value = ...future.value$value, 
[16:11:02.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.143]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.143]                     ...future.globalenv.names))
[16:11:02.143]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.143]         }, condition = base::local({
[16:11:02.143]             c <- base::c
[16:11:02.143]             inherits <- base::inherits
[16:11:02.143]             invokeRestart <- base::invokeRestart
[16:11:02.143]             length <- base::length
[16:11:02.143]             list <- base::list
[16:11:02.143]             seq.int <- base::seq.int
[16:11:02.143]             signalCondition <- base::signalCondition
[16:11:02.143]             sys.calls <- base::sys.calls
[16:11:02.143]             `[[` <- base::`[[`
[16:11:02.143]             `+` <- base::`+`
[16:11:02.143]             `<<-` <- base::`<<-`
[16:11:02.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.143]                   3L)]
[16:11:02.143]             }
[16:11:02.143]             function(cond) {
[16:11:02.143]                 is_error <- inherits(cond, "error")
[16:11:02.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.143]                   NULL)
[16:11:02.143]                 if (is_error) {
[16:11:02.143]                   sessionInformation <- function() {
[16:11:02.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.143]                       search = base::search(), system = base::Sys.info())
[16:11:02.143]                   }
[16:11:02.143]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.143]                     cond$call), session = sessionInformation(), 
[16:11:02.143]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.143]                   signalCondition(cond)
[16:11:02.143]                 }
[16:11:02.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.143]                 "immediateCondition"))) {
[16:11:02.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.143]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.143]                   if (TRUE && !signal) {
[16:11:02.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.143]                     {
[16:11:02.143]                       inherits <- base::inherits
[16:11:02.143]                       invokeRestart <- base::invokeRestart
[16:11:02.143]                       is.null <- base::is.null
[16:11:02.143]                       muffled <- FALSE
[16:11:02.143]                       if (inherits(cond, "message")) {
[16:11:02.143]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.143]                         if (muffled) 
[16:11:02.143]                           invokeRestart("muffleMessage")
[16:11:02.143]                       }
[16:11:02.143]                       else if (inherits(cond, "warning")) {
[16:11:02.143]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.143]                         if (muffled) 
[16:11:02.143]                           invokeRestart("muffleWarning")
[16:11:02.143]                       }
[16:11:02.143]                       else if (inherits(cond, "condition")) {
[16:11:02.143]                         if (!is.null(pattern)) {
[16:11:02.143]                           computeRestarts <- base::computeRestarts
[16:11:02.143]                           grepl <- base::grepl
[16:11:02.143]                           restarts <- computeRestarts(cond)
[16:11:02.143]                           for (restart in restarts) {
[16:11:02.143]                             name <- restart$name
[16:11:02.143]                             if (is.null(name)) 
[16:11:02.143]                               next
[16:11:02.143]                             if (!grepl(pattern, name)) 
[16:11:02.143]                               next
[16:11:02.143]                             invokeRestart(restart)
[16:11:02.143]                             muffled <- TRUE
[16:11:02.143]                             break
[16:11:02.143]                           }
[16:11:02.143]                         }
[16:11:02.143]                       }
[16:11:02.143]                       invisible(muffled)
[16:11:02.143]                     }
[16:11:02.143]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.143]                   }
[16:11:02.143]                 }
[16:11:02.143]                 else {
[16:11:02.143]                   if (TRUE) {
[16:11:02.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.143]                     {
[16:11:02.143]                       inherits <- base::inherits
[16:11:02.143]                       invokeRestart <- base::invokeRestart
[16:11:02.143]                       is.null <- base::is.null
[16:11:02.143]                       muffled <- FALSE
[16:11:02.143]                       if (inherits(cond, "message")) {
[16:11:02.143]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.143]                         if (muffled) 
[16:11:02.143]                           invokeRestart("muffleMessage")
[16:11:02.143]                       }
[16:11:02.143]                       else if (inherits(cond, "warning")) {
[16:11:02.143]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.143]                         if (muffled) 
[16:11:02.143]                           invokeRestart("muffleWarning")
[16:11:02.143]                       }
[16:11:02.143]                       else if (inherits(cond, "condition")) {
[16:11:02.143]                         if (!is.null(pattern)) {
[16:11:02.143]                           computeRestarts <- base::computeRestarts
[16:11:02.143]                           grepl <- base::grepl
[16:11:02.143]                           restarts <- computeRestarts(cond)
[16:11:02.143]                           for (restart in restarts) {
[16:11:02.143]                             name <- restart$name
[16:11:02.143]                             if (is.null(name)) 
[16:11:02.143]                               next
[16:11:02.143]                             if (!grepl(pattern, name)) 
[16:11:02.143]                               next
[16:11:02.143]                             invokeRestart(restart)
[16:11:02.143]                             muffled <- TRUE
[16:11:02.143]                             break
[16:11:02.143]                           }
[16:11:02.143]                         }
[16:11:02.143]                       }
[16:11:02.143]                       invisible(muffled)
[16:11:02.143]                     }
[16:11:02.143]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.143]                   }
[16:11:02.143]                 }
[16:11:02.143]             }
[16:11:02.143]         }))
[16:11:02.143]     }, error = function(ex) {
[16:11:02.143]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.143]                 ...future.rng), started = ...future.startTime, 
[16:11:02.143]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.143]             version = "1.8"), class = "FutureResult")
[16:11:02.143]     }, finally = {
[16:11:02.143]         if (!identical(...future.workdir, getwd())) 
[16:11:02.143]             setwd(...future.workdir)
[16:11:02.143]         {
[16:11:02.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.143]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.143]             }
[16:11:02.143]             base::options(...future.oldOptions)
[16:11:02.143]             if (.Platform$OS.type == "windows") {
[16:11:02.143]                 old_names <- names(...future.oldEnvVars)
[16:11:02.143]                 envs <- base::Sys.getenv()
[16:11:02.143]                 names <- names(envs)
[16:11:02.143]                 common <- intersect(names, old_names)
[16:11:02.143]                 added <- setdiff(names, old_names)
[16:11:02.143]                 removed <- setdiff(old_names, names)
[16:11:02.143]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.143]                   envs[common]]
[16:11:02.143]                 NAMES <- toupper(changed)
[16:11:02.143]                 args <- list()
[16:11:02.143]                 for (kk in seq_along(NAMES)) {
[16:11:02.143]                   name <- changed[[kk]]
[16:11:02.143]                   NAME <- NAMES[[kk]]
[16:11:02.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.143]                     next
[16:11:02.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.143]                 }
[16:11:02.143]                 NAMES <- toupper(added)
[16:11:02.143]                 for (kk in seq_along(NAMES)) {
[16:11:02.143]                   name <- added[[kk]]
[16:11:02.143]                   NAME <- NAMES[[kk]]
[16:11:02.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.143]                     next
[16:11:02.143]                   args[[name]] <- ""
[16:11:02.143]                 }
[16:11:02.143]                 NAMES <- toupper(removed)
[16:11:02.143]                 for (kk in seq_along(NAMES)) {
[16:11:02.143]                   name <- removed[[kk]]
[16:11:02.143]                   NAME <- NAMES[[kk]]
[16:11:02.143]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.143]                     next
[16:11:02.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.143]                 }
[16:11:02.143]                 if (length(args) > 0) 
[16:11:02.143]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.143]             }
[16:11:02.143]             else {
[16:11:02.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.143]             }
[16:11:02.143]             {
[16:11:02.143]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.143]                   0L) {
[16:11:02.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.143]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.143]                   base::options(opts)
[16:11:02.143]                 }
[16:11:02.143]                 {
[16:11:02.143]                   {
[16:11:02.143]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.143]                     NULL
[16:11:02.143]                   }
[16:11:02.143]                   options(future.plan = NULL)
[16:11:02.143]                   if (is.na(NA_character_)) 
[16:11:02.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.143]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.143]                     envir = parent.frame()) 
[16:11:02.143]                   {
[16:11:02.143]                     default_workers <- missing(workers)
[16:11:02.143]                     if (is.function(workers)) 
[16:11:02.143]                       workers <- workers()
[16:11:02.143]                     workers <- structure(as.integer(workers), 
[16:11:02.143]                       class = class(workers))
[16:11:02.143]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.143]                       1L)
[16:11:02.143]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.143]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.143]                       if (default_workers) 
[16:11:02.143]                         supportsMulticore(warn = TRUE)
[16:11:02.143]                       return(sequential(..., envir = envir))
[16:11:02.143]                     }
[16:11:02.143]                     oopts <- options(mc.cores = workers)
[16:11:02.143]                     on.exit(options(oopts))
[16:11:02.143]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.143]                       envir = envir)
[16:11:02.143]                     if (!future$lazy) 
[16:11:02.143]                       future <- run(future)
[16:11:02.143]                     invisible(future)
[16:11:02.143]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.143]                 }
[16:11:02.143]             }
[16:11:02.143]         }
[16:11:02.143]     })
[16:11:02.143]     if (TRUE) {
[16:11:02.143]         base::sink(type = "output", split = FALSE)
[16:11:02.143]         if (TRUE) {
[16:11:02.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.143]         }
[16:11:02.143]         else {
[16:11:02.143]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.143]         }
[16:11:02.143]         base::close(...future.stdout)
[16:11:02.143]         ...future.stdout <- NULL
[16:11:02.143]     }
[16:11:02.143]     ...future.result$conditions <- ...future.conditions
[16:11:02.143]     ...future.result$finished <- base::Sys.time()
[16:11:02.143]     ...future.result
[16:11:02.143] }
[16:11:02.145] assign_globals() ...
[16:11:02.145] List of 11
[16:11:02.145]  $ ...future.FUN            :function (x, ...)  
[16:11:02.145]  $ x_FUN                    :function (x, y)  
[16:11:02.145]  $ times                    : int 15
[16:11:02.145]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.145]  $ stop_if_not              :function (...)  
[16:11:02.145]  $ dim                      : int [1:2] 3 5
[16:11:02.145]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:02.145]  $ future.call.arguments    :List of 1
[16:11:02.145]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:02.145]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.145]  $ ...future.elements_ii    :List of 2
[16:11:02.145]   ..$ A: num 50
[16:11:02.145]   ..$ B: num 60
[16:11:02.145]  $ ...future.seeds_ii       : NULL
[16:11:02.145]  $ ...future.globals.maxSize: NULL
[16:11:02.145]  - attr(*, "resolved")= logi FALSE
[16:11:02.145]  - attr(*, "total_size")= num 98600
[16:11:02.145]  - attr(*, "where")=List of 11
[16:11:02.145]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.145]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.145]  - attr(*, "already-done")= logi TRUE
[16:11:02.156] - copied ‘...future.FUN’ to environment
[16:11:02.156] - reassign environment for ‘x_FUN’
[16:11:02.156] - copied ‘x_FUN’ to environment
[16:11:02.156] - copied ‘times’ to environment
[16:11:02.156] - copied ‘stopf’ to environment
[16:11:02.156] - copied ‘stop_if_not’ to environment
[16:11:02.156] - copied ‘dim’ to environment
[16:11:02.156] - copied ‘valid_types’ to environment
[16:11:02.156] - copied ‘future.call.arguments’ to environment
[16:11:02.157] - copied ‘...future.elements_ii’ to environment
[16:11:02.157] - copied ‘...future.seeds_ii’ to environment
[16:11:02.157] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.157] assign_globals() ... done
[16:11:02.157] requestCore(): workers = 2
[16:11:02.159] MulticoreFuture started
[16:11:02.160] - Launch lazy future ... done
[16:11:02.160] run() for ‘MulticoreFuture’ ... done
[16:11:02.161] Created future:
[16:11:02.161] plan(): Setting new future strategy stack:
[16:11:02.161] List of future strategies:
[16:11:02.161] 1. sequential:
[16:11:02.161]    - args: function (..., envir = parent.frame())
[16:11:02.161]    - tweaked: FALSE
[16:11:02.161]    - call: NULL
[16:11:02.163] plan(): nbrOfWorkers() = 1
[16:11:02.166] plan(): Setting new future strategy stack:
[16:11:02.166] List of future strategies:
[16:11:02.166] 1. multicore:
[16:11:02.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.166]    - tweaked: FALSE
[16:11:02.166]    - call: plan(strategy)
[16:11:02.173] plan(): nbrOfWorkers() = 2
[16:11:02.161] MulticoreFuture:
[16:11:02.161] Label: ‘future_vapply-1’
[16:11:02.161] Expression:
[16:11:02.161] {
[16:11:02.161]     do.call(function(...) {
[16:11:02.161]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.161]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.161]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.161]             on.exit(options(oopts), add = TRUE)
[16:11:02.161]         }
[16:11:02.161]         {
[16:11:02.161]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.161]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.161]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.161]             })
[16:11:02.161]         }
[16:11:02.161]     }, args = future.call.arguments)
[16:11:02.161] }
[16:11:02.161] Lazy evaluation: FALSE
[16:11:02.161] Asynchronous evaluation: TRUE
[16:11:02.161] Local evaluation: TRUE
[16:11:02.161] Environment: R_GlobalEnv
[16:11:02.161] Capture standard output: TRUE
[16:11:02.161] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.161] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:02.161] Packages: 1 packages (‘future.apply’)
[16:11:02.161] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.161] Resolved: TRUE
[16:11:02.161] Value: <not collected>
[16:11:02.161] Conditions captured: <none>
[16:11:02.161] Early signaling: FALSE
[16:11:02.161] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.161] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.174] Chunk #1 of 2 ... DONE
[16:11:02.174] Chunk #2 of 2 ...
[16:11:02.175]  - Finding globals in 'X' for chunk #2 ...
[16:11:02.175] getGlobalsAndPackages() ...
[16:11:02.175] Searching for globals...
[16:11:02.176] 
[16:11:02.176] Searching for globals ... DONE
[16:11:02.176] - globals: [0] <none>
[16:11:02.176] getGlobalsAndPackages() ... DONE
[16:11:02.177]    + additional globals found: [n=0] 
[16:11:02.177]    + additional namespaces needed: [n=0] 
[16:11:02.177]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:02.177]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:02.177]  - seeds: <none>
[16:11:02.177] getGlobalsAndPackages() ...
[16:11:02.178] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.178] Resolving globals: FALSE
[16:11:02.178] Tweak future expression to call with '...' arguments ...
[16:11:02.178] {
[16:11:02.178]     do.call(function(...) {
[16:11:02.178]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.178]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.178]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.178]             on.exit(options(oopts), add = TRUE)
[16:11:02.178]         }
[16:11:02.178]         {
[16:11:02.178]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.178]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.178]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.178]             })
[16:11:02.178]         }
[16:11:02.178]     }, args = future.call.arguments)
[16:11:02.178] }
[16:11:02.179] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.180] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.180] - packages: [1] ‘future.apply’
[16:11:02.180] getGlobalsAndPackages() ... DONE
[16:11:02.181] run() for ‘Future’ ...
[16:11:02.181] - state: ‘created’
[16:11:02.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.186] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.187]   - Field: ‘label’
[16:11:02.187]   - Field: ‘local’
[16:11:02.187]   - Field: ‘owner’
[16:11:02.187]   - Field: ‘envir’
[16:11:02.187]   - Field: ‘workers’
[16:11:02.187]   - Field: ‘packages’
[16:11:02.187]   - Field: ‘gc’
[16:11:02.188]   - Field: ‘job’
[16:11:02.188]   - Field: ‘conditions’
[16:11:02.188]   - Field: ‘expr’
[16:11:02.188]   - Field: ‘uuid’
[16:11:02.188]   - Field: ‘seed’
[16:11:02.188]   - Field: ‘version’
[16:11:02.188]   - Field: ‘result’
[16:11:02.189]   - Field: ‘asynchronous’
[16:11:02.189]   - Field: ‘calls’
[16:11:02.189]   - Field: ‘globals’
[16:11:02.189]   - Field: ‘stdout’
[16:11:02.189]   - Field: ‘earlySignal’
[16:11:02.189]   - Field: ‘lazy’
[16:11:02.189]   - Field: ‘state’
[16:11:02.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.190] - Launch lazy future ...
[16:11:02.190] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:02.190] Packages needed by future strategies (n = 0): <none>
[16:11:02.191] {
[16:11:02.191]     {
[16:11:02.191]         {
[16:11:02.191]             ...future.startTime <- base::Sys.time()
[16:11:02.191]             {
[16:11:02.191]                 {
[16:11:02.191]                   {
[16:11:02.191]                     {
[16:11:02.191]                       {
[16:11:02.191]                         base::local({
[16:11:02.191]                           has_future <- base::requireNamespace("future", 
[16:11:02.191]                             quietly = TRUE)
[16:11:02.191]                           if (has_future) {
[16:11:02.191]                             ns <- base::getNamespace("future")
[16:11:02.191]                             version <- ns[[".package"]][["version"]]
[16:11:02.191]                             if (is.null(version)) 
[16:11:02.191]                               version <- utils::packageVersion("future")
[16:11:02.191]                           }
[16:11:02.191]                           else {
[16:11:02.191]                             version <- NULL
[16:11:02.191]                           }
[16:11:02.191]                           if (!has_future || version < "1.8.0") {
[16:11:02.191]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.191]                               "", base::R.version$version.string), 
[16:11:02.191]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:02.191]                                 base::R.version$platform, 8 * 
[16:11:02.191]                                   base::.Machine$sizeof.pointer), 
[16:11:02.191]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.191]                                 "release", "version")], collapse = " "), 
[16:11:02.191]                               hostname = base::Sys.info()[["nodename"]])
[16:11:02.191]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.191]                               info)
[16:11:02.191]                             info <- base::paste(info, collapse = "; ")
[16:11:02.191]                             if (!has_future) {
[16:11:02.191]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.191]                                 info)
[16:11:02.191]                             }
[16:11:02.191]                             else {
[16:11:02.191]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.191]                                 info, version)
[16:11:02.191]                             }
[16:11:02.191]                             base::stop(msg)
[16:11:02.191]                           }
[16:11:02.191]                         })
[16:11:02.191]                       }
[16:11:02.191]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.191]                       base::options(mc.cores = 1L)
[16:11:02.191]                     }
[16:11:02.191]                     base::local({
[16:11:02.191]                       for (pkg in "future.apply") {
[16:11:02.191]                         base::loadNamespace(pkg)
[16:11:02.191]                         base::library(pkg, character.only = TRUE)
[16:11:02.191]                       }
[16:11:02.191]                     })
[16:11:02.191]                   }
[16:11:02.191]                   options(future.plan = NULL)
[16:11:02.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.191]                 }
[16:11:02.191]                 ...future.workdir <- getwd()
[16:11:02.191]             }
[16:11:02.191]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.191]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.191]         }
[16:11:02.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.191]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:02.191]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.191]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.191]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.191]             base::names(...future.oldOptions))
[16:11:02.191]     }
[16:11:02.191]     if (FALSE) {
[16:11:02.191]     }
[16:11:02.191]     else {
[16:11:02.191]         if (TRUE) {
[16:11:02.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.191]                 open = "w")
[16:11:02.191]         }
[16:11:02.191]         else {
[16:11:02.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.191]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.191]         }
[16:11:02.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.191]             base::sink(type = "output", split = FALSE)
[16:11:02.191]             base::close(...future.stdout)
[16:11:02.191]         }, add = TRUE)
[16:11:02.191]     }
[16:11:02.191]     ...future.frame <- base::sys.nframe()
[16:11:02.191]     ...future.conditions <- base::list()
[16:11:02.191]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.191]     if (FALSE) {
[16:11:02.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.191]     }
[16:11:02.191]     ...future.result <- base::tryCatch({
[16:11:02.191]         base::withCallingHandlers({
[16:11:02.191]             ...future.value <- base::withVisible(base::local({
[16:11:02.191]                 withCallingHandlers({
[16:11:02.191]                   {
[16:11:02.191]                     do.call(function(...) {
[16:11:02.191]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.191]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.191]                         ...future.globals.maxSize)) {
[16:11:02.191]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.191]                         on.exit(options(oopts), add = TRUE)
[16:11:02.191]                       }
[16:11:02.191]                       {
[16:11:02.191]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.191]                           FUN = function(jj) {
[16:11:02.191]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.191]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.191]                           })
[16:11:02.191]                       }
[16:11:02.191]                     }, args = future.call.arguments)
[16:11:02.191]                   }
[16:11:02.191]                 }, immediateCondition = function(cond) {
[16:11:02.191]                   save_rds <- function (object, pathname, ...) 
[16:11:02.191]                   {
[16:11:02.191]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.191]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.191]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.191]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.191]                         fi_tmp[["mtime"]])
[16:11:02.191]                     }
[16:11:02.191]                     tryCatch({
[16:11:02.191]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.191]                     }, error = function(ex) {
[16:11:02.191]                       msg <- conditionMessage(ex)
[16:11:02.191]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.191]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.191]                         fi_tmp[["mtime"]], msg)
[16:11:02.191]                       ex$message <- msg
[16:11:02.191]                       stop(ex)
[16:11:02.191]                     })
[16:11:02.191]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.191]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.191]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.191]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.191]                       fi <- file.info(pathname)
[16:11:02.191]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.191]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.191]                         fi[["size"]], fi[["mtime"]])
[16:11:02.191]                       stop(msg)
[16:11:02.191]                     }
[16:11:02.191]                     invisible(pathname)
[16:11:02.191]                   }
[16:11:02.191]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.191]                     rootPath = tempdir()) 
[16:11:02.191]                   {
[16:11:02.191]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.191]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.191]                       tmpdir = path, fileext = ".rds")
[16:11:02.191]                     save_rds(obj, file)
[16:11:02.191]                   }
[16:11:02.191]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.191]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.191]                   {
[16:11:02.191]                     inherits <- base::inherits
[16:11:02.191]                     invokeRestart <- base::invokeRestart
[16:11:02.191]                     is.null <- base::is.null
[16:11:02.191]                     muffled <- FALSE
[16:11:02.191]                     if (inherits(cond, "message")) {
[16:11:02.191]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.191]                       if (muffled) 
[16:11:02.191]                         invokeRestart("muffleMessage")
[16:11:02.191]                     }
[16:11:02.191]                     else if (inherits(cond, "warning")) {
[16:11:02.191]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.191]                       if (muffled) 
[16:11:02.191]                         invokeRestart("muffleWarning")
[16:11:02.191]                     }
[16:11:02.191]                     else if (inherits(cond, "condition")) {
[16:11:02.191]                       if (!is.null(pattern)) {
[16:11:02.191]                         computeRestarts <- base::computeRestarts
[16:11:02.191]                         grepl <- base::grepl
[16:11:02.191]                         restarts <- computeRestarts(cond)
[16:11:02.191]                         for (restart in restarts) {
[16:11:02.191]                           name <- restart$name
[16:11:02.191]                           if (is.null(name)) 
[16:11:02.191]                             next
[16:11:02.191]                           if (!grepl(pattern, name)) 
[16:11:02.191]                             next
[16:11:02.191]                           invokeRestart(restart)
[16:11:02.191]                           muffled <- TRUE
[16:11:02.191]                           break
[16:11:02.191]                         }
[16:11:02.191]                       }
[16:11:02.191]                     }
[16:11:02.191]                     invisible(muffled)
[16:11:02.191]                   }
[16:11:02.191]                   muffleCondition(cond)
[16:11:02.191]                 })
[16:11:02.191]             }))
[16:11:02.191]             future::FutureResult(value = ...future.value$value, 
[16:11:02.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.191]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.191]                     ...future.globalenv.names))
[16:11:02.191]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.191]         }, condition = base::local({
[16:11:02.191]             c <- base::c
[16:11:02.191]             inherits <- base::inherits
[16:11:02.191]             invokeRestart <- base::invokeRestart
[16:11:02.191]             length <- base::length
[16:11:02.191]             list <- base::list
[16:11:02.191]             seq.int <- base::seq.int
[16:11:02.191]             signalCondition <- base::signalCondition
[16:11:02.191]             sys.calls <- base::sys.calls
[16:11:02.191]             `[[` <- base::`[[`
[16:11:02.191]             `+` <- base::`+`
[16:11:02.191]             `<<-` <- base::`<<-`
[16:11:02.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.191]                   3L)]
[16:11:02.191]             }
[16:11:02.191]             function(cond) {
[16:11:02.191]                 is_error <- inherits(cond, "error")
[16:11:02.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.191]                   NULL)
[16:11:02.191]                 if (is_error) {
[16:11:02.191]                   sessionInformation <- function() {
[16:11:02.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.191]                       search = base::search(), system = base::Sys.info())
[16:11:02.191]                   }
[16:11:02.191]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.191]                     cond$call), session = sessionInformation(), 
[16:11:02.191]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.191]                   signalCondition(cond)
[16:11:02.191]                 }
[16:11:02.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.191]                 "immediateCondition"))) {
[16:11:02.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.191]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.191]                   if (TRUE && !signal) {
[16:11:02.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.191]                     {
[16:11:02.191]                       inherits <- base::inherits
[16:11:02.191]                       invokeRestart <- base::invokeRestart
[16:11:02.191]                       is.null <- base::is.null
[16:11:02.191]                       muffled <- FALSE
[16:11:02.191]                       if (inherits(cond, "message")) {
[16:11:02.191]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.191]                         if (muffled) 
[16:11:02.191]                           invokeRestart("muffleMessage")
[16:11:02.191]                       }
[16:11:02.191]                       else if (inherits(cond, "warning")) {
[16:11:02.191]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.191]                         if (muffled) 
[16:11:02.191]                           invokeRestart("muffleWarning")
[16:11:02.191]                       }
[16:11:02.191]                       else if (inherits(cond, "condition")) {
[16:11:02.191]                         if (!is.null(pattern)) {
[16:11:02.191]                           computeRestarts <- base::computeRestarts
[16:11:02.191]                           grepl <- base::grepl
[16:11:02.191]                           restarts <- computeRestarts(cond)
[16:11:02.191]                           for (restart in restarts) {
[16:11:02.191]                             name <- restart$name
[16:11:02.191]                             if (is.null(name)) 
[16:11:02.191]                               next
[16:11:02.191]                             if (!grepl(pattern, name)) 
[16:11:02.191]                               next
[16:11:02.191]                             invokeRestart(restart)
[16:11:02.191]                             muffled <- TRUE
[16:11:02.191]                             break
[16:11:02.191]                           }
[16:11:02.191]                         }
[16:11:02.191]                       }
[16:11:02.191]                       invisible(muffled)
[16:11:02.191]                     }
[16:11:02.191]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.191]                   }
[16:11:02.191]                 }
[16:11:02.191]                 else {
[16:11:02.191]                   if (TRUE) {
[16:11:02.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.191]                     {
[16:11:02.191]                       inherits <- base::inherits
[16:11:02.191]                       invokeRestart <- base::invokeRestart
[16:11:02.191]                       is.null <- base::is.null
[16:11:02.191]                       muffled <- FALSE
[16:11:02.191]                       if (inherits(cond, "message")) {
[16:11:02.191]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.191]                         if (muffled) 
[16:11:02.191]                           invokeRestart("muffleMessage")
[16:11:02.191]                       }
[16:11:02.191]                       else if (inherits(cond, "warning")) {
[16:11:02.191]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.191]                         if (muffled) 
[16:11:02.191]                           invokeRestart("muffleWarning")
[16:11:02.191]                       }
[16:11:02.191]                       else if (inherits(cond, "condition")) {
[16:11:02.191]                         if (!is.null(pattern)) {
[16:11:02.191]                           computeRestarts <- base::computeRestarts
[16:11:02.191]                           grepl <- base::grepl
[16:11:02.191]                           restarts <- computeRestarts(cond)
[16:11:02.191]                           for (restart in restarts) {
[16:11:02.191]                             name <- restart$name
[16:11:02.191]                             if (is.null(name)) 
[16:11:02.191]                               next
[16:11:02.191]                             if (!grepl(pattern, name)) 
[16:11:02.191]                               next
[16:11:02.191]                             invokeRestart(restart)
[16:11:02.191]                             muffled <- TRUE
[16:11:02.191]                             break
[16:11:02.191]                           }
[16:11:02.191]                         }
[16:11:02.191]                       }
[16:11:02.191]                       invisible(muffled)
[16:11:02.191]                     }
[16:11:02.191]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.191]                   }
[16:11:02.191]                 }
[16:11:02.191]             }
[16:11:02.191]         }))
[16:11:02.191]     }, error = function(ex) {
[16:11:02.191]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.191]                 ...future.rng), started = ...future.startTime, 
[16:11:02.191]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.191]             version = "1.8"), class = "FutureResult")
[16:11:02.191]     }, finally = {
[16:11:02.191]         if (!identical(...future.workdir, getwd())) 
[16:11:02.191]             setwd(...future.workdir)
[16:11:02.191]         {
[16:11:02.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.191]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.191]             }
[16:11:02.191]             base::options(...future.oldOptions)
[16:11:02.191]             if (.Platform$OS.type == "windows") {
[16:11:02.191]                 old_names <- names(...future.oldEnvVars)
[16:11:02.191]                 envs <- base::Sys.getenv()
[16:11:02.191]                 names <- names(envs)
[16:11:02.191]                 common <- intersect(names, old_names)
[16:11:02.191]                 added <- setdiff(names, old_names)
[16:11:02.191]                 removed <- setdiff(old_names, names)
[16:11:02.191]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.191]                   envs[common]]
[16:11:02.191]                 NAMES <- toupper(changed)
[16:11:02.191]                 args <- list()
[16:11:02.191]                 for (kk in seq_along(NAMES)) {
[16:11:02.191]                   name <- changed[[kk]]
[16:11:02.191]                   NAME <- NAMES[[kk]]
[16:11:02.191]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.191]                     next
[16:11:02.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.191]                 }
[16:11:02.191]                 NAMES <- toupper(added)
[16:11:02.191]                 for (kk in seq_along(NAMES)) {
[16:11:02.191]                   name <- added[[kk]]
[16:11:02.191]                   NAME <- NAMES[[kk]]
[16:11:02.191]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.191]                     next
[16:11:02.191]                   args[[name]] <- ""
[16:11:02.191]                 }
[16:11:02.191]                 NAMES <- toupper(removed)
[16:11:02.191]                 for (kk in seq_along(NAMES)) {
[16:11:02.191]                   name <- removed[[kk]]
[16:11:02.191]                   NAME <- NAMES[[kk]]
[16:11:02.191]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.191]                     next
[16:11:02.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.191]                 }
[16:11:02.191]                 if (length(args) > 0) 
[16:11:02.191]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.191]             }
[16:11:02.191]             else {
[16:11:02.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.191]             }
[16:11:02.191]             {
[16:11:02.191]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.191]                   0L) {
[16:11:02.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.191]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.191]                   base::options(opts)
[16:11:02.191]                 }
[16:11:02.191]                 {
[16:11:02.191]                   {
[16:11:02.191]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.191]                     NULL
[16:11:02.191]                   }
[16:11:02.191]                   options(future.plan = NULL)
[16:11:02.191]                   if (is.na(NA_character_)) 
[16:11:02.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.191]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.191]                     envir = parent.frame()) 
[16:11:02.191]                   {
[16:11:02.191]                     default_workers <- missing(workers)
[16:11:02.191]                     if (is.function(workers)) 
[16:11:02.191]                       workers <- workers()
[16:11:02.191]                     workers <- structure(as.integer(workers), 
[16:11:02.191]                       class = class(workers))
[16:11:02.191]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.191]                       1L)
[16:11:02.191]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.191]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.191]                       if (default_workers) 
[16:11:02.191]                         supportsMulticore(warn = TRUE)
[16:11:02.191]                       return(sequential(..., envir = envir))
[16:11:02.191]                     }
[16:11:02.191]                     oopts <- options(mc.cores = workers)
[16:11:02.191]                     on.exit(options(oopts))
[16:11:02.191]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.191]                       envir = envir)
[16:11:02.191]                     if (!future$lazy) 
[16:11:02.191]                       future <- run(future)
[16:11:02.191]                     invisible(future)
[16:11:02.191]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.191]                 }
[16:11:02.191]             }
[16:11:02.191]         }
[16:11:02.191]     })
[16:11:02.191]     if (TRUE) {
[16:11:02.191]         base::sink(type = "output", split = FALSE)
[16:11:02.191]         if (TRUE) {
[16:11:02.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.191]         }
[16:11:02.191]         else {
[16:11:02.191]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.191]         }
[16:11:02.191]         base::close(...future.stdout)
[16:11:02.191]         ...future.stdout <- NULL
[16:11:02.191]     }
[16:11:02.191]     ...future.result$conditions <- ...future.conditions
[16:11:02.191]     ...future.result$finished <- base::Sys.time()
[16:11:02.191]     ...future.result
[16:11:02.191] }
[16:11:02.195] assign_globals() ...
[16:11:02.195] List of 11
[16:11:02.195]  $ ...future.FUN            :function (x, ...)  
[16:11:02.195]  $ x_FUN                    :function (x, y)  
[16:11:02.195]  $ times                    : int 15
[16:11:02.195]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.195]  $ stop_if_not              :function (...)  
[16:11:02.195]  $ dim                      : int [1:2] 3 5
[16:11:02.195]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:02.195]  $ future.call.arguments    :List of 1
[16:11:02.195]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:02.195]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.195]  $ ...future.elements_ii    :List of 2
[16:11:02.195]   ..$ C: num 70
[16:11:02.195]   ..$ D: num 80
[16:11:02.195]  $ ...future.seeds_ii       : NULL
[16:11:02.195]  $ ...future.globals.maxSize: NULL
[16:11:02.195]  - attr(*, "resolved")= logi FALSE
[16:11:02.195]  - attr(*, "total_size")= num 98600
[16:11:02.195]  - attr(*, "where")=List of 11
[16:11:02.195]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.195]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.195]  - attr(*, "already-done")= logi TRUE
[16:11:02.210] - copied ‘...future.FUN’ to environment
[16:11:02.210] - reassign environment for ‘x_FUN’
[16:11:02.210] - copied ‘x_FUN’ to environment
[16:11:02.210] - copied ‘times’ to environment
[16:11:02.210] - copied ‘stopf’ to environment
[16:11:02.210] - copied ‘stop_if_not’ to environment
[16:11:02.210] - copied ‘dim’ to environment
[16:11:02.210] - copied ‘valid_types’ to environment
[16:11:02.211] - copied ‘future.call.arguments’ to environment
[16:11:02.211] - copied ‘...future.elements_ii’ to environment
[16:11:02.211] - copied ‘...future.seeds_ii’ to environment
[16:11:02.211] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.211] assign_globals() ... done
[16:11:02.211] requestCore(): workers = 2
[16:11:02.213] MulticoreFuture started
[16:11:02.214] - Launch lazy future ... done
[16:11:02.214] run() for ‘MulticoreFuture’ ... done
[16:11:02.215] Created future:
[16:11:02.215] plan(): Setting new future strategy stack:
[16:11:02.215] List of future strategies:
[16:11:02.215] 1. sequential:
[16:11:02.215]    - args: function (..., envir = parent.frame())
[16:11:02.215]    - tweaked: FALSE
[16:11:02.215]    - call: NULL
[16:11:02.216] plan(): nbrOfWorkers() = 1
[16:11:02.219] plan(): Setting new future strategy stack:
[16:11:02.219] List of future strategies:
[16:11:02.219] 1. multicore:
[16:11:02.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.219]    - tweaked: FALSE
[16:11:02.219]    - call: plan(strategy)
[16:11:02.225] plan(): nbrOfWorkers() = 2
[16:11:02.215] MulticoreFuture:
[16:11:02.215] Label: ‘future_vapply-2’
[16:11:02.215] Expression:
[16:11:02.215] {
[16:11:02.215]     do.call(function(...) {
[16:11:02.215]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.215]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.215]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.215]             on.exit(options(oopts), add = TRUE)
[16:11:02.215]         }
[16:11:02.215]         {
[16:11:02.215]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.215]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.215]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.215]             })
[16:11:02.215]         }
[16:11:02.215]     }, args = future.call.arguments)
[16:11:02.215] }
[16:11:02.215] Lazy evaluation: FALSE
[16:11:02.215] Asynchronous evaluation: TRUE
[16:11:02.215] Local evaluation: TRUE
[16:11:02.215] Environment: R_GlobalEnv
[16:11:02.215] Capture standard output: TRUE
[16:11:02.215] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.215] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:02.215] Packages: 1 packages (‘future.apply’)
[16:11:02.215] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.215] Resolved: TRUE
[16:11:02.215] Value: <not collected>
[16:11:02.215] Conditions captured: <none>
[16:11:02.215] Early signaling: FALSE
[16:11:02.215] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.215] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.226] Chunk #2 of 2 ... DONE
[16:11:02.226] Launching 2 futures (chunks) ... DONE
[16:11:02.226] Resolving 2 futures (chunks) ...
[16:11:02.227] resolve() on list ...
[16:11:02.227]  recursive: 0
[16:11:02.227]  length: 2
[16:11:02.227] 
[16:11:02.228] Future #1
[16:11:02.229] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:02.229] - nx: 2
[16:11:02.229] - relay: TRUE
[16:11:02.229] - stdout: TRUE
[16:11:02.229] - signal: TRUE
[16:11:02.229] - resignal: FALSE
[16:11:02.230] - force: TRUE
[16:11:02.230] - relayed: [n=2] FALSE, FALSE
[16:11:02.230] - queued futures: [n=2] FALSE, FALSE
[16:11:02.230]  - until=1
[16:11:02.230]  - relaying element #1
[16:11:02.231] - relayed: [n=2] TRUE, FALSE
[16:11:02.231] - queued futures: [n=2] TRUE, FALSE
[16:11:02.231] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:02.231]  length: 1 (resolved future 1)
[16:11:02.232] Future #2
[16:11:02.232] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:02.233] - nx: 2
[16:11:02.233] - relay: TRUE
[16:11:02.233] - stdout: TRUE
[16:11:02.233] - signal: TRUE
[16:11:02.233] - resignal: FALSE
[16:11:02.233] - force: TRUE
[16:11:02.233] - relayed: [n=2] TRUE, FALSE
[16:11:02.234] - queued futures: [n=2] TRUE, FALSE
[16:11:02.234]  - until=2
[16:11:02.234]  - relaying element #2
[16:11:02.234] - relayed: [n=2] TRUE, TRUE
[16:11:02.234] - queued futures: [n=2] TRUE, TRUE
[16:11:02.234] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:02.234]  length: 0 (resolved future 2)
[16:11:02.235] Relaying remaining futures
[16:11:02.235] signalConditionsASAP(NULL, pos=0) ...
[16:11:02.235] - nx: 2
[16:11:02.235] - relay: TRUE
[16:11:02.235] - stdout: TRUE
[16:11:02.235] - signal: TRUE
[16:11:02.235] - resignal: FALSE
[16:11:02.235] - force: TRUE
[16:11:02.235] - relayed: [n=2] TRUE, TRUE
[16:11:02.235] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:02.236] - relayed: [n=2] TRUE, TRUE
[16:11:02.236] - queued futures: [n=2] TRUE, TRUE
[16:11:02.236] signalConditionsASAP(NULL, pos=0) ... done
[16:11:02.236] resolve() on list ... DONE
[16:11:02.236]  - Number of value chunks collected: 2
[16:11:02.236] Resolving 2 futures (chunks) ... DONE
[16:11:02.237] Reducing values from 2 chunks ...
[16:11:02.237]  - Number of values collected after concatenation: 4
[16:11:02.237]  - Number of values expected: 4
[16:11:02.237] Reducing values from 2 chunks ... DONE
[16:11:02.237] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:11:02.239] future_lapply() ...
[16:11:02.249] Number of chunks: 2
[16:11:02.249] getGlobalsAndPackagesXApply() ...
[16:11:02.249]  - future.globals: TRUE
[16:11:02.249] getGlobalsAndPackages() ...
[16:11:02.249] Searching for globals...
[16:11:02.254] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:02.254] Searching for globals ... DONE
[16:11:02.254] Resolving globals: FALSE
[16:11:02.255] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:11:02.255] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:02.256] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:02.256] - packages: [1] ‘future.apply’
[16:11:02.256] getGlobalsAndPackages() ... DONE
[16:11:02.256]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:02.256]  - needed namespaces: [n=1] ‘future.apply’
[16:11:02.256] Finding globals ... DONE
[16:11:02.256]  - use_args: TRUE
[16:11:02.256]  - Getting '...' globals ...
[16:11:02.257] resolve() on list ...
[16:11:02.257]  recursive: 0
[16:11:02.257]  length: 1
[16:11:02.257]  elements: ‘...’
[16:11:02.257]  length: 0 (resolved future 1)
[16:11:02.257] resolve() on list ... DONE
[16:11:02.257]    - '...' content: [n=0] 
[16:11:02.258] List of 1
[16:11:02.258]  $ ...: list()
[16:11:02.258]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.258]  - attr(*, "where")=List of 1
[16:11:02.258]   ..$ ...:<environment: 0x561e8a187d88> 
[16:11:02.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.258]  - attr(*, "resolved")= logi TRUE
[16:11:02.258]  - attr(*, "total_size")= num NA
[16:11:02.260]  - Getting '...' globals ... DONE
[16:11:02.260] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:02.260] List of 8
[16:11:02.260]  $ ...future.FUN:function (x, ...)  
[16:11:02.260]  $ x_FUN        :function (x)  
[16:11:02.260]  $ times        : int 1
[16:11:02.260]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.260]  $ stop_if_not  :function (...)  
[16:11:02.260]  $ dim          : NULL
[16:11:02.260]  $ valid_types  : chr "logical"
[16:11:02.260]  $ ...          : list()
[16:11:02.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.260]  - attr(*, "where")=List of 8
[16:11:02.260]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:02.260]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:02.260]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:02.260]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:02.260]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:02.260]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:02.260]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:02.260]   ..$ ...          :<environment: 0x561e8a187d88> 
[16:11:02.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.260]  - attr(*, "resolved")= logi FALSE
[16:11:02.260]  - attr(*, "total_size")= num 94200
[16:11:02.268] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:02.268] getGlobalsAndPackagesXApply() ... DONE
[16:11:02.269] Number of futures (= number of chunks): 2
[16:11:02.269] Launching 2 futures (chunks) ...
[16:11:02.269] Chunk #1 of 2 ...
[16:11:02.269]  - Finding globals in 'X' for chunk #1 ...
[16:11:02.269] getGlobalsAndPackages() ...
[16:11:02.269] Searching for globals...
[16:11:02.269] 
[16:11:02.270] Searching for globals ... DONE
[16:11:02.270] - globals: [0] <none>
[16:11:02.270] getGlobalsAndPackages() ... DONE
[16:11:02.270]    + additional globals found: [n=0] 
[16:11:02.270]    + additional namespaces needed: [n=0] 
[16:11:02.270]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:02.270]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[16:11:02.270]  - seeds: <none>
[16:11:02.270] getGlobalsAndPackages() ...
[16:11:02.270] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.271] Resolving globals: FALSE
[16:11:02.271] Tweak future expression to call with '...' arguments ...
[16:11:02.271] {
[16:11:02.271]     do.call(function(...) {
[16:11:02.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.271]             on.exit(options(oopts), add = TRUE)
[16:11:02.271]         }
[16:11:02.271]         {
[16:11:02.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.271]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.271]             })
[16:11:02.271]         }
[16:11:02.271]     }, args = future.call.arguments)
[16:11:02.271] }
[16:11:02.271] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.272] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.272] - packages: [1] ‘future.apply’
[16:11:02.272] getGlobalsAndPackages() ... DONE
[16:11:02.272] run() for ‘Future’ ...
[16:11:02.272] - state: ‘created’
[16:11:02.273] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.276] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.277] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.277]   - Field: ‘label’
[16:11:02.277]   - Field: ‘local’
[16:11:02.277]   - Field: ‘owner’
[16:11:02.277]   - Field: ‘envir’
[16:11:02.277]   - Field: ‘workers’
[16:11:02.277]   - Field: ‘packages’
[16:11:02.277]   - Field: ‘gc’
[16:11:02.277]   - Field: ‘job’
[16:11:02.278]   - Field: ‘conditions’
[16:11:02.278]   - Field: ‘expr’
[16:11:02.278]   - Field: ‘uuid’
[16:11:02.278]   - Field: ‘seed’
[16:11:02.278]   - Field: ‘version’
[16:11:02.278]   - Field: ‘result’
[16:11:02.278]   - Field: ‘asynchronous’
[16:11:02.278]   - Field: ‘calls’
[16:11:02.278]   - Field: ‘globals’
[16:11:02.278]   - Field: ‘stdout’
[16:11:02.279]   - Field: ‘earlySignal’
[16:11:02.279]   - Field: ‘lazy’
[16:11:02.279]   - Field: ‘state’
[16:11:02.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.279] - Launch lazy future ...
[16:11:02.279] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:02.279] Packages needed by future strategies (n = 0): <none>
[16:11:02.280] {
[16:11:02.280]     {
[16:11:02.280]         {
[16:11:02.280]             ...future.startTime <- base::Sys.time()
[16:11:02.280]             {
[16:11:02.280]                 {
[16:11:02.280]                   {
[16:11:02.280]                     {
[16:11:02.280]                       {
[16:11:02.280]                         base::local({
[16:11:02.280]                           has_future <- base::requireNamespace("future", 
[16:11:02.280]                             quietly = TRUE)
[16:11:02.280]                           if (has_future) {
[16:11:02.280]                             ns <- base::getNamespace("future")
[16:11:02.280]                             version <- ns[[".package"]][["version"]]
[16:11:02.280]                             if (is.null(version)) 
[16:11:02.280]                               version <- utils::packageVersion("future")
[16:11:02.280]                           }
[16:11:02.280]                           else {
[16:11:02.280]                             version <- NULL
[16:11:02.280]                           }
[16:11:02.280]                           if (!has_future || version < "1.8.0") {
[16:11:02.280]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.280]                               "", base::R.version$version.string), 
[16:11:02.280]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:02.280]                                 base::R.version$platform, 8 * 
[16:11:02.280]                                   base::.Machine$sizeof.pointer), 
[16:11:02.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.280]                                 "release", "version")], collapse = " "), 
[16:11:02.280]                               hostname = base::Sys.info()[["nodename"]])
[16:11:02.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.280]                               info)
[16:11:02.280]                             info <- base::paste(info, collapse = "; ")
[16:11:02.280]                             if (!has_future) {
[16:11:02.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.280]                                 info)
[16:11:02.280]                             }
[16:11:02.280]                             else {
[16:11:02.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.280]                                 info, version)
[16:11:02.280]                             }
[16:11:02.280]                             base::stop(msg)
[16:11:02.280]                           }
[16:11:02.280]                         })
[16:11:02.280]                       }
[16:11:02.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.280]                       base::options(mc.cores = 1L)
[16:11:02.280]                     }
[16:11:02.280]                     base::local({
[16:11:02.280]                       for (pkg in "future.apply") {
[16:11:02.280]                         base::loadNamespace(pkg)
[16:11:02.280]                         base::library(pkg, character.only = TRUE)
[16:11:02.280]                       }
[16:11:02.280]                     })
[16:11:02.280]                   }
[16:11:02.280]                   options(future.plan = NULL)
[16:11:02.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.280]                 }
[16:11:02.280]                 ...future.workdir <- getwd()
[16:11:02.280]             }
[16:11:02.280]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.280]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.280]         }
[16:11:02.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.280]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[16:11:02.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.280]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.280]             base::names(...future.oldOptions))
[16:11:02.280]     }
[16:11:02.280]     if (FALSE) {
[16:11:02.280]     }
[16:11:02.280]     else {
[16:11:02.280]         if (TRUE) {
[16:11:02.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.280]                 open = "w")
[16:11:02.280]         }
[16:11:02.280]         else {
[16:11:02.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.280]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.280]         }
[16:11:02.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.280]             base::sink(type = "output", split = FALSE)
[16:11:02.280]             base::close(...future.stdout)
[16:11:02.280]         }, add = TRUE)
[16:11:02.280]     }
[16:11:02.280]     ...future.frame <- base::sys.nframe()
[16:11:02.280]     ...future.conditions <- base::list()
[16:11:02.280]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.280]     if (FALSE) {
[16:11:02.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.280]     }
[16:11:02.280]     ...future.result <- base::tryCatch({
[16:11:02.280]         base::withCallingHandlers({
[16:11:02.280]             ...future.value <- base::withVisible(base::local({
[16:11:02.280]                 withCallingHandlers({
[16:11:02.280]                   {
[16:11:02.280]                     do.call(function(...) {
[16:11:02.280]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.280]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.280]                         ...future.globals.maxSize)) {
[16:11:02.280]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.280]                         on.exit(options(oopts), add = TRUE)
[16:11:02.280]                       }
[16:11:02.280]                       {
[16:11:02.280]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.280]                           FUN = function(jj) {
[16:11:02.280]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.280]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.280]                           })
[16:11:02.280]                       }
[16:11:02.280]                     }, args = future.call.arguments)
[16:11:02.280]                   }
[16:11:02.280]                 }, immediateCondition = function(cond) {
[16:11:02.280]                   save_rds <- function (object, pathname, ...) 
[16:11:02.280]                   {
[16:11:02.280]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.280]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.280]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.280]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.280]                         fi_tmp[["mtime"]])
[16:11:02.280]                     }
[16:11:02.280]                     tryCatch({
[16:11:02.280]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.280]                     }, error = function(ex) {
[16:11:02.280]                       msg <- conditionMessage(ex)
[16:11:02.280]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.280]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.280]                         fi_tmp[["mtime"]], msg)
[16:11:02.280]                       ex$message <- msg
[16:11:02.280]                       stop(ex)
[16:11:02.280]                     })
[16:11:02.280]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.280]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.280]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.280]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.280]                       fi <- file.info(pathname)
[16:11:02.280]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.280]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.280]                         fi[["size"]], fi[["mtime"]])
[16:11:02.280]                       stop(msg)
[16:11:02.280]                     }
[16:11:02.280]                     invisible(pathname)
[16:11:02.280]                   }
[16:11:02.280]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.280]                     rootPath = tempdir()) 
[16:11:02.280]                   {
[16:11:02.280]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.280]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.280]                       tmpdir = path, fileext = ".rds")
[16:11:02.280]                     save_rds(obj, file)
[16:11:02.280]                   }
[16:11:02.280]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.280]                   {
[16:11:02.280]                     inherits <- base::inherits
[16:11:02.280]                     invokeRestart <- base::invokeRestart
[16:11:02.280]                     is.null <- base::is.null
[16:11:02.280]                     muffled <- FALSE
[16:11:02.280]                     if (inherits(cond, "message")) {
[16:11:02.280]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.280]                       if (muffled) 
[16:11:02.280]                         invokeRestart("muffleMessage")
[16:11:02.280]                     }
[16:11:02.280]                     else if (inherits(cond, "warning")) {
[16:11:02.280]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.280]                       if (muffled) 
[16:11:02.280]                         invokeRestart("muffleWarning")
[16:11:02.280]                     }
[16:11:02.280]                     else if (inherits(cond, "condition")) {
[16:11:02.280]                       if (!is.null(pattern)) {
[16:11:02.280]                         computeRestarts <- base::computeRestarts
[16:11:02.280]                         grepl <- base::grepl
[16:11:02.280]                         restarts <- computeRestarts(cond)
[16:11:02.280]                         for (restart in restarts) {
[16:11:02.280]                           name <- restart$name
[16:11:02.280]                           if (is.null(name)) 
[16:11:02.280]                             next
[16:11:02.280]                           if (!grepl(pattern, name)) 
[16:11:02.280]                             next
[16:11:02.280]                           invokeRestart(restart)
[16:11:02.280]                           muffled <- TRUE
[16:11:02.280]                           break
[16:11:02.280]                         }
[16:11:02.280]                       }
[16:11:02.280]                     }
[16:11:02.280]                     invisible(muffled)
[16:11:02.280]                   }
[16:11:02.280]                   muffleCondition(cond)
[16:11:02.280]                 })
[16:11:02.280]             }))
[16:11:02.280]             future::FutureResult(value = ...future.value$value, 
[16:11:02.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.280]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.280]                     ...future.globalenv.names))
[16:11:02.280]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.280]         }, condition = base::local({
[16:11:02.280]             c <- base::c
[16:11:02.280]             inherits <- base::inherits
[16:11:02.280]             invokeRestart <- base::invokeRestart
[16:11:02.280]             length <- base::length
[16:11:02.280]             list <- base::list
[16:11:02.280]             seq.int <- base::seq.int
[16:11:02.280]             signalCondition <- base::signalCondition
[16:11:02.280]             sys.calls <- base::sys.calls
[16:11:02.280]             `[[` <- base::`[[`
[16:11:02.280]             `+` <- base::`+`
[16:11:02.280]             `<<-` <- base::`<<-`
[16:11:02.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.280]                   3L)]
[16:11:02.280]             }
[16:11:02.280]             function(cond) {
[16:11:02.280]                 is_error <- inherits(cond, "error")
[16:11:02.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.280]                   NULL)
[16:11:02.280]                 if (is_error) {
[16:11:02.280]                   sessionInformation <- function() {
[16:11:02.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.280]                       search = base::search(), system = base::Sys.info())
[16:11:02.280]                   }
[16:11:02.280]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.280]                     cond$call), session = sessionInformation(), 
[16:11:02.280]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.280]                   signalCondition(cond)
[16:11:02.280]                 }
[16:11:02.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.280]                 "immediateCondition"))) {
[16:11:02.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.280]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.280]                   if (TRUE && !signal) {
[16:11:02.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.280]                     {
[16:11:02.280]                       inherits <- base::inherits
[16:11:02.280]                       invokeRestart <- base::invokeRestart
[16:11:02.280]                       is.null <- base::is.null
[16:11:02.280]                       muffled <- FALSE
[16:11:02.280]                       if (inherits(cond, "message")) {
[16:11:02.280]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.280]                         if (muffled) 
[16:11:02.280]                           invokeRestart("muffleMessage")
[16:11:02.280]                       }
[16:11:02.280]                       else if (inherits(cond, "warning")) {
[16:11:02.280]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.280]                         if (muffled) 
[16:11:02.280]                           invokeRestart("muffleWarning")
[16:11:02.280]                       }
[16:11:02.280]                       else if (inherits(cond, "condition")) {
[16:11:02.280]                         if (!is.null(pattern)) {
[16:11:02.280]                           computeRestarts <- base::computeRestarts
[16:11:02.280]                           grepl <- base::grepl
[16:11:02.280]                           restarts <- computeRestarts(cond)
[16:11:02.280]                           for (restart in restarts) {
[16:11:02.280]                             name <- restart$name
[16:11:02.280]                             if (is.null(name)) 
[16:11:02.280]                               next
[16:11:02.280]                             if (!grepl(pattern, name)) 
[16:11:02.280]                               next
[16:11:02.280]                             invokeRestart(restart)
[16:11:02.280]                             muffled <- TRUE
[16:11:02.280]                             break
[16:11:02.280]                           }
[16:11:02.280]                         }
[16:11:02.280]                       }
[16:11:02.280]                       invisible(muffled)
[16:11:02.280]                     }
[16:11:02.280]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.280]                   }
[16:11:02.280]                 }
[16:11:02.280]                 else {
[16:11:02.280]                   if (TRUE) {
[16:11:02.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.280]                     {
[16:11:02.280]                       inherits <- base::inherits
[16:11:02.280]                       invokeRestart <- base::invokeRestart
[16:11:02.280]                       is.null <- base::is.null
[16:11:02.280]                       muffled <- FALSE
[16:11:02.280]                       if (inherits(cond, "message")) {
[16:11:02.280]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.280]                         if (muffled) 
[16:11:02.280]                           invokeRestart("muffleMessage")
[16:11:02.280]                       }
[16:11:02.280]                       else if (inherits(cond, "warning")) {
[16:11:02.280]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.280]                         if (muffled) 
[16:11:02.280]                           invokeRestart("muffleWarning")
[16:11:02.280]                       }
[16:11:02.280]                       else if (inherits(cond, "condition")) {
[16:11:02.280]                         if (!is.null(pattern)) {
[16:11:02.280]                           computeRestarts <- base::computeRestarts
[16:11:02.280]                           grepl <- base::grepl
[16:11:02.280]                           restarts <- computeRestarts(cond)
[16:11:02.280]                           for (restart in restarts) {
[16:11:02.280]                             name <- restart$name
[16:11:02.280]                             if (is.null(name)) 
[16:11:02.280]                               next
[16:11:02.280]                             if (!grepl(pattern, name)) 
[16:11:02.280]                               next
[16:11:02.280]                             invokeRestart(restart)
[16:11:02.280]                             muffled <- TRUE
[16:11:02.280]                             break
[16:11:02.280]                           }
[16:11:02.280]                         }
[16:11:02.280]                       }
[16:11:02.280]                       invisible(muffled)
[16:11:02.280]                     }
[16:11:02.280]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.280]                   }
[16:11:02.280]                 }
[16:11:02.280]             }
[16:11:02.280]         }))
[16:11:02.280]     }, error = function(ex) {
[16:11:02.280]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.280]                 ...future.rng), started = ...future.startTime, 
[16:11:02.280]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.280]             version = "1.8"), class = "FutureResult")
[16:11:02.280]     }, finally = {
[16:11:02.280]         if (!identical(...future.workdir, getwd())) 
[16:11:02.280]             setwd(...future.workdir)
[16:11:02.280]         {
[16:11:02.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.280]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.280]             }
[16:11:02.280]             base::options(...future.oldOptions)
[16:11:02.280]             if (.Platform$OS.type == "windows") {
[16:11:02.280]                 old_names <- names(...future.oldEnvVars)
[16:11:02.280]                 envs <- base::Sys.getenv()
[16:11:02.280]                 names <- names(envs)
[16:11:02.280]                 common <- intersect(names, old_names)
[16:11:02.280]                 added <- setdiff(names, old_names)
[16:11:02.280]                 removed <- setdiff(old_names, names)
[16:11:02.280]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.280]                   envs[common]]
[16:11:02.280]                 NAMES <- toupper(changed)
[16:11:02.280]                 args <- list()
[16:11:02.280]                 for (kk in seq_along(NAMES)) {
[16:11:02.280]                   name <- changed[[kk]]
[16:11:02.280]                   NAME <- NAMES[[kk]]
[16:11:02.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.280]                     next
[16:11:02.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.280]                 }
[16:11:02.280]                 NAMES <- toupper(added)
[16:11:02.280]                 for (kk in seq_along(NAMES)) {
[16:11:02.280]                   name <- added[[kk]]
[16:11:02.280]                   NAME <- NAMES[[kk]]
[16:11:02.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.280]                     next
[16:11:02.280]                   args[[name]] <- ""
[16:11:02.280]                 }
[16:11:02.280]                 NAMES <- toupper(removed)
[16:11:02.280]                 for (kk in seq_along(NAMES)) {
[16:11:02.280]                   name <- removed[[kk]]
[16:11:02.280]                   NAME <- NAMES[[kk]]
[16:11:02.280]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.280]                     next
[16:11:02.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.280]                 }
[16:11:02.280]                 if (length(args) > 0) 
[16:11:02.280]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.280]             }
[16:11:02.280]             else {
[16:11:02.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.280]             }
[16:11:02.280]             {
[16:11:02.280]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.280]                   0L) {
[16:11:02.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.280]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.280]                   base::options(opts)
[16:11:02.280]                 }
[16:11:02.280]                 {
[16:11:02.280]                   {
[16:11:02.280]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.280]                     NULL
[16:11:02.280]                   }
[16:11:02.280]                   options(future.plan = NULL)
[16:11:02.280]                   if (is.na(NA_character_)) 
[16:11:02.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.280]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.280]                     envir = parent.frame()) 
[16:11:02.280]                   {
[16:11:02.280]                     default_workers <- missing(workers)
[16:11:02.280]                     if (is.function(workers)) 
[16:11:02.280]                       workers <- workers()
[16:11:02.280]                     workers <- structure(as.integer(workers), 
[16:11:02.280]                       class = class(workers))
[16:11:02.280]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.280]                       1L)
[16:11:02.280]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.280]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.280]                       if (default_workers) 
[16:11:02.280]                         supportsMulticore(warn = TRUE)
[16:11:02.280]                       return(sequential(..., envir = envir))
[16:11:02.280]                     }
[16:11:02.280]                     oopts <- options(mc.cores = workers)
[16:11:02.280]                     on.exit(options(oopts))
[16:11:02.280]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.280]                       envir = envir)
[16:11:02.280]                     if (!future$lazy) 
[16:11:02.280]                       future <- run(future)
[16:11:02.280]                     invisible(future)
[16:11:02.280]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.280]                 }
[16:11:02.280]             }
[16:11:02.280]         }
[16:11:02.280]     })
[16:11:02.280]     if (TRUE) {
[16:11:02.280]         base::sink(type = "output", split = FALSE)
[16:11:02.280]         if (TRUE) {
[16:11:02.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.280]         }
[16:11:02.280]         else {
[16:11:02.280]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.280]         }
[16:11:02.280]         base::close(...future.stdout)
[16:11:02.280]         ...future.stdout <- NULL
[16:11:02.280]     }
[16:11:02.280]     ...future.result$conditions <- ...future.conditions
[16:11:02.280]     ...future.result$finished <- base::Sys.time()
[16:11:02.280]     ...future.result
[16:11:02.280] }
[16:11:02.283] assign_globals() ...
[16:11:02.283] List of 11
[16:11:02.283]  $ ...future.FUN            :function (x, ...)  
[16:11:02.283]  $ x_FUN                    :function (x)  
[16:11:02.283]  $ times                    : int 1
[16:11:02.283]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.283]  $ stop_if_not              :function (...)  
[16:11:02.283]  $ dim                      : NULL
[16:11:02.283]  $ valid_types              : chr "logical"
[16:11:02.283]  $ future.call.arguments    : list()
[16:11:02.283]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.283]  $ ...future.elements_ii    :List of 6
[16:11:02.283]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[16:11:02.283]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[16:11:02.283]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[16:11:02.283]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[16:11:02.283]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[16:11:02.283]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[16:11:02.283]  $ ...future.seeds_ii       : NULL
[16:11:02.283]  $ ...future.globals.maxSize: NULL
[16:11:02.283]  - attr(*, "resolved")= logi FALSE
[16:11:02.283]  - attr(*, "total_size")= num 94200
[16:11:02.283]  - attr(*, "where")=List of 11
[16:11:02.283]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.283]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.283]  - attr(*, "already-done")= logi TRUE
[16:11:02.294] - copied ‘...future.FUN’ to environment
[16:11:02.294] - copied ‘x_FUN’ to environment
[16:11:02.294] - copied ‘times’ to environment
[16:11:02.295] - copied ‘stopf’ to environment
[16:11:02.295] - copied ‘stop_if_not’ to environment
[16:11:02.295] - copied ‘dim’ to environment
[16:11:02.295] - copied ‘valid_types’ to environment
[16:11:02.295] - copied ‘future.call.arguments’ to environment
[16:11:02.295] - copied ‘...future.elements_ii’ to environment
[16:11:02.295] - copied ‘...future.seeds_ii’ to environment
[16:11:02.295] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.295] assign_globals() ... done
[16:11:02.295] requestCore(): workers = 2
[16:11:02.298] MulticoreFuture started
[16:11:02.298] - Launch lazy future ... done
[16:11:02.299] run() for ‘MulticoreFuture’ ... done
[16:11:02.300] Created future:
[16:11:02.300] plan(): Setting new future strategy stack:
[16:11:02.300] List of future strategies:
[16:11:02.300] 1. sequential:
[16:11:02.300]    - args: function (..., envir = parent.frame())
[16:11:02.300]    - tweaked: FALSE
[16:11:02.300]    - call: NULL
[16:11:02.302] plan(): nbrOfWorkers() = 1
[16:11:02.305] plan(): Setting new future strategy stack:
[16:11:02.305] List of future strategies:
[16:11:02.305] 1. multicore:
[16:11:02.305]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.305]    - tweaked: FALSE
[16:11:02.305]    - call: plan(strategy)
[16:11:02.311] plan(): nbrOfWorkers() = 2
[16:11:02.300] MulticoreFuture:
[16:11:02.300] Label: ‘future_vapply-1’
[16:11:02.300] Expression:
[16:11:02.300] {
[16:11:02.300]     do.call(function(...) {
[16:11:02.300]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.300]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.300]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.300]             on.exit(options(oopts), add = TRUE)
[16:11:02.300]         }
[16:11:02.300]         {
[16:11:02.300]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.300]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.300]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.300]             })
[16:11:02.300]         }
[16:11:02.300]     }, args = future.call.arguments)
[16:11:02.300] }
[16:11:02.300] Lazy evaluation: FALSE
[16:11:02.300] Asynchronous evaluation: TRUE
[16:11:02.300] Local evaluation: TRUE
[16:11:02.300] Environment: R_GlobalEnv
[16:11:02.300] Capture standard output: TRUE
[16:11:02.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.300] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:02.300] Packages: 1 packages (‘future.apply’)
[16:11:02.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.300] Resolved: TRUE
[16:11:02.300] Value: <not collected>
[16:11:02.300] Conditions captured: <none>
[16:11:02.300] Early signaling: FALSE
[16:11:02.300] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.300] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.313] Chunk #1 of 2 ... DONE
[16:11:02.313] Chunk #2 of 2 ...
[16:11:02.313]  - Finding globals in 'X' for chunk #2 ...
[16:11:02.313] getGlobalsAndPackages() ...
[16:11:02.313] Searching for globals...
[16:11:02.314] 
[16:11:02.314] Searching for globals ... DONE
[16:11:02.314] - globals: [0] <none>
[16:11:02.315] getGlobalsAndPackages() ... DONE
[16:11:02.315]    + additional globals found: [n=0] 
[16:11:02.315]    + additional namespaces needed: [n=0] 
[16:11:02.315]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:02.315]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:02.315]  - seeds: <none>
[16:11:02.316] getGlobalsAndPackages() ...
[16:11:02.316] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.316] Resolving globals: FALSE
[16:11:02.316] Tweak future expression to call with '...' arguments ...
[16:11:02.316] {
[16:11:02.316]     do.call(function(...) {
[16:11:02.316]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.316]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.316]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.316]             on.exit(options(oopts), add = TRUE)
[16:11:02.316]         }
[16:11:02.316]         {
[16:11:02.316]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.316]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.316]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.316]             })
[16:11:02.316]         }
[16:11:02.316]     }, args = future.call.arguments)
[16:11:02.316] }
[16:11:02.317] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.318] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.318] - packages: [1] ‘future.apply’
[16:11:02.318] getGlobalsAndPackages() ... DONE
[16:11:02.319] run() for ‘Future’ ...
[16:11:02.319] - state: ‘created’
[16:11:02.319] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.324] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.324]   - Field: ‘label’
[16:11:02.324]   - Field: ‘local’
[16:11:02.325]   - Field: ‘owner’
[16:11:02.325]   - Field: ‘envir’
[16:11:02.325]   - Field: ‘workers’
[16:11:02.325]   - Field: ‘packages’
[16:11:02.325]   - Field: ‘gc’
[16:11:02.325]   - Field: ‘job’
[16:11:02.325]   - Field: ‘conditions’
[16:11:02.326]   - Field: ‘expr’
[16:11:02.326]   - Field: ‘uuid’
[16:11:02.326]   - Field: ‘seed’
[16:11:02.326]   - Field: ‘version’
[16:11:02.326]   - Field: ‘result’
[16:11:02.326]   - Field: ‘asynchronous’
[16:11:02.326]   - Field: ‘calls’
[16:11:02.326]   - Field: ‘globals’
[16:11:02.327]   - Field: ‘stdout’
[16:11:02.327]   - Field: ‘earlySignal’
[16:11:02.327]   - Field: ‘lazy’
[16:11:02.327]   - Field: ‘state’
[16:11:02.327] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.327] - Launch lazy future ...
[16:11:02.328] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:02.328] Packages needed by future strategies (n = 0): <none>
[16:11:02.329] {
[16:11:02.329]     {
[16:11:02.329]         {
[16:11:02.329]             ...future.startTime <- base::Sys.time()
[16:11:02.329]             {
[16:11:02.329]                 {
[16:11:02.329]                   {
[16:11:02.329]                     {
[16:11:02.329]                       {
[16:11:02.329]                         base::local({
[16:11:02.329]                           has_future <- base::requireNamespace("future", 
[16:11:02.329]                             quietly = TRUE)
[16:11:02.329]                           if (has_future) {
[16:11:02.329]                             ns <- base::getNamespace("future")
[16:11:02.329]                             version <- ns[[".package"]][["version"]]
[16:11:02.329]                             if (is.null(version)) 
[16:11:02.329]                               version <- utils::packageVersion("future")
[16:11:02.329]                           }
[16:11:02.329]                           else {
[16:11:02.329]                             version <- NULL
[16:11:02.329]                           }
[16:11:02.329]                           if (!has_future || version < "1.8.0") {
[16:11:02.329]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.329]                               "", base::R.version$version.string), 
[16:11:02.329]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:02.329]                                 base::R.version$platform, 8 * 
[16:11:02.329]                                   base::.Machine$sizeof.pointer), 
[16:11:02.329]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.329]                                 "release", "version")], collapse = " "), 
[16:11:02.329]                               hostname = base::Sys.info()[["nodename"]])
[16:11:02.329]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.329]                               info)
[16:11:02.329]                             info <- base::paste(info, collapse = "; ")
[16:11:02.329]                             if (!has_future) {
[16:11:02.329]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.329]                                 info)
[16:11:02.329]                             }
[16:11:02.329]                             else {
[16:11:02.329]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.329]                                 info, version)
[16:11:02.329]                             }
[16:11:02.329]                             base::stop(msg)
[16:11:02.329]                           }
[16:11:02.329]                         })
[16:11:02.329]                       }
[16:11:02.329]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.329]                       base::options(mc.cores = 1L)
[16:11:02.329]                     }
[16:11:02.329]                     base::local({
[16:11:02.329]                       for (pkg in "future.apply") {
[16:11:02.329]                         base::loadNamespace(pkg)
[16:11:02.329]                         base::library(pkg, character.only = TRUE)
[16:11:02.329]                       }
[16:11:02.329]                     })
[16:11:02.329]                   }
[16:11:02.329]                   options(future.plan = NULL)
[16:11:02.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.329]                 }
[16:11:02.329]                 ...future.workdir <- getwd()
[16:11:02.329]             }
[16:11:02.329]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.329]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.329]         }
[16:11:02.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.329]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:02.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.329]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.329]             base::names(...future.oldOptions))
[16:11:02.329]     }
[16:11:02.329]     if (FALSE) {
[16:11:02.329]     }
[16:11:02.329]     else {
[16:11:02.329]         if (TRUE) {
[16:11:02.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.329]                 open = "w")
[16:11:02.329]         }
[16:11:02.329]         else {
[16:11:02.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.329]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.329]         }
[16:11:02.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.329]             base::sink(type = "output", split = FALSE)
[16:11:02.329]             base::close(...future.stdout)
[16:11:02.329]         }, add = TRUE)
[16:11:02.329]     }
[16:11:02.329]     ...future.frame <- base::sys.nframe()
[16:11:02.329]     ...future.conditions <- base::list()
[16:11:02.329]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.329]     if (FALSE) {
[16:11:02.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.329]     }
[16:11:02.329]     ...future.result <- base::tryCatch({
[16:11:02.329]         base::withCallingHandlers({
[16:11:02.329]             ...future.value <- base::withVisible(base::local({
[16:11:02.329]                 withCallingHandlers({
[16:11:02.329]                   {
[16:11:02.329]                     do.call(function(...) {
[16:11:02.329]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.329]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.329]                         ...future.globals.maxSize)) {
[16:11:02.329]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.329]                         on.exit(options(oopts), add = TRUE)
[16:11:02.329]                       }
[16:11:02.329]                       {
[16:11:02.329]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.329]                           FUN = function(jj) {
[16:11:02.329]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.329]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.329]                           })
[16:11:02.329]                       }
[16:11:02.329]                     }, args = future.call.arguments)
[16:11:02.329]                   }
[16:11:02.329]                 }, immediateCondition = function(cond) {
[16:11:02.329]                   save_rds <- function (object, pathname, ...) 
[16:11:02.329]                   {
[16:11:02.329]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.329]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.329]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.329]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.329]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.329]                         fi_tmp[["mtime"]])
[16:11:02.329]                     }
[16:11:02.329]                     tryCatch({
[16:11:02.329]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.329]                     }, error = function(ex) {
[16:11:02.329]                       msg <- conditionMessage(ex)
[16:11:02.329]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.329]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.329]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.329]                         fi_tmp[["mtime"]], msg)
[16:11:02.329]                       ex$message <- msg
[16:11:02.329]                       stop(ex)
[16:11:02.329]                     })
[16:11:02.329]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.329]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.329]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.329]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.329]                       fi <- file.info(pathname)
[16:11:02.329]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.329]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.329]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.329]                         fi[["size"]], fi[["mtime"]])
[16:11:02.329]                       stop(msg)
[16:11:02.329]                     }
[16:11:02.329]                     invisible(pathname)
[16:11:02.329]                   }
[16:11:02.329]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.329]                     rootPath = tempdir()) 
[16:11:02.329]                   {
[16:11:02.329]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.329]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.329]                       tmpdir = path, fileext = ".rds")
[16:11:02.329]                     save_rds(obj, file)
[16:11:02.329]                   }
[16:11:02.329]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.329]                   {
[16:11:02.329]                     inherits <- base::inherits
[16:11:02.329]                     invokeRestart <- base::invokeRestart
[16:11:02.329]                     is.null <- base::is.null
[16:11:02.329]                     muffled <- FALSE
[16:11:02.329]                     if (inherits(cond, "message")) {
[16:11:02.329]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.329]                       if (muffled) 
[16:11:02.329]                         invokeRestart("muffleMessage")
[16:11:02.329]                     }
[16:11:02.329]                     else if (inherits(cond, "warning")) {
[16:11:02.329]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.329]                       if (muffled) 
[16:11:02.329]                         invokeRestart("muffleWarning")
[16:11:02.329]                     }
[16:11:02.329]                     else if (inherits(cond, "condition")) {
[16:11:02.329]                       if (!is.null(pattern)) {
[16:11:02.329]                         computeRestarts <- base::computeRestarts
[16:11:02.329]                         grepl <- base::grepl
[16:11:02.329]                         restarts <- computeRestarts(cond)
[16:11:02.329]                         for (restart in restarts) {
[16:11:02.329]                           name <- restart$name
[16:11:02.329]                           if (is.null(name)) 
[16:11:02.329]                             next
[16:11:02.329]                           if (!grepl(pattern, name)) 
[16:11:02.329]                             next
[16:11:02.329]                           invokeRestart(restart)
[16:11:02.329]                           muffled <- TRUE
[16:11:02.329]                           break
[16:11:02.329]                         }
[16:11:02.329]                       }
[16:11:02.329]                     }
[16:11:02.329]                     invisible(muffled)
[16:11:02.329]                   }
[16:11:02.329]                   muffleCondition(cond)
[16:11:02.329]                 })
[16:11:02.329]             }))
[16:11:02.329]             future::FutureResult(value = ...future.value$value, 
[16:11:02.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.329]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.329]                     ...future.globalenv.names))
[16:11:02.329]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.329]         }, condition = base::local({
[16:11:02.329]             c <- base::c
[16:11:02.329]             inherits <- base::inherits
[16:11:02.329]             invokeRestart <- base::invokeRestart
[16:11:02.329]             length <- base::length
[16:11:02.329]             list <- base::list
[16:11:02.329]             seq.int <- base::seq.int
[16:11:02.329]             signalCondition <- base::signalCondition
[16:11:02.329]             sys.calls <- base::sys.calls
[16:11:02.329]             `[[` <- base::`[[`
[16:11:02.329]             `+` <- base::`+`
[16:11:02.329]             `<<-` <- base::`<<-`
[16:11:02.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.329]                   3L)]
[16:11:02.329]             }
[16:11:02.329]             function(cond) {
[16:11:02.329]                 is_error <- inherits(cond, "error")
[16:11:02.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.329]                   NULL)
[16:11:02.329]                 if (is_error) {
[16:11:02.329]                   sessionInformation <- function() {
[16:11:02.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.329]                       search = base::search(), system = base::Sys.info())
[16:11:02.329]                   }
[16:11:02.329]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.329]                     cond$call), session = sessionInformation(), 
[16:11:02.329]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.329]                   signalCondition(cond)
[16:11:02.329]                 }
[16:11:02.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.329]                 "immediateCondition"))) {
[16:11:02.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.329]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.329]                   if (TRUE && !signal) {
[16:11:02.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.329]                     {
[16:11:02.329]                       inherits <- base::inherits
[16:11:02.329]                       invokeRestart <- base::invokeRestart
[16:11:02.329]                       is.null <- base::is.null
[16:11:02.329]                       muffled <- FALSE
[16:11:02.329]                       if (inherits(cond, "message")) {
[16:11:02.329]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.329]                         if (muffled) 
[16:11:02.329]                           invokeRestart("muffleMessage")
[16:11:02.329]                       }
[16:11:02.329]                       else if (inherits(cond, "warning")) {
[16:11:02.329]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.329]                         if (muffled) 
[16:11:02.329]                           invokeRestart("muffleWarning")
[16:11:02.329]                       }
[16:11:02.329]                       else if (inherits(cond, "condition")) {
[16:11:02.329]                         if (!is.null(pattern)) {
[16:11:02.329]                           computeRestarts <- base::computeRestarts
[16:11:02.329]                           grepl <- base::grepl
[16:11:02.329]                           restarts <- computeRestarts(cond)
[16:11:02.329]                           for (restart in restarts) {
[16:11:02.329]                             name <- restart$name
[16:11:02.329]                             if (is.null(name)) 
[16:11:02.329]                               next
[16:11:02.329]                             if (!grepl(pattern, name)) 
[16:11:02.329]                               next
[16:11:02.329]                             invokeRestart(restart)
[16:11:02.329]                             muffled <- TRUE
[16:11:02.329]                             break
[16:11:02.329]                           }
[16:11:02.329]                         }
[16:11:02.329]                       }
[16:11:02.329]                       invisible(muffled)
[16:11:02.329]                     }
[16:11:02.329]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.329]                   }
[16:11:02.329]                 }
[16:11:02.329]                 else {
[16:11:02.329]                   if (TRUE) {
[16:11:02.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.329]                     {
[16:11:02.329]                       inherits <- base::inherits
[16:11:02.329]                       invokeRestart <- base::invokeRestart
[16:11:02.329]                       is.null <- base::is.null
[16:11:02.329]                       muffled <- FALSE
[16:11:02.329]                       if (inherits(cond, "message")) {
[16:11:02.329]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.329]                         if (muffled) 
[16:11:02.329]                           invokeRestart("muffleMessage")
[16:11:02.329]                       }
[16:11:02.329]                       else if (inherits(cond, "warning")) {
[16:11:02.329]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.329]                         if (muffled) 
[16:11:02.329]                           invokeRestart("muffleWarning")
[16:11:02.329]                       }
[16:11:02.329]                       else if (inherits(cond, "condition")) {
[16:11:02.329]                         if (!is.null(pattern)) {
[16:11:02.329]                           computeRestarts <- base::computeRestarts
[16:11:02.329]                           grepl <- base::grepl
[16:11:02.329]                           restarts <- computeRestarts(cond)
[16:11:02.329]                           for (restart in restarts) {
[16:11:02.329]                             name <- restart$name
[16:11:02.329]                             if (is.null(name)) 
[16:11:02.329]                               next
[16:11:02.329]                             if (!grepl(pattern, name)) 
[16:11:02.329]                               next
[16:11:02.329]                             invokeRestart(restart)
[16:11:02.329]                             muffled <- TRUE
[16:11:02.329]                             break
[16:11:02.329]                           }
[16:11:02.329]                         }
[16:11:02.329]                       }
[16:11:02.329]                       invisible(muffled)
[16:11:02.329]                     }
[16:11:02.329]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.329]                   }
[16:11:02.329]                 }
[16:11:02.329]             }
[16:11:02.329]         }))
[16:11:02.329]     }, error = function(ex) {
[16:11:02.329]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.329]                 ...future.rng), started = ...future.startTime, 
[16:11:02.329]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.329]             version = "1.8"), class = "FutureResult")
[16:11:02.329]     }, finally = {
[16:11:02.329]         if (!identical(...future.workdir, getwd())) 
[16:11:02.329]             setwd(...future.workdir)
[16:11:02.329]         {
[16:11:02.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.329]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.329]             }
[16:11:02.329]             base::options(...future.oldOptions)
[16:11:02.329]             if (.Platform$OS.type == "windows") {
[16:11:02.329]                 old_names <- names(...future.oldEnvVars)
[16:11:02.329]                 envs <- base::Sys.getenv()
[16:11:02.329]                 names <- names(envs)
[16:11:02.329]                 common <- intersect(names, old_names)
[16:11:02.329]                 added <- setdiff(names, old_names)
[16:11:02.329]                 removed <- setdiff(old_names, names)
[16:11:02.329]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.329]                   envs[common]]
[16:11:02.329]                 NAMES <- toupper(changed)
[16:11:02.329]                 args <- list()
[16:11:02.329]                 for (kk in seq_along(NAMES)) {
[16:11:02.329]                   name <- changed[[kk]]
[16:11:02.329]                   NAME <- NAMES[[kk]]
[16:11:02.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.329]                     next
[16:11:02.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.329]                 }
[16:11:02.329]                 NAMES <- toupper(added)
[16:11:02.329]                 for (kk in seq_along(NAMES)) {
[16:11:02.329]                   name <- added[[kk]]
[16:11:02.329]                   NAME <- NAMES[[kk]]
[16:11:02.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.329]                     next
[16:11:02.329]                   args[[name]] <- ""
[16:11:02.329]                 }
[16:11:02.329]                 NAMES <- toupper(removed)
[16:11:02.329]                 for (kk in seq_along(NAMES)) {
[16:11:02.329]                   name <- removed[[kk]]
[16:11:02.329]                   NAME <- NAMES[[kk]]
[16:11:02.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.329]                     next
[16:11:02.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.329]                 }
[16:11:02.329]                 if (length(args) > 0) 
[16:11:02.329]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.329]             }
[16:11:02.329]             else {
[16:11:02.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.329]             }
[16:11:02.329]             {
[16:11:02.329]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.329]                   0L) {
[16:11:02.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.329]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.329]                   base::options(opts)
[16:11:02.329]                 }
[16:11:02.329]                 {
[16:11:02.329]                   {
[16:11:02.329]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.329]                     NULL
[16:11:02.329]                   }
[16:11:02.329]                   options(future.plan = NULL)
[16:11:02.329]                   if (is.na(NA_character_)) 
[16:11:02.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.329]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.329]                     envir = parent.frame()) 
[16:11:02.329]                   {
[16:11:02.329]                     default_workers <- missing(workers)
[16:11:02.329]                     if (is.function(workers)) 
[16:11:02.329]                       workers <- workers()
[16:11:02.329]                     workers <- structure(as.integer(workers), 
[16:11:02.329]                       class = class(workers))
[16:11:02.329]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.329]                       1L)
[16:11:02.329]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.329]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.329]                       if (default_workers) 
[16:11:02.329]                         supportsMulticore(warn = TRUE)
[16:11:02.329]                       return(sequential(..., envir = envir))
[16:11:02.329]                     }
[16:11:02.329]                     oopts <- options(mc.cores = workers)
[16:11:02.329]                     on.exit(options(oopts))
[16:11:02.329]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.329]                       envir = envir)
[16:11:02.329]                     if (!future$lazy) 
[16:11:02.329]                       future <- run(future)
[16:11:02.329]                     invisible(future)
[16:11:02.329]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.329]                 }
[16:11:02.329]             }
[16:11:02.329]         }
[16:11:02.329]     })
[16:11:02.329]     if (TRUE) {
[16:11:02.329]         base::sink(type = "output", split = FALSE)
[16:11:02.329]         if (TRUE) {
[16:11:02.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.329]         }
[16:11:02.329]         else {
[16:11:02.329]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.329]         }
[16:11:02.329]         base::close(...future.stdout)
[16:11:02.329]         ...future.stdout <- NULL
[16:11:02.329]     }
[16:11:02.329]     ...future.result$conditions <- ...future.conditions
[16:11:02.329]     ...future.result$finished <- base::Sys.time()
[16:11:02.329]     ...future.result
[16:11:02.329] }
[16:11:02.332] assign_globals() ...
[16:11:02.332] List of 11
[16:11:02.332]  $ ...future.FUN            :function (x, ...)  
[16:11:02.332]  $ x_FUN                    :function (x)  
[16:11:02.332]  $ times                    : int 1
[16:11:02.332]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.332]  $ stop_if_not              :function (...)  
[16:11:02.332]  $ dim                      : NULL
[16:11:02.332]  $ valid_types              : chr "logical"
[16:11:02.332]  $ future.call.arguments    : list()
[16:11:02.332]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.332]  $ ...future.elements_ii    :List of 5
[16:11:02.332]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[16:11:02.332]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[16:11:02.332]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[16:11:02.332]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[16:11:02.332]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[16:11:02.332]  $ ...future.seeds_ii       : NULL
[16:11:02.332]  $ ...future.globals.maxSize: NULL
[16:11:02.332]  - attr(*, "resolved")= logi FALSE
[16:11:02.332]  - attr(*, "total_size")= num 94200
[16:11:02.332]  - attr(*, "where")=List of 11
[16:11:02.332]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.332]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.332]  - attr(*, "already-done")= logi TRUE
[16:11:02.347] - copied ‘...future.FUN’ to environment
[16:11:02.347] - copied ‘x_FUN’ to environment
[16:11:02.347] - copied ‘times’ to environment
[16:11:02.347] - copied ‘stopf’ to environment
[16:11:02.347] - copied ‘stop_if_not’ to environment
[16:11:02.348] - copied ‘dim’ to environment
[16:11:02.348] - copied ‘valid_types’ to environment
[16:11:02.348] - copied ‘future.call.arguments’ to environment
[16:11:02.348] - copied ‘...future.elements_ii’ to environment
[16:11:02.348] - copied ‘...future.seeds_ii’ to environment
[16:11:02.348] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.348] assign_globals() ... done
[16:11:02.348] requestCore(): workers = 2
[16:11:02.351] MulticoreFuture started
[16:11:02.351] - Launch lazy future ... done
[16:11:02.351] run() for ‘MulticoreFuture’ ... done
[16:11:02.352] Created future:
[16:11:02.352] plan(): Setting new future strategy stack:
[16:11:02.352] List of future strategies:
[16:11:02.352] 1. sequential:
[16:11:02.352]    - args: function (..., envir = parent.frame())
[16:11:02.352]    - tweaked: FALSE
[16:11:02.352]    - call: NULL
[16:11:02.353] plan(): nbrOfWorkers() = 1
[16:11:02.356] plan(): Setting new future strategy stack:
[16:11:02.356] List of future strategies:
[16:11:02.356] 1. multicore:
[16:11:02.356]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.356]    - tweaked: FALSE
[16:11:02.356]    - call: plan(strategy)
[16:11:02.362] plan(): nbrOfWorkers() = 2
[16:11:02.352] MulticoreFuture:
[16:11:02.352] Label: ‘future_vapply-2’
[16:11:02.352] Expression:
[16:11:02.352] {
[16:11:02.352]     do.call(function(...) {
[16:11:02.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.352]             on.exit(options(oopts), add = TRUE)
[16:11:02.352]         }
[16:11:02.352]         {
[16:11:02.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.352]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.352]             })
[16:11:02.352]         }
[16:11:02.352]     }, args = future.call.arguments)
[16:11:02.352] }
[16:11:02.352] Lazy evaluation: FALSE
[16:11:02.352] Asynchronous evaluation: TRUE
[16:11:02.352] Local evaluation: TRUE
[16:11:02.352] Environment: R_GlobalEnv
[16:11:02.352] Capture standard output: TRUE
[16:11:02.352] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.352] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:02.352] Packages: 1 packages (‘future.apply’)
[16:11:02.352] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.352] Resolved: TRUE
[16:11:02.352] Value: <not collected>
[16:11:02.352] Conditions captured: <none>
[16:11:02.352] Early signaling: FALSE
[16:11:02.352] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.352] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.363] Chunk #2 of 2 ... DONE
[16:11:02.363] Launching 2 futures (chunks) ... DONE
[16:11:02.364] Resolving 2 futures (chunks) ...
[16:11:02.364] resolve() on list ...
[16:11:02.364]  recursive: 0
[16:11:02.364]  length: 2
[16:11:02.364] 
[16:11:02.365] Future #1
[16:11:02.366] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:02.366] - nx: 2
[16:11:02.366] - relay: TRUE
[16:11:02.366] - stdout: TRUE
[16:11:02.366] - signal: TRUE
[16:11:02.367] - resignal: FALSE
[16:11:02.367] - force: TRUE
[16:11:02.367] - relayed: [n=2] FALSE, FALSE
[16:11:02.367] - queued futures: [n=2] FALSE, FALSE
[16:11:02.367]  - until=1
[16:11:02.367]  - relaying element #1
[16:11:02.368] - relayed: [n=2] TRUE, FALSE
[16:11:02.368] - queued futures: [n=2] TRUE, FALSE
[16:11:02.368] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:02.368]  length: 1 (resolved future 1)
[16:11:02.369] Future #2
[16:11:02.369] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:02.370] - nx: 2
[16:11:02.370] - relay: TRUE
[16:11:02.370] - stdout: TRUE
[16:11:02.370] - signal: TRUE
[16:11:02.370] - resignal: FALSE
[16:11:02.370] - force: TRUE
[16:11:02.370] - relayed: [n=2] TRUE, FALSE
[16:11:02.370] - queued futures: [n=2] TRUE, FALSE
[16:11:02.371]  - until=2
[16:11:02.371]  - relaying element #2
[16:11:02.371] - relayed: [n=2] TRUE, TRUE
[16:11:02.371] - queued futures: [n=2] TRUE, TRUE
[16:11:02.371] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:02.371]  length: 0 (resolved future 2)
[16:11:02.372] Relaying remaining futures
[16:11:02.372] signalConditionsASAP(NULL, pos=0) ...
[16:11:02.372] - nx: 2
[16:11:02.372] - relay: TRUE
[16:11:02.372] - stdout: TRUE
[16:11:02.372] - signal: TRUE
[16:11:02.372] - resignal: FALSE
[16:11:02.372] - force: TRUE
[16:11:02.372] - relayed: [n=2] TRUE, TRUE
[16:11:02.372] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:02.373] - relayed: [n=2] TRUE, TRUE
[16:11:02.373] - queued futures: [n=2] TRUE, TRUE
[16:11:02.373] signalConditionsASAP(NULL, pos=0) ... done
[16:11:02.373] resolve() on list ... DONE
[16:11:02.373]  - Number of value chunks collected: 2
[16:11:02.373] Resolving 2 futures (chunks) ... DONE
[16:11:02.373] Reducing values from 2 chunks ...
[16:11:02.374]  - Number of values collected after concatenation: 11
[16:11:02.374]  - Number of values expected: 11
[16:11:02.374] Reducing values from 2 chunks ... DONE
[16:11:02.374] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:11:02.375] future_lapply() ...
[16:11:02.385] Number of chunks: 2
[16:11:02.385] getGlobalsAndPackagesXApply() ...
[16:11:02.385]  - future.globals: TRUE
[16:11:02.385] getGlobalsAndPackages() ...
[16:11:02.385] Searching for globals...
[16:11:02.389] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:02.389] Searching for globals ... DONE
[16:11:02.390] Resolving globals: FALSE
[16:11:02.391] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:11:02.391] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:02.391] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:02.391] - packages: [1] ‘future.apply’
[16:11:02.391] getGlobalsAndPackages() ... DONE
[16:11:02.391]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:02.392]  - needed namespaces: [n=1] ‘future.apply’
[16:11:02.392] Finding globals ... DONE
[16:11:02.392]  - use_args: TRUE
[16:11:02.392]  - Getting '...' globals ...
[16:11:02.392] resolve() on list ...
[16:11:02.392]  recursive: 0
[16:11:02.392]  length: 1
[16:11:02.393]  elements: ‘...’
[16:11:02.393]  length: 0 (resolved future 1)
[16:11:02.393] resolve() on list ... DONE
[16:11:02.393]    - '...' content: [n=0] 
[16:11:02.393] List of 1
[16:11:02.393]  $ ...: list()
[16:11:02.393]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.393]  - attr(*, "where")=List of 1
[16:11:02.393]   ..$ ...:<environment: 0x561e8a1adfb8> 
[16:11:02.393]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.393]  - attr(*, "resolved")= logi TRUE
[16:11:02.393]  - attr(*, "total_size")= num NA
[16:11:02.396]  - Getting '...' globals ... DONE
[16:11:02.396] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:02.396] List of 8
[16:11:02.396]  $ ...future.FUN:function (x, ...)  
[16:11:02.396]  $ x_FUN        :function (x)  
[16:11:02.396]  $ times        : int 1
[16:11:02.396]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.396]  $ stop_if_not  :function (...)  
[16:11:02.396]  $ dim          : NULL
[16:11:02.396]  $ valid_types  : chr [1:2] "logical" "integer"
[16:11:02.396]  $ ...          : list()
[16:11:02.396]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.396]  - attr(*, "where")=List of 8
[16:11:02.396]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:02.396]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:02.396]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:02.396]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:02.396]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:02.396]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:02.396]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:02.396]   ..$ ...          :<environment: 0x561e8a1adfb8> 
[16:11:02.396]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.396]  - attr(*, "resolved")= logi FALSE
[16:11:02.396]  - attr(*, "total_size")= num 94264
[16:11:02.404] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:02.404] getGlobalsAndPackagesXApply() ... DONE
[16:11:02.404] Number of futures (= number of chunks): 2
[16:11:02.404] Launching 2 futures (chunks) ...
[16:11:02.404] Chunk #1 of 2 ...
[16:11:02.404]  - Finding globals in 'X' for chunk #1 ...
[16:11:02.404] getGlobalsAndPackages() ...
[16:11:02.405] Searching for globals...
[16:11:02.405] 
[16:11:02.405] Searching for globals ... DONE
[16:11:02.405] - globals: [0] <none>
[16:11:02.405] getGlobalsAndPackages() ... DONE
[16:11:02.405]    + additional globals found: [n=0] 
[16:11:02.405]    + additional namespaces needed: [n=0] 
[16:11:02.405]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:02.406]  - seeds: <none>
[16:11:02.406] getGlobalsAndPackages() ...
[16:11:02.406] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.406] Resolving globals: FALSE
[16:11:02.406] Tweak future expression to call with '...' arguments ...
[16:11:02.406] {
[16:11:02.406]     do.call(function(...) {
[16:11:02.406]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.406]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.406]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.406]             on.exit(options(oopts), add = TRUE)
[16:11:02.406]         }
[16:11:02.406]         {
[16:11:02.406]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.406]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.406]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.406]             })
[16:11:02.406]         }
[16:11:02.406]     }, args = future.call.arguments)
[16:11:02.406] }
[16:11:02.406] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.407] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.407] - packages: [1] ‘future.apply’
[16:11:02.407] getGlobalsAndPackages() ... DONE
[16:11:02.407] run() for ‘Future’ ...
[16:11:02.408] - state: ‘created’
[16:11:02.408] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.411] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.412]   - Field: ‘label’
[16:11:02.412]   - Field: ‘local’
[16:11:02.412]   - Field: ‘owner’
[16:11:02.412]   - Field: ‘envir’
[16:11:02.412]   - Field: ‘workers’
[16:11:02.412]   - Field: ‘packages’
[16:11:02.412]   - Field: ‘gc’
[16:11:02.412]   - Field: ‘job’
[16:11:02.412]   - Field: ‘conditions’
[16:11:02.413]   - Field: ‘expr’
[16:11:02.413]   - Field: ‘uuid’
[16:11:02.413]   - Field: ‘seed’
[16:11:02.413]   - Field: ‘version’
[16:11:02.413]   - Field: ‘result’
[16:11:02.413]   - Field: ‘asynchronous’
[16:11:02.413]   - Field: ‘calls’
[16:11:02.413]   - Field: ‘globals’
[16:11:02.413]   - Field: ‘stdout’
[16:11:02.413]   - Field: ‘earlySignal’
[16:11:02.413]   - Field: ‘lazy’
[16:11:02.414]   - Field: ‘state’
[16:11:02.414] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.414] - Launch lazy future ...
[16:11:02.414] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:02.414] Packages needed by future strategies (n = 0): <none>
[16:11:02.415] {
[16:11:02.415]     {
[16:11:02.415]         {
[16:11:02.415]             ...future.startTime <- base::Sys.time()
[16:11:02.415]             {
[16:11:02.415]                 {
[16:11:02.415]                   {
[16:11:02.415]                     {
[16:11:02.415]                       {
[16:11:02.415]                         base::local({
[16:11:02.415]                           has_future <- base::requireNamespace("future", 
[16:11:02.415]                             quietly = TRUE)
[16:11:02.415]                           if (has_future) {
[16:11:02.415]                             ns <- base::getNamespace("future")
[16:11:02.415]                             version <- ns[[".package"]][["version"]]
[16:11:02.415]                             if (is.null(version)) 
[16:11:02.415]                               version <- utils::packageVersion("future")
[16:11:02.415]                           }
[16:11:02.415]                           else {
[16:11:02.415]                             version <- NULL
[16:11:02.415]                           }
[16:11:02.415]                           if (!has_future || version < "1.8.0") {
[16:11:02.415]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.415]                               "", base::R.version$version.string), 
[16:11:02.415]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:02.415]                                 base::R.version$platform, 8 * 
[16:11:02.415]                                   base::.Machine$sizeof.pointer), 
[16:11:02.415]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.415]                                 "release", "version")], collapse = " "), 
[16:11:02.415]                               hostname = base::Sys.info()[["nodename"]])
[16:11:02.415]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.415]                               info)
[16:11:02.415]                             info <- base::paste(info, collapse = "; ")
[16:11:02.415]                             if (!has_future) {
[16:11:02.415]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.415]                                 info)
[16:11:02.415]                             }
[16:11:02.415]                             else {
[16:11:02.415]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.415]                                 info, version)
[16:11:02.415]                             }
[16:11:02.415]                             base::stop(msg)
[16:11:02.415]                           }
[16:11:02.415]                         })
[16:11:02.415]                       }
[16:11:02.415]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.415]                       base::options(mc.cores = 1L)
[16:11:02.415]                     }
[16:11:02.415]                     base::local({
[16:11:02.415]                       for (pkg in "future.apply") {
[16:11:02.415]                         base::loadNamespace(pkg)
[16:11:02.415]                         base::library(pkg, character.only = TRUE)
[16:11:02.415]                       }
[16:11:02.415]                     })
[16:11:02.415]                   }
[16:11:02.415]                   options(future.plan = NULL)
[16:11:02.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.415]                 }
[16:11:02.415]                 ...future.workdir <- getwd()
[16:11:02.415]             }
[16:11:02.415]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.415]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.415]         }
[16:11:02.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:02.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.415]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.415]             base::names(...future.oldOptions))
[16:11:02.415]     }
[16:11:02.415]     if (FALSE) {
[16:11:02.415]     }
[16:11:02.415]     else {
[16:11:02.415]         if (TRUE) {
[16:11:02.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.415]                 open = "w")
[16:11:02.415]         }
[16:11:02.415]         else {
[16:11:02.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.415]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.415]         }
[16:11:02.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.415]             base::sink(type = "output", split = FALSE)
[16:11:02.415]             base::close(...future.stdout)
[16:11:02.415]         }, add = TRUE)
[16:11:02.415]     }
[16:11:02.415]     ...future.frame <- base::sys.nframe()
[16:11:02.415]     ...future.conditions <- base::list()
[16:11:02.415]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.415]     if (FALSE) {
[16:11:02.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.415]     }
[16:11:02.415]     ...future.result <- base::tryCatch({
[16:11:02.415]         base::withCallingHandlers({
[16:11:02.415]             ...future.value <- base::withVisible(base::local({
[16:11:02.415]                 withCallingHandlers({
[16:11:02.415]                   {
[16:11:02.415]                     do.call(function(...) {
[16:11:02.415]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.415]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.415]                         ...future.globals.maxSize)) {
[16:11:02.415]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.415]                         on.exit(options(oopts), add = TRUE)
[16:11:02.415]                       }
[16:11:02.415]                       {
[16:11:02.415]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.415]                           FUN = function(jj) {
[16:11:02.415]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.415]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.415]                           })
[16:11:02.415]                       }
[16:11:02.415]                     }, args = future.call.arguments)
[16:11:02.415]                   }
[16:11:02.415]                 }, immediateCondition = function(cond) {
[16:11:02.415]                   save_rds <- function (object, pathname, ...) 
[16:11:02.415]                   {
[16:11:02.415]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.415]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.415]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.415]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.415]                         fi_tmp[["mtime"]])
[16:11:02.415]                     }
[16:11:02.415]                     tryCatch({
[16:11:02.415]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.415]                     }, error = function(ex) {
[16:11:02.415]                       msg <- conditionMessage(ex)
[16:11:02.415]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.415]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.415]                         fi_tmp[["mtime"]], msg)
[16:11:02.415]                       ex$message <- msg
[16:11:02.415]                       stop(ex)
[16:11:02.415]                     })
[16:11:02.415]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.415]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.415]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.415]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.415]                       fi <- file.info(pathname)
[16:11:02.415]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.415]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.415]                         fi[["size"]], fi[["mtime"]])
[16:11:02.415]                       stop(msg)
[16:11:02.415]                     }
[16:11:02.415]                     invisible(pathname)
[16:11:02.415]                   }
[16:11:02.415]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.415]                     rootPath = tempdir()) 
[16:11:02.415]                   {
[16:11:02.415]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.415]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.415]                       tmpdir = path, fileext = ".rds")
[16:11:02.415]                     save_rds(obj, file)
[16:11:02.415]                   }
[16:11:02.415]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.415]                   {
[16:11:02.415]                     inherits <- base::inherits
[16:11:02.415]                     invokeRestart <- base::invokeRestart
[16:11:02.415]                     is.null <- base::is.null
[16:11:02.415]                     muffled <- FALSE
[16:11:02.415]                     if (inherits(cond, "message")) {
[16:11:02.415]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.415]                       if (muffled) 
[16:11:02.415]                         invokeRestart("muffleMessage")
[16:11:02.415]                     }
[16:11:02.415]                     else if (inherits(cond, "warning")) {
[16:11:02.415]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.415]                       if (muffled) 
[16:11:02.415]                         invokeRestart("muffleWarning")
[16:11:02.415]                     }
[16:11:02.415]                     else if (inherits(cond, "condition")) {
[16:11:02.415]                       if (!is.null(pattern)) {
[16:11:02.415]                         computeRestarts <- base::computeRestarts
[16:11:02.415]                         grepl <- base::grepl
[16:11:02.415]                         restarts <- computeRestarts(cond)
[16:11:02.415]                         for (restart in restarts) {
[16:11:02.415]                           name <- restart$name
[16:11:02.415]                           if (is.null(name)) 
[16:11:02.415]                             next
[16:11:02.415]                           if (!grepl(pattern, name)) 
[16:11:02.415]                             next
[16:11:02.415]                           invokeRestart(restart)
[16:11:02.415]                           muffled <- TRUE
[16:11:02.415]                           break
[16:11:02.415]                         }
[16:11:02.415]                       }
[16:11:02.415]                     }
[16:11:02.415]                     invisible(muffled)
[16:11:02.415]                   }
[16:11:02.415]                   muffleCondition(cond)
[16:11:02.415]                 })
[16:11:02.415]             }))
[16:11:02.415]             future::FutureResult(value = ...future.value$value, 
[16:11:02.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.415]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.415]                     ...future.globalenv.names))
[16:11:02.415]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.415]         }, condition = base::local({
[16:11:02.415]             c <- base::c
[16:11:02.415]             inherits <- base::inherits
[16:11:02.415]             invokeRestart <- base::invokeRestart
[16:11:02.415]             length <- base::length
[16:11:02.415]             list <- base::list
[16:11:02.415]             seq.int <- base::seq.int
[16:11:02.415]             signalCondition <- base::signalCondition
[16:11:02.415]             sys.calls <- base::sys.calls
[16:11:02.415]             `[[` <- base::`[[`
[16:11:02.415]             `+` <- base::`+`
[16:11:02.415]             `<<-` <- base::`<<-`
[16:11:02.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.415]                   3L)]
[16:11:02.415]             }
[16:11:02.415]             function(cond) {
[16:11:02.415]                 is_error <- inherits(cond, "error")
[16:11:02.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.415]                   NULL)
[16:11:02.415]                 if (is_error) {
[16:11:02.415]                   sessionInformation <- function() {
[16:11:02.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.415]                       search = base::search(), system = base::Sys.info())
[16:11:02.415]                   }
[16:11:02.415]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.415]                     cond$call), session = sessionInformation(), 
[16:11:02.415]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.415]                   signalCondition(cond)
[16:11:02.415]                 }
[16:11:02.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.415]                 "immediateCondition"))) {
[16:11:02.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.415]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.415]                   if (TRUE && !signal) {
[16:11:02.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.415]                     {
[16:11:02.415]                       inherits <- base::inherits
[16:11:02.415]                       invokeRestart <- base::invokeRestart
[16:11:02.415]                       is.null <- base::is.null
[16:11:02.415]                       muffled <- FALSE
[16:11:02.415]                       if (inherits(cond, "message")) {
[16:11:02.415]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.415]                         if (muffled) 
[16:11:02.415]                           invokeRestart("muffleMessage")
[16:11:02.415]                       }
[16:11:02.415]                       else if (inherits(cond, "warning")) {
[16:11:02.415]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.415]                         if (muffled) 
[16:11:02.415]                           invokeRestart("muffleWarning")
[16:11:02.415]                       }
[16:11:02.415]                       else if (inherits(cond, "condition")) {
[16:11:02.415]                         if (!is.null(pattern)) {
[16:11:02.415]                           computeRestarts <- base::computeRestarts
[16:11:02.415]                           grepl <- base::grepl
[16:11:02.415]                           restarts <- computeRestarts(cond)
[16:11:02.415]                           for (restart in restarts) {
[16:11:02.415]                             name <- restart$name
[16:11:02.415]                             if (is.null(name)) 
[16:11:02.415]                               next
[16:11:02.415]                             if (!grepl(pattern, name)) 
[16:11:02.415]                               next
[16:11:02.415]                             invokeRestart(restart)
[16:11:02.415]                             muffled <- TRUE
[16:11:02.415]                             break
[16:11:02.415]                           }
[16:11:02.415]                         }
[16:11:02.415]                       }
[16:11:02.415]                       invisible(muffled)
[16:11:02.415]                     }
[16:11:02.415]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.415]                   }
[16:11:02.415]                 }
[16:11:02.415]                 else {
[16:11:02.415]                   if (TRUE) {
[16:11:02.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.415]                     {
[16:11:02.415]                       inherits <- base::inherits
[16:11:02.415]                       invokeRestart <- base::invokeRestart
[16:11:02.415]                       is.null <- base::is.null
[16:11:02.415]                       muffled <- FALSE
[16:11:02.415]                       if (inherits(cond, "message")) {
[16:11:02.415]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.415]                         if (muffled) 
[16:11:02.415]                           invokeRestart("muffleMessage")
[16:11:02.415]                       }
[16:11:02.415]                       else if (inherits(cond, "warning")) {
[16:11:02.415]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.415]                         if (muffled) 
[16:11:02.415]                           invokeRestart("muffleWarning")
[16:11:02.415]                       }
[16:11:02.415]                       else if (inherits(cond, "condition")) {
[16:11:02.415]                         if (!is.null(pattern)) {
[16:11:02.415]                           computeRestarts <- base::computeRestarts
[16:11:02.415]                           grepl <- base::grepl
[16:11:02.415]                           restarts <- computeRestarts(cond)
[16:11:02.415]                           for (restart in restarts) {
[16:11:02.415]                             name <- restart$name
[16:11:02.415]                             if (is.null(name)) 
[16:11:02.415]                               next
[16:11:02.415]                             if (!grepl(pattern, name)) 
[16:11:02.415]                               next
[16:11:02.415]                             invokeRestart(restart)
[16:11:02.415]                             muffled <- TRUE
[16:11:02.415]                             break
[16:11:02.415]                           }
[16:11:02.415]                         }
[16:11:02.415]                       }
[16:11:02.415]                       invisible(muffled)
[16:11:02.415]                     }
[16:11:02.415]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.415]                   }
[16:11:02.415]                 }
[16:11:02.415]             }
[16:11:02.415]         }))
[16:11:02.415]     }, error = function(ex) {
[16:11:02.415]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.415]                 ...future.rng), started = ...future.startTime, 
[16:11:02.415]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.415]             version = "1.8"), class = "FutureResult")
[16:11:02.415]     }, finally = {
[16:11:02.415]         if (!identical(...future.workdir, getwd())) 
[16:11:02.415]             setwd(...future.workdir)
[16:11:02.415]         {
[16:11:02.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.415]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.415]             }
[16:11:02.415]             base::options(...future.oldOptions)
[16:11:02.415]             if (.Platform$OS.type == "windows") {
[16:11:02.415]                 old_names <- names(...future.oldEnvVars)
[16:11:02.415]                 envs <- base::Sys.getenv()
[16:11:02.415]                 names <- names(envs)
[16:11:02.415]                 common <- intersect(names, old_names)
[16:11:02.415]                 added <- setdiff(names, old_names)
[16:11:02.415]                 removed <- setdiff(old_names, names)
[16:11:02.415]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.415]                   envs[common]]
[16:11:02.415]                 NAMES <- toupper(changed)
[16:11:02.415]                 args <- list()
[16:11:02.415]                 for (kk in seq_along(NAMES)) {
[16:11:02.415]                   name <- changed[[kk]]
[16:11:02.415]                   NAME <- NAMES[[kk]]
[16:11:02.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.415]                     next
[16:11:02.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.415]                 }
[16:11:02.415]                 NAMES <- toupper(added)
[16:11:02.415]                 for (kk in seq_along(NAMES)) {
[16:11:02.415]                   name <- added[[kk]]
[16:11:02.415]                   NAME <- NAMES[[kk]]
[16:11:02.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.415]                     next
[16:11:02.415]                   args[[name]] <- ""
[16:11:02.415]                 }
[16:11:02.415]                 NAMES <- toupper(removed)
[16:11:02.415]                 for (kk in seq_along(NAMES)) {
[16:11:02.415]                   name <- removed[[kk]]
[16:11:02.415]                   NAME <- NAMES[[kk]]
[16:11:02.415]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.415]                     next
[16:11:02.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.415]                 }
[16:11:02.415]                 if (length(args) > 0) 
[16:11:02.415]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.415]             }
[16:11:02.415]             else {
[16:11:02.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.415]             }
[16:11:02.415]             {
[16:11:02.415]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.415]                   0L) {
[16:11:02.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.415]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.415]                   base::options(opts)
[16:11:02.415]                 }
[16:11:02.415]                 {
[16:11:02.415]                   {
[16:11:02.415]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.415]                     NULL
[16:11:02.415]                   }
[16:11:02.415]                   options(future.plan = NULL)
[16:11:02.415]                   if (is.na(NA_character_)) 
[16:11:02.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.415]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.415]                     envir = parent.frame()) 
[16:11:02.415]                   {
[16:11:02.415]                     default_workers <- missing(workers)
[16:11:02.415]                     if (is.function(workers)) 
[16:11:02.415]                       workers <- workers()
[16:11:02.415]                     workers <- structure(as.integer(workers), 
[16:11:02.415]                       class = class(workers))
[16:11:02.415]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.415]                       1L)
[16:11:02.415]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.415]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.415]                       if (default_workers) 
[16:11:02.415]                         supportsMulticore(warn = TRUE)
[16:11:02.415]                       return(sequential(..., envir = envir))
[16:11:02.415]                     }
[16:11:02.415]                     oopts <- options(mc.cores = workers)
[16:11:02.415]                     on.exit(options(oopts))
[16:11:02.415]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.415]                       envir = envir)
[16:11:02.415]                     if (!future$lazy) 
[16:11:02.415]                       future <- run(future)
[16:11:02.415]                     invisible(future)
[16:11:02.415]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.415]                 }
[16:11:02.415]             }
[16:11:02.415]         }
[16:11:02.415]     })
[16:11:02.415]     if (TRUE) {
[16:11:02.415]         base::sink(type = "output", split = FALSE)
[16:11:02.415]         if (TRUE) {
[16:11:02.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.415]         }
[16:11:02.415]         else {
[16:11:02.415]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.415]         }
[16:11:02.415]         base::close(...future.stdout)
[16:11:02.415]         ...future.stdout <- NULL
[16:11:02.415]     }
[16:11:02.415]     ...future.result$conditions <- ...future.conditions
[16:11:02.415]     ...future.result$finished <- base::Sys.time()
[16:11:02.415]     ...future.result
[16:11:02.415] }
[16:11:02.417] assign_globals() ...
[16:11:02.418] List of 11
[16:11:02.418]  $ ...future.FUN            :function (x, ...)  
[16:11:02.418]  $ x_FUN                    :function (x)  
[16:11:02.418]  $ times                    : int 1
[16:11:02.418]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.418]  $ stop_if_not              :function (...)  
[16:11:02.418]  $ dim                      : NULL
[16:11:02.418]  $ valid_types              : chr [1:2] "logical" "integer"
[16:11:02.418]  $ future.call.arguments    : list()
[16:11:02.418]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.418]  $ ...future.elements_ii    :List of 1
[16:11:02.418]   ..$ a: num 1
[16:11:02.418]  $ ...future.seeds_ii       : NULL
[16:11:02.418]  $ ...future.globals.maxSize: NULL
[16:11:02.418]  - attr(*, "where")=List of 11
[16:11:02.418]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.418]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.418]  - attr(*, "resolved")= logi FALSE
[16:11:02.418]  - attr(*, "total_size")= num 94264
[16:11:02.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.418]  - attr(*, "already-done")= logi TRUE
[16:11:02.427] - copied ‘...future.FUN’ to environment
[16:11:02.427] - copied ‘x_FUN’ to environment
[16:11:02.427] - copied ‘times’ to environment
[16:11:02.427] - copied ‘stopf’ to environment
[16:11:02.427] - copied ‘stop_if_not’ to environment
[16:11:02.427] - copied ‘dim’ to environment
[16:11:02.427] - copied ‘valid_types’ to environment
[16:11:02.428] - copied ‘future.call.arguments’ to environment
[16:11:02.428] - copied ‘...future.elements_ii’ to environment
[16:11:02.428] - copied ‘...future.seeds_ii’ to environment
[16:11:02.428] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.428] assign_globals() ... done
[16:11:02.428] requestCore(): workers = 2
[16:11:02.430] MulticoreFuture started
[16:11:02.431] - Launch lazy future ... done
[16:11:02.432] run() for ‘MulticoreFuture’ ... done
[16:11:02.432] Created future:
[16:11:02.432] plan(): Setting new future strategy stack:
[16:11:02.433] List of future strategies:
[16:11:02.433] 1. sequential:
[16:11:02.433]    - args: function (..., envir = parent.frame())
[16:11:02.433]    - tweaked: FALSE
[16:11:02.433]    - call: NULL
[16:11:02.434] plan(): nbrOfWorkers() = 1
[16:11:02.437] plan(): Setting new future strategy stack:
[16:11:02.437] List of future strategies:
[16:11:02.437] 1. multicore:
[16:11:02.437]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.437]    - tweaked: FALSE
[16:11:02.437]    - call: plan(strategy)
[16:11:02.444] plan(): nbrOfWorkers() = 2
[16:11:02.433] MulticoreFuture:
[16:11:02.433] Label: ‘future_vapply-1’
[16:11:02.433] Expression:
[16:11:02.433] {
[16:11:02.433]     do.call(function(...) {
[16:11:02.433]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.433]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.433]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.433]             on.exit(options(oopts), add = TRUE)
[16:11:02.433]         }
[16:11:02.433]         {
[16:11:02.433]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.433]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.433]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.433]             })
[16:11:02.433]         }
[16:11:02.433]     }, args = future.call.arguments)
[16:11:02.433] }
[16:11:02.433] Lazy evaluation: FALSE
[16:11:02.433] Asynchronous evaluation: TRUE
[16:11:02.433] Local evaluation: TRUE
[16:11:02.433] Environment: R_GlobalEnv
[16:11:02.433] Capture standard output: TRUE
[16:11:02.433] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.433] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:02.433] Packages: 1 packages (‘future.apply’)
[16:11:02.433] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.433] Resolved: TRUE
[16:11:02.433] Value: <not collected>
[16:11:02.433] Conditions captured: <none>
[16:11:02.433] Early signaling: FALSE
[16:11:02.433] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.433] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.445] Chunk #1 of 2 ... DONE
[16:11:02.446] Chunk #2 of 2 ...
[16:11:02.446]  - Finding globals in 'X' for chunk #2 ...
[16:11:02.446] getGlobalsAndPackages() ...
[16:11:02.446] Searching for globals...
[16:11:02.447] 
[16:11:02.447] Searching for globals ... DONE
[16:11:02.447] - globals: [0] <none>
[16:11:02.448] getGlobalsAndPackages() ... DONE
[16:11:02.448]    + additional globals found: [n=0] 
[16:11:02.448]    + additional namespaces needed: [n=0] 
[16:11:02.448]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:02.448]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:02.449]  - seeds: <none>
[16:11:02.449] getGlobalsAndPackages() ...
[16:11:02.449] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.449] Resolving globals: FALSE
[16:11:02.449] Tweak future expression to call with '...' arguments ...
[16:11:02.450] {
[16:11:02.450]     do.call(function(...) {
[16:11:02.450]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.450]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.450]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.450]             on.exit(options(oopts), add = TRUE)
[16:11:02.450]         }
[16:11:02.450]         {
[16:11:02.450]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.450]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.450]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.450]             })
[16:11:02.450]         }
[16:11:02.450]     }, args = future.call.arguments)
[16:11:02.450] }
[16:11:02.450] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.451] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.451] - packages: [1] ‘future.apply’
[16:11:02.452] getGlobalsAndPackages() ... DONE
[16:11:02.452] run() for ‘Future’ ...
[16:11:02.452] - state: ‘created’
[16:11:02.453] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.457] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.458]   - Field: ‘label’
[16:11:02.458]   - Field: ‘local’
[16:11:02.458]   - Field: ‘owner’
[16:11:02.458]   - Field: ‘envir’
[16:11:02.458]   - Field: ‘workers’
[16:11:02.458]   - Field: ‘packages’
[16:11:02.459]   - Field: ‘gc’
[16:11:02.459]   - Field: ‘job’
[16:11:02.459]   - Field: ‘conditions’
[16:11:02.459]   - Field: ‘expr’
[16:11:02.459]   - Field: ‘uuid’
[16:11:02.459]   - Field: ‘seed’
[16:11:02.459]   - Field: ‘version’
[16:11:02.459]   - Field: ‘result’
[16:11:02.460]   - Field: ‘asynchronous’
[16:11:02.460]   - Field: ‘calls’
[16:11:02.460]   - Field: ‘globals’
[16:11:02.460]   - Field: ‘stdout’
[16:11:02.460]   - Field: ‘earlySignal’
[16:11:02.460]   - Field: ‘lazy’
[16:11:02.460]   - Field: ‘state’
[16:11:02.461] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.461] - Launch lazy future ...
[16:11:02.461] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:02.461] Packages needed by future strategies (n = 0): <none>
[16:11:02.462] {
[16:11:02.462]     {
[16:11:02.462]         {
[16:11:02.462]             ...future.startTime <- base::Sys.time()
[16:11:02.462]             {
[16:11:02.462]                 {
[16:11:02.462]                   {
[16:11:02.462]                     {
[16:11:02.462]                       {
[16:11:02.462]                         base::local({
[16:11:02.462]                           has_future <- base::requireNamespace("future", 
[16:11:02.462]                             quietly = TRUE)
[16:11:02.462]                           if (has_future) {
[16:11:02.462]                             ns <- base::getNamespace("future")
[16:11:02.462]                             version <- ns[[".package"]][["version"]]
[16:11:02.462]                             if (is.null(version)) 
[16:11:02.462]                               version <- utils::packageVersion("future")
[16:11:02.462]                           }
[16:11:02.462]                           else {
[16:11:02.462]                             version <- NULL
[16:11:02.462]                           }
[16:11:02.462]                           if (!has_future || version < "1.8.0") {
[16:11:02.462]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.462]                               "", base::R.version$version.string), 
[16:11:02.462]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:02.462]                                 base::R.version$platform, 8 * 
[16:11:02.462]                                   base::.Machine$sizeof.pointer), 
[16:11:02.462]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.462]                                 "release", "version")], collapse = " "), 
[16:11:02.462]                               hostname = base::Sys.info()[["nodename"]])
[16:11:02.462]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.462]                               info)
[16:11:02.462]                             info <- base::paste(info, collapse = "; ")
[16:11:02.462]                             if (!has_future) {
[16:11:02.462]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.462]                                 info)
[16:11:02.462]                             }
[16:11:02.462]                             else {
[16:11:02.462]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.462]                                 info, version)
[16:11:02.462]                             }
[16:11:02.462]                             base::stop(msg)
[16:11:02.462]                           }
[16:11:02.462]                         })
[16:11:02.462]                       }
[16:11:02.462]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.462]                       base::options(mc.cores = 1L)
[16:11:02.462]                     }
[16:11:02.462]                     base::local({
[16:11:02.462]                       for (pkg in "future.apply") {
[16:11:02.462]                         base::loadNamespace(pkg)
[16:11:02.462]                         base::library(pkg, character.only = TRUE)
[16:11:02.462]                       }
[16:11:02.462]                     })
[16:11:02.462]                   }
[16:11:02.462]                   options(future.plan = NULL)
[16:11:02.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.462]                 }
[16:11:02.462]                 ...future.workdir <- getwd()
[16:11:02.462]             }
[16:11:02.462]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.462]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.462]         }
[16:11:02.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.462]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:02.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.462]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.462]             base::names(...future.oldOptions))
[16:11:02.462]     }
[16:11:02.462]     if (FALSE) {
[16:11:02.462]     }
[16:11:02.462]     else {
[16:11:02.462]         if (TRUE) {
[16:11:02.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.462]                 open = "w")
[16:11:02.462]         }
[16:11:02.462]         else {
[16:11:02.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.462]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.462]         }
[16:11:02.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.462]             base::sink(type = "output", split = FALSE)
[16:11:02.462]             base::close(...future.stdout)
[16:11:02.462]         }, add = TRUE)
[16:11:02.462]     }
[16:11:02.462]     ...future.frame <- base::sys.nframe()
[16:11:02.462]     ...future.conditions <- base::list()
[16:11:02.462]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.462]     if (FALSE) {
[16:11:02.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.462]     }
[16:11:02.462]     ...future.result <- base::tryCatch({
[16:11:02.462]         base::withCallingHandlers({
[16:11:02.462]             ...future.value <- base::withVisible(base::local({
[16:11:02.462]                 withCallingHandlers({
[16:11:02.462]                   {
[16:11:02.462]                     do.call(function(...) {
[16:11:02.462]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.462]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.462]                         ...future.globals.maxSize)) {
[16:11:02.462]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.462]                         on.exit(options(oopts), add = TRUE)
[16:11:02.462]                       }
[16:11:02.462]                       {
[16:11:02.462]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.462]                           FUN = function(jj) {
[16:11:02.462]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.462]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.462]                           })
[16:11:02.462]                       }
[16:11:02.462]                     }, args = future.call.arguments)
[16:11:02.462]                   }
[16:11:02.462]                 }, immediateCondition = function(cond) {
[16:11:02.462]                   save_rds <- function (object, pathname, ...) 
[16:11:02.462]                   {
[16:11:02.462]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.462]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.462]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.462]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.462]                         fi_tmp[["mtime"]])
[16:11:02.462]                     }
[16:11:02.462]                     tryCatch({
[16:11:02.462]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.462]                     }, error = function(ex) {
[16:11:02.462]                       msg <- conditionMessage(ex)
[16:11:02.462]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.462]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.462]                         fi_tmp[["mtime"]], msg)
[16:11:02.462]                       ex$message <- msg
[16:11:02.462]                       stop(ex)
[16:11:02.462]                     })
[16:11:02.462]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.462]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.462]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.462]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.462]                       fi <- file.info(pathname)
[16:11:02.462]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.462]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.462]                         fi[["size"]], fi[["mtime"]])
[16:11:02.462]                       stop(msg)
[16:11:02.462]                     }
[16:11:02.462]                     invisible(pathname)
[16:11:02.462]                   }
[16:11:02.462]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.462]                     rootPath = tempdir()) 
[16:11:02.462]                   {
[16:11:02.462]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.462]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.462]                       tmpdir = path, fileext = ".rds")
[16:11:02.462]                     save_rds(obj, file)
[16:11:02.462]                   }
[16:11:02.462]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.462]                   {
[16:11:02.462]                     inherits <- base::inherits
[16:11:02.462]                     invokeRestart <- base::invokeRestart
[16:11:02.462]                     is.null <- base::is.null
[16:11:02.462]                     muffled <- FALSE
[16:11:02.462]                     if (inherits(cond, "message")) {
[16:11:02.462]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.462]                       if (muffled) 
[16:11:02.462]                         invokeRestart("muffleMessage")
[16:11:02.462]                     }
[16:11:02.462]                     else if (inherits(cond, "warning")) {
[16:11:02.462]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.462]                       if (muffled) 
[16:11:02.462]                         invokeRestart("muffleWarning")
[16:11:02.462]                     }
[16:11:02.462]                     else if (inherits(cond, "condition")) {
[16:11:02.462]                       if (!is.null(pattern)) {
[16:11:02.462]                         computeRestarts <- base::computeRestarts
[16:11:02.462]                         grepl <- base::grepl
[16:11:02.462]                         restarts <- computeRestarts(cond)
[16:11:02.462]                         for (restart in restarts) {
[16:11:02.462]                           name <- restart$name
[16:11:02.462]                           if (is.null(name)) 
[16:11:02.462]                             next
[16:11:02.462]                           if (!grepl(pattern, name)) 
[16:11:02.462]                             next
[16:11:02.462]                           invokeRestart(restart)
[16:11:02.462]                           muffled <- TRUE
[16:11:02.462]                           break
[16:11:02.462]                         }
[16:11:02.462]                       }
[16:11:02.462]                     }
[16:11:02.462]                     invisible(muffled)
[16:11:02.462]                   }
[16:11:02.462]                   muffleCondition(cond)
[16:11:02.462]                 })
[16:11:02.462]             }))
[16:11:02.462]             future::FutureResult(value = ...future.value$value, 
[16:11:02.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.462]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.462]                     ...future.globalenv.names))
[16:11:02.462]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.462]         }, condition = base::local({
[16:11:02.462]             c <- base::c
[16:11:02.462]             inherits <- base::inherits
[16:11:02.462]             invokeRestart <- base::invokeRestart
[16:11:02.462]             length <- base::length
[16:11:02.462]             list <- base::list
[16:11:02.462]             seq.int <- base::seq.int
[16:11:02.462]             signalCondition <- base::signalCondition
[16:11:02.462]             sys.calls <- base::sys.calls
[16:11:02.462]             `[[` <- base::`[[`
[16:11:02.462]             `+` <- base::`+`
[16:11:02.462]             `<<-` <- base::`<<-`
[16:11:02.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.462]                   3L)]
[16:11:02.462]             }
[16:11:02.462]             function(cond) {
[16:11:02.462]                 is_error <- inherits(cond, "error")
[16:11:02.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.462]                   NULL)
[16:11:02.462]                 if (is_error) {
[16:11:02.462]                   sessionInformation <- function() {
[16:11:02.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.462]                       search = base::search(), system = base::Sys.info())
[16:11:02.462]                   }
[16:11:02.462]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.462]                     cond$call), session = sessionInformation(), 
[16:11:02.462]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.462]                   signalCondition(cond)
[16:11:02.462]                 }
[16:11:02.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.462]                 "immediateCondition"))) {
[16:11:02.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.462]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.462]                   if (TRUE && !signal) {
[16:11:02.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.462]                     {
[16:11:02.462]                       inherits <- base::inherits
[16:11:02.462]                       invokeRestart <- base::invokeRestart
[16:11:02.462]                       is.null <- base::is.null
[16:11:02.462]                       muffled <- FALSE
[16:11:02.462]                       if (inherits(cond, "message")) {
[16:11:02.462]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.462]                         if (muffled) 
[16:11:02.462]                           invokeRestart("muffleMessage")
[16:11:02.462]                       }
[16:11:02.462]                       else if (inherits(cond, "warning")) {
[16:11:02.462]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.462]                         if (muffled) 
[16:11:02.462]                           invokeRestart("muffleWarning")
[16:11:02.462]                       }
[16:11:02.462]                       else if (inherits(cond, "condition")) {
[16:11:02.462]                         if (!is.null(pattern)) {
[16:11:02.462]                           computeRestarts <- base::computeRestarts
[16:11:02.462]                           grepl <- base::grepl
[16:11:02.462]                           restarts <- computeRestarts(cond)
[16:11:02.462]                           for (restart in restarts) {
[16:11:02.462]                             name <- restart$name
[16:11:02.462]                             if (is.null(name)) 
[16:11:02.462]                               next
[16:11:02.462]                             if (!grepl(pattern, name)) 
[16:11:02.462]                               next
[16:11:02.462]                             invokeRestart(restart)
[16:11:02.462]                             muffled <- TRUE
[16:11:02.462]                             break
[16:11:02.462]                           }
[16:11:02.462]                         }
[16:11:02.462]                       }
[16:11:02.462]                       invisible(muffled)
[16:11:02.462]                     }
[16:11:02.462]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.462]                   }
[16:11:02.462]                 }
[16:11:02.462]                 else {
[16:11:02.462]                   if (TRUE) {
[16:11:02.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.462]                     {
[16:11:02.462]                       inherits <- base::inherits
[16:11:02.462]                       invokeRestart <- base::invokeRestart
[16:11:02.462]                       is.null <- base::is.null
[16:11:02.462]                       muffled <- FALSE
[16:11:02.462]                       if (inherits(cond, "message")) {
[16:11:02.462]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.462]                         if (muffled) 
[16:11:02.462]                           invokeRestart("muffleMessage")
[16:11:02.462]                       }
[16:11:02.462]                       else if (inherits(cond, "warning")) {
[16:11:02.462]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.462]                         if (muffled) 
[16:11:02.462]                           invokeRestart("muffleWarning")
[16:11:02.462]                       }
[16:11:02.462]                       else if (inherits(cond, "condition")) {
[16:11:02.462]                         if (!is.null(pattern)) {
[16:11:02.462]                           computeRestarts <- base::computeRestarts
[16:11:02.462]                           grepl <- base::grepl
[16:11:02.462]                           restarts <- computeRestarts(cond)
[16:11:02.462]                           for (restart in restarts) {
[16:11:02.462]                             name <- restart$name
[16:11:02.462]                             if (is.null(name)) 
[16:11:02.462]                               next
[16:11:02.462]                             if (!grepl(pattern, name)) 
[16:11:02.462]                               next
[16:11:02.462]                             invokeRestart(restart)
[16:11:02.462]                             muffled <- TRUE
[16:11:02.462]                             break
[16:11:02.462]                           }
[16:11:02.462]                         }
[16:11:02.462]                       }
[16:11:02.462]                       invisible(muffled)
[16:11:02.462]                     }
[16:11:02.462]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.462]                   }
[16:11:02.462]                 }
[16:11:02.462]             }
[16:11:02.462]         }))
[16:11:02.462]     }, error = function(ex) {
[16:11:02.462]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.462]                 ...future.rng), started = ...future.startTime, 
[16:11:02.462]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.462]             version = "1.8"), class = "FutureResult")
[16:11:02.462]     }, finally = {
[16:11:02.462]         if (!identical(...future.workdir, getwd())) 
[16:11:02.462]             setwd(...future.workdir)
[16:11:02.462]         {
[16:11:02.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.462]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.462]             }
[16:11:02.462]             base::options(...future.oldOptions)
[16:11:02.462]             if (.Platform$OS.type == "windows") {
[16:11:02.462]                 old_names <- names(...future.oldEnvVars)
[16:11:02.462]                 envs <- base::Sys.getenv()
[16:11:02.462]                 names <- names(envs)
[16:11:02.462]                 common <- intersect(names, old_names)
[16:11:02.462]                 added <- setdiff(names, old_names)
[16:11:02.462]                 removed <- setdiff(old_names, names)
[16:11:02.462]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.462]                   envs[common]]
[16:11:02.462]                 NAMES <- toupper(changed)
[16:11:02.462]                 args <- list()
[16:11:02.462]                 for (kk in seq_along(NAMES)) {
[16:11:02.462]                   name <- changed[[kk]]
[16:11:02.462]                   NAME <- NAMES[[kk]]
[16:11:02.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.462]                     next
[16:11:02.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.462]                 }
[16:11:02.462]                 NAMES <- toupper(added)
[16:11:02.462]                 for (kk in seq_along(NAMES)) {
[16:11:02.462]                   name <- added[[kk]]
[16:11:02.462]                   NAME <- NAMES[[kk]]
[16:11:02.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.462]                     next
[16:11:02.462]                   args[[name]] <- ""
[16:11:02.462]                 }
[16:11:02.462]                 NAMES <- toupper(removed)
[16:11:02.462]                 for (kk in seq_along(NAMES)) {
[16:11:02.462]                   name <- removed[[kk]]
[16:11:02.462]                   NAME <- NAMES[[kk]]
[16:11:02.462]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.462]                     next
[16:11:02.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.462]                 }
[16:11:02.462]                 if (length(args) > 0) 
[16:11:02.462]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.462]             }
[16:11:02.462]             else {
[16:11:02.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.462]             }
[16:11:02.462]             {
[16:11:02.462]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.462]                   0L) {
[16:11:02.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.462]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.462]                   base::options(opts)
[16:11:02.462]                 }
[16:11:02.462]                 {
[16:11:02.462]                   {
[16:11:02.462]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.462]                     NULL
[16:11:02.462]                   }
[16:11:02.462]                   options(future.plan = NULL)
[16:11:02.462]                   if (is.na(NA_character_)) 
[16:11:02.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.462]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.462]                     envir = parent.frame()) 
[16:11:02.462]                   {
[16:11:02.462]                     default_workers <- missing(workers)
[16:11:02.462]                     if (is.function(workers)) 
[16:11:02.462]                       workers <- workers()
[16:11:02.462]                     workers <- structure(as.integer(workers), 
[16:11:02.462]                       class = class(workers))
[16:11:02.462]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.462]                       1L)
[16:11:02.462]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.462]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.462]                       if (default_workers) 
[16:11:02.462]                         supportsMulticore(warn = TRUE)
[16:11:02.462]                       return(sequential(..., envir = envir))
[16:11:02.462]                     }
[16:11:02.462]                     oopts <- options(mc.cores = workers)
[16:11:02.462]                     on.exit(options(oopts))
[16:11:02.462]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.462]                       envir = envir)
[16:11:02.462]                     if (!future$lazy) 
[16:11:02.462]                       future <- run(future)
[16:11:02.462]                     invisible(future)
[16:11:02.462]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.462]                 }
[16:11:02.462]             }
[16:11:02.462]         }
[16:11:02.462]     })
[16:11:02.462]     if (TRUE) {
[16:11:02.462]         base::sink(type = "output", split = FALSE)
[16:11:02.462]         if (TRUE) {
[16:11:02.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.462]         }
[16:11:02.462]         else {
[16:11:02.462]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.462]         }
[16:11:02.462]         base::close(...future.stdout)
[16:11:02.462]         ...future.stdout <- NULL
[16:11:02.462]     }
[16:11:02.462]     ...future.result$conditions <- ...future.conditions
[16:11:02.462]     ...future.result$finished <- base::Sys.time()
[16:11:02.462]     ...future.result
[16:11:02.462] }
[16:11:02.466] assign_globals() ...
[16:11:02.466] List of 11
[16:11:02.466]  $ ...future.FUN            :function (x, ...)  
[16:11:02.466]  $ x_FUN                    :function (x)  
[16:11:02.466]  $ times                    : int 1
[16:11:02.466]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.466]  $ stop_if_not              :function (...)  
[16:11:02.466]  $ dim                      : NULL
[16:11:02.466]  $ valid_types              : chr [1:2] "logical" "integer"
[16:11:02.466]  $ future.call.arguments    : list()
[16:11:02.466]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.466]  $ ...future.elements_ii    :List of 2
[16:11:02.466]   ..$ b: num 2
[16:11:02.466]   ..$ c: num 3
[16:11:02.466]  $ ...future.seeds_ii       : NULL
[16:11:02.466]  $ ...future.globals.maxSize: NULL
[16:11:02.466]  - attr(*, "resolved")= logi FALSE
[16:11:02.466]  - attr(*, "total_size")= num 94264
[16:11:02.466]  - attr(*, "where")=List of 11
[16:11:02.466]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.466]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.466]  - attr(*, "already-done")= logi TRUE
[16:11:02.514] - copied ‘...future.FUN’ to environment
[16:11:02.515] - copied ‘x_FUN’ to environment
[16:11:02.515] - copied ‘times’ to environment
[16:11:02.515] - copied ‘stopf’ to environment
[16:11:02.515] - copied ‘stop_if_not’ to environment
[16:11:02.515] - copied ‘dim’ to environment
[16:11:02.515] - copied ‘valid_types’ to environment
[16:11:02.515] - copied ‘future.call.arguments’ to environment
[16:11:02.515] - copied ‘...future.elements_ii’ to environment
[16:11:02.515] - copied ‘...future.seeds_ii’ to environment
[16:11:02.515] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.516] assign_globals() ... done
[16:11:02.516] requestCore(): workers = 2
[16:11:02.518] MulticoreFuture started
[16:11:02.518] - Launch lazy future ... done
[16:11:02.518] run() for ‘MulticoreFuture’ ... done
[16:11:02.519] Created future:
[16:11:02.520] plan(): Setting new future strategy stack:
[16:11:02.520] List of future strategies:
[16:11:02.520] 1. sequential:
[16:11:02.520]    - args: function (..., envir = parent.frame())
[16:11:02.520]    - tweaked: FALSE
[16:11:02.520]    - call: NULL
[16:11:02.521] plan(): nbrOfWorkers() = 1
[16:11:02.523] plan(): Setting new future strategy stack:
[16:11:02.523] List of future strategies:
[16:11:02.523] 1. multicore:
[16:11:02.523]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.523]    - tweaked: FALSE
[16:11:02.523]    - call: plan(strategy)
[16:11:02.528] plan(): nbrOfWorkers() = 2
[16:11:02.519] MulticoreFuture:
[16:11:02.519] Label: ‘future_vapply-2’
[16:11:02.519] Expression:
[16:11:02.519] {
[16:11:02.519]     do.call(function(...) {
[16:11:02.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.519]             on.exit(options(oopts), add = TRUE)
[16:11:02.519]         }
[16:11:02.519]         {
[16:11:02.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.519]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.519]             })
[16:11:02.519]         }
[16:11:02.519]     }, args = future.call.arguments)
[16:11:02.519] }
[16:11:02.519] Lazy evaluation: FALSE
[16:11:02.519] Asynchronous evaluation: TRUE
[16:11:02.519] Local evaluation: TRUE
[16:11:02.519] Environment: R_GlobalEnv
[16:11:02.519] Capture standard output: TRUE
[16:11:02.519] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.519] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:02.519] Packages: 1 packages (‘future.apply’)
[16:11:02.519] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.519] Resolved: TRUE
[16:11:02.519] Value: <not collected>
[16:11:02.519] Conditions captured: <none>
[16:11:02.519] Early signaling: FALSE
[16:11:02.519] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.519] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.529] Chunk #2 of 2 ... DONE
[16:11:02.529] Launching 2 futures (chunks) ... DONE
[16:11:02.529] Resolving 2 futures (chunks) ...
[16:11:02.529] resolve() on list ...
[16:11:02.530]  recursive: 0
[16:11:02.530]  length: 2
[16:11:02.530] 
[16:11:02.530] Future #1
[16:11:02.531] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:02.531] - nx: 2
[16:11:02.532] - relay: TRUE
[16:11:02.532] - stdout: TRUE
[16:11:02.532] - signal: TRUE
[16:11:02.532] - resignal: FALSE
[16:11:02.532] - force: TRUE
[16:11:02.532] - relayed: [n=2] FALSE, FALSE
[16:11:02.533] - queued futures: [n=2] FALSE, FALSE
[16:11:02.533]  - until=1
[16:11:02.533]  - relaying element #1
[16:11:02.533] - relayed: [n=2] TRUE, FALSE
[16:11:02.534] - queued futures: [n=2] TRUE, FALSE
[16:11:02.534] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:02.534]  length: 1 (resolved future 1)
[16:11:02.534] Future #2
[16:11:02.536] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:11:02.536] - nx: 2
[16:11:02.536] - relay: TRUE
[16:11:02.536] - stdout: TRUE
[16:11:02.536] - signal: TRUE
[16:11:02.537] - resignal: FALSE
[16:11:02.537] - force: TRUE
[16:11:02.537] - relayed: [n=2] TRUE, FALSE
[16:11:02.537] - queued futures: [n=2] TRUE, FALSE
[16:11:02.537]  - until=2
[16:11:02.537]  - relaying element #2
[16:11:02.537] - relayed: [n=2] TRUE, TRUE
[16:11:02.538] - queued futures: [n=2] TRUE, TRUE
[16:11:02.538] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:11:02.538]  length: 0 (resolved future 2)
[16:11:02.538] Relaying remaining futures
[16:11:02.538] signalConditionsASAP(NULL, pos=0) ...
[16:11:02.538] - nx: 2
[16:11:02.538] - relay: TRUE
[16:11:02.538] - stdout: TRUE
[16:11:02.539] - signal: TRUE
[16:11:02.539] - resignal: FALSE
[16:11:02.539] - force: TRUE
[16:11:02.539] - relayed: [n=2] TRUE, TRUE
[16:11:02.539] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:02.539] - relayed: [n=2] TRUE, TRUE
[16:11:02.539] - queued futures: [n=2] TRUE, TRUE
[16:11:02.539] signalConditionsASAP(NULL, pos=0) ... done
[16:11:02.539] resolve() on list ... DONE
[16:11:02.540]  - Number of value chunks collected: 2
[16:11:02.540] Resolving 2 futures (chunks) ... DONE
[16:11:02.540] Reducing values from 2 chunks ...
[16:11:02.540]  - Number of values collected after concatenation: 3
[16:11:02.540]  - Number of values expected: 3
[16:11:02.540] Reducing values from 2 chunks ... DONE
[16:11:02.540] future_lapply() ... DONE
- exceptions ...
[16:11:02.541] future_lapply() ...
[16:11:02.547] Number of chunks: 2
[16:11:02.547] getGlobalsAndPackagesXApply() ...
[16:11:02.547]  - future.globals: TRUE
[16:11:02.547] getGlobalsAndPackages() ...
[16:11:02.547] Searching for globals...
[16:11:02.552] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:02.552] Searching for globals ... DONE
[16:11:02.552] Resolving globals: FALSE
[16:11:02.553] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:11:02.554] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:02.554] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:02.554] - packages: [1] ‘future.apply’
[16:11:02.554] getGlobalsAndPackages() ... DONE
[16:11:02.554]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:02.554]  - needed namespaces: [n=1] ‘future.apply’
[16:11:02.555] Finding globals ... DONE
[16:11:02.555]  - use_args: TRUE
[16:11:02.555]  - Getting '...' globals ...
[16:11:02.555] resolve() on list ...
[16:11:02.555]  recursive: 0
[16:11:02.555]  length: 1
[16:11:02.555]  elements: ‘...’
[16:11:02.556]  length: 0 (resolved future 1)
[16:11:02.556] resolve() on list ... DONE
[16:11:02.556]    - '...' content: [n=0] 
[16:11:02.556] List of 1
[16:11:02.556]  $ ...: list()
[16:11:02.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.556]  - attr(*, "where")=List of 1
[16:11:02.556]   ..$ ...:<environment: 0x561e89c87cf0> 
[16:11:02.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.556]  - attr(*, "resolved")= logi TRUE
[16:11:02.556]  - attr(*, "total_size")= num NA
[16:11:02.559]  - Getting '...' globals ... DONE
[16:11:02.559] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:02.559] List of 8
[16:11:02.559]  $ ...future.FUN:function (x, ...)  
[16:11:02.559]  $ x_FUN        :function (x)  
[16:11:02.559]  $ times        : int 2
[16:11:02.559]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.559]  $ stop_if_not  :function (...)  
[16:11:02.559]  $ dim          : NULL
[16:11:02.559]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:02.559]  $ ...          : list()
[16:11:02.559]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.559]  - attr(*, "where")=List of 8
[16:11:02.559]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:02.559]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:02.559]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:02.559]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:02.559]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:02.559]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:02.559]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:02.559]   ..$ ...          :<environment: 0x561e89c87cf0> 
[16:11:02.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.559]  - attr(*, "resolved")= logi FALSE
[16:11:02.559]  - attr(*, "total_size")= num 95128
[16:11:02.566] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:02.566] getGlobalsAndPackagesXApply() ... DONE
[16:11:02.566] Number of futures (= number of chunks): 2
[16:11:02.566] Launching 2 futures (chunks) ...
[16:11:02.566] Chunk #1 of 2 ...
[16:11:02.566]  - Finding globals in 'X' for chunk #1 ...
[16:11:02.567] getGlobalsAndPackages() ...
[16:11:02.567] Searching for globals...
[16:11:02.567] 
[16:11:02.567] Searching for globals ... DONE
[16:11:02.567] - globals: [0] <none>
[16:11:02.567] getGlobalsAndPackages() ... DONE
[16:11:02.568]    + additional globals found: [n=0] 
[16:11:02.568]    + additional namespaces needed: [n=0] 
[16:11:02.568]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:02.568]  - seeds: <none>
[16:11:02.568] getGlobalsAndPackages() ...
[16:11:02.568] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.568] Resolving globals: FALSE
[16:11:02.569] Tweak future expression to call with '...' arguments ...
[16:11:02.569] {
[16:11:02.569]     do.call(function(...) {
[16:11:02.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.569]             on.exit(options(oopts), add = TRUE)
[16:11:02.569]         }
[16:11:02.569]         {
[16:11:02.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.569]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.569]             })
[16:11:02.569]         }
[16:11:02.569]     }, args = future.call.arguments)
[16:11:02.569] }
[16:11:02.569] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.570] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.570] - packages: [1] ‘future.apply’
[16:11:02.570] getGlobalsAndPackages() ... DONE
[16:11:02.570] run() for ‘Future’ ...
[16:11:02.570] - state: ‘created’
[16:11:02.571] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.575] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.575] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.575]   - Field: ‘label’
[16:11:02.576]   - Field: ‘local’
[16:11:02.576]   - Field: ‘owner’
[16:11:02.576]   - Field: ‘envir’
[16:11:02.576]   - Field: ‘workers’
[16:11:02.576]   - Field: ‘packages’
[16:11:02.576]   - Field: ‘gc’
[16:11:02.576]   - Field: ‘job’
[16:11:02.576]   - Field: ‘conditions’
[16:11:02.577]   - Field: ‘expr’
[16:11:02.577]   - Field: ‘uuid’
[16:11:02.577]   - Field: ‘seed’
[16:11:02.577]   - Field: ‘version’
[16:11:02.577]   - Field: ‘result’
[16:11:02.577]   - Field: ‘asynchronous’
[16:11:02.577]   - Field: ‘calls’
[16:11:02.577]   - Field: ‘globals’
[16:11:02.578]   - Field: ‘stdout’
[16:11:02.578]   - Field: ‘earlySignal’
[16:11:02.578]   - Field: ‘lazy’
[16:11:02.578]   - Field: ‘state’
[16:11:02.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.578] - Launch lazy future ...
[16:11:02.578] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:02.579] Packages needed by future strategies (n = 0): <none>
[16:11:02.579] {
[16:11:02.579]     {
[16:11:02.579]         {
[16:11:02.579]             ...future.startTime <- base::Sys.time()
[16:11:02.579]             {
[16:11:02.579]                 {
[16:11:02.579]                   {
[16:11:02.579]                     {
[16:11:02.579]                       {
[16:11:02.579]                         base::local({
[16:11:02.579]                           has_future <- base::requireNamespace("future", 
[16:11:02.579]                             quietly = TRUE)
[16:11:02.579]                           if (has_future) {
[16:11:02.579]                             ns <- base::getNamespace("future")
[16:11:02.579]                             version <- ns[[".package"]][["version"]]
[16:11:02.579]                             if (is.null(version)) 
[16:11:02.579]                               version <- utils::packageVersion("future")
[16:11:02.579]                           }
[16:11:02.579]                           else {
[16:11:02.579]                             version <- NULL
[16:11:02.579]                           }
[16:11:02.579]                           if (!has_future || version < "1.8.0") {
[16:11:02.579]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.579]                               "", base::R.version$version.string), 
[16:11:02.579]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:02.579]                                 base::R.version$platform, 8 * 
[16:11:02.579]                                   base::.Machine$sizeof.pointer), 
[16:11:02.579]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.579]                                 "release", "version")], collapse = " "), 
[16:11:02.579]                               hostname = base::Sys.info()[["nodename"]])
[16:11:02.579]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.579]                               info)
[16:11:02.579]                             info <- base::paste(info, collapse = "; ")
[16:11:02.579]                             if (!has_future) {
[16:11:02.579]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.579]                                 info)
[16:11:02.579]                             }
[16:11:02.579]                             else {
[16:11:02.579]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.579]                                 info, version)
[16:11:02.579]                             }
[16:11:02.579]                             base::stop(msg)
[16:11:02.579]                           }
[16:11:02.579]                         })
[16:11:02.579]                       }
[16:11:02.579]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.579]                       base::options(mc.cores = 1L)
[16:11:02.579]                     }
[16:11:02.579]                     base::local({
[16:11:02.579]                       for (pkg in "future.apply") {
[16:11:02.579]                         base::loadNamespace(pkg)
[16:11:02.579]                         base::library(pkg, character.only = TRUE)
[16:11:02.579]                       }
[16:11:02.579]                     })
[16:11:02.579]                   }
[16:11:02.579]                   options(future.plan = NULL)
[16:11:02.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.579]                 }
[16:11:02.579]                 ...future.workdir <- getwd()
[16:11:02.579]             }
[16:11:02.579]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.579]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.579]         }
[16:11:02.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:02.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.579]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.579]             base::names(...future.oldOptions))
[16:11:02.579]     }
[16:11:02.579]     if (FALSE) {
[16:11:02.579]     }
[16:11:02.579]     else {
[16:11:02.579]         if (TRUE) {
[16:11:02.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.579]                 open = "w")
[16:11:02.579]         }
[16:11:02.579]         else {
[16:11:02.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.579]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.579]         }
[16:11:02.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.579]             base::sink(type = "output", split = FALSE)
[16:11:02.579]             base::close(...future.stdout)
[16:11:02.579]         }, add = TRUE)
[16:11:02.579]     }
[16:11:02.579]     ...future.frame <- base::sys.nframe()
[16:11:02.579]     ...future.conditions <- base::list()
[16:11:02.579]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.579]     if (FALSE) {
[16:11:02.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.579]     }
[16:11:02.579]     ...future.result <- base::tryCatch({
[16:11:02.579]         base::withCallingHandlers({
[16:11:02.579]             ...future.value <- base::withVisible(base::local({
[16:11:02.579]                 withCallingHandlers({
[16:11:02.579]                   {
[16:11:02.579]                     do.call(function(...) {
[16:11:02.579]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.579]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.579]                         ...future.globals.maxSize)) {
[16:11:02.579]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.579]                         on.exit(options(oopts), add = TRUE)
[16:11:02.579]                       }
[16:11:02.579]                       {
[16:11:02.579]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.579]                           FUN = function(jj) {
[16:11:02.579]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.579]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.579]                           })
[16:11:02.579]                       }
[16:11:02.579]                     }, args = future.call.arguments)
[16:11:02.579]                   }
[16:11:02.579]                 }, immediateCondition = function(cond) {
[16:11:02.579]                   save_rds <- function (object, pathname, ...) 
[16:11:02.579]                   {
[16:11:02.579]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.579]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.579]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.579]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.579]                         fi_tmp[["mtime"]])
[16:11:02.579]                     }
[16:11:02.579]                     tryCatch({
[16:11:02.579]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.579]                     }, error = function(ex) {
[16:11:02.579]                       msg <- conditionMessage(ex)
[16:11:02.579]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.579]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.579]                         fi_tmp[["mtime"]], msg)
[16:11:02.579]                       ex$message <- msg
[16:11:02.579]                       stop(ex)
[16:11:02.579]                     })
[16:11:02.579]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.579]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.579]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.579]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.579]                       fi <- file.info(pathname)
[16:11:02.579]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.579]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.579]                         fi[["size"]], fi[["mtime"]])
[16:11:02.579]                       stop(msg)
[16:11:02.579]                     }
[16:11:02.579]                     invisible(pathname)
[16:11:02.579]                   }
[16:11:02.579]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.579]                     rootPath = tempdir()) 
[16:11:02.579]                   {
[16:11:02.579]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.579]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.579]                       tmpdir = path, fileext = ".rds")
[16:11:02.579]                     save_rds(obj, file)
[16:11:02.579]                   }
[16:11:02.579]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.579]                   {
[16:11:02.579]                     inherits <- base::inherits
[16:11:02.579]                     invokeRestart <- base::invokeRestart
[16:11:02.579]                     is.null <- base::is.null
[16:11:02.579]                     muffled <- FALSE
[16:11:02.579]                     if (inherits(cond, "message")) {
[16:11:02.579]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.579]                       if (muffled) 
[16:11:02.579]                         invokeRestart("muffleMessage")
[16:11:02.579]                     }
[16:11:02.579]                     else if (inherits(cond, "warning")) {
[16:11:02.579]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.579]                       if (muffled) 
[16:11:02.579]                         invokeRestart("muffleWarning")
[16:11:02.579]                     }
[16:11:02.579]                     else if (inherits(cond, "condition")) {
[16:11:02.579]                       if (!is.null(pattern)) {
[16:11:02.579]                         computeRestarts <- base::computeRestarts
[16:11:02.579]                         grepl <- base::grepl
[16:11:02.579]                         restarts <- computeRestarts(cond)
[16:11:02.579]                         for (restart in restarts) {
[16:11:02.579]                           name <- restart$name
[16:11:02.579]                           if (is.null(name)) 
[16:11:02.579]                             next
[16:11:02.579]                           if (!grepl(pattern, name)) 
[16:11:02.579]                             next
[16:11:02.579]                           invokeRestart(restart)
[16:11:02.579]                           muffled <- TRUE
[16:11:02.579]                           break
[16:11:02.579]                         }
[16:11:02.579]                       }
[16:11:02.579]                     }
[16:11:02.579]                     invisible(muffled)
[16:11:02.579]                   }
[16:11:02.579]                   muffleCondition(cond)
[16:11:02.579]                 })
[16:11:02.579]             }))
[16:11:02.579]             future::FutureResult(value = ...future.value$value, 
[16:11:02.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.579]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.579]                     ...future.globalenv.names))
[16:11:02.579]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.579]         }, condition = base::local({
[16:11:02.579]             c <- base::c
[16:11:02.579]             inherits <- base::inherits
[16:11:02.579]             invokeRestart <- base::invokeRestart
[16:11:02.579]             length <- base::length
[16:11:02.579]             list <- base::list
[16:11:02.579]             seq.int <- base::seq.int
[16:11:02.579]             signalCondition <- base::signalCondition
[16:11:02.579]             sys.calls <- base::sys.calls
[16:11:02.579]             `[[` <- base::`[[`
[16:11:02.579]             `+` <- base::`+`
[16:11:02.579]             `<<-` <- base::`<<-`
[16:11:02.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.579]                   3L)]
[16:11:02.579]             }
[16:11:02.579]             function(cond) {
[16:11:02.579]                 is_error <- inherits(cond, "error")
[16:11:02.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.579]                   NULL)
[16:11:02.579]                 if (is_error) {
[16:11:02.579]                   sessionInformation <- function() {
[16:11:02.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.579]                       search = base::search(), system = base::Sys.info())
[16:11:02.579]                   }
[16:11:02.579]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.579]                     cond$call), session = sessionInformation(), 
[16:11:02.579]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.579]                   signalCondition(cond)
[16:11:02.579]                 }
[16:11:02.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.579]                 "immediateCondition"))) {
[16:11:02.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.579]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.579]                   if (TRUE && !signal) {
[16:11:02.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.579]                     {
[16:11:02.579]                       inherits <- base::inherits
[16:11:02.579]                       invokeRestart <- base::invokeRestart
[16:11:02.579]                       is.null <- base::is.null
[16:11:02.579]                       muffled <- FALSE
[16:11:02.579]                       if (inherits(cond, "message")) {
[16:11:02.579]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.579]                         if (muffled) 
[16:11:02.579]                           invokeRestart("muffleMessage")
[16:11:02.579]                       }
[16:11:02.579]                       else if (inherits(cond, "warning")) {
[16:11:02.579]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.579]                         if (muffled) 
[16:11:02.579]                           invokeRestart("muffleWarning")
[16:11:02.579]                       }
[16:11:02.579]                       else if (inherits(cond, "condition")) {
[16:11:02.579]                         if (!is.null(pattern)) {
[16:11:02.579]                           computeRestarts <- base::computeRestarts
[16:11:02.579]                           grepl <- base::grepl
[16:11:02.579]                           restarts <- computeRestarts(cond)
[16:11:02.579]                           for (restart in restarts) {
[16:11:02.579]                             name <- restart$name
[16:11:02.579]                             if (is.null(name)) 
[16:11:02.579]                               next
[16:11:02.579]                             if (!grepl(pattern, name)) 
[16:11:02.579]                               next
[16:11:02.579]                             invokeRestart(restart)
[16:11:02.579]                             muffled <- TRUE
[16:11:02.579]                             break
[16:11:02.579]                           }
[16:11:02.579]                         }
[16:11:02.579]                       }
[16:11:02.579]                       invisible(muffled)
[16:11:02.579]                     }
[16:11:02.579]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.579]                   }
[16:11:02.579]                 }
[16:11:02.579]                 else {
[16:11:02.579]                   if (TRUE) {
[16:11:02.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.579]                     {
[16:11:02.579]                       inherits <- base::inherits
[16:11:02.579]                       invokeRestart <- base::invokeRestart
[16:11:02.579]                       is.null <- base::is.null
[16:11:02.579]                       muffled <- FALSE
[16:11:02.579]                       if (inherits(cond, "message")) {
[16:11:02.579]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.579]                         if (muffled) 
[16:11:02.579]                           invokeRestart("muffleMessage")
[16:11:02.579]                       }
[16:11:02.579]                       else if (inherits(cond, "warning")) {
[16:11:02.579]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.579]                         if (muffled) 
[16:11:02.579]                           invokeRestart("muffleWarning")
[16:11:02.579]                       }
[16:11:02.579]                       else if (inherits(cond, "condition")) {
[16:11:02.579]                         if (!is.null(pattern)) {
[16:11:02.579]                           computeRestarts <- base::computeRestarts
[16:11:02.579]                           grepl <- base::grepl
[16:11:02.579]                           restarts <- computeRestarts(cond)
[16:11:02.579]                           for (restart in restarts) {
[16:11:02.579]                             name <- restart$name
[16:11:02.579]                             if (is.null(name)) 
[16:11:02.579]                               next
[16:11:02.579]                             if (!grepl(pattern, name)) 
[16:11:02.579]                               next
[16:11:02.579]                             invokeRestart(restart)
[16:11:02.579]                             muffled <- TRUE
[16:11:02.579]                             break
[16:11:02.579]                           }
[16:11:02.579]                         }
[16:11:02.579]                       }
[16:11:02.579]                       invisible(muffled)
[16:11:02.579]                     }
[16:11:02.579]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.579]                   }
[16:11:02.579]                 }
[16:11:02.579]             }
[16:11:02.579]         }))
[16:11:02.579]     }, error = function(ex) {
[16:11:02.579]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.579]                 ...future.rng), started = ...future.startTime, 
[16:11:02.579]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.579]             version = "1.8"), class = "FutureResult")
[16:11:02.579]     }, finally = {
[16:11:02.579]         if (!identical(...future.workdir, getwd())) 
[16:11:02.579]             setwd(...future.workdir)
[16:11:02.579]         {
[16:11:02.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.579]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.579]             }
[16:11:02.579]             base::options(...future.oldOptions)
[16:11:02.579]             if (.Platform$OS.type == "windows") {
[16:11:02.579]                 old_names <- names(...future.oldEnvVars)
[16:11:02.579]                 envs <- base::Sys.getenv()
[16:11:02.579]                 names <- names(envs)
[16:11:02.579]                 common <- intersect(names, old_names)
[16:11:02.579]                 added <- setdiff(names, old_names)
[16:11:02.579]                 removed <- setdiff(old_names, names)
[16:11:02.579]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.579]                   envs[common]]
[16:11:02.579]                 NAMES <- toupper(changed)
[16:11:02.579]                 args <- list()
[16:11:02.579]                 for (kk in seq_along(NAMES)) {
[16:11:02.579]                   name <- changed[[kk]]
[16:11:02.579]                   NAME <- NAMES[[kk]]
[16:11:02.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.579]                     next
[16:11:02.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.579]                 }
[16:11:02.579]                 NAMES <- toupper(added)
[16:11:02.579]                 for (kk in seq_along(NAMES)) {
[16:11:02.579]                   name <- added[[kk]]
[16:11:02.579]                   NAME <- NAMES[[kk]]
[16:11:02.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.579]                     next
[16:11:02.579]                   args[[name]] <- ""
[16:11:02.579]                 }
[16:11:02.579]                 NAMES <- toupper(removed)
[16:11:02.579]                 for (kk in seq_along(NAMES)) {
[16:11:02.579]                   name <- removed[[kk]]
[16:11:02.579]                   NAME <- NAMES[[kk]]
[16:11:02.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.579]                     next
[16:11:02.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.579]                 }
[16:11:02.579]                 if (length(args) > 0) 
[16:11:02.579]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.579]             }
[16:11:02.579]             else {
[16:11:02.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.579]             }
[16:11:02.579]             {
[16:11:02.579]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.579]                   0L) {
[16:11:02.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.579]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.579]                   base::options(opts)
[16:11:02.579]                 }
[16:11:02.579]                 {
[16:11:02.579]                   {
[16:11:02.579]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.579]                     NULL
[16:11:02.579]                   }
[16:11:02.579]                   options(future.plan = NULL)
[16:11:02.579]                   if (is.na(NA_character_)) 
[16:11:02.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.579]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.579]                     envir = parent.frame()) 
[16:11:02.579]                   {
[16:11:02.579]                     default_workers <- missing(workers)
[16:11:02.579]                     if (is.function(workers)) 
[16:11:02.579]                       workers <- workers()
[16:11:02.579]                     workers <- structure(as.integer(workers), 
[16:11:02.579]                       class = class(workers))
[16:11:02.579]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.579]                       1L)
[16:11:02.579]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.579]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.579]                       if (default_workers) 
[16:11:02.579]                         supportsMulticore(warn = TRUE)
[16:11:02.579]                       return(sequential(..., envir = envir))
[16:11:02.579]                     }
[16:11:02.579]                     oopts <- options(mc.cores = workers)
[16:11:02.579]                     on.exit(options(oopts))
[16:11:02.579]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.579]                       envir = envir)
[16:11:02.579]                     if (!future$lazy) 
[16:11:02.579]                       future <- run(future)
[16:11:02.579]                     invisible(future)
[16:11:02.579]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.579]                 }
[16:11:02.579]             }
[16:11:02.579]         }
[16:11:02.579]     })
[16:11:02.579]     if (TRUE) {
[16:11:02.579]         base::sink(type = "output", split = FALSE)
[16:11:02.579]         if (TRUE) {
[16:11:02.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.579]         }
[16:11:02.579]         else {
[16:11:02.579]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.579]         }
[16:11:02.579]         base::close(...future.stdout)
[16:11:02.579]         ...future.stdout <- NULL
[16:11:02.579]     }
[16:11:02.579]     ...future.result$conditions <- ...future.conditions
[16:11:02.579]     ...future.result$finished <- base::Sys.time()
[16:11:02.579]     ...future.result
[16:11:02.579] }
[16:11:02.582] assign_globals() ...
[16:11:02.582] List of 11
[16:11:02.582]  $ ...future.FUN            :function (x, ...)  
[16:11:02.582]  $ x_FUN                    :function (x)  
[16:11:02.582]  $ times                    : int 2
[16:11:02.582]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.582]  $ stop_if_not              :function (...)  
[16:11:02.582]  $ dim                      : NULL
[16:11:02.582]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:02.582]  $ future.call.arguments    : list()
[16:11:02.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.582]  $ ...future.elements_ii    :List of 1
[16:11:02.582]   ..$ : int 1
[16:11:02.582]  $ ...future.seeds_ii       : NULL
[16:11:02.582]  $ ...future.globals.maxSize: NULL
[16:11:02.582]  - attr(*, "where")=List of 11
[16:11:02.582]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.582]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.582]  - attr(*, "resolved")= logi FALSE
[16:11:02.582]  - attr(*, "total_size")= num 95128
[16:11:02.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.582]  - attr(*, "already-done")= logi TRUE
[16:11:02.592] - copied ‘...future.FUN’ to environment
[16:11:02.592] - copied ‘x_FUN’ to environment
[16:11:02.592] - copied ‘times’ to environment
[16:11:02.592] - copied ‘stopf’ to environment
[16:11:02.592] - copied ‘stop_if_not’ to environment
[16:11:02.592] - copied ‘dim’ to environment
[16:11:02.592] - copied ‘valid_types’ to environment
[16:11:02.593] - copied ‘future.call.arguments’ to environment
[16:11:02.593] - copied ‘...future.elements_ii’ to environment
[16:11:02.593] - copied ‘...future.seeds_ii’ to environment
[16:11:02.593] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.593] assign_globals() ... done
[16:11:02.593] requestCore(): workers = 2
[16:11:02.595] MulticoreFuture started
[16:11:02.595] - Launch lazy future ... done
[16:11:02.596] run() for ‘MulticoreFuture’ ... done
[16:11:02.596] Created future:
[16:11:02.597] plan(): Setting new future strategy stack:
[16:11:02.597] List of future strategies:
[16:11:02.597] 1. sequential:
[16:11:02.597]    - args: function (..., envir = parent.frame())
[16:11:02.597]    - tweaked: FALSE
[16:11:02.597]    - call: NULL
[16:11:02.598] plan(): nbrOfWorkers() = 1
[16:11:02.600] plan(): Setting new future strategy stack:
[16:11:02.600] List of future strategies:
[16:11:02.600] 1. multicore:
[16:11:02.600]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.600]    - tweaked: FALSE
[16:11:02.600]    - call: plan(strategy)
[16:11:02.605] plan(): nbrOfWorkers() = 2
[16:11:02.596] MulticoreFuture:
[16:11:02.596] Label: ‘future_vapply-1’
[16:11:02.596] Expression:
[16:11:02.596] {
[16:11:02.596]     do.call(function(...) {
[16:11:02.596]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.596]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.596]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.596]             on.exit(options(oopts), add = TRUE)
[16:11:02.596]         }
[16:11:02.596]         {
[16:11:02.596]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.596]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.596]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.596]             })
[16:11:02.596]         }
[16:11:02.596]     }, args = future.call.arguments)
[16:11:02.596] }
[16:11:02.596] Lazy evaluation: FALSE
[16:11:02.596] Asynchronous evaluation: TRUE
[16:11:02.596] Local evaluation: TRUE
[16:11:02.596] Environment: R_GlobalEnv
[16:11:02.596] Capture standard output: TRUE
[16:11:02.596] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.596] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:02.596] Packages: 1 packages (‘future.apply’)
[16:11:02.596] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.596] Resolved: FALSE
[16:11:02.596] Value: <not collected>
[16:11:02.596] Conditions captured: <none>
[16:11:02.596] Early signaling: FALSE
[16:11:02.596] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.596] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.609] Chunk #1 of 2 ... DONE
[16:11:02.609] Chunk #2 of 2 ...
[16:11:02.609]  - Finding globals in 'X' for chunk #2 ...
[16:11:02.609] getGlobalsAndPackages() ...
[16:11:02.609] Searching for globals...
[16:11:02.610] 
[16:11:02.610] Searching for globals ... DONE
[16:11:02.610] - globals: [0] <none>
[16:11:02.610] getGlobalsAndPackages() ... DONE
[16:11:02.610]    + additional globals found: [n=0] 
[16:11:02.610]    + additional namespaces needed: [n=0] 
[16:11:02.611]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:02.611]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:02.611]  - seeds: <none>
[16:11:02.611] getGlobalsAndPackages() ...
[16:11:02.611] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.611] Resolving globals: FALSE
[16:11:02.612] Tweak future expression to call with '...' arguments ...
[16:11:02.612] {
[16:11:02.612]     do.call(function(...) {
[16:11:02.612]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.612]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.612]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.612]             on.exit(options(oopts), add = TRUE)
[16:11:02.612]         }
[16:11:02.612]         {
[16:11:02.612]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.612]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.612]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.612]             })
[16:11:02.612]         }
[16:11:02.612]     }, args = future.call.arguments)
[16:11:02.612] }
[16:11:02.612] Tweak future expression to call with '...' arguments ... DONE
[16:11:02.613] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:02.613] - packages: [1] ‘future.apply’
[16:11:02.613] getGlobalsAndPackages() ... DONE
[16:11:02.614] run() for ‘Future’ ...
[16:11:02.614] - state: ‘created’
[16:11:02.614] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:11:02.618] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.619] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:11:02.619]   - Field: ‘label’
[16:11:02.619]   - Field: ‘local’
[16:11:02.619]   - Field: ‘owner’
[16:11:02.619]   - Field: ‘envir’
[16:11:02.619]   - Field: ‘workers’
[16:11:02.619]   - Field: ‘packages’
[16:11:02.619]   - Field: ‘gc’
[16:11:02.620]   - Field: ‘job’
[16:11:02.620]   - Field: ‘conditions’
[16:11:02.620]   - Field: ‘expr’
[16:11:02.620]   - Field: ‘uuid’
[16:11:02.620]   - Field: ‘seed’
[16:11:02.620]   - Field: ‘version’
[16:11:02.620]   - Field: ‘result’
[16:11:02.621]   - Field: ‘asynchronous’
[16:11:02.621]   - Field: ‘calls’
[16:11:02.621]   - Field: ‘globals’
[16:11:02.621]   - Field: ‘stdout’
[16:11:02.621]   - Field: ‘earlySignal’
[16:11:02.621]   - Field: ‘lazy’
[16:11:02.621]   - Field: ‘state’
[16:11:02.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:11:02.621] - Launch lazy future ...
[16:11:02.622] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:02.622] Packages needed by future strategies (n = 0): <none>
[16:11:02.623] {
[16:11:02.623]     {
[16:11:02.623]         {
[16:11:02.623]             ...future.startTime <- base::Sys.time()
[16:11:02.623]             {
[16:11:02.623]                 {
[16:11:02.623]                   {
[16:11:02.623]                     {
[16:11:02.623]                       {
[16:11:02.623]                         base::local({
[16:11:02.623]                           has_future <- base::requireNamespace("future", 
[16:11:02.623]                             quietly = TRUE)
[16:11:02.623]                           if (has_future) {
[16:11:02.623]                             ns <- base::getNamespace("future")
[16:11:02.623]                             version <- ns[[".package"]][["version"]]
[16:11:02.623]                             if (is.null(version)) 
[16:11:02.623]                               version <- utils::packageVersion("future")
[16:11:02.623]                           }
[16:11:02.623]                           else {
[16:11:02.623]                             version <- NULL
[16:11:02.623]                           }
[16:11:02.623]                           if (!has_future || version < "1.8.0") {
[16:11:02.623]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:02.623]                               "", base::R.version$version.string), 
[16:11:02.623]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:02.623]                                 base::R.version$platform, 8 * 
[16:11:02.623]                                   base::.Machine$sizeof.pointer), 
[16:11:02.623]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:02.623]                                 "release", "version")], collapse = " "), 
[16:11:02.623]                               hostname = base::Sys.info()[["nodename"]])
[16:11:02.623]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:02.623]                               info)
[16:11:02.623]                             info <- base::paste(info, collapse = "; ")
[16:11:02.623]                             if (!has_future) {
[16:11:02.623]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:02.623]                                 info)
[16:11:02.623]                             }
[16:11:02.623]                             else {
[16:11:02.623]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:02.623]                                 info, version)
[16:11:02.623]                             }
[16:11:02.623]                             base::stop(msg)
[16:11:02.623]                           }
[16:11:02.623]                         })
[16:11:02.623]                       }
[16:11:02.623]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:02.623]                       base::options(mc.cores = 1L)
[16:11:02.623]                     }
[16:11:02.623]                     base::local({
[16:11:02.623]                       for (pkg in "future.apply") {
[16:11:02.623]                         base::loadNamespace(pkg)
[16:11:02.623]                         base::library(pkg, character.only = TRUE)
[16:11:02.623]                       }
[16:11:02.623]                     })
[16:11:02.623]                   }
[16:11:02.623]                   options(future.plan = NULL)
[16:11:02.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:02.623]                 }
[16:11:02.623]                 ...future.workdir <- getwd()
[16:11:02.623]             }
[16:11:02.623]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:02.623]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:02.623]         }
[16:11:02.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:02.623]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:02.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:02.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:02.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:02.623]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:02.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:02.623]             base::names(...future.oldOptions))
[16:11:02.623]     }
[16:11:02.623]     if (FALSE) {
[16:11:02.623]     }
[16:11:02.623]     else {
[16:11:02.623]         if (TRUE) {
[16:11:02.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:02.623]                 open = "w")
[16:11:02.623]         }
[16:11:02.623]         else {
[16:11:02.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:02.623]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:02.623]         }
[16:11:02.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:02.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:02.623]             base::sink(type = "output", split = FALSE)
[16:11:02.623]             base::close(...future.stdout)
[16:11:02.623]         }, add = TRUE)
[16:11:02.623]     }
[16:11:02.623]     ...future.frame <- base::sys.nframe()
[16:11:02.623]     ...future.conditions <- base::list()
[16:11:02.623]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:02.623]     if (FALSE) {
[16:11:02.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:02.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:02.623]     }
[16:11:02.623]     ...future.result <- base::tryCatch({
[16:11:02.623]         base::withCallingHandlers({
[16:11:02.623]             ...future.value <- base::withVisible(base::local({
[16:11:02.623]                 withCallingHandlers({
[16:11:02.623]                   {
[16:11:02.623]                     do.call(function(...) {
[16:11:02.623]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.623]                       if (!identical(...future.globals.maxSize.org, 
[16:11:02.623]                         ...future.globals.maxSize)) {
[16:11:02.623]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.623]                         on.exit(options(oopts), add = TRUE)
[16:11:02.623]                       }
[16:11:02.623]                       {
[16:11:02.623]                         lapply(seq_along(...future.elements_ii), 
[16:11:02.623]                           FUN = function(jj) {
[16:11:02.623]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.623]                             ...future.FUN(...future.X_jj, ...)
[16:11:02.623]                           })
[16:11:02.623]                       }
[16:11:02.623]                     }, args = future.call.arguments)
[16:11:02.623]                   }
[16:11:02.623]                 }, immediateCondition = function(cond) {
[16:11:02.623]                   save_rds <- function (object, pathname, ...) 
[16:11:02.623]                   {
[16:11:02.623]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:11:02.623]                     if (file_test("-f", pathname_tmp)) {
[16:11:02.623]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.623]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:11:02.623]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.623]                         fi_tmp[["mtime"]])
[16:11:02.623]                     }
[16:11:02.623]                     tryCatch({
[16:11:02.623]                       saveRDS(object, file = pathname_tmp, ...)
[16:11:02.623]                     }, error = function(ex) {
[16:11:02.623]                       msg <- conditionMessage(ex)
[16:11:02.623]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.623]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:11:02.623]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.623]                         fi_tmp[["mtime"]], msg)
[16:11:02.623]                       ex$message <- msg
[16:11:02.623]                       stop(ex)
[16:11:02.623]                     })
[16:11:02.623]                     stopifnot(file_test("-f", pathname_tmp))
[16:11:02.623]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:11:02.623]                     if (!res || file_test("-f", pathname_tmp)) {
[16:11:02.623]                       fi_tmp <- file.info(pathname_tmp)
[16:11:02.623]                       fi <- file.info(pathname)
[16:11:02.623]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:11:02.623]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:11:02.623]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:11:02.623]                         fi[["size"]], fi[["mtime"]])
[16:11:02.623]                       stop(msg)
[16:11:02.623]                     }
[16:11:02.623]                     invisible(pathname)
[16:11:02.623]                   }
[16:11:02.623]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:11:02.623]                     rootPath = tempdir()) 
[16:11:02.623]                   {
[16:11:02.623]                     obj <- list(time = Sys.time(), condition = cond)
[16:11:02.623]                     file <- tempfile(pattern = class(cond)[1], 
[16:11:02.623]                       tmpdir = path, fileext = ".rds")
[16:11:02.623]                     save_rds(obj, file)
[16:11:02.623]                   }
[16:11:02.623]                   saveImmediateCondition(cond, path = "/tmp/RtmpbN9JX4/.future/immediateConditions")
[16:11:02.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.623]                   {
[16:11:02.623]                     inherits <- base::inherits
[16:11:02.623]                     invokeRestart <- base::invokeRestart
[16:11:02.623]                     is.null <- base::is.null
[16:11:02.623]                     muffled <- FALSE
[16:11:02.623]                     if (inherits(cond, "message")) {
[16:11:02.623]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:02.623]                       if (muffled) 
[16:11:02.623]                         invokeRestart("muffleMessage")
[16:11:02.623]                     }
[16:11:02.623]                     else if (inherits(cond, "warning")) {
[16:11:02.623]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:02.623]                       if (muffled) 
[16:11:02.623]                         invokeRestart("muffleWarning")
[16:11:02.623]                     }
[16:11:02.623]                     else if (inherits(cond, "condition")) {
[16:11:02.623]                       if (!is.null(pattern)) {
[16:11:02.623]                         computeRestarts <- base::computeRestarts
[16:11:02.623]                         grepl <- base::grepl
[16:11:02.623]                         restarts <- computeRestarts(cond)
[16:11:02.623]                         for (restart in restarts) {
[16:11:02.623]                           name <- restart$name
[16:11:02.623]                           if (is.null(name)) 
[16:11:02.623]                             next
[16:11:02.623]                           if (!grepl(pattern, name)) 
[16:11:02.623]                             next
[16:11:02.623]                           invokeRestart(restart)
[16:11:02.623]                           muffled <- TRUE
[16:11:02.623]                           break
[16:11:02.623]                         }
[16:11:02.623]                       }
[16:11:02.623]                     }
[16:11:02.623]                     invisible(muffled)
[16:11:02.623]                   }
[16:11:02.623]                   muffleCondition(cond)
[16:11:02.623]                 })
[16:11:02.623]             }))
[16:11:02.623]             future::FutureResult(value = ...future.value$value, 
[16:11:02.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.623]                   ...future.rng), globalenv = if (FALSE) 
[16:11:02.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:02.623]                     ...future.globalenv.names))
[16:11:02.623]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:02.623]         }, condition = base::local({
[16:11:02.623]             c <- base::c
[16:11:02.623]             inherits <- base::inherits
[16:11:02.623]             invokeRestart <- base::invokeRestart
[16:11:02.623]             length <- base::length
[16:11:02.623]             list <- base::list
[16:11:02.623]             seq.int <- base::seq.int
[16:11:02.623]             signalCondition <- base::signalCondition
[16:11:02.623]             sys.calls <- base::sys.calls
[16:11:02.623]             `[[` <- base::`[[`
[16:11:02.623]             `+` <- base::`+`
[16:11:02.623]             `<<-` <- base::`<<-`
[16:11:02.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:02.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:02.623]                   3L)]
[16:11:02.623]             }
[16:11:02.623]             function(cond) {
[16:11:02.623]                 is_error <- inherits(cond, "error")
[16:11:02.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:02.623]                   NULL)
[16:11:02.623]                 if (is_error) {
[16:11:02.623]                   sessionInformation <- function() {
[16:11:02.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:02.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:02.623]                       search = base::search(), system = base::Sys.info())
[16:11:02.623]                   }
[16:11:02.623]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:02.623]                     cond$call), session = sessionInformation(), 
[16:11:02.623]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:02.623]                   signalCondition(cond)
[16:11:02.623]                 }
[16:11:02.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:02.623]                 "immediateCondition"))) {
[16:11:02.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:02.623]                   ...future.conditions[[length(...future.conditions) + 
[16:11:02.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:02.623]                   if (TRUE && !signal) {
[16:11:02.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.623]                     {
[16:11:02.623]                       inherits <- base::inherits
[16:11:02.623]                       invokeRestart <- base::invokeRestart
[16:11:02.623]                       is.null <- base::is.null
[16:11:02.623]                       muffled <- FALSE
[16:11:02.623]                       if (inherits(cond, "message")) {
[16:11:02.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.623]                         if (muffled) 
[16:11:02.623]                           invokeRestart("muffleMessage")
[16:11:02.623]                       }
[16:11:02.623]                       else if (inherits(cond, "warning")) {
[16:11:02.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.623]                         if (muffled) 
[16:11:02.623]                           invokeRestart("muffleWarning")
[16:11:02.623]                       }
[16:11:02.623]                       else if (inherits(cond, "condition")) {
[16:11:02.623]                         if (!is.null(pattern)) {
[16:11:02.623]                           computeRestarts <- base::computeRestarts
[16:11:02.623]                           grepl <- base::grepl
[16:11:02.623]                           restarts <- computeRestarts(cond)
[16:11:02.623]                           for (restart in restarts) {
[16:11:02.623]                             name <- restart$name
[16:11:02.623]                             if (is.null(name)) 
[16:11:02.623]                               next
[16:11:02.623]                             if (!grepl(pattern, name)) 
[16:11:02.623]                               next
[16:11:02.623]                             invokeRestart(restart)
[16:11:02.623]                             muffled <- TRUE
[16:11:02.623]                             break
[16:11:02.623]                           }
[16:11:02.623]                         }
[16:11:02.623]                       }
[16:11:02.623]                       invisible(muffled)
[16:11:02.623]                     }
[16:11:02.623]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.623]                   }
[16:11:02.623]                 }
[16:11:02.623]                 else {
[16:11:02.623]                   if (TRUE) {
[16:11:02.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:02.623]                     {
[16:11:02.623]                       inherits <- base::inherits
[16:11:02.623]                       invokeRestart <- base::invokeRestart
[16:11:02.623]                       is.null <- base::is.null
[16:11:02.623]                       muffled <- FALSE
[16:11:02.623]                       if (inherits(cond, "message")) {
[16:11:02.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:02.623]                         if (muffled) 
[16:11:02.623]                           invokeRestart("muffleMessage")
[16:11:02.623]                       }
[16:11:02.623]                       else if (inherits(cond, "warning")) {
[16:11:02.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:02.623]                         if (muffled) 
[16:11:02.623]                           invokeRestart("muffleWarning")
[16:11:02.623]                       }
[16:11:02.623]                       else if (inherits(cond, "condition")) {
[16:11:02.623]                         if (!is.null(pattern)) {
[16:11:02.623]                           computeRestarts <- base::computeRestarts
[16:11:02.623]                           grepl <- base::grepl
[16:11:02.623]                           restarts <- computeRestarts(cond)
[16:11:02.623]                           for (restart in restarts) {
[16:11:02.623]                             name <- restart$name
[16:11:02.623]                             if (is.null(name)) 
[16:11:02.623]                               next
[16:11:02.623]                             if (!grepl(pattern, name)) 
[16:11:02.623]                               next
[16:11:02.623]                             invokeRestart(restart)
[16:11:02.623]                             muffled <- TRUE
[16:11:02.623]                             break
[16:11:02.623]                           }
[16:11:02.623]                         }
[16:11:02.623]                       }
[16:11:02.623]                       invisible(muffled)
[16:11:02.623]                     }
[16:11:02.623]                     muffleCondition(cond, pattern = "^muffle")
[16:11:02.623]                   }
[16:11:02.623]                 }
[16:11:02.623]             }
[16:11:02.623]         }))
[16:11:02.623]     }, error = function(ex) {
[16:11:02.623]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:02.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:02.623]                 ...future.rng), started = ...future.startTime, 
[16:11:02.623]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:02.623]             version = "1.8"), class = "FutureResult")
[16:11:02.623]     }, finally = {
[16:11:02.623]         if (!identical(...future.workdir, getwd())) 
[16:11:02.623]             setwd(...future.workdir)
[16:11:02.623]         {
[16:11:02.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:02.623]                 ...future.oldOptions$nwarnings <- NULL
[16:11:02.623]             }
[16:11:02.623]             base::options(...future.oldOptions)
[16:11:02.623]             if (.Platform$OS.type == "windows") {
[16:11:02.623]                 old_names <- names(...future.oldEnvVars)
[16:11:02.623]                 envs <- base::Sys.getenv()
[16:11:02.623]                 names <- names(envs)
[16:11:02.623]                 common <- intersect(names, old_names)
[16:11:02.623]                 added <- setdiff(names, old_names)
[16:11:02.623]                 removed <- setdiff(old_names, names)
[16:11:02.623]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:02.623]                   envs[common]]
[16:11:02.623]                 NAMES <- toupper(changed)
[16:11:02.623]                 args <- list()
[16:11:02.623]                 for (kk in seq_along(NAMES)) {
[16:11:02.623]                   name <- changed[[kk]]
[16:11:02.623]                   NAME <- NAMES[[kk]]
[16:11:02.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.623]                     next
[16:11:02.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.623]                 }
[16:11:02.623]                 NAMES <- toupper(added)
[16:11:02.623]                 for (kk in seq_along(NAMES)) {
[16:11:02.623]                   name <- added[[kk]]
[16:11:02.623]                   NAME <- NAMES[[kk]]
[16:11:02.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.623]                     next
[16:11:02.623]                   args[[name]] <- ""
[16:11:02.623]                 }
[16:11:02.623]                 NAMES <- toupper(removed)
[16:11:02.623]                 for (kk in seq_along(NAMES)) {
[16:11:02.623]                   name <- removed[[kk]]
[16:11:02.623]                   NAME <- NAMES[[kk]]
[16:11:02.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:02.623]                     next
[16:11:02.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:02.623]                 }
[16:11:02.623]                 if (length(args) > 0) 
[16:11:02.623]                   base::do.call(base::Sys.setenv, args = args)
[16:11:02.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:02.623]             }
[16:11:02.623]             else {
[16:11:02.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:02.623]             }
[16:11:02.623]             {
[16:11:02.623]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:02.623]                   0L) {
[16:11:02.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:02.623]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:02.623]                   base::options(opts)
[16:11:02.623]                 }
[16:11:02.623]                 {
[16:11:02.623]                   {
[16:11:02.623]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:02.623]                     NULL
[16:11:02.623]                   }
[16:11:02.623]                   options(future.plan = NULL)
[16:11:02.623]                   if (is.na(NA_character_)) 
[16:11:02.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:02.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:02.623]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:11:02.623]                     envir = parent.frame()) 
[16:11:02.623]                   {
[16:11:02.623]                     default_workers <- missing(workers)
[16:11:02.623]                     if (is.function(workers)) 
[16:11:02.623]                       workers <- workers()
[16:11:02.623]                     workers <- structure(as.integer(workers), 
[16:11:02.623]                       class = class(workers))
[16:11:02.623]                     stop_if_not(is.finite(workers), workers >= 
[16:11:02.623]                       1L)
[16:11:02.623]                     if ((workers == 1L && !inherits(workers, 
[16:11:02.623]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:11:02.623]                       if (default_workers) 
[16:11:02.623]                         supportsMulticore(warn = TRUE)
[16:11:02.623]                       return(sequential(..., envir = envir))
[16:11:02.623]                     }
[16:11:02.623]                     oopts <- options(mc.cores = workers)
[16:11:02.623]                     on.exit(options(oopts))
[16:11:02.623]                     future <- MulticoreFuture(..., workers = workers, 
[16:11:02.623]                       envir = envir)
[16:11:02.623]                     if (!future$lazy) 
[16:11:02.623]                       future <- run(future)
[16:11:02.623]                     invisible(future)
[16:11:02.623]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:02.623]                 }
[16:11:02.623]             }
[16:11:02.623]         }
[16:11:02.623]     })
[16:11:02.623]     if (TRUE) {
[16:11:02.623]         base::sink(type = "output", split = FALSE)
[16:11:02.623]         if (TRUE) {
[16:11:02.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:02.623]         }
[16:11:02.623]         else {
[16:11:02.623]             ...future.result["stdout"] <- base::list(NULL)
[16:11:02.623]         }
[16:11:02.623]         base::close(...future.stdout)
[16:11:02.623]         ...future.stdout <- NULL
[16:11:02.623]     }
[16:11:02.623]     ...future.result$conditions <- ...future.conditions
[16:11:02.623]     ...future.result$finished <- base::Sys.time()
[16:11:02.623]     ...future.result
[16:11:02.623] }
[16:11:02.626] assign_globals() ...
[16:11:02.626] List of 11
[16:11:02.626]  $ ...future.FUN            :function (x, ...)  
[16:11:02.626]  $ x_FUN                    :function (x)  
[16:11:02.626]  $ times                    : int 2
[16:11:02.626]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:02.626]  $ stop_if_not              :function (...)  
[16:11:02.626]  $ dim                      : NULL
[16:11:02.626]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[16:11:02.626]  $ future.call.arguments    : list()
[16:11:02.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:02.626]  $ ...future.elements_ii    :List of 2
[16:11:02.626]   ..$ : int 2
[16:11:02.626]   ..$ : int 3
[16:11:02.626]  $ ...future.seeds_ii       : NULL
[16:11:02.626]  $ ...future.globals.maxSize: NULL
[16:11:02.626]  - attr(*, "resolved")= logi FALSE
[16:11:02.626]  - attr(*, "total_size")= num 95128
[16:11:02.626]  - attr(*, "where")=List of 11
[16:11:02.626]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ times                    :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ stopf                    :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ dim                      :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ valid_types              :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:11:02.626]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:11:02.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:02.626]  - attr(*, "already-done")= logi TRUE
[16:11:02.636] - copied ‘...future.FUN’ to environment
[16:11:02.636] - copied ‘x_FUN’ to environment
[16:11:02.637] - copied ‘times’ to environment
[16:11:02.637] - copied ‘stopf’ to environment
[16:11:02.637] - copied ‘stop_if_not’ to environment
[16:11:02.637] - copied ‘dim’ to environment
[16:11:02.637] - copied ‘valid_types’ to environment
[16:11:02.637] - copied ‘future.call.arguments’ to environment
[16:11:02.637] - copied ‘...future.elements_ii’ to environment
[16:11:02.637] - copied ‘...future.seeds_ii’ to environment
[16:11:02.638] - copied ‘...future.globals.maxSize’ to environment
[16:11:02.638] assign_globals() ... done
[16:11:02.638] requestCore(): workers = 2
[16:11:02.640] MulticoreFuture started
[16:11:02.640] - Launch lazy future ... done
[16:11:02.641] run() for ‘MulticoreFuture’ ... done
[16:11:02.641] Created future:
[16:11:02.641] plan(): Setting new future strategy stack:
[16:11:02.642] List of future strategies:
[16:11:02.642] 1. sequential:
[16:11:02.642]    - args: function (..., envir = parent.frame())
[16:11:02.642]    - tweaked: FALSE
[16:11:02.642]    - call: NULL
[16:11:02.648] plan(): nbrOfWorkers() = 1
[16:11:02.650] plan(): Setting new future strategy stack:
[16:11:02.650] List of future strategies:
[16:11:02.650] 1. multicore:
[16:11:02.650]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:11:02.650]    - tweaked: FALSE
[16:11:02.650]    - call: plan(strategy)
[16:11:02.654] plan(): nbrOfWorkers() = 2
[16:11:02.641] MulticoreFuture:
[16:11:02.641] Label: ‘future_vapply-2’
[16:11:02.641] Expression:
[16:11:02.641] {
[16:11:02.641]     do.call(function(...) {
[16:11:02.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:02.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:02.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:02.641]             on.exit(options(oopts), add = TRUE)
[16:11:02.641]         }
[16:11:02.641]         {
[16:11:02.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:02.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:02.641]                 ...future.FUN(...future.X_jj, ...)
[16:11:02.641]             })
[16:11:02.641]         }
[16:11:02.641]     }, args = future.call.arguments)
[16:11:02.641] }
[16:11:02.641] Lazy evaluation: FALSE
[16:11:02.641] Asynchronous evaluation: TRUE
[16:11:02.641] Local evaluation: TRUE
[16:11:02.641] Environment: R_GlobalEnv
[16:11:02.641] Capture standard output: TRUE
[16:11:02.641] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:02.641] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:02.641] Packages: 1 packages (‘future.apply’)
[16:11:02.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:02.641] Resolved: FALSE
[16:11:02.641] Value: <not collected>
[16:11:02.641] Conditions captured: <none>
[16:11:02.641] Early signaling: FALSE
[16:11:02.641] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:02.641] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:02.659] Chunk #2 of 2 ... DONE
[16:11:02.660] Launching 2 futures (chunks) ... DONE
[16:11:02.660] Resolving 2 futures (chunks) ...
[16:11:02.660] resolve() on list ...
[16:11:02.660]  recursive: 0
[16:11:02.660]  length: 2
[16:11:02.661] 
[16:11:02.661] Future #1
[16:11:02.667] signalConditions() ...
[16:11:02.667]  - include = ‘immediateCondition’
[16:11:02.668]  - exclude = 
[16:11:02.668]  - resignal = FALSE
[16:11:02.668]  - Number of conditions: 1
[16:11:02.668] signalConditions() ... done
[16:11:02.668] signalConditions() ...
[16:11:02.668]  - include = ‘immediateCondition’
[16:11:02.669]  - exclude = 
[16:11:02.669]  - resignal = FALSE
[16:11:02.669]  - Number of conditions: 1
[16:11:02.669] signalConditions() ... done
[16:11:02.669] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:11:02.669] - nx: 2
[16:11:02.669] - relay: TRUE
[16:11:02.670] - stdout: TRUE
[16:11:02.670] - signal: TRUE
[16:11:02.670] - resignal: FALSE
[16:11:02.670] - force: TRUE
[16:11:02.670] - relayed: [n=2] FALSE, FALSE
[16:11:02.670] - queued futures: [n=2] FALSE, FALSE
[16:11:02.670]  - until=1
[16:11:02.670]  - relaying element #1
[16:11:02.671] signalConditions() ...
[16:11:02.671]  - include = ‘immediateCondition’
[16:11:02.671]  - exclude = 
[16:11:02.671]  - resignal = FALSE
[16:11:02.671]  - Number of conditions: 1
[16:11:02.671] signalConditions() ... done
[16:11:02.672] signalConditions() ...
[16:11:02.672]  - include = ‘immediateCondition’
[16:11:02.672]  - exclude = 
[16:11:02.672]  - resignal = FALSE
[16:11:02.672]  - Number of conditions: 1
[16:11:02.672] signalConditions() ... done
[16:11:02.672] signalConditions() ...
[16:11:02.673]  - include = ‘condition’
[16:11:02.673]  - exclude = ‘immediateCondition’
[16:11:02.673]  - resignal = TRUE
[16:11:02.673]  - Number of conditions: 1
[16:11:02.673]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:11:02.673] signalConditions() ... done
[16:11:02.673] - relayed: [n=2] FALSE, FALSE
[16:11:02.674] - queued futures: [n=2] TRUE, FALSE
[16:11:02.674] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:11:02.674] plan(): Setting new future strategy stack:
[16:11:02.674] List of future strategies:
[16:11:02.674] 1. sequential:
[16:11:02.674]    - args: function (..., envir = parent.frame())
[16:11:02.674]    - tweaked: FALSE
[16:11:02.674]    - call: plan(sequential)
[16:11:02.675] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:11:02.676] plan(): Setting new future strategy stack:
[16:11:02.676] List of future strategies:
[16:11:02.676] 1. multisession:
[16:11:02.676]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:02.676]    - tweaked: FALSE
[16:11:02.676]    - call: plan(strategy)
[16:11:02.676] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:11:02.677] multisession:
[16:11:02.677] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:11:02.677] - tweaked: FALSE
[16:11:02.677] - call: plan(strategy)
[16:11:02.684] getGlobalsAndPackages() ...
[16:11:02.684] Not searching for globals
[16:11:02.685] - globals: [0] <none>
[16:11:02.685] getGlobalsAndPackages() ... DONE
[16:11:02.685] [local output] makeClusterPSOCK() ...
[16:11:02.742] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:11:02.748] [local output] Base port: 11817
[16:11:02.748] [local output] Getting setup options for 2 cluster nodes ...
[16:11:02.748] [local output]  - Node 1 of 2 ...
[16:11:02.748] [local output] localMachine=TRUE => revtunnel=FALSE

[16:11:02.749] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpbN9JX4/worker.rank=1.parallelly.parent=78203.1317b34eb1b89.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpbN9JX4/worker.rank=1.parallelly.parent=78203.1317b34eb1b89.pid")'’
[16:11:02.936] - Possible to infer worker's PID: TRUE
[16:11:02.936] [local output] Rscript port: 11817

[16:11:02.937] [local output]  - Node 2 of 2 ...
[16:11:02.937] [local output] localMachine=TRUE => revtunnel=FALSE

[16:11:02.938] [local output] Rscript port: 11817

[16:11:02.938] [local output] Getting setup options for 2 cluster nodes ... done
[16:11:02.938] [local output]  - Parallel setup requested for some PSOCK nodes
[16:11:02.939] [local output] Setting up PSOCK nodes in parallel
[16:11:02.939] List of 36
[16:11:02.939]  $ worker          : chr "localhost"
[16:11:02.939]   ..- attr(*, "localhost")= logi TRUE
[16:11:02.939]  $ master          : chr "localhost"
[16:11:02.939]  $ port            : int 11817
[16:11:02.939]  $ connectTimeout  : num 120
[16:11:02.939]  $ timeout         : num 2592000
[16:11:02.939]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:11:02.939]  $ homogeneous     : logi TRUE
[16:11:02.939]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:11:02.939]  $ rscript_envs    : NULL
[16:11:02.939]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:11:02.939]  $ rscript_startup : NULL
[16:11:02.939]  $ rscript_sh      : chr "sh"
[16:11:02.939]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:11:02.939]  $ methods         : logi TRUE
[16:11:02.939]  $ socketOptions   : chr "no-delay"
[16:11:02.939]  $ useXDR          : logi FALSE
[16:11:02.939]  $ outfile         : chr "/dev/null"
[16:11:02.939]  $ renice          : int NA
[16:11:02.939]  $ rshcmd          : NULL
[16:11:02.939]  $ user            : chr(0) 
[16:11:02.939]  $ revtunnel       : logi FALSE
[16:11:02.939]  $ rshlogfile      : NULL
[16:11:02.939]  $ rshopts         : chr(0) 
[16:11:02.939]  $ rank            : int 1
[16:11:02.939]  $ manual          : logi FALSE
[16:11:02.939]  $ dryrun          : logi FALSE
[16:11:02.939]  $ quiet           : logi FALSE
[16:11:02.939]  $ setup_strategy  : chr "parallel"
[16:11:02.939]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:11:02.939]  $ pidfile         : chr "/tmp/RtmpbN9JX4/worker.rank=1.parallelly.parent=78203.1317b34eb1b89.pid"
[16:11:02.939]  $ rshcmd_label    : NULL
[16:11:02.939]  $ rsh_call        : NULL
[16:11:02.939]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:11:02.939]  $ localMachine    : logi TRUE
[16:11:02.939]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:11:02.939]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:11:02.939]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:11:02.939]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:11:02.939]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:11:02.939]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:11:02.939]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:11:02.939]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:11:02.939]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:11:02.939]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:11:02.939]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:11:02.939]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:11:02.939]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:11:02.939]  $ arguments       :List of 28
[16:11:02.939]   ..$ worker          : chr "localhost"
[16:11:02.939]   ..$ master          : NULL
[16:11:02.939]   ..$ port            : int 11817
[16:11:02.939]   ..$ connectTimeout  : num 120
[16:11:02.939]   ..$ timeout         : num 2592000
[16:11:02.939]   ..$ rscript         : NULL
[16:11:02.939]   ..$ homogeneous     : NULL
[16:11:02.939]   ..$ rscript_args    : NULL
[16:11:02.939]   ..$ rscript_envs    : NULL
[16:11:02.939]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:11:02.939]   ..$ rscript_startup : NULL
[16:11:02.939]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:11:02.939]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:11:02.939]   ..$ methods         : logi TRUE
[16:11:02.939]   ..$ socketOptions   : chr "no-delay"
[16:11:02.939]   ..$ useXDR          : logi FALSE
[16:11:02.939]   ..$ outfile         : chr "/dev/null"
[16:11:02.939]   ..$ renice          : int NA
[16:11:02.939]   ..$ rshcmd          : NULL
[16:11:02.939]   ..$ user            : NULL
[16:11:02.939]   ..$ revtunnel       : logi NA
[16:11:02.939]   ..$ rshlogfile      : NULL
[16:11:02.939]   ..$ rshopts         : NULL
[16:11:02.939]   ..$ rank            : int 1
[16:11:02.939]   ..$ manual          : logi FALSE
[16:11:02.939]   ..$ dryrun          : logi FALSE
[16:11:02.939]   ..$ quiet           : logi FALSE
[16:11:02.939]   ..$ setup_strategy  : chr "parallel"
[16:11:02.939]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:11:02.955] [local output] System call to launch all workers:
[16:11:02.955] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpbN9JX4/worker.rank=1.parallelly.parent=78203.1317b34eb1b89.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11817 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:11:02.955] [local output] Starting PSOCK main server
[16:11:02.957] [local output] Workers launched
[16:11:02.957] [local output] Waiting for workers to connect back
[16:11:02.957]  - [local output] 0 workers out of 2 ready
[16:11:03.221]  - [local output] 0 workers out of 2 ready
[16:11:03.222]  - [local output] 1 workers out of 2 ready
[16:11:03.223]  - [local output] 1 workers out of 2 ready
[16:11:03.223]  - [local output] 2 workers out of 2 ready
[16:11:03.223] [local output] Launching of workers completed
[16:11:03.223] [local output] Collecting session information from workers
[16:11:03.224] [local output]  - Worker #1 of 2
[16:11:03.224] [local output]  - Worker #2 of 2
[16:11:03.225] [local output] makeClusterPSOCK() ... done
[16:11:03.236] Packages needed by the future expression (n = 0): <none>
[16:11:03.236] Packages needed by future strategies (n = 0): <none>
[16:11:03.236] {
[16:11:03.236]     {
[16:11:03.236]         {
[16:11:03.236]             ...future.startTime <- base::Sys.time()
[16:11:03.236]             {
[16:11:03.236]                 {
[16:11:03.236]                   {
[16:11:03.236]                     {
[16:11:03.236]                       base::local({
[16:11:03.236]                         has_future <- base::requireNamespace("future", 
[16:11:03.236]                           quietly = TRUE)
[16:11:03.236]                         if (has_future) {
[16:11:03.236]                           ns <- base::getNamespace("future")
[16:11:03.236]                           version <- ns[[".package"]][["version"]]
[16:11:03.236]                           if (is.null(version)) 
[16:11:03.236]                             version <- utils::packageVersion("future")
[16:11:03.236]                         }
[16:11:03.236]                         else {
[16:11:03.236]                           version <- NULL
[16:11:03.236]                         }
[16:11:03.236]                         if (!has_future || version < "1.8.0") {
[16:11:03.236]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:03.236]                             "", base::R.version$version.string), 
[16:11:03.236]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:03.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:03.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:03.236]                               "release", "version")], collapse = " "), 
[16:11:03.236]                             hostname = base::Sys.info()[["nodename"]])
[16:11:03.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:03.236]                             info)
[16:11:03.236]                           info <- base::paste(info, collapse = "; ")
[16:11:03.236]                           if (!has_future) {
[16:11:03.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:03.236]                               info)
[16:11:03.236]                           }
[16:11:03.236]                           else {
[16:11:03.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:03.236]                               info, version)
[16:11:03.236]                           }
[16:11:03.236]                           base::stop(msg)
[16:11:03.236]                         }
[16:11:03.236]                       })
[16:11:03.236]                     }
[16:11:03.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:03.236]                     base::options(mc.cores = 1L)
[16:11:03.236]                   }
[16:11:03.236]                   options(future.plan = NULL)
[16:11:03.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:03.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:03.236]                 }
[16:11:03.236]                 ...future.workdir <- getwd()
[16:11:03.236]             }
[16:11:03.236]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:03.236]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:03.236]         }
[16:11:03.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:03.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:03.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:03.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:03.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:03.236]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:03.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:03.236]             base::names(...future.oldOptions))
[16:11:03.236]     }
[16:11:03.236]     if (FALSE) {
[16:11:03.236]     }
[16:11:03.236]     else {
[16:11:03.236]         if (TRUE) {
[16:11:03.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:03.236]                 open = "w")
[16:11:03.236]         }
[16:11:03.236]         else {
[16:11:03.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:03.236]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:03.236]         }
[16:11:03.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:03.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:03.236]             base::sink(type = "output", split = FALSE)
[16:11:03.236]             base::close(...future.stdout)
[16:11:03.236]         }, add = TRUE)
[16:11:03.236]     }
[16:11:03.236]     ...future.frame <- base::sys.nframe()
[16:11:03.236]     ...future.conditions <- base::list()
[16:11:03.236]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:03.236]     if (FALSE) {
[16:11:03.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:03.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:03.236]     }
[16:11:03.236]     ...future.result <- base::tryCatch({
[16:11:03.236]         base::withCallingHandlers({
[16:11:03.236]             ...future.value <- base::withVisible(base::local({
[16:11:03.236]                 ...future.makeSendCondition <- local({
[16:11:03.236]                   sendCondition <- NULL
[16:11:03.236]                   function(frame = 1L) {
[16:11:03.236]                     if (is.function(sendCondition)) 
[16:11:03.236]                       return(sendCondition)
[16:11:03.236]                     ns <- getNamespace("parallel")
[16:11:03.236]                     if (exists("sendData", mode = "function", 
[16:11:03.236]                       envir = ns)) {
[16:11:03.236]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:03.236]                         envir = ns)
[16:11:03.236]                       envir <- sys.frame(frame)
[16:11:03.236]                       master <- NULL
[16:11:03.236]                       while (!identical(envir, .GlobalEnv) && 
[16:11:03.236]                         !identical(envir, emptyenv())) {
[16:11:03.236]                         if (exists("master", mode = "list", envir = envir, 
[16:11:03.236]                           inherits = FALSE)) {
[16:11:03.236]                           master <- get("master", mode = "list", 
[16:11:03.236]                             envir = envir, inherits = FALSE)
[16:11:03.236]                           if (inherits(master, c("SOCKnode", 
[16:11:03.236]                             "SOCK0node"))) {
[16:11:03.236]                             sendCondition <<- function(cond) {
[16:11:03.236]                               data <- list(type = "VALUE", value = cond, 
[16:11:03.236]                                 success = TRUE)
[16:11:03.236]                               parallel_sendData(master, data)
[16:11:03.236]                             }
[16:11:03.236]                             return(sendCondition)
[16:11:03.236]                           }
[16:11:03.236]                         }
[16:11:03.236]                         frame <- frame + 1L
[16:11:03.236]                         envir <- sys.frame(frame)
[16:11:03.236]                       }
[16:11:03.236]                     }
[16:11:03.236]                     sendCondition <<- function(cond) NULL
[16:11:03.236]                   }
[16:11:03.236]                 })
[16:11:03.236]                 withCallingHandlers({
[16:11:03.236]                   NA
[16:11:03.236]                 }, immediateCondition = function(cond) {
[16:11:03.236]                   sendCondition <- ...future.makeSendCondition()
[16:11:03.236]                   sendCondition(cond)
[16:11:03.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.236]                   {
[16:11:03.236]                     inherits <- base::inherits
[16:11:03.236]                     invokeRestart <- base::invokeRestart
[16:11:03.236]                     is.null <- base::is.null
[16:11:03.236]                     muffled <- FALSE
[16:11:03.236]                     if (inherits(cond, "message")) {
[16:11:03.236]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:03.236]                       if (muffled) 
[16:11:03.236]                         invokeRestart("muffleMessage")
[16:11:03.236]                     }
[16:11:03.236]                     else if (inherits(cond, "warning")) {
[16:11:03.236]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:03.236]                       if (muffled) 
[16:11:03.236]                         invokeRestart("muffleWarning")
[16:11:03.236]                     }
[16:11:03.236]                     else if (inherits(cond, "condition")) {
[16:11:03.236]                       if (!is.null(pattern)) {
[16:11:03.236]                         computeRestarts <- base::computeRestarts
[16:11:03.236]                         grepl <- base::grepl
[16:11:03.236]                         restarts <- computeRestarts(cond)
[16:11:03.236]                         for (restart in restarts) {
[16:11:03.236]                           name <- restart$name
[16:11:03.236]                           if (is.null(name)) 
[16:11:03.236]                             next
[16:11:03.236]                           if (!grepl(pattern, name)) 
[16:11:03.236]                             next
[16:11:03.236]                           invokeRestart(restart)
[16:11:03.236]                           muffled <- TRUE
[16:11:03.236]                           break
[16:11:03.236]                         }
[16:11:03.236]                       }
[16:11:03.236]                     }
[16:11:03.236]                     invisible(muffled)
[16:11:03.236]                   }
[16:11:03.236]                   muffleCondition(cond)
[16:11:03.236]                 })
[16:11:03.236]             }))
[16:11:03.236]             future::FutureResult(value = ...future.value$value, 
[16:11:03.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:03.236]                   ...future.rng), globalenv = if (FALSE) 
[16:11:03.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:03.236]                     ...future.globalenv.names))
[16:11:03.236]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:03.236]         }, condition = base::local({
[16:11:03.236]             c <- base::c
[16:11:03.236]             inherits <- base::inherits
[16:11:03.236]             invokeRestart <- base::invokeRestart
[16:11:03.236]             length <- base::length
[16:11:03.236]             list <- base::list
[16:11:03.236]             seq.int <- base::seq.int
[16:11:03.236]             signalCondition <- base::signalCondition
[16:11:03.236]             sys.calls <- base::sys.calls
[16:11:03.236]             `[[` <- base::`[[`
[16:11:03.236]             `+` <- base::`+`
[16:11:03.236]             `<<-` <- base::`<<-`
[16:11:03.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:03.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:03.236]                   3L)]
[16:11:03.236]             }
[16:11:03.236]             function(cond) {
[16:11:03.236]                 is_error <- inherits(cond, "error")
[16:11:03.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:03.236]                   NULL)
[16:11:03.236]                 if (is_error) {
[16:11:03.236]                   sessionInformation <- function() {
[16:11:03.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:03.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:03.236]                       search = base::search(), system = base::Sys.info())
[16:11:03.236]                   }
[16:11:03.236]                   ...future.conditions[[length(...future.conditions) + 
[16:11:03.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:03.236]                     cond$call), session = sessionInformation(), 
[16:11:03.236]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:03.236]                   signalCondition(cond)
[16:11:03.236]                 }
[16:11:03.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:03.236]                 "immediateCondition"))) {
[16:11:03.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:03.236]                   ...future.conditions[[length(...future.conditions) + 
[16:11:03.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:03.236]                   if (TRUE && !signal) {
[16:11:03.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.236]                     {
[16:11:03.236]                       inherits <- base::inherits
[16:11:03.236]                       invokeRestart <- base::invokeRestart
[16:11:03.236]                       is.null <- base::is.null
[16:11:03.236]                       muffled <- FALSE
[16:11:03.236]                       if (inherits(cond, "message")) {
[16:11:03.236]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:03.236]                         if (muffled) 
[16:11:03.236]                           invokeRestart("muffleMessage")
[16:11:03.236]                       }
[16:11:03.236]                       else if (inherits(cond, "warning")) {
[16:11:03.236]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:03.236]                         if (muffled) 
[16:11:03.236]                           invokeRestart("muffleWarning")
[16:11:03.236]                       }
[16:11:03.236]                       else if (inherits(cond, "condition")) {
[16:11:03.236]                         if (!is.null(pattern)) {
[16:11:03.236]                           computeRestarts <- base::computeRestarts
[16:11:03.236]                           grepl <- base::grepl
[16:11:03.236]                           restarts <- computeRestarts(cond)
[16:11:03.236]                           for (restart in restarts) {
[16:11:03.236]                             name <- restart$name
[16:11:03.236]                             if (is.null(name)) 
[16:11:03.236]                               next
[16:11:03.236]                             if (!grepl(pattern, name)) 
[16:11:03.236]                               next
[16:11:03.236]                             invokeRestart(restart)
[16:11:03.236]                             muffled <- TRUE
[16:11:03.236]                             break
[16:11:03.236]                           }
[16:11:03.236]                         }
[16:11:03.236]                       }
[16:11:03.236]                       invisible(muffled)
[16:11:03.236]                     }
[16:11:03.236]                     muffleCondition(cond, pattern = "^muffle")
[16:11:03.236]                   }
[16:11:03.236]                 }
[16:11:03.236]                 else {
[16:11:03.236]                   if (TRUE) {
[16:11:03.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.236]                     {
[16:11:03.236]                       inherits <- base::inherits
[16:11:03.236]                       invokeRestart <- base::invokeRestart
[16:11:03.236]                       is.null <- base::is.null
[16:11:03.236]                       muffled <- FALSE
[16:11:03.236]                       if (inherits(cond, "message")) {
[16:11:03.236]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:03.236]                         if (muffled) 
[16:11:03.236]                           invokeRestart("muffleMessage")
[16:11:03.236]                       }
[16:11:03.236]                       else if (inherits(cond, "warning")) {
[16:11:03.236]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:03.236]                         if (muffled) 
[16:11:03.236]                           invokeRestart("muffleWarning")
[16:11:03.236]                       }
[16:11:03.236]                       else if (inherits(cond, "condition")) {
[16:11:03.236]                         if (!is.null(pattern)) {
[16:11:03.236]                           computeRestarts <- base::computeRestarts
[16:11:03.236]                           grepl <- base::grepl
[16:11:03.236]                           restarts <- computeRestarts(cond)
[16:11:03.236]                           for (restart in restarts) {
[16:11:03.236]                             name <- restart$name
[16:11:03.236]                             if (is.null(name)) 
[16:11:03.236]                               next
[16:11:03.236]                             if (!grepl(pattern, name)) 
[16:11:03.236]                               next
[16:11:03.236]                             invokeRestart(restart)
[16:11:03.236]                             muffled <- TRUE
[16:11:03.236]                             break
[16:11:03.236]                           }
[16:11:03.236]                         }
[16:11:03.236]                       }
[16:11:03.236]                       invisible(muffled)
[16:11:03.236]                     }
[16:11:03.236]                     muffleCondition(cond, pattern = "^muffle")
[16:11:03.236]                   }
[16:11:03.236]                 }
[16:11:03.236]             }
[16:11:03.236]         }))
[16:11:03.236]     }, error = function(ex) {
[16:11:03.236]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:03.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:03.236]                 ...future.rng), started = ...future.startTime, 
[16:11:03.236]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:03.236]             version = "1.8"), class = "FutureResult")
[16:11:03.236]     }, finally = {
[16:11:03.236]         if (!identical(...future.workdir, getwd())) 
[16:11:03.236]             setwd(...future.workdir)
[16:11:03.236]         {
[16:11:03.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:03.236]                 ...future.oldOptions$nwarnings <- NULL
[16:11:03.236]             }
[16:11:03.236]             base::options(...future.oldOptions)
[16:11:03.236]             if (.Platform$OS.type == "windows") {
[16:11:03.236]                 old_names <- names(...future.oldEnvVars)
[16:11:03.236]                 envs <- base::Sys.getenv()
[16:11:03.236]                 names <- names(envs)
[16:11:03.236]                 common <- intersect(names, old_names)
[16:11:03.236]                 added <- setdiff(names, old_names)
[16:11:03.236]                 removed <- setdiff(old_names, names)
[16:11:03.236]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:03.236]                   envs[common]]
[16:11:03.236]                 NAMES <- toupper(changed)
[16:11:03.236]                 args <- list()
[16:11:03.236]                 for (kk in seq_along(NAMES)) {
[16:11:03.236]                   name <- changed[[kk]]
[16:11:03.236]                   NAME <- NAMES[[kk]]
[16:11:03.236]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.236]                     next
[16:11:03.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:03.236]                 }
[16:11:03.236]                 NAMES <- toupper(added)
[16:11:03.236]                 for (kk in seq_along(NAMES)) {
[16:11:03.236]                   name <- added[[kk]]
[16:11:03.236]                   NAME <- NAMES[[kk]]
[16:11:03.236]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.236]                     next
[16:11:03.236]                   args[[name]] <- ""
[16:11:03.236]                 }
[16:11:03.236]                 NAMES <- toupper(removed)
[16:11:03.236]                 for (kk in seq_along(NAMES)) {
[16:11:03.236]                   name <- removed[[kk]]
[16:11:03.236]                   NAME <- NAMES[[kk]]
[16:11:03.236]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.236]                     next
[16:11:03.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:03.236]                 }
[16:11:03.236]                 if (length(args) > 0) 
[16:11:03.236]                   base::do.call(base::Sys.setenv, args = args)
[16:11:03.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:03.236]             }
[16:11:03.236]             else {
[16:11:03.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:03.236]             }
[16:11:03.236]             {
[16:11:03.236]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:03.236]                   0L) {
[16:11:03.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:03.236]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:03.236]                   base::options(opts)
[16:11:03.236]                 }
[16:11:03.236]                 {
[16:11:03.236]                   {
[16:11:03.236]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:03.236]                     NULL
[16:11:03.236]                   }
[16:11:03.236]                   options(future.plan = NULL)
[16:11:03.236]                   if (is.na(NA_character_)) 
[16:11:03.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:03.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:03.236]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:03.236]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:03.236]                     envir = parent.frame()) 
[16:11:03.236]                   {
[16:11:03.236]                     if (is.function(workers)) 
[16:11:03.236]                       workers <- workers()
[16:11:03.236]                     workers <- structure(as.integer(workers), 
[16:11:03.236]                       class = class(workers))
[16:11:03.236]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:03.236]                       workers >= 1)
[16:11:03.236]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:03.236]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:03.236]                     }
[16:11:03.236]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:03.236]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:03.236]                       envir = envir)
[16:11:03.236]                     if (!future$lazy) 
[16:11:03.236]                       future <- run(future)
[16:11:03.236]                     invisible(future)
[16:11:03.236]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:03.236]                 }
[16:11:03.236]             }
[16:11:03.236]         }
[16:11:03.236]     })
[16:11:03.236]     if (TRUE) {
[16:11:03.236]         base::sink(type = "output", split = FALSE)
[16:11:03.236]         if (TRUE) {
[16:11:03.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:03.236]         }
[16:11:03.236]         else {
[16:11:03.236]             ...future.result["stdout"] <- base::list(NULL)
[16:11:03.236]         }
[16:11:03.236]         base::close(...future.stdout)
[16:11:03.236]         ...future.stdout <- NULL
[16:11:03.236]     }
[16:11:03.236]     ...future.result$conditions <- ...future.conditions
[16:11:03.236]     ...future.result$finished <- base::Sys.time()
[16:11:03.236]     ...future.result
[16:11:03.236] }
[16:11:03.307] MultisessionFuture started
[16:11:03.308] result() for ClusterFuture ...
[16:11:03.308] receiveMessageFromWorker() for ClusterFuture ...
[16:11:03.308] - Validating connection of MultisessionFuture
[16:11:03.339] - received message: FutureResult
[16:11:03.339] - Received FutureResult
[16:11:03.339] - Erased future from FutureRegistry
[16:11:03.339] result() for ClusterFuture ...
[16:11:03.339] - result already collected: FutureResult
[16:11:03.339] result() for ClusterFuture ... done
[16:11:03.340] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:03.340] result() for ClusterFuture ... done
[16:11:03.340] result() for ClusterFuture ...
[16:11:03.340] - result already collected: FutureResult
[16:11:03.340] result() for ClusterFuture ... done
[16:11:03.340] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:11:03.344] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[16:11:03.346] future_lapply() ...
[16:11:03.351] Number of chunks: 2
[16:11:03.351] getGlobalsAndPackagesXApply() ...
[16:11:03.351]  - future.globals: TRUE
[16:11:03.351] getGlobalsAndPackages() ...
[16:11:03.351] Searching for globals...
[16:11:03.354] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:03.354] Searching for globals ... DONE
[16:11:03.354] Resolving globals: FALSE
[16:11:03.355] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[16:11:03.356] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:03.356] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:03.356] - packages: [1] ‘future.apply’
[16:11:03.356] getGlobalsAndPackages() ... DONE
[16:11:03.356]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:03.356]  - needed namespaces: [n=1] ‘future.apply’
[16:11:03.356] Finding globals ... DONE
[16:11:03.356]  - use_args: TRUE
[16:11:03.356]  - Getting '...' globals ...
[16:11:03.357] resolve() on list ...
[16:11:03.357]  recursive: 0
[16:11:03.357]  length: 1
[16:11:03.357]  elements: ‘...’
[16:11:03.357]  length: 0 (resolved future 1)
[16:11:03.357] resolve() on list ... DONE
[16:11:03.357]    - '...' content: [n=0] 
[16:11:03.357] List of 1
[16:11:03.357]  $ ...: list()
[16:11:03.357]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:03.357]  - attr(*, "where")=List of 1
[16:11:03.357]   ..$ ...:<environment: 0x561e8b41baf8> 
[16:11:03.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:03.357]  - attr(*, "resolved")= logi TRUE
[16:11:03.357]  - attr(*, "total_size")= num NA
[16:11:03.360]  - Getting '...' globals ... DONE
[16:11:03.360] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:03.360] List of 8
[16:11:03.360]  $ ...future.FUN:function (x, ...)  
[16:11:03.360]  $ x_FUN        :function (x)  
[16:11:03.360]  $ times        : int 1
[16:11:03.360]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:03.360]  $ stop_if_not  :function (...)  
[16:11:03.360]  $ dim          : NULL
[16:11:03.360]  $ valid_types  : chr "character"
[16:11:03.360]  $ ...          : list()
[16:11:03.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:03.360]  - attr(*, "where")=List of 8
[16:11:03.360]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:03.360]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:03.360]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:03.360]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:03.360]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:03.360]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:03.360]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:03.360]   ..$ ...          :<environment: 0x561e8b41baf8> 
[16:11:03.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:03.360]  - attr(*, "resolved")= logi FALSE
[16:11:03.360]  - attr(*, "total_size")= num 94208
[16:11:03.366] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:03.366] getGlobalsAndPackagesXApply() ... DONE
[16:11:03.366] Number of futures (= number of chunks): 2
[16:11:03.366] Launching 2 futures (chunks) ...
[16:11:03.366] Chunk #1 of 2 ...
[16:11:03.366]  - Finding globals in 'X' for chunk #1 ...
[16:11:03.366] getGlobalsAndPackages() ...
[16:11:03.366] Searching for globals...
[16:11:03.367] 
[16:11:03.367] Searching for globals ... DONE
[16:11:03.367] - globals: [0] <none>
[16:11:03.367] getGlobalsAndPackages() ... DONE
[16:11:03.367]    + additional globals found: [n=0] 
[16:11:03.367]    + additional namespaces needed: [n=0] 
[16:11:03.367]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:03.367]  - seeds: <none>
[16:11:03.367] getGlobalsAndPackages() ...
[16:11:03.367] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:03.368] Resolving globals: FALSE
[16:11:03.368] Tweak future expression to call with '...' arguments ...
[16:11:03.368] {
[16:11:03.368]     do.call(function(...) {
[16:11:03.368]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:03.368]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:03.368]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:03.368]             on.exit(options(oopts), add = TRUE)
[16:11:03.368]         }
[16:11:03.368]         {
[16:11:03.368]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:03.368]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:03.368]                 ...future.FUN(...future.X_jj, ...)
[16:11:03.368]             })
[16:11:03.368]         }
[16:11:03.368]     }, args = future.call.arguments)
[16:11:03.368] }
[16:11:03.368] Tweak future expression to call with '...' arguments ... DONE
[16:11:03.369] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:03.369] - packages: [1] ‘future.apply’
[16:11:03.369] getGlobalsAndPackages() ... DONE
[16:11:03.369] run() for ‘Future’ ...
[16:11:03.369] - state: ‘created’
[16:11:03.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:03.384] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:03.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:03.384]   - Field: ‘node’
[16:11:03.384]   - Field: ‘label’
[16:11:03.384]   - Field: ‘local’
[16:11:03.384]   - Field: ‘owner’
[16:11:03.384]   - Field: ‘envir’
[16:11:03.385]   - Field: ‘workers’
[16:11:03.385]   - Field: ‘packages’
[16:11:03.385]   - Field: ‘gc’
[16:11:03.385]   - Field: ‘conditions’
[16:11:03.385]   - Field: ‘persistent’
[16:11:03.385]   - Field: ‘expr’
[16:11:03.385]   - Field: ‘uuid’
[16:11:03.385]   - Field: ‘seed’
[16:11:03.385]   - Field: ‘version’
[16:11:03.385]   - Field: ‘result’
[16:11:03.385]   - Field: ‘asynchronous’
[16:11:03.386]   - Field: ‘calls’
[16:11:03.386]   - Field: ‘globals’
[16:11:03.386]   - Field: ‘stdout’
[16:11:03.386]   - Field: ‘earlySignal’
[16:11:03.386]   - Field: ‘lazy’
[16:11:03.386]   - Field: ‘state’
[16:11:03.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:03.386] - Launch lazy future ...
[16:11:03.387] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:03.387] Packages needed by future strategies (n = 0): <none>
[16:11:03.387] {
[16:11:03.387]     {
[16:11:03.387]         {
[16:11:03.387]             ...future.startTime <- base::Sys.time()
[16:11:03.387]             {
[16:11:03.387]                 {
[16:11:03.387]                   {
[16:11:03.387]                     {
[16:11:03.387]                       {
[16:11:03.387]                         base::local({
[16:11:03.387]                           has_future <- base::requireNamespace("future", 
[16:11:03.387]                             quietly = TRUE)
[16:11:03.387]                           if (has_future) {
[16:11:03.387]                             ns <- base::getNamespace("future")
[16:11:03.387]                             version <- ns[[".package"]][["version"]]
[16:11:03.387]                             if (is.null(version)) 
[16:11:03.387]                               version <- utils::packageVersion("future")
[16:11:03.387]                           }
[16:11:03.387]                           else {
[16:11:03.387]                             version <- NULL
[16:11:03.387]                           }
[16:11:03.387]                           if (!has_future || version < "1.8.0") {
[16:11:03.387]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:03.387]                               "", base::R.version$version.string), 
[16:11:03.387]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:03.387]                                 base::R.version$platform, 8 * 
[16:11:03.387]                                   base::.Machine$sizeof.pointer), 
[16:11:03.387]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:03.387]                                 "release", "version")], collapse = " "), 
[16:11:03.387]                               hostname = base::Sys.info()[["nodename"]])
[16:11:03.387]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:03.387]                               info)
[16:11:03.387]                             info <- base::paste(info, collapse = "; ")
[16:11:03.387]                             if (!has_future) {
[16:11:03.387]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:03.387]                                 info)
[16:11:03.387]                             }
[16:11:03.387]                             else {
[16:11:03.387]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:03.387]                                 info, version)
[16:11:03.387]                             }
[16:11:03.387]                             base::stop(msg)
[16:11:03.387]                           }
[16:11:03.387]                         })
[16:11:03.387]                       }
[16:11:03.387]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:03.387]                       base::options(mc.cores = 1L)
[16:11:03.387]                     }
[16:11:03.387]                     base::local({
[16:11:03.387]                       for (pkg in "future.apply") {
[16:11:03.387]                         base::loadNamespace(pkg)
[16:11:03.387]                         base::library(pkg, character.only = TRUE)
[16:11:03.387]                       }
[16:11:03.387]                     })
[16:11:03.387]                   }
[16:11:03.387]                   options(future.plan = NULL)
[16:11:03.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:03.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:03.387]                 }
[16:11:03.387]                 ...future.workdir <- getwd()
[16:11:03.387]             }
[16:11:03.387]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:03.387]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:03.387]         }
[16:11:03.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:03.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:03.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:03.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:03.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:03.387]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:03.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:03.387]             base::names(...future.oldOptions))
[16:11:03.387]     }
[16:11:03.387]     if (FALSE) {
[16:11:03.387]     }
[16:11:03.387]     else {
[16:11:03.387]         if (TRUE) {
[16:11:03.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:03.387]                 open = "w")
[16:11:03.387]         }
[16:11:03.387]         else {
[16:11:03.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:03.387]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:03.387]         }
[16:11:03.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:03.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:03.387]             base::sink(type = "output", split = FALSE)
[16:11:03.387]             base::close(...future.stdout)
[16:11:03.387]         }, add = TRUE)
[16:11:03.387]     }
[16:11:03.387]     ...future.frame <- base::sys.nframe()
[16:11:03.387]     ...future.conditions <- base::list()
[16:11:03.387]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:03.387]     if (FALSE) {
[16:11:03.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:03.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:03.387]     }
[16:11:03.387]     ...future.result <- base::tryCatch({
[16:11:03.387]         base::withCallingHandlers({
[16:11:03.387]             ...future.value <- base::withVisible(base::local({
[16:11:03.387]                 ...future.makeSendCondition <- local({
[16:11:03.387]                   sendCondition <- NULL
[16:11:03.387]                   function(frame = 1L) {
[16:11:03.387]                     if (is.function(sendCondition)) 
[16:11:03.387]                       return(sendCondition)
[16:11:03.387]                     ns <- getNamespace("parallel")
[16:11:03.387]                     if (exists("sendData", mode = "function", 
[16:11:03.387]                       envir = ns)) {
[16:11:03.387]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:03.387]                         envir = ns)
[16:11:03.387]                       envir <- sys.frame(frame)
[16:11:03.387]                       master <- NULL
[16:11:03.387]                       while (!identical(envir, .GlobalEnv) && 
[16:11:03.387]                         !identical(envir, emptyenv())) {
[16:11:03.387]                         if (exists("master", mode = "list", envir = envir, 
[16:11:03.387]                           inherits = FALSE)) {
[16:11:03.387]                           master <- get("master", mode = "list", 
[16:11:03.387]                             envir = envir, inherits = FALSE)
[16:11:03.387]                           if (inherits(master, c("SOCKnode", 
[16:11:03.387]                             "SOCK0node"))) {
[16:11:03.387]                             sendCondition <<- function(cond) {
[16:11:03.387]                               data <- list(type = "VALUE", value = cond, 
[16:11:03.387]                                 success = TRUE)
[16:11:03.387]                               parallel_sendData(master, data)
[16:11:03.387]                             }
[16:11:03.387]                             return(sendCondition)
[16:11:03.387]                           }
[16:11:03.387]                         }
[16:11:03.387]                         frame <- frame + 1L
[16:11:03.387]                         envir <- sys.frame(frame)
[16:11:03.387]                       }
[16:11:03.387]                     }
[16:11:03.387]                     sendCondition <<- function(cond) NULL
[16:11:03.387]                   }
[16:11:03.387]                 })
[16:11:03.387]                 withCallingHandlers({
[16:11:03.387]                   {
[16:11:03.387]                     do.call(function(...) {
[16:11:03.387]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:03.387]                       if (!identical(...future.globals.maxSize.org, 
[16:11:03.387]                         ...future.globals.maxSize)) {
[16:11:03.387]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:03.387]                         on.exit(options(oopts), add = TRUE)
[16:11:03.387]                       }
[16:11:03.387]                       {
[16:11:03.387]                         lapply(seq_along(...future.elements_ii), 
[16:11:03.387]                           FUN = function(jj) {
[16:11:03.387]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:03.387]                             ...future.FUN(...future.X_jj, ...)
[16:11:03.387]                           })
[16:11:03.387]                       }
[16:11:03.387]                     }, args = future.call.arguments)
[16:11:03.387]                   }
[16:11:03.387]                 }, immediateCondition = function(cond) {
[16:11:03.387]                   sendCondition <- ...future.makeSendCondition()
[16:11:03.387]                   sendCondition(cond)
[16:11:03.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.387]                   {
[16:11:03.387]                     inherits <- base::inherits
[16:11:03.387]                     invokeRestart <- base::invokeRestart
[16:11:03.387]                     is.null <- base::is.null
[16:11:03.387]                     muffled <- FALSE
[16:11:03.387]                     if (inherits(cond, "message")) {
[16:11:03.387]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:03.387]                       if (muffled) 
[16:11:03.387]                         invokeRestart("muffleMessage")
[16:11:03.387]                     }
[16:11:03.387]                     else if (inherits(cond, "warning")) {
[16:11:03.387]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:03.387]                       if (muffled) 
[16:11:03.387]                         invokeRestart("muffleWarning")
[16:11:03.387]                     }
[16:11:03.387]                     else if (inherits(cond, "condition")) {
[16:11:03.387]                       if (!is.null(pattern)) {
[16:11:03.387]                         computeRestarts <- base::computeRestarts
[16:11:03.387]                         grepl <- base::grepl
[16:11:03.387]                         restarts <- computeRestarts(cond)
[16:11:03.387]                         for (restart in restarts) {
[16:11:03.387]                           name <- restart$name
[16:11:03.387]                           if (is.null(name)) 
[16:11:03.387]                             next
[16:11:03.387]                           if (!grepl(pattern, name)) 
[16:11:03.387]                             next
[16:11:03.387]                           invokeRestart(restart)
[16:11:03.387]                           muffled <- TRUE
[16:11:03.387]                           break
[16:11:03.387]                         }
[16:11:03.387]                       }
[16:11:03.387]                     }
[16:11:03.387]                     invisible(muffled)
[16:11:03.387]                   }
[16:11:03.387]                   muffleCondition(cond)
[16:11:03.387]                 })
[16:11:03.387]             }))
[16:11:03.387]             future::FutureResult(value = ...future.value$value, 
[16:11:03.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:03.387]                   ...future.rng), globalenv = if (FALSE) 
[16:11:03.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:03.387]                     ...future.globalenv.names))
[16:11:03.387]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:03.387]         }, condition = base::local({
[16:11:03.387]             c <- base::c
[16:11:03.387]             inherits <- base::inherits
[16:11:03.387]             invokeRestart <- base::invokeRestart
[16:11:03.387]             length <- base::length
[16:11:03.387]             list <- base::list
[16:11:03.387]             seq.int <- base::seq.int
[16:11:03.387]             signalCondition <- base::signalCondition
[16:11:03.387]             sys.calls <- base::sys.calls
[16:11:03.387]             `[[` <- base::`[[`
[16:11:03.387]             `+` <- base::`+`
[16:11:03.387]             `<<-` <- base::`<<-`
[16:11:03.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:03.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:03.387]                   3L)]
[16:11:03.387]             }
[16:11:03.387]             function(cond) {
[16:11:03.387]                 is_error <- inherits(cond, "error")
[16:11:03.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:03.387]                   NULL)
[16:11:03.387]                 if (is_error) {
[16:11:03.387]                   sessionInformation <- function() {
[16:11:03.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:03.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:03.387]                       search = base::search(), system = base::Sys.info())
[16:11:03.387]                   }
[16:11:03.387]                   ...future.conditions[[length(...future.conditions) + 
[16:11:03.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:03.387]                     cond$call), session = sessionInformation(), 
[16:11:03.387]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:03.387]                   signalCondition(cond)
[16:11:03.387]                 }
[16:11:03.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:03.387]                 "immediateCondition"))) {
[16:11:03.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:03.387]                   ...future.conditions[[length(...future.conditions) + 
[16:11:03.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:03.387]                   if (TRUE && !signal) {
[16:11:03.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.387]                     {
[16:11:03.387]                       inherits <- base::inherits
[16:11:03.387]                       invokeRestart <- base::invokeRestart
[16:11:03.387]                       is.null <- base::is.null
[16:11:03.387]                       muffled <- FALSE
[16:11:03.387]                       if (inherits(cond, "message")) {
[16:11:03.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:03.387]                         if (muffled) 
[16:11:03.387]                           invokeRestart("muffleMessage")
[16:11:03.387]                       }
[16:11:03.387]                       else if (inherits(cond, "warning")) {
[16:11:03.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:03.387]                         if (muffled) 
[16:11:03.387]                           invokeRestart("muffleWarning")
[16:11:03.387]                       }
[16:11:03.387]                       else if (inherits(cond, "condition")) {
[16:11:03.387]                         if (!is.null(pattern)) {
[16:11:03.387]                           computeRestarts <- base::computeRestarts
[16:11:03.387]                           grepl <- base::grepl
[16:11:03.387]                           restarts <- computeRestarts(cond)
[16:11:03.387]                           for (restart in restarts) {
[16:11:03.387]                             name <- restart$name
[16:11:03.387]                             if (is.null(name)) 
[16:11:03.387]                               next
[16:11:03.387]                             if (!grepl(pattern, name)) 
[16:11:03.387]                               next
[16:11:03.387]                             invokeRestart(restart)
[16:11:03.387]                             muffled <- TRUE
[16:11:03.387]                             break
[16:11:03.387]                           }
[16:11:03.387]                         }
[16:11:03.387]                       }
[16:11:03.387]                       invisible(muffled)
[16:11:03.387]                     }
[16:11:03.387]                     muffleCondition(cond, pattern = "^muffle")
[16:11:03.387]                   }
[16:11:03.387]                 }
[16:11:03.387]                 else {
[16:11:03.387]                   if (TRUE) {
[16:11:03.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.387]                     {
[16:11:03.387]                       inherits <- base::inherits
[16:11:03.387]                       invokeRestart <- base::invokeRestart
[16:11:03.387]                       is.null <- base::is.null
[16:11:03.387]                       muffled <- FALSE
[16:11:03.387]                       if (inherits(cond, "message")) {
[16:11:03.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:03.387]                         if (muffled) 
[16:11:03.387]                           invokeRestart("muffleMessage")
[16:11:03.387]                       }
[16:11:03.387]                       else if (inherits(cond, "warning")) {
[16:11:03.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:03.387]                         if (muffled) 
[16:11:03.387]                           invokeRestart("muffleWarning")
[16:11:03.387]                       }
[16:11:03.387]                       else if (inherits(cond, "condition")) {
[16:11:03.387]                         if (!is.null(pattern)) {
[16:11:03.387]                           computeRestarts <- base::computeRestarts
[16:11:03.387]                           grepl <- base::grepl
[16:11:03.387]                           restarts <- computeRestarts(cond)
[16:11:03.387]                           for (restart in restarts) {
[16:11:03.387]                             name <- restart$name
[16:11:03.387]                             if (is.null(name)) 
[16:11:03.387]                               next
[16:11:03.387]                             if (!grepl(pattern, name)) 
[16:11:03.387]                               next
[16:11:03.387]                             invokeRestart(restart)
[16:11:03.387]                             muffled <- TRUE
[16:11:03.387]                             break
[16:11:03.387]                           }
[16:11:03.387]                         }
[16:11:03.387]                       }
[16:11:03.387]                       invisible(muffled)
[16:11:03.387]                     }
[16:11:03.387]                     muffleCondition(cond, pattern = "^muffle")
[16:11:03.387]                   }
[16:11:03.387]                 }
[16:11:03.387]             }
[16:11:03.387]         }))
[16:11:03.387]     }, error = function(ex) {
[16:11:03.387]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:03.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:03.387]                 ...future.rng), started = ...future.startTime, 
[16:11:03.387]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:03.387]             version = "1.8"), class = "FutureResult")
[16:11:03.387]     }, finally = {
[16:11:03.387]         if (!identical(...future.workdir, getwd())) 
[16:11:03.387]             setwd(...future.workdir)
[16:11:03.387]         {
[16:11:03.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:03.387]                 ...future.oldOptions$nwarnings <- NULL
[16:11:03.387]             }
[16:11:03.387]             base::options(...future.oldOptions)
[16:11:03.387]             if (.Platform$OS.type == "windows") {
[16:11:03.387]                 old_names <- names(...future.oldEnvVars)
[16:11:03.387]                 envs <- base::Sys.getenv()
[16:11:03.387]                 names <- names(envs)
[16:11:03.387]                 common <- intersect(names, old_names)
[16:11:03.387]                 added <- setdiff(names, old_names)
[16:11:03.387]                 removed <- setdiff(old_names, names)
[16:11:03.387]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:03.387]                   envs[common]]
[16:11:03.387]                 NAMES <- toupper(changed)
[16:11:03.387]                 args <- list()
[16:11:03.387]                 for (kk in seq_along(NAMES)) {
[16:11:03.387]                   name <- changed[[kk]]
[16:11:03.387]                   NAME <- NAMES[[kk]]
[16:11:03.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.387]                     next
[16:11:03.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:03.387]                 }
[16:11:03.387]                 NAMES <- toupper(added)
[16:11:03.387]                 for (kk in seq_along(NAMES)) {
[16:11:03.387]                   name <- added[[kk]]
[16:11:03.387]                   NAME <- NAMES[[kk]]
[16:11:03.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.387]                     next
[16:11:03.387]                   args[[name]] <- ""
[16:11:03.387]                 }
[16:11:03.387]                 NAMES <- toupper(removed)
[16:11:03.387]                 for (kk in seq_along(NAMES)) {
[16:11:03.387]                   name <- removed[[kk]]
[16:11:03.387]                   NAME <- NAMES[[kk]]
[16:11:03.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.387]                     next
[16:11:03.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:03.387]                 }
[16:11:03.387]                 if (length(args) > 0) 
[16:11:03.387]                   base::do.call(base::Sys.setenv, args = args)
[16:11:03.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:03.387]             }
[16:11:03.387]             else {
[16:11:03.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:03.387]             }
[16:11:03.387]             {
[16:11:03.387]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:03.387]                   0L) {
[16:11:03.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:03.387]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:03.387]                   base::options(opts)
[16:11:03.387]                 }
[16:11:03.387]                 {
[16:11:03.387]                   {
[16:11:03.387]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:03.387]                     NULL
[16:11:03.387]                   }
[16:11:03.387]                   options(future.plan = NULL)
[16:11:03.387]                   if (is.na(NA_character_)) 
[16:11:03.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:03.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:03.387]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:03.387]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:03.387]                     envir = parent.frame()) 
[16:11:03.387]                   {
[16:11:03.387]                     if (is.function(workers)) 
[16:11:03.387]                       workers <- workers()
[16:11:03.387]                     workers <- structure(as.integer(workers), 
[16:11:03.387]                       class = class(workers))
[16:11:03.387]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:03.387]                       workers >= 1)
[16:11:03.387]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:03.387]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:03.387]                     }
[16:11:03.387]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:03.387]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:03.387]                       envir = envir)
[16:11:03.387]                     if (!future$lazy) 
[16:11:03.387]                       future <- run(future)
[16:11:03.387]                     invisible(future)
[16:11:03.387]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:03.387]                 }
[16:11:03.387]             }
[16:11:03.387]         }
[16:11:03.387]     })
[16:11:03.387]     if (TRUE) {
[16:11:03.387]         base::sink(type = "output", split = FALSE)
[16:11:03.387]         if (TRUE) {
[16:11:03.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:03.387]         }
[16:11:03.387]         else {
[16:11:03.387]             ...future.result["stdout"] <- base::list(NULL)
[16:11:03.387]         }
[16:11:03.387]         base::close(...future.stdout)
[16:11:03.387]         ...future.stdout <- NULL
[16:11:03.387]     }
[16:11:03.387]     ...future.result$conditions <- ...future.conditions
[16:11:03.387]     ...future.result$finished <- base::Sys.time()
[16:11:03.387]     ...future.result
[16:11:03.387] }
[16:11:03.390] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[16:11:03.390] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:03.432] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:03.432] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:11:03.433] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:11:03.433] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:03.433] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:03.433] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:03.476] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:03.476] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:03.520] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:03.520] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:03.520] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:03.521] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[16:11:03.523] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[16:11:03.524] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:03.524] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:03.524] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[16:11:03.524] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[16:11:03.525] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:03.525] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:03.525] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:03.525] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:03.525] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[16:11:03.526] MultisessionFuture started
[16:11:03.526] - Launch lazy future ... done
[16:11:03.526] run() for ‘MultisessionFuture’ ... done
[16:11:03.526] Created future:
[16:11:03.526] MultisessionFuture:
[16:11:03.526] Label: ‘future_vapply-1’
[16:11:03.526] Expression:
[16:11:03.526] {
[16:11:03.526]     do.call(function(...) {
[16:11:03.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:03.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:03.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:03.526]             on.exit(options(oopts), add = TRUE)
[16:11:03.526]         }
[16:11:03.526]         {
[16:11:03.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:03.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:03.526]                 ...future.FUN(...future.X_jj, ...)
[16:11:03.526]             })
[16:11:03.526]         }
[16:11:03.526]     }, args = future.call.arguments)
[16:11:03.526] }
[16:11:03.526] Lazy evaluation: FALSE
[16:11:03.526] Asynchronous evaluation: TRUE
[16:11:03.526] Local evaluation: TRUE
[16:11:03.526] Environment: R_GlobalEnv
[16:11:03.526] Capture standard output: TRUE
[16:11:03.526] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:03.526] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:03.526] Packages: 1 packages (‘future.apply’)
[16:11:03.526] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:03.526] Resolved: FALSE
[16:11:03.526] Value: <not collected>
[16:11:03.526] Conditions captured: <none>
[16:11:03.526] Early signaling: FALSE
[16:11:03.526] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:03.526] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:03.538] Chunk #1 of 2 ... DONE
[16:11:03.539] Chunk #2 of 2 ...
[16:11:03.539]  - Finding globals in 'X' for chunk #2 ...
[16:11:03.539] getGlobalsAndPackages() ...
[16:11:03.539] Searching for globals...
[16:11:03.539] 
[16:11:03.539] Searching for globals ... DONE
[16:11:03.539] - globals: [0] <none>
[16:11:03.539] getGlobalsAndPackages() ... DONE
[16:11:03.540]    + additional globals found: [n=0] 
[16:11:03.540]    + additional namespaces needed: [n=0] 
[16:11:03.540]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:03.540]  - seeds: <none>
[16:11:03.540] getGlobalsAndPackages() ...
[16:11:03.540] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:03.540] Resolving globals: FALSE
[16:11:03.540] Tweak future expression to call with '...' arguments ...
[16:11:03.540] {
[16:11:03.540]     do.call(function(...) {
[16:11:03.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:03.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:03.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:03.540]             on.exit(options(oopts), add = TRUE)
[16:11:03.540]         }
[16:11:03.540]         {
[16:11:03.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:03.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:03.540]                 ...future.FUN(...future.X_jj, ...)
[16:11:03.540]             })
[16:11:03.540]         }
[16:11:03.540]     }, args = future.call.arguments)
[16:11:03.540] }
[16:11:03.541] Tweak future expression to call with '...' arguments ... DONE
[16:11:03.541] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:03.541] - packages: [1] ‘future.apply’
[16:11:03.541] getGlobalsAndPackages() ... DONE
[16:11:03.542] run() for ‘Future’ ...
[16:11:03.542] - state: ‘created’
[16:11:03.542] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:03.557] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:03.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:03.557]   - Field: ‘node’
[16:11:03.557]   - Field: ‘label’
[16:11:03.557]   - Field: ‘local’
[16:11:03.557]   - Field: ‘owner’
[16:11:03.557]   - Field: ‘envir’
[16:11:03.557]   - Field: ‘workers’
[16:11:03.558]   - Field: ‘packages’
[16:11:03.558]   - Field: ‘gc’
[16:11:03.558]   - Field: ‘conditions’
[16:11:03.558]   - Field: ‘persistent’
[16:11:03.558]   - Field: ‘expr’
[16:11:03.558]   - Field: ‘uuid’
[16:11:03.558]   - Field: ‘seed’
[16:11:03.558]   - Field: ‘version’
[16:11:03.558]   - Field: ‘result’
[16:11:03.558]   - Field: ‘asynchronous’
[16:11:03.558]   - Field: ‘calls’
[16:11:03.559]   - Field: ‘globals’
[16:11:03.559]   - Field: ‘stdout’
[16:11:03.559]   - Field: ‘earlySignal’
[16:11:03.559]   - Field: ‘lazy’
[16:11:03.559]   - Field: ‘state’
[16:11:03.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:03.559] - Launch lazy future ...
[16:11:03.559] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:03.560] Packages needed by future strategies (n = 0): <none>
[16:11:03.560] {
[16:11:03.560]     {
[16:11:03.560]         {
[16:11:03.560]             ...future.startTime <- base::Sys.time()
[16:11:03.560]             {
[16:11:03.560]                 {
[16:11:03.560]                   {
[16:11:03.560]                     {
[16:11:03.560]                       {
[16:11:03.560]                         base::local({
[16:11:03.560]                           has_future <- base::requireNamespace("future", 
[16:11:03.560]                             quietly = TRUE)
[16:11:03.560]                           if (has_future) {
[16:11:03.560]                             ns <- base::getNamespace("future")
[16:11:03.560]                             version <- ns[[".package"]][["version"]]
[16:11:03.560]                             if (is.null(version)) 
[16:11:03.560]                               version <- utils::packageVersion("future")
[16:11:03.560]                           }
[16:11:03.560]                           else {
[16:11:03.560]                             version <- NULL
[16:11:03.560]                           }
[16:11:03.560]                           if (!has_future || version < "1.8.0") {
[16:11:03.560]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:03.560]                               "", base::R.version$version.string), 
[16:11:03.560]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:03.560]                                 base::R.version$platform, 8 * 
[16:11:03.560]                                   base::.Machine$sizeof.pointer), 
[16:11:03.560]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:03.560]                                 "release", "version")], collapse = " "), 
[16:11:03.560]                               hostname = base::Sys.info()[["nodename"]])
[16:11:03.560]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:03.560]                               info)
[16:11:03.560]                             info <- base::paste(info, collapse = "; ")
[16:11:03.560]                             if (!has_future) {
[16:11:03.560]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:03.560]                                 info)
[16:11:03.560]                             }
[16:11:03.560]                             else {
[16:11:03.560]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:03.560]                                 info, version)
[16:11:03.560]                             }
[16:11:03.560]                             base::stop(msg)
[16:11:03.560]                           }
[16:11:03.560]                         })
[16:11:03.560]                       }
[16:11:03.560]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:03.560]                       base::options(mc.cores = 1L)
[16:11:03.560]                     }
[16:11:03.560]                     base::local({
[16:11:03.560]                       for (pkg in "future.apply") {
[16:11:03.560]                         base::loadNamespace(pkg)
[16:11:03.560]                         base::library(pkg, character.only = TRUE)
[16:11:03.560]                       }
[16:11:03.560]                     })
[16:11:03.560]                   }
[16:11:03.560]                   options(future.plan = NULL)
[16:11:03.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:03.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:03.560]                 }
[16:11:03.560]                 ...future.workdir <- getwd()
[16:11:03.560]             }
[16:11:03.560]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:03.560]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:03.560]         }
[16:11:03.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:03.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:03.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:03.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:03.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:03.560]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:03.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:03.560]             base::names(...future.oldOptions))
[16:11:03.560]     }
[16:11:03.560]     if (FALSE) {
[16:11:03.560]     }
[16:11:03.560]     else {
[16:11:03.560]         if (TRUE) {
[16:11:03.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:03.560]                 open = "w")
[16:11:03.560]         }
[16:11:03.560]         else {
[16:11:03.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:03.560]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:03.560]         }
[16:11:03.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:03.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:03.560]             base::sink(type = "output", split = FALSE)
[16:11:03.560]             base::close(...future.stdout)
[16:11:03.560]         }, add = TRUE)
[16:11:03.560]     }
[16:11:03.560]     ...future.frame <- base::sys.nframe()
[16:11:03.560]     ...future.conditions <- base::list()
[16:11:03.560]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:03.560]     if (FALSE) {
[16:11:03.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:03.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:03.560]     }
[16:11:03.560]     ...future.result <- base::tryCatch({
[16:11:03.560]         base::withCallingHandlers({
[16:11:03.560]             ...future.value <- base::withVisible(base::local({
[16:11:03.560]                 ...future.makeSendCondition <- local({
[16:11:03.560]                   sendCondition <- NULL
[16:11:03.560]                   function(frame = 1L) {
[16:11:03.560]                     if (is.function(sendCondition)) 
[16:11:03.560]                       return(sendCondition)
[16:11:03.560]                     ns <- getNamespace("parallel")
[16:11:03.560]                     if (exists("sendData", mode = "function", 
[16:11:03.560]                       envir = ns)) {
[16:11:03.560]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:03.560]                         envir = ns)
[16:11:03.560]                       envir <- sys.frame(frame)
[16:11:03.560]                       master <- NULL
[16:11:03.560]                       while (!identical(envir, .GlobalEnv) && 
[16:11:03.560]                         !identical(envir, emptyenv())) {
[16:11:03.560]                         if (exists("master", mode = "list", envir = envir, 
[16:11:03.560]                           inherits = FALSE)) {
[16:11:03.560]                           master <- get("master", mode = "list", 
[16:11:03.560]                             envir = envir, inherits = FALSE)
[16:11:03.560]                           if (inherits(master, c("SOCKnode", 
[16:11:03.560]                             "SOCK0node"))) {
[16:11:03.560]                             sendCondition <<- function(cond) {
[16:11:03.560]                               data <- list(type = "VALUE", value = cond, 
[16:11:03.560]                                 success = TRUE)
[16:11:03.560]                               parallel_sendData(master, data)
[16:11:03.560]                             }
[16:11:03.560]                             return(sendCondition)
[16:11:03.560]                           }
[16:11:03.560]                         }
[16:11:03.560]                         frame <- frame + 1L
[16:11:03.560]                         envir <- sys.frame(frame)
[16:11:03.560]                       }
[16:11:03.560]                     }
[16:11:03.560]                     sendCondition <<- function(cond) NULL
[16:11:03.560]                   }
[16:11:03.560]                 })
[16:11:03.560]                 withCallingHandlers({
[16:11:03.560]                   {
[16:11:03.560]                     do.call(function(...) {
[16:11:03.560]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:03.560]                       if (!identical(...future.globals.maxSize.org, 
[16:11:03.560]                         ...future.globals.maxSize)) {
[16:11:03.560]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:03.560]                         on.exit(options(oopts), add = TRUE)
[16:11:03.560]                       }
[16:11:03.560]                       {
[16:11:03.560]                         lapply(seq_along(...future.elements_ii), 
[16:11:03.560]                           FUN = function(jj) {
[16:11:03.560]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:03.560]                             ...future.FUN(...future.X_jj, ...)
[16:11:03.560]                           })
[16:11:03.560]                       }
[16:11:03.560]                     }, args = future.call.arguments)
[16:11:03.560]                   }
[16:11:03.560]                 }, immediateCondition = function(cond) {
[16:11:03.560]                   sendCondition <- ...future.makeSendCondition()
[16:11:03.560]                   sendCondition(cond)
[16:11:03.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.560]                   {
[16:11:03.560]                     inherits <- base::inherits
[16:11:03.560]                     invokeRestart <- base::invokeRestart
[16:11:03.560]                     is.null <- base::is.null
[16:11:03.560]                     muffled <- FALSE
[16:11:03.560]                     if (inherits(cond, "message")) {
[16:11:03.560]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:03.560]                       if (muffled) 
[16:11:03.560]                         invokeRestart("muffleMessage")
[16:11:03.560]                     }
[16:11:03.560]                     else if (inherits(cond, "warning")) {
[16:11:03.560]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:03.560]                       if (muffled) 
[16:11:03.560]                         invokeRestart("muffleWarning")
[16:11:03.560]                     }
[16:11:03.560]                     else if (inherits(cond, "condition")) {
[16:11:03.560]                       if (!is.null(pattern)) {
[16:11:03.560]                         computeRestarts <- base::computeRestarts
[16:11:03.560]                         grepl <- base::grepl
[16:11:03.560]                         restarts <- computeRestarts(cond)
[16:11:03.560]                         for (restart in restarts) {
[16:11:03.560]                           name <- restart$name
[16:11:03.560]                           if (is.null(name)) 
[16:11:03.560]                             next
[16:11:03.560]                           if (!grepl(pattern, name)) 
[16:11:03.560]                             next
[16:11:03.560]                           invokeRestart(restart)
[16:11:03.560]                           muffled <- TRUE
[16:11:03.560]                           break
[16:11:03.560]                         }
[16:11:03.560]                       }
[16:11:03.560]                     }
[16:11:03.560]                     invisible(muffled)
[16:11:03.560]                   }
[16:11:03.560]                   muffleCondition(cond)
[16:11:03.560]                 })
[16:11:03.560]             }))
[16:11:03.560]             future::FutureResult(value = ...future.value$value, 
[16:11:03.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:03.560]                   ...future.rng), globalenv = if (FALSE) 
[16:11:03.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:03.560]                     ...future.globalenv.names))
[16:11:03.560]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:03.560]         }, condition = base::local({
[16:11:03.560]             c <- base::c
[16:11:03.560]             inherits <- base::inherits
[16:11:03.560]             invokeRestart <- base::invokeRestart
[16:11:03.560]             length <- base::length
[16:11:03.560]             list <- base::list
[16:11:03.560]             seq.int <- base::seq.int
[16:11:03.560]             signalCondition <- base::signalCondition
[16:11:03.560]             sys.calls <- base::sys.calls
[16:11:03.560]             `[[` <- base::`[[`
[16:11:03.560]             `+` <- base::`+`
[16:11:03.560]             `<<-` <- base::`<<-`
[16:11:03.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:03.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:03.560]                   3L)]
[16:11:03.560]             }
[16:11:03.560]             function(cond) {
[16:11:03.560]                 is_error <- inherits(cond, "error")
[16:11:03.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:03.560]                   NULL)
[16:11:03.560]                 if (is_error) {
[16:11:03.560]                   sessionInformation <- function() {
[16:11:03.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:03.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:03.560]                       search = base::search(), system = base::Sys.info())
[16:11:03.560]                   }
[16:11:03.560]                   ...future.conditions[[length(...future.conditions) + 
[16:11:03.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:03.560]                     cond$call), session = sessionInformation(), 
[16:11:03.560]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:03.560]                   signalCondition(cond)
[16:11:03.560]                 }
[16:11:03.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:03.560]                 "immediateCondition"))) {
[16:11:03.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:03.560]                   ...future.conditions[[length(...future.conditions) + 
[16:11:03.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:03.560]                   if (TRUE && !signal) {
[16:11:03.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.560]                     {
[16:11:03.560]                       inherits <- base::inherits
[16:11:03.560]                       invokeRestart <- base::invokeRestart
[16:11:03.560]                       is.null <- base::is.null
[16:11:03.560]                       muffled <- FALSE
[16:11:03.560]                       if (inherits(cond, "message")) {
[16:11:03.560]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:03.560]                         if (muffled) 
[16:11:03.560]                           invokeRestart("muffleMessage")
[16:11:03.560]                       }
[16:11:03.560]                       else if (inherits(cond, "warning")) {
[16:11:03.560]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:03.560]                         if (muffled) 
[16:11:03.560]                           invokeRestart("muffleWarning")
[16:11:03.560]                       }
[16:11:03.560]                       else if (inherits(cond, "condition")) {
[16:11:03.560]                         if (!is.null(pattern)) {
[16:11:03.560]                           computeRestarts <- base::computeRestarts
[16:11:03.560]                           grepl <- base::grepl
[16:11:03.560]                           restarts <- computeRestarts(cond)
[16:11:03.560]                           for (restart in restarts) {
[16:11:03.560]                             name <- restart$name
[16:11:03.560]                             if (is.null(name)) 
[16:11:03.560]                               next
[16:11:03.560]                             if (!grepl(pattern, name)) 
[16:11:03.560]                               next
[16:11:03.560]                             invokeRestart(restart)
[16:11:03.560]                             muffled <- TRUE
[16:11:03.560]                             break
[16:11:03.560]                           }
[16:11:03.560]                         }
[16:11:03.560]                       }
[16:11:03.560]                       invisible(muffled)
[16:11:03.560]                     }
[16:11:03.560]                     muffleCondition(cond, pattern = "^muffle")
[16:11:03.560]                   }
[16:11:03.560]                 }
[16:11:03.560]                 else {
[16:11:03.560]                   if (TRUE) {
[16:11:03.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.560]                     {
[16:11:03.560]                       inherits <- base::inherits
[16:11:03.560]                       invokeRestart <- base::invokeRestart
[16:11:03.560]                       is.null <- base::is.null
[16:11:03.560]                       muffled <- FALSE
[16:11:03.560]                       if (inherits(cond, "message")) {
[16:11:03.560]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:03.560]                         if (muffled) 
[16:11:03.560]                           invokeRestart("muffleMessage")
[16:11:03.560]                       }
[16:11:03.560]                       else if (inherits(cond, "warning")) {
[16:11:03.560]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:03.560]                         if (muffled) 
[16:11:03.560]                           invokeRestart("muffleWarning")
[16:11:03.560]                       }
[16:11:03.560]                       else if (inherits(cond, "condition")) {
[16:11:03.560]                         if (!is.null(pattern)) {
[16:11:03.560]                           computeRestarts <- base::computeRestarts
[16:11:03.560]                           grepl <- base::grepl
[16:11:03.560]                           restarts <- computeRestarts(cond)
[16:11:03.560]                           for (restart in restarts) {
[16:11:03.560]                             name <- restart$name
[16:11:03.560]                             if (is.null(name)) 
[16:11:03.560]                               next
[16:11:03.560]                             if (!grepl(pattern, name)) 
[16:11:03.560]                               next
[16:11:03.560]                             invokeRestart(restart)
[16:11:03.560]                             muffled <- TRUE
[16:11:03.560]                             break
[16:11:03.560]                           }
[16:11:03.560]                         }
[16:11:03.560]                       }
[16:11:03.560]                       invisible(muffled)
[16:11:03.560]                     }
[16:11:03.560]                     muffleCondition(cond, pattern = "^muffle")
[16:11:03.560]                   }
[16:11:03.560]                 }
[16:11:03.560]             }
[16:11:03.560]         }))
[16:11:03.560]     }, error = function(ex) {
[16:11:03.560]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:03.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:03.560]                 ...future.rng), started = ...future.startTime, 
[16:11:03.560]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:03.560]             version = "1.8"), class = "FutureResult")
[16:11:03.560]     }, finally = {
[16:11:03.560]         if (!identical(...future.workdir, getwd())) 
[16:11:03.560]             setwd(...future.workdir)
[16:11:03.560]         {
[16:11:03.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:03.560]                 ...future.oldOptions$nwarnings <- NULL
[16:11:03.560]             }
[16:11:03.560]             base::options(...future.oldOptions)
[16:11:03.560]             if (.Platform$OS.type == "windows") {
[16:11:03.560]                 old_names <- names(...future.oldEnvVars)
[16:11:03.560]                 envs <- base::Sys.getenv()
[16:11:03.560]                 names <- names(envs)
[16:11:03.560]                 common <- intersect(names, old_names)
[16:11:03.560]                 added <- setdiff(names, old_names)
[16:11:03.560]                 removed <- setdiff(old_names, names)
[16:11:03.560]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:03.560]                   envs[common]]
[16:11:03.560]                 NAMES <- toupper(changed)
[16:11:03.560]                 args <- list()
[16:11:03.560]                 for (kk in seq_along(NAMES)) {
[16:11:03.560]                   name <- changed[[kk]]
[16:11:03.560]                   NAME <- NAMES[[kk]]
[16:11:03.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.560]                     next
[16:11:03.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:03.560]                 }
[16:11:03.560]                 NAMES <- toupper(added)
[16:11:03.560]                 for (kk in seq_along(NAMES)) {
[16:11:03.560]                   name <- added[[kk]]
[16:11:03.560]                   NAME <- NAMES[[kk]]
[16:11:03.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.560]                     next
[16:11:03.560]                   args[[name]] <- ""
[16:11:03.560]                 }
[16:11:03.560]                 NAMES <- toupper(removed)
[16:11:03.560]                 for (kk in seq_along(NAMES)) {
[16:11:03.560]                   name <- removed[[kk]]
[16:11:03.560]                   NAME <- NAMES[[kk]]
[16:11:03.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.560]                     next
[16:11:03.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:03.560]                 }
[16:11:03.560]                 if (length(args) > 0) 
[16:11:03.560]                   base::do.call(base::Sys.setenv, args = args)
[16:11:03.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:03.560]             }
[16:11:03.560]             else {
[16:11:03.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:03.560]             }
[16:11:03.560]             {
[16:11:03.560]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:03.560]                   0L) {
[16:11:03.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:03.560]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:03.560]                   base::options(opts)
[16:11:03.560]                 }
[16:11:03.560]                 {
[16:11:03.560]                   {
[16:11:03.560]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:03.560]                     NULL
[16:11:03.560]                   }
[16:11:03.560]                   options(future.plan = NULL)
[16:11:03.560]                   if (is.na(NA_character_)) 
[16:11:03.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:03.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:03.560]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:03.560]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:03.560]                     envir = parent.frame()) 
[16:11:03.560]                   {
[16:11:03.560]                     if (is.function(workers)) 
[16:11:03.560]                       workers <- workers()
[16:11:03.560]                     workers <- structure(as.integer(workers), 
[16:11:03.560]                       class = class(workers))
[16:11:03.560]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:03.560]                       workers >= 1)
[16:11:03.560]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:03.560]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:03.560]                     }
[16:11:03.560]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:03.560]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:03.560]                       envir = envir)
[16:11:03.560]                     if (!future$lazy) 
[16:11:03.560]                       future <- run(future)
[16:11:03.560]                     invisible(future)
[16:11:03.560]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:03.560]                 }
[16:11:03.560]             }
[16:11:03.560]         }
[16:11:03.560]     })
[16:11:03.560]     if (TRUE) {
[16:11:03.560]         base::sink(type = "output", split = FALSE)
[16:11:03.560]         if (TRUE) {
[16:11:03.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:03.560]         }
[16:11:03.560]         else {
[16:11:03.560]             ...future.result["stdout"] <- base::list(NULL)
[16:11:03.560]         }
[16:11:03.560]         base::close(...future.stdout)
[16:11:03.560]         ...future.stdout <- NULL
[16:11:03.560]     }
[16:11:03.560]     ...future.result$conditions <- ...future.conditions
[16:11:03.560]     ...future.result$finished <- base::Sys.time()
[16:11:03.560]     ...future.result
[16:11:03.560] }
[16:11:03.636] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[16:11:03.636] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:03.641] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:03.641] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:11:03.641] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:11:03.641] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:03.642] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:03.642] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:03.684] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:03.684] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:03.728] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:03.728] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:03.728] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:03.728] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[16:11:03.729] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[16:11:03.729] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:03.729] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:03.729] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[16:11:03.730] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[16:11:03.730] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:03.730] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:03.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:03.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:03.731] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[16:11:03.731] MultisessionFuture started
[16:11:03.731] - Launch lazy future ... done
[16:11:03.731] run() for ‘MultisessionFuture’ ... done
[16:11:03.731] Created future:
[16:11:03.732] MultisessionFuture:
[16:11:03.732] Label: ‘future_vapply-2’
[16:11:03.732] Expression:
[16:11:03.732] {
[16:11:03.732]     do.call(function(...) {
[16:11:03.732]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:03.732]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:03.732]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:03.732]             on.exit(options(oopts), add = TRUE)
[16:11:03.732]         }
[16:11:03.732]         {
[16:11:03.732]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:03.732]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:03.732]                 ...future.FUN(...future.X_jj, ...)
[16:11:03.732]             })
[16:11:03.732]         }
[16:11:03.732]     }, args = future.call.arguments)
[16:11:03.732] }
[16:11:03.732] Lazy evaluation: FALSE
[16:11:03.732] Asynchronous evaluation: TRUE
[16:11:03.732] Local evaluation: TRUE
[16:11:03.732] Environment: R_GlobalEnv
[16:11:03.732] Capture standard output: TRUE
[16:11:03.732] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:03.732] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:03.732] Packages: 1 packages (‘future.apply’)
[16:11:03.732] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:03.732] Resolved: FALSE
[16:11:03.732] Value: <not collected>
[16:11:03.732] Conditions captured: <none>
[16:11:03.732] Early signaling: FALSE
[16:11:03.732] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:03.732] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:03.743] Chunk #2 of 2 ... DONE
[16:11:03.743] Launching 2 futures (chunks) ... DONE
[16:11:03.744] Resolving 2 futures (chunks) ...
[16:11:03.744] resolve() on list ...
[16:11:03.744]  recursive: 0
[16:11:03.744]  length: 2
[16:11:03.744] 
[16:11:03.744] receiveMessageFromWorker() for ClusterFuture ...
[16:11:03.745] - Validating connection of MultisessionFuture
[16:11:03.745] - received message: FutureResult
[16:11:03.745] - Received FutureResult
[16:11:03.745] - Erased future from FutureRegistry
[16:11:03.745] result() for ClusterFuture ...
[16:11:03.745] - result already collected: FutureResult
[16:11:03.745] result() for ClusterFuture ... done
[16:11:03.745] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:03.745] Future #1
[16:11:03.746] result() for ClusterFuture ...
[16:11:03.746] - result already collected: FutureResult
[16:11:03.746] result() for ClusterFuture ... done
[16:11:03.746] result() for ClusterFuture ...
[16:11:03.746] - result already collected: FutureResult
[16:11:03.746] result() for ClusterFuture ... done
[16:11:03.746] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:03.746] - nx: 2
[16:11:03.746] - relay: TRUE
[16:11:03.746] - stdout: TRUE
[16:11:03.746] - signal: TRUE
[16:11:03.746] - resignal: FALSE
[16:11:03.747] - force: TRUE
[16:11:03.747] - relayed: [n=2] FALSE, FALSE
[16:11:03.747] - queued futures: [n=2] FALSE, FALSE
[16:11:03.747]  - until=1
[16:11:03.747]  - relaying element #1
[16:11:03.747] result() for ClusterFuture ...
[16:11:03.747] - result already collected: FutureResult
[16:11:03.747] result() for ClusterFuture ... done
[16:11:03.747] result() for ClusterFuture ...
[16:11:03.747] - result already collected: FutureResult
[16:11:03.747] result() for ClusterFuture ... done
[16:11:03.747] result() for ClusterFuture ...
[16:11:03.748] - result already collected: FutureResult
[16:11:03.748] result() for ClusterFuture ... done
[16:11:03.748] result() for ClusterFuture ...
[16:11:03.748] - result already collected: FutureResult
[16:11:03.748] result() for ClusterFuture ... done
[16:11:03.748] - relayed: [n=2] TRUE, FALSE
[16:11:03.748] - queued futures: [n=2] TRUE, FALSE
[16:11:03.748] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:03.748]  length: 1 (resolved future 1)
[16:11:03.810] receiveMessageFromWorker() for ClusterFuture ...
[16:11:03.811] - Validating connection of MultisessionFuture
[16:11:03.811] - received message: FutureResult
[16:11:03.811] - Received FutureResult
[16:11:03.811] - Erased future from FutureRegistry
[16:11:03.811] result() for ClusterFuture ...
[16:11:03.811] - result already collected: FutureResult
[16:11:03.811] result() for ClusterFuture ... done
[16:11:03.811] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:03.812] Future #2
[16:11:03.812] result() for ClusterFuture ...
[16:11:03.812] - result already collected: FutureResult
[16:11:03.812] result() for ClusterFuture ... done
[16:11:03.812] result() for ClusterFuture ...
[16:11:03.812] - result already collected: FutureResult
[16:11:03.812] result() for ClusterFuture ... done
[16:11:03.812] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:03.812] - nx: 2
[16:11:03.812] - relay: TRUE
[16:11:03.812] - stdout: TRUE
[16:11:03.813] - signal: TRUE
[16:11:03.813] - resignal: FALSE
[16:11:03.813] - force: TRUE
[16:11:03.813] - relayed: [n=2] TRUE, FALSE
[16:11:03.813] - queued futures: [n=2] TRUE, FALSE
[16:11:03.813]  - until=2
[16:11:03.813]  - relaying element #2
[16:11:03.813] result() for ClusterFuture ...
[16:11:03.813] - result already collected: FutureResult
[16:11:03.813] result() for ClusterFuture ... done
[16:11:03.813] result() for ClusterFuture ...
[16:11:03.814] - result already collected: FutureResult
[16:11:03.814] result() for ClusterFuture ... done
[16:11:03.814] result() for ClusterFuture ...
[16:11:03.814] - result already collected: FutureResult
[16:11:03.814] result() for ClusterFuture ... done
[16:11:03.814] result() for ClusterFuture ...
[16:11:03.814] - result already collected: FutureResult
[16:11:03.814] result() for ClusterFuture ... done
[16:11:03.814] - relayed: [n=2] TRUE, TRUE
[16:11:03.814] - queued futures: [n=2] TRUE, TRUE
[16:11:03.814] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:03.815]  length: 0 (resolved future 2)
[16:11:03.815] Relaying remaining futures
[16:11:03.815] signalConditionsASAP(NULL, pos=0) ...
[16:11:03.815] - nx: 2
[16:11:03.815] - relay: TRUE
[16:11:03.815] - stdout: TRUE
[16:11:03.815] - signal: TRUE
[16:11:03.815] - resignal: FALSE
[16:11:03.815] - force: TRUE
[16:11:03.815] - relayed: [n=2] TRUE, TRUE
[16:11:03.815] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:03.816] - relayed: [n=2] TRUE, TRUE
[16:11:03.816] - queued futures: [n=2] TRUE, TRUE
[16:11:03.816] signalConditionsASAP(NULL, pos=0) ... done
[16:11:03.816] resolve() on list ... DONE
[16:11:03.816] result() for ClusterFuture ...
[16:11:03.816] - result already collected: FutureResult
[16:11:03.816] result() for ClusterFuture ... done
[16:11:03.816] result() for ClusterFuture ...
[16:11:03.816] - result already collected: FutureResult
[16:11:03.816] result() for ClusterFuture ... done
[16:11:03.816] result() for ClusterFuture ...
[16:11:03.817] - result already collected: FutureResult
[16:11:03.817] result() for ClusterFuture ... done
[16:11:03.817] result() for ClusterFuture ...
[16:11:03.817] - result already collected: FutureResult
[16:11:03.817] result() for ClusterFuture ... done
[16:11:03.817]  - Number of value chunks collected: 2
[16:11:03.817] Resolving 2 futures (chunks) ... DONE
[16:11:03.817] Reducing values from 2 chunks ...
[16:11:03.817]  - Number of values collected after concatenation: 2
[16:11:03.817]  - Number of values expected: 2
[16:11:03.817] Reducing values from 2 chunks ... DONE
[16:11:03.817] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[16:11:03.819] future_lapply() ...
[16:11:03.824] Number of chunks: 2
[16:11:03.824] getGlobalsAndPackagesXApply() ...
[16:11:03.824]  - future.globals: TRUE
[16:11:03.824] getGlobalsAndPackages() ...
[16:11:03.824] Searching for globals...
[16:11:03.828] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[16:11:03.828] Searching for globals ... DONE
[16:11:03.828] Resolving globals: FALSE
[16:11:03.829] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[16:11:03.829] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:03.830] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:03.830] - packages: [1] ‘future.apply’
[16:11:03.830] getGlobalsAndPackages() ... DONE
[16:11:03.830]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:03.830]  - needed namespaces: [n=1] ‘future.apply’
[16:11:03.830] Finding globals ... DONE
[16:11:03.830]  - use_args: TRUE
[16:11:03.830]  - Getting '...' globals ...
[16:11:03.831] resolve() on list ...
[16:11:03.831]  recursive: 0
[16:11:03.831]  length: 1
[16:11:03.831]  elements: ‘...’
[16:11:03.831]  length: 0 (resolved future 1)
[16:11:03.831] resolve() on list ... DONE
[16:11:03.831]    - '...' content: [n=0] 
[16:11:03.831] List of 1
[16:11:03.831]  $ ...: list()
[16:11:03.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:03.831]  - attr(*, "where")=List of 1
[16:11:03.831]   ..$ ...:<environment: 0x561e8b5711d0> 
[16:11:03.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:03.831]  - attr(*, "resolved")= logi TRUE
[16:11:03.831]  - attr(*, "total_size")= num NA
[16:11:03.834]  - Getting '...' globals ... DONE
[16:11:03.834] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:03.834] List of 8
[16:11:03.834]  $ ...future.FUN:function (x, ...)  
[16:11:03.834]  $ x_FUN        :function (x)  
[16:11:03.834]  $ times        : int 0
[16:11:03.834]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:03.834]  $ stop_if_not  :function (...)  
[16:11:03.834]  $ dim          : NULL
[16:11:03.834]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:03.834]  $ ...          : list()
[16:11:03.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:03.834]  - attr(*, "where")=List of 8
[16:11:03.834]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:03.834]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:03.834]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:03.834]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:03.834]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:03.834]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:03.834]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:03.834]   ..$ ...          :<environment: 0x561e8b5711d0> 
[16:11:03.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:03.834]  - attr(*, "resolved")= logi FALSE
[16:11:03.834]  - attr(*, "total_size")= num 95472
[16:11:03.839] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:03.839] getGlobalsAndPackagesXApply() ... DONE
[16:11:03.839] Number of futures (= number of chunks): 2
[16:11:03.839] Launching 2 futures (chunks) ...
[16:11:03.840] Chunk #1 of 2 ...
[16:11:03.840]  - Finding globals in 'X' for chunk #1 ...
[16:11:03.840] getGlobalsAndPackages() ...
[16:11:03.840] Searching for globals...
[16:11:03.840] 
[16:11:03.840] Searching for globals ... DONE
[16:11:03.840] - globals: [0] <none>
[16:11:03.840] getGlobalsAndPackages() ... DONE
[16:11:03.841]    + additional globals found: [n=0] 
[16:11:03.841]    + additional namespaces needed: [n=0] 
[16:11:03.841]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:03.841]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:03.841]  - seeds: <none>
[16:11:03.841] getGlobalsAndPackages() ...
[16:11:03.841] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:03.841] Resolving globals: FALSE
[16:11:03.841] Tweak future expression to call with '...' arguments ...
[16:11:03.841] {
[16:11:03.841]     do.call(function(...) {
[16:11:03.841]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:03.841]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:03.841]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:03.841]             on.exit(options(oopts), add = TRUE)
[16:11:03.841]         }
[16:11:03.841]         {
[16:11:03.841]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:03.841]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:03.841]                 ...future.FUN(...future.X_jj, ...)
[16:11:03.841]             })
[16:11:03.841]         }
[16:11:03.841]     }, args = future.call.arguments)
[16:11:03.841] }
[16:11:03.842] Tweak future expression to call with '...' arguments ... DONE
[16:11:03.842] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:03.842] - packages: [1] ‘future.apply’
[16:11:03.842] getGlobalsAndPackages() ... DONE
[16:11:03.843] run() for ‘Future’ ...
[16:11:03.843] - state: ‘created’
[16:11:03.843] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:03.857] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:03.857] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:03.857]   - Field: ‘node’
[16:11:03.858]   - Field: ‘label’
[16:11:03.858]   - Field: ‘local’
[16:11:03.858]   - Field: ‘owner’
[16:11:03.858]   - Field: ‘envir’
[16:11:03.858]   - Field: ‘workers’
[16:11:03.858]   - Field: ‘packages’
[16:11:03.858]   - Field: ‘gc’
[16:11:03.858]   - Field: ‘conditions’
[16:11:03.858]   - Field: ‘persistent’
[16:11:03.858]   - Field: ‘expr’
[16:11:03.859]   - Field: ‘uuid’
[16:11:03.859]   - Field: ‘seed’
[16:11:03.859]   - Field: ‘version’
[16:11:03.859]   - Field: ‘result’
[16:11:03.859]   - Field: ‘asynchronous’
[16:11:03.859]   - Field: ‘calls’
[16:11:03.859]   - Field: ‘globals’
[16:11:03.859]   - Field: ‘stdout’
[16:11:03.859]   - Field: ‘earlySignal’
[16:11:03.859]   - Field: ‘lazy’
[16:11:03.859]   - Field: ‘state’
[16:11:03.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:03.860] - Launch lazy future ...
[16:11:03.860] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:03.860] Packages needed by future strategies (n = 0): <none>
[16:11:03.861] {
[16:11:03.861]     {
[16:11:03.861]         {
[16:11:03.861]             ...future.startTime <- base::Sys.time()
[16:11:03.861]             {
[16:11:03.861]                 {
[16:11:03.861]                   {
[16:11:03.861]                     {
[16:11:03.861]                       {
[16:11:03.861]                         base::local({
[16:11:03.861]                           has_future <- base::requireNamespace("future", 
[16:11:03.861]                             quietly = TRUE)
[16:11:03.861]                           if (has_future) {
[16:11:03.861]                             ns <- base::getNamespace("future")
[16:11:03.861]                             version <- ns[[".package"]][["version"]]
[16:11:03.861]                             if (is.null(version)) 
[16:11:03.861]                               version <- utils::packageVersion("future")
[16:11:03.861]                           }
[16:11:03.861]                           else {
[16:11:03.861]                             version <- NULL
[16:11:03.861]                           }
[16:11:03.861]                           if (!has_future || version < "1.8.0") {
[16:11:03.861]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:03.861]                               "", base::R.version$version.string), 
[16:11:03.861]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:03.861]                                 base::R.version$platform, 8 * 
[16:11:03.861]                                   base::.Machine$sizeof.pointer), 
[16:11:03.861]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:03.861]                                 "release", "version")], collapse = " "), 
[16:11:03.861]                               hostname = base::Sys.info()[["nodename"]])
[16:11:03.861]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:03.861]                               info)
[16:11:03.861]                             info <- base::paste(info, collapse = "; ")
[16:11:03.861]                             if (!has_future) {
[16:11:03.861]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:03.861]                                 info)
[16:11:03.861]                             }
[16:11:03.861]                             else {
[16:11:03.861]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:03.861]                                 info, version)
[16:11:03.861]                             }
[16:11:03.861]                             base::stop(msg)
[16:11:03.861]                           }
[16:11:03.861]                         })
[16:11:03.861]                       }
[16:11:03.861]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:03.861]                       base::options(mc.cores = 1L)
[16:11:03.861]                     }
[16:11:03.861]                     base::local({
[16:11:03.861]                       for (pkg in "future.apply") {
[16:11:03.861]                         base::loadNamespace(pkg)
[16:11:03.861]                         base::library(pkg, character.only = TRUE)
[16:11:03.861]                       }
[16:11:03.861]                     })
[16:11:03.861]                   }
[16:11:03.861]                   options(future.plan = NULL)
[16:11:03.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:03.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:03.861]                 }
[16:11:03.861]                 ...future.workdir <- getwd()
[16:11:03.861]             }
[16:11:03.861]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:03.861]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:03.861]         }
[16:11:03.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:03.861]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:03.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:03.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:03.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:03.861]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:03.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:03.861]             base::names(...future.oldOptions))
[16:11:03.861]     }
[16:11:03.861]     if (FALSE) {
[16:11:03.861]     }
[16:11:03.861]     else {
[16:11:03.861]         if (TRUE) {
[16:11:03.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:03.861]                 open = "w")
[16:11:03.861]         }
[16:11:03.861]         else {
[16:11:03.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:03.861]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:03.861]         }
[16:11:03.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:03.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:03.861]             base::sink(type = "output", split = FALSE)
[16:11:03.861]             base::close(...future.stdout)
[16:11:03.861]         }, add = TRUE)
[16:11:03.861]     }
[16:11:03.861]     ...future.frame <- base::sys.nframe()
[16:11:03.861]     ...future.conditions <- base::list()
[16:11:03.861]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:03.861]     if (FALSE) {
[16:11:03.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:03.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:03.861]     }
[16:11:03.861]     ...future.result <- base::tryCatch({
[16:11:03.861]         base::withCallingHandlers({
[16:11:03.861]             ...future.value <- base::withVisible(base::local({
[16:11:03.861]                 ...future.makeSendCondition <- local({
[16:11:03.861]                   sendCondition <- NULL
[16:11:03.861]                   function(frame = 1L) {
[16:11:03.861]                     if (is.function(sendCondition)) 
[16:11:03.861]                       return(sendCondition)
[16:11:03.861]                     ns <- getNamespace("parallel")
[16:11:03.861]                     if (exists("sendData", mode = "function", 
[16:11:03.861]                       envir = ns)) {
[16:11:03.861]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:03.861]                         envir = ns)
[16:11:03.861]                       envir <- sys.frame(frame)
[16:11:03.861]                       master <- NULL
[16:11:03.861]                       while (!identical(envir, .GlobalEnv) && 
[16:11:03.861]                         !identical(envir, emptyenv())) {
[16:11:03.861]                         if (exists("master", mode = "list", envir = envir, 
[16:11:03.861]                           inherits = FALSE)) {
[16:11:03.861]                           master <- get("master", mode = "list", 
[16:11:03.861]                             envir = envir, inherits = FALSE)
[16:11:03.861]                           if (inherits(master, c("SOCKnode", 
[16:11:03.861]                             "SOCK0node"))) {
[16:11:03.861]                             sendCondition <<- function(cond) {
[16:11:03.861]                               data <- list(type = "VALUE", value = cond, 
[16:11:03.861]                                 success = TRUE)
[16:11:03.861]                               parallel_sendData(master, data)
[16:11:03.861]                             }
[16:11:03.861]                             return(sendCondition)
[16:11:03.861]                           }
[16:11:03.861]                         }
[16:11:03.861]                         frame <- frame + 1L
[16:11:03.861]                         envir <- sys.frame(frame)
[16:11:03.861]                       }
[16:11:03.861]                     }
[16:11:03.861]                     sendCondition <<- function(cond) NULL
[16:11:03.861]                   }
[16:11:03.861]                 })
[16:11:03.861]                 withCallingHandlers({
[16:11:03.861]                   {
[16:11:03.861]                     do.call(function(...) {
[16:11:03.861]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:03.861]                       if (!identical(...future.globals.maxSize.org, 
[16:11:03.861]                         ...future.globals.maxSize)) {
[16:11:03.861]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:03.861]                         on.exit(options(oopts), add = TRUE)
[16:11:03.861]                       }
[16:11:03.861]                       {
[16:11:03.861]                         lapply(seq_along(...future.elements_ii), 
[16:11:03.861]                           FUN = function(jj) {
[16:11:03.861]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:03.861]                             ...future.FUN(...future.X_jj, ...)
[16:11:03.861]                           })
[16:11:03.861]                       }
[16:11:03.861]                     }, args = future.call.arguments)
[16:11:03.861]                   }
[16:11:03.861]                 }, immediateCondition = function(cond) {
[16:11:03.861]                   sendCondition <- ...future.makeSendCondition()
[16:11:03.861]                   sendCondition(cond)
[16:11:03.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.861]                   {
[16:11:03.861]                     inherits <- base::inherits
[16:11:03.861]                     invokeRestart <- base::invokeRestart
[16:11:03.861]                     is.null <- base::is.null
[16:11:03.861]                     muffled <- FALSE
[16:11:03.861]                     if (inherits(cond, "message")) {
[16:11:03.861]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:03.861]                       if (muffled) 
[16:11:03.861]                         invokeRestart("muffleMessage")
[16:11:03.861]                     }
[16:11:03.861]                     else if (inherits(cond, "warning")) {
[16:11:03.861]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:03.861]                       if (muffled) 
[16:11:03.861]                         invokeRestart("muffleWarning")
[16:11:03.861]                     }
[16:11:03.861]                     else if (inherits(cond, "condition")) {
[16:11:03.861]                       if (!is.null(pattern)) {
[16:11:03.861]                         computeRestarts <- base::computeRestarts
[16:11:03.861]                         grepl <- base::grepl
[16:11:03.861]                         restarts <- computeRestarts(cond)
[16:11:03.861]                         for (restart in restarts) {
[16:11:03.861]                           name <- restart$name
[16:11:03.861]                           if (is.null(name)) 
[16:11:03.861]                             next
[16:11:03.861]                           if (!grepl(pattern, name)) 
[16:11:03.861]                             next
[16:11:03.861]                           invokeRestart(restart)
[16:11:03.861]                           muffled <- TRUE
[16:11:03.861]                           break
[16:11:03.861]                         }
[16:11:03.861]                       }
[16:11:03.861]                     }
[16:11:03.861]                     invisible(muffled)
[16:11:03.861]                   }
[16:11:03.861]                   muffleCondition(cond)
[16:11:03.861]                 })
[16:11:03.861]             }))
[16:11:03.861]             future::FutureResult(value = ...future.value$value, 
[16:11:03.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:03.861]                   ...future.rng), globalenv = if (FALSE) 
[16:11:03.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:03.861]                     ...future.globalenv.names))
[16:11:03.861]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:03.861]         }, condition = base::local({
[16:11:03.861]             c <- base::c
[16:11:03.861]             inherits <- base::inherits
[16:11:03.861]             invokeRestart <- base::invokeRestart
[16:11:03.861]             length <- base::length
[16:11:03.861]             list <- base::list
[16:11:03.861]             seq.int <- base::seq.int
[16:11:03.861]             signalCondition <- base::signalCondition
[16:11:03.861]             sys.calls <- base::sys.calls
[16:11:03.861]             `[[` <- base::`[[`
[16:11:03.861]             `+` <- base::`+`
[16:11:03.861]             `<<-` <- base::`<<-`
[16:11:03.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:03.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:03.861]                   3L)]
[16:11:03.861]             }
[16:11:03.861]             function(cond) {
[16:11:03.861]                 is_error <- inherits(cond, "error")
[16:11:03.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:03.861]                   NULL)
[16:11:03.861]                 if (is_error) {
[16:11:03.861]                   sessionInformation <- function() {
[16:11:03.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:03.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:03.861]                       search = base::search(), system = base::Sys.info())
[16:11:03.861]                   }
[16:11:03.861]                   ...future.conditions[[length(...future.conditions) + 
[16:11:03.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:03.861]                     cond$call), session = sessionInformation(), 
[16:11:03.861]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:03.861]                   signalCondition(cond)
[16:11:03.861]                 }
[16:11:03.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:03.861]                 "immediateCondition"))) {
[16:11:03.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:03.861]                   ...future.conditions[[length(...future.conditions) + 
[16:11:03.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:03.861]                   if (TRUE && !signal) {
[16:11:03.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.861]                     {
[16:11:03.861]                       inherits <- base::inherits
[16:11:03.861]                       invokeRestart <- base::invokeRestart
[16:11:03.861]                       is.null <- base::is.null
[16:11:03.861]                       muffled <- FALSE
[16:11:03.861]                       if (inherits(cond, "message")) {
[16:11:03.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:03.861]                         if (muffled) 
[16:11:03.861]                           invokeRestart("muffleMessage")
[16:11:03.861]                       }
[16:11:03.861]                       else if (inherits(cond, "warning")) {
[16:11:03.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:03.861]                         if (muffled) 
[16:11:03.861]                           invokeRestart("muffleWarning")
[16:11:03.861]                       }
[16:11:03.861]                       else if (inherits(cond, "condition")) {
[16:11:03.861]                         if (!is.null(pattern)) {
[16:11:03.861]                           computeRestarts <- base::computeRestarts
[16:11:03.861]                           grepl <- base::grepl
[16:11:03.861]                           restarts <- computeRestarts(cond)
[16:11:03.861]                           for (restart in restarts) {
[16:11:03.861]                             name <- restart$name
[16:11:03.861]                             if (is.null(name)) 
[16:11:03.861]                               next
[16:11:03.861]                             if (!grepl(pattern, name)) 
[16:11:03.861]                               next
[16:11:03.861]                             invokeRestart(restart)
[16:11:03.861]                             muffled <- TRUE
[16:11:03.861]                             break
[16:11:03.861]                           }
[16:11:03.861]                         }
[16:11:03.861]                       }
[16:11:03.861]                       invisible(muffled)
[16:11:03.861]                     }
[16:11:03.861]                     muffleCondition(cond, pattern = "^muffle")
[16:11:03.861]                   }
[16:11:03.861]                 }
[16:11:03.861]                 else {
[16:11:03.861]                   if (TRUE) {
[16:11:03.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:03.861]                     {
[16:11:03.861]                       inherits <- base::inherits
[16:11:03.861]                       invokeRestart <- base::invokeRestart
[16:11:03.861]                       is.null <- base::is.null
[16:11:03.861]                       muffled <- FALSE
[16:11:03.861]                       if (inherits(cond, "message")) {
[16:11:03.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:03.861]                         if (muffled) 
[16:11:03.861]                           invokeRestart("muffleMessage")
[16:11:03.861]                       }
[16:11:03.861]                       else if (inherits(cond, "warning")) {
[16:11:03.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:03.861]                         if (muffled) 
[16:11:03.861]                           invokeRestart("muffleWarning")
[16:11:03.861]                       }
[16:11:03.861]                       else if (inherits(cond, "condition")) {
[16:11:03.861]                         if (!is.null(pattern)) {
[16:11:03.861]                           computeRestarts <- base::computeRestarts
[16:11:03.861]                           grepl <- base::grepl
[16:11:03.861]                           restarts <- computeRestarts(cond)
[16:11:03.861]                           for (restart in restarts) {
[16:11:03.861]                             name <- restart$name
[16:11:03.861]                             if (is.null(name)) 
[16:11:03.861]                               next
[16:11:03.861]                             if (!grepl(pattern, name)) 
[16:11:03.861]                               next
[16:11:03.861]                             invokeRestart(restart)
[16:11:03.861]                             muffled <- TRUE
[16:11:03.861]                             break
[16:11:03.861]                           }
[16:11:03.861]                         }
[16:11:03.861]                       }
[16:11:03.861]                       invisible(muffled)
[16:11:03.861]                     }
[16:11:03.861]                     muffleCondition(cond, pattern = "^muffle")
[16:11:03.861]                   }
[16:11:03.861]                 }
[16:11:03.861]             }
[16:11:03.861]         }))
[16:11:03.861]     }, error = function(ex) {
[16:11:03.861]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:03.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:03.861]                 ...future.rng), started = ...future.startTime, 
[16:11:03.861]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:03.861]             version = "1.8"), class = "FutureResult")
[16:11:03.861]     }, finally = {
[16:11:03.861]         if (!identical(...future.workdir, getwd())) 
[16:11:03.861]             setwd(...future.workdir)
[16:11:03.861]         {
[16:11:03.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:03.861]                 ...future.oldOptions$nwarnings <- NULL
[16:11:03.861]             }
[16:11:03.861]             base::options(...future.oldOptions)
[16:11:03.861]             if (.Platform$OS.type == "windows") {
[16:11:03.861]                 old_names <- names(...future.oldEnvVars)
[16:11:03.861]                 envs <- base::Sys.getenv()
[16:11:03.861]                 names <- names(envs)
[16:11:03.861]                 common <- intersect(names, old_names)
[16:11:03.861]                 added <- setdiff(names, old_names)
[16:11:03.861]                 removed <- setdiff(old_names, names)
[16:11:03.861]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:03.861]                   envs[common]]
[16:11:03.861]                 NAMES <- toupper(changed)
[16:11:03.861]                 args <- list()
[16:11:03.861]                 for (kk in seq_along(NAMES)) {
[16:11:03.861]                   name <- changed[[kk]]
[16:11:03.861]                   NAME <- NAMES[[kk]]
[16:11:03.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.861]                     next
[16:11:03.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:03.861]                 }
[16:11:03.861]                 NAMES <- toupper(added)
[16:11:03.861]                 for (kk in seq_along(NAMES)) {
[16:11:03.861]                   name <- added[[kk]]
[16:11:03.861]                   NAME <- NAMES[[kk]]
[16:11:03.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.861]                     next
[16:11:03.861]                   args[[name]] <- ""
[16:11:03.861]                 }
[16:11:03.861]                 NAMES <- toupper(removed)
[16:11:03.861]                 for (kk in seq_along(NAMES)) {
[16:11:03.861]                   name <- removed[[kk]]
[16:11:03.861]                   NAME <- NAMES[[kk]]
[16:11:03.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:03.861]                     next
[16:11:03.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:03.861]                 }
[16:11:03.861]                 if (length(args) > 0) 
[16:11:03.861]                   base::do.call(base::Sys.setenv, args = args)
[16:11:03.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:03.861]             }
[16:11:03.861]             else {
[16:11:03.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:03.861]             }
[16:11:03.861]             {
[16:11:03.861]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:03.861]                   0L) {
[16:11:03.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:03.861]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:03.861]                   base::options(opts)
[16:11:03.861]                 }
[16:11:03.861]                 {
[16:11:03.861]                   {
[16:11:03.861]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:03.861]                     NULL
[16:11:03.861]                   }
[16:11:03.861]                   options(future.plan = NULL)
[16:11:03.861]                   if (is.na(NA_character_)) 
[16:11:03.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:03.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:03.861]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:03.861]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:03.861]                     envir = parent.frame()) 
[16:11:03.861]                   {
[16:11:03.861]                     if (is.function(workers)) 
[16:11:03.861]                       workers <- workers()
[16:11:03.861]                     workers <- structure(as.integer(workers), 
[16:11:03.861]                       class = class(workers))
[16:11:03.861]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:03.861]                       workers >= 1)
[16:11:03.861]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:03.861]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:03.861]                     }
[16:11:03.861]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:03.861]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:03.861]                       envir = envir)
[16:11:03.861]                     if (!future$lazy) 
[16:11:03.861]                       future <- run(future)
[16:11:03.861]                     invisible(future)
[16:11:03.861]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:03.861]                 }
[16:11:03.861]             }
[16:11:03.861]         }
[16:11:03.861]     })
[16:11:03.861]     if (TRUE) {
[16:11:03.861]         base::sink(type = "output", split = FALSE)
[16:11:03.861]         if (TRUE) {
[16:11:03.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:03.861]         }
[16:11:03.861]         else {
[16:11:03.861]             ...future.result["stdout"] <- base::list(NULL)
[16:11:03.861]         }
[16:11:03.861]         base::close(...future.stdout)
[16:11:03.861]         ...future.stdout <- NULL
[16:11:03.861]     }
[16:11:03.861]     ...future.result$conditions <- ...future.conditions
[16:11:03.861]     ...future.result$finished <- base::Sys.time()
[16:11:03.861]     ...future.result
[16:11:03.861] }
[16:11:03.863] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[16:11:03.863] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:03.908] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:03.908] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[16:11:03.908] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[16:11:03.909] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:03.909] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:03.909] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:03.952] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:03.952] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:03.996] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:03.996] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:03.996] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:03.997] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:03.997] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:03.997] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:03.997] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:03.998] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:11:03.998] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:11:03.998] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:04.000] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.000] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:04.001] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.001] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[16:11:04.001] MultisessionFuture started
[16:11:04.002] - Launch lazy future ... done
[16:11:04.002] run() for ‘MultisessionFuture’ ... done
[16:11:04.002] Created future:
[16:11:04.002] MultisessionFuture:
[16:11:04.002] Label: ‘future_vapply-1’
[16:11:04.002] Expression:
[16:11:04.002] {
[16:11:04.002]     do.call(function(...) {
[16:11:04.002]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.002]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.002]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.002]             on.exit(options(oopts), add = TRUE)
[16:11:04.002]         }
[16:11:04.002]         {
[16:11:04.002]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.002]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.002]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.002]             })
[16:11:04.002]         }
[16:11:04.002]     }, args = future.call.arguments)
[16:11:04.002] }
[16:11:04.002] Lazy evaluation: FALSE
[16:11:04.002] Asynchronous evaluation: TRUE
[16:11:04.002] Local evaluation: TRUE
[16:11:04.002] Environment: R_GlobalEnv
[16:11:04.002] Capture standard output: TRUE
[16:11:04.002] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:04.002] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:04.002] Packages: 1 packages (‘future.apply’)
[16:11:04.002] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:04.002] Resolved: FALSE
[16:11:04.002] Value: <not collected>
[16:11:04.002] Conditions captured: <none>
[16:11:04.002] Early signaling: FALSE
[16:11:04.002] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:04.002] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.013] Chunk #1 of 2 ... DONE
[16:11:04.014] Chunk #2 of 2 ...
[16:11:04.014]  - Finding globals in 'X' for chunk #2 ...
[16:11:04.014] getGlobalsAndPackages() ...
[16:11:04.014] Searching for globals...
[16:11:04.014] 
[16:11:04.014] Searching for globals ... DONE
[16:11:04.014] - globals: [0] <none>
[16:11:04.014] getGlobalsAndPackages() ... DONE
[16:11:04.014]    + additional globals found: [n=0] 
[16:11:04.015]    + additional namespaces needed: [n=0] 
[16:11:04.015]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:04.015]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:04.015]  - seeds: <none>
[16:11:04.015] getGlobalsAndPackages() ...
[16:11:04.015] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.015] Resolving globals: FALSE
[16:11:04.015] Tweak future expression to call with '...' arguments ...
[16:11:04.015] {
[16:11:04.015]     do.call(function(...) {
[16:11:04.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.015]             on.exit(options(oopts), add = TRUE)
[16:11:04.015]         }
[16:11:04.015]         {
[16:11:04.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.015]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.015]             })
[16:11:04.015]         }
[16:11:04.015]     }, args = future.call.arguments)
[16:11:04.015] }
[16:11:04.016] Tweak future expression to call with '...' arguments ... DONE
[16:11:04.016] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.016] - packages: [1] ‘future.apply’
[16:11:04.016] getGlobalsAndPackages() ... DONE
[16:11:04.017] run() for ‘Future’ ...
[16:11:04.017] - state: ‘created’
[16:11:04.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:04.031] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:04.031]   - Field: ‘node’
[16:11:04.031]   - Field: ‘label’
[16:11:04.031]   - Field: ‘local’
[16:11:04.031]   - Field: ‘owner’
[16:11:04.031]   - Field: ‘envir’
[16:11:04.031]   - Field: ‘workers’
[16:11:04.032]   - Field: ‘packages’
[16:11:04.032]   - Field: ‘gc’
[16:11:04.032]   - Field: ‘conditions’
[16:11:04.032]   - Field: ‘persistent’
[16:11:04.032]   - Field: ‘expr’
[16:11:04.032]   - Field: ‘uuid’
[16:11:04.032]   - Field: ‘seed’
[16:11:04.032]   - Field: ‘version’
[16:11:04.032]   - Field: ‘result’
[16:11:04.032]   - Field: ‘asynchronous’
[16:11:04.033]   - Field: ‘calls’
[16:11:04.033]   - Field: ‘globals’
[16:11:04.033]   - Field: ‘stdout’
[16:11:04.033]   - Field: ‘earlySignal’
[16:11:04.033]   - Field: ‘lazy’
[16:11:04.033]   - Field: ‘state’
[16:11:04.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:04.033] - Launch lazy future ...
[16:11:04.034] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:04.034] Packages needed by future strategies (n = 0): <none>
[16:11:04.034] {
[16:11:04.034]     {
[16:11:04.034]         {
[16:11:04.034]             ...future.startTime <- base::Sys.time()
[16:11:04.034]             {
[16:11:04.034]                 {
[16:11:04.034]                   {
[16:11:04.034]                     {
[16:11:04.034]                       {
[16:11:04.034]                         base::local({
[16:11:04.034]                           has_future <- base::requireNamespace("future", 
[16:11:04.034]                             quietly = TRUE)
[16:11:04.034]                           if (has_future) {
[16:11:04.034]                             ns <- base::getNamespace("future")
[16:11:04.034]                             version <- ns[[".package"]][["version"]]
[16:11:04.034]                             if (is.null(version)) 
[16:11:04.034]                               version <- utils::packageVersion("future")
[16:11:04.034]                           }
[16:11:04.034]                           else {
[16:11:04.034]                             version <- NULL
[16:11:04.034]                           }
[16:11:04.034]                           if (!has_future || version < "1.8.0") {
[16:11:04.034]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:04.034]                               "", base::R.version$version.string), 
[16:11:04.034]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:04.034]                                 base::R.version$platform, 8 * 
[16:11:04.034]                                   base::.Machine$sizeof.pointer), 
[16:11:04.034]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:04.034]                                 "release", "version")], collapse = " "), 
[16:11:04.034]                               hostname = base::Sys.info()[["nodename"]])
[16:11:04.034]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:04.034]                               info)
[16:11:04.034]                             info <- base::paste(info, collapse = "; ")
[16:11:04.034]                             if (!has_future) {
[16:11:04.034]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:04.034]                                 info)
[16:11:04.034]                             }
[16:11:04.034]                             else {
[16:11:04.034]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:04.034]                                 info, version)
[16:11:04.034]                             }
[16:11:04.034]                             base::stop(msg)
[16:11:04.034]                           }
[16:11:04.034]                         })
[16:11:04.034]                       }
[16:11:04.034]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:04.034]                       base::options(mc.cores = 1L)
[16:11:04.034]                     }
[16:11:04.034]                     base::local({
[16:11:04.034]                       for (pkg in "future.apply") {
[16:11:04.034]                         base::loadNamespace(pkg)
[16:11:04.034]                         base::library(pkg, character.only = TRUE)
[16:11:04.034]                       }
[16:11:04.034]                     })
[16:11:04.034]                   }
[16:11:04.034]                   options(future.plan = NULL)
[16:11:04.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:04.034]                 }
[16:11:04.034]                 ...future.workdir <- getwd()
[16:11:04.034]             }
[16:11:04.034]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:04.034]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:04.034]         }
[16:11:04.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:04.034]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:04.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:04.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:04.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:04.034]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:04.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:04.034]             base::names(...future.oldOptions))
[16:11:04.034]     }
[16:11:04.034]     if (FALSE) {
[16:11:04.034]     }
[16:11:04.034]     else {
[16:11:04.034]         if (TRUE) {
[16:11:04.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:04.034]                 open = "w")
[16:11:04.034]         }
[16:11:04.034]         else {
[16:11:04.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:04.034]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:04.034]         }
[16:11:04.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:04.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:04.034]             base::sink(type = "output", split = FALSE)
[16:11:04.034]             base::close(...future.stdout)
[16:11:04.034]         }, add = TRUE)
[16:11:04.034]     }
[16:11:04.034]     ...future.frame <- base::sys.nframe()
[16:11:04.034]     ...future.conditions <- base::list()
[16:11:04.034]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:04.034]     if (FALSE) {
[16:11:04.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:04.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:04.034]     }
[16:11:04.034]     ...future.result <- base::tryCatch({
[16:11:04.034]         base::withCallingHandlers({
[16:11:04.034]             ...future.value <- base::withVisible(base::local({
[16:11:04.034]                 ...future.makeSendCondition <- local({
[16:11:04.034]                   sendCondition <- NULL
[16:11:04.034]                   function(frame = 1L) {
[16:11:04.034]                     if (is.function(sendCondition)) 
[16:11:04.034]                       return(sendCondition)
[16:11:04.034]                     ns <- getNamespace("parallel")
[16:11:04.034]                     if (exists("sendData", mode = "function", 
[16:11:04.034]                       envir = ns)) {
[16:11:04.034]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:04.034]                         envir = ns)
[16:11:04.034]                       envir <- sys.frame(frame)
[16:11:04.034]                       master <- NULL
[16:11:04.034]                       while (!identical(envir, .GlobalEnv) && 
[16:11:04.034]                         !identical(envir, emptyenv())) {
[16:11:04.034]                         if (exists("master", mode = "list", envir = envir, 
[16:11:04.034]                           inherits = FALSE)) {
[16:11:04.034]                           master <- get("master", mode = "list", 
[16:11:04.034]                             envir = envir, inherits = FALSE)
[16:11:04.034]                           if (inherits(master, c("SOCKnode", 
[16:11:04.034]                             "SOCK0node"))) {
[16:11:04.034]                             sendCondition <<- function(cond) {
[16:11:04.034]                               data <- list(type = "VALUE", value = cond, 
[16:11:04.034]                                 success = TRUE)
[16:11:04.034]                               parallel_sendData(master, data)
[16:11:04.034]                             }
[16:11:04.034]                             return(sendCondition)
[16:11:04.034]                           }
[16:11:04.034]                         }
[16:11:04.034]                         frame <- frame + 1L
[16:11:04.034]                         envir <- sys.frame(frame)
[16:11:04.034]                       }
[16:11:04.034]                     }
[16:11:04.034]                     sendCondition <<- function(cond) NULL
[16:11:04.034]                   }
[16:11:04.034]                 })
[16:11:04.034]                 withCallingHandlers({
[16:11:04.034]                   {
[16:11:04.034]                     do.call(function(...) {
[16:11:04.034]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.034]                       if (!identical(...future.globals.maxSize.org, 
[16:11:04.034]                         ...future.globals.maxSize)) {
[16:11:04.034]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.034]                         on.exit(options(oopts), add = TRUE)
[16:11:04.034]                       }
[16:11:04.034]                       {
[16:11:04.034]                         lapply(seq_along(...future.elements_ii), 
[16:11:04.034]                           FUN = function(jj) {
[16:11:04.034]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.034]                             ...future.FUN(...future.X_jj, ...)
[16:11:04.034]                           })
[16:11:04.034]                       }
[16:11:04.034]                     }, args = future.call.arguments)
[16:11:04.034]                   }
[16:11:04.034]                 }, immediateCondition = function(cond) {
[16:11:04.034]                   sendCondition <- ...future.makeSendCondition()
[16:11:04.034]                   sendCondition(cond)
[16:11:04.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.034]                   {
[16:11:04.034]                     inherits <- base::inherits
[16:11:04.034]                     invokeRestart <- base::invokeRestart
[16:11:04.034]                     is.null <- base::is.null
[16:11:04.034]                     muffled <- FALSE
[16:11:04.034]                     if (inherits(cond, "message")) {
[16:11:04.034]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:04.034]                       if (muffled) 
[16:11:04.034]                         invokeRestart("muffleMessage")
[16:11:04.034]                     }
[16:11:04.034]                     else if (inherits(cond, "warning")) {
[16:11:04.034]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:04.034]                       if (muffled) 
[16:11:04.034]                         invokeRestart("muffleWarning")
[16:11:04.034]                     }
[16:11:04.034]                     else if (inherits(cond, "condition")) {
[16:11:04.034]                       if (!is.null(pattern)) {
[16:11:04.034]                         computeRestarts <- base::computeRestarts
[16:11:04.034]                         grepl <- base::grepl
[16:11:04.034]                         restarts <- computeRestarts(cond)
[16:11:04.034]                         for (restart in restarts) {
[16:11:04.034]                           name <- restart$name
[16:11:04.034]                           if (is.null(name)) 
[16:11:04.034]                             next
[16:11:04.034]                           if (!grepl(pattern, name)) 
[16:11:04.034]                             next
[16:11:04.034]                           invokeRestart(restart)
[16:11:04.034]                           muffled <- TRUE
[16:11:04.034]                           break
[16:11:04.034]                         }
[16:11:04.034]                       }
[16:11:04.034]                     }
[16:11:04.034]                     invisible(muffled)
[16:11:04.034]                   }
[16:11:04.034]                   muffleCondition(cond)
[16:11:04.034]                 })
[16:11:04.034]             }))
[16:11:04.034]             future::FutureResult(value = ...future.value$value, 
[16:11:04.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.034]                   ...future.rng), globalenv = if (FALSE) 
[16:11:04.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:04.034]                     ...future.globalenv.names))
[16:11:04.034]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:04.034]         }, condition = base::local({
[16:11:04.034]             c <- base::c
[16:11:04.034]             inherits <- base::inherits
[16:11:04.034]             invokeRestart <- base::invokeRestart
[16:11:04.034]             length <- base::length
[16:11:04.034]             list <- base::list
[16:11:04.034]             seq.int <- base::seq.int
[16:11:04.034]             signalCondition <- base::signalCondition
[16:11:04.034]             sys.calls <- base::sys.calls
[16:11:04.034]             `[[` <- base::`[[`
[16:11:04.034]             `+` <- base::`+`
[16:11:04.034]             `<<-` <- base::`<<-`
[16:11:04.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:04.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:04.034]                   3L)]
[16:11:04.034]             }
[16:11:04.034]             function(cond) {
[16:11:04.034]                 is_error <- inherits(cond, "error")
[16:11:04.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:04.034]                   NULL)
[16:11:04.034]                 if (is_error) {
[16:11:04.034]                   sessionInformation <- function() {
[16:11:04.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:04.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:04.034]                       search = base::search(), system = base::Sys.info())
[16:11:04.034]                   }
[16:11:04.034]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:04.034]                     cond$call), session = sessionInformation(), 
[16:11:04.034]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:04.034]                   signalCondition(cond)
[16:11:04.034]                 }
[16:11:04.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:04.034]                 "immediateCondition"))) {
[16:11:04.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:04.034]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:04.034]                   if (TRUE && !signal) {
[16:11:04.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.034]                     {
[16:11:04.034]                       inherits <- base::inherits
[16:11:04.034]                       invokeRestart <- base::invokeRestart
[16:11:04.034]                       is.null <- base::is.null
[16:11:04.034]                       muffled <- FALSE
[16:11:04.034]                       if (inherits(cond, "message")) {
[16:11:04.034]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.034]                         if (muffled) 
[16:11:04.034]                           invokeRestart("muffleMessage")
[16:11:04.034]                       }
[16:11:04.034]                       else if (inherits(cond, "warning")) {
[16:11:04.034]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.034]                         if (muffled) 
[16:11:04.034]                           invokeRestart("muffleWarning")
[16:11:04.034]                       }
[16:11:04.034]                       else if (inherits(cond, "condition")) {
[16:11:04.034]                         if (!is.null(pattern)) {
[16:11:04.034]                           computeRestarts <- base::computeRestarts
[16:11:04.034]                           grepl <- base::grepl
[16:11:04.034]                           restarts <- computeRestarts(cond)
[16:11:04.034]                           for (restart in restarts) {
[16:11:04.034]                             name <- restart$name
[16:11:04.034]                             if (is.null(name)) 
[16:11:04.034]                               next
[16:11:04.034]                             if (!grepl(pattern, name)) 
[16:11:04.034]                               next
[16:11:04.034]                             invokeRestart(restart)
[16:11:04.034]                             muffled <- TRUE
[16:11:04.034]                             break
[16:11:04.034]                           }
[16:11:04.034]                         }
[16:11:04.034]                       }
[16:11:04.034]                       invisible(muffled)
[16:11:04.034]                     }
[16:11:04.034]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.034]                   }
[16:11:04.034]                 }
[16:11:04.034]                 else {
[16:11:04.034]                   if (TRUE) {
[16:11:04.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.034]                     {
[16:11:04.034]                       inherits <- base::inherits
[16:11:04.034]                       invokeRestart <- base::invokeRestart
[16:11:04.034]                       is.null <- base::is.null
[16:11:04.034]                       muffled <- FALSE
[16:11:04.034]                       if (inherits(cond, "message")) {
[16:11:04.034]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.034]                         if (muffled) 
[16:11:04.034]                           invokeRestart("muffleMessage")
[16:11:04.034]                       }
[16:11:04.034]                       else if (inherits(cond, "warning")) {
[16:11:04.034]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.034]                         if (muffled) 
[16:11:04.034]                           invokeRestart("muffleWarning")
[16:11:04.034]                       }
[16:11:04.034]                       else if (inherits(cond, "condition")) {
[16:11:04.034]                         if (!is.null(pattern)) {
[16:11:04.034]                           computeRestarts <- base::computeRestarts
[16:11:04.034]                           grepl <- base::grepl
[16:11:04.034]                           restarts <- computeRestarts(cond)
[16:11:04.034]                           for (restart in restarts) {
[16:11:04.034]                             name <- restart$name
[16:11:04.034]                             if (is.null(name)) 
[16:11:04.034]                               next
[16:11:04.034]                             if (!grepl(pattern, name)) 
[16:11:04.034]                               next
[16:11:04.034]                             invokeRestart(restart)
[16:11:04.034]                             muffled <- TRUE
[16:11:04.034]                             break
[16:11:04.034]                           }
[16:11:04.034]                         }
[16:11:04.034]                       }
[16:11:04.034]                       invisible(muffled)
[16:11:04.034]                     }
[16:11:04.034]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.034]                   }
[16:11:04.034]                 }
[16:11:04.034]             }
[16:11:04.034]         }))
[16:11:04.034]     }, error = function(ex) {
[16:11:04.034]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:04.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.034]                 ...future.rng), started = ...future.startTime, 
[16:11:04.034]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:04.034]             version = "1.8"), class = "FutureResult")
[16:11:04.034]     }, finally = {
[16:11:04.034]         if (!identical(...future.workdir, getwd())) 
[16:11:04.034]             setwd(...future.workdir)
[16:11:04.034]         {
[16:11:04.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:04.034]                 ...future.oldOptions$nwarnings <- NULL
[16:11:04.034]             }
[16:11:04.034]             base::options(...future.oldOptions)
[16:11:04.034]             if (.Platform$OS.type == "windows") {
[16:11:04.034]                 old_names <- names(...future.oldEnvVars)
[16:11:04.034]                 envs <- base::Sys.getenv()
[16:11:04.034]                 names <- names(envs)
[16:11:04.034]                 common <- intersect(names, old_names)
[16:11:04.034]                 added <- setdiff(names, old_names)
[16:11:04.034]                 removed <- setdiff(old_names, names)
[16:11:04.034]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:04.034]                   envs[common]]
[16:11:04.034]                 NAMES <- toupper(changed)
[16:11:04.034]                 args <- list()
[16:11:04.034]                 for (kk in seq_along(NAMES)) {
[16:11:04.034]                   name <- changed[[kk]]
[16:11:04.034]                   NAME <- NAMES[[kk]]
[16:11:04.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.034]                     next
[16:11:04.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.034]                 }
[16:11:04.034]                 NAMES <- toupper(added)
[16:11:04.034]                 for (kk in seq_along(NAMES)) {
[16:11:04.034]                   name <- added[[kk]]
[16:11:04.034]                   NAME <- NAMES[[kk]]
[16:11:04.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.034]                     next
[16:11:04.034]                   args[[name]] <- ""
[16:11:04.034]                 }
[16:11:04.034]                 NAMES <- toupper(removed)
[16:11:04.034]                 for (kk in seq_along(NAMES)) {
[16:11:04.034]                   name <- removed[[kk]]
[16:11:04.034]                   NAME <- NAMES[[kk]]
[16:11:04.034]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.034]                     next
[16:11:04.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.034]                 }
[16:11:04.034]                 if (length(args) > 0) 
[16:11:04.034]                   base::do.call(base::Sys.setenv, args = args)
[16:11:04.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:04.034]             }
[16:11:04.034]             else {
[16:11:04.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:04.034]             }
[16:11:04.034]             {
[16:11:04.034]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:04.034]                   0L) {
[16:11:04.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:04.034]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:04.034]                   base::options(opts)
[16:11:04.034]                 }
[16:11:04.034]                 {
[16:11:04.034]                   {
[16:11:04.034]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:04.034]                     NULL
[16:11:04.034]                   }
[16:11:04.034]                   options(future.plan = NULL)
[16:11:04.034]                   if (is.na(NA_character_)) 
[16:11:04.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:04.034]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:04.034]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:04.034]                     envir = parent.frame()) 
[16:11:04.034]                   {
[16:11:04.034]                     if (is.function(workers)) 
[16:11:04.034]                       workers <- workers()
[16:11:04.034]                     workers <- structure(as.integer(workers), 
[16:11:04.034]                       class = class(workers))
[16:11:04.034]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:04.034]                       workers >= 1)
[16:11:04.034]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:04.034]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:04.034]                     }
[16:11:04.034]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:04.034]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:04.034]                       envir = envir)
[16:11:04.034]                     if (!future$lazy) 
[16:11:04.034]                       future <- run(future)
[16:11:04.034]                     invisible(future)
[16:11:04.034]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:04.034]                 }
[16:11:04.034]             }
[16:11:04.034]         }
[16:11:04.034]     })
[16:11:04.034]     if (TRUE) {
[16:11:04.034]         base::sink(type = "output", split = FALSE)
[16:11:04.034]         if (TRUE) {
[16:11:04.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:04.034]         }
[16:11:04.034]         else {
[16:11:04.034]             ...future.result["stdout"] <- base::list(NULL)
[16:11:04.034]         }
[16:11:04.034]         base::close(...future.stdout)
[16:11:04.034]         ...future.stdout <- NULL
[16:11:04.034]     }
[16:11:04.034]     ...future.result$conditions <- ...future.conditions
[16:11:04.034]     ...future.result$finished <- base::Sys.time()
[16:11:04.034]     ...future.result
[16:11:04.034] }
[16:11:04.037] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[16:11:04.037] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:04.080] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:04.080] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[16:11:04.080] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[16:11:04.081] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:04.081] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:04.081] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:04.124] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:04.124] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:04.168] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:04.168] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:04.168] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.169] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:04.169] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:04.169] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:04.170] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.170] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:11:04.170] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:11:04.170] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:04.171] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.171] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:04.171] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.171] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[16:11:04.172] MultisessionFuture started
[16:11:04.172] - Launch lazy future ... done
[16:11:04.172] run() for ‘MultisessionFuture’ ... done
[16:11:04.172] Created future:
[16:11:04.172] MultisessionFuture:
[16:11:04.172] Label: ‘future_vapply-2’
[16:11:04.172] Expression:
[16:11:04.172] {
[16:11:04.172]     do.call(function(...) {
[16:11:04.172]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.172]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.172]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.172]             on.exit(options(oopts), add = TRUE)
[16:11:04.172]         }
[16:11:04.172]         {
[16:11:04.172]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.172]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.172]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.172]             })
[16:11:04.172]         }
[16:11:04.172]     }, args = future.call.arguments)
[16:11:04.172] }
[16:11:04.172] Lazy evaluation: FALSE
[16:11:04.172] Asynchronous evaluation: TRUE
[16:11:04.172] Local evaluation: TRUE
[16:11:04.172] Environment: R_GlobalEnv
[16:11:04.172] Capture standard output: TRUE
[16:11:04.172] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:04.172] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:04.172] Packages: 1 packages (‘future.apply’)
[16:11:04.172] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:04.172] Resolved: FALSE
[16:11:04.172] Value: <not collected>
[16:11:04.172] Conditions captured: <none>
[16:11:04.172] Early signaling: FALSE
[16:11:04.172] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:04.172] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.184] Chunk #2 of 2 ... DONE
[16:11:04.184] Launching 2 futures (chunks) ... DONE
[16:11:04.184] Resolving 2 futures (chunks) ...
[16:11:04.184] resolve() on list ...
[16:11:04.184]  recursive: 0
[16:11:04.185]  length: 2
[16:11:04.185] 
[16:11:04.185] receiveMessageFromWorker() for ClusterFuture ...
[16:11:04.185] - Validating connection of MultisessionFuture
[16:11:04.185] - received message: FutureResult
[16:11:04.186] - Received FutureResult
[16:11:04.186] - Erased future from FutureRegistry
[16:11:04.186] result() for ClusterFuture ...
[16:11:04.186] - result already collected: FutureResult
[16:11:04.186] result() for ClusterFuture ... done
[16:11:04.186] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:04.186] Future #1
[16:11:04.186] result() for ClusterFuture ...
[16:11:04.186] - result already collected: FutureResult
[16:11:04.186] result() for ClusterFuture ... done
[16:11:04.186] result() for ClusterFuture ...
[16:11:04.187] - result already collected: FutureResult
[16:11:04.187] result() for ClusterFuture ... done
[16:11:04.187] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:04.187] - nx: 2
[16:11:04.187] - relay: TRUE
[16:11:04.187] - stdout: TRUE
[16:11:04.187] - signal: TRUE
[16:11:04.187] - resignal: FALSE
[16:11:04.187] - force: TRUE
[16:11:04.187] - relayed: [n=2] FALSE, FALSE
[16:11:04.187] - queued futures: [n=2] FALSE, FALSE
[16:11:04.187]  - until=1
[16:11:04.188]  - relaying element #1
[16:11:04.188] result() for ClusterFuture ...
[16:11:04.188] - result already collected: FutureResult
[16:11:04.188] result() for ClusterFuture ... done
[16:11:04.188] result() for ClusterFuture ...
[16:11:04.188] - result already collected: FutureResult
[16:11:04.188] result() for ClusterFuture ... done
[16:11:04.188] result() for ClusterFuture ...
[16:11:04.188] - result already collected: FutureResult
[16:11:04.188] result() for ClusterFuture ... done
[16:11:04.188] result() for ClusterFuture ...
[16:11:04.189] - result already collected: FutureResult
[16:11:04.189] result() for ClusterFuture ... done
[16:11:04.189] - relayed: [n=2] TRUE, FALSE
[16:11:04.189] - queued futures: [n=2] TRUE, FALSE
[16:11:04.189] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:04.189]  length: 1 (resolved future 1)
[16:11:04.231] receiveMessageFromWorker() for ClusterFuture ...
[16:11:04.231] - Validating connection of MultisessionFuture
[16:11:04.231] - received message: FutureResult
[16:11:04.231] - Received FutureResult
[16:11:04.231] - Erased future from FutureRegistry
[16:11:04.231] result() for ClusterFuture ...
[16:11:04.231] - result already collected: FutureResult
[16:11:04.231] result() for ClusterFuture ... done
[16:11:04.232] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:04.232] Future #2
[16:11:04.232] result() for ClusterFuture ...
[16:11:04.232] - result already collected: FutureResult
[16:11:04.232] result() for ClusterFuture ... done
[16:11:04.232] result() for ClusterFuture ...
[16:11:04.232] - result already collected: FutureResult
[16:11:04.232] result() for ClusterFuture ... done
[16:11:04.232] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:04.232] - nx: 2
[16:11:04.233] - relay: TRUE
[16:11:04.233] - stdout: TRUE
[16:11:04.233] - signal: TRUE
[16:11:04.233] - resignal: FALSE
[16:11:04.233] - force: TRUE
[16:11:04.233] - relayed: [n=2] TRUE, FALSE
[16:11:04.233] - queued futures: [n=2] TRUE, FALSE
[16:11:04.233]  - until=2
[16:11:04.233]  - relaying element #2
[16:11:04.233] result() for ClusterFuture ...
[16:11:04.233] - result already collected: FutureResult
[16:11:04.233] result() for ClusterFuture ... done
[16:11:04.234] result() for ClusterFuture ...
[16:11:04.234] - result already collected: FutureResult
[16:11:04.234] result() for ClusterFuture ... done
[16:11:04.234] result() for ClusterFuture ...
[16:11:04.234] - result already collected: FutureResult
[16:11:04.234] result() for ClusterFuture ... done
[16:11:04.234] result() for ClusterFuture ...
[16:11:04.234] - result already collected: FutureResult
[16:11:04.234] result() for ClusterFuture ... done
[16:11:04.234] - relayed: [n=2] TRUE, TRUE
[16:11:04.234] - queued futures: [n=2] TRUE, TRUE
[16:11:04.235] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:04.235]  length: 0 (resolved future 2)
[16:11:04.235] Relaying remaining futures
[16:11:04.235] signalConditionsASAP(NULL, pos=0) ...
[16:11:04.235] - nx: 2
[16:11:04.235] - relay: TRUE
[16:11:04.235] - stdout: TRUE
[16:11:04.235] - signal: TRUE
[16:11:04.235] - resignal: FALSE
[16:11:04.235] - force: TRUE
[16:11:04.235] - relayed: [n=2] TRUE, TRUE
[16:11:04.235] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:04.236] - relayed: [n=2] TRUE, TRUE
[16:11:04.236] - queued futures: [n=2] TRUE, TRUE
[16:11:04.236] signalConditionsASAP(NULL, pos=0) ... done
[16:11:04.236] resolve() on list ... DONE
[16:11:04.236] result() for ClusterFuture ...
[16:11:04.236] - result already collected: FutureResult
[16:11:04.236] result() for ClusterFuture ... done
[16:11:04.236] result() for ClusterFuture ...
[16:11:04.236] - result already collected: FutureResult
[16:11:04.236] result() for ClusterFuture ... done
[16:11:04.236] result() for ClusterFuture ...
[16:11:04.237] - result already collected: FutureResult
[16:11:04.237] result() for ClusterFuture ... done
[16:11:04.237] result() for ClusterFuture ...
[16:11:04.237] - result already collected: FutureResult
[16:11:04.237] result() for ClusterFuture ... done
[16:11:04.237]  - Number of value chunks collected: 2
[16:11:04.237] Resolving 2 futures (chunks) ... DONE
[16:11:04.237] Reducing values from 2 chunks ...
[16:11:04.237]  - Number of values collected after concatenation: 10
[16:11:04.237]  - Number of values expected: 10
[16:11:04.237] Reducing values from 2 chunks ... DONE
[16:11:04.238] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[16:11:04.238] future_lapply() ...
[16:11:04.244] Number of chunks: 2
[16:11:04.244] getGlobalsAndPackagesXApply() ...
[16:11:04.244]  - future.globals: TRUE
[16:11:04.244] getGlobalsAndPackages() ...
[16:11:04.244] Searching for globals...
[16:11:04.247] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[16:11:04.248] Searching for globals ... DONE
[16:11:04.248] Resolving globals: FALSE
[16:11:04.249] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[16:11:04.249] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:04.249] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:04.249] - packages: [1] ‘future.apply’
[16:11:04.249] getGlobalsAndPackages() ... DONE
[16:11:04.249]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:04.250]  - needed namespaces: [n=1] ‘future.apply’
[16:11:04.250] Finding globals ... DONE
[16:11:04.250]  - use_args: TRUE
[16:11:04.250]  - Getting '...' globals ...
[16:11:04.250] resolve() on list ...
[16:11:04.250]  recursive: 0
[16:11:04.250]  length: 1
[16:11:04.250]  elements: ‘...’
[16:11:04.250]  length: 0 (resolved future 1)
[16:11:04.251] resolve() on list ... DONE
[16:11:04.251]    - '...' content: [n=0] 
[16:11:04.251] List of 1
[16:11:04.251]  $ ...: list()
[16:11:04.251]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:04.251]  - attr(*, "where")=List of 1
[16:11:04.251]   ..$ ...:<environment: 0x561e8b5dec40> 
[16:11:04.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:04.251]  - attr(*, "resolved")= logi TRUE
[16:11:04.251]  - attr(*, "total_size")= num NA
[16:11:04.253]  - Getting '...' globals ... DONE
[16:11:04.253] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:04.254] List of 8
[16:11:04.254]  $ ...future.FUN:function (x, ...)  
[16:11:04.254]  $ x_FUN        :function (x)  
[16:11:04.254]  $ times        : int 0
[16:11:04.254]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:04.254]  $ stop_if_not  :function (...)  
[16:11:04.254]  $ dim          : NULL
[16:11:04.254]  $ valid_types  : chr [1:2] "logical" "integer"
[16:11:04.254]  $ ...          : list()
[16:11:04.254]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:04.254]  - attr(*, "where")=List of 8
[16:11:04.254]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:04.254]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:04.254]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:04.254]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:04.254]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:04.254]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:04.254]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:04.254]   ..$ ...          :<environment: 0x561e8b5dec40> 
[16:11:04.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:04.254]  - attr(*, "resolved")= logi FALSE
[16:11:04.254]  - attr(*, "total_size")= num 95400
[16:11:04.259] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:04.259] getGlobalsAndPackagesXApply() ... DONE
[16:11:04.259] Number of futures (= number of chunks): 2
[16:11:04.259] Launching 2 futures (chunks) ...
[16:11:04.259] Chunk #1 of 2 ...
[16:11:04.260]  - Finding globals in 'X' for chunk #1 ...
[16:11:04.260] getGlobalsAndPackages() ...
[16:11:04.260] Searching for globals...
[16:11:04.260] 
[16:11:04.260] Searching for globals ... DONE
[16:11:04.260] - globals: [0] <none>
[16:11:04.260] getGlobalsAndPackages() ... DONE
[16:11:04.260]    + additional globals found: [n=0] 
[16:11:04.260]    + additional namespaces needed: [n=0] 
[16:11:04.260]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:04.261]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:04.261]  - seeds: <none>
[16:11:04.261] getGlobalsAndPackages() ...
[16:11:04.261] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.261] Resolving globals: FALSE
[16:11:04.261] Tweak future expression to call with '...' arguments ...
[16:11:04.261] {
[16:11:04.261]     do.call(function(...) {
[16:11:04.261]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.261]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.261]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.261]             on.exit(options(oopts), add = TRUE)
[16:11:04.261]         }
[16:11:04.261]         {
[16:11:04.261]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.261]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.261]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.261]             })
[16:11:04.261]         }
[16:11:04.261]     }, args = future.call.arguments)
[16:11:04.261] }
[16:11:04.261] Tweak future expression to call with '...' arguments ... DONE
[16:11:04.262] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.262] - packages: [1] ‘future.apply’
[16:11:04.262] getGlobalsAndPackages() ... DONE
[16:11:04.263] run() for ‘Future’ ...
[16:11:04.263] - state: ‘created’
[16:11:04.263] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:04.279] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:04.279]   - Field: ‘node’
[16:11:04.279]   - Field: ‘label’
[16:11:04.280]   - Field: ‘local’
[16:11:04.280]   - Field: ‘owner’
[16:11:04.280]   - Field: ‘envir’
[16:11:04.280]   - Field: ‘workers’
[16:11:04.280]   - Field: ‘packages’
[16:11:04.280]   - Field: ‘gc’
[16:11:04.280]   - Field: ‘conditions’
[16:11:04.280]   - Field: ‘persistent’
[16:11:04.280]   - Field: ‘expr’
[16:11:04.280]   - Field: ‘uuid’
[16:11:04.281]   - Field: ‘seed’
[16:11:04.281]   - Field: ‘version’
[16:11:04.281]   - Field: ‘result’
[16:11:04.281]   - Field: ‘asynchronous’
[16:11:04.281]   - Field: ‘calls’
[16:11:04.281]   - Field: ‘globals’
[16:11:04.281]   - Field: ‘stdout’
[16:11:04.281]   - Field: ‘earlySignal’
[16:11:04.281]   - Field: ‘lazy’
[16:11:04.281]   - Field: ‘state’
[16:11:04.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:04.281] - Launch lazy future ...
[16:11:04.282] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:04.282] Packages needed by future strategies (n = 0): <none>
[16:11:04.282] {
[16:11:04.282]     {
[16:11:04.282]         {
[16:11:04.282]             ...future.startTime <- base::Sys.time()
[16:11:04.282]             {
[16:11:04.282]                 {
[16:11:04.282]                   {
[16:11:04.282]                     {
[16:11:04.282]                       {
[16:11:04.282]                         base::local({
[16:11:04.282]                           has_future <- base::requireNamespace("future", 
[16:11:04.282]                             quietly = TRUE)
[16:11:04.282]                           if (has_future) {
[16:11:04.282]                             ns <- base::getNamespace("future")
[16:11:04.282]                             version <- ns[[".package"]][["version"]]
[16:11:04.282]                             if (is.null(version)) 
[16:11:04.282]                               version <- utils::packageVersion("future")
[16:11:04.282]                           }
[16:11:04.282]                           else {
[16:11:04.282]                             version <- NULL
[16:11:04.282]                           }
[16:11:04.282]                           if (!has_future || version < "1.8.0") {
[16:11:04.282]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:04.282]                               "", base::R.version$version.string), 
[16:11:04.282]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:04.282]                                 base::R.version$platform, 8 * 
[16:11:04.282]                                   base::.Machine$sizeof.pointer), 
[16:11:04.282]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:04.282]                                 "release", "version")], collapse = " "), 
[16:11:04.282]                               hostname = base::Sys.info()[["nodename"]])
[16:11:04.282]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:04.282]                               info)
[16:11:04.282]                             info <- base::paste(info, collapse = "; ")
[16:11:04.282]                             if (!has_future) {
[16:11:04.282]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:04.282]                                 info)
[16:11:04.282]                             }
[16:11:04.282]                             else {
[16:11:04.282]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:04.282]                                 info, version)
[16:11:04.282]                             }
[16:11:04.282]                             base::stop(msg)
[16:11:04.282]                           }
[16:11:04.282]                         })
[16:11:04.282]                       }
[16:11:04.282]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:04.282]                       base::options(mc.cores = 1L)
[16:11:04.282]                     }
[16:11:04.282]                     base::local({
[16:11:04.282]                       for (pkg in "future.apply") {
[16:11:04.282]                         base::loadNamespace(pkg)
[16:11:04.282]                         base::library(pkg, character.only = TRUE)
[16:11:04.282]                       }
[16:11:04.282]                     })
[16:11:04.282]                   }
[16:11:04.282]                   options(future.plan = NULL)
[16:11:04.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:04.282]                 }
[16:11:04.282]                 ...future.workdir <- getwd()
[16:11:04.282]             }
[16:11:04.282]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:04.282]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:04.282]         }
[16:11:04.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:04.282]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:04.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:04.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:04.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:04.282]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:04.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:04.282]             base::names(...future.oldOptions))
[16:11:04.282]     }
[16:11:04.282]     if (FALSE) {
[16:11:04.282]     }
[16:11:04.282]     else {
[16:11:04.282]         if (TRUE) {
[16:11:04.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:04.282]                 open = "w")
[16:11:04.282]         }
[16:11:04.282]         else {
[16:11:04.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:04.282]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:04.282]         }
[16:11:04.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:04.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:04.282]             base::sink(type = "output", split = FALSE)
[16:11:04.282]             base::close(...future.stdout)
[16:11:04.282]         }, add = TRUE)
[16:11:04.282]     }
[16:11:04.282]     ...future.frame <- base::sys.nframe()
[16:11:04.282]     ...future.conditions <- base::list()
[16:11:04.282]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:04.282]     if (FALSE) {
[16:11:04.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:04.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:04.282]     }
[16:11:04.282]     ...future.result <- base::tryCatch({
[16:11:04.282]         base::withCallingHandlers({
[16:11:04.282]             ...future.value <- base::withVisible(base::local({
[16:11:04.282]                 ...future.makeSendCondition <- local({
[16:11:04.282]                   sendCondition <- NULL
[16:11:04.282]                   function(frame = 1L) {
[16:11:04.282]                     if (is.function(sendCondition)) 
[16:11:04.282]                       return(sendCondition)
[16:11:04.282]                     ns <- getNamespace("parallel")
[16:11:04.282]                     if (exists("sendData", mode = "function", 
[16:11:04.282]                       envir = ns)) {
[16:11:04.282]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:04.282]                         envir = ns)
[16:11:04.282]                       envir <- sys.frame(frame)
[16:11:04.282]                       master <- NULL
[16:11:04.282]                       while (!identical(envir, .GlobalEnv) && 
[16:11:04.282]                         !identical(envir, emptyenv())) {
[16:11:04.282]                         if (exists("master", mode = "list", envir = envir, 
[16:11:04.282]                           inherits = FALSE)) {
[16:11:04.282]                           master <- get("master", mode = "list", 
[16:11:04.282]                             envir = envir, inherits = FALSE)
[16:11:04.282]                           if (inherits(master, c("SOCKnode", 
[16:11:04.282]                             "SOCK0node"))) {
[16:11:04.282]                             sendCondition <<- function(cond) {
[16:11:04.282]                               data <- list(type = "VALUE", value = cond, 
[16:11:04.282]                                 success = TRUE)
[16:11:04.282]                               parallel_sendData(master, data)
[16:11:04.282]                             }
[16:11:04.282]                             return(sendCondition)
[16:11:04.282]                           }
[16:11:04.282]                         }
[16:11:04.282]                         frame <- frame + 1L
[16:11:04.282]                         envir <- sys.frame(frame)
[16:11:04.282]                       }
[16:11:04.282]                     }
[16:11:04.282]                     sendCondition <<- function(cond) NULL
[16:11:04.282]                   }
[16:11:04.282]                 })
[16:11:04.282]                 withCallingHandlers({
[16:11:04.282]                   {
[16:11:04.282]                     do.call(function(...) {
[16:11:04.282]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.282]                       if (!identical(...future.globals.maxSize.org, 
[16:11:04.282]                         ...future.globals.maxSize)) {
[16:11:04.282]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.282]                         on.exit(options(oopts), add = TRUE)
[16:11:04.282]                       }
[16:11:04.282]                       {
[16:11:04.282]                         lapply(seq_along(...future.elements_ii), 
[16:11:04.282]                           FUN = function(jj) {
[16:11:04.282]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.282]                             ...future.FUN(...future.X_jj, ...)
[16:11:04.282]                           })
[16:11:04.282]                       }
[16:11:04.282]                     }, args = future.call.arguments)
[16:11:04.282]                   }
[16:11:04.282]                 }, immediateCondition = function(cond) {
[16:11:04.282]                   sendCondition <- ...future.makeSendCondition()
[16:11:04.282]                   sendCondition(cond)
[16:11:04.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.282]                   {
[16:11:04.282]                     inherits <- base::inherits
[16:11:04.282]                     invokeRestart <- base::invokeRestart
[16:11:04.282]                     is.null <- base::is.null
[16:11:04.282]                     muffled <- FALSE
[16:11:04.282]                     if (inherits(cond, "message")) {
[16:11:04.282]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:04.282]                       if (muffled) 
[16:11:04.282]                         invokeRestart("muffleMessage")
[16:11:04.282]                     }
[16:11:04.282]                     else if (inherits(cond, "warning")) {
[16:11:04.282]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:04.282]                       if (muffled) 
[16:11:04.282]                         invokeRestart("muffleWarning")
[16:11:04.282]                     }
[16:11:04.282]                     else if (inherits(cond, "condition")) {
[16:11:04.282]                       if (!is.null(pattern)) {
[16:11:04.282]                         computeRestarts <- base::computeRestarts
[16:11:04.282]                         grepl <- base::grepl
[16:11:04.282]                         restarts <- computeRestarts(cond)
[16:11:04.282]                         for (restart in restarts) {
[16:11:04.282]                           name <- restart$name
[16:11:04.282]                           if (is.null(name)) 
[16:11:04.282]                             next
[16:11:04.282]                           if (!grepl(pattern, name)) 
[16:11:04.282]                             next
[16:11:04.282]                           invokeRestart(restart)
[16:11:04.282]                           muffled <- TRUE
[16:11:04.282]                           break
[16:11:04.282]                         }
[16:11:04.282]                       }
[16:11:04.282]                     }
[16:11:04.282]                     invisible(muffled)
[16:11:04.282]                   }
[16:11:04.282]                   muffleCondition(cond)
[16:11:04.282]                 })
[16:11:04.282]             }))
[16:11:04.282]             future::FutureResult(value = ...future.value$value, 
[16:11:04.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.282]                   ...future.rng), globalenv = if (FALSE) 
[16:11:04.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:04.282]                     ...future.globalenv.names))
[16:11:04.282]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:04.282]         }, condition = base::local({
[16:11:04.282]             c <- base::c
[16:11:04.282]             inherits <- base::inherits
[16:11:04.282]             invokeRestart <- base::invokeRestart
[16:11:04.282]             length <- base::length
[16:11:04.282]             list <- base::list
[16:11:04.282]             seq.int <- base::seq.int
[16:11:04.282]             signalCondition <- base::signalCondition
[16:11:04.282]             sys.calls <- base::sys.calls
[16:11:04.282]             `[[` <- base::`[[`
[16:11:04.282]             `+` <- base::`+`
[16:11:04.282]             `<<-` <- base::`<<-`
[16:11:04.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:04.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:04.282]                   3L)]
[16:11:04.282]             }
[16:11:04.282]             function(cond) {
[16:11:04.282]                 is_error <- inherits(cond, "error")
[16:11:04.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:04.282]                   NULL)
[16:11:04.282]                 if (is_error) {
[16:11:04.282]                   sessionInformation <- function() {
[16:11:04.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:04.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:04.282]                       search = base::search(), system = base::Sys.info())
[16:11:04.282]                   }
[16:11:04.282]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:04.282]                     cond$call), session = sessionInformation(), 
[16:11:04.282]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:04.282]                   signalCondition(cond)
[16:11:04.282]                 }
[16:11:04.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:04.282]                 "immediateCondition"))) {
[16:11:04.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:04.282]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:04.282]                   if (TRUE && !signal) {
[16:11:04.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.282]                     {
[16:11:04.282]                       inherits <- base::inherits
[16:11:04.282]                       invokeRestart <- base::invokeRestart
[16:11:04.282]                       is.null <- base::is.null
[16:11:04.282]                       muffled <- FALSE
[16:11:04.282]                       if (inherits(cond, "message")) {
[16:11:04.282]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.282]                         if (muffled) 
[16:11:04.282]                           invokeRestart("muffleMessage")
[16:11:04.282]                       }
[16:11:04.282]                       else if (inherits(cond, "warning")) {
[16:11:04.282]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.282]                         if (muffled) 
[16:11:04.282]                           invokeRestart("muffleWarning")
[16:11:04.282]                       }
[16:11:04.282]                       else if (inherits(cond, "condition")) {
[16:11:04.282]                         if (!is.null(pattern)) {
[16:11:04.282]                           computeRestarts <- base::computeRestarts
[16:11:04.282]                           grepl <- base::grepl
[16:11:04.282]                           restarts <- computeRestarts(cond)
[16:11:04.282]                           for (restart in restarts) {
[16:11:04.282]                             name <- restart$name
[16:11:04.282]                             if (is.null(name)) 
[16:11:04.282]                               next
[16:11:04.282]                             if (!grepl(pattern, name)) 
[16:11:04.282]                               next
[16:11:04.282]                             invokeRestart(restart)
[16:11:04.282]                             muffled <- TRUE
[16:11:04.282]                             break
[16:11:04.282]                           }
[16:11:04.282]                         }
[16:11:04.282]                       }
[16:11:04.282]                       invisible(muffled)
[16:11:04.282]                     }
[16:11:04.282]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.282]                   }
[16:11:04.282]                 }
[16:11:04.282]                 else {
[16:11:04.282]                   if (TRUE) {
[16:11:04.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.282]                     {
[16:11:04.282]                       inherits <- base::inherits
[16:11:04.282]                       invokeRestart <- base::invokeRestart
[16:11:04.282]                       is.null <- base::is.null
[16:11:04.282]                       muffled <- FALSE
[16:11:04.282]                       if (inherits(cond, "message")) {
[16:11:04.282]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.282]                         if (muffled) 
[16:11:04.282]                           invokeRestart("muffleMessage")
[16:11:04.282]                       }
[16:11:04.282]                       else if (inherits(cond, "warning")) {
[16:11:04.282]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.282]                         if (muffled) 
[16:11:04.282]                           invokeRestart("muffleWarning")
[16:11:04.282]                       }
[16:11:04.282]                       else if (inherits(cond, "condition")) {
[16:11:04.282]                         if (!is.null(pattern)) {
[16:11:04.282]                           computeRestarts <- base::computeRestarts
[16:11:04.282]                           grepl <- base::grepl
[16:11:04.282]                           restarts <- computeRestarts(cond)
[16:11:04.282]                           for (restart in restarts) {
[16:11:04.282]                             name <- restart$name
[16:11:04.282]                             if (is.null(name)) 
[16:11:04.282]                               next
[16:11:04.282]                             if (!grepl(pattern, name)) 
[16:11:04.282]                               next
[16:11:04.282]                             invokeRestart(restart)
[16:11:04.282]                             muffled <- TRUE
[16:11:04.282]                             break
[16:11:04.282]                           }
[16:11:04.282]                         }
[16:11:04.282]                       }
[16:11:04.282]                       invisible(muffled)
[16:11:04.282]                     }
[16:11:04.282]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.282]                   }
[16:11:04.282]                 }
[16:11:04.282]             }
[16:11:04.282]         }))
[16:11:04.282]     }, error = function(ex) {
[16:11:04.282]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:04.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.282]                 ...future.rng), started = ...future.startTime, 
[16:11:04.282]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:04.282]             version = "1.8"), class = "FutureResult")
[16:11:04.282]     }, finally = {
[16:11:04.282]         if (!identical(...future.workdir, getwd())) 
[16:11:04.282]             setwd(...future.workdir)
[16:11:04.282]         {
[16:11:04.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:04.282]                 ...future.oldOptions$nwarnings <- NULL
[16:11:04.282]             }
[16:11:04.282]             base::options(...future.oldOptions)
[16:11:04.282]             if (.Platform$OS.type == "windows") {
[16:11:04.282]                 old_names <- names(...future.oldEnvVars)
[16:11:04.282]                 envs <- base::Sys.getenv()
[16:11:04.282]                 names <- names(envs)
[16:11:04.282]                 common <- intersect(names, old_names)
[16:11:04.282]                 added <- setdiff(names, old_names)
[16:11:04.282]                 removed <- setdiff(old_names, names)
[16:11:04.282]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:04.282]                   envs[common]]
[16:11:04.282]                 NAMES <- toupper(changed)
[16:11:04.282]                 args <- list()
[16:11:04.282]                 for (kk in seq_along(NAMES)) {
[16:11:04.282]                   name <- changed[[kk]]
[16:11:04.282]                   NAME <- NAMES[[kk]]
[16:11:04.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.282]                     next
[16:11:04.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.282]                 }
[16:11:04.282]                 NAMES <- toupper(added)
[16:11:04.282]                 for (kk in seq_along(NAMES)) {
[16:11:04.282]                   name <- added[[kk]]
[16:11:04.282]                   NAME <- NAMES[[kk]]
[16:11:04.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.282]                     next
[16:11:04.282]                   args[[name]] <- ""
[16:11:04.282]                 }
[16:11:04.282]                 NAMES <- toupper(removed)
[16:11:04.282]                 for (kk in seq_along(NAMES)) {
[16:11:04.282]                   name <- removed[[kk]]
[16:11:04.282]                   NAME <- NAMES[[kk]]
[16:11:04.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.282]                     next
[16:11:04.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.282]                 }
[16:11:04.282]                 if (length(args) > 0) 
[16:11:04.282]                   base::do.call(base::Sys.setenv, args = args)
[16:11:04.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:04.282]             }
[16:11:04.282]             else {
[16:11:04.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:04.282]             }
[16:11:04.282]             {
[16:11:04.282]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:04.282]                   0L) {
[16:11:04.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:04.282]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:04.282]                   base::options(opts)
[16:11:04.282]                 }
[16:11:04.282]                 {
[16:11:04.282]                   {
[16:11:04.282]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:04.282]                     NULL
[16:11:04.282]                   }
[16:11:04.282]                   options(future.plan = NULL)
[16:11:04.282]                   if (is.na(NA_character_)) 
[16:11:04.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:04.282]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:04.282]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:04.282]                     envir = parent.frame()) 
[16:11:04.282]                   {
[16:11:04.282]                     if (is.function(workers)) 
[16:11:04.282]                       workers <- workers()
[16:11:04.282]                     workers <- structure(as.integer(workers), 
[16:11:04.282]                       class = class(workers))
[16:11:04.282]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:04.282]                       workers >= 1)
[16:11:04.282]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:04.282]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:04.282]                     }
[16:11:04.282]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:04.282]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:04.282]                       envir = envir)
[16:11:04.282]                     if (!future$lazy) 
[16:11:04.282]                       future <- run(future)
[16:11:04.282]                     invisible(future)
[16:11:04.282]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:04.282]                 }
[16:11:04.282]             }
[16:11:04.282]         }
[16:11:04.282]     })
[16:11:04.282]     if (TRUE) {
[16:11:04.282]         base::sink(type = "output", split = FALSE)
[16:11:04.282]         if (TRUE) {
[16:11:04.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:04.282]         }
[16:11:04.282]         else {
[16:11:04.282]             ...future.result["stdout"] <- base::list(NULL)
[16:11:04.282]         }
[16:11:04.282]         base::close(...future.stdout)
[16:11:04.282]         ...future.stdout <- NULL
[16:11:04.282]     }
[16:11:04.282]     ...future.result$conditions <- ...future.conditions
[16:11:04.282]     ...future.result$finished <- base::Sys.time()
[16:11:04.282]     ...future.result
[16:11:04.282] }
[16:11:04.285] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[16:11:04.285] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:04.328] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:04.328] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[16:11:04.328] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[16:11:04.328] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:04.329] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:04.329] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:04.372] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:04.372] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:04.416] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:04.416] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:04.416] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.417] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:11:04.417] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:11:04.417] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:04.418] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.418] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:11:04.418] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:11:04.418] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:04.419] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.419] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:04.419] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.419] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[16:11:04.421] MultisessionFuture started
[16:11:04.422] - Launch lazy future ... done
[16:11:04.422] run() for ‘MultisessionFuture’ ... done
[16:11:04.422] Created future:
[16:11:04.422] MultisessionFuture:
[16:11:04.422] Label: ‘future_vapply-1’
[16:11:04.422] Expression:
[16:11:04.422] {
[16:11:04.422]     do.call(function(...) {
[16:11:04.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.422]             on.exit(options(oopts), add = TRUE)
[16:11:04.422]         }
[16:11:04.422]         {
[16:11:04.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.422]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.422]             })
[16:11:04.422]         }
[16:11:04.422]     }, args = future.call.arguments)
[16:11:04.422] }
[16:11:04.422] Lazy evaluation: FALSE
[16:11:04.422] Asynchronous evaluation: TRUE
[16:11:04.422] Local evaluation: TRUE
[16:11:04.422] Environment: R_GlobalEnv
[16:11:04.422] Capture standard output: TRUE
[16:11:04.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:04.422] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:04.422] Packages: 1 packages (‘future.apply’)
[16:11:04.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:04.422] Resolved: FALSE
[16:11:04.422] Value: <not collected>
[16:11:04.422] Conditions captured: <none>
[16:11:04.422] Early signaling: FALSE
[16:11:04.422] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:04.422] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.433] Chunk #1 of 2 ... DONE
[16:11:04.434] Chunk #2 of 2 ...
[16:11:04.434]  - Finding globals in 'X' for chunk #2 ...
[16:11:04.434] getGlobalsAndPackages() ...
[16:11:04.434] Searching for globals...
[16:11:04.434] 
[16:11:04.434] Searching for globals ... DONE
[16:11:04.434] - globals: [0] <none>
[16:11:04.435] getGlobalsAndPackages() ... DONE
[16:11:04.435]    + additional globals found: [n=0] 
[16:11:04.435]    + additional namespaces needed: [n=0] 
[16:11:04.435]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:04.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:04.435]  - seeds: <none>
[16:11:04.435] getGlobalsAndPackages() ...
[16:11:04.435] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.435] Resolving globals: FALSE
[16:11:04.435] Tweak future expression to call with '...' arguments ...
[16:11:04.436] {
[16:11:04.436]     do.call(function(...) {
[16:11:04.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.436]             on.exit(options(oopts), add = TRUE)
[16:11:04.436]         }
[16:11:04.436]         {
[16:11:04.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.436]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.436]             })
[16:11:04.436]         }
[16:11:04.436]     }, args = future.call.arguments)
[16:11:04.436] }
[16:11:04.436] Tweak future expression to call with '...' arguments ... DONE
[16:11:04.436] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.436] - packages: [1] ‘future.apply’
[16:11:04.437] getGlobalsAndPackages() ... DONE
[16:11:04.437] run() for ‘Future’ ...
[16:11:04.437] - state: ‘created’
[16:11:04.437] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:04.451] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.451] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:04.451]   - Field: ‘node’
[16:11:04.451]   - Field: ‘label’
[16:11:04.451]   - Field: ‘local’
[16:11:04.451]   - Field: ‘owner’
[16:11:04.452]   - Field: ‘envir’
[16:11:04.452]   - Field: ‘workers’
[16:11:04.452]   - Field: ‘packages’
[16:11:04.452]   - Field: ‘gc’
[16:11:04.452]   - Field: ‘conditions’
[16:11:04.452]   - Field: ‘persistent’
[16:11:04.452]   - Field: ‘expr’
[16:11:04.452]   - Field: ‘uuid’
[16:11:04.452]   - Field: ‘seed’
[16:11:04.452]   - Field: ‘version’
[16:11:04.453]   - Field: ‘result’
[16:11:04.453]   - Field: ‘asynchronous’
[16:11:04.453]   - Field: ‘calls’
[16:11:04.453]   - Field: ‘globals’
[16:11:04.453]   - Field: ‘stdout’
[16:11:04.453]   - Field: ‘earlySignal’
[16:11:04.453]   - Field: ‘lazy’
[16:11:04.453]   - Field: ‘state’
[16:11:04.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:04.453] - Launch lazy future ...
[16:11:04.454] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:04.454] Packages needed by future strategies (n = 0): <none>
[16:11:04.454] {
[16:11:04.454]     {
[16:11:04.454]         {
[16:11:04.454]             ...future.startTime <- base::Sys.time()
[16:11:04.454]             {
[16:11:04.454]                 {
[16:11:04.454]                   {
[16:11:04.454]                     {
[16:11:04.454]                       {
[16:11:04.454]                         base::local({
[16:11:04.454]                           has_future <- base::requireNamespace("future", 
[16:11:04.454]                             quietly = TRUE)
[16:11:04.454]                           if (has_future) {
[16:11:04.454]                             ns <- base::getNamespace("future")
[16:11:04.454]                             version <- ns[[".package"]][["version"]]
[16:11:04.454]                             if (is.null(version)) 
[16:11:04.454]                               version <- utils::packageVersion("future")
[16:11:04.454]                           }
[16:11:04.454]                           else {
[16:11:04.454]                             version <- NULL
[16:11:04.454]                           }
[16:11:04.454]                           if (!has_future || version < "1.8.0") {
[16:11:04.454]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:04.454]                               "", base::R.version$version.string), 
[16:11:04.454]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:04.454]                                 base::R.version$platform, 8 * 
[16:11:04.454]                                   base::.Machine$sizeof.pointer), 
[16:11:04.454]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:04.454]                                 "release", "version")], collapse = " "), 
[16:11:04.454]                               hostname = base::Sys.info()[["nodename"]])
[16:11:04.454]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:04.454]                               info)
[16:11:04.454]                             info <- base::paste(info, collapse = "; ")
[16:11:04.454]                             if (!has_future) {
[16:11:04.454]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:04.454]                                 info)
[16:11:04.454]                             }
[16:11:04.454]                             else {
[16:11:04.454]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:04.454]                                 info, version)
[16:11:04.454]                             }
[16:11:04.454]                             base::stop(msg)
[16:11:04.454]                           }
[16:11:04.454]                         })
[16:11:04.454]                       }
[16:11:04.454]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:04.454]                       base::options(mc.cores = 1L)
[16:11:04.454]                     }
[16:11:04.454]                     base::local({
[16:11:04.454]                       for (pkg in "future.apply") {
[16:11:04.454]                         base::loadNamespace(pkg)
[16:11:04.454]                         base::library(pkg, character.only = TRUE)
[16:11:04.454]                       }
[16:11:04.454]                     })
[16:11:04.454]                   }
[16:11:04.454]                   options(future.plan = NULL)
[16:11:04.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:04.454]                 }
[16:11:04.454]                 ...future.workdir <- getwd()
[16:11:04.454]             }
[16:11:04.454]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:04.454]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:04.454]         }
[16:11:04.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:04.454]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:04.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:04.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:04.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:04.454]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:04.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:04.454]             base::names(...future.oldOptions))
[16:11:04.454]     }
[16:11:04.454]     if (FALSE) {
[16:11:04.454]     }
[16:11:04.454]     else {
[16:11:04.454]         if (TRUE) {
[16:11:04.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:04.454]                 open = "w")
[16:11:04.454]         }
[16:11:04.454]         else {
[16:11:04.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:04.454]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:04.454]         }
[16:11:04.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:04.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:04.454]             base::sink(type = "output", split = FALSE)
[16:11:04.454]             base::close(...future.stdout)
[16:11:04.454]         }, add = TRUE)
[16:11:04.454]     }
[16:11:04.454]     ...future.frame <- base::sys.nframe()
[16:11:04.454]     ...future.conditions <- base::list()
[16:11:04.454]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:04.454]     if (FALSE) {
[16:11:04.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:04.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:04.454]     }
[16:11:04.454]     ...future.result <- base::tryCatch({
[16:11:04.454]         base::withCallingHandlers({
[16:11:04.454]             ...future.value <- base::withVisible(base::local({
[16:11:04.454]                 ...future.makeSendCondition <- local({
[16:11:04.454]                   sendCondition <- NULL
[16:11:04.454]                   function(frame = 1L) {
[16:11:04.454]                     if (is.function(sendCondition)) 
[16:11:04.454]                       return(sendCondition)
[16:11:04.454]                     ns <- getNamespace("parallel")
[16:11:04.454]                     if (exists("sendData", mode = "function", 
[16:11:04.454]                       envir = ns)) {
[16:11:04.454]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:04.454]                         envir = ns)
[16:11:04.454]                       envir <- sys.frame(frame)
[16:11:04.454]                       master <- NULL
[16:11:04.454]                       while (!identical(envir, .GlobalEnv) && 
[16:11:04.454]                         !identical(envir, emptyenv())) {
[16:11:04.454]                         if (exists("master", mode = "list", envir = envir, 
[16:11:04.454]                           inherits = FALSE)) {
[16:11:04.454]                           master <- get("master", mode = "list", 
[16:11:04.454]                             envir = envir, inherits = FALSE)
[16:11:04.454]                           if (inherits(master, c("SOCKnode", 
[16:11:04.454]                             "SOCK0node"))) {
[16:11:04.454]                             sendCondition <<- function(cond) {
[16:11:04.454]                               data <- list(type = "VALUE", value = cond, 
[16:11:04.454]                                 success = TRUE)
[16:11:04.454]                               parallel_sendData(master, data)
[16:11:04.454]                             }
[16:11:04.454]                             return(sendCondition)
[16:11:04.454]                           }
[16:11:04.454]                         }
[16:11:04.454]                         frame <- frame + 1L
[16:11:04.454]                         envir <- sys.frame(frame)
[16:11:04.454]                       }
[16:11:04.454]                     }
[16:11:04.454]                     sendCondition <<- function(cond) NULL
[16:11:04.454]                   }
[16:11:04.454]                 })
[16:11:04.454]                 withCallingHandlers({
[16:11:04.454]                   {
[16:11:04.454]                     do.call(function(...) {
[16:11:04.454]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.454]                       if (!identical(...future.globals.maxSize.org, 
[16:11:04.454]                         ...future.globals.maxSize)) {
[16:11:04.454]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.454]                         on.exit(options(oopts), add = TRUE)
[16:11:04.454]                       }
[16:11:04.454]                       {
[16:11:04.454]                         lapply(seq_along(...future.elements_ii), 
[16:11:04.454]                           FUN = function(jj) {
[16:11:04.454]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.454]                             ...future.FUN(...future.X_jj, ...)
[16:11:04.454]                           })
[16:11:04.454]                       }
[16:11:04.454]                     }, args = future.call.arguments)
[16:11:04.454]                   }
[16:11:04.454]                 }, immediateCondition = function(cond) {
[16:11:04.454]                   sendCondition <- ...future.makeSendCondition()
[16:11:04.454]                   sendCondition(cond)
[16:11:04.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.454]                   {
[16:11:04.454]                     inherits <- base::inherits
[16:11:04.454]                     invokeRestart <- base::invokeRestart
[16:11:04.454]                     is.null <- base::is.null
[16:11:04.454]                     muffled <- FALSE
[16:11:04.454]                     if (inherits(cond, "message")) {
[16:11:04.454]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:04.454]                       if (muffled) 
[16:11:04.454]                         invokeRestart("muffleMessage")
[16:11:04.454]                     }
[16:11:04.454]                     else if (inherits(cond, "warning")) {
[16:11:04.454]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:04.454]                       if (muffled) 
[16:11:04.454]                         invokeRestart("muffleWarning")
[16:11:04.454]                     }
[16:11:04.454]                     else if (inherits(cond, "condition")) {
[16:11:04.454]                       if (!is.null(pattern)) {
[16:11:04.454]                         computeRestarts <- base::computeRestarts
[16:11:04.454]                         grepl <- base::grepl
[16:11:04.454]                         restarts <- computeRestarts(cond)
[16:11:04.454]                         for (restart in restarts) {
[16:11:04.454]                           name <- restart$name
[16:11:04.454]                           if (is.null(name)) 
[16:11:04.454]                             next
[16:11:04.454]                           if (!grepl(pattern, name)) 
[16:11:04.454]                             next
[16:11:04.454]                           invokeRestart(restart)
[16:11:04.454]                           muffled <- TRUE
[16:11:04.454]                           break
[16:11:04.454]                         }
[16:11:04.454]                       }
[16:11:04.454]                     }
[16:11:04.454]                     invisible(muffled)
[16:11:04.454]                   }
[16:11:04.454]                   muffleCondition(cond)
[16:11:04.454]                 })
[16:11:04.454]             }))
[16:11:04.454]             future::FutureResult(value = ...future.value$value, 
[16:11:04.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.454]                   ...future.rng), globalenv = if (FALSE) 
[16:11:04.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:04.454]                     ...future.globalenv.names))
[16:11:04.454]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:04.454]         }, condition = base::local({
[16:11:04.454]             c <- base::c
[16:11:04.454]             inherits <- base::inherits
[16:11:04.454]             invokeRestart <- base::invokeRestart
[16:11:04.454]             length <- base::length
[16:11:04.454]             list <- base::list
[16:11:04.454]             seq.int <- base::seq.int
[16:11:04.454]             signalCondition <- base::signalCondition
[16:11:04.454]             sys.calls <- base::sys.calls
[16:11:04.454]             `[[` <- base::`[[`
[16:11:04.454]             `+` <- base::`+`
[16:11:04.454]             `<<-` <- base::`<<-`
[16:11:04.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:04.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:04.454]                   3L)]
[16:11:04.454]             }
[16:11:04.454]             function(cond) {
[16:11:04.454]                 is_error <- inherits(cond, "error")
[16:11:04.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:04.454]                   NULL)
[16:11:04.454]                 if (is_error) {
[16:11:04.454]                   sessionInformation <- function() {
[16:11:04.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:04.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:04.454]                       search = base::search(), system = base::Sys.info())
[16:11:04.454]                   }
[16:11:04.454]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:04.454]                     cond$call), session = sessionInformation(), 
[16:11:04.454]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:04.454]                   signalCondition(cond)
[16:11:04.454]                 }
[16:11:04.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:04.454]                 "immediateCondition"))) {
[16:11:04.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:04.454]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:04.454]                   if (TRUE && !signal) {
[16:11:04.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.454]                     {
[16:11:04.454]                       inherits <- base::inherits
[16:11:04.454]                       invokeRestart <- base::invokeRestart
[16:11:04.454]                       is.null <- base::is.null
[16:11:04.454]                       muffled <- FALSE
[16:11:04.454]                       if (inherits(cond, "message")) {
[16:11:04.454]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.454]                         if (muffled) 
[16:11:04.454]                           invokeRestart("muffleMessage")
[16:11:04.454]                       }
[16:11:04.454]                       else if (inherits(cond, "warning")) {
[16:11:04.454]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.454]                         if (muffled) 
[16:11:04.454]                           invokeRestart("muffleWarning")
[16:11:04.454]                       }
[16:11:04.454]                       else if (inherits(cond, "condition")) {
[16:11:04.454]                         if (!is.null(pattern)) {
[16:11:04.454]                           computeRestarts <- base::computeRestarts
[16:11:04.454]                           grepl <- base::grepl
[16:11:04.454]                           restarts <- computeRestarts(cond)
[16:11:04.454]                           for (restart in restarts) {
[16:11:04.454]                             name <- restart$name
[16:11:04.454]                             if (is.null(name)) 
[16:11:04.454]                               next
[16:11:04.454]                             if (!grepl(pattern, name)) 
[16:11:04.454]                               next
[16:11:04.454]                             invokeRestart(restart)
[16:11:04.454]                             muffled <- TRUE
[16:11:04.454]                             break
[16:11:04.454]                           }
[16:11:04.454]                         }
[16:11:04.454]                       }
[16:11:04.454]                       invisible(muffled)
[16:11:04.454]                     }
[16:11:04.454]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.454]                   }
[16:11:04.454]                 }
[16:11:04.454]                 else {
[16:11:04.454]                   if (TRUE) {
[16:11:04.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.454]                     {
[16:11:04.454]                       inherits <- base::inherits
[16:11:04.454]                       invokeRestart <- base::invokeRestart
[16:11:04.454]                       is.null <- base::is.null
[16:11:04.454]                       muffled <- FALSE
[16:11:04.454]                       if (inherits(cond, "message")) {
[16:11:04.454]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.454]                         if (muffled) 
[16:11:04.454]                           invokeRestart("muffleMessage")
[16:11:04.454]                       }
[16:11:04.454]                       else if (inherits(cond, "warning")) {
[16:11:04.454]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.454]                         if (muffled) 
[16:11:04.454]                           invokeRestart("muffleWarning")
[16:11:04.454]                       }
[16:11:04.454]                       else if (inherits(cond, "condition")) {
[16:11:04.454]                         if (!is.null(pattern)) {
[16:11:04.454]                           computeRestarts <- base::computeRestarts
[16:11:04.454]                           grepl <- base::grepl
[16:11:04.454]                           restarts <- computeRestarts(cond)
[16:11:04.454]                           for (restart in restarts) {
[16:11:04.454]                             name <- restart$name
[16:11:04.454]                             if (is.null(name)) 
[16:11:04.454]                               next
[16:11:04.454]                             if (!grepl(pattern, name)) 
[16:11:04.454]                               next
[16:11:04.454]                             invokeRestart(restart)
[16:11:04.454]                             muffled <- TRUE
[16:11:04.454]                             break
[16:11:04.454]                           }
[16:11:04.454]                         }
[16:11:04.454]                       }
[16:11:04.454]                       invisible(muffled)
[16:11:04.454]                     }
[16:11:04.454]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.454]                   }
[16:11:04.454]                 }
[16:11:04.454]             }
[16:11:04.454]         }))
[16:11:04.454]     }, error = function(ex) {
[16:11:04.454]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:04.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.454]                 ...future.rng), started = ...future.startTime, 
[16:11:04.454]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:04.454]             version = "1.8"), class = "FutureResult")
[16:11:04.454]     }, finally = {
[16:11:04.454]         if (!identical(...future.workdir, getwd())) 
[16:11:04.454]             setwd(...future.workdir)
[16:11:04.454]         {
[16:11:04.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:04.454]                 ...future.oldOptions$nwarnings <- NULL
[16:11:04.454]             }
[16:11:04.454]             base::options(...future.oldOptions)
[16:11:04.454]             if (.Platform$OS.type == "windows") {
[16:11:04.454]                 old_names <- names(...future.oldEnvVars)
[16:11:04.454]                 envs <- base::Sys.getenv()
[16:11:04.454]                 names <- names(envs)
[16:11:04.454]                 common <- intersect(names, old_names)
[16:11:04.454]                 added <- setdiff(names, old_names)
[16:11:04.454]                 removed <- setdiff(old_names, names)
[16:11:04.454]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:04.454]                   envs[common]]
[16:11:04.454]                 NAMES <- toupper(changed)
[16:11:04.454]                 args <- list()
[16:11:04.454]                 for (kk in seq_along(NAMES)) {
[16:11:04.454]                   name <- changed[[kk]]
[16:11:04.454]                   NAME <- NAMES[[kk]]
[16:11:04.454]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.454]                     next
[16:11:04.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.454]                 }
[16:11:04.454]                 NAMES <- toupper(added)
[16:11:04.454]                 for (kk in seq_along(NAMES)) {
[16:11:04.454]                   name <- added[[kk]]
[16:11:04.454]                   NAME <- NAMES[[kk]]
[16:11:04.454]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.454]                     next
[16:11:04.454]                   args[[name]] <- ""
[16:11:04.454]                 }
[16:11:04.454]                 NAMES <- toupper(removed)
[16:11:04.454]                 for (kk in seq_along(NAMES)) {
[16:11:04.454]                   name <- removed[[kk]]
[16:11:04.454]                   NAME <- NAMES[[kk]]
[16:11:04.454]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.454]                     next
[16:11:04.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.454]                 }
[16:11:04.454]                 if (length(args) > 0) 
[16:11:04.454]                   base::do.call(base::Sys.setenv, args = args)
[16:11:04.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:04.454]             }
[16:11:04.454]             else {
[16:11:04.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:04.454]             }
[16:11:04.454]             {
[16:11:04.454]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:04.454]                   0L) {
[16:11:04.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:04.454]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:04.454]                   base::options(opts)
[16:11:04.454]                 }
[16:11:04.454]                 {
[16:11:04.454]                   {
[16:11:04.454]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:04.454]                     NULL
[16:11:04.454]                   }
[16:11:04.454]                   options(future.plan = NULL)
[16:11:04.454]                   if (is.na(NA_character_)) 
[16:11:04.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:04.454]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:04.454]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:04.454]                     envir = parent.frame()) 
[16:11:04.454]                   {
[16:11:04.454]                     if (is.function(workers)) 
[16:11:04.454]                       workers <- workers()
[16:11:04.454]                     workers <- structure(as.integer(workers), 
[16:11:04.454]                       class = class(workers))
[16:11:04.454]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:04.454]                       workers >= 1)
[16:11:04.454]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:04.454]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:04.454]                     }
[16:11:04.454]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:04.454]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:04.454]                       envir = envir)
[16:11:04.454]                     if (!future$lazy) 
[16:11:04.454]                       future <- run(future)
[16:11:04.454]                     invisible(future)
[16:11:04.454]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:04.454]                 }
[16:11:04.454]             }
[16:11:04.454]         }
[16:11:04.454]     })
[16:11:04.454]     if (TRUE) {
[16:11:04.454]         base::sink(type = "output", split = FALSE)
[16:11:04.454]         if (TRUE) {
[16:11:04.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:04.454]         }
[16:11:04.454]         else {
[16:11:04.454]             ...future.result["stdout"] <- base::list(NULL)
[16:11:04.454]         }
[16:11:04.454]         base::close(...future.stdout)
[16:11:04.454]         ...future.stdout <- NULL
[16:11:04.454]     }
[16:11:04.454]     ...future.result$conditions <- ...future.conditions
[16:11:04.454]     ...future.result$finished <- base::Sys.time()
[16:11:04.454]     ...future.result
[16:11:04.454] }
[16:11:04.457] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[16:11:04.457] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:04.500] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:04.500] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[16:11:04.500] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[16:11:04.501] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:04.501] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:04.501] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:04.544] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:04.544] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:04.588] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:04.588] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:04.588] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.589] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[16:11:04.589] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[16:11:04.589] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:04.590] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.590] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:11:04.590] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:11:04.591] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:04.591] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:04.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.592] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[16:11:04.592] MultisessionFuture started
[16:11:04.592] - Launch lazy future ... done
[16:11:04.593] run() for ‘MultisessionFuture’ ... done
[16:11:04.593] Created future:
[16:11:04.593] MultisessionFuture:
[16:11:04.593] Label: ‘future_vapply-2’
[16:11:04.593] Expression:
[16:11:04.593] {
[16:11:04.593]     do.call(function(...) {
[16:11:04.593]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.593]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.593]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.593]             on.exit(options(oopts), add = TRUE)
[16:11:04.593]         }
[16:11:04.593]         {
[16:11:04.593]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.593]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.593]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.593]             })
[16:11:04.593]         }
[16:11:04.593]     }, args = future.call.arguments)
[16:11:04.593] }
[16:11:04.593] Lazy evaluation: FALSE
[16:11:04.593] Asynchronous evaluation: TRUE
[16:11:04.593] Local evaluation: TRUE
[16:11:04.593] Environment: R_GlobalEnv
[16:11:04.593] Capture standard output: TRUE
[16:11:04.593] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:04.593] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:04.593] Packages: 1 packages (‘future.apply’)
[16:11:04.593] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:04.593] Resolved: FALSE
[16:11:04.593] Value: <not collected>
[16:11:04.593] Conditions captured: <none>
[16:11:04.593] Early signaling: FALSE
[16:11:04.593] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:04.593] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.605] Chunk #2 of 2 ... DONE
[16:11:04.605] Launching 2 futures (chunks) ... DONE
[16:11:04.605] Resolving 2 futures (chunks) ...
[16:11:04.605] resolve() on list ...
[16:11:04.605]  recursive: 0
[16:11:04.605]  length: 2
[16:11:04.605] 
[16:11:04.606] receiveMessageFromWorker() for ClusterFuture ...
[16:11:04.606] - Validating connection of MultisessionFuture
[16:11:04.606] - received message: FutureResult
[16:11:04.606] - Received FutureResult
[16:11:04.606] - Erased future from FutureRegistry
[16:11:04.607] result() for ClusterFuture ...
[16:11:04.607] - result already collected: FutureResult
[16:11:04.607] result() for ClusterFuture ... done
[16:11:04.607] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:04.607] Future #1
[16:11:04.607] result() for ClusterFuture ...
[16:11:04.607] - result already collected: FutureResult
[16:11:04.607] result() for ClusterFuture ... done
[16:11:04.607] result() for ClusterFuture ...
[16:11:04.607] - result already collected: FutureResult
[16:11:04.607] result() for ClusterFuture ... done
[16:11:04.607] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:04.608] - nx: 2
[16:11:04.608] - relay: TRUE
[16:11:04.608] - stdout: TRUE
[16:11:04.608] - signal: TRUE
[16:11:04.608] - resignal: FALSE
[16:11:04.608] - force: TRUE
[16:11:04.608] - relayed: [n=2] FALSE, FALSE
[16:11:04.608] - queued futures: [n=2] FALSE, FALSE
[16:11:04.608]  - until=1
[16:11:04.608]  - relaying element #1
[16:11:04.608] result() for ClusterFuture ...
[16:11:04.609] - result already collected: FutureResult
[16:11:04.609] result() for ClusterFuture ... done
[16:11:04.609] result() for ClusterFuture ...
[16:11:04.609] - result already collected: FutureResult
[16:11:04.609] result() for ClusterFuture ... done
[16:11:04.609] result() for ClusterFuture ...
[16:11:04.609] - result already collected: FutureResult
[16:11:04.609] result() for ClusterFuture ... done
[16:11:04.609] result() for ClusterFuture ...
[16:11:04.609] - result already collected: FutureResult
[16:11:04.609] result() for ClusterFuture ... done
[16:11:04.609] - relayed: [n=2] TRUE, FALSE
[16:11:04.610] - queued futures: [n=2] TRUE, FALSE
[16:11:04.610] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:04.610]  length: 1 (resolved future 1)
[16:11:04.641] receiveMessageFromWorker() for ClusterFuture ...
[16:11:04.641] - Validating connection of MultisessionFuture
[16:11:04.641] - received message: FutureResult
[16:11:04.641] - Received FutureResult
[16:11:04.641] - Erased future from FutureRegistry
[16:11:04.641] result() for ClusterFuture ...
[16:11:04.642] - result already collected: FutureResult
[16:11:04.642] result() for ClusterFuture ... done
[16:11:04.642] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:04.642] Future #2
[16:11:04.642] result() for ClusterFuture ...
[16:11:04.642] - result already collected: FutureResult
[16:11:04.642] result() for ClusterFuture ... done
[16:11:04.642] result() for ClusterFuture ...
[16:11:04.642] - result already collected: FutureResult
[16:11:04.642] result() for ClusterFuture ... done
[16:11:04.642] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:04.643] - nx: 2
[16:11:04.643] - relay: TRUE
[16:11:04.643] - stdout: TRUE
[16:11:04.643] - signal: TRUE
[16:11:04.643] - resignal: FALSE
[16:11:04.643] - force: TRUE
[16:11:04.643] - relayed: [n=2] TRUE, FALSE
[16:11:04.643] - queued futures: [n=2] TRUE, FALSE
[16:11:04.643]  - until=2
[16:11:04.643]  - relaying element #2
[16:11:04.643] result() for ClusterFuture ...
[16:11:04.643] - result already collected: FutureResult
[16:11:04.644] result() for ClusterFuture ... done
[16:11:04.644] result() for ClusterFuture ...
[16:11:04.644] - result already collected: FutureResult
[16:11:04.644] result() for ClusterFuture ... done
[16:11:04.644] result() for ClusterFuture ...
[16:11:04.644] - result already collected: FutureResult
[16:11:04.644] result() for ClusterFuture ... done
[16:11:04.644] result() for ClusterFuture ...
[16:11:04.644] - result already collected: FutureResult
[16:11:04.644] result() for ClusterFuture ... done
[16:11:04.644] - relayed: [n=2] TRUE, TRUE
[16:11:04.645] - queued futures: [n=2] TRUE, TRUE
[16:11:04.645] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:04.645]  length: 0 (resolved future 2)
[16:11:04.645] Relaying remaining futures
[16:11:04.645] signalConditionsASAP(NULL, pos=0) ...
[16:11:04.645] - nx: 2
[16:11:04.645] - relay: TRUE
[16:11:04.645] - stdout: TRUE
[16:11:04.645] - signal: TRUE
[16:11:04.645] - resignal: FALSE
[16:11:04.645] - force: TRUE
[16:11:04.645] - relayed: [n=2] TRUE, TRUE
[16:11:04.646] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:04.646] - relayed: [n=2] TRUE, TRUE
[16:11:04.646] - queued futures: [n=2] TRUE, TRUE
[16:11:04.646] signalConditionsASAP(NULL, pos=0) ... done
[16:11:04.646] resolve() on list ... DONE
[16:11:04.646] result() for ClusterFuture ...
[16:11:04.646] - result already collected: FutureResult
[16:11:04.646] result() for ClusterFuture ... done
[16:11:04.646] result() for ClusterFuture ...
[16:11:04.646] - result already collected: FutureResult
[16:11:04.646] result() for ClusterFuture ... done
[16:11:04.647] result() for ClusterFuture ...
[16:11:04.647] - result already collected: FutureResult
[16:11:04.647] result() for ClusterFuture ... done
[16:11:04.647] result() for ClusterFuture ...
[16:11:04.647] - result already collected: FutureResult
[16:11:04.647] result() for ClusterFuture ... done
[16:11:04.647]  - Number of value chunks collected: 2
[16:11:04.647] Resolving 2 futures (chunks) ... DONE
[16:11:04.647] Reducing values from 2 chunks ...
[16:11:04.647]  - Number of values collected after concatenation: 10
[16:11:04.647]  - Number of values expected: 10
[16:11:04.647] Reducing values from 2 chunks ... DONE
[16:11:04.648] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[16:11:04.648] future_lapply() ...
[16:11:04.654] Number of chunks: 2
[16:11:04.654] getGlobalsAndPackagesXApply() ...
[16:11:04.654]  - future.globals: TRUE
[16:11:04.654] getGlobalsAndPackages() ...
[16:11:04.654] Searching for globals...
[16:11:04.657] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:04.657] Searching for globals ... DONE
[16:11:04.657] Resolving globals: FALSE
[16:11:04.658] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[16:11:04.658] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:04.658] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:04.659] - packages: [1] ‘future.apply’
[16:11:04.659] getGlobalsAndPackages() ... DONE
[16:11:04.659]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:04.659]  - needed namespaces: [n=1] ‘future.apply’
[16:11:04.659] Finding globals ... DONE
[16:11:04.659]  - use_args: TRUE
[16:11:04.659]  - Getting '...' globals ...
[16:11:04.659] resolve() on list ...
[16:11:04.660]  recursive: 0
[16:11:04.660]  length: 1
[16:11:04.660]  elements: ‘...’
[16:11:04.660]  length: 0 (resolved future 1)
[16:11:04.660] resolve() on list ... DONE
[16:11:04.660]    - '...' content: [n=0] 
[16:11:04.660] List of 1
[16:11:04.660]  $ ...: list()
[16:11:04.660]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:04.660]  - attr(*, "where")=List of 1
[16:11:04.660]   ..$ ...:<environment: 0x561e8b65b9f0> 
[16:11:04.660]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:04.660]  - attr(*, "resolved")= logi TRUE
[16:11:04.660]  - attr(*, "total_size")= num NA
[16:11:04.663]  - Getting '...' globals ... DONE
[16:11:04.663] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:04.663] List of 8
[16:11:04.663]  $ ...future.FUN:function (x, ...)  
[16:11:04.663]  $ x_FUN        :function (x)  
[16:11:04.663]  $ times        : int 1
[16:11:04.663]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:04.663]  $ stop_if_not  :function (...)  
[16:11:04.663]  $ dim          : NULL
[16:11:04.663]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:04.663]  $ ...          : list()
[16:11:04.663]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:04.663]  - attr(*, "where")=List of 8
[16:11:04.663]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:04.663]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:04.663]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:04.663]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:04.663]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:04.663]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:04.663]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:04.663]   ..$ ...          :<environment: 0x561e8b65b9f0> 
[16:11:04.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:04.663]  - attr(*, "resolved")= logi FALSE
[16:11:04.663]  - attr(*, "total_size")= num 94336
[16:11:04.668] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:04.668] getGlobalsAndPackagesXApply() ... DONE
[16:11:04.668] Number of futures (= number of chunks): 2
[16:11:04.668] Launching 2 futures (chunks) ...
[16:11:04.668] Chunk #1 of 2 ...
[16:11:04.669]  - Finding globals in 'X' for chunk #1 ...
[16:11:04.669] getGlobalsAndPackages() ...
[16:11:04.669] Searching for globals...
[16:11:04.669] 
[16:11:04.669] Searching for globals ... DONE
[16:11:04.669] - globals: [0] <none>
[16:11:04.669] getGlobalsAndPackages() ... DONE
[16:11:04.669]    + additional globals found: [n=0] 
[16:11:04.669]    + additional namespaces needed: [n=0] 
[16:11:04.670]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:04.670]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:04.670]  - seeds: <none>
[16:11:04.670] getGlobalsAndPackages() ...
[16:11:04.670] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.670] Resolving globals: FALSE
[16:11:04.670] Tweak future expression to call with '...' arguments ...
[16:11:04.670] {
[16:11:04.670]     do.call(function(...) {
[16:11:04.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.670]             on.exit(options(oopts), add = TRUE)
[16:11:04.670]         }
[16:11:04.670]         {
[16:11:04.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.670]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.670]             })
[16:11:04.670]         }
[16:11:04.670]     }, args = future.call.arguments)
[16:11:04.670] }
[16:11:04.670] Tweak future expression to call with '...' arguments ... DONE
[16:11:04.671] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.671] - packages: [1] ‘future.apply’
[16:11:04.671] getGlobalsAndPackages() ... DONE
[16:11:04.672] run() for ‘Future’ ...
[16:11:04.672] - state: ‘created’
[16:11:04.672] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:04.687] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:04.688]   - Field: ‘node’
[16:11:04.688]   - Field: ‘label’
[16:11:04.688]   - Field: ‘local’
[16:11:04.688]   - Field: ‘owner’
[16:11:04.688]   - Field: ‘envir’
[16:11:04.688]   - Field: ‘workers’
[16:11:04.688]   - Field: ‘packages’
[16:11:04.688]   - Field: ‘gc’
[16:11:04.689]   - Field: ‘conditions’
[16:11:04.689]   - Field: ‘persistent’
[16:11:04.689]   - Field: ‘expr’
[16:11:04.689]   - Field: ‘uuid’
[16:11:04.689]   - Field: ‘seed’
[16:11:04.689]   - Field: ‘version’
[16:11:04.689]   - Field: ‘result’
[16:11:04.689]   - Field: ‘asynchronous’
[16:11:04.689]   - Field: ‘calls’
[16:11:04.689]   - Field: ‘globals’
[16:11:04.689]   - Field: ‘stdout’
[16:11:04.690]   - Field: ‘earlySignal’
[16:11:04.690]   - Field: ‘lazy’
[16:11:04.690]   - Field: ‘state’
[16:11:04.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:04.690] - Launch lazy future ...
[16:11:04.690] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:04.690] Packages needed by future strategies (n = 0): <none>
[16:11:04.691] {
[16:11:04.691]     {
[16:11:04.691]         {
[16:11:04.691]             ...future.startTime <- base::Sys.time()
[16:11:04.691]             {
[16:11:04.691]                 {
[16:11:04.691]                   {
[16:11:04.691]                     {
[16:11:04.691]                       {
[16:11:04.691]                         base::local({
[16:11:04.691]                           has_future <- base::requireNamespace("future", 
[16:11:04.691]                             quietly = TRUE)
[16:11:04.691]                           if (has_future) {
[16:11:04.691]                             ns <- base::getNamespace("future")
[16:11:04.691]                             version <- ns[[".package"]][["version"]]
[16:11:04.691]                             if (is.null(version)) 
[16:11:04.691]                               version <- utils::packageVersion("future")
[16:11:04.691]                           }
[16:11:04.691]                           else {
[16:11:04.691]                             version <- NULL
[16:11:04.691]                           }
[16:11:04.691]                           if (!has_future || version < "1.8.0") {
[16:11:04.691]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:04.691]                               "", base::R.version$version.string), 
[16:11:04.691]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:04.691]                                 base::R.version$platform, 8 * 
[16:11:04.691]                                   base::.Machine$sizeof.pointer), 
[16:11:04.691]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:04.691]                                 "release", "version")], collapse = " "), 
[16:11:04.691]                               hostname = base::Sys.info()[["nodename"]])
[16:11:04.691]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:04.691]                               info)
[16:11:04.691]                             info <- base::paste(info, collapse = "; ")
[16:11:04.691]                             if (!has_future) {
[16:11:04.691]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:04.691]                                 info)
[16:11:04.691]                             }
[16:11:04.691]                             else {
[16:11:04.691]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:04.691]                                 info, version)
[16:11:04.691]                             }
[16:11:04.691]                             base::stop(msg)
[16:11:04.691]                           }
[16:11:04.691]                         })
[16:11:04.691]                       }
[16:11:04.691]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:04.691]                       base::options(mc.cores = 1L)
[16:11:04.691]                     }
[16:11:04.691]                     base::local({
[16:11:04.691]                       for (pkg in "future.apply") {
[16:11:04.691]                         base::loadNamespace(pkg)
[16:11:04.691]                         base::library(pkg, character.only = TRUE)
[16:11:04.691]                       }
[16:11:04.691]                     })
[16:11:04.691]                   }
[16:11:04.691]                   options(future.plan = NULL)
[16:11:04.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:04.691]                 }
[16:11:04.691]                 ...future.workdir <- getwd()
[16:11:04.691]             }
[16:11:04.691]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:04.691]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:04.691]         }
[16:11:04.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:04.691]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:04.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:04.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:04.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:04.691]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:04.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:04.691]             base::names(...future.oldOptions))
[16:11:04.691]     }
[16:11:04.691]     if (FALSE) {
[16:11:04.691]     }
[16:11:04.691]     else {
[16:11:04.691]         if (TRUE) {
[16:11:04.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:04.691]                 open = "w")
[16:11:04.691]         }
[16:11:04.691]         else {
[16:11:04.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:04.691]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:04.691]         }
[16:11:04.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:04.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:04.691]             base::sink(type = "output", split = FALSE)
[16:11:04.691]             base::close(...future.stdout)
[16:11:04.691]         }, add = TRUE)
[16:11:04.691]     }
[16:11:04.691]     ...future.frame <- base::sys.nframe()
[16:11:04.691]     ...future.conditions <- base::list()
[16:11:04.691]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:04.691]     if (FALSE) {
[16:11:04.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:04.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:04.691]     }
[16:11:04.691]     ...future.result <- base::tryCatch({
[16:11:04.691]         base::withCallingHandlers({
[16:11:04.691]             ...future.value <- base::withVisible(base::local({
[16:11:04.691]                 ...future.makeSendCondition <- local({
[16:11:04.691]                   sendCondition <- NULL
[16:11:04.691]                   function(frame = 1L) {
[16:11:04.691]                     if (is.function(sendCondition)) 
[16:11:04.691]                       return(sendCondition)
[16:11:04.691]                     ns <- getNamespace("parallel")
[16:11:04.691]                     if (exists("sendData", mode = "function", 
[16:11:04.691]                       envir = ns)) {
[16:11:04.691]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:04.691]                         envir = ns)
[16:11:04.691]                       envir <- sys.frame(frame)
[16:11:04.691]                       master <- NULL
[16:11:04.691]                       while (!identical(envir, .GlobalEnv) && 
[16:11:04.691]                         !identical(envir, emptyenv())) {
[16:11:04.691]                         if (exists("master", mode = "list", envir = envir, 
[16:11:04.691]                           inherits = FALSE)) {
[16:11:04.691]                           master <- get("master", mode = "list", 
[16:11:04.691]                             envir = envir, inherits = FALSE)
[16:11:04.691]                           if (inherits(master, c("SOCKnode", 
[16:11:04.691]                             "SOCK0node"))) {
[16:11:04.691]                             sendCondition <<- function(cond) {
[16:11:04.691]                               data <- list(type = "VALUE", value = cond, 
[16:11:04.691]                                 success = TRUE)
[16:11:04.691]                               parallel_sendData(master, data)
[16:11:04.691]                             }
[16:11:04.691]                             return(sendCondition)
[16:11:04.691]                           }
[16:11:04.691]                         }
[16:11:04.691]                         frame <- frame + 1L
[16:11:04.691]                         envir <- sys.frame(frame)
[16:11:04.691]                       }
[16:11:04.691]                     }
[16:11:04.691]                     sendCondition <<- function(cond) NULL
[16:11:04.691]                   }
[16:11:04.691]                 })
[16:11:04.691]                 withCallingHandlers({
[16:11:04.691]                   {
[16:11:04.691]                     do.call(function(...) {
[16:11:04.691]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.691]                       if (!identical(...future.globals.maxSize.org, 
[16:11:04.691]                         ...future.globals.maxSize)) {
[16:11:04.691]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.691]                         on.exit(options(oopts), add = TRUE)
[16:11:04.691]                       }
[16:11:04.691]                       {
[16:11:04.691]                         lapply(seq_along(...future.elements_ii), 
[16:11:04.691]                           FUN = function(jj) {
[16:11:04.691]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.691]                             ...future.FUN(...future.X_jj, ...)
[16:11:04.691]                           })
[16:11:04.691]                       }
[16:11:04.691]                     }, args = future.call.arguments)
[16:11:04.691]                   }
[16:11:04.691]                 }, immediateCondition = function(cond) {
[16:11:04.691]                   sendCondition <- ...future.makeSendCondition()
[16:11:04.691]                   sendCondition(cond)
[16:11:04.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.691]                   {
[16:11:04.691]                     inherits <- base::inherits
[16:11:04.691]                     invokeRestart <- base::invokeRestart
[16:11:04.691]                     is.null <- base::is.null
[16:11:04.691]                     muffled <- FALSE
[16:11:04.691]                     if (inherits(cond, "message")) {
[16:11:04.691]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:04.691]                       if (muffled) 
[16:11:04.691]                         invokeRestart("muffleMessage")
[16:11:04.691]                     }
[16:11:04.691]                     else if (inherits(cond, "warning")) {
[16:11:04.691]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:04.691]                       if (muffled) 
[16:11:04.691]                         invokeRestart("muffleWarning")
[16:11:04.691]                     }
[16:11:04.691]                     else if (inherits(cond, "condition")) {
[16:11:04.691]                       if (!is.null(pattern)) {
[16:11:04.691]                         computeRestarts <- base::computeRestarts
[16:11:04.691]                         grepl <- base::grepl
[16:11:04.691]                         restarts <- computeRestarts(cond)
[16:11:04.691]                         for (restart in restarts) {
[16:11:04.691]                           name <- restart$name
[16:11:04.691]                           if (is.null(name)) 
[16:11:04.691]                             next
[16:11:04.691]                           if (!grepl(pattern, name)) 
[16:11:04.691]                             next
[16:11:04.691]                           invokeRestart(restart)
[16:11:04.691]                           muffled <- TRUE
[16:11:04.691]                           break
[16:11:04.691]                         }
[16:11:04.691]                       }
[16:11:04.691]                     }
[16:11:04.691]                     invisible(muffled)
[16:11:04.691]                   }
[16:11:04.691]                   muffleCondition(cond)
[16:11:04.691]                 })
[16:11:04.691]             }))
[16:11:04.691]             future::FutureResult(value = ...future.value$value, 
[16:11:04.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.691]                   ...future.rng), globalenv = if (FALSE) 
[16:11:04.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:04.691]                     ...future.globalenv.names))
[16:11:04.691]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:04.691]         }, condition = base::local({
[16:11:04.691]             c <- base::c
[16:11:04.691]             inherits <- base::inherits
[16:11:04.691]             invokeRestart <- base::invokeRestart
[16:11:04.691]             length <- base::length
[16:11:04.691]             list <- base::list
[16:11:04.691]             seq.int <- base::seq.int
[16:11:04.691]             signalCondition <- base::signalCondition
[16:11:04.691]             sys.calls <- base::sys.calls
[16:11:04.691]             `[[` <- base::`[[`
[16:11:04.691]             `+` <- base::`+`
[16:11:04.691]             `<<-` <- base::`<<-`
[16:11:04.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:04.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:04.691]                   3L)]
[16:11:04.691]             }
[16:11:04.691]             function(cond) {
[16:11:04.691]                 is_error <- inherits(cond, "error")
[16:11:04.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:04.691]                   NULL)
[16:11:04.691]                 if (is_error) {
[16:11:04.691]                   sessionInformation <- function() {
[16:11:04.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:04.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:04.691]                       search = base::search(), system = base::Sys.info())
[16:11:04.691]                   }
[16:11:04.691]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:04.691]                     cond$call), session = sessionInformation(), 
[16:11:04.691]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:04.691]                   signalCondition(cond)
[16:11:04.691]                 }
[16:11:04.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:04.691]                 "immediateCondition"))) {
[16:11:04.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:04.691]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:04.691]                   if (TRUE && !signal) {
[16:11:04.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.691]                     {
[16:11:04.691]                       inherits <- base::inherits
[16:11:04.691]                       invokeRestart <- base::invokeRestart
[16:11:04.691]                       is.null <- base::is.null
[16:11:04.691]                       muffled <- FALSE
[16:11:04.691]                       if (inherits(cond, "message")) {
[16:11:04.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.691]                         if (muffled) 
[16:11:04.691]                           invokeRestart("muffleMessage")
[16:11:04.691]                       }
[16:11:04.691]                       else if (inherits(cond, "warning")) {
[16:11:04.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.691]                         if (muffled) 
[16:11:04.691]                           invokeRestart("muffleWarning")
[16:11:04.691]                       }
[16:11:04.691]                       else if (inherits(cond, "condition")) {
[16:11:04.691]                         if (!is.null(pattern)) {
[16:11:04.691]                           computeRestarts <- base::computeRestarts
[16:11:04.691]                           grepl <- base::grepl
[16:11:04.691]                           restarts <- computeRestarts(cond)
[16:11:04.691]                           for (restart in restarts) {
[16:11:04.691]                             name <- restart$name
[16:11:04.691]                             if (is.null(name)) 
[16:11:04.691]                               next
[16:11:04.691]                             if (!grepl(pattern, name)) 
[16:11:04.691]                               next
[16:11:04.691]                             invokeRestart(restart)
[16:11:04.691]                             muffled <- TRUE
[16:11:04.691]                             break
[16:11:04.691]                           }
[16:11:04.691]                         }
[16:11:04.691]                       }
[16:11:04.691]                       invisible(muffled)
[16:11:04.691]                     }
[16:11:04.691]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.691]                   }
[16:11:04.691]                 }
[16:11:04.691]                 else {
[16:11:04.691]                   if (TRUE) {
[16:11:04.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.691]                     {
[16:11:04.691]                       inherits <- base::inherits
[16:11:04.691]                       invokeRestart <- base::invokeRestart
[16:11:04.691]                       is.null <- base::is.null
[16:11:04.691]                       muffled <- FALSE
[16:11:04.691]                       if (inherits(cond, "message")) {
[16:11:04.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.691]                         if (muffled) 
[16:11:04.691]                           invokeRestart("muffleMessage")
[16:11:04.691]                       }
[16:11:04.691]                       else if (inherits(cond, "warning")) {
[16:11:04.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.691]                         if (muffled) 
[16:11:04.691]                           invokeRestart("muffleWarning")
[16:11:04.691]                       }
[16:11:04.691]                       else if (inherits(cond, "condition")) {
[16:11:04.691]                         if (!is.null(pattern)) {
[16:11:04.691]                           computeRestarts <- base::computeRestarts
[16:11:04.691]                           grepl <- base::grepl
[16:11:04.691]                           restarts <- computeRestarts(cond)
[16:11:04.691]                           for (restart in restarts) {
[16:11:04.691]                             name <- restart$name
[16:11:04.691]                             if (is.null(name)) 
[16:11:04.691]                               next
[16:11:04.691]                             if (!grepl(pattern, name)) 
[16:11:04.691]                               next
[16:11:04.691]                             invokeRestart(restart)
[16:11:04.691]                             muffled <- TRUE
[16:11:04.691]                             break
[16:11:04.691]                           }
[16:11:04.691]                         }
[16:11:04.691]                       }
[16:11:04.691]                       invisible(muffled)
[16:11:04.691]                     }
[16:11:04.691]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.691]                   }
[16:11:04.691]                 }
[16:11:04.691]             }
[16:11:04.691]         }))
[16:11:04.691]     }, error = function(ex) {
[16:11:04.691]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:04.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.691]                 ...future.rng), started = ...future.startTime, 
[16:11:04.691]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:04.691]             version = "1.8"), class = "FutureResult")
[16:11:04.691]     }, finally = {
[16:11:04.691]         if (!identical(...future.workdir, getwd())) 
[16:11:04.691]             setwd(...future.workdir)
[16:11:04.691]         {
[16:11:04.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:04.691]                 ...future.oldOptions$nwarnings <- NULL
[16:11:04.691]             }
[16:11:04.691]             base::options(...future.oldOptions)
[16:11:04.691]             if (.Platform$OS.type == "windows") {
[16:11:04.691]                 old_names <- names(...future.oldEnvVars)
[16:11:04.691]                 envs <- base::Sys.getenv()
[16:11:04.691]                 names <- names(envs)
[16:11:04.691]                 common <- intersect(names, old_names)
[16:11:04.691]                 added <- setdiff(names, old_names)
[16:11:04.691]                 removed <- setdiff(old_names, names)
[16:11:04.691]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:04.691]                   envs[common]]
[16:11:04.691]                 NAMES <- toupper(changed)
[16:11:04.691]                 args <- list()
[16:11:04.691]                 for (kk in seq_along(NAMES)) {
[16:11:04.691]                   name <- changed[[kk]]
[16:11:04.691]                   NAME <- NAMES[[kk]]
[16:11:04.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.691]                     next
[16:11:04.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.691]                 }
[16:11:04.691]                 NAMES <- toupper(added)
[16:11:04.691]                 for (kk in seq_along(NAMES)) {
[16:11:04.691]                   name <- added[[kk]]
[16:11:04.691]                   NAME <- NAMES[[kk]]
[16:11:04.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.691]                     next
[16:11:04.691]                   args[[name]] <- ""
[16:11:04.691]                 }
[16:11:04.691]                 NAMES <- toupper(removed)
[16:11:04.691]                 for (kk in seq_along(NAMES)) {
[16:11:04.691]                   name <- removed[[kk]]
[16:11:04.691]                   NAME <- NAMES[[kk]]
[16:11:04.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.691]                     next
[16:11:04.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.691]                 }
[16:11:04.691]                 if (length(args) > 0) 
[16:11:04.691]                   base::do.call(base::Sys.setenv, args = args)
[16:11:04.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:04.691]             }
[16:11:04.691]             else {
[16:11:04.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:04.691]             }
[16:11:04.691]             {
[16:11:04.691]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:04.691]                   0L) {
[16:11:04.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:04.691]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:04.691]                   base::options(opts)
[16:11:04.691]                 }
[16:11:04.691]                 {
[16:11:04.691]                   {
[16:11:04.691]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:04.691]                     NULL
[16:11:04.691]                   }
[16:11:04.691]                   options(future.plan = NULL)
[16:11:04.691]                   if (is.na(NA_character_)) 
[16:11:04.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:04.691]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:04.691]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:04.691]                     envir = parent.frame()) 
[16:11:04.691]                   {
[16:11:04.691]                     if (is.function(workers)) 
[16:11:04.691]                       workers <- workers()
[16:11:04.691]                     workers <- structure(as.integer(workers), 
[16:11:04.691]                       class = class(workers))
[16:11:04.691]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:04.691]                       workers >= 1)
[16:11:04.691]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:04.691]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:04.691]                     }
[16:11:04.691]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:04.691]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:04.691]                       envir = envir)
[16:11:04.691]                     if (!future$lazy) 
[16:11:04.691]                       future <- run(future)
[16:11:04.691]                     invisible(future)
[16:11:04.691]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:04.691]                 }
[16:11:04.691]             }
[16:11:04.691]         }
[16:11:04.691]     })
[16:11:04.691]     if (TRUE) {
[16:11:04.691]         base::sink(type = "output", split = FALSE)
[16:11:04.691]         if (TRUE) {
[16:11:04.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:04.691]         }
[16:11:04.691]         else {
[16:11:04.691]             ...future.result["stdout"] <- base::list(NULL)
[16:11:04.691]         }
[16:11:04.691]         base::close(...future.stdout)
[16:11:04.691]         ...future.stdout <- NULL
[16:11:04.691]     }
[16:11:04.691]     ...future.result$conditions <- ...future.conditions
[16:11:04.691]     ...future.result$finished <- base::Sys.time()
[16:11:04.691]     ...future.result
[16:11:04.691] }
[16:11:04.694] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[16:11:04.694] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:04.736] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:04.736] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:11:04.736] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:11:04.737] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:04.737] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:04.737] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:04.780] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:04.780] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:04.824] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:04.824] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:04.824] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.825] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:04.825] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:04.825] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:04.826] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.826] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:11:04.826] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:11:04.826] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:04.827] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.827] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:04.827] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:04.827] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[16:11:04.828] MultisessionFuture started
[16:11:04.828] - Launch lazy future ... done
[16:11:04.828] run() for ‘MultisessionFuture’ ... done
[16:11:04.828] Created future:
[16:11:04.828] MultisessionFuture:
[16:11:04.828] Label: ‘future_vapply-1’
[16:11:04.828] Expression:
[16:11:04.828] {
[16:11:04.828]     do.call(function(...) {
[16:11:04.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.828]             on.exit(options(oopts), add = TRUE)
[16:11:04.828]         }
[16:11:04.828]         {
[16:11:04.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.828]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.828]             })
[16:11:04.828]         }
[16:11:04.828]     }, args = future.call.arguments)
[16:11:04.828] }
[16:11:04.828] Lazy evaluation: FALSE
[16:11:04.828] Asynchronous evaluation: TRUE
[16:11:04.828] Local evaluation: TRUE
[16:11:04.828] Environment: R_GlobalEnv
[16:11:04.828] Capture standard output: TRUE
[16:11:04.828] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:04.828] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:04.828] Packages: 1 packages (‘future.apply’)
[16:11:04.828] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:04.828] Resolved: FALSE
[16:11:04.828] Value: <not collected>
[16:11:04.828] Conditions captured: <none>
[16:11:04.828] Early signaling: FALSE
[16:11:04.828] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:04.828] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.842] Chunk #1 of 2 ... DONE
[16:11:04.843] Chunk #2 of 2 ...
[16:11:04.843]  - Finding globals in 'X' for chunk #2 ...
[16:11:04.843] getGlobalsAndPackages() ...
[16:11:04.843] Searching for globals...
[16:11:04.843] 
[16:11:04.843] Searching for globals ... DONE
[16:11:04.843] - globals: [0] <none>
[16:11:04.843] getGlobalsAndPackages() ... DONE
[16:11:04.844]    + additional globals found: [n=0] 
[16:11:04.844]    + additional namespaces needed: [n=0] 
[16:11:04.844]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:04.844]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:04.844]  - seeds: <none>
[16:11:04.844] getGlobalsAndPackages() ...
[16:11:04.844] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.844] Resolving globals: FALSE
[16:11:04.844] Tweak future expression to call with '...' arguments ...
[16:11:04.844] {
[16:11:04.844]     do.call(function(...) {
[16:11:04.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:04.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.844]             on.exit(options(oopts), add = TRUE)
[16:11:04.844]         }
[16:11:04.844]         {
[16:11:04.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:04.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.844]                 ...future.FUN(...future.X_jj, ...)
[16:11:04.844]             })
[16:11:04.844]         }
[16:11:04.844]     }, args = future.call.arguments)
[16:11:04.844] }
[16:11:04.845] Tweak future expression to call with '...' arguments ... DONE
[16:11:04.845] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:04.845] - packages: [1] ‘future.apply’
[16:11:04.846] getGlobalsAndPackages() ... DONE
[16:11:04.846] run() for ‘Future’ ...
[16:11:04.846] - state: ‘created’
[16:11:04.846] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:04.861] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:04.861] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:04.861]   - Field: ‘node’
[16:11:04.861]   - Field: ‘label’
[16:11:04.861]   - Field: ‘local’
[16:11:04.861]   - Field: ‘owner’
[16:11:04.861]   - Field: ‘envir’
[16:11:04.862]   - Field: ‘workers’
[16:11:04.862]   - Field: ‘packages’
[16:11:04.862]   - Field: ‘gc’
[16:11:04.862]   - Field: ‘conditions’
[16:11:04.862]   - Field: ‘persistent’
[16:11:04.862]   - Field: ‘expr’
[16:11:04.862]   - Field: ‘uuid’
[16:11:04.862]   - Field: ‘seed’
[16:11:04.862]   - Field: ‘version’
[16:11:04.862]   - Field: ‘result’
[16:11:04.862]   - Field: ‘asynchronous’
[16:11:04.863]   - Field: ‘calls’
[16:11:04.863]   - Field: ‘globals’
[16:11:04.863]   - Field: ‘stdout’
[16:11:04.863]   - Field: ‘earlySignal’
[16:11:04.863]   - Field: ‘lazy’
[16:11:04.863]   - Field: ‘state’
[16:11:04.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:04.863] - Launch lazy future ...
[16:11:04.863] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:04.864] Packages needed by future strategies (n = 0): <none>
[16:11:04.864] {
[16:11:04.864]     {
[16:11:04.864]         {
[16:11:04.864]             ...future.startTime <- base::Sys.time()
[16:11:04.864]             {
[16:11:04.864]                 {
[16:11:04.864]                   {
[16:11:04.864]                     {
[16:11:04.864]                       {
[16:11:04.864]                         base::local({
[16:11:04.864]                           has_future <- base::requireNamespace("future", 
[16:11:04.864]                             quietly = TRUE)
[16:11:04.864]                           if (has_future) {
[16:11:04.864]                             ns <- base::getNamespace("future")
[16:11:04.864]                             version <- ns[[".package"]][["version"]]
[16:11:04.864]                             if (is.null(version)) 
[16:11:04.864]                               version <- utils::packageVersion("future")
[16:11:04.864]                           }
[16:11:04.864]                           else {
[16:11:04.864]                             version <- NULL
[16:11:04.864]                           }
[16:11:04.864]                           if (!has_future || version < "1.8.0") {
[16:11:04.864]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:04.864]                               "", base::R.version$version.string), 
[16:11:04.864]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:04.864]                                 base::R.version$platform, 8 * 
[16:11:04.864]                                   base::.Machine$sizeof.pointer), 
[16:11:04.864]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:04.864]                                 "release", "version")], collapse = " "), 
[16:11:04.864]                               hostname = base::Sys.info()[["nodename"]])
[16:11:04.864]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:04.864]                               info)
[16:11:04.864]                             info <- base::paste(info, collapse = "; ")
[16:11:04.864]                             if (!has_future) {
[16:11:04.864]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:04.864]                                 info)
[16:11:04.864]                             }
[16:11:04.864]                             else {
[16:11:04.864]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:04.864]                                 info, version)
[16:11:04.864]                             }
[16:11:04.864]                             base::stop(msg)
[16:11:04.864]                           }
[16:11:04.864]                         })
[16:11:04.864]                       }
[16:11:04.864]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:04.864]                       base::options(mc.cores = 1L)
[16:11:04.864]                     }
[16:11:04.864]                     base::local({
[16:11:04.864]                       for (pkg in "future.apply") {
[16:11:04.864]                         base::loadNamespace(pkg)
[16:11:04.864]                         base::library(pkg, character.only = TRUE)
[16:11:04.864]                       }
[16:11:04.864]                     })
[16:11:04.864]                   }
[16:11:04.864]                   options(future.plan = NULL)
[16:11:04.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:04.864]                 }
[16:11:04.864]                 ...future.workdir <- getwd()
[16:11:04.864]             }
[16:11:04.864]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:04.864]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:04.864]         }
[16:11:04.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:04.864]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:04.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:04.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:04.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:04.864]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:04.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:04.864]             base::names(...future.oldOptions))
[16:11:04.864]     }
[16:11:04.864]     if (FALSE) {
[16:11:04.864]     }
[16:11:04.864]     else {
[16:11:04.864]         if (TRUE) {
[16:11:04.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:04.864]                 open = "w")
[16:11:04.864]         }
[16:11:04.864]         else {
[16:11:04.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:04.864]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:04.864]         }
[16:11:04.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:04.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:04.864]             base::sink(type = "output", split = FALSE)
[16:11:04.864]             base::close(...future.stdout)
[16:11:04.864]         }, add = TRUE)
[16:11:04.864]     }
[16:11:04.864]     ...future.frame <- base::sys.nframe()
[16:11:04.864]     ...future.conditions <- base::list()
[16:11:04.864]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:04.864]     if (FALSE) {
[16:11:04.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:04.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:04.864]     }
[16:11:04.864]     ...future.result <- base::tryCatch({
[16:11:04.864]         base::withCallingHandlers({
[16:11:04.864]             ...future.value <- base::withVisible(base::local({
[16:11:04.864]                 ...future.makeSendCondition <- local({
[16:11:04.864]                   sendCondition <- NULL
[16:11:04.864]                   function(frame = 1L) {
[16:11:04.864]                     if (is.function(sendCondition)) 
[16:11:04.864]                       return(sendCondition)
[16:11:04.864]                     ns <- getNamespace("parallel")
[16:11:04.864]                     if (exists("sendData", mode = "function", 
[16:11:04.864]                       envir = ns)) {
[16:11:04.864]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:04.864]                         envir = ns)
[16:11:04.864]                       envir <- sys.frame(frame)
[16:11:04.864]                       master <- NULL
[16:11:04.864]                       while (!identical(envir, .GlobalEnv) && 
[16:11:04.864]                         !identical(envir, emptyenv())) {
[16:11:04.864]                         if (exists("master", mode = "list", envir = envir, 
[16:11:04.864]                           inherits = FALSE)) {
[16:11:04.864]                           master <- get("master", mode = "list", 
[16:11:04.864]                             envir = envir, inherits = FALSE)
[16:11:04.864]                           if (inherits(master, c("SOCKnode", 
[16:11:04.864]                             "SOCK0node"))) {
[16:11:04.864]                             sendCondition <<- function(cond) {
[16:11:04.864]                               data <- list(type = "VALUE", value = cond, 
[16:11:04.864]                                 success = TRUE)
[16:11:04.864]                               parallel_sendData(master, data)
[16:11:04.864]                             }
[16:11:04.864]                             return(sendCondition)
[16:11:04.864]                           }
[16:11:04.864]                         }
[16:11:04.864]                         frame <- frame + 1L
[16:11:04.864]                         envir <- sys.frame(frame)
[16:11:04.864]                       }
[16:11:04.864]                     }
[16:11:04.864]                     sendCondition <<- function(cond) NULL
[16:11:04.864]                   }
[16:11:04.864]                 })
[16:11:04.864]                 withCallingHandlers({
[16:11:04.864]                   {
[16:11:04.864]                     do.call(function(...) {
[16:11:04.864]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:04.864]                       if (!identical(...future.globals.maxSize.org, 
[16:11:04.864]                         ...future.globals.maxSize)) {
[16:11:04.864]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:04.864]                         on.exit(options(oopts), add = TRUE)
[16:11:04.864]                       }
[16:11:04.864]                       {
[16:11:04.864]                         lapply(seq_along(...future.elements_ii), 
[16:11:04.864]                           FUN = function(jj) {
[16:11:04.864]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:04.864]                             ...future.FUN(...future.X_jj, ...)
[16:11:04.864]                           })
[16:11:04.864]                       }
[16:11:04.864]                     }, args = future.call.arguments)
[16:11:04.864]                   }
[16:11:04.864]                 }, immediateCondition = function(cond) {
[16:11:04.864]                   sendCondition <- ...future.makeSendCondition()
[16:11:04.864]                   sendCondition(cond)
[16:11:04.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.864]                   {
[16:11:04.864]                     inherits <- base::inherits
[16:11:04.864]                     invokeRestart <- base::invokeRestart
[16:11:04.864]                     is.null <- base::is.null
[16:11:04.864]                     muffled <- FALSE
[16:11:04.864]                     if (inherits(cond, "message")) {
[16:11:04.864]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:04.864]                       if (muffled) 
[16:11:04.864]                         invokeRestart("muffleMessage")
[16:11:04.864]                     }
[16:11:04.864]                     else if (inherits(cond, "warning")) {
[16:11:04.864]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:04.864]                       if (muffled) 
[16:11:04.864]                         invokeRestart("muffleWarning")
[16:11:04.864]                     }
[16:11:04.864]                     else if (inherits(cond, "condition")) {
[16:11:04.864]                       if (!is.null(pattern)) {
[16:11:04.864]                         computeRestarts <- base::computeRestarts
[16:11:04.864]                         grepl <- base::grepl
[16:11:04.864]                         restarts <- computeRestarts(cond)
[16:11:04.864]                         for (restart in restarts) {
[16:11:04.864]                           name <- restart$name
[16:11:04.864]                           if (is.null(name)) 
[16:11:04.864]                             next
[16:11:04.864]                           if (!grepl(pattern, name)) 
[16:11:04.864]                             next
[16:11:04.864]                           invokeRestart(restart)
[16:11:04.864]                           muffled <- TRUE
[16:11:04.864]                           break
[16:11:04.864]                         }
[16:11:04.864]                       }
[16:11:04.864]                     }
[16:11:04.864]                     invisible(muffled)
[16:11:04.864]                   }
[16:11:04.864]                   muffleCondition(cond)
[16:11:04.864]                 })
[16:11:04.864]             }))
[16:11:04.864]             future::FutureResult(value = ...future.value$value, 
[16:11:04.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.864]                   ...future.rng), globalenv = if (FALSE) 
[16:11:04.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:04.864]                     ...future.globalenv.names))
[16:11:04.864]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:04.864]         }, condition = base::local({
[16:11:04.864]             c <- base::c
[16:11:04.864]             inherits <- base::inherits
[16:11:04.864]             invokeRestart <- base::invokeRestart
[16:11:04.864]             length <- base::length
[16:11:04.864]             list <- base::list
[16:11:04.864]             seq.int <- base::seq.int
[16:11:04.864]             signalCondition <- base::signalCondition
[16:11:04.864]             sys.calls <- base::sys.calls
[16:11:04.864]             `[[` <- base::`[[`
[16:11:04.864]             `+` <- base::`+`
[16:11:04.864]             `<<-` <- base::`<<-`
[16:11:04.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:04.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:04.864]                   3L)]
[16:11:04.864]             }
[16:11:04.864]             function(cond) {
[16:11:04.864]                 is_error <- inherits(cond, "error")
[16:11:04.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:04.864]                   NULL)
[16:11:04.864]                 if (is_error) {
[16:11:04.864]                   sessionInformation <- function() {
[16:11:04.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:04.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:04.864]                       search = base::search(), system = base::Sys.info())
[16:11:04.864]                   }
[16:11:04.864]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:04.864]                     cond$call), session = sessionInformation(), 
[16:11:04.864]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:04.864]                   signalCondition(cond)
[16:11:04.864]                 }
[16:11:04.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:04.864]                 "immediateCondition"))) {
[16:11:04.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:04.864]                   ...future.conditions[[length(...future.conditions) + 
[16:11:04.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:04.864]                   if (TRUE && !signal) {
[16:11:04.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.864]                     {
[16:11:04.864]                       inherits <- base::inherits
[16:11:04.864]                       invokeRestart <- base::invokeRestart
[16:11:04.864]                       is.null <- base::is.null
[16:11:04.864]                       muffled <- FALSE
[16:11:04.864]                       if (inherits(cond, "message")) {
[16:11:04.864]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.864]                         if (muffled) 
[16:11:04.864]                           invokeRestart("muffleMessage")
[16:11:04.864]                       }
[16:11:04.864]                       else if (inherits(cond, "warning")) {
[16:11:04.864]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.864]                         if (muffled) 
[16:11:04.864]                           invokeRestart("muffleWarning")
[16:11:04.864]                       }
[16:11:04.864]                       else if (inherits(cond, "condition")) {
[16:11:04.864]                         if (!is.null(pattern)) {
[16:11:04.864]                           computeRestarts <- base::computeRestarts
[16:11:04.864]                           grepl <- base::grepl
[16:11:04.864]                           restarts <- computeRestarts(cond)
[16:11:04.864]                           for (restart in restarts) {
[16:11:04.864]                             name <- restart$name
[16:11:04.864]                             if (is.null(name)) 
[16:11:04.864]                               next
[16:11:04.864]                             if (!grepl(pattern, name)) 
[16:11:04.864]                               next
[16:11:04.864]                             invokeRestart(restart)
[16:11:04.864]                             muffled <- TRUE
[16:11:04.864]                             break
[16:11:04.864]                           }
[16:11:04.864]                         }
[16:11:04.864]                       }
[16:11:04.864]                       invisible(muffled)
[16:11:04.864]                     }
[16:11:04.864]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.864]                   }
[16:11:04.864]                 }
[16:11:04.864]                 else {
[16:11:04.864]                   if (TRUE) {
[16:11:04.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:04.864]                     {
[16:11:04.864]                       inherits <- base::inherits
[16:11:04.864]                       invokeRestart <- base::invokeRestart
[16:11:04.864]                       is.null <- base::is.null
[16:11:04.864]                       muffled <- FALSE
[16:11:04.864]                       if (inherits(cond, "message")) {
[16:11:04.864]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:04.864]                         if (muffled) 
[16:11:04.864]                           invokeRestart("muffleMessage")
[16:11:04.864]                       }
[16:11:04.864]                       else if (inherits(cond, "warning")) {
[16:11:04.864]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:04.864]                         if (muffled) 
[16:11:04.864]                           invokeRestart("muffleWarning")
[16:11:04.864]                       }
[16:11:04.864]                       else if (inherits(cond, "condition")) {
[16:11:04.864]                         if (!is.null(pattern)) {
[16:11:04.864]                           computeRestarts <- base::computeRestarts
[16:11:04.864]                           grepl <- base::grepl
[16:11:04.864]                           restarts <- computeRestarts(cond)
[16:11:04.864]                           for (restart in restarts) {
[16:11:04.864]                             name <- restart$name
[16:11:04.864]                             if (is.null(name)) 
[16:11:04.864]                               next
[16:11:04.864]                             if (!grepl(pattern, name)) 
[16:11:04.864]                               next
[16:11:04.864]                             invokeRestart(restart)
[16:11:04.864]                             muffled <- TRUE
[16:11:04.864]                             break
[16:11:04.864]                           }
[16:11:04.864]                         }
[16:11:04.864]                       }
[16:11:04.864]                       invisible(muffled)
[16:11:04.864]                     }
[16:11:04.864]                     muffleCondition(cond, pattern = "^muffle")
[16:11:04.864]                   }
[16:11:04.864]                 }
[16:11:04.864]             }
[16:11:04.864]         }))
[16:11:04.864]     }, error = function(ex) {
[16:11:04.864]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:04.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:04.864]                 ...future.rng), started = ...future.startTime, 
[16:11:04.864]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:04.864]             version = "1.8"), class = "FutureResult")
[16:11:04.864]     }, finally = {
[16:11:04.864]         if (!identical(...future.workdir, getwd())) 
[16:11:04.864]             setwd(...future.workdir)
[16:11:04.864]         {
[16:11:04.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:04.864]                 ...future.oldOptions$nwarnings <- NULL
[16:11:04.864]             }
[16:11:04.864]             base::options(...future.oldOptions)
[16:11:04.864]             if (.Platform$OS.type == "windows") {
[16:11:04.864]                 old_names <- names(...future.oldEnvVars)
[16:11:04.864]                 envs <- base::Sys.getenv()
[16:11:04.864]                 names <- names(envs)
[16:11:04.864]                 common <- intersect(names, old_names)
[16:11:04.864]                 added <- setdiff(names, old_names)
[16:11:04.864]                 removed <- setdiff(old_names, names)
[16:11:04.864]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:04.864]                   envs[common]]
[16:11:04.864]                 NAMES <- toupper(changed)
[16:11:04.864]                 args <- list()
[16:11:04.864]                 for (kk in seq_along(NAMES)) {
[16:11:04.864]                   name <- changed[[kk]]
[16:11:04.864]                   NAME <- NAMES[[kk]]
[16:11:04.864]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.864]                     next
[16:11:04.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.864]                 }
[16:11:04.864]                 NAMES <- toupper(added)
[16:11:04.864]                 for (kk in seq_along(NAMES)) {
[16:11:04.864]                   name <- added[[kk]]
[16:11:04.864]                   NAME <- NAMES[[kk]]
[16:11:04.864]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.864]                     next
[16:11:04.864]                   args[[name]] <- ""
[16:11:04.864]                 }
[16:11:04.864]                 NAMES <- toupper(removed)
[16:11:04.864]                 for (kk in seq_along(NAMES)) {
[16:11:04.864]                   name <- removed[[kk]]
[16:11:04.864]                   NAME <- NAMES[[kk]]
[16:11:04.864]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:04.864]                     next
[16:11:04.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:04.864]                 }
[16:11:04.864]                 if (length(args) > 0) 
[16:11:04.864]                   base::do.call(base::Sys.setenv, args = args)
[16:11:04.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:04.864]             }
[16:11:04.864]             else {
[16:11:04.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:04.864]             }
[16:11:04.864]             {
[16:11:04.864]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:04.864]                   0L) {
[16:11:04.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:04.864]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:04.864]                   base::options(opts)
[16:11:04.864]                 }
[16:11:04.864]                 {
[16:11:04.864]                   {
[16:11:04.864]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:04.864]                     NULL
[16:11:04.864]                   }
[16:11:04.864]                   options(future.plan = NULL)
[16:11:04.864]                   if (is.na(NA_character_)) 
[16:11:04.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:04.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:04.864]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:04.864]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:04.864]                     envir = parent.frame()) 
[16:11:04.864]                   {
[16:11:04.864]                     if (is.function(workers)) 
[16:11:04.864]                       workers <- workers()
[16:11:04.864]                     workers <- structure(as.integer(workers), 
[16:11:04.864]                       class = class(workers))
[16:11:04.864]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:04.864]                       workers >= 1)
[16:11:04.864]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:04.864]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:04.864]                     }
[16:11:04.864]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:04.864]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:04.864]                       envir = envir)
[16:11:04.864]                     if (!future$lazy) 
[16:11:04.864]                       future <- run(future)
[16:11:04.864]                     invisible(future)
[16:11:04.864]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:04.864]                 }
[16:11:04.864]             }
[16:11:04.864]         }
[16:11:04.864]     })
[16:11:04.864]     if (TRUE) {
[16:11:04.864]         base::sink(type = "output", split = FALSE)
[16:11:04.864]         if (TRUE) {
[16:11:04.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:04.864]         }
[16:11:04.864]         else {
[16:11:04.864]             ...future.result["stdout"] <- base::list(NULL)
[16:11:04.864]         }
[16:11:04.864]         base::close(...future.stdout)
[16:11:04.864]         ...future.stdout <- NULL
[16:11:04.864]     }
[16:11:04.864]     ...future.result$conditions <- ...future.conditions
[16:11:04.864]     ...future.result$finished <- base::Sys.time()
[16:11:04.864]     ...future.result
[16:11:04.864] }
[16:11:04.867] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[16:11:04.867] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:04.908] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:04.908] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:11:04.909] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:11:04.909] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:04.909] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:04.909] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:04.952] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:04.952] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:04.996] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:04.996] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:04.996] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.996] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:04.997] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:04.997] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:04.997] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.998] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:11:04.998] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:11:04.998] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:04.998] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.999] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:04.999] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:04.999] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[16:11:05.000] MultisessionFuture started
[16:11:05.000] - Launch lazy future ... done
[16:11:05.000] run() for ‘MultisessionFuture’ ... done
[16:11:05.000] Created future:
[16:11:05.000] MultisessionFuture:
[16:11:05.000] Label: ‘future_vapply-2’
[16:11:05.000] Expression:
[16:11:05.000] {
[16:11:05.000]     do.call(function(...) {
[16:11:05.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.000]             on.exit(options(oopts), add = TRUE)
[16:11:05.000]         }
[16:11:05.000]         {
[16:11:05.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.000]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.000]             })
[16:11:05.000]         }
[16:11:05.000]     }, args = future.call.arguments)
[16:11:05.000] }
[16:11:05.000] Lazy evaluation: FALSE
[16:11:05.000] Asynchronous evaluation: TRUE
[16:11:05.000] Local evaluation: TRUE
[16:11:05.000] Environment: R_GlobalEnv
[16:11:05.000] Capture standard output: TRUE
[16:11:05.000] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:05.000] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:05.000] Packages: 1 packages (‘future.apply’)
[16:11:05.000] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:05.000] Resolved: FALSE
[16:11:05.000] Value: <not collected>
[16:11:05.000] Conditions captured: <none>
[16:11:05.000] Early signaling: FALSE
[16:11:05.000] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:05.000] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.012] Chunk #2 of 2 ... DONE
[16:11:05.012] Launching 2 futures (chunks) ... DONE
[16:11:05.012] Resolving 2 futures (chunks) ...
[16:11:05.012] resolve() on list ...
[16:11:05.012]  recursive: 0
[16:11:05.013]  length: 2
[16:11:05.013] 
[16:11:05.013] receiveMessageFromWorker() for ClusterFuture ...
[16:11:05.013] - Validating connection of MultisessionFuture
[16:11:05.013] - received message: FutureResult
[16:11:05.013] - Received FutureResult
[16:11:05.014] - Erased future from FutureRegistry
[16:11:05.014] result() for ClusterFuture ...
[16:11:05.014] - result already collected: FutureResult
[16:11:05.014] result() for ClusterFuture ... done
[16:11:05.014] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:05.014] Future #1
[16:11:05.014] result() for ClusterFuture ...
[16:11:05.014] - result already collected: FutureResult
[16:11:05.014] result() for ClusterFuture ... done
[16:11:05.014] result() for ClusterFuture ...
[16:11:05.014] - result already collected: FutureResult
[16:11:05.014] result() for ClusterFuture ... done
[16:11:05.015] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:05.015] - nx: 2
[16:11:05.015] - relay: TRUE
[16:11:05.015] - stdout: TRUE
[16:11:05.015] - signal: TRUE
[16:11:05.015] - resignal: FALSE
[16:11:05.015] - force: TRUE
[16:11:05.015] - relayed: [n=2] FALSE, FALSE
[16:11:05.015] - queued futures: [n=2] FALSE, FALSE
[16:11:05.015]  - until=1
[16:11:05.015]  - relaying element #1
[16:11:05.015] result() for ClusterFuture ...
[16:11:05.016] - result already collected: FutureResult
[16:11:05.016] result() for ClusterFuture ... done
[16:11:05.016] result() for ClusterFuture ...
[16:11:05.016] - result already collected: FutureResult
[16:11:05.016] result() for ClusterFuture ... done
[16:11:05.016] result() for ClusterFuture ...
[16:11:05.016] - result already collected: FutureResult
[16:11:05.016] result() for ClusterFuture ... done
[16:11:05.016] result() for ClusterFuture ...
[16:11:05.016] - result already collected: FutureResult
[16:11:05.016] result() for ClusterFuture ... done
[16:11:05.017] - relayed: [n=2] TRUE, FALSE
[16:11:05.017] - queued futures: [n=2] TRUE, FALSE
[16:11:05.017] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:05.017]  length: 1 (resolved future 1)
[16:11:05.058] receiveMessageFromWorker() for ClusterFuture ...
[16:11:05.059] - Validating connection of MultisessionFuture
[16:11:05.059] - received message: FutureResult
[16:11:05.059] - Received FutureResult
[16:11:05.059] - Erased future from FutureRegistry
[16:11:05.059] result() for ClusterFuture ...
[16:11:05.059] - result already collected: FutureResult
[16:11:05.059] result() for ClusterFuture ... done
[16:11:05.059] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:05.059] Future #2
[16:11:05.059] result() for ClusterFuture ...
[16:11:05.060] - result already collected: FutureResult
[16:11:05.060] result() for ClusterFuture ... done
[16:11:05.060] result() for ClusterFuture ...
[16:11:05.060] - result already collected: FutureResult
[16:11:05.060] result() for ClusterFuture ... done
[16:11:05.060] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:05.060] - nx: 2
[16:11:05.060] - relay: TRUE
[16:11:05.060] - stdout: TRUE
[16:11:05.060] - signal: TRUE
[16:11:05.061] - resignal: FALSE
[16:11:05.061] - force: TRUE
[16:11:05.061] - relayed: [n=2] TRUE, FALSE
[16:11:05.061] - queued futures: [n=2] TRUE, FALSE
[16:11:05.061]  - until=2
[16:11:05.061]  - relaying element #2
[16:11:05.061] result() for ClusterFuture ...
[16:11:05.061] - result already collected: FutureResult
[16:11:05.061] result() for ClusterFuture ... done
[16:11:05.061] result() for ClusterFuture ...
[16:11:05.061] - result already collected: FutureResult
[16:11:05.061] result() for ClusterFuture ... done
[16:11:05.062] result() for ClusterFuture ...
[16:11:05.062] - result already collected: FutureResult
[16:11:05.062] result() for ClusterFuture ... done
[16:11:05.062] result() for ClusterFuture ...
[16:11:05.062] - result already collected: FutureResult
[16:11:05.062] result() for ClusterFuture ... done
[16:11:05.062] - relayed: [n=2] TRUE, TRUE
[16:11:05.062] - queued futures: [n=2] TRUE, TRUE
[16:11:05.062] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:05.062]  length: 0 (resolved future 2)
[16:11:05.062] Relaying remaining futures
[16:11:05.063] signalConditionsASAP(NULL, pos=0) ...
[16:11:05.063] - nx: 2
[16:11:05.063] - relay: TRUE
[16:11:05.063] - stdout: TRUE
[16:11:05.063] - signal: TRUE
[16:11:05.063] - resignal: FALSE
[16:11:05.063] - force: TRUE
[16:11:05.063] - relayed: [n=2] TRUE, TRUE
[16:11:05.063] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:05.063] - relayed: [n=2] TRUE, TRUE
[16:11:05.063] - queued futures: [n=2] TRUE, TRUE
[16:11:05.063] signalConditionsASAP(NULL, pos=0) ... done
[16:11:05.064] resolve() on list ... DONE
[16:11:05.064] result() for ClusterFuture ...
[16:11:05.064] - result already collected: FutureResult
[16:11:05.064] result() for ClusterFuture ... done
[16:11:05.064] result() for ClusterFuture ...
[16:11:05.064] - result already collected: FutureResult
[16:11:05.064] result() for ClusterFuture ... done
[16:11:05.064] result() for ClusterFuture ...
[16:11:05.064] - result already collected: FutureResult
[16:11:05.064] result() for ClusterFuture ... done
[16:11:05.064] result() for ClusterFuture ...
[16:11:05.065] - result already collected: FutureResult
[16:11:05.065] result() for ClusterFuture ... done
[16:11:05.065]  - Number of value chunks collected: 2
[16:11:05.065] Resolving 2 futures (chunks) ... DONE
[16:11:05.065] Reducing values from 2 chunks ...
[16:11:05.065]  - Number of values collected after concatenation: 10
[16:11:05.065]  - Number of values expected: 10
[16:11:05.065] Reducing values from 2 chunks ... DONE
[16:11:05.065] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[16:11:05.066] future_lapply() ...
[16:11:05.071] Number of chunks: 2
[16:11:05.071] getGlobalsAndPackagesXApply() ...
[16:11:05.071]  - future.globals: TRUE
[16:11:05.071] getGlobalsAndPackages() ...
[16:11:05.072] Searching for globals...
[16:11:05.075] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[16:11:05.075] Searching for globals ... DONE
[16:11:05.075] Resolving globals: FALSE
[16:11:05.076] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[16:11:05.077] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:05.077] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:05.077] - packages: [1] ‘future.apply’
[16:11:05.077] getGlobalsAndPackages() ... DONE
[16:11:05.077]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:05.077]  - needed namespaces: [n=1] ‘future.apply’
[16:11:05.077] Finding globals ... DONE
[16:11:05.077]  - use_args: TRUE
[16:11:05.078]  - Getting '...' globals ...
[16:11:05.078] resolve() on list ...
[16:11:05.078]  recursive: 0
[16:11:05.078]  length: 1
[16:11:05.078]  elements: ‘...’
[16:11:05.078]  length: 0 (resolved future 1)
[16:11:05.078] resolve() on list ... DONE
[16:11:05.078]    - '...' content: [n=0] 
[16:11:05.078] List of 1
[16:11:05.078]  $ ...: list()
[16:11:05.078]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:05.078]  - attr(*, "where")=List of 1
[16:11:05.078]   ..$ ...:<environment: 0x561e8b6ddad0> 
[16:11:05.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:05.078]  - attr(*, "resolved")= logi TRUE
[16:11:05.078]  - attr(*, "total_size")= num NA
[16:11:05.081]  - Getting '...' globals ... DONE
[16:11:05.081] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:05.081] List of 8
[16:11:05.081]  $ ...future.FUN:function (x, ...)  
[16:11:05.081]  $ x_FUN        :function (x)  
[16:11:05.081]  $ times        : int 2
[16:11:05.081]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:05.081]  $ stop_if_not  :function (...)  
[16:11:05.081]  $ dim          : NULL
[16:11:05.081]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:05.081]  $ ...          : list()
[16:11:05.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:05.081]  - attr(*, "where")=List of 8
[16:11:05.081]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:05.081]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:05.081]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:05.081]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:05.081]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:05.081]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:05.081]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:05.081]   ..$ ...          :<environment: 0x561e8b6ddad0> 
[16:11:05.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:05.081]  - attr(*, "resolved")= logi FALSE
[16:11:05.081]  - attr(*, "total_size")= num 96456
[16:11:05.086] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:05.087] getGlobalsAndPackagesXApply() ... DONE
[16:11:05.087] Number of futures (= number of chunks): 2
[16:11:05.087] Launching 2 futures (chunks) ...
[16:11:05.087] Chunk #1 of 2 ...
[16:11:05.087]  - Finding globals in 'X' for chunk #1 ...
[16:11:05.087] getGlobalsAndPackages() ...
[16:11:05.087] Searching for globals...
[16:11:05.087] 
[16:11:05.088] Searching for globals ... DONE
[16:11:05.088] - globals: [0] <none>
[16:11:05.088] getGlobalsAndPackages() ... DONE
[16:11:05.088]    + additional globals found: [n=0] 
[16:11:05.088]    + additional namespaces needed: [n=0] 
[16:11:05.088]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:05.088]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:05.088]  - seeds: <none>
[16:11:05.088] getGlobalsAndPackages() ...
[16:11:05.088] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.089] Resolving globals: FALSE
[16:11:05.089] Tweak future expression to call with '...' arguments ...
[16:11:05.089] {
[16:11:05.089]     do.call(function(...) {
[16:11:05.089]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.089]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.089]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.089]             on.exit(options(oopts), add = TRUE)
[16:11:05.089]         }
[16:11:05.089]         {
[16:11:05.089]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.089]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.089]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.089]             })
[16:11:05.089]         }
[16:11:05.089]     }, args = future.call.arguments)
[16:11:05.089] }
[16:11:05.089] Tweak future expression to call with '...' arguments ... DONE
[16:11:05.089] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.090] - packages: [1] ‘future.apply’
[16:11:05.090] getGlobalsAndPackages() ... DONE
[16:11:05.090] run() for ‘Future’ ...
[16:11:05.090] - state: ‘created’
[16:11:05.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:05.105] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:05.105]   - Field: ‘node’
[16:11:05.105]   - Field: ‘label’
[16:11:05.105]   - Field: ‘local’
[16:11:05.105]   - Field: ‘owner’
[16:11:05.106]   - Field: ‘envir’
[16:11:05.106]   - Field: ‘workers’
[16:11:05.106]   - Field: ‘packages’
[16:11:05.106]   - Field: ‘gc’
[16:11:05.106]   - Field: ‘conditions’
[16:11:05.106]   - Field: ‘persistent’
[16:11:05.106]   - Field: ‘expr’
[16:11:05.106]   - Field: ‘uuid’
[16:11:05.106]   - Field: ‘seed’
[16:11:05.106]   - Field: ‘version’
[16:11:05.106]   - Field: ‘result’
[16:11:05.107]   - Field: ‘asynchronous’
[16:11:05.107]   - Field: ‘calls’
[16:11:05.107]   - Field: ‘globals’
[16:11:05.107]   - Field: ‘stdout’
[16:11:05.107]   - Field: ‘earlySignal’
[16:11:05.107]   - Field: ‘lazy’
[16:11:05.107]   - Field: ‘state’
[16:11:05.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:05.107] - Launch lazy future ...
[16:11:05.108] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:05.108] Packages needed by future strategies (n = 0): <none>
[16:11:05.108] {
[16:11:05.108]     {
[16:11:05.108]         {
[16:11:05.108]             ...future.startTime <- base::Sys.time()
[16:11:05.108]             {
[16:11:05.108]                 {
[16:11:05.108]                   {
[16:11:05.108]                     {
[16:11:05.108]                       {
[16:11:05.108]                         base::local({
[16:11:05.108]                           has_future <- base::requireNamespace("future", 
[16:11:05.108]                             quietly = TRUE)
[16:11:05.108]                           if (has_future) {
[16:11:05.108]                             ns <- base::getNamespace("future")
[16:11:05.108]                             version <- ns[[".package"]][["version"]]
[16:11:05.108]                             if (is.null(version)) 
[16:11:05.108]                               version <- utils::packageVersion("future")
[16:11:05.108]                           }
[16:11:05.108]                           else {
[16:11:05.108]                             version <- NULL
[16:11:05.108]                           }
[16:11:05.108]                           if (!has_future || version < "1.8.0") {
[16:11:05.108]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:05.108]                               "", base::R.version$version.string), 
[16:11:05.108]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:05.108]                                 base::R.version$platform, 8 * 
[16:11:05.108]                                   base::.Machine$sizeof.pointer), 
[16:11:05.108]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:05.108]                                 "release", "version")], collapse = " "), 
[16:11:05.108]                               hostname = base::Sys.info()[["nodename"]])
[16:11:05.108]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:05.108]                               info)
[16:11:05.108]                             info <- base::paste(info, collapse = "; ")
[16:11:05.108]                             if (!has_future) {
[16:11:05.108]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:05.108]                                 info)
[16:11:05.108]                             }
[16:11:05.108]                             else {
[16:11:05.108]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:05.108]                                 info, version)
[16:11:05.108]                             }
[16:11:05.108]                             base::stop(msg)
[16:11:05.108]                           }
[16:11:05.108]                         })
[16:11:05.108]                       }
[16:11:05.108]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:05.108]                       base::options(mc.cores = 1L)
[16:11:05.108]                     }
[16:11:05.108]                     base::local({
[16:11:05.108]                       for (pkg in "future.apply") {
[16:11:05.108]                         base::loadNamespace(pkg)
[16:11:05.108]                         base::library(pkg, character.only = TRUE)
[16:11:05.108]                       }
[16:11:05.108]                     })
[16:11:05.108]                   }
[16:11:05.108]                   options(future.plan = NULL)
[16:11:05.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:05.108]                 }
[16:11:05.108]                 ...future.workdir <- getwd()
[16:11:05.108]             }
[16:11:05.108]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:05.108]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:05.108]         }
[16:11:05.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:05.108]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:05.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:05.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:05.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:05.108]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:05.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:05.108]             base::names(...future.oldOptions))
[16:11:05.108]     }
[16:11:05.108]     if (FALSE) {
[16:11:05.108]     }
[16:11:05.108]     else {
[16:11:05.108]         if (TRUE) {
[16:11:05.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:05.108]                 open = "w")
[16:11:05.108]         }
[16:11:05.108]         else {
[16:11:05.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:05.108]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:05.108]         }
[16:11:05.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:05.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:05.108]             base::sink(type = "output", split = FALSE)
[16:11:05.108]             base::close(...future.stdout)
[16:11:05.108]         }, add = TRUE)
[16:11:05.108]     }
[16:11:05.108]     ...future.frame <- base::sys.nframe()
[16:11:05.108]     ...future.conditions <- base::list()
[16:11:05.108]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:05.108]     if (FALSE) {
[16:11:05.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:05.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:05.108]     }
[16:11:05.108]     ...future.result <- base::tryCatch({
[16:11:05.108]         base::withCallingHandlers({
[16:11:05.108]             ...future.value <- base::withVisible(base::local({
[16:11:05.108]                 ...future.makeSendCondition <- local({
[16:11:05.108]                   sendCondition <- NULL
[16:11:05.108]                   function(frame = 1L) {
[16:11:05.108]                     if (is.function(sendCondition)) 
[16:11:05.108]                       return(sendCondition)
[16:11:05.108]                     ns <- getNamespace("parallel")
[16:11:05.108]                     if (exists("sendData", mode = "function", 
[16:11:05.108]                       envir = ns)) {
[16:11:05.108]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:05.108]                         envir = ns)
[16:11:05.108]                       envir <- sys.frame(frame)
[16:11:05.108]                       master <- NULL
[16:11:05.108]                       while (!identical(envir, .GlobalEnv) && 
[16:11:05.108]                         !identical(envir, emptyenv())) {
[16:11:05.108]                         if (exists("master", mode = "list", envir = envir, 
[16:11:05.108]                           inherits = FALSE)) {
[16:11:05.108]                           master <- get("master", mode = "list", 
[16:11:05.108]                             envir = envir, inherits = FALSE)
[16:11:05.108]                           if (inherits(master, c("SOCKnode", 
[16:11:05.108]                             "SOCK0node"))) {
[16:11:05.108]                             sendCondition <<- function(cond) {
[16:11:05.108]                               data <- list(type = "VALUE", value = cond, 
[16:11:05.108]                                 success = TRUE)
[16:11:05.108]                               parallel_sendData(master, data)
[16:11:05.108]                             }
[16:11:05.108]                             return(sendCondition)
[16:11:05.108]                           }
[16:11:05.108]                         }
[16:11:05.108]                         frame <- frame + 1L
[16:11:05.108]                         envir <- sys.frame(frame)
[16:11:05.108]                       }
[16:11:05.108]                     }
[16:11:05.108]                     sendCondition <<- function(cond) NULL
[16:11:05.108]                   }
[16:11:05.108]                 })
[16:11:05.108]                 withCallingHandlers({
[16:11:05.108]                   {
[16:11:05.108]                     do.call(function(...) {
[16:11:05.108]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.108]                       if (!identical(...future.globals.maxSize.org, 
[16:11:05.108]                         ...future.globals.maxSize)) {
[16:11:05.108]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.108]                         on.exit(options(oopts), add = TRUE)
[16:11:05.108]                       }
[16:11:05.108]                       {
[16:11:05.108]                         lapply(seq_along(...future.elements_ii), 
[16:11:05.108]                           FUN = function(jj) {
[16:11:05.108]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.108]                             ...future.FUN(...future.X_jj, ...)
[16:11:05.108]                           })
[16:11:05.108]                       }
[16:11:05.108]                     }, args = future.call.arguments)
[16:11:05.108]                   }
[16:11:05.108]                 }, immediateCondition = function(cond) {
[16:11:05.108]                   sendCondition <- ...future.makeSendCondition()
[16:11:05.108]                   sendCondition(cond)
[16:11:05.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.108]                   {
[16:11:05.108]                     inherits <- base::inherits
[16:11:05.108]                     invokeRestart <- base::invokeRestart
[16:11:05.108]                     is.null <- base::is.null
[16:11:05.108]                     muffled <- FALSE
[16:11:05.108]                     if (inherits(cond, "message")) {
[16:11:05.108]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:05.108]                       if (muffled) 
[16:11:05.108]                         invokeRestart("muffleMessage")
[16:11:05.108]                     }
[16:11:05.108]                     else if (inherits(cond, "warning")) {
[16:11:05.108]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:05.108]                       if (muffled) 
[16:11:05.108]                         invokeRestart("muffleWarning")
[16:11:05.108]                     }
[16:11:05.108]                     else if (inherits(cond, "condition")) {
[16:11:05.108]                       if (!is.null(pattern)) {
[16:11:05.108]                         computeRestarts <- base::computeRestarts
[16:11:05.108]                         grepl <- base::grepl
[16:11:05.108]                         restarts <- computeRestarts(cond)
[16:11:05.108]                         for (restart in restarts) {
[16:11:05.108]                           name <- restart$name
[16:11:05.108]                           if (is.null(name)) 
[16:11:05.108]                             next
[16:11:05.108]                           if (!grepl(pattern, name)) 
[16:11:05.108]                             next
[16:11:05.108]                           invokeRestart(restart)
[16:11:05.108]                           muffled <- TRUE
[16:11:05.108]                           break
[16:11:05.108]                         }
[16:11:05.108]                       }
[16:11:05.108]                     }
[16:11:05.108]                     invisible(muffled)
[16:11:05.108]                   }
[16:11:05.108]                   muffleCondition(cond)
[16:11:05.108]                 })
[16:11:05.108]             }))
[16:11:05.108]             future::FutureResult(value = ...future.value$value, 
[16:11:05.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.108]                   ...future.rng), globalenv = if (FALSE) 
[16:11:05.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:05.108]                     ...future.globalenv.names))
[16:11:05.108]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:05.108]         }, condition = base::local({
[16:11:05.108]             c <- base::c
[16:11:05.108]             inherits <- base::inherits
[16:11:05.108]             invokeRestart <- base::invokeRestart
[16:11:05.108]             length <- base::length
[16:11:05.108]             list <- base::list
[16:11:05.108]             seq.int <- base::seq.int
[16:11:05.108]             signalCondition <- base::signalCondition
[16:11:05.108]             sys.calls <- base::sys.calls
[16:11:05.108]             `[[` <- base::`[[`
[16:11:05.108]             `+` <- base::`+`
[16:11:05.108]             `<<-` <- base::`<<-`
[16:11:05.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:05.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:05.108]                   3L)]
[16:11:05.108]             }
[16:11:05.108]             function(cond) {
[16:11:05.108]                 is_error <- inherits(cond, "error")
[16:11:05.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:05.108]                   NULL)
[16:11:05.108]                 if (is_error) {
[16:11:05.108]                   sessionInformation <- function() {
[16:11:05.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:05.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:05.108]                       search = base::search(), system = base::Sys.info())
[16:11:05.108]                   }
[16:11:05.108]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:05.108]                     cond$call), session = sessionInformation(), 
[16:11:05.108]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:05.108]                   signalCondition(cond)
[16:11:05.108]                 }
[16:11:05.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:05.108]                 "immediateCondition"))) {
[16:11:05.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:05.108]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:05.108]                   if (TRUE && !signal) {
[16:11:05.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.108]                     {
[16:11:05.108]                       inherits <- base::inherits
[16:11:05.108]                       invokeRestart <- base::invokeRestart
[16:11:05.108]                       is.null <- base::is.null
[16:11:05.108]                       muffled <- FALSE
[16:11:05.108]                       if (inherits(cond, "message")) {
[16:11:05.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.108]                         if (muffled) 
[16:11:05.108]                           invokeRestart("muffleMessage")
[16:11:05.108]                       }
[16:11:05.108]                       else if (inherits(cond, "warning")) {
[16:11:05.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.108]                         if (muffled) 
[16:11:05.108]                           invokeRestart("muffleWarning")
[16:11:05.108]                       }
[16:11:05.108]                       else if (inherits(cond, "condition")) {
[16:11:05.108]                         if (!is.null(pattern)) {
[16:11:05.108]                           computeRestarts <- base::computeRestarts
[16:11:05.108]                           grepl <- base::grepl
[16:11:05.108]                           restarts <- computeRestarts(cond)
[16:11:05.108]                           for (restart in restarts) {
[16:11:05.108]                             name <- restart$name
[16:11:05.108]                             if (is.null(name)) 
[16:11:05.108]                               next
[16:11:05.108]                             if (!grepl(pattern, name)) 
[16:11:05.108]                               next
[16:11:05.108]                             invokeRestart(restart)
[16:11:05.108]                             muffled <- TRUE
[16:11:05.108]                             break
[16:11:05.108]                           }
[16:11:05.108]                         }
[16:11:05.108]                       }
[16:11:05.108]                       invisible(muffled)
[16:11:05.108]                     }
[16:11:05.108]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.108]                   }
[16:11:05.108]                 }
[16:11:05.108]                 else {
[16:11:05.108]                   if (TRUE) {
[16:11:05.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.108]                     {
[16:11:05.108]                       inherits <- base::inherits
[16:11:05.108]                       invokeRestart <- base::invokeRestart
[16:11:05.108]                       is.null <- base::is.null
[16:11:05.108]                       muffled <- FALSE
[16:11:05.108]                       if (inherits(cond, "message")) {
[16:11:05.108]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.108]                         if (muffled) 
[16:11:05.108]                           invokeRestart("muffleMessage")
[16:11:05.108]                       }
[16:11:05.108]                       else if (inherits(cond, "warning")) {
[16:11:05.108]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.108]                         if (muffled) 
[16:11:05.108]                           invokeRestart("muffleWarning")
[16:11:05.108]                       }
[16:11:05.108]                       else if (inherits(cond, "condition")) {
[16:11:05.108]                         if (!is.null(pattern)) {
[16:11:05.108]                           computeRestarts <- base::computeRestarts
[16:11:05.108]                           grepl <- base::grepl
[16:11:05.108]                           restarts <- computeRestarts(cond)
[16:11:05.108]                           for (restart in restarts) {
[16:11:05.108]                             name <- restart$name
[16:11:05.108]                             if (is.null(name)) 
[16:11:05.108]                               next
[16:11:05.108]                             if (!grepl(pattern, name)) 
[16:11:05.108]                               next
[16:11:05.108]                             invokeRestart(restart)
[16:11:05.108]                             muffled <- TRUE
[16:11:05.108]                             break
[16:11:05.108]                           }
[16:11:05.108]                         }
[16:11:05.108]                       }
[16:11:05.108]                       invisible(muffled)
[16:11:05.108]                     }
[16:11:05.108]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.108]                   }
[16:11:05.108]                 }
[16:11:05.108]             }
[16:11:05.108]         }))
[16:11:05.108]     }, error = function(ex) {
[16:11:05.108]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:05.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.108]                 ...future.rng), started = ...future.startTime, 
[16:11:05.108]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:05.108]             version = "1.8"), class = "FutureResult")
[16:11:05.108]     }, finally = {
[16:11:05.108]         if (!identical(...future.workdir, getwd())) 
[16:11:05.108]             setwd(...future.workdir)
[16:11:05.108]         {
[16:11:05.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:05.108]                 ...future.oldOptions$nwarnings <- NULL
[16:11:05.108]             }
[16:11:05.108]             base::options(...future.oldOptions)
[16:11:05.108]             if (.Platform$OS.type == "windows") {
[16:11:05.108]                 old_names <- names(...future.oldEnvVars)
[16:11:05.108]                 envs <- base::Sys.getenv()
[16:11:05.108]                 names <- names(envs)
[16:11:05.108]                 common <- intersect(names, old_names)
[16:11:05.108]                 added <- setdiff(names, old_names)
[16:11:05.108]                 removed <- setdiff(old_names, names)
[16:11:05.108]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:05.108]                   envs[common]]
[16:11:05.108]                 NAMES <- toupper(changed)
[16:11:05.108]                 args <- list()
[16:11:05.108]                 for (kk in seq_along(NAMES)) {
[16:11:05.108]                   name <- changed[[kk]]
[16:11:05.108]                   NAME <- NAMES[[kk]]
[16:11:05.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.108]                     next
[16:11:05.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.108]                 }
[16:11:05.108]                 NAMES <- toupper(added)
[16:11:05.108]                 for (kk in seq_along(NAMES)) {
[16:11:05.108]                   name <- added[[kk]]
[16:11:05.108]                   NAME <- NAMES[[kk]]
[16:11:05.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.108]                     next
[16:11:05.108]                   args[[name]] <- ""
[16:11:05.108]                 }
[16:11:05.108]                 NAMES <- toupper(removed)
[16:11:05.108]                 for (kk in seq_along(NAMES)) {
[16:11:05.108]                   name <- removed[[kk]]
[16:11:05.108]                   NAME <- NAMES[[kk]]
[16:11:05.108]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.108]                     next
[16:11:05.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.108]                 }
[16:11:05.108]                 if (length(args) > 0) 
[16:11:05.108]                   base::do.call(base::Sys.setenv, args = args)
[16:11:05.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:05.108]             }
[16:11:05.108]             else {
[16:11:05.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:05.108]             }
[16:11:05.108]             {
[16:11:05.108]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:05.108]                   0L) {
[16:11:05.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:05.108]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:05.108]                   base::options(opts)
[16:11:05.108]                 }
[16:11:05.108]                 {
[16:11:05.108]                   {
[16:11:05.108]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:05.108]                     NULL
[16:11:05.108]                   }
[16:11:05.108]                   options(future.plan = NULL)
[16:11:05.108]                   if (is.na(NA_character_)) 
[16:11:05.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:05.108]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:05.108]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:05.108]                     envir = parent.frame()) 
[16:11:05.108]                   {
[16:11:05.108]                     if (is.function(workers)) 
[16:11:05.108]                       workers <- workers()
[16:11:05.108]                     workers <- structure(as.integer(workers), 
[16:11:05.108]                       class = class(workers))
[16:11:05.108]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:05.108]                       workers >= 1)
[16:11:05.108]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:05.108]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:05.108]                     }
[16:11:05.108]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:05.108]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:05.108]                       envir = envir)
[16:11:05.108]                     if (!future$lazy) 
[16:11:05.108]                       future <- run(future)
[16:11:05.108]                     invisible(future)
[16:11:05.108]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:05.108]                 }
[16:11:05.108]             }
[16:11:05.108]         }
[16:11:05.108]     })
[16:11:05.108]     if (TRUE) {
[16:11:05.108]         base::sink(type = "output", split = FALSE)
[16:11:05.108]         if (TRUE) {
[16:11:05.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:05.108]         }
[16:11:05.108]         else {
[16:11:05.108]             ...future.result["stdout"] <- base::list(NULL)
[16:11:05.108]         }
[16:11:05.108]         base::close(...future.stdout)
[16:11:05.108]         ...future.stdout <- NULL
[16:11:05.108]     }
[16:11:05.108]     ...future.result$conditions <- ...future.conditions
[16:11:05.108]     ...future.result$finished <- base::Sys.time()
[16:11:05.108]     ...future.result
[16:11:05.108] }
[16:11:05.111] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[16:11:05.111] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:05.152] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:05.152] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[16:11:05.152] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[16:11:05.153] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:05.153] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:05.153] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:05.196] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:05.196] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:05.240] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:05.240] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:05.241] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:05.241] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:05.241] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:05.241] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:05.242] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:05.242] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:11:05.242] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:11:05.242] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:05.243] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:05.243] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:05.243] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:05.243] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[16:11:05.244] MultisessionFuture started
[16:11:05.244] - Launch lazy future ... done
[16:11:05.244] run() for ‘MultisessionFuture’ ... done
[16:11:05.244] Created future:
[16:11:05.244] MultisessionFuture:
[16:11:05.244] Label: ‘future_vapply-1’
[16:11:05.244] Expression:
[16:11:05.244] {
[16:11:05.244]     do.call(function(...) {
[16:11:05.244]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.244]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.244]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.244]             on.exit(options(oopts), add = TRUE)
[16:11:05.244]         }
[16:11:05.244]         {
[16:11:05.244]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.244]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.244]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.244]             })
[16:11:05.244]         }
[16:11:05.244]     }, args = future.call.arguments)
[16:11:05.244] }
[16:11:05.244] Lazy evaluation: FALSE
[16:11:05.244] Asynchronous evaluation: TRUE
[16:11:05.244] Local evaluation: TRUE
[16:11:05.244] Environment: R_GlobalEnv
[16:11:05.244] Capture standard output: TRUE
[16:11:05.244] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:05.244] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:05.244] Packages: 1 packages (‘future.apply’)
[16:11:05.244] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:05.244] Resolved: FALSE
[16:11:05.244] Value: <not collected>
[16:11:05.244] Conditions captured: <none>
[16:11:05.244] Early signaling: FALSE
[16:11:05.244] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:05.244] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.258] Chunk #1 of 2 ... DONE
[16:11:05.258] Chunk #2 of 2 ...
[16:11:05.258]  - Finding globals in 'X' for chunk #2 ...
[16:11:05.258] getGlobalsAndPackages() ...
[16:11:05.258] Searching for globals...
[16:11:05.259] 
[16:11:05.259] Searching for globals ... DONE
[16:11:05.259] - globals: [0] <none>
[16:11:05.259] getGlobalsAndPackages() ... DONE
[16:11:05.259]    + additional globals found: [n=0] 
[16:11:05.259]    + additional namespaces needed: [n=0] 
[16:11:05.259]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:05.259]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:05.259]  - seeds: <none>
[16:11:05.260] getGlobalsAndPackages() ...
[16:11:05.260] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.260] Resolving globals: FALSE
[16:11:05.260] Tweak future expression to call with '...' arguments ...
[16:11:05.260] {
[16:11:05.260]     do.call(function(...) {
[16:11:05.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.260]             on.exit(options(oopts), add = TRUE)
[16:11:05.260]         }
[16:11:05.260]         {
[16:11:05.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.260]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.260]             })
[16:11:05.260]         }
[16:11:05.260]     }, args = future.call.arguments)
[16:11:05.260] }
[16:11:05.260] Tweak future expression to call with '...' arguments ... DONE
[16:11:05.261] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.261] - packages: [1] ‘future.apply’
[16:11:05.261] getGlobalsAndPackages() ... DONE
[16:11:05.261] run() for ‘Future’ ...
[16:11:05.261] - state: ‘created’
[16:11:05.261] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:05.276] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:05.276]   - Field: ‘node’
[16:11:05.276]   - Field: ‘label’
[16:11:05.276]   - Field: ‘local’
[16:11:05.277]   - Field: ‘owner’
[16:11:05.277]   - Field: ‘envir’
[16:11:05.277]   - Field: ‘workers’
[16:11:05.277]   - Field: ‘packages’
[16:11:05.277]   - Field: ‘gc’
[16:11:05.277]   - Field: ‘conditions’
[16:11:05.277]   - Field: ‘persistent’
[16:11:05.277]   - Field: ‘expr’
[16:11:05.277]   - Field: ‘uuid’
[16:11:05.277]   - Field: ‘seed’
[16:11:05.277]   - Field: ‘version’
[16:11:05.278]   - Field: ‘result’
[16:11:05.278]   - Field: ‘asynchronous’
[16:11:05.278]   - Field: ‘calls’
[16:11:05.278]   - Field: ‘globals’
[16:11:05.278]   - Field: ‘stdout’
[16:11:05.278]   - Field: ‘earlySignal’
[16:11:05.278]   - Field: ‘lazy’
[16:11:05.278]   - Field: ‘state’
[16:11:05.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:05.278] - Launch lazy future ...
[16:11:05.279] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:05.279] Packages needed by future strategies (n = 0): <none>
[16:11:05.279] {
[16:11:05.279]     {
[16:11:05.279]         {
[16:11:05.279]             ...future.startTime <- base::Sys.time()
[16:11:05.279]             {
[16:11:05.279]                 {
[16:11:05.279]                   {
[16:11:05.279]                     {
[16:11:05.279]                       {
[16:11:05.279]                         base::local({
[16:11:05.279]                           has_future <- base::requireNamespace("future", 
[16:11:05.279]                             quietly = TRUE)
[16:11:05.279]                           if (has_future) {
[16:11:05.279]                             ns <- base::getNamespace("future")
[16:11:05.279]                             version <- ns[[".package"]][["version"]]
[16:11:05.279]                             if (is.null(version)) 
[16:11:05.279]                               version <- utils::packageVersion("future")
[16:11:05.279]                           }
[16:11:05.279]                           else {
[16:11:05.279]                             version <- NULL
[16:11:05.279]                           }
[16:11:05.279]                           if (!has_future || version < "1.8.0") {
[16:11:05.279]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:05.279]                               "", base::R.version$version.string), 
[16:11:05.279]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:05.279]                                 base::R.version$platform, 8 * 
[16:11:05.279]                                   base::.Machine$sizeof.pointer), 
[16:11:05.279]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:05.279]                                 "release", "version")], collapse = " "), 
[16:11:05.279]                               hostname = base::Sys.info()[["nodename"]])
[16:11:05.279]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:05.279]                               info)
[16:11:05.279]                             info <- base::paste(info, collapse = "; ")
[16:11:05.279]                             if (!has_future) {
[16:11:05.279]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:05.279]                                 info)
[16:11:05.279]                             }
[16:11:05.279]                             else {
[16:11:05.279]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:05.279]                                 info, version)
[16:11:05.279]                             }
[16:11:05.279]                             base::stop(msg)
[16:11:05.279]                           }
[16:11:05.279]                         })
[16:11:05.279]                       }
[16:11:05.279]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:05.279]                       base::options(mc.cores = 1L)
[16:11:05.279]                     }
[16:11:05.279]                     base::local({
[16:11:05.279]                       for (pkg in "future.apply") {
[16:11:05.279]                         base::loadNamespace(pkg)
[16:11:05.279]                         base::library(pkg, character.only = TRUE)
[16:11:05.279]                       }
[16:11:05.279]                     })
[16:11:05.279]                   }
[16:11:05.279]                   options(future.plan = NULL)
[16:11:05.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:05.279]                 }
[16:11:05.279]                 ...future.workdir <- getwd()
[16:11:05.279]             }
[16:11:05.279]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:05.279]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:05.279]         }
[16:11:05.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:05.279]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:05.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:05.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:05.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:05.279]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:05.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:05.279]             base::names(...future.oldOptions))
[16:11:05.279]     }
[16:11:05.279]     if (FALSE) {
[16:11:05.279]     }
[16:11:05.279]     else {
[16:11:05.279]         if (TRUE) {
[16:11:05.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:05.279]                 open = "w")
[16:11:05.279]         }
[16:11:05.279]         else {
[16:11:05.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:05.279]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:05.279]         }
[16:11:05.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:05.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:05.279]             base::sink(type = "output", split = FALSE)
[16:11:05.279]             base::close(...future.stdout)
[16:11:05.279]         }, add = TRUE)
[16:11:05.279]     }
[16:11:05.279]     ...future.frame <- base::sys.nframe()
[16:11:05.279]     ...future.conditions <- base::list()
[16:11:05.279]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:05.279]     if (FALSE) {
[16:11:05.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:05.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:05.279]     }
[16:11:05.279]     ...future.result <- base::tryCatch({
[16:11:05.279]         base::withCallingHandlers({
[16:11:05.279]             ...future.value <- base::withVisible(base::local({
[16:11:05.279]                 ...future.makeSendCondition <- local({
[16:11:05.279]                   sendCondition <- NULL
[16:11:05.279]                   function(frame = 1L) {
[16:11:05.279]                     if (is.function(sendCondition)) 
[16:11:05.279]                       return(sendCondition)
[16:11:05.279]                     ns <- getNamespace("parallel")
[16:11:05.279]                     if (exists("sendData", mode = "function", 
[16:11:05.279]                       envir = ns)) {
[16:11:05.279]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:05.279]                         envir = ns)
[16:11:05.279]                       envir <- sys.frame(frame)
[16:11:05.279]                       master <- NULL
[16:11:05.279]                       while (!identical(envir, .GlobalEnv) && 
[16:11:05.279]                         !identical(envir, emptyenv())) {
[16:11:05.279]                         if (exists("master", mode = "list", envir = envir, 
[16:11:05.279]                           inherits = FALSE)) {
[16:11:05.279]                           master <- get("master", mode = "list", 
[16:11:05.279]                             envir = envir, inherits = FALSE)
[16:11:05.279]                           if (inherits(master, c("SOCKnode", 
[16:11:05.279]                             "SOCK0node"))) {
[16:11:05.279]                             sendCondition <<- function(cond) {
[16:11:05.279]                               data <- list(type = "VALUE", value = cond, 
[16:11:05.279]                                 success = TRUE)
[16:11:05.279]                               parallel_sendData(master, data)
[16:11:05.279]                             }
[16:11:05.279]                             return(sendCondition)
[16:11:05.279]                           }
[16:11:05.279]                         }
[16:11:05.279]                         frame <- frame + 1L
[16:11:05.279]                         envir <- sys.frame(frame)
[16:11:05.279]                       }
[16:11:05.279]                     }
[16:11:05.279]                     sendCondition <<- function(cond) NULL
[16:11:05.279]                   }
[16:11:05.279]                 })
[16:11:05.279]                 withCallingHandlers({
[16:11:05.279]                   {
[16:11:05.279]                     do.call(function(...) {
[16:11:05.279]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.279]                       if (!identical(...future.globals.maxSize.org, 
[16:11:05.279]                         ...future.globals.maxSize)) {
[16:11:05.279]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.279]                         on.exit(options(oopts), add = TRUE)
[16:11:05.279]                       }
[16:11:05.279]                       {
[16:11:05.279]                         lapply(seq_along(...future.elements_ii), 
[16:11:05.279]                           FUN = function(jj) {
[16:11:05.279]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.279]                             ...future.FUN(...future.X_jj, ...)
[16:11:05.279]                           })
[16:11:05.279]                       }
[16:11:05.279]                     }, args = future.call.arguments)
[16:11:05.279]                   }
[16:11:05.279]                 }, immediateCondition = function(cond) {
[16:11:05.279]                   sendCondition <- ...future.makeSendCondition()
[16:11:05.279]                   sendCondition(cond)
[16:11:05.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.279]                   {
[16:11:05.279]                     inherits <- base::inherits
[16:11:05.279]                     invokeRestart <- base::invokeRestart
[16:11:05.279]                     is.null <- base::is.null
[16:11:05.279]                     muffled <- FALSE
[16:11:05.279]                     if (inherits(cond, "message")) {
[16:11:05.279]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:05.279]                       if (muffled) 
[16:11:05.279]                         invokeRestart("muffleMessage")
[16:11:05.279]                     }
[16:11:05.279]                     else if (inherits(cond, "warning")) {
[16:11:05.279]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:05.279]                       if (muffled) 
[16:11:05.279]                         invokeRestart("muffleWarning")
[16:11:05.279]                     }
[16:11:05.279]                     else if (inherits(cond, "condition")) {
[16:11:05.279]                       if (!is.null(pattern)) {
[16:11:05.279]                         computeRestarts <- base::computeRestarts
[16:11:05.279]                         grepl <- base::grepl
[16:11:05.279]                         restarts <- computeRestarts(cond)
[16:11:05.279]                         for (restart in restarts) {
[16:11:05.279]                           name <- restart$name
[16:11:05.279]                           if (is.null(name)) 
[16:11:05.279]                             next
[16:11:05.279]                           if (!grepl(pattern, name)) 
[16:11:05.279]                             next
[16:11:05.279]                           invokeRestart(restart)
[16:11:05.279]                           muffled <- TRUE
[16:11:05.279]                           break
[16:11:05.279]                         }
[16:11:05.279]                       }
[16:11:05.279]                     }
[16:11:05.279]                     invisible(muffled)
[16:11:05.279]                   }
[16:11:05.279]                   muffleCondition(cond)
[16:11:05.279]                 })
[16:11:05.279]             }))
[16:11:05.279]             future::FutureResult(value = ...future.value$value, 
[16:11:05.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.279]                   ...future.rng), globalenv = if (FALSE) 
[16:11:05.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:05.279]                     ...future.globalenv.names))
[16:11:05.279]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:05.279]         }, condition = base::local({
[16:11:05.279]             c <- base::c
[16:11:05.279]             inherits <- base::inherits
[16:11:05.279]             invokeRestart <- base::invokeRestart
[16:11:05.279]             length <- base::length
[16:11:05.279]             list <- base::list
[16:11:05.279]             seq.int <- base::seq.int
[16:11:05.279]             signalCondition <- base::signalCondition
[16:11:05.279]             sys.calls <- base::sys.calls
[16:11:05.279]             `[[` <- base::`[[`
[16:11:05.279]             `+` <- base::`+`
[16:11:05.279]             `<<-` <- base::`<<-`
[16:11:05.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:05.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:05.279]                   3L)]
[16:11:05.279]             }
[16:11:05.279]             function(cond) {
[16:11:05.279]                 is_error <- inherits(cond, "error")
[16:11:05.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:05.279]                   NULL)
[16:11:05.279]                 if (is_error) {
[16:11:05.279]                   sessionInformation <- function() {
[16:11:05.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:05.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:05.279]                       search = base::search(), system = base::Sys.info())
[16:11:05.279]                   }
[16:11:05.279]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:05.279]                     cond$call), session = sessionInformation(), 
[16:11:05.279]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:05.279]                   signalCondition(cond)
[16:11:05.279]                 }
[16:11:05.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:05.279]                 "immediateCondition"))) {
[16:11:05.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:05.279]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:05.279]                   if (TRUE && !signal) {
[16:11:05.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.279]                     {
[16:11:05.279]                       inherits <- base::inherits
[16:11:05.279]                       invokeRestart <- base::invokeRestart
[16:11:05.279]                       is.null <- base::is.null
[16:11:05.279]                       muffled <- FALSE
[16:11:05.279]                       if (inherits(cond, "message")) {
[16:11:05.279]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.279]                         if (muffled) 
[16:11:05.279]                           invokeRestart("muffleMessage")
[16:11:05.279]                       }
[16:11:05.279]                       else if (inherits(cond, "warning")) {
[16:11:05.279]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.279]                         if (muffled) 
[16:11:05.279]                           invokeRestart("muffleWarning")
[16:11:05.279]                       }
[16:11:05.279]                       else if (inherits(cond, "condition")) {
[16:11:05.279]                         if (!is.null(pattern)) {
[16:11:05.279]                           computeRestarts <- base::computeRestarts
[16:11:05.279]                           grepl <- base::grepl
[16:11:05.279]                           restarts <- computeRestarts(cond)
[16:11:05.279]                           for (restart in restarts) {
[16:11:05.279]                             name <- restart$name
[16:11:05.279]                             if (is.null(name)) 
[16:11:05.279]                               next
[16:11:05.279]                             if (!grepl(pattern, name)) 
[16:11:05.279]                               next
[16:11:05.279]                             invokeRestart(restart)
[16:11:05.279]                             muffled <- TRUE
[16:11:05.279]                             break
[16:11:05.279]                           }
[16:11:05.279]                         }
[16:11:05.279]                       }
[16:11:05.279]                       invisible(muffled)
[16:11:05.279]                     }
[16:11:05.279]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.279]                   }
[16:11:05.279]                 }
[16:11:05.279]                 else {
[16:11:05.279]                   if (TRUE) {
[16:11:05.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.279]                     {
[16:11:05.279]                       inherits <- base::inherits
[16:11:05.279]                       invokeRestart <- base::invokeRestart
[16:11:05.279]                       is.null <- base::is.null
[16:11:05.279]                       muffled <- FALSE
[16:11:05.279]                       if (inherits(cond, "message")) {
[16:11:05.279]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.279]                         if (muffled) 
[16:11:05.279]                           invokeRestart("muffleMessage")
[16:11:05.279]                       }
[16:11:05.279]                       else if (inherits(cond, "warning")) {
[16:11:05.279]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.279]                         if (muffled) 
[16:11:05.279]                           invokeRestart("muffleWarning")
[16:11:05.279]                       }
[16:11:05.279]                       else if (inherits(cond, "condition")) {
[16:11:05.279]                         if (!is.null(pattern)) {
[16:11:05.279]                           computeRestarts <- base::computeRestarts
[16:11:05.279]                           grepl <- base::grepl
[16:11:05.279]                           restarts <- computeRestarts(cond)
[16:11:05.279]                           for (restart in restarts) {
[16:11:05.279]                             name <- restart$name
[16:11:05.279]                             if (is.null(name)) 
[16:11:05.279]                               next
[16:11:05.279]                             if (!grepl(pattern, name)) 
[16:11:05.279]                               next
[16:11:05.279]                             invokeRestart(restart)
[16:11:05.279]                             muffled <- TRUE
[16:11:05.279]                             break
[16:11:05.279]                           }
[16:11:05.279]                         }
[16:11:05.279]                       }
[16:11:05.279]                       invisible(muffled)
[16:11:05.279]                     }
[16:11:05.279]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.279]                   }
[16:11:05.279]                 }
[16:11:05.279]             }
[16:11:05.279]         }))
[16:11:05.279]     }, error = function(ex) {
[16:11:05.279]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:05.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.279]                 ...future.rng), started = ...future.startTime, 
[16:11:05.279]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:05.279]             version = "1.8"), class = "FutureResult")
[16:11:05.279]     }, finally = {
[16:11:05.279]         if (!identical(...future.workdir, getwd())) 
[16:11:05.279]             setwd(...future.workdir)
[16:11:05.279]         {
[16:11:05.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:05.279]                 ...future.oldOptions$nwarnings <- NULL
[16:11:05.279]             }
[16:11:05.279]             base::options(...future.oldOptions)
[16:11:05.279]             if (.Platform$OS.type == "windows") {
[16:11:05.279]                 old_names <- names(...future.oldEnvVars)
[16:11:05.279]                 envs <- base::Sys.getenv()
[16:11:05.279]                 names <- names(envs)
[16:11:05.279]                 common <- intersect(names, old_names)
[16:11:05.279]                 added <- setdiff(names, old_names)
[16:11:05.279]                 removed <- setdiff(old_names, names)
[16:11:05.279]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:05.279]                   envs[common]]
[16:11:05.279]                 NAMES <- toupper(changed)
[16:11:05.279]                 args <- list()
[16:11:05.279]                 for (kk in seq_along(NAMES)) {
[16:11:05.279]                   name <- changed[[kk]]
[16:11:05.279]                   NAME <- NAMES[[kk]]
[16:11:05.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.279]                     next
[16:11:05.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.279]                 }
[16:11:05.279]                 NAMES <- toupper(added)
[16:11:05.279]                 for (kk in seq_along(NAMES)) {
[16:11:05.279]                   name <- added[[kk]]
[16:11:05.279]                   NAME <- NAMES[[kk]]
[16:11:05.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.279]                     next
[16:11:05.279]                   args[[name]] <- ""
[16:11:05.279]                 }
[16:11:05.279]                 NAMES <- toupper(removed)
[16:11:05.279]                 for (kk in seq_along(NAMES)) {
[16:11:05.279]                   name <- removed[[kk]]
[16:11:05.279]                   NAME <- NAMES[[kk]]
[16:11:05.279]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.279]                     next
[16:11:05.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.279]                 }
[16:11:05.279]                 if (length(args) > 0) 
[16:11:05.279]                   base::do.call(base::Sys.setenv, args = args)
[16:11:05.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:05.279]             }
[16:11:05.279]             else {
[16:11:05.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:05.279]             }
[16:11:05.279]             {
[16:11:05.279]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:05.279]                   0L) {
[16:11:05.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:05.279]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:05.279]                   base::options(opts)
[16:11:05.279]                 }
[16:11:05.279]                 {
[16:11:05.279]                   {
[16:11:05.279]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:05.279]                     NULL
[16:11:05.279]                   }
[16:11:05.279]                   options(future.plan = NULL)
[16:11:05.279]                   if (is.na(NA_character_)) 
[16:11:05.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:05.279]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:05.279]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:05.279]                     envir = parent.frame()) 
[16:11:05.279]                   {
[16:11:05.279]                     if (is.function(workers)) 
[16:11:05.279]                       workers <- workers()
[16:11:05.279]                     workers <- structure(as.integer(workers), 
[16:11:05.279]                       class = class(workers))
[16:11:05.279]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:05.279]                       workers >= 1)
[16:11:05.279]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:05.279]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:05.279]                     }
[16:11:05.279]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:05.279]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:05.279]                       envir = envir)
[16:11:05.279]                     if (!future$lazy) 
[16:11:05.279]                       future <- run(future)
[16:11:05.279]                     invisible(future)
[16:11:05.279]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:05.279]                 }
[16:11:05.279]             }
[16:11:05.279]         }
[16:11:05.279]     })
[16:11:05.279]     if (TRUE) {
[16:11:05.279]         base::sink(type = "output", split = FALSE)
[16:11:05.279]         if (TRUE) {
[16:11:05.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:05.279]         }
[16:11:05.279]         else {
[16:11:05.279]             ...future.result["stdout"] <- base::list(NULL)
[16:11:05.279]         }
[16:11:05.279]         base::close(...future.stdout)
[16:11:05.279]         ...future.stdout <- NULL
[16:11:05.279]     }
[16:11:05.279]     ...future.result$conditions <- ...future.conditions
[16:11:05.279]     ...future.result$finished <- base::Sys.time()
[16:11:05.279]     ...future.result
[16:11:05.279] }
[16:11:05.282] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[16:11:05.282] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:05.324] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:05.324] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[16:11:05.324] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[16:11:05.324] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:05.325] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:05.325] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:05.368] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:05.368] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:05.412] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:05.412] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:05.412] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:05.413] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:05.413] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:05.413] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:05.414] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:05.414] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:11:05.414] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:11:05.414] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:05.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:05.415] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:05.415] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:05.415] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[16:11:05.416] MultisessionFuture started
[16:11:05.416] - Launch lazy future ... done
[16:11:05.416] run() for ‘MultisessionFuture’ ... done
[16:11:05.416] Created future:
[16:11:05.416] MultisessionFuture:
[16:11:05.416] Label: ‘future_vapply-2’
[16:11:05.416] Expression:
[16:11:05.416] {
[16:11:05.416]     do.call(function(...) {
[16:11:05.416]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.416]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.416]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.416]             on.exit(options(oopts), add = TRUE)
[16:11:05.416]         }
[16:11:05.416]         {
[16:11:05.416]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.416]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.416]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.416]             })
[16:11:05.416]         }
[16:11:05.416]     }, args = future.call.arguments)
[16:11:05.416] }
[16:11:05.416] Lazy evaluation: FALSE
[16:11:05.416] Asynchronous evaluation: TRUE
[16:11:05.416] Local evaluation: TRUE
[16:11:05.416] Environment: R_GlobalEnv
[16:11:05.416] Capture standard output: TRUE
[16:11:05.416] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:05.416] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:05.416] Packages: 1 packages (‘future.apply’)
[16:11:05.416] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:05.416] Resolved: FALSE
[16:11:05.416] Value: <not collected>
[16:11:05.416] Conditions captured: <none>
[16:11:05.416] Early signaling: FALSE
[16:11:05.416] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:05.416] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.428] Chunk #2 of 2 ... DONE
[16:11:05.428] Launching 2 futures (chunks) ... DONE
[16:11:05.428] Resolving 2 futures (chunks) ...
[16:11:05.428] resolve() on list ...
[16:11:05.428]  recursive: 0
[16:11:05.428]  length: 2
[16:11:05.428] 
[16:11:05.429] receiveMessageFromWorker() for ClusterFuture ...
[16:11:05.429] - Validating connection of MultisessionFuture
[16:11:05.429] - received message: FutureResult
[16:11:05.429] - Received FutureResult
[16:11:05.429] - Erased future from FutureRegistry
[16:11:05.429] result() for ClusterFuture ...
[16:11:05.430] - result already collected: FutureResult
[16:11:05.430] result() for ClusterFuture ... done
[16:11:05.430] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:05.430] Future #1
[16:11:05.430] result() for ClusterFuture ...
[16:11:05.430] - result already collected: FutureResult
[16:11:05.430] result() for ClusterFuture ... done
[16:11:05.430] result() for ClusterFuture ...
[16:11:05.430] - result already collected: FutureResult
[16:11:05.430] result() for ClusterFuture ... done
[16:11:05.430] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:05.430] - nx: 2
[16:11:05.431] - relay: TRUE
[16:11:05.431] - stdout: TRUE
[16:11:05.431] - signal: TRUE
[16:11:05.431] - resignal: FALSE
[16:11:05.431] - force: TRUE
[16:11:05.431] - relayed: [n=2] FALSE, FALSE
[16:11:05.431] - queued futures: [n=2] FALSE, FALSE
[16:11:05.431]  - until=1
[16:11:05.431]  - relaying element #1
[16:11:05.431] result() for ClusterFuture ...
[16:11:05.431] - result already collected: FutureResult
[16:11:05.431] result() for ClusterFuture ... done
[16:11:05.432] result() for ClusterFuture ...
[16:11:05.432] - result already collected: FutureResult
[16:11:05.432] result() for ClusterFuture ... done
[16:11:05.432] result() for ClusterFuture ...
[16:11:05.432] - result already collected: FutureResult
[16:11:05.432] result() for ClusterFuture ... done
[16:11:05.432] result() for ClusterFuture ...
[16:11:05.432] - result already collected: FutureResult
[16:11:05.432] result() for ClusterFuture ... done
[16:11:05.432] - relayed: [n=2] TRUE, FALSE
[16:11:05.432] - queued futures: [n=2] TRUE, FALSE
[16:11:05.433] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:05.433]  length: 1 (resolved future 1)
[16:11:05.474] receiveMessageFromWorker() for ClusterFuture ...
[16:11:05.474] - Validating connection of MultisessionFuture
[16:11:05.474] - received message: FutureResult
[16:11:05.475] - Received FutureResult
[16:11:05.475] - Erased future from FutureRegistry
[16:11:05.475] result() for ClusterFuture ...
[16:11:05.475] - result already collected: FutureResult
[16:11:05.475] result() for ClusterFuture ... done
[16:11:05.475] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:05.475] Future #2
[16:11:05.475] result() for ClusterFuture ...
[16:11:05.475] - result already collected: FutureResult
[16:11:05.475] result() for ClusterFuture ... done
[16:11:05.475] result() for ClusterFuture ...
[16:11:05.475] - result already collected: FutureResult
[16:11:05.476] result() for ClusterFuture ... done
[16:11:05.476] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:05.476] - nx: 2
[16:11:05.476] - relay: TRUE
[16:11:05.476] - stdout: TRUE
[16:11:05.476] - signal: TRUE
[16:11:05.476] - resignal: FALSE
[16:11:05.476] - force: TRUE
[16:11:05.476] - relayed: [n=2] TRUE, FALSE
[16:11:05.476] - queued futures: [n=2] TRUE, FALSE
[16:11:05.476]  - until=2
[16:11:05.477]  - relaying element #2
[16:11:05.477] result() for ClusterFuture ...
[16:11:05.477] - result already collected: FutureResult
[16:11:05.477] result() for ClusterFuture ... done
[16:11:05.477] result() for ClusterFuture ...
[16:11:05.477] - result already collected: FutureResult
[16:11:05.477] result() for ClusterFuture ... done
[16:11:05.477] result() for ClusterFuture ...
[16:11:05.477] - result already collected: FutureResult
[16:11:05.477] result() for ClusterFuture ... done
[16:11:05.477] result() for ClusterFuture ...
[16:11:05.478] - result already collected: FutureResult
[16:11:05.478] result() for ClusterFuture ... done
[16:11:05.478] - relayed: [n=2] TRUE, TRUE
[16:11:05.478] - queued futures: [n=2] TRUE, TRUE
[16:11:05.478] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:05.478]  length: 0 (resolved future 2)
[16:11:05.478] Relaying remaining futures
[16:11:05.478] signalConditionsASAP(NULL, pos=0) ...
[16:11:05.478] - nx: 2
[16:11:05.478] - relay: TRUE
[16:11:05.478] - stdout: TRUE
[16:11:05.478] - signal: TRUE
[16:11:05.479] - resignal: FALSE
[16:11:05.479] - force: TRUE
[16:11:05.479] - relayed: [n=2] TRUE, TRUE
[16:11:05.479] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:05.479] - relayed: [n=2] TRUE, TRUE
[16:11:05.479] - queued futures: [n=2] TRUE, TRUE
[16:11:05.479] signalConditionsASAP(NULL, pos=0) ... done
[16:11:05.479] resolve() on list ... DONE
[16:11:05.479] result() for ClusterFuture ...
[16:11:05.479] - result already collected: FutureResult
[16:11:05.479] result() for ClusterFuture ... done
[16:11:05.480] result() for ClusterFuture ...
[16:11:05.480] - result already collected: FutureResult
[16:11:05.480] result() for ClusterFuture ... done
[16:11:05.480] result() for ClusterFuture ...
[16:11:05.480] - result already collected: FutureResult
[16:11:05.480] result() for ClusterFuture ... done
[16:11:05.480] result() for ClusterFuture ...
[16:11:05.480] - result already collected: FutureResult
[16:11:05.480] result() for ClusterFuture ... done
[16:11:05.480]  - Number of value chunks collected: 2
[16:11:05.480] Resolving 2 futures (chunks) ... DONE
[16:11:05.481] Reducing values from 2 chunks ...
[16:11:05.481]  - Number of values collected after concatenation: 10
[16:11:05.481]  - Number of values expected: 10
[16:11:05.481] Reducing values from 2 chunks ... DONE
[16:11:05.481] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:11:05.482] future_lapply() ...
[16:11:05.487] Number of chunks: 2
[16:11:05.487] getGlobalsAndPackagesXApply() ...
[16:11:05.487]  - future.globals: TRUE
[16:11:05.488] getGlobalsAndPackages() ...
[16:11:05.488] Searching for globals...
[16:11:05.491] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:11:05.492] Searching for globals ... DONE
[16:11:05.492] Resolving globals: FALSE
[16:11:05.493] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[16:11:05.493] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:05.493] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:05.493] - packages: [1] ‘future.apply’
[16:11:05.493] getGlobalsAndPackages() ... DONE
[16:11:05.493]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:05.493]  - needed namespaces: [n=1] ‘future.apply’
[16:11:05.494] Finding globals ... DONE
[16:11:05.494]  - use_args: TRUE
[16:11:05.494]  - Getting '...' globals ...
[16:11:05.494] resolve() on list ...
[16:11:05.494]  recursive: 0
[16:11:05.494]  length: 1
[16:11:05.494]  elements: ‘...’
[16:11:05.494]  length: 0 (resolved future 1)
[16:11:05.495] resolve() on list ... DONE
[16:11:05.495]    - '...' content: [n=0] 
[16:11:05.495] List of 1
[16:11:05.495]  $ ...: list()
[16:11:05.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:05.495]  - attr(*, "where")=List of 1
[16:11:05.495]   ..$ ...:<environment: 0x561e8b6bc748> 
[16:11:05.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:05.495]  - attr(*, "resolved")= logi TRUE
[16:11:05.495]  - attr(*, "total_size")= num NA
[16:11:05.497]  - Getting '...' globals ... DONE
[16:11:05.497] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:05.498] List of 8
[16:11:05.498]  $ ...future.FUN:function (x, ...)  
[16:11:05.498]  $ x_FUN        :function (x)  
[16:11:05.498]  $ times        : int 4
[16:11:05.498]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:05.498]  $ stop_if_not  :function (...)  
[16:11:05.498]  $ dim          : int [1:2] 2 2
[16:11:05.498]  $ valid_types  : chr [1:2] "logical" "integer"
[16:11:05.498]  $ ...          : list()
[16:11:05.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:05.498]  - attr(*, "where")=List of 8
[16:11:05.498]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:05.498]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:05.498]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:05.498]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:05.498]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:05.498]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:05.498]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:05.498]   ..$ ...          :<environment: 0x561e8b6bc748> 
[16:11:05.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:05.498]  - attr(*, "resolved")= logi FALSE
[16:11:05.498]  - attr(*, "total_size")= num 97232
[16:11:05.503] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:05.503] getGlobalsAndPackagesXApply() ... DONE
[16:11:05.503] Number of futures (= number of chunks): 2
[16:11:05.503] Launching 2 futures (chunks) ...
[16:11:05.503] Chunk #1 of 2 ...
[16:11:05.504]  - Finding globals in 'X' for chunk #1 ...
[16:11:05.504] getGlobalsAndPackages() ...
[16:11:05.504] Searching for globals...
[16:11:05.504] 
[16:11:05.504] Searching for globals ... DONE
[16:11:05.504] - globals: [0] <none>
[16:11:05.504] getGlobalsAndPackages() ... DONE
[16:11:05.504]    + additional globals found: [n=0] 
[16:11:05.504]    + additional namespaces needed: [n=0] 
[16:11:05.505]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:05.505]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:05.505]  - seeds: <none>
[16:11:05.505] getGlobalsAndPackages() ...
[16:11:05.505] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.505] Resolving globals: FALSE
[16:11:05.505] Tweak future expression to call with '...' arguments ...
[16:11:05.505] {
[16:11:05.505]     do.call(function(...) {
[16:11:05.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.505]             on.exit(options(oopts), add = TRUE)
[16:11:05.505]         }
[16:11:05.505]         {
[16:11:05.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.505]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.505]             })
[16:11:05.505]         }
[16:11:05.505]     }, args = future.call.arguments)
[16:11:05.505] }
[16:11:05.505] Tweak future expression to call with '...' arguments ... DONE
[16:11:05.506] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.506] - packages: [1] ‘future.apply’
[16:11:05.506] getGlobalsAndPackages() ... DONE
[16:11:05.506] run() for ‘Future’ ...
[16:11:05.507] - state: ‘created’
[16:11:05.507] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:05.522] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:05.522]   - Field: ‘node’
[16:11:05.522]   - Field: ‘label’
[16:11:05.522]   - Field: ‘local’
[16:11:05.523]   - Field: ‘owner’
[16:11:05.523]   - Field: ‘envir’
[16:11:05.523]   - Field: ‘workers’
[16:11:05.523]   - Field: ‘packages’
[16:11:05.523]   - Field: ‘gc’
[16:11:05.523]   - Field: ‘conditions’
[16:11:05.523]   - Field: ‘persistent’
[16:11:05.523]   - Field: ‘expr’
[16:11:05.523]   - Field: ‘uuid’
[16:11:05.523]   - Field: ‘seed’
[16:11:05.523]   - Field: ‘version’
[16:11:05.524]   - Field: ‘result’
[16:11:05.524]   - Field: ‘asynchronous’
[16:11:05.524]   - Field: ‘calls’
[16:11:05.524]   - Field: ‘globals’
[16:11:05.524]   - Field: ‘stdout’
[16:11:05.524]   - Field: ‘earlySignal’
[16:11:05.524]   - Field: ‘lazy’
[16:11:05.524]   - Field: ‘state’
[16:11:05.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:05.524] - Launch lazy future ...
[16:11:05.525] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:05.525] Packages needed by future strategies (n = 0): <none>
[16:11:05.525] {
[16:11:05.525]     {
[16:11:05.525]         {
[16:11:05.525]             ...future.startTime <- base::Sys.time()
[16:11:05.525]             {
[16:11:05.525]                 {
[16:11:05.525]                   {
[16:11:05.525]                     {
[16:11:05.525]                       {
[16:11:05.525]                         base::local({
[16:11:05.525]                           has_future <- base::requireNamespace("future", 
[16:11:05.525]                             quietly = TRUE)
[16:11:05.525]                           if (has_future) {
[16:11:05.525]                             ns <- base::getNamespace("future")
[16:11:05.525]                             version <- ns[[".package"]][["version"]]
[16:11:05.525]                             if (is.null(version)) 
[16:11:05.525]                               version <- utils::packageVersion("future")
[16:11:05.525]                           }
[16:11:05.525]                           else {
[16:11:05.525]                             version <- NULL
[16:11:05.525]                           }
[16:11:05.525]                           if (!has_future || version < "1.8.0") {
[16:11:05.525]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:05.525]                               "", base::R.version$version.string), 
[16:11:05.525]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:05.525]                                 base::R.version$platform, 8 * 
[16:11:05.525]                                   base::.Machine$sizeof.pointer), 
[16:11:05.525]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:05.525]                                 "release", "version")], collapse = " "), 
[16:11:05.525]                               hostname = base::Sys.info()[["nodename"]])
[16:11:05.525]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:05.525]                               info)
[16:11:05.525]                             info <- base::paste(info, collapse = "; ")
[16:11:05.525]                             if (!has_future) {
[16:11:05.525]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:05.525]                                 info)
[16:11:05.525]                             }
[16:11:05.525]                             else {
[16:11:05.525]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:05.525]                                 info, version)
[16:11:05.525]                             }
[16:11:05.525]                             base::stop(msg)
[16:11:05.525]                           }
[16:11:05.525]                         })
[16:11:05.525]                       }
[16:11:05.525]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:05.525]                       base::options(mc.cores = 1L)
[16:11:05.525]                     }
[16:11:05.525]                     base::local({
[16:11:05.525]                       for (pkg in "future.apply") {
[16:11:05.525]                         base::loadNamespace(pkg)
[16:11:05.525]                         base::library(pkg, character.only = TRUE)
[16:11:05.525]                       }
[16:11:05.525]                     })
[16:11:05.525]                   }
[16:11:05.525]                   options(future.plan = NULL)
[16:11:05.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:05.525]                 }
[16:11:05.525]                 ...future.workdir <- getwd()
[16:11:05.525]             }
[16:11:05.525]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:05.525]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:05.525]         }
[16:11:05.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:05.525]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:05.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:05.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:05.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:05.525]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:05.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:05.525]             base::names(...future.oldOptions))
[16:11:05.525]     }
[16:11:05.525]     if (FALSE) {
[16:11:05.525]     }
[16:11:05.525]     else {
[16:11:05.525]         if (TRUE) {
[16:11:05.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:05.525]                 open = "w")
[16:11:05.525]         }
[16:11:05.525]         else {
[16:11:05.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:05.525]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:05.525]         }
[16:11:05.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:05.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:05.525]             base::sink(type = "output", split = FALSE)
[16:11:05.525]             base::close(...future.stdout)
[16:11:05.525]         }, add = TRUE)
[16:11:05.525]     }
[16:11:05.525]     ...future.frame <- base::sys.nframe()
[16:11:05.525]     ...future.conditions <- base::list()
[16:11:05.525]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:05.525]     if (FALSE) {
[16:11:05.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:05.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:05.525]     }
[16:11:05.525]     ...future.result <- base::tryCatch({
[16:11:05.525]         base::withCallingHandlers({
[16:11:05.525]             ...future.value <- base::withVisible(base::local({
[16:11:05.525]                 ...future.makeSendCondition <- local({
[16:11:05.525]                   sendCondition <- NULL
[16:11:05.525]                   function(frame = 1L) {
[16:11:05.525]                     if (is.function(sendCondition)) 
[16:11:05.525]                       return(sendCondition)
[16:11:05.525]                     ns <- getNamespace("parallel")
[16:11:05.525]                     if (exists("sendData", mode = "function", 
[16:11:05.525]                       envir = ns)) {
[16:11:05.525]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:05.525]                         envir = ns)
[16:11:05.525]                       envir <- sys.frame(frame)
[16:11:05.525]                       master <- NULL
[16:11:05.525]                       while (!identical(envir, .GlobalEnv) && 
[16:11:05.525]                         !identical(envir, emptyenv())) {
[16:11:05.525]                         if (exists("master", mode = "list", envir = envir, 
[16:11:05.525]                           inherits = FALSE)) {
[16:11:05.525]                           master <- get("master", mode = "list", 
[16:11:05.525]                             envir = envir, inherits = FALSE)
[16:11:05.525]                           if (inherits(master, c("SOCKnode", 
[16:11:05.525]                             "SOCK0node"))) {
[16:11:05.525]                             sendCondition <<- function(cond) {
[16:11:05.525]                               data <- list(type = "VALUE", value = cond, 
[16:11:05.525]                                 success = TRUE)
[16:11:05.525]                               parallel_sendData(master, data)
[16:11:05.525]                             }
[16:11:05.525]                             return(sendCondition)
[16:11:05.525]                           }
[16:11:05.525]                         }
[16:11:05.525]                         frame <- frame + 1L
[16:11:05.525]                         envir <- sys.frame(frame)
[16:11:05.525]                       }
[16:11:05.525]                     }
[16:11:05.525]                     sendCondition <<- function(cond) NULL
[16:11:05.525]                   }
[16:11:05.525]                 })
[16:11:05.525]                 withCallingHandlers({
[16:11:05.525]                   {
[16:11:05.525]                     do.call(function(...) {
[16:11:05.525]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.525]                       if (!identical(...future.globals.maxSize.org, 
[16:11:05.525]                         ...future.globals.maxSize)) {
[16:11:05.525]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.525]                         on.exit(options(oopts), add = TRUE)
[16:11:05.525]                       }
[16:11:05.525]                       {
[16:11:05.525]                         lapply(seq_along(...future.elements_ii), 
[16:11:05.525]                           FUN = function(jj) {
[16:11:05.525]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.525]                             ...future.FUN(...future.X_jj, ...)
[16:11:05.525]                           })
[16:11:05.525]                       }
[16:11:05.525]                     }, args = future.call.arguments)
[16:11:05.525]                   }
[16:11:05.525]                 }, immediateCondition = function(cond) {
[16:11:05.525]                   sendCondition <- ...future.makeSendCondition()
[16:11:05.525]                   sendCondition(cond)
[16:11:05.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.525]                   {
[16:11:05.525]                     inherits <- base::inherits
[16:11:05.525]                     invokeRestart <- base::invokeRestart
[16:11:05.525]                     is.null <- base::is.null
[16:11:05.525]                     muffled <- FALSE
[16:11:05.525]                     if (inherits(cond, "message")) {
[16:11:05.525]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:05.525]                       if (muffled) 
[16:11:05.525]                         invokeRestart("muffleMessage")
[16:11:05.525]                     }
[16:11:05.525]                     else if (inherits(cond, "warning")) {
[16:11:05.525]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:05.525]                       if (muffled) 
[16:11:05.525]                         invokeRestart("muffleWarning")
[16:11:05.525]                     }
[16:11:05.525]                     else if (inherits(cond, "condition")) {
[16:11:05.525]                       if (!is.null(pattern)) {
[16:11:05.525]                         computeRestarts <- base::computeRestarts
[16:11:05.525]                         grepl <- base::grepl
[16:11:05.525]                         restarts <- computeRestarts(cond)
[16:11:05.525]                         for (restart in restarts) {
[16:11:05.525]                           name <- restart$name
[16:11:05.525]                           if (is.null(name)) 
[16:11:05.525]                             next
[16:11:05.525]                           if (!grepl(pattern, name)) 
[16:11:05.525]                             next
[16:11:05.525]                           invokeRestart(restart)
[16:11:05.525]                           muffled <- TRUE
[16:11:05.525]                           break
[16:11:05.525]                         }
[16:11:05.525]                       }
[16:11:05.525]                     }
[16:11:05.525]                     invisible(muffled)
[16:11:05.525]                   }
[16:11:05.525]                   muffleCondition(cond)
[16:11:05.525]                 })
[16:11:05.525]             }))
[16:11:05.525]             future::FutureResult(value = ...future.value$value, 
[16:11:05.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.525]                   ...future.rng), globalenv = if (FALSE) 
[16:11:05.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:05.525]                     ...future.globalenv.names))
[16:11:05.525]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:05.525]         }, condition = base::local({
[16:11:05.525]             c <- base::c
[16:11:05.525]             inherits <- base::inherits
[16:11:05.525]             invokeRestart <- base::invokeRestart
[16:11:05.525]             length <- base::length
[16:11:05.525]             list <- base::list
[16:11:05.525]             seq.int <- base::seq.int
[16:11:05.525]             signalCondition <- base::signalCondition
[16:11:05.525]             sys.calls <- base::sys.calls
[16:11:05.525]             `[[` <- base::`[[`
[16:11:05.525]             `+` <- base::`+`
[16:11:05.525]             `<<-` <- base::`<<-`
[16:11:05.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:05.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:05.525]                   3L)]
[16:11:05.525]             }
[16:11:05.525]             function(cond) {
[16:11:05.525]                 is_error <- inherits(cond, "error")
[16:11:05.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:05.525]                   NULL)
[16:11:05.525]                 if (is_error) {
[16:11:05.525]                   sessionInformation <- function() {
[16:11:05.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:05.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:05.525]                       search = base::search(), system = base::Sys.info())
[16:11:05.525]                   }
[16:11:05.525]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:05.525]                     cond$call), session = sessionInformation(), 
[16:11:05.525]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:05.525]                   signalCondition(cond)
[16:11:05.525]                 }
[16:11:05.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:05.525]                 "immediateCondition"))) {
[16:11:05.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:05.525]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:05.525]                   if (TRUE && !signal) {
[16:11:05.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.525]                     {
[16:11:05.525]                       inherits <- base::inherits
[16:11:05.525]                       invokeRestart <- base::invokeRestart
[16:11:05.525]                       is.null <- base::is.null
[16:11:05.525]                       muffled <- FALSE
[16:11:05.525]                       if (inherits(cond, "message")) {
[16:11:05.525]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.525]                         if (muffled) 
[16:11:05.525]                           invokeRestart("muffleMessage")
[16:11:05.525]                       }
[16:11:05.525]                       else if (inherits(cond, "warning")) {
[16:11:05.525]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.525]                         if (muffled) 
[16:11:05.525]                           invokeRestart("muffleWarning")
[16:11:05.525]                       }
[16:11:05.525]                       else if (inherits(cond, "condition")) {
[16:11:05.525]                         if (!is.null(pattern)) {
[16:11:05.525]                           computeRestarts <- base::computeRestarts
[16:11:05.525]                           grepl <- base::grepl
[16:11:05.525]                           restarts <- computeRestarts(cond)
[16:11:05.525]                           for (restart in restarts) {
[16:11:05.525]                             name <- restart$name
[16:11:05.525]                             if (is.null(name)) 
[16:11:05.525]                               next
[16:11:05.525]                             if (!grepl(pattern, name)) 
[16:11:05.525]                               next
[16:11:05.525]                             invokeRestart(restart)
[16:11:05.525]                             muffled <- TRUE
[16:11:05.525]                             break
[16:11:05.525]                           }
[16:11:05.525]                         }
[16:11:05.525]                       }
[16:11:05.525]                       invisible(muffled)
[16:11:05.525]                     }
[16:11:05.525]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.525]                   }
[16:11:05.525]                 }
[16:11:05.525]                 else {
[16:11:05.525]                   if (TRUE) {
[16:11:05.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.525]                     {
[16:11:05.525]                       inherits <- base::inherits
[16:11:05.525]                       invokeRestart <- base::invokeRestart
[16:11:05.525]                       is.null <- base::is.null
[16:11:05.525]                       muffled <- FALSE
[16:11:05.525]                       if (inherits(cond, "message")) {
[16:11:05.525]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.525]                         if (muffled) 
[16:11:05.525]                           invokeRestart("muffleMessage")
[16:11:05.525]                       }
[16:11:05.525]                       else if (inherits(cond, "warning")) {
[16:11:05.525]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.525]                         if (muffled) 
[16:11:05.525]                           invokeRestart("muffleWarning")
[16:11:05.525]                       }
[16:11:05.525]                       else if (inherits(cond, "condition")) {
[16:11:05.525]                         if (!is.null(pattern)) {
[16:11:05.525]                           computeRestarts <- base::computeRestarts
[16:11:05.525]                           grepl <- base::grepl
[16:11:05.525]                           restarts <- computeRestarts(cond)
[16:11:05.525]                           for (restart in restarts) {
[16:11:05.525]                             name <- restart$name
[16:11:05.525]                             if (is.null(name)) 
[16:11:05.525]                               next
[16:11:05.525]                             if (!grepl(pattern, name)) 
[16:11:05.525]                               next
[16:11:05.525]                             invokeRestart(restart)
[16:11:05.525]                             muffled <- TRUE
[16:11:05.525]                             break
[16:11:05.525]                           }
[16:11:05.525]                         }
[16:11:05.525]                       }
[16:11:05.525]                       invisible(muffled)
[16:11:05.525]                     }
[16:11:05.525]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.525]                   }
[16:11:05.525]                 }
[16:11:05.525]             }
[16:11:05.525]         }))
[16:11:05.525]     }, error = function(ex) {
[16:11:05.525]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:05.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.525]                 ...future.rng), started = ...future.startTime, 
[16:11:05.525]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:05.525]             version = "1.8"), class = "FutureResult")
[16:11:05.525]     }, finally = {
[16:11:05.525]         if (!identical(...future.workdir, getwd())) 
[16:11:05.525]             setwd(...future.workdir)
[16:11:05.525]         {
[16:11:05.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:05.525]                 ...future.oldOptions$nwarnings <- NULL
[16:11:05.525]             }
[16:11:05.525]             base::options(...future.oldOptions)
[16:11:05.525]             if (.Platform$OS.type == "windows") {
[16:11:05.525]                 old_names <- names(...future.oldEnvVars)
[16:11:05.525]                 envs <- base::Sys.getenv()
[16:11:05.525]                 names <- names(envs)
[16:11:05.525]                 common <- intersect(names, old_names)
[16:11:05.525]                 added <- setdiff(names, old_names)
[16:11:05.525]                 removed <- setdiff(old_names, names)
[16:11:05.525]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:05.525]                   envs[common]]
[16:11:05.525]                 NAMES <- toupper(changed)
[16:11:05.525]                 args <- list()
[16:11:05.525]                 for (kk in seq_along(NAMES)) {
[16:11:05.525]                   name <- changed[[kk]]
[16:11:05.525]                   NAME <- NAMES[[kk]]
[16:11:05.525]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.525]                     next
[16:11:05.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.525]                 }
[16:11:05.525]                 NAMES <- toupper(added)
[16:11:05.525]                 for (kk in seq_along(NAMES)) {
[16:11:05.525]                   name <- added[[kk]]
[16:11:05.525]                   NAME <- NAMES[[kk]]
[16:11:05.525]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.525]                     next
[16:11:05.525]                   args[[name]] <- ""
[16:11:05.525]                 }
[16:11:05.525]                 NAMES <- toupper(removed)
[16:11:05.525]                 for (kk in seq_along(NAMES)) {
[16:11:05.525]                   name <- removed[[kk]]
[16:11:05.525]                   NAME <- NAMES[[kk]]
[16:11:05.525]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.525]                     next
[16:11:05.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.525]                 }
[16:11:05.525]                 if (length(args) > 0) 
[16:11:05.525]                   base::do.call(base::Sys.setenv, args = args)
[16:11:05.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:05.525]             }
[16:11:05.525]             else {
[16:11:05.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:05.525]             }
[16:11:05.525]             {
[16:11:05.525]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:05.525]                   0L) {
[16:11:05.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:05.525]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:05.525]                   base::options(opts)
[16:11:05.525]                 }
[16:11:05.525]                 {
[16:11:05.525]                   {
[16:11:05.525]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:05.525]                     NULL
[16:11:05.525]                   }
[16:11:05.525]                   options(future.plan = NULL)
[16:11:05.525]                   if (is.na(NA_character_)) 
[16:11:05.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:05.525]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:05.525]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:05.525]                     envir = parent.frame()) 
[16:11:05.525]                   {
[16:11:05.525]                     if (is.function(workers)) 
[16:11:05.525]                       workers <- workers()
[16:11:05.525]                     workers <- structure(as.integer(workers), 
[16:11:05.525]                       class = class(workers))
[16:11:05.525]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:05.525]                       workers >= 1)
[16:11:05.525]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:05.525]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:05.525]                     }
[16:11:05.525]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:05.525]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:05.525]                       envir = envir)
[16:11:05.525]                     if (!future$lazy) 
[16:11:05.525]                       future <- run(future)
[16:11:05.525]                     invisible(future)
[16:11:05.525]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:05.525]                 }
[16:11:05.525]             }
[16:11:05.525]         }
[16:11:05.525]     })
[16:11:05.525]     if (TRUE) {
[16:11:05.525]         base::sink(type = "output", split = FALSE)
[16:11:05.525]         if (TRUE) {
[16:11:05.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:05.525]         }
[16:11:05.525]         else {
[16:11:05.525]             ...future.result["stdout"] <- base::list(NULL)
[16:11:05.525]         }
[16:11:05.525]         base::close(...future.stdout)
[16:11:05.525]         ...future.stdout <- NULL
[16:11:05.525]     }
[16:11:05.525]     ...future.result$conditions <- ...future.conditions
[16:11:05.525]     ...future.result$finished <- base::Sys.time()
[16:11:05.525]     ...future.result
[16:11:05.525] }
[16:11:05.528] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[16:11:05.528] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:05.572] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:05.572] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[16:11:05.573] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[16:11:05.573] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:05.573] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:05.573] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:05.616] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:05.616] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:05.660] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:05.660] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:11:05.660] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:11:05.661] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:11:05.661] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:11:05.661] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:05.662] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:05.662] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:11:05.662] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:11:05.662] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:05.663] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:05.663] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:05.663] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:05.663] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[16:11:05.664] MultisessionFuture started
[16:11:05.664] - Launch lazy future ... done
[16:11:05.664] run() for ‘MultisessionFuture’ ... done
[16:11:05.664] Created future:
[16:11:05.665] MultisessionFuture:
[16:11:05.665] Label: ‘future_vapply-1’
[16:11:05.665] Expression:
[16:11:05.665] {
[16:11:05.665]     do.call(function(...) {
[16:11:05.665]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.665]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.665]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.665]             on.exit(options(oopts), add = TRUE)
[16:11:05.665]         }
[16:11:05.665]         {
[16:11:05.665]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.665]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.665]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.665]             })
[16:11:05.665]         }
[16:11:05.665]     }, args = future.call.arguments)
[16:11:05.665] }
[16:11:05.665] Lazy evaluation: FALSE
[16:11:05.665] Asynchronous evaluation: TRUE
[16:11:05.665] Local evaluation: TRUE
[16:11:05.665] Environment: R_GlobalEnv
[16:11:05.665] Capture standard output: TRUE
[16:11:05.665] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:05.665] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:05.665] Packages: 1 packages (‘future.apply’)
[16:11:05.665] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:05.665] Resolved: FALSE
[16:11:05.665] Value: <not collected>
[16:11:05.665] Conditions captured: <none>
[16:11:05.665] Early signaling: FALSE
[16:11:05.665] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:05.665] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.678] Chunk #1 of 2 ... DONE
[16:11:05.679] Chunk #2 of 2 ...
[16:11:05.679]  - Finding globals in 'X' for chunk #2 ...
[16:11:05.679] getGlobalsAndPackages() ...
[16:11:05.679] Searching for globals...
[16:11:05.679] 
[16:11:05.679] Searching for globals ... DONE
[16:11:05.679] - globals: [0] <none>
[16:11:05.679] getGlobalsAndPackages() ... DONE
[16:11:05.679]    + additional globals found: [n=0] 
[16:11:05.680]    + additional namespaces needed: [n=0] 
[16:11:05.680]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:05.680]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:05.680]  - seeds: <none>
[16:11:05.680] getGlobalsAndPackages() ...
[16:11:05.680] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.680] Resolving globals: FALSE
[16:11:05.680] Tweak future expression to call with '...' arguments ...
[16:11:05.680] {
[16:11:05.680]     do.call(function(...) {
[16:11:05.680]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.680]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.680]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.680]             on.exit(options(oopts), add = TRUE)
[16:11:05.680]         }
[16:11:05.680]         {
[16:11:05.680]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.680]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.680]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.680]             })
[16:11:05.680]         }
[16:11:05.680]     }, args = future.call.arguments)
[16:11:05.680] }
[16:11:05.681] Tweak future expression to call with '...' arguments ... DONE
[16:11:05.681] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.681] - packages: [1] ‘future.apply’
[16:11:05.681] getGlobalsAndPackages() ... DONE
[16:11:05.682] run() for ‘Future’ ...
[16:11:05.682] - state: ‘created’
[16:11:05.682] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:05.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:05.696]   - Field: ‘node’
[16:11:05.697]   - Field: ‘label’
[16:11:05.697]   - Field: ‘local’
[16:11:05.697]   - Field: ‘owner’
[16:11:05.697]   - Field: ‘envir’
[16:11:05.697]   - Field: ‘workers’
[16:11:05.697]   - Field: ‘packages’
[16:11:05.697]   - Field: ‘gc’
[16:11:05.697]   - Field: ‘conditions’
[16:11:05.697]   - Field: ‘persistent’
[16:11:05.697]   - Field: ‘expr’
[16:11:05.697]   - Field: ‘uuid’
[16:11:05.697]   - Field: ‘seed’
[16:11:05.698]   - Field: ‘version’
[16:11:05.698]   - Field: ‘result’
[16:11:05.698]   - Field: ‘asynchronous’
[16:11:05.698]   - Field: ‘calls’
[16:11:05.698]   - Field: ‘globals’
[16:11:05.698]   - Field: ‘stdout’
[16:11:05.698]   - Field: ‘earlySignal’
[16:11:05.698]   - Field: ‘lazy’
[16:11:05.698]   - Field: ‘state’
[16:11:05.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:05.698] - Launch lazy future ...
[16:11:05.699] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:05.699] Packages needed by future strategies (n = 0): <none>
[16:11:05.699] {
[16:11:05.699]     {
[16:11:05.699]         {
[16:11:05.699]             ...future.startTime <- base::Sys.time()
[16:11:05.699]             {
[16:11:05.699]                 {
[16:11:05.699]                   {
[16:11:05.699]                     {
[16:11:05.699]                       {
[16:11:05.699]                         base::local({
[16:11:05.699]                           has_future <- base::requireNamespace("future", 
[16:11:05.699]                             quietly = TRUE)
[16:11:05.699]                           if (has_future) {
[16:11:05.699]                             ns <- base::getNamespace("future")
[16:11:05.699]                             version <- ns[[".package"]][["version"]]
[16:11:05.699]                             if (is.null(version)) 
[16:11:05.699]                               version <- utils::packageVersion("future")
[16:11:05.699]                           }
[16:11:05.699]                           else {
[16:11:05.699]                             version <- NULL
[16:11:05.699]                           }
[16:11:05.699]                           if (!has_future || version < "1.8.0") {
[16:11:05.699]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:05.699]                               "", base::R.version$version.string), 
[16:11:05.699]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:05.699]                                 base::R.version$platform, 8 * 
[16:11:05.699]                                   base::.Machine$sizeof.pointer), 
[16:11:05.699]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:05.699]                                 "release", "version")], collapse = " "), 
[16:11:05.699]                               hostname = base::Sys.info()[["nodename"]])
[16:11:05.699]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:05.699]                               info)
[16:11:05.699]                             info <- base::paste(info, collapse = "; ")
[16:11:05.699]                             if (!has_future) {
[16:11:05.699]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:05.699]                                 info)
[16:11:05.699]                             }
[16:11:05.699]                             else {
[16:11:05.699]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:05.699]                                 info, version)
[16:11:05.699]                             }
[16:11:05.699]                             base::stop(msg)
[16:11:05.699]                           }
[16:11:05.699]                         })
[16:11:05.699]                       }
[16:11:05.699]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:05.699]                       base::options(mc.cores = 1L)
[16:11:05.699]                     }
[16:11:05.699]                     base::local({
[16:11:05.699]                       for (pkg in "future.apply") {
[16:11:05.699]                         base::loadNamespace(pkg)
[16:11:05.699]                         base::library(pkg, character.only = TRUE)
[16:11:05.699]                       }
[16:11:05.699]                     })
[16:11:05.699]                   }
[16:11:05.699]                   options(future.plan = NULL)
[16:11:05.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:05.699]                 }
[16:11:05.699]                 ...future.workdir <- getwd()
[16:11:05.699]             }
[16:11:05.699]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:05.699]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:05.699]         }
[16:11:05.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:05.699]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:05.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:05.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:05.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:05.699]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:05.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:05.699]             base::names(...future.oldOptions))
[16:11:05.699]     }
[16:11:05.699]     if (FALSE) {
[16:11:05.699]     }
[16:11:05.699]     else {
[16:11:05.699]         if (TRUE) {
[16:11:05.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:05.699]                 open = "w")
[16:11:05.699]         }
[16:11:05.699]         else {
[16:11:05.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:05.699]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:05.699]         }
[16:11:05.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:05.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:05.699]             base::sink(type = "output", split = FALSE)
[16:11:05.699]             base::close(...future.stdout)
[16:11:05.699]         }, add = TRUE)
[16:11:05.699]     }
[16:11:05.699]     ...future.frame <- base::sys.nframe()
[16:11:05.699]     ...future.conditions <- base::list()
[16:11:05.699]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:05.699]     if (FALSE) {
[16:11:05.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:05.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:05.699]     }
[16:11:05.699]     ...future.result <- base::tryCatch({
[16:11:05.699]         base::withCallingHandlers({
[16:11:05.699]             ...future.value <- base::withVisible(base::local({
[16:11:05.699]                 ...future.makeSendCondition <- local({
[16:11:05.699]                   sendCondition <- NULL
[16:11:05.699]                   function(frame = 1L) {
[16:11:05.699]                     if (is.function(sendCondition)) 
[16:11:05.699]                       return(sendCondition)
[16:11:05.699]                     ns <- getNamespace("parallel")
[16:11:05.699]                     if (exists("sendData", mode = "function", 
[16:11:05.699]                       envir = ns)) {
[16:11:05.699]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:05.699]                         envir = ns)
[16:11:05.699]                       envir <- sys.frame(frame)
[16:11:05.699]                       master <- NULL
[16:11:05.699]                       while (!identical(envir, .GlobalEnv) && 
[16:11:05.699]                         !identical(envir, emptyenv())) {
[16:11:05.699]                         if (exists("master", mode = "list", envir = envir, 
[16:11:05.699]                           inherits = FALSE)) {
[16:11:05.699]                           master <- get("master", mode = "list", 
[16:11:05.699]                             envir = envir, inherits = FALSE)
[16:11:05.699]                           if (inherits(master, c("SOCKnode", 
[16:11:05.699]                             "SOCK0node"))) {
[16:11:05.699]                             sendCondition <<- function(cond) {
[16:11:05.699]                               data <- list(type = "VALUE", value = cond, 
[16:11:05.699]                                 success = TRUE)
[16:11:05.699]                               parallel_sendData(master, data)
[16:11:05.699]                             }
[16:11:05.699]                             return(sendCondition)
[16:11:05.699]                           }
[16:11:05.699]                         }
[16:11:05.699]                         frame <- frame + 1L
[16:11:05.699]                         envir <- sys.frame(frame)
[16:11:05.699]                       }
[16:11:05.699]                     }
[16:11:05.699]                     sendCondition <<- function(cond) NULL
[16:11:05.699]                   }
[16:11:05.699]                 })
[16:11:05.699]                 withCallingHandlers({
[16:11:05.699]                   {
[16:11:05.699]                     do.call(function(...) {
[16:11:05.699]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.699]                       if (!identical(...future.globals.maxSize.org, 
[16:11:05.699]                         ...future.globals.maxSize)) {
[16:11:05.699]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.699]                         on.exit(options(oopts), add = TRUE)
[16:11:05.699]                       }
[16:11:05.699]                       {
[16:11:05.699]                         lapply(seq_along(...future.elements_ii), 
[16:11:05.699]                           FUN = function(jj) {
[16:11:05.699]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.699]                             ...future.FUN(...future.X_jj, ...)
[16:11:05.699]                           })
[16:11:05.699]                       }
[16:11:05.699]                     }, args = future.call.arguments)
[16:11:05.699]                   }
[16:11:05.699]                 }, immediateCondition = function(cond) {
[16:11:05.699]                   sendCondition <- ...future.makeSendCondition()
[16:11:05.699]                   sendCondition(cond)
[16:11:05.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.699]                   {
[16:11:05.699]                     inherits <- base::inherits
[16:11:05.699]                     invokeRestart <- base::invokeRestart
[16:11:05.699]                     is.null <- base::is.null
[16:11:05.699]                     muffled <- FALSE
[16:11:05.699]                     if (inherits(cond, "message")) {
[16:11:05.699]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:05.699]                       if (muffled) 
[16:11:05.699]                         invokeRestart("muffleMessage")
[16:11:05.699]                     }
[16:11:05.699]                     else if (inherits(cond, "warning")) {
[16:11:05.699]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:05.699]                       if (muffled) 
[16:11:05.699]                         invokeRestart("muffleWarning")
[16:11:05.699]                     }
[16:11:05.699]                     else if (inherits(cond, "condition")) {
[16:11:05.699]                       if (!is.null(pattern)) {
[16:11:05.699]                         computeRestarts <- base::computeRestarts
[16:11:05.699]                         grepl <- base::grepl
[16:11:05.699]                         restarts <- computeRestarts(cond)
[16:11:05.699]                         for (restart in restarts) {
[16:11:05.699]                           name <- restart$name
[16:11:05.699]                           if (is.null(name)) 
[16:11:05.699]                             next
[16:11:05.699]                           if (!grepl(pattern, name)) 
[16:11:05.699]                             next
[16:11:05.699]                           invokeRestart(restart)
[16:11:05.699]                           muffled <- TRUE
[16:11:05.699]                           break
[16:11:05.699]                         }
[16:11:05.699]                       }
[16:11:05.699]                     }
[16:11:05.699]                     invisible(muffled)
[16:11:05.699]                   }
[16:11:05.699]                   muffleCondition(cond)
[16:11:05.699]                 })
[16:11:05.699]             }))
[16:11:05.699]             future::FutureResult(value = ...future.value$value, 
[16:11:05.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.699]                   ...future.rng), globalenv = if (FALSE) 
[16:11:05.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:05.699]                     ...future.globalenv.names))
[16:11:05.699]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:05.699]         }, condition = base::local({
[16:11:05.699]             c <- base::c
[16:11:05.699]             inherits <- base::inherits
[16:11:05.699]             invokeRestart <- base::invokeRestart
[16:11:05.699]             length <- base::length
[16:11:05.699]             list <- base::list
[16:11:05.699]             seq.int <- base::seq.int
[16:11:05.699]             signalCondition <- base::signalCondition
[16:11:05.699]             sys.calls <- base::sys.calls
[16:11:05.699]             `[[` <- base::`[[`
[16:11:05.699]             `+` <- base::`+`
[16:11:05.699]             `<<-` <- base::`<<-`
[16:11:05.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:05.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:05.699]                   3L)]
[16:11:05.699]             }
[16:11:05.699]             function(cond) {
[16:11:05.699]                 is_error <- inherits(cond, "error")
[16:11:05.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:05.699]                   NULL)
[16:11:05.699]                 if (is_error) {
[16:11:05.699]                   sessionInformation <- function() {
[16:11:05.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:05.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:05.699]                       search = base::search(), system = base::Sys.info())
[16:11:05.699]                   }
[16:11:05.699]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:05.699]                     cond$call), session = sessionInformation(), 
[16:11:05.699]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:05.699]                   signalCondition(cond)
[16:11:05.699]                 }
[16:11:05.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:05.699]                 "immediateCondition"))) {
[16:11:05.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:05.699]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:05.699]                   if (TRUE && !signal) {
[16:11:05.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.699]                     {
[16:11:05.699]                       inherits <- base::inherits
[16:11:05.699]                       invokeRestart <- base::invokeRestart
[16:11:05.699]                       is.null <- base::is.null
[16:11:05.699]                       muffled <- FALSE
[16:11:05.699]                       if (inherits(cond, "message")) {
[16:11:05.699]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.699]                         if (muffled) 
[16:11:05.699]                           invokeRestart("muffleMessage")
[16:11:05.699]                       }
[16:11:05.699]                       else if (inherits(cond, "warning")) {
[16:11:05.699]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.699]                         if (muffled) 
[16:11:05.699]                           invokeRestart("muffleWarning")
[16:11:05.699]                       }
[16:11:05.699]                       else if (inherits(cond, "condition")) {
[16:11:05.699]                         if (!is.null(pattern)) {
[16:11:05.699]                           computeRestarts <- base::computeRestarts
[16:11:05.699]                           grepl <- base::grepl
[16:11:05.699]                           restarts <- computeRestarts(cond)
[16:11:05.699]                           for (restart in restarts) {
[16:11:05.699]                             name <- restart$name
[16:11:05.699]                             if (is.null(name)) 
[16:11:05.699]                               next
[16:11:05.699]                             if (!grepl(pattern, name)) 
[16:11:05.699]                               next
[16:11:05.699]                             invokeRestart(restart)
[16:11:05.699]                             muffled <- TRUE
[16:11:05.699]                             break
[16:11:05.699]                           }
[16:11:05.699]                         }
[16:11:05.699]                       }
[16:11:05.699]                       invisible(muffled)
[16:11:05.699]                     }
[16:11:05.699]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.699]                   }
[16:11:05.699]                 }
[16:11:05.699]                 else {
[16:11:05.699]                   if (TRUE) {
[16:11:05.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.699]                     {
[16:11:05.699]                       inherits <- base::inherits
[16:11:05.699]                       invokeRestart <- base::invokeRestart
[16:11:05.699]                       is.null <- base::is.null
[16:11:05.699]                       muffled <- FALSE
[16:11:05.699]                       if (inherits(cond, "message")) {
[16:11:05.699]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.699]                         if (muffled) 
[16:11:05.699]                           invokeRestart("muffleMessage")
[16:11:05.699]                       }
[16:11:05.699]                       else if (inherits(cond, "warning")) {
[16:11:05.699]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.699]                         if (muffled) 
[16:11:05.699]                           invokeRestart("muffleWarning")
[16:11:05.699]                       }
[16:11:05.699]                       else if (inherits(cond, "condition")) {
[16:11:05.699]                         if (!is.null(pattern)) {
[16:11:05.699]                           computeRestarts <- base::computeRestarts
[16:11:05.699]                           grepl <- base::grepl
[16:11:05.699]                           restarts <- computeRestarts(cond)
[16:11:05.699]                           for (restart in restarts) {
[16:11:05.699]                             name <- restart$name
[16:11:05.699]                             if (is.null(name)) 
[16:11:05.699]                               next
[16:11:05.699]                             if (!grepl(pattern, name)) 
[16:11:05.699]                               next
[16:11:05.699]                             invokeRestart(restart)
[16:11:05.699]                             muffled <- TRUE
[16:11:05.699]                             break
[16:11:05.699]                           }
[16:11:05.699]                         }
[16:11:05.699]                       }
[16:11:05.699]                       invisible(muffled)
[16:11:05.699]                     }
[16:11:05.699]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.699]                   }
[16:11:05.699]                 }
[16:11:05.699]             }
[16:11:05.699]         }))
[16:11:05.699]     }, error = function(ex) {
[16:11:05.699]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:05.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.699]                 ...future.rng), started = ...future.startTime, 
[16:11:05.699]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:05.699]             version = "1.8"), class = "FutureResult")
[16:11:05.699]     }, finally = {
[16:11:05.699]         if (!identical(...future.workdir, getwd())) 
[16:11:05.699]             setwd(...future.workdir)
[16:11:05.699]         {
[16:11:05.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:05.699]                 ...future.oldOptions$nwarnings <- NULL
[16:11:05.699]             }
[16:11:05.699]             base::options(...future.oldOptions)
[16:11:05.699]             if (.Platform$OS.type == "windows") {
[16:11:05.699]                 old_names <- names(...future.oldEnvVars)
[16:11:05.699]                 envs <- base::Sys.getenv()
[16:11:05.699]                 names <- names(envs)
[16:11:05.699]                 common <- intersect(names, old_names)
[16:11:05.699]                 added <- setdiff(names, old_names)
[16:11:05.699]                 removed <- setdiff(old_names, names)
[16:11:05.699]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:05.699]                   envs[common]]
[16:11:05.699]                 NAMES <- toupper(changed)
[16:11:05.699]                 args <- list()
[16:11:05.699]                 for (kk in seq_along(NAMES)) {
[16:11:05.699]                   name <- changed[[kk]]
[16:11:05.699]                   NAME <- NAMES[[kk]]
[16:11:05.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.699]                     next
[16:11:05.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.699]                 }
[16:11:05.699]                 NAMES <- toupper(added)
[16:11:05.699]                 for (kk in seq_along(NAMES)) {
[16:11:05.699]                   name <- added[[kk]]
[16:11:05.699]                   NAME <- NAMES[[kk]]
[16:11:05.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.699]                     next
[16:11:05.699]                   args[[name]] <- ""
[16:11:05.699]                 }
[16:11:05.699]                 NAMES <- toupper(removed)
[16:11:05.699]                 for (kk in seq_along(NAMES)) {
[16:11:05.699]                   name <- removed[[kk]]
[16:11:05.699]                   NAME <- NAMES[[kk]]
[16:11:05.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.699]                     next
[16:11:05.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.699]                 }
[16:11:05.699]                 if (length(args) > 0) 
[16:11:05.699]                   base::do.call(base::Sys.setenv, args = args)
[16:11:05.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:05.699]             }
[16:11:05.699]             else {
[16:11:05.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:05.699]             }
[16:11:05.699]             {
[16:11:05.699]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:05.699]                   0L) {
[16:11:05.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:05.699]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:05.699]                   base::options(opts)
[16:11:05.699]                 }
[16:11:05.699]                 {
[16:11:05.699]                   {
[16:11:05.699]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:05.699]                     NULL
[16:11:05.699]                   }
[16:11:05.699]                   options(future.plan = NULL)
[16:11:05.699]                   if (is.na(NA_character_)) 
[16:11:05.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:05.699]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:05.699]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:05.699]                     envir = parent.frame()) 
[16:11:05.699]                   {
[16:11:05.699]                     if (is.function(workers)) 
[16:11:05.699]                       workers <- workers()
[16:11:05.699]                     workers <- structure(as.integer(workers), 
[16:11:05.699]                       class = class(workers))
[16:11:05.699]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:05.699]                       workers >= 1)
[16:11:05.699]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:05.699]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:05.699]                     }
[16:11:05.699]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:05.699]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:05.699]                       envir = envir)
[16:11:05.699]                     if (!future$lazy) 
[16:11:05.699]                       future <- run(future)
[16:11:05.699]                     invisible(future)
[16:11:05.699]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:05.699]                 }
[16:11:05.699]             }
[16:11:05.699]         }
[16:11:05.699]     })
[16:11:05.699]     if (TRUE) {
[16:11:05.699]         base::sink(type = "output", split = FALSE)
[16:11:05.699]         if (TRUE) {
[16:11:05.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:05.699]         }
[16:11:05.699]         else {
[16:11:05.699]             ...future.result["stdout"] <- base::list(NULL)
[16:11:05.699]         }
[16:11:05.699]         base::close(...future.stdout)
[16:11:05.699]         ...future.stdout <- NULL
[16:11:05.699]     }
[16:11:05.699]     ...future.result$conditions <- ...future.conditions
[16:11:05.699]     ...future.result$finished <- base::Sys.time()
[16:11:05.699]     ...future.result
[16:11:05.699] }
[16:11:05.702] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[16:11:05.702] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:05.744] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:05.744] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[16:11:05.744] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[16:11:05.745] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:05.745] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:05.745] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:05.788] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:05.788] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:05.832] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:05.832] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:11:05.832] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:11:05.833] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[16:11:05.833] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[16:11:05.833] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:05.834] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:05.834] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:11:05.834] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:11:05.834] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:05.835] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:05.835] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:05.835] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:05.835] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[16:11:05.836] MultisessionFuture started
[16:11:05.836] - Launch lazy future ... done
[16:11:05.836] run() for ‘MultisessionFuture’ ... done
[16:11:05.836] Created future:
[16:11:05.836] MultisessionFuture:
[16:11:05.836] Label: ‘future_vapply-2’
[16:11:05.836] Expression:
[16:11:05.836] {
[16:11:05.836]     do.call(function(...) {
[16:11:05.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.836]             on.exit(options(oopts), add = TRUE)
[16:11:05.836]         }
[16:11:05.836]         {
[16:11:05.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.836]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.836]             })
[16:11:05.836]         }
[16:11:05.836]     }, args = future.call.arguments)
[16:11:05.836] }
[16:11:05.836] Lazy evaluation: FALSE
[16:11:05.836] Asynchronous evaluation: TRUE
[16:11:05.836] Local evaluation: TRUE
[16:11:05.836] Environment: R_GlobalEnv
[16:11:05.836] Capture standard output: TRUE
[16:11:05.836] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:05.836] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:05.836] Packages: 1 packages (‘future.apply’)
[16:11:05.836] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:05.836] Resolved: FALSE
[16:11:05.836] Value: <not collected>
[16:11:05.836] Conditions captured: <none>
[16:11:05.836] Early signaling: FALSE
[16:11:05.836] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:05.836] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.848] Chunk #2 of 2 ... DONE
[16:11:05.848] Launching 2 futures (chunks) ... DONE
[16:11:05.848] Resolving 2 futures (chunks) ...
[16:11:05.848] resolve() on list ...
[16:11:05.848]  recursive: 0
[16:11:05.849]  length: 2
[16:11:05.849] 
[16:11:05.849] receiveMessageFromWorker() for ClusterFuture ...
[16:11:05.849] - Validating connection of MultisessionFuture
[16:11:05.849] - received message: FutureResult
[16:11:05.849] - Received FutureResult
[16:11:05.850] - Erased future from FutureRegistry
[16:11:05.850] result() for ClusterFuture ...
[16:11:05.850] - result already collected: FutureResult
[16:11:05.850] result() for ClusterFuture ... done
[16:11:05.850] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:05.850] Future #1
[16:11:05.850] result() for ClusterFuture ...
[16:11:05.850] - result already collected: FutureResult
[16:11:05.850] result() for ClusterFuture ... done
[16:11:05.850] result() for ClusterFuture ...
[16:11:05.850] - result already collected: FutureResult
[16:11:05.851] result() for ClusterFuture ... done
[16:11:05.851] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:05.851] - nx: 2
[16:11:05.851] - relay: TRUE
[16:11:05.851] - stdout: TRUE
[16:11:05.851] - signal: TRUE
[16:11:05.851] - resignal: FALSE
[16:11:05.851] - force: TRUE
[16:11:05.851] - relayed: [n=2] FALSE, FALSE
[16:11:05.851] - queued futures: [n=2] FALSE, FALSE
[16:11:05.851]  - until=1
[16:11:05.851]  - relaying element #1
[16:11:05.852] result() for ClusterFuture ...
[16:11:05.852] - result already collected: FutureResult
[16:11:05.852] result() for ClusterFuture ... done
[16:11:05.852] result() for ClusterFuture ...
[16:11:05.852] - result already collected: FutureResult
[16:11:05.852] result() for ClusterFuture ... done
[16:11:05.852] result() for ClusterFuture ...
[16:11:05.852] - result already collected: FutureResult
[16:11:05.852] result() for ClusterFuture ... done
[16:11:05.852] result() for ClusterFuture ...
[16:11:05.852] - result already collected: FutureResult
[16:11:05.853] result() for ClusterFuture ... done
[16:11:05.853] - relayed: [n=2] TRUE, FALSE
[16:11:05.853] - queued futures: [n=2] TRUE, FALSE
[16:11:05.853] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:05.853]  length: 1 (resolved future 1)
[16:11:05.895] receiveMessageFromWorker() for ClusterFuture ...
[16:11:05.895] - Validating connection of MultisessionFuture
[16:11:05.895] - received message: FutureResult
[16:11:05.895] - Received FutureResult
[16:11:05.895] - Erased future from FutureRegistry
[16:11:05.895] result() for ClusterFuture ...
[16:11:05.895] - result already collected: FutureResult
[16:11:05.895] result() for ClusterFuture ... done
[16:11:05.896] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:05.896] Future #2
[16:11:05.896] result() for ClusterFuture ...
[16:11:05.896] - result already collected: FutureResult
[16:11:05.896] result() for ClusterFuture ... done
[16:11:05.896] result() for ClusterFuture ...
[16:11:05.896] - result already collected: FutureResult
[16:11:05.896] result() for ClusterFuture ... done
[16:11:05.896] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:05.896] - nx: 2
[16:11:05.896] - relay: TRUE
[16:11:05.897] - stdout: TRUE
[16:11:05.897] - signal: TRUE
[16:11:05.897] - resignal: FALSE
[16:11:05.897] - force: TRUE
[16:11:05.897] - relayed: [n=2] TRUE, FALSE
[16:11:05.897] - queued futures: [n=2] TRUE, FALSE
[16:11:05.897]  - until=2
[16:11:05.897]  - relaying element #2
[16:11:05.897] result() for ClusterFuture ...
[16:11:05.897] - result already collected: FutureResult
[16:11:05.897] result() for ClusterFuture ... done
[16:11:05.897] result() for ClusterFuture ...
[16:11:05.898] - result already collected: FutureResult
[16:11:05.898] result() for ClusterFuture ... done
[16:11:05.898] result() for ClusterFuture ...
[16:11:05.898] - result already collected: FutureResult
[16:11:05.898] result() for ClusterFuture ... done
[16:11:05.898] result() for ClusterFuture ...
[16:11:05.898] - result already collected: FutureResult
[16:11:05.898] result() for ClusterFuture ... done
[16:11:05.898] - relayed: [n=2] TRUE, TRUE
[16:11:05.898] - queued futures: [n=2] TRUE, TRUE
[16:11:05.898] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:05.899]  length: 0 (resolved future 2)
[16:11:05.899] Relaying remaining futures
[16:11:05.899] signalConditionsASAP(NULL, pos=0) ...
[16:11:05.899] - nx: 2
[16:11:05.899] - relay: TRUE
[16:11:05.899] - stdout: TRUE
[16:11:05.899] - signal: TRUE
[16:11:05.899] - resignal: FALSE
[16:11:05.899] - force: TRUE
[16:11:05.899] - relayed: [n=2] TRUE, TRUE
[16:11:05.899] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:05.899] - relayed: [n=2] TRUE, TRUE
[16:11:05.900] - queued futures: [n=2] TRUE, TRUE
[16:11:05.900] signalConditionsASAP(NULL, pos=0) ... done
[16:11:05.900] resolve() on list ... DONE
[16:11:05.900] result() for ClusterFuture ...
[16:11:05.900] - result already collected: FutureResult
[16:11:05.900] result() for ClusterFuture ... done
[16:11:05.900] result() for ClusterFuture ...
[16:11:05.900] - result already collected: FutureResult
[16:11:05.900] result() for ClusterFuture ... done
[16:11:05.900] result() for ClusterFuture ...
[16:11:05.900] - result already collected: FutureResult
[16:11:05.901] result() for ClusterFuture ... done
[16:11:05.901] result() for ClusterFuture ...
[16:11:05.901] - result already collected: FutureResult
[16:11:05.901] result() for ClusterFuture ... done
[16:11:05.901]  - Number of value chunks collected: 2
[16:11:05.901] Resolving 2 futures (chunks) ... DONE
[16:11:05.901] Reducing values from 2 chunks ...
[16:11:05.901]  - Number of values collected after concatenation: 10
[16:11:05.901]  - Number of values expected: 10
[16:11:05.901] Reducing values from 2 chunks ... DONE
[16:11:05.901] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[16:11:05.902] future_lapply() ...
[16:11:05.907] Number of chunks: 2
[16:11:05.907] getGlobalsAndPackagesXApply() ...
[16:11:05.908]  - future.globals: TRUE
[16:11:05.908] getGlobalsAndPackages() ...
[16:11:05.908] Searching for globals...
[16:11:05.911] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[16:11:05.911] Searching for globals ... DONE
[16:11:05.911] Resolving globals: FALSE
[16:11:05.912] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[16:11:05.913] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:05.913] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:05.913] - packages: [1] ‘future.apply’
[16:11:05.913] getGlobalsAndPackages() ... DONE
[16:11:05.913]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:05.913]  - needed namespaces: [n=1] ‘future.apply’
[16:11:05.913] Finding globals ... DONE
[16:11:05.913]  - use_args: TRUE
[16:11:05.913]  - Getting '...' globals ...
[16:11:05.914] resolve() on list ...
[16:11:05.914]  recursive: 0
[16:11:05.914]  length: 1
[16:11:05.914]  elements: ‘...’
[16:11:05.914]  length: 0 (resolved future 1)
[16:11:05.914] resolve() on list ... DONE
[16:11:05.914]    - '...' content: [n=0] 
[16:11:05.914] List of 1
[16:11:05.914]  $ ...: list()
[16:11:05.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:05.914]  - attr(*, "where")=List of 1
[16:11:05.914]   ..$ ...:<environment: 0x561e8b66c5f8> 
[16:11:05.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:05.914]  - attr(*, "resolved")= logi TRUE
[16:11:05.914]  - attr(*, "total_size")= num NA
[16:11:05.917]  - Getting '...' globals ... DONE
[16:11:05.917] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:05.917] List of 8
[16:11:05.917]  $ ...future.FUN:function (x, ...)  
[16:11:05.917]  $ x_FUN        :function (x)  
[16:11:05.917]  $ times        : int 4
[16:11:05.917]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:05.917]  $ stop_if_not  :function (...)  
[16:11:05.917]  $ dim          : int [1:2] 2 2
[16:11:05.917]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:05.917]  $ ...          : list()
[16:11:05.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:05.917]  - attr(*, "where")=List of 8
[16:11:05.917]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:05.917]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:05.917]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:05.917]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:05.917]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:05.917]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:05.917]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:05.917]   ..$ ...          :<environment: 0x561e8b66c5f8> 
[16:11:05.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:05.917]  - attr(*, "resolved")= logi FALSE
[16:11:05.917]  - attr(*, "total_size")= num 97304
[16:11:05.922] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:05.922] getGlobalsAndPackagesXApply() ... DONE
[16:11:05.923] Number of futures (= number of chunks): 2
[16:11:05.923] Launching 2 futures (chunks) ...
[16:11:05.923] Chunk #1 of 2 ...
[16:11:05.923]  - Finding globals in 'X' for chunk #1 ...
[16:11:05.923] getGlobalsAndPackages() ...
[16:11:05.923] Searching for globals...
[16:11:05.923] 
[16:11:05.923] Searching for globals ... DONE
[16:11:05.924] - globals: [0] <none>
[16:11:05.924] getGlobalsAndPackages() ... DONE
[16:11:05.924]    + additional globals found: [n=0] 
[16:11:05.924]    + additional namespaces needed: [n=0] 
[16:11:05.924]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:05.924]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:05.924]  - seeds: <none>
[16:11:05.924] getGlobalsAndPackages() ...
[16:11:05.924] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.924] Resolving globals: FALSE
[16:11:05.925] Tweak future expression to call with '...' arguments ...
[16:11:05.925] {
[16:11:05.925]     do.call(function(...) {
[16:11:05.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:05.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.925]             on.exit(options(oopts), add = TRUE)
[16:11:05.925]         }
[16:11:05.925]         {
[16:11:05.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:05.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.925]                 ...future.FUN(...future.X_jj, ...)
[16:11:05.925]             })
[16:11:05.925]         }
[16:11:05.925]     }, args = future.call.arguments)
[16:11:05.925] }
[16:11:05.925] Tweak future expression to call with '...' arguments ... DONE
[16:11:05.925] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:05.926] - packages: [1] ‘future.apply’
[16:11:05.926] getGlobalsAndPackages() ... DONE
[16:11:05.926] run() for ‘Future’ ...
[16:11:05.926] - state: ‘created’
[16:11:05.926] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:05.940] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:05.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:05.941]   - Field: ‘node’
[16:11:05.941]   - Field: ‘label’
[16:11:05.941]   - Field: ‘local’
[16:11:05.941]   - Field: ‘owner’
[16:11:05.941]   - Field: ‘envir’
[16:11:05.941]   - Field: ‘workers’
[16:11:05.941]   - Field: ‘packages’
[16:11:05.941]   - Field: ‘gc’
[16:11:05.941]   - Field: ‘conditions’
[16:11:05.941]   - Field: ‘persistent’
[16:11:05.941]   - Field: ‘expr’
[16:11:05.942]   - Field: ‘uuid’
[16:11:05.942]   - Field: ‘seed’
[16:11:05.942]   - Field: ‘version’
[16:11:05.942]   - Field: ‘result’
[16:11:05.942]   - Field: ‘asynchronous’
[16:11:05.942]   - Field: ‘calls’
[16:11:05.942]   - Field: ‘globals’
[16:11:05.942]   - Field: ‘stdout’
[16:11:05.942]   - Field: ‘earlySignal’
[16:11:05.942]   - Field: ‘lazy’
[16:11:05.942]   - Field: ‘state’
[16:11:05.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:05.943] - Launch lazy future ...
[16:11:05.943] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:05.943] Packages needed by future strategies (n = 0): <none>
[16:11:05.944] {
[16:11:05.944]     {
[16:11:05.944]         {
[16:11:05.944]             ...future.startTime <- base::Sys.time()
[16:11:05.944]             {
[16:11:05.944]                 {
[16:11:05.944]                   {
[16:11:05.944]                     {
[16:11:05.944]                       {
[16:11:05.944]                         base::local({
[16:11:05.944]                           has_future <- base::requireNamespace("future", 
[16:11:05.944]                             quietly = TRUE)
[16:11:05.944]                           if (has_future) {
[16:11:05.944]                             ns <- base::getNamespace("future")
[16:11:05.944]                             version <- ns[[".package"]][["version"]]
[16:11:05.944]                             if (is.null(version)) 
[16:11:05.944]                               version <- utils::packageVersion("future")
[16:11:05.944]                           }
[16:11:05.944]                           else {
[16:11:05.944]                             version <- NULL
[16:11:05.944]                           }
[16:11:05.944]                           if (!has_future || version < "1.8.0") {
[16:11:05.944]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:05.944]                               "", base::R.version$version.string), 
[16:11:05.944]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:05.944]                                 base::R.version$platform, 8 * 
[16:11:05.944]                                   base::.Machine$sizeof.pointer), 
[16:11:05.944]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:05.944]                                 "release", "version")], collapse = " "), 
[16:11:05.944]                               hostname = base::Sys.info()[["nodename"]])
[16:11:05.944]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:05.944]                               info)
[16:11:05.944]                             info <- base::paste(info, collapse = "; ")
[16:11:05.944]                             if (!has_future) {
[16:11:05.944]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:05.944]                                 info)
[16:11:05.944]                             }
[16:11:05.944]                             else {
[16:11:05.944]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:05.944]                                 info, version)
[16:11:05.944]                             }
[16:11:05.944]                             base::stop(msg)
[16:11:05.944]                           }
[16:11:05.944]                         })
[16:11:05.944]                       }
[16:11:05.944]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:05.944]                       base::options(mc.cores = 1L)
[16:11:05.944]                     }
[16:11:05.944]                     base::local({
[16:11:05.944]                       for (pkg in "future.apply") {
[16:11:05.944]                         base::loadNamespace(pkg)
[16:11:05.944]                         base::library(pkg, character.only = TRUE)
[16:11:05.944]                       }
[16:11:05.944]                     })
[16:11:05.944]                   }
[16:11:05.944]                   options(future.plan = NULL)
[16:11:05.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:05.944]                 }
[16:11:05.944]                 ...future.workdir <- getwd()
[16:11:05.944]             }
[16:11:05.944]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:05.944]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:05.944]         }
[16:11:05.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:05.944]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:05.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:05.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:05.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:05.944]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:05.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:05.944]             base::names(...future.oldOptions))
[16:11:05.944]     }
[16:11:05.944]     if (FALSE) {
[16:11:05.944]     }
[16:11:05.944]     else {
[16:11:05.944]         if (TRUE) {
[16:11:05.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:05.944]                 open = "w")
[16:11:05.944]         }
[16:11:05.944]         else {
[16:11:05.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:05.944]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:05.944]         }
[16:11:05.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:05.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:05.944]             base::sink(type = "output", split = FALSE)
[16:11:05.944]             base::close(...future.stdout)
[16:11:05.944]         }, add = TRUE)
[16:11:05.944]     }
[16:11:05.944]     ...future.frame <- base::sys.nframe()
[16:11:05.944]     ...future.conditions <- base::list()
[16:11:05.944]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:05.944]     if (FALSE) {
[16:11:05.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:05.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:05.944]     }
[16:11:05.944]     ...future.result <- base::tryCatch({
[16:11:05.944]         base::withCallingHandlers({
[16:11:05.944]             ...future.value <- base::withVisible(base::local({
[16:11:05.944]                 ...future.makeSendCondition <- local({
[16:11:05.944]                   sendCondition <- NULL
[16:11:05.944]                   function(frame = 1L) {
[16:11:05.944]                     if (is.function(sendCondition)) 
[16:11:05.944]                       return(sendCondition)
[16:11:05.944]                     ns <- getNamespace("parallel")
[16:11:05.944]                     if (exists("sendData", mode = "function", 
[16:11:05.944]                       envir = ns)) {
[16:11:05.944]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:05.944]                         envir = ns)
[16:11:05.944]                       envir <- sys.frame(frame)
[16:11:05.944]                       master <- NULL
[16:11:05.944]                       while (!identical(envir, .GlobalEnv) && 
[16:11:05.944]                         !identical(envir, emptyenv())) {
[16:11:05.944]                         if (exists("master", mode = "list", envir = envir, 
[16:11:05.944]                           inherits = FALSE)) {
[16:11:05.944]                           master <- get("master", mode = "list", 
[16:11:05.944]                             envir = envir, inherits = FALSE)
[16:11:05.944]                           if (inherits(master, c("SOCKnode", 
[16:11:05.944]                             "SOCK0node"))) {
[16:11:05.944]                             sendCondition <<- function(cond) {
[16:11:05.944]                               data <- list(type = "VALUE", value = cond, 
[16:11:05.944]                                 success = TRUE)
[16:11:05.944]                               parallel_sendData(master, data)
[16:11:05.944]                             }
[16:11:05.944]                             return(sendCondition)
[16:11:05.944]                           }
[16:11:05.944]                         }
[16:11:05.944]                         frame <- frame + 1L
[16:11:05.944]                         envir <- sys.frame(frame)
[16:11:05.944]                       }
[16:11:05.944]                     }
[16:11:05.944]                     sendCondition <<- function(cond) NULL
[16:11:05.944]                   }
[16:11:05.944]                 })
[16:11:05.944]                 withCallingHandlers({
[16:11:05.944]                   {
[16:11:05.944]                     do.call(function(...) {
[16:11:05.944]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:05.944]                       if (!identical(...future.globals.maxSize.org, 
[16:11:05.944]                         ...future.globals.maxSize)) {
[16:11:05.944]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:05.944]                         on.exit(options(oopts), add = TRUE)
[16:11:05.944]                       }
[16:11:05.944]                       {
[16:11:05.944]                         lapply(seq_along(...future.elements_ii), 
[16:11:05.944]                           FUN = function(jj) {
[16:11:05.944]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:05.944]                             ...future.FUN(...future.X_jj, ...)
[16:11:05.944]                           })
[16:11:05.944]                       }
[16:11:05.944]                     }, args = future.call.arguments)
[16:11:05.944]                   }
[16:11:05.944]                 }, immediateCondition = function(cond) {
[16:11:05.944]                   sendCondition <- ...future.makeSendCondition()
[16:11:05.944]                   sendCondition(cond)
[16:11:05.944]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.944]                   {
[16:11:05.944]                     inherits <- base::inherits
[16:11:05.944]                     invokeRestart <- base::invokeRestart
[16:11:05.944]                     is.null <- base::is.null
[16:11:05.944]                     muffled <- FALSE
[16:11:05.944]                     if (inherits(cond, "message")) {
[16:11:05.944]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:05.944]                       if (muffled) 
[16:11:05.944]                         invokeRestart("muffleMessage")
[16:11:05.944]                     }
[16:11:05.944]                     else if (inherits(cond, "warning")) {
[16:11:05.944]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:05.944]                       if (muffled) 
[16:11:05.944]                         invokeRestart("muffleWarning")
[16:11:05.944]                     }
[16:11:05.944]                     else if (inherits(cond, "condition")) {
[16:11:05.944]                       if (!is.null(pattern)) {
[16:11:05.944]                         computeRestarts <- base::computeRestarts
[16:11:05.944]                         grepl <- base::grepl
[16:11:05.944]                         restarts <- computeRestarts(cond)
[16:11:05.944]                         for (restart in restarts) {
[16:11:05.944]                           name <- restart$name
[16:11:05.944]                           if (is.null(name)) 
[16:11:05.944]                             next
[16:11:05.944]                           if (!grepl(pattern, name)) 
[16:11:05.944]                             next
[16:11:05.944]                           invokeRestart(restart)
[16:11:05.944]                           muffled <- TRUE
[16:11:05.944]                           break
[16:11:05.944]                         }
[16:11:05.944]                       }
[16:11:05.944]                     }
[16:11:05.944]                     invisible(muffled)
[16:11:05.944]                   }
[16:11:05.944]                   muffleCondition(cond)
[16:11:05.944]                 })
[16:11:05.944]             }))
[16:11:05.944]             future::FutureResult(value = ...future.value$value, 
[16:11:05.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.944]                   ...future.rng), globalenv = if (FALSE) 
[16:11:05.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:05.944]                     ...future.globalenv.names))
[16:11:05.944]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:05.944]         }, condition = base::local({
[16:11:05.944]             c <- base::c
[16:11:05.944]             inherits <- base::inherits
[16:11:05.944]             invokeRestart <- base::invokeRestart
[16:11:05.944]             length <- base::length
[16:11:05.944]             list <- base::list
[16:11:05.944]             seq.int <- base::seq.int
[16:11:05.944]             signalCondition <- base::signalCondition
[16:11:05.944]             sys.calls <- base::sys.calls
[16:11:05.944]             `[[` <- base::`[[`
[16:11:05.944]             `+` <- base::`+`
[16:11:05.944]             `<<-` <- base::`<<-`
[16:11:05.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:05.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:05.944]                   3L)]
[16:11:05.944]             }
[16:11:05.944]             function(cond) {
[16:11:05.944]                 is_error <- inherits(cond, "error")
[16:11:05.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:05.944]                   NULL)
[16:11:05.944]                 if (is_error) {
[16:11:05.944]                   sessionInformation <- function() {
[16:11:05.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:05.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:05.944]                       search = base::search(), system = base::Sys.info())
[16:11:05.944]                   }
[16:11:05.944]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:05.944]                     cond$call), session = sessionInformation(), 
[16:11:05.944]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:05.944]                   signalCondition(cond)
[16:11:05.944]                 }
[16:11:05.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:05.944]                 "immediateCondition"))) {
[16:11:05.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:05.944]                   ...future.conditions[[length(...future.conditions) + 
[16:11:05.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:05.944]                   if (TRUE && !signal) {
[16:11:05.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.944]                     {
[16:11:05.944]                       inherits <- base::inherits
[16:11:05.944]                       invokeRestart <- base::invokeRestart
[16:11:05.944]                       is.null <- base::is.null
[16:11:05.944]                       muffled <- FALSE
[16:11:05.944]                       if (inherits(cond, "message")) {
[16:11:05.944]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.944]                         if (muffled) 
[16:11:05.944]                           invokeRestart("muffleMessage")
[16:11:05.944]                       }
[16:11:05.944]                       else if (inherits(cond, "warning")) {
[16:11:05.944]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.944]                         if (muffled) 
[16:11:05.944]                           invokeRestart("muffleWarning")
[16:11:05.944]                       }
[16:11:05.944]                       else if (inherits(cond, "condition")) {
[16:11:05.944]                         if (!is.null(pattern)) {
[16:11:05.944]                           computeRestarts <- base::computeRestarts
[16:11:05.944]                           grepl <- base::grepl
[16:11:05.944]                           restarts <- computeRestarts(cond)
[16:11:05.944]                           for (restart in restarts) {
[16:11:05.944]                             name <- restart$name
[16:11:05.944]                             if (is.null(name)) 
[16:11:05.944]                               next
[16:11:05.944]                             if (!grepl(pattern, name)) 
[16:11:05.944]                               next
[16:11:05.944]                             invokeRestart(restart)
[16:11:05.944]                             muffled <- TRUE
[16:11:05.944]                             break
[16:11:05.944]                           }
[16:11:05.944]                         }
[16:11:05.944]                       }
[16:11:05.944]                       invisible(muffled)
[16:11:05.944]                     }
[16:11:05.944]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.944]                   }
[16:11:05.944]                 }
[16:11:05.944]                 else {
[16:11:05.944]                   if (TRUE) {
[16:11:05.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:05.944]                     {
[16:11:05.944]                       inherits <- base::inherits
[16:11:05.944]                       invokeRestart <- base::invokeRestart
[16:11:05.944]                       is.null <- base::is.null
[16:11:05.944]                       muffled <- FALSE
[16:11:05.944]                       if (inherits(cond, "message")) {
[16:11:05.944]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:05.944]                         if (muffled) 
[16:11:05.944]                           invokeRestart("muffleMessage")
[16:11:05.944]                       }
[16:11:05.944]                       else if (inherits(cond, "warning")) {
[16:11:05.944]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:05.944]                         if (muffled) 
[16:11:05.944]                           invokeRestart("muffleWarning")
[16:11:05.944]                       }
[16:11:05.944]                       else if (inherits(cond, "condition")) {
[16:11:05.944]                         if (!is.null(pattern)) {
[16:11:05.944]                           computeRestarts <- base::computeRestarts
[16:11:05.944]                           grepl <- base::grepl
[16:11:05.944]                           restarts <- computeRestarts(cond)
[16:11:05.944]                           for (restart in restarts) {
[16:11:05.944]                             name <- restart$name
[16:11:05.944]                             if (is.null(name)) 
[16:11:05.944]                               next
[16:11:05.944]                             if (!grepl(pattern, name)) 
[16:11:05.944]                               next
[16:11:05.944]                             invokeRestart(restart)
[16:11:05.944]                             muffled <- TRUE
[16:11:05.944]                             break
[16:11:05.944]                           }
[16:11:05.944]                         }
[16:11:05.944]                       }
[16:11:05.944]                       invisible(muffled)
[16:11:05.944]                     }
[16:11:05.944]                     muffleCondition(cond, pattern = "^muffle")
[16:11:05.944]                   }
[16:11:05.944]                 }
[16:11:05.944]             }
[16:11:05.944]         }))
[16:11:05.944]     }, error = function(ex) {
[16:11:05.944]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:05.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:05.944]                 ...future.rng), started = ...future.startTime, 
[16:11:05.944]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:05.944]             version = "1.8"), class = "FutureResult")
[16:11:05.944]     }, finally = {
[16:11:05.944]         if (!identical(...future.workdir, getwd())) 
[16:11:05.944]             setwd(...future.workdir)
[16:11:05.944]         {
[16:11:05.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:05.944]                 ...future.oldOptions$nwarnings <- NULL
[16:11:05.944]             }
[16:11:05.944]             base::options(...future.oldOptions)
[16:11:05.944]             if (.Platform$OS.type == "windows") {
[16:11:05.944]                 old_names <- names(...future.oldEnvVars)
[16:11:05.944]                 envs <- base::Sys.getenv()
[16:11:05.944]                 names <- names(envs)
[16:11:05.944]                 common <- intersect(names, old_names)
[16:11:05.944]                 added <- setdiff(names, old_names)
[16:11:05.944]                 removed <- setdiff(old_names, names)
[16:11:05.944]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:05.944]                   envs[common]]
[16:11:05.944]                 NAMES <- toupper(changed)
[16:11:05.944]                 args <- list()
[16:11:05.944]                 for (kk in seq_along(NAMES)) {
[16:11:05.944]                   name <- changed[[kk]]
[16:11:05.944]                   NAME <- NAMES[[kk]]
[16:11:05.944]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.944]                     next
[16:11:05.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.944]                 }
[16:11:05.944]                 NAMES <- toupper(added)
[16:11:05.944]                 for (kk in seq_along(NAMES)) {
[16:11:05.944]                   name <- added[[kk]]
[16:11:05.944]                   NAME <- NAMES[[kk]]
[16:11:05.944]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.944]                     next
[16:11:05.944]                   args[[name]] <- ""
[16:11:05.944]                 }
[16:11:05.944]                 NAMES <- toupper(removed)
[16:11:05.944]                 for (kk in seq_along(NAMES)) {
[16:11:05.944]                   name <- removed[[kk]]
[16:11:05.944]                   NAME <- NAMES[[kk]]
[16:11:05.944]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:05.944]                     next
[16:11:05.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:05.944]                 }
[16:11:05.944]                 if (length(args) > 0) 
[16:11:05.944]                   base::do.call(base::Sys.setenv, args = args)
[16:11:05.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:05.944]             }
[16:11:05.944]             else {
[16:11:05.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:05.944]             }
[16:11:05.944]             {
[16:11:05.944]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:05.944]                   0L) {
[16:11:05.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:05.944]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:05.944]                   base::options(opts)
[16:11:05.944]                 }
[16:11:05.944]                 {
[16:11:05.944]                   {
[16:11:05.944]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:05.944]                     NULL
[16:11:05.944]                   }
[16:11:05.944]                   options(future.plan = NULL)
[16:11:05.944]                   if (is.na(NA_character_)) 
[16:11:05.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:05.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:05.944]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:05.944]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:05.944]                     envir = parent.frame()) 
[16:11:05.944]                   {
[16:11:05.944]                     if (is.function(workers)) 
[16:11:05.944]                       workers <- workers()
[16:11:05.944]                     workers <- structure(as.integer(workers), 
[16:11:05.944]                       class = class(workers))
[16:11:05.944]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:05.944]                       workers >= 1)
[16:11:05.944]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:05.944]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:05.944]                     }
[16:11:05.944]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:05.944]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:05.944]                       envir = envir)
[16:11:05.944]                     if (!future$lazy) 
[16:11:05.944]                       future <- run(future)
[16:11:05.944]                     invisible(future)
[16:11:05.944]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:05.944]                 }
[16:11:05.944]             }
[16:11:05.944]         }
[16:11:05.944]     })
[16:11:05.944]     if (TRUE) {
[16:11:05.944]         base::sink(type = "output", split = FALSE)
[16:11:05.944]         if (TRUE) {
[16:11:05.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:05.944]         }
[16:11:05.944]         else {
[16:11:05.944]             ...future.result["stdout"] <- base::list(NULL)
[16:11:05.944]         }
[16:11:05.944]         base::close(...future.stdout)
[16:11:05.944]         ...future.stdout <- NULL
[16:11:05.944]     }
[16:11:05.944]     ...future.result$conditions <- ...future.conditions
[16:11:05.944]     ...future.result$finished <- base::Sys.time()
[16:11:05.944]     ...future.result
[16:11:05.944] }
[16:11:05.946] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[16:11:05.946] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:05.988] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:05.988] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[16:11:05.988] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[16:11:05.989] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:05.989] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:05.989] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:06.032] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:06.032] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:06.076] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:06.076] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:11:06.076] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:11:06.077] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:06.077] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:06.077] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:06.077] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.078] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:11:06.078] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:11:06.078] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:06.078] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.079] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:06.079] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.079] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[16:11:06.082] MultisessionFuture started
[16:11:06.082] - Launch lazy future ... done
[16:11:06.082] run() for ‘MultisessionFuture’ ... done
[16:11:06.082] Created future:
[16:11:06.082] MultisessionFuture:
[16:11:06.082] Label: ‘future_vapply-1’
[16:11:06.082] Expression:
[16:11:06.082] {
[16:11:06.082]     do.call(function(...) {
[16:11:06.082]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.082]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.082]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.082]             on.exit(options(oopts), add = TRUE)
[16:11:06.082]         }
[16:11:06.082]         {
[16:11:06.082]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.082]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.082]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.082]             })
[16:11:06.082]         }
[16:11:06.082]     }, args = future.call.arguments)
[16:11:06.082] }
[16:11:06.082] Lazy evaluation: FALSE
[16:11:06.082] Asynchronous evaluation: TRUE
[16:11:06.082] Local evaluation: TRUE
[16:11:06.082] Environment: R_GlobalEnv
[16:11:06.082] Capture standard output: TRUE
[16:11:06.082] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:06.082] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:06.082] Packages: 1 packages (‘future.apply’)
[16:11:06.082] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:06.082] Resolved: FALSE
[16:11:06.082] Value: <not collected>
[16:11:06.082] Conditions captured: <none>
[16:11:06.082] Early signaling: FALSE
[16:11:06.082] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:06.082] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.094] Chunk #1 of 2 ... DONE
[16:11:06.094] Chunk #2 of 2 ...
[16:11:06.094]  - Finding globals in 'X' for chunk #2 ...
[16:11:06.094] getGlobalsAndPackages() ...
[16:11:06.094] Searching for globals...
[16:11:06.094] 
[16:11:06.094] Searching for globals ... DONE
[16:11:06.095] - globals: [0] <none>
[16:11:06.095] getGlobalsAndPackages() ... DONE
[16:11:06.095]    + additional globals found: [n=0] 
[16:11:06.095]    + additional namespaces needed: [n=0] 
[16:11:06.095]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:06.095]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:06.095]  - seeds: <none>
[16:11:06.095] getGlobalsAndPackages() ...
[16:11:06.095] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.095] Resolving globals: FALSE
[16:11:06.095] Tweak future expression to call with '...' arguments ...
[16:11:06.096] {
[16:11:06.096]     do.call(function(...) {
[16:11:06.096]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.096]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.096]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.096]             on.exit(options(oopts), add = TRUE)
[16:11:06.096]         }
[16:11:06.096]         {
[16:11:06.096]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.096]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.096]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.096]             })
[16:11:06.096]         }
[16:11:06.096]     }, args = future.call.arguments)
[16:11:06.096] }
[16:11:06.096] Tweak future expression to call with '...' arguments ... DONE
[16:11:06.096] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.097] - packages: [1] ‘future.apply’
[16:11:06.097] getGlobalsAndPackages() ... DONE
[16:11:06.097] run() for ‘Future’ ...
[16:11:06.097] - state: ‘created’
[16:11:06.097] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:06.112] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:06.112]   - Field: ‘node’
[16:11:06.112]   - Field: ‘label’
[16:11:06.112]   - Field: ‘local’
[16:11:06.112]   - Field: ‘owner’
[16:11:06.112]   - Field: ‘envir’
[16:11:06.112]   - Field: ‘workers’
[16:11:06.112]   - Field: ‘packages’
[16:11:06.113]   - Field: ‘gc’
[16:11:06.113]   - Field: ‘conditions’
[16:11:06.113]   - Field: ‘persistent’
[16:11:06.113]   - Field: ‘expr’
[16:11:06.113]   - Field: ‘uuid’
[16:11:06.113]   - Field: ‘seed’
[16:11:06.113]   - Field: ‘version’
[16:11:06.113]   - Field: ‘result’
[16:11:06.113]   - Field: ‘asynchronous’
[16:11:06.113]   - Field: ‘calls’
[16:11:06.113]   - Field: ‘globals’
[16:11:06.114]   - Field: ‘stdout’
[16:11:06.114]   - Field: ‘earlySignal’
[16:11:06.114]   - Field: ‘lazy’
[16:11:06.114]   - Field: ‘state’
[16:11:06.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:06.114] - Launch lazy future ...
[16:11:06.114] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:06.114] Packages needed by future strategies (n = 0): <none>
[16:11:06.115] {
[16:11:06.115]     {
[16:11:06.115]         {
[16:11:06.115]             ...future.startTime <- base::Sys.time()
[16:11:06.115]             {
[16:11:06.115]                 {
[16:11:06.115]                   {
[16:11:06.115]                     {
[16:11:06.115]                       {
[16:11:06.115]                         base::local({
[16:11:06.115]                           has_future <- base::requireNamespace("future", 
[16:11:06.115]                             quietly = TRUE)
[16:11:06.115]                           if (has_future) {
[16:11:06.115]                             ns <- base::getNamespace("future")
[16:11:06.115]                             version <- ns[[".package"]][["version"]]
[16:11:06.115]                             if (is.null(version)) 
[16:11:06.115]                               version <- utils::packageVersion("future")
[16:11:06.115]                           }
[16:11:06.115]                           else {
[16:11:06.115]                             version <- NULL
[16:11:06.115]                           }
[16:11:06.115]                           if (!has_future || version < "1.8.0") {
[16:11:06.115]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:06.115]                               "", base::R.version$version.string), 
[16:11:06.115]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:06.115]                                 base::R.version$platform, 8 * 
[16:11:06.115]                                   base::.Machine$sizeof.pointer), 
[16:11:06.115]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:06.115]                                 "release", "version")], collapse = " "), 
[16:11:06.115]                               hostname = base::Sys.info()[["nodename"]])
[16:11:06.115]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:06.115]                               info)
[16:11:06.115]                             info <- base::paste(info, collapse = "; ")
[16:11:06.115]                             if (!has_future) {
[16:11:06.115]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:06.115]                                 info)
[16:11:06.115]                             }
[16:11:06.115]                             else {
[16:11:06.115]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:06.115]                                 info, version)
[16:11:06.115]                             }
[16:11:06.115]                             base::stop(msg)
[16:11:06.115]                           }
[16:11:06.115]                         })
[16:11:06.115]                       }
[16:11:06.115]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:06.115]                       base::options(mc.cores = 1L)
[16:11:06.115]                     }
[16:11:06.115]                     base::local({
[16:11:06.115]                       for (pkg in "future.apply") {
[16:11:06.115]                         base::loadNamespace(pkg)
[16:11:06.115]                         base::library(pkg, character.only = TRUE)
[16:11:06.115]                       }
[16:11:06.115]                     })
[16:11:06.115]                   }
[16:11:06.115]                   options(future.plan = NULL)
[16:11:06.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:06.115]                 }
[16:11:06.115]                 ...future.workdir <- getwd()
[16:11:06.115]             }
[16:11:06.115]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:06.115]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:06.115]         }
[16:11:06.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:06.115]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:06.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:06.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:06.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:06.115]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:06.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:06.115]             base::names(...future.oldOptions))
[16:11:06.115]     }
[16:11:06.115]     if (FALSE) {
[16:11:06.115]     }
[16:11:06.115]     else {
[16:11:06.115]         if (TRUE) {
[16:11:06.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:06.115]                 open = "w")
[16:11:06.115]         }
[16:11:06.115]         else {
[16:11:06.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:06.115]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:06.115]         }
[16:11:06.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:06.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:06.115]             base::sink(type = "output", split = FALSE)
[16:11:06.115]             base::close(...future.stdout)
[16:11:06.115]         }, add = TRUE)
[16:11:06.115]     }
[16:11:06.115]     ...future.frame <- base::sys.nframe()
[16:11:06.115]     ...future.conditions <- base::list()
[16:11:06.115]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:06.115]     if (FALSE) {
[16:11:06.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:06.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:06.115]     }
[16:11:06.115]     ...future.result <- base::tryCatch({
[16:11:06.115]         base::withCallingHandlers({
[16:11:06.115]             ...future.value <- base::withVisible(base::local({
[16:11:06.115]                 ...future.makeSendCondition <- local({
[16:11:06.115]                   sendCondition <- NULL
[16:11:06.115]                   function(frame = 1L) {
[16:11:06.115]                     if (is.function(sendCondition)) 
[16:11:06.115]                       return(sendCondition)
[16:11:06.115]                     ns <- getNamespace("parallel")
[16:11:06.115]                     if (exists("sendData", mode = "function", 
[16:11:06.115]                       envir = ns)) {
[16:11:06.115]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:06.115]                         envir = ns)
[16:11:06.115]                       envir <- sys.frame(frame)
[16:11:06.115]                       master <- NULL
[16:11:06.115]                       while (!identical(envir, .GlobalEnv) && 
[16:11:06.115]                         !identical(envir, emptyenv())) {
[16:11:06.115]                         if (exists("master", mode = "list", envir = envir, 
[16:11:06.115]                           inherits = FALSE)) {
[16:11:06.115]                           master <- get("master", mode = "list", 
[16:11:06.115]                             envir = envir, inherits = FALSE)
[16:11:06.115]                           if (inherits(master, c("SOCKnode", 
[16:11:06.115]                             "SOCK0node"))) {
[16:11:06.115]                             sendCondition <<- function(cond) {
[16:11:06.115]                               data <- list(type = "VALUE", value = cond, 
[16:11:06.115]                                 success = TRUE)
[16:11:06.115]                               parallel_sendData(master, data)
[16:11:06.115]                             }
[16:11:06.115]                             return(sendCondition)
[16:11:06.115]                           }
[16:11:06.115]                         }
[16:11:06.115]                         frame <- frame + 1L
[16:11:06.115]                         envir <- sys.frame(frame)
[16:11:06.115]                       }
[16:11:06.115]                     }
[16:11:06.115]                     sendCondition <<- function(cond) NULL
[16:11:06.115]                   }
[16:11:06.115]                 })
[16:11:06.115]                 withCallingHandlers({
[16:11:06.115]                   {
[16:11:06.115]                     do.call(function(...) {
[16:11:06.115]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.115]                       if (!identical(...future.globals.maxSize.org, 
[16:11:06.115]                         ...future.globals.maxSize)) {
[16:11:06.115]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.115]                         on.exit(options(oopts), add = TRUE)
[16:11:06.115]                       }
[16:11:06.115]                       {
[16:11:06.115]                         lapply(seq_along(...future.elements_ii), 
[16:11:06.115]                           FUN = function(jj) {
[16:11:06.115]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.115]                             ...future.FUN(...future.X_jj, ...)
[16:11:06.115]                           })
[16:11:06.115]                       }
[16:11:06.115]                     }, args = future.call.arguments)
[16:11:06.115]                   }
[16:11:06.115]                 }, immediateCondition = function(cond) {
[16:11:06.115]                   sendCondition <- ...future.makeSendCondition()
[16:11:06.115]                   sendCondition(cond)
[16:11:06.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.115]                   {
[16:11:06.115]                     inherits <- base::inherits
[16:11:06.115]                     invokeRestart <- base::invokeRestart
[16:11:06.115]                     is.null <- base::is.null
[16:11:06.115]                     muffled <- FALSE
[16:11:06.115]                     if (inherits(cond, "message")) {
[16:11:06.115]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:06.115]                       if (muffled) 
[16:11:06.115]                         invokeRestart("muffleMessage")
[16:11:06.115]                     }
[16:11:06.115]                     else if (inherits(cond, "warning")) {
[16:11:06.115]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:06.115]                       if (muffled) 
[16:11:06.115]                         invokeRestart("muffleWarning")
[16:11:06.115]                     }
[16:11:06.115]                     else if (inherits(cond, "condition")) {
[16:11:06.115]                       if (!is.null(pattern)) {
[16:11:06.115]                         computeRestarts <- base::computeRestarts
[16:11:06.115]                         grepl <- base::grepl
[16:11:06.115]                         restarts <- computeRestarts(cond)
[16:11:06.115]                         for (restart in restarts) {
[16:11:06.115]                           name <- restart$name
[16:11:06.115]                           if (is.null(name)) 
[16:11:06.115]                             next
[16:11:06.115]                           if (!grepl(pattern, name)) 
[16:11:06.115]                             next
[16:11:06.115]                           invokeRestart(restart)
[16:11:06.115]                           muffled <- TRUE
[16:11:06.115]                           break
[16:11:06.115]                         }
[16:11:06.115]                       }
[16:11:06.115]                     }
[16:11:06.115]                     invisible(muffled)
[16:11:06.115]                   }
[16:11:06.115]                   muffleCondition(cond)
[16:11:06.115]                 })
[16:11:06.115]             }))
[16:11:06.115]             future::FutureResult(value = ...future.value$value, 
[16:11:06.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.115]                   ...future.rng), globalenv = if (FALSE) 
[16:11:06.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:06.115]                     ...future.globalenv.names))
[16:11:06.115]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:06.115]         }, condition = base::local({
[16:11:06.115]             c <- base::c
[16:11:06.115]             inherits <- base::inherits
[16:11:06.115]             invokeRestart <- base::invokeRestart
[16:11:06.115]             length <- base::length
[16:11:06.115]             list <- base::list
[16:11:06.115]             seq.int <- base::seq.int
[16:11:06.115]             signalCondition <- base::signalCondition
[16:11:06.115]             sys.calls <- base::sys.calls
[16:11:06.115]             `[[` <- base::`[[`
[16:11:06.115]             `+` <- base::`+`
[16:11:06.115]             `<<-` <- base::`<<-`
[16:11:06.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:06.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:06.115]                   3L)]
[16:11:06.115]             }
[16:11:06.115]             function(cond) {
[16:11:06.115]                 is_error <- inherits(cond, "error")
[16:11:06.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:06.115]                   NULL)
[16:11:06.115]                 if (is_error) {
[16:11:06.115]                   sessionInformation <- function() {
[16:11:06.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:06.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:06.115]                       search = base::search(), system = base::Sys.info())
[16:11:06.115]                   }
[16:11:06.115]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:06.115]                     cond$call), session = sessionInformation(), 
[16:11:06.115]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:06.115]                   signalCondition(cond)
[16:11:06.115]                 }
[16:11:06.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:06.115]                 "immediateCondition"))) {
[16:11:06.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:06.115]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:06.115]                   if (TRUE && !signal) {
[16:11:06.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.115]                     {
[16:11:06.115]                       inherits <- base::inherits
[16:11:06.115]                       invokeRestart <- base::invokeRestart
[16:11:06.115]                       is.null <- base::is.null
[16:11:06.115]                       muffled <- FALSE
[16:11:06.115]                       if (inherits(cond, "message")) {
[16:11:06.115]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.115]                         if (muffled) 
[16:11:06.115]                           invokeRestart("muffleMessage")
[16:11:06.115]                       }
[16:11:06.115]                       else if (inherits(cond, "warning")) {
[16:11:06.115]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.115]                         if (muffled) 
[16:11:06.115]                           invokeRestart("muffleWarning")
[16:11:06.115]                       }
[16:11:06.115]                       else if (inherits(cond, "condition")) {
[16:11:06.115]                         if (!is.null(pattern)) {
[16:11:06.115]                           computeRestarts <- base::computeRestarts
[16:11:06.115]                           grepl <- base::grepl
[16:11:06.115]                           restarts <- computeRestarts(cond)
[16:11:06.115]                           for (restart in restarts) {
[16:11:06.115]                             name <- restart$name
[16:11:06.115]                             if (is.null(name)) 
[16:11:06.115]                               next
[16:11:06.115]                             if (!grepl(pattern, name)) 
[16:11:06.115]                               next
[16:11:06.115]                             invokeRestart(restart)
[16:11:06.115]                             muffled <- TRUE
[16:11:06.115]                             break
[16:11:06.115]                           }
[16:11:06.115]                         }
[16:11:06.115]                       }
[16:11:06.115]                       invisible(muffled)
[16:11:06.115]                     }
[16:11:06.115]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.115]                   }
[16:11:06.115]                 }
[16:11:06.115]                 else {
[16:11:06.115]                   if (TRUE) {
[16:11:06.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.115]                     {
[16:11:06.115]                       inherits <- base::inherits
[16:11:06.115]                       invokeRestart <- base::invokeRestart
[16:11:06.115]                       is.null <- base::is.null
[16:11:06.115]                       muffled <- FALSE
[16:11:06.115]                       if (inherits(cond, "message")) {
[16:11:06.115]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.115]                         if (muffled) 
[16:11:06.115]                           invokeRestart("muffleMessage")
[16:11:06.115]                       }
[16:11:06.115]                       else if (inherits(cond, "warning")) {
[16:11:06.115]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.115]                         if (muffled) 
[16:11:06.115]                           invokeRestart("muffleWarning")
[16:11:06.115]                       }
[16:11:06.115]                       else if (inherits(cond, "condition")) {
[16:11:06.115]                         if (!is.null(pattern)) {
[16:11:06.115]                           computeRestarts <- base::computeRestarts
[16:11:06.115]                           grepl <- base::grepl
[16:11:06.115]                           restarts <- computeRestarts(cond)
[16:11:06.115]                           for (restart in restarts) {
[16:11:06.115]                             name <- restart$name
[16:11:06.115]                             if (is.null(name)) 
[16:11:06.115]                               next
[16:11:06.115]                             if (!grepl(pattern, name)) 
[16:11:06.115]                               next
[16:11:06.115]                             invokeRestart(restart)
[16:11:06.115]                             muffled <- TRUE
[16:11:06.115]                             break
[16:11:06.115]                           }
[16:11:06.115]                         }
[16:11:06.115]                       }
[16:11:06.115]                       invisible(muffled)
[16:11:06.115]                     }
[16:11:06.115]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.115]                   }
[16:11:06.115]                 }
[16:11:06.115]             }
[16:11:06.115]         }))
[16:11:06.115]     }, error = function(ex) {
[16:11:06.115]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:06.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.115]                 ...future.rng), started = ...future.startTime, 
[16:11:06.115]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:06.115]             version = "1.8"), class = "FutureResult")
[16:11:06.115]     }, finally = {
[16:11:06.115]         if (!identical(...future.workdir, getwd())) 
[16:11:06.115]             setwd(...future.workdir)
[16:11:06.115]         {
[16:11:06.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:06.115]                 ...future.oldOptions$nwarnings <- NULL
[16:11:06.115]             }
[16:11:06.115]             base::options(...future.oldOptions)
[16:11:06.115]             if (.Platform$OS.type == "windows") {
[16:11:06.115]                 old_names <- names(...future.oldEnvVars)
[16:11:06.115]                 envs <- base::Sys.getenv()
[16:11:06.115]                 names <- names(envs)
[16:11:06.115]                 common <- intersect(names, old_names)
[16:11:06.115]                 added <- setdiff(names, old_names)
[16:11:06.115]                 removed <- setdiff(old_names, names)
[16:11:06.115]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:06.115]                   envs[common]]
[16:11:06.115]                 NAMES <- toupper(changed)
[16:11:06.115]                 args <- list()
[16:11:06.115]                 for (kk in seq_along(NAMES)) {
[16:11:06.115]                   name <- changed[[kk]]
[16:11:06.115]                   NAME <- NAMES[[kk]]
[16:11:06.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.115]                     next
[16:11:06.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.115]                 }
[16:11:06.115]                 NAMES <- toupper(added)
[16:11:06.115]                 for (kk in seq_along(NAMES)) {
[16:11:06.115]                   name <- added[[kk]]
[16:11:06.115]                   NAME <- NAMES[[kk]]
[16:11:06.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.115]                     next
[16:11:06.115]                   args[[name]] <- ""
[16:11:06.115]                 }
[16:11:06.115]                 NAMES <- toupper(removed)
[16:11:06.115]                 for (kk in seq_along(NAMES)) {
[16:11:06.115]                   name <- removed[[kk]]
[16:11:06.115]                   NAME <- NAMES[[kk]]
[16:11:06.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.115]                     next
[16:11:06.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.115]                 }
[16:11:06.115]                 if (length(args) > 0) 
[16:11:06.115]                   base::do.call(base::Sys.setenv, args = args)
[16:11:06.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:06.115]             }
[16:11:06.115]             else {
[16:11:06.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:06.115]             }
[16:11:06.115]             {
[16:11:06.115]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:06.115]                   0L) {
[16:11:06.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:06.115]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:06.115]                   base::options(opts)
[16:11:06.115]                 }
[16:11:06.115]                 {
[16:11:06.115]                   {
[16:11:06.115]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:06.115]                     NULL
[16:11:06.115]                   }
[16:11:06.115]                   options(future.plan = NULL)
[16:11:06.115]                   if (is.na(NA_character_)) 
[16:11:06.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:06.115]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:06.115]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:06.115]                     envir = parent.frame()) 
[16:11:06.115]                   {
[16:11:06.115]                     if (is.function(workers)) 
[16:11:06.115]                       workers <- workers()
[16:11:06.115]                     workers <- structure(as.integer(workers), 
[16:11:06.115]                       class = class(workers))
[16:11:06.115]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:06.115]                       workers >= 1)
[16:11:06.115]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:06.115]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:06.115]                     }
[16:11:06.115]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:06.115]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:06.115]                       envir = envir)
[16:11:06.115]                     if (!future$lazy) 
[16:11:06.115]                       future <- run(future)
[16:11:06.115]                     invisible(future)
[16:11:06.115]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:06.115]                 }
[16:11:06.115]             }
[16:11:06.115]         }
[16:11:06.115]     })
[16:11:06.115]     if (TRUE) {
[16:11:06.115]         base::sink(type = "output", split = FALSE)
[16:11:06.115]         if (TRUE) {
[16:11:06.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:06.115]         }
[16:11:06.115]         else {
[16:11:06.115]             ...future.result["stdout"] <- base::list(NULL)
[16:11:06.115]         }
[16:11:06.115]         base::close(...future.stdout)
[16:11:06.115]         ...future.stdout <- NULL
[16:11:06.115]     }
[16:11:06.115]     ...future.result$conditions <- ...future.conditions
[16:11:06.115]     ...future.result$finished <- base::Sys.time()
[16:11:06.115]     ...future.result
[16:11:06.115] }
[16:11:06.118] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[16:11:06.118] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:06.160] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:06.160] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[16:11:06.161] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[16:11:06.161] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:06.161] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:06.161] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:06.204] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:06.204] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:06.248] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:06.248] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:11:06.248] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:11:06.249] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:06.249] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:06.249] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:06.250] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:06.250] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:11:06.252] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:11:06.252] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:06.253] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:06.253] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:06.253] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:06.253] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[16:11:06.254] MultisessionFuture started
[16:11:06.254] - Launch lazy future ... done
[16:11:06.254] run() for ‘MultisessionFuture’ ... done
[16:11:06.254] Created future:
[16:11:06.254] MultisessionFuture:
[16:11:06.254] Label: ‘future_vapply-2’
[16:11:06.254] Expression:
[16:11:06.254] {
[16:11:06.254]     do.call(function(...) {
[16:11:06.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.254]             on.exit(options(oopts), add = TRUE)
[16:11:06.254]         }
[16:11:06.254]         {
[16:11:06.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.254]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.254]             })
[16:11:06.254]         }
[16:11:06.254]     }, args = future.call.arguments)
[16:11:06.254] }
[16:11:06.254] Lazy evaluation: FALSE
[16:11:06.254] Asynchronous evaluation: TRUE
[16:11:06.254] Local evaluation: TRUE
[16:11:06.254] Environment: R_GlobalEnv
[16:11:06.254] Capture standard output: TRUE
[16:11:06.254] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:06.254] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:06.254] Packages: 1 packages (‘future.apply’)
[16:11:06.254] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:06.254] Resolved: FALSE
[16:11:06.254] Value: <not collected>
[16:11:06.254] Conditions captured: <none>
[16:11:06.254] Early signaling: FALSE
[16:11:06.254] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:06.254] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.266] Chunk #2 of 2 ... DONE
[16:11:06.266] Launching 2 futures (chunks) ... DONE
[16:11:06.266] Resolving 2 futures (chunks) ...
[16:11:06.266] resolve() on list ...
[16:11:06.266]  recursive: 0
[16:11:06.267]  length: 2
[16:11:06.267] 
[16:11:06.267] receiveMessageFromWorker() for ClusterFuture ...
[16:11:06.267] - Validating connection of MultisessionFuture
[16:11:06.267] - received message: FutureResult
[16:11:06.267] - Received FutureResult
[16:11:06.268] - Erased future from FutureRegistry
[16:11:06.268] result() for ClusterFuture ...
[16:11:06.268] - result already collected: FutureResult
[16:11:06.268] result() for ClusterFuture ... done
[16:11:06.268] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:06.268] Future #1
[16:11:06.268] result() for ClusterFuture ...
[16:11:06.268] - result already collected: FutureResult
[16:11:06.268] result() for ClusterFuture ... done
[16:11:06.268] result() for ClusterFuture ...
[16:11:06.269] - result already collected: FutureResult
[16:11:06.269] result() for ClusterFuture ... done
[16:11:06.269] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:06.269] - nx: 2
[16:11:06.269] - relay: TRUE
[16:11:06.269] - stdout: TRUE
[16:11:06.269] - signal: TRUE
[16:11:06.269] - resignal: FALSE
[16:11:06.269] - force: TRUE
[16:11:06.269] - relayed: [n=2] FALSE, FALSE
[16:11:06.269] - queued futures: [n=2] FALSE, FALSE
[16:11:06.269]  - until=1
[16:11:06.270]  - relaying element #1
[16:11:06.270] result() for ClusterFuture ...
[16:11:06.270] - result already collected: FutureResult
[16:11:06.270] result() for ClusterFuture ... done
[16:11:06.270] result() for ClusterFuture ...
[16:11:06.270] - result already collected: FutureResult
[16:11:06.270] result() for ClusterFuture ... done
[16:11:06.270] result() for ClusterFuture ...
[16:11:06.270] - result already collected: FutureResult
[16:11:06.270] result() for ClusterFuture ... done
[16:11:06.270] result() for ClusterFuture ...
[16:11:06.270] - result already collected: FutureResult
[16:11:06.271] result() for ClusterFuture ... done
[16:11:06.271] - relayed: [n=2] TRUE, FALSE
[16:11:06.271] - queued futures: [n=2] TRUE, FALSE
[16:11:06.271] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:06.271]  length: 1 (resolved future 1)
[16:11:06.301] receiveMessageFromWorker() for ClusterFuture ...
[16:11:06.301] - Validating connection of MultisessionFuture
[16:11:06.301] - received message: FutureResult
[16:11:06.301] - Received FutureResult
[16:11:06.301] - Erased future from FutureRegistry
[16:11:06.302] result() for ClusterFuture ...
[16:11:06.302] - result already collected: FutureResult
[16:11:06.302] result() for ClusterFuture ... done
[16:11:06.302] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:06.302] Future #2
[16:11:06.302] result() for ClusterFuture ...
[16:11:06.302] - result already collected: FutureResult
[16:11:06.302] result() for ClusterFuture ... done
[16:11:06.302] result() for ClusterFuture ...
[16:11:06.302] - result already collected: FutureResult
[16:11:06.302] result() for ClusterFuture ... done
[16:11:06.303] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:06.303] - nx: 2
[16:11:06.303] - relay: TRUE
[16:11:06.303] - stdout: TRUE
[16:11:06.303] - signal: TRUE
[16:11:06.303] - resignal: FALSE
[16:11:06.303] - force: TRUE
[16:11:06.303] - relayed: [n=2] TRUE, FALSE
[16:11:06.303] - queued futures: [n=2] TRUE, FALSE
[16:11:06.303]  - until=2
[16:11:06.303]  - relaying element #2
[16:11:06.303] result() for ClusterFuture ...
[16:11:06.304] - result already collected: FutureResult
[16:11:06.304] result() for ClusterFuture ... done
[16:11:06.304] result() for ClusterFuture ...
[16:11:06.304] - result already collected: FutureResult
[16:11:06.304] result() for ClusterFuture ... done
[16:11:06.304] result() for ClusterFuture ...
[16:11:06.304] - result already collected: FutureResult
[16:11:06.304] result() for ClusterFuture ... done
[16:11:06.304] result() for ClusterFuture ...
[16:11:06.304] - result already collected: FutureResult
[16:11:06.304] result() for ClusterFuture ... done
[16:11:06.305] - relayed: [n=2] TRUE, TRUE
[16:11:06.305] - queued futures: [n=2] TRUE, TRUE
[16:11:06.305] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:06.305]  length: 0 (resolved future 2)
[16:11:06.305] Relaying remaining futures
[16:11:06.305] signalConditionsASAP(NULL, pos=0) ...
[16:11:06.305] - nx: 2
[16:11:06.305] - relay: TRUE
[16:11:06.305] - stdout: TRUE
[16:11:06.305] - signal: TRUE
[16:11:06.305] - resignal: FALSE
[16:11:06.306] - force: TRUE
[16:11:06.306] - relayed: [n=2] TRUE, TRUE
[16:11:06.306] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:06.306] - relayed: [n=2] TRUE, TRUE
[16:11:06.306] - queued futures: [n=2] TRUE, TRUE
[16:11:06.306] signalConditionsASAP(NULL, pos=0) ... done
[16:11:06.306] resolve() on list ... DONE
[16:11:06.306] result() for ClusterFuture ...
[16:11:06.306] - result already collected: FutureResult
[16:11:06.306] result() for ClusterFuture ... done
[16:11:06.306] result() for ClusterFuture ...
[16:11:06.307] - result already collected: FutureResult
[16:11:06.307] result() for ClusterFuture ... done
[16:11:06.307] result() for ClusterFuture ...
[16:11:06.307] - result already collected: FutureResult
[16:11:06.307] result() for ClusterFuture ... done
[16:11:06.307] result() for ClusterFuture ...
[16:11:06.307] - result already collected: FutureResult
[16:11:06.307] result() for ClusterFuture ... done
[16:11:06.307]  - Number of value chunks collected: 2
[16:11:06.307] Resolving 2 futures (chunks) ... DONE
[16:11:06.307] Reducing values from 2 chunks ...
[16:11:06.308]  - Number of values collected after concatenation: 10
[16:11:06.308]  - Number of values expected: 10
[16:11:06.308] Reducing values from 2 chunks ... DONE
[16:11:06.308] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[16:11:06.310] future_lapply() ...
[16:11:06.315] Number of chunks: 2
[16:11:06.315] getGlobalsAndPackagesXApply() ...
[16:11:06.315]  - future.globals: TRUE
[16:11:06.315] getGlobalsAndPackages() ...
[16:11:06.316] Searching for globals...
[16:11:06.319] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[16:11:06.319] Searching for globals ... DONE
[16:11:06.320] Resolving globals: FALSE
[16:11:06.320] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[16:11:06.321] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:06.321] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:06.321] - packages: [1] ‘future.apply’
[16:11:06.321] getGlobalsAndPackages() ... DONE
[16:11:06.321]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:06.321]  - needed namespaces: [n=1] ‘future.apply’
[16:11:06.322] Finding globals ... DONE
[16:11:06.322]  - use_args: TRUE
[16:11:06.322]  - Getting '...' globals ...
[16:11:06.322] resolve() on list ...
[16:11:06.322]  recursive: 0
[16:11:06.322]  length: 1
[16:11:06.322]  elements: ‘...’
[16:11:06.322]  length: 0 (resolved future 1)
[16:11:06.322] resolve() on list ... DONE
[16:11:06.323]    - '...' content: [n=0] 
[16:11:06.323] List of 1
[16:11:06.323]  $ ...: list()
[16:11:06.323]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:06.323]  - attr(*, "where")=List of 1
[16:11:06.323]   ..$ ...:<environment: 0x561e8b5a1678> 
[16:11:06.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:06.323]  - attr(*, "resolved")= logi TRUE
[16:11:06.323]  - attr(*, "total_size")= num NA
[16:11:06.325]  - Getting '...' globals ... DONE
[16:11:06.325] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:06.325] List of 8
[16:11:06.325]  $ ...future.FUN:function (x, ...)  
[16:11:06.325]  $ x_FUN        :function (x)  
[16:11:06.325]  $ times        : int 4
[16:11:06.325]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:06.325]  $ stop_if_not  :function (...)  
[16:11:06.325]  $ dim          : int [1:2] 2 2
[16:11:06.325]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:06.325]  $ ...          : list()
[16:11:06.325]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:06.325]  - attr(*, "where")=List of 8
[16:11:06.325]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:06.325]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:06.325]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:06.325]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:06.325]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:06.325]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:06.325]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:06.325]   ..$ ...          :<environment: 0x561e8b5a1678> 
[16:11:06.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:06.325]  - attr(*, "resolved")= logi FALSE
[16:11:06.325]  - attr(*, "total_size")= num 105552
[16:11:06.331] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:06.331] getGlobalsAndPackagesXApply() ... DONE
[16:11:06.331] Number of futures (= number of chunks): 2
[16:11:06.331] Launching 2 futures (chunks) ...
[16:11:06.331] Chunk #1 of 2 ...
[16:11:06.331]  - Finding globals in 'X' for chunk #1 ...
[16:11:06.331] getGlobalsAndPackages() ...
[16:11:06.331] Searching for globals...
[16:11:06.332] 
[16:11:06.332] Searching for globals ... DONE
[16:11:06.332] - globals: [0] <none>
[16:11:06.332] getGlobalsAndPackages() ... DONE
[16:11:06.332]    + additional globals found: [n=0] 
[16:11:06.332]    + additional namespaces needed: [n=0] 
[16:11:06.332]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:06.332]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:06.333]  - seeds: <none>
[16:11:06.333] getGlobalsAndPackages() ...
[16:11:06.333] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.333] Resolving globals: FALSE
[16:11:06.333] Tweak future expression to call with '...' arguments ...
[16:11:06.333] {
[16:11:06.333]     do.call(function(...) {
[16:11:06.333]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.333]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.333]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.333]             on.exit(options(oopts), add = TRUE)
[16:11:06.333]         }
[16:11:06.333]         {
[16:11:06.333]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.333]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.333]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.333]             })
[16:11:06.333]         }
[16:11:06.333]     }, args = future.call.arguments)
[16:11:06.333] }
[16:11:06.333] Tweak future expression to call with '...' arguments ... DONE
[16:11:06.334] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.334] - packages: [1] ‘future.apply’
[16:11:06.334] getGlobalsAndPackages() ... DONE
[16:11:06.334] run() for ‘Future’ ...
[16:11:06.334] - state: ‘created’
[16:11:06.335] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:06.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:06.350]   - Field: ‘node’
[16:11:06.350]   - Field: ‘label’
[16:11:06.350]   - Field: ‘local’
[16:11:06.350]   - Field: ‘owner’
[16:11:06.350]   - Field: ‘envir’
[16:11:06.350]   - Field: ‘workers’
[16:11:06.350]   - Field: ‘packages’
[16:11:06.350]   - Field: ‘gc’
[16:11:06.350]   - Field: ‘conditions’
[16:11:06.350]   - Field: ‘persistent’
[16:11:06.350]   - Field: ‘expr’
[16:11:06.351]   - Field: ‘uuid’
[16:11:06.351]   - Field: ‘seed’
[16:11:06.351]   - Field: ‘version’
[16:11:06.351]   - Field: ‘result’
[16:11:06.351]   - Field: ‘asynchronous’
[16:11:06.351]   - Field: ‘calls’
[16:11:06.351]   - Field: ‘globals’
[16:11:06.351]   - Field: ‘stdout’
[16:11:06.351]   - Field: ‘earlySignal’
[16:11:06.351]   - Field: ‘lazy’
[16:11:06.351]   - Field: ‘state’
[16:11:06.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:06.352] - Launch lazy future ...
[16:11:06.352] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:06.352] Packages needed by future strategies (n = 0): <none>
[16:11:06.353] {
[16:11:06.353]     {
[16:11:06.353]         {
[16:11:06.353]             ...future.startTime <- base::Sys.time()
[16:11:06.353]             {
[16:11:06.353]                 {
[16:11:06.353]                   {
[16:11:06.353]                     {
[16:11:06.353]                       {
[16:11:06.353]                         base::local({
[16:11:06.353]                           has_future <- base::requireNamespace("future", 
[16:11:06.353]                             quietly = TRUE)
[16:11:06.353]                           if (has_future) {
[16:11:06.353]                             ns <- base::getNamespace("future")
[16:11:06.353]                             version <- ns[[".package"]][["version"]]
[16:11:06.353]                             if (is.null(version)) 
[16:11:06.353]                               version <- utils::packageVersion("future")
[16:11:06.353]                           }
[16:11:06.353]                           else {
[16:11:06.353]                             version <- NULL
[16:11:06.353]                           }
[16:11:06.353]                           if (!has_future || version < "1.8.0") {
[16:11:06.353]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:06.353]                               "", base::R.version$version.string), 
[16:11:06.353]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:06.353]                                 base::R.version$platform, 8 * 
[16:11:06.353]                                   base::.Machine$sizeof.pointer), 
[16:11:06.353]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:06.353]                                 "release", "version")], collapse = " "), 
[16:11:06.353]                               hostname = base::Sys.info()[["nodename"]])
[16:11:06.353]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:06.353]                               info)
[16:11:06.353]                             info <- base::paste(info, collapse = "; ")
[16:11:06.353]                             if (!has_future) {
[16:11:06.353]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:06.353]                                 info)
[16:11:06.353]                             }
[16:11:06.353]                             else {
[16:11:06.353]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:06.353]                                 info, version)
[16:11:06.353]                             }
[16:11:06.353]                             base::stop(msg)
[16:11:06.353]                           }
[16:11:06.353]                         })
[16:11:06.353]                       }
[16:11:06.353]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:06.353]                       base::options(mc.cores = 1L)
[16:11:06.353]                     }
[16:11:06.353]                     base::local({
[16:11:06.353]                       for (pkg in "future.apply") {
[16:11:06.353]                         base::loadNamespace(pkg)
[16:11:06.353]                         base::library(pkg, character.only = TRUE)
[16:11:06.353]                       }
[16:11:06.353]                     })
[16:11:06.353]                   }
[16:11:06.353]                   options(future.plan = NULL)
[16:11:06.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:06.353]                 }
[16:11:06.353]                 ...future.workdir <- getwd()
[16:11:06.353]             }
[16:11:06.353]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:06.353]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:06.353]         }
[16:11:06.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:06.353]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:06.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:06.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:06.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:06.353]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:06.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:06.353]             base::names(...future.oldOptions))
[16:11:06.353]     }
[16:11:06.353]     if (FALSE) {
[16:11:06.353]     }
[16:11:06.353]     else {
[16:11:06.353]         if (TRUE) {
[16:11:06.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:06.353]                 open = "w")
[16:11:06.353]         }
[16:11:06.353]         else {
[16:11:06.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:06.353]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:06.353]         }
[16:11:06.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:06.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:06.353]             base::sink(type = "output", split = FALSE)
[16:11:06.353]             base::close(...future.stdout)
[16:11:06.353]         }, add = TRUE)
[16:11:06.353]     }
[16:11:06.353]     ...future.frame <- base::sys.nframe()
[16:11:06.353]     ...future.conditions <- base::list()
[16:11:06.353]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:06.353]     if (FALSE) {
[16:11:06.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:06.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:06.353]     }
[16:11:06.353]     ...future.result <- base::tryCatch({
[16:11:06.353]         base::withCallingHandlers({
[16:11:06.353]             ...future.value <- base::withVisible(base::local({
[16:11:06.353]                 ...future.makeSendCondition <- local({
[16:11:06.353]                   sendCondition <- NULL
[16:11:06.353]                   function(frame = 1L) {
[16:11:06.353]                     if (is.function(sendCondition)) 
[16:11:06.353]                       return(sendCondition)
[16:11:06.353]                     ns <- getNamespace("parallel")
[16:11:06.353]                     if (exists("sendData", mode = "function", 
[16:11:06.353]                       envir = ns)) {
[16:11:06.353]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:06.353]                         envir = ns)
[16:11:06.353]                       envir <- sys.frame(frame)
[16:11:06.353]                       master <- NULL
[16:11:06.353]                       while (!identical(envir, .GlobalEnv) && 
[16:11:06.353]                         !identical(envir, emptyenv())) {
[16:11:06.353]                         if (exists("master", mode = "list", envir = envir, 
[16:11:06.353]                           inherits = FALSE)) {
[16:11:06.353]                           master <- get("master", mode = "list", 
[16:11:06.353]                             envir = envir, inherits = FALSE)
[16:11:06.353]                           if (inherits(master, c("SOCKnode", 
[16:11:06.353]                             "SOCK0node"))) {
[16:11:06.353]                             sendCondition <<- function(cond) {
[16:11:06.353]                               data <- list(type = "VALUE", value = cond, 
[16:11:06.353]                                 success = TRUE)
[16:11:06.353]                               parallel_sendData(master, data)
[16:11:06.353]                             }
[16:11:06.353]                             return(sendCondition)
[16:11:06.353]                           }
[16:11:06.353]                         }
[16:11:06.353]                         frame <- frame + 1L
[16:11:06.353]                         envir <- sys.frame(frame)
[16:11:06.353]                       }
[16:11:06.353]                     }
[16:11:06.353]                     sendCondition <<- function(cond) NULL
[16:11:06.353]                   }
[16:11:06.353]                 })
[16:11:06.353]                 withCallingHandlers({
[16:11:06.353]                   {
[16:11:06.353]                     do.call(function(...) {
[16:11:06.353]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.353]                       if (!identical(...future.globals.maxSize.org, 
[16:11:06.353]                         ...future.globals.maxSize)) {
[16:11:06.353]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.353]                         on.exit(options(oopts), add = TRUE)
[16:11:06.353]                       }
[16:11:06.353]                       {
[16:11:06.353]                         lapply(seq_along(...future.elements_ii), 
[16:11:06.353]                           FUN = function(jj) {
[16:11:06.353]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.353]                             ...future.FUN(...future.X_jj, ...)
[16:11:06.353]                           })
[16:11:06.353]                       }
[16:11:06.353]                     }, args = future.call.arguments)
[16:11:06.353]                   }
[16:11:06.353]                 }, immediateCondition = function(cond) {
[16:11:06.353]                   sendCondition <- ...future.makeSendCondition()
[16:11:06.353]                   sendCondition(cond)
[16:11:06.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.353]                   {
[16:11:06.353]                     inherits <- base::inherits
[16:11:06.353]                     invokeRestart <- base::invokeRestart
[16:11:06.353]                     is.null <- base::is.null
[16:11:06.353]                     muffled <- FALSE
[16:11:06.353]                     if (inherits(cond, "message")) {
[16:11:06.353]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:06.353]                       if (muffled) 
[16:11:06.353]                         invokeRestart("muffleMessage")
[16:11:06.353]                     }
[16:11:06.353]                     else if (inherits(cond, "warning")) {
[16:11:06.353]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:06.353]                       if (muffled) 
[16:11:06.353]                         invokeRestart("muffleWarning")
[16:11:06.353]                     }
[16:11:06.353]                     else if (inherits(cond, "condition")) {
[16:11:06.353]                       if (!is.null(pattern)) {
[16:11:06.353]                         computeRestarts <- base::computeRestarts
[16:11:06.353]                         grepl <- base::grepl
[16:11:06.353]                         restarts <- computeRestarts(cond)
[16:11:06.353]                         for (restart in restarts) {
[16:11:06.353]                           name <- restart$name
[16:11:06.353]                           if (is.null(name)) 
[16:11:06.353]                             next
[16:11:06.353]                           if (!grepl(pattern, name)) 
[16:11:06.353]                             next
[16:11:06.353]                           invokeRestart(restart)
[16:11:06.353]                           muffled <- TRUE
[16:11:06.353]                           break
[16:11:06.353]                         }
[16:11:06.353]                       }
[16:11:06.353]                     }
[16:11:06.353]                     invisible(muffled)
[16:11:06.353]                   }
[16:11:06.353]                   muffleCondition(cond)
[16:11:06.353]                 })
[16:11:06.353]             }))
[16:11:06.353]             future::FutureResult(value = ...future.value$value, 
[16:11:06.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.353]                   ...future.rng), globalenv = if (FALSE) 
[16:11:06.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:06.353]                     ...future.globalenv.names))
[16:11:06.353]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:06.353]         }, condition = base::local({
[16:11:06.353]             c <- base::c
[16:11:06.353]             inherits <- base::inherits
[16:11:06.353]             invokeRestart <- base::invokeRestart
[16:11:06.353]             length <- base::length
[16:11:06.353]             list <- base::list
[16:11:06.353]             seq.int <- base::seq.int
[16:11:06.353]             signalCondition <- base::signalCondition
[16:11:06.353]             sys.calls <- base::sys.calls
[16:11:06.353]             `[[` <- base::`[[`
[16:11:06.353]             `+` <- base::`+`
[16:11:06.353]             `<<-` <- base::`<<-`
[16:11:06.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:06.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:06.353]                   3L)]
[16:11:06.353]             }
[16:11:06.353]             function(cond) {
[16:11:06.353]                 is_error <- inherits(cond, "error")
[16:11:06.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:06.353]                   NULL)
[16:11:06.353]                 if (is_error) {
[16:11:06.353]                   sessionInformation <- function() {
[16:11:06.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:06.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:06.353]                       search = base::search(), system = base::Sys.info())
[16:11:06.353]                   }
[16:11:06.353]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:06.353]                     cond$call), session = sessionInformation(), 
[16:11:06.353]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:06.353]                   signalCondition(cond)
[16:11:06.353]                 }
[16:11:06.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:06.353]                 "immediateCondition"))) {
[16:11:06.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:06.353]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:06.353]                   if (TRUE && !signal) {
[16:11:06.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.353]                     {
[16:11:06.353]                       inherits <- base::inherits
[16:11:06.353]                       invokeRestart <- base::invokeRestart
[16:11:06.353]                       is.null <- base::is.null
[16:11:06.353]                       muffled <- FALSE
[16:11:06.353]                       if (inherits(cond, "message")) {
[16:11:06.353]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.353]                         if (muffled) 
[16:11:06.353]                           invokeRestart("muffleMessage")
[16:11:06.353]                       }
[16:11:06.353]                       else if (inherits(cond, "warning")) {
[16:11:06.353]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.353]                         if (muffled) 
[16:11:06.353]                           invokeRestart("muffleWarning")
[16:11:06.353]                       }
[16:11:06.353]                       else if (inherits(cond, "condition")) {
[16:11:06.353]                         if (!is.null(pattern)) {
[16:11:06.353]                           computeRestarts <- base::computeRestarts
[16:11:06.353]                           grepl <- base::grepl
[16:11:06.353]                           restarts <- computeRestarts(cond)
[16:11:06.353]                           for (restart in restarts) {
[16:11:06.353]                             name <- restart$name
[16:11:06.353]                             if (is.null(name)) 
[16:11:06.353]                               next
[16:11:06.353]                             if (!grepl(pattern, name)) 
[16:11:06.353]                               next
[16:11:06.353]                             invokeRestart(restart)
[16:11:06.353]                             muffled <- TRUE
[16:11:06.353]                             break
[16:11:06.353]                           }
[16:11:06.353]                         }
[16:11:06.353]                       }
[16:11:06.353]                       invisible(muffled)
[16:11:06.353]                     }
[16:11:06.353]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.353]                   }
[16:11:06.353]                 }
[16:11:06.353]                 else {
[16:11:06.353]                   if (TRUE) {
[16:11:06.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.353]                     {
[16:11:06.353]                       inherits <- base::inherits
[16:11:06.353]                       invokeRestart <- base::invokeRestart
[16:11:06.353]                       is.null <- base::is.null
[16:11:06.353]                       muffled <- FALSE
[16:11:06.353]                       if (inherits(cond, "message")) {
[16:11:06.353]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.353]                         if (muffled) 
[16:11:06.353]                           invokeRestart("muffleMessage")
[16:11:06.353]                       }
[16:11:06.353]                       else if (inherits(cond, "warning")) {
[16:11:06.353]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.353]                         if (muffled) 
[16:11:06.353]                           invokeRestart("muffleWarning")
[16:11:06.353]                       }
[16:11:06.353]                       else if (inherits(cond, "condition")) {
[16:11:06.353]                         if (!is.null(pattern)) {
[16:11:06.353]                           computeRestarts <- base::computeRestarts
[16:11:06.353]                           grepl <- base::grepl
[16:11:06.353]                           restarts <- computeRestarts(cond)
[16:11:06.353]                           for (restart in restarts) {
[16:11:06.353]                             name <- restart$name
[16:11:06.353]                             if (is.null(name)) 
[16:11:06.353]                               next
[16:11:06.353]                             if (!grepl(pattern, name)) 
[16:11:06.353]                               next
[16:11:06.353]                             invokeRestart(restart)
[16:11:06.353]                             muffled <- TRUE
[16:11:06.353]                             break
[16:11:06.353]                           }
[16:11:06.353]                         }
[16:11:06.353]                       }
[16:11:06.353]                       invisible(muffled)
[16:11:06.353]                     }
[16:11:06.353]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.353]                   }
[16:11:06.353]                 }
[16:11:06.353]             }
[16:11:06.353]         }))
[16:11:06.353]     }, error = function(ex) {
[16:11:06.353]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:06.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.353]                 ...future.rng), started = ...future.startTime, 
[16:11:06.353]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:06.353]             version = "1.8"), class = "FutureResult")
[16:11:06.353]     }, finally = {
[16:11:06.353]         if (!identical(...future.workdir, getwd())) 
[16:11:06.353]             setwd(...future.workdir)
[16:11:06.353]         {
[16:11:06.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:06.353]                 ...future.oldOptions$nwarnings <- NULL
[16:11:06.353]             }
[16:11:06.353]             base::options(...future.oldOptions)
[16:11:06.353]             if (.Platform$OS.type == "windows") {
[16:11:06.353]                 old_names <- names(...future.oldEnvVars)
[16:11:06.353]                 envs <- base::Sys.getenv()
[16:11:06.353]                 names <- names(envs)
[16:11:06.353]                 common <- intersect(names, old_names)
[16:11:06.353]                 added <- setdiff(names, old_names)
[16:11:06.353]                 removed <- setdiff(old_names, names)
[16:11:06.353]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:06.353]                   envs[common]]
[16:11:06.353]                 NAMES <- toupper(changed)
[16:11:06.353]                 args <- list()
[16:11:06.353]                 for (kk in seq_along(NAMES)) {
[16:11:06.353]                   name <- changed[[kk]]
[16:11:06.353]                   NAME <- NAMES[[kk]]
[16:11:06.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.353]                     next
[16:11:06.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.353]                 }
[16:11:06.353]                 NAMES <- toupper(added)
[16:11:06.353]                 for (kk in seq_along(NAMES)) {
[16:11:06.353]                   name <- added[[kk]]
[16:11:06.353]                   NAME <- NAMES[[kk]]
[16:11:06.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.353]                     next
[16:11:06.353]                   args[[name]] <- ""
[16:11:06.353]                 }
[16:11:06.353]                 NAMES <- toupper(removed)
[16:11:06.353]                 for (kk in seq_along(NAMES)) {
[16:11:06.353]                   name <- removed[[kk]]
[16:11:06.353]                   NAME <- NAMES[[kk]]
[16:11:06.353]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.353]                     next
[16:11:06.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.353]                 }
[16:11:06.353]                 if (length(args) > 0) 
[16:11:06.353]                   base::do.call(base::Sys.setenv, args = args)
[16:11:06.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:06.353]             }
[16:11:06.353]             else {
[16:11:06.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:06.353]             }
[16:11:06.353]             {
[16:11:06.353]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:06.353]                   0L) {
[16:11:06.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:06.353]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:06.353]                   base::options(opts)
[16:11:06.353]                 }
[16:11:06.353]                 {
[16:11:06.353]                   {
[16:11:06.353]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:06.353]                     NULL
[16:11:06.353]                   }
[16:11:06.353]                   options(future.plan = NULL)
[16:11:06.353]                   if (is.na(NA_character_)) 
[16:11:06.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:06.353]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:06.353]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:06.353]                     envir = parent.frame()) 
[16:11:06.353]                   {
[16:11:06.353]                     if (is.function(workers)) 
[16:11:06.353]                       workers <- workers()
[16:11:06.353]                     workers <- structure(as.integer(workers), 
[16:11:06.353]                       class = class(workers))
[16:11:06.353]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:06.353]                       workers >= 1)
[16:11:06.353]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:06.353]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:06.353]                     }
[16:11:06.353]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:06.353]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:06.353]                       envir = envir)
[16:11:06.353]                     if (!future$lazy) 
[16:11:06.353]                       future <- run(future)
[16:11:06.353]                     invisible(future)
[16:11:06.353]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:06.353]                 }
[16:11:06.353]             }
[16:11:06.353]         }
[16:11:06.353]     })
[16:11:06.353]     if (TRUE) {
[16:11:06.353]         base::sink(type = "output", split = FALSE)
[16:11:06.353]         if (TRUE) {
[16:11:06.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:06.353]         }
[16:11:06.353]         else {
[16:11:06.353]             ...future.result["stdout"] <- base::list(NULL)
[16:11:06.353]         }
[16:11:06.353]         base::close(...future.stdout)
[16:11:06.353]         ...future.stdout <- NULL
[16:11:06.353]     }
[16:11:06.353]     ...future.result$conditions <- ...future.conditions
[16:11:06.353]     ...future.result$finished <- base::Sys.time()
[16:11:06.353]     ...future.result
[16:11:06.353] }
[16:11:06.356] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[16:11:06.356] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:06.400] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:06.400] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[16:11:06.401] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[16:11:06.401] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:06.401] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:06.401] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:06.448] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:06.448] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:06.492] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:06.492] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:11:06.493] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:11:06.493] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:06.493] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:06.493] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:06.494] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.494] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[16:11:06.494] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[16:11:06.495] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:06.495] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.495] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:06.495] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.495] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[16:11:06.496] MultisessionFuture started
[16:11:06.496] - Launch lazy future ... done
[16:11:06.496] run() for ‘MultisessionFuture’ ... done
[16:11:06.496] Created future:
[16:11:06.497] MultisessionFuture:
[16:11:06.497] Label: ‘future_vapply-1’
[16:11:06.497] Expression:
[16:11:06.497] {
[16:11:06.497]     do.call(function(...) {
[16:11:06.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.497]             on.exit(options(oopts), add = TRUE)
[16:11:06.497]         }
[16:11:06.497]         {
[16:11:06.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.497]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.497]             })
[16:11:06.497]         }
[16:11:06.497]     }, args = future.call.arguments)
[16:11:06.497] }
[16:11:06.497] Lazy evaluation: FALSE
[16:11:06.497] Asynchronous evaluation: TRUE
[16:11:06.497] Local evaluation: TRUE
[16:11:06.497] Environment: R_GlobalEnv
[16:11:06.497] Capture standard output: TRUE
[16:11:06.497] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:06.497] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:06.497] Packages: 1 packages (‘future.apply’)
[16:11:06.497] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:06.497] Resolved: FALSE
[16:11:06.497] Value: <not collected>
[16:11:06.497] Conditions captured: <none>
[16:11:06.497] Early signaling: FALSE
[16:11:06.497] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:06.497] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.508] Chunk #1 of 2 ... DONE
[16:11:06.509] Chunk #2 of 2 ...
[16:11:06.509]  - Finding globals in 'X' for chunk #2 ...
[16:11:06.509] getGlobalsAndPackages() ...
[16:11:06.509] Searching for globals...
[16:11:06.509] 
[16:11:06.509] Searching for globals ... DONE
[16:11:06.509] - globals: [0] <none>
[16:11:06.509] getGlobalsAndPackages() ... DONE
[16:11:06.510]    + additional globals found: [n=0] 
[16:11:06.510]    + additional namespaces needed: [n=0] 
[16:11:06.510]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:06.510]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:06.510]  - seeds: <none>
[16:11:06.510] getGlobalsAndPackages() ...
[16:11:06.510] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.510] Resolving globals: FALSE
[16:11:06.510] Tweak future expression to call with '...' arguments ...
[16:11:06.510] {
[16:11:06.510]     do.call(function(...) {
[16:11:06.510]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.510]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.510]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.510]             on.exit(options(oopts), add = TRUE)
[16:11:06.510]         }
[16:11:06.510]         {
[16:11:06.510]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.510]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.510]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.510]             })
[16:11:06.510]         }
[16:11:06.510]     }, args = future.call.arguments)
[16:11:06.510] }
[16:11:06.511] Tweak future expression to call with '...' arguments ... DONE
[16:11:06.511] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.511] - packages: [1] ‘future.apply’
[16:11:06.512] getGlobalsAndPackages() ... DONE
[16:11:06.512] run() for ‘Future’ ...
[16:11:06.512] - state: ‘created’
[16:11:06.512] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:06.527] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:06.527]   - Field: ‘node’
[16:11:06.527]   - Field: ‘label’
[16:11:06.528]   - Field: ‘local’
[16:11:06.528]   - Field: ‘owner’
[16:11:06.528]   - Field: ‘envir’
[16:11:06.528]   - Field: ‘workers’
[16:11:06.528]   - Field: ‘packages’
[16:11:06.528]   - Field: ‘gc’
[16:11:06.528]   - Field: ‘conditions’
[16:11:06.528]   - Field: ‘persistent’
[16:11:06.528]   - Field: ‘expr’
[16:11:06.529]   - Field: ‘uuid’
[16:11:06.529]   - Field: ‘seed’
[16:11:06.529]   - Field: ‘version’
[16:11:06.529]   - Field: ‘result’
[16:11:06.529]   - Field: ‘asynchronous’
[16:11:06.529]   - Field: ‘calls’
[16:11:06.529]   - Field: ‘globals’
[16:11:06.529]   - Field: ‘stdout’
[16:11:06.529]   - Field: ‘earlySignal’
[16:11:06.529]   - Field: ‘lazy’
[16:11:06.529]   - Field: ‘state’
[16:11:06.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:06.530] - Launch lazy future ...
[16:11:06.530] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:06.530] Packages needed by future strategies (n = 0): <none>
[16:11:06.531] {
[16:11:06.531]     {
[16:11:06.531]         {
[16:11:06.531]             ...future.startTime <- base::Sys.time()
[16:11:06.531]             {
[16:11:06.531]                 {
[16:11:06.531]                   {
[16:11:06.531]                     {
[16:11:06.531]                       {
[16:11:06.531]                         base::local({
[16:11:06.531]                           has_future <- base::requireNamespace("future", 
[16:11:06.531]                             quietly = TRUE)
[16:11:06.531]                           if (has_future) {
[16:11:06.531]                             ns <- base::getNamespace("future")
[16:11:06.531]                             version <- ns[[".package"]][["version"]]
[16:11:06.531]                             if (is.null(version)) 
[16:11:06.531]                               version <- utils::packageVersion("future")
[16:11:06.531]                           }
[16:11:06.531]                           else {
[16:11:06.531]                             version <- NULL
[16:11:06.531]                           }
[16:11:06.531]                           if (!has_future || version < "1.8.0") {
[16:11:06.531]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:06.531]                               "", base::R.version$version.string), 
[16:11:06.531]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:06.531]                                 base::R.version$platform, 8 * 
[16:11:06.531]                                   base::.Machine$sizeof.pointer), 
[16:11:06.531]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:06.531]                                 "release", "version")], collapse = " "), 
[16:11:06.531]                               hostname = base::Sys.info()[["nodename"]])
[16:11:06.531]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:06.531]                               info)
[16:11:06.531]                             info <- base::paste(info, collapse = "; ")
[16:11:06.531]                             if (!has_future) {
[16:11:06.531]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:06.531]                                 info)
[16:11:06.531]                             }
[16:11:06.531]                             else {
[16:11:06.531]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:06.531]                                 info, version)
[16:11:06.531]                             }
[16:11:06.531]                             base::stop(msg)
[16:11:06.531]                           }
[16:11:06.531]                         })
[16:11:06.531]                       }
[16:11:06.531]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:06.531]                       base::options(mc.cores = 1L)
[16:11:06.531]                     }
[16:11:06.531]                     base::local({
[16:11:06.531]                       for (pkg in "future.apply") {
[16:11:06.531]                         base::loadNamespace(pkg)
[16:11:06.531]                         base::library(pkg, character.only = TRUE)
[16:11:06.531]                       }
[16:11:06.531]                     })
[16:11:06.531]                   }
[16:11:06.531]                   options(future.plan = NULL)
[16:11:06.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:06.531]                 }
[16:11:06.531]                 ...future.workdir <- getwd()
[16:11:06.531]             }
[16:11:06.531]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:06.531]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:06.531]         }
[16:11:06.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:06.531]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:06.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:06.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:06.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:06.531]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:06.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:06.531]             base::names(...future.oldOptions))
[16:11:06.531]     }
[16:11:06.531]     if (FALSE) {
[16:11:06.531]     }
[16:11:06.531]     else {
[16:11:06.531]         if (TRUE) {
[16:11:06.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:06.531]                 open = "w")
[16:11:06.531]         }
[16:11:06.531]         else {
[16:11:06.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:06.531]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:06.531]         }
[16:11:06.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:06.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:06.531]             base::sink(type = "output", split = FALSE)
[16:11:06.531]             base::close(...future.stdout)
[16:11:06.531]         }, add = TRUE)
[16:11:06.531]     }
[16:11:06.531]     ...future.frame <- base::sys.nframe()
[16:11:06.531]     ...future.conditions <- base::list()
[16:11:06.531]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:06.531]     if (FALSE) {
[16:11:06.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:06.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:06.531]     }
[16:11:06.531]     ...future.result <- base::tryCatch({
[16:11:06.531]         base::withCallingHandlers({
[16:11:06.531]             ...future.value <- base::withVisible(base::local({
[16:11:06.531]                 ...future.makeSendCondition <- local({
[16:11:06.531]                   sendCondition <- NULL
[16:11:06.531]                   function(frame = 1L) {
[16:11:06.531]                     if (is.function(sendCondition)) 
[16:11:06.531]                       return(sendCondition)
[16:11:06.531]                     ns <- getNamespace("parallel")
[16:11:06.531]                     if (exists("sendData", mode = "function", 
[16:11:06.531]                       envir = ns)) {
[16:11:06.531]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:06.531]                         envir = ns)
[16:11:06.531]                       envir <- sys.frame(frame)
[16:11:06.531]                       master <- NULL
[16:11:06.531]                       while (!identical(envir, .GlobalEnv) && 
[16:11:06.531]                         !identical(envir, emptyenv())) {
[16:11:06.531]                         if (exists("master", mode = "list", envir = envir, 
[16:11:06.531]                           inherits = FALSE)) {
[16:11:06.531]                           master <- get("master", mode = "list", 
[16:11:06.531]                             envir = envir, inherits = FALSE)
[16:11:06.531]                           if (inherits(master, c("SOCKnode", 
[16:11:06.531]                             "SOCK0node"))) {
[16:11:06.531]                             sendCondition <<- function(cond) {
[16:11:06.531]                               data <- list(type = "VALUE", value = cond, 
[16:11:06.531]                                 success = TRUE)
[16:11:06.531]                               parallel_sendData(master, data)
[16:11:06.531]                             }
[16:11:06.531]                             return(sendCondition)
[16:11:06.531]                           }
[16:11:06.531]                         }
[16:11:06.531]                         frame <- frame + 1L
[16:11:06.531]                         envir <- sys.frame(frame)
[16:11:06.531]                       }
[16:11:06.531]                     }
[16:11:06.531]                     sendCondition <<- function(cond) NULL
[16:11:06.531]                   }
[16:11:06.531]                 })
[16:11:06.531]                 withCallingHandlers({
[16:11:06.531]                   {
[16:11:06.531]                     do.call(function(...) {
[16:11:06.531]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.531]                       if (!identical(...future.globals.maxSize.org, 
[16:11:06.531]                         ...future.globals.maxSize)) {
[16:11:06.531]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.531]                         on.exit(options(oopts), add = TRUE)
[16:11:06.531]                       }
[16:11:06.531]                       {
[16:11:06.531]                         lapply(seq_along(...future.elements_ii), 
[16:11:06.531]                           FUN = function(jj) {
[16:11:06.531]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.531]                             ...future.FUN(...future.X_jj, ...)
[16:11:06.531]                           })
[16:11:06.531]                       }
[16:11:06.531]                     }, args = future.call.arguments)
[16:11:06.531]                   }
[16:11:06.531]                 }, immediateCondition = function(cond) {
[16:11:06.531]                   sendCondition <- ...future.makeSendCondition()
[16:11:06.531]                   sendCondition(cond)
[16:11:06.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.531]                   {
[16:11:06.531]                     inherits <- base::inherits
[16:11:06.531]                     invokeRestart <- base::invokeRestart
[16:11:06.531]                     is.null <- base::is.null
[16:11:06.531]                     muffled <- FALSE
[16:11:06.531]                     if (inherits(cond, "message")) {
[16:11:06.531]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:06.531]                       if (muffled) 
[16:11:06.531]                         invokeRestart("muffleMessage")
[16:11:06.531]                     }
[16:11:06.531]                     else if (inherits(cond, "warning")) {
[16:11:06.531]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:06.531]                       if (muffled) 
[16:11:06.531]                         invokeRestart("muffleWarning")
[16:11:06.531]                     }
[16:11:06.531]                     else if (inherits(cond, "condition")) {
[16:11:06.531]                       if (!is.null(pattern)) {
[16:11:06.531]                         computeRestarts <- base::computeRestarts
[16:11:06.531]                         grepl <- base::grepl
[16:11:06.531]                         restarts <- computeRestarts(cond)
[16:11:06.531]                         for (restart in restarts) {
[16:11:06.531]                           name <- restart$name
[16:11:06.531]                           if (is.null(name)) 
[16:11:06.531]                             next
[16:11:06.531]                           if (!grepl(pattern, name)) 
[16:11:06.531]                             next
[16:11:06.531]                           invokeRestart(restart)
[16:11:06.531]                           muffled <- TRUE
[16:11:06.531]                           break
[16:11:06.531]                         }
[16:11:06.531]                       }
[16:11:06.531]                     }
[16:11:06.531]                     invisible(muffled)
[16:11:06.531]                   }
[16:11:06.531]                   muffleCondition(cond)
[16:11:06.531]                 })
[16:11:06.531]             }))
[16:11:06.531]             future::FutureResult(value = ...future.value$value, 
[16:11:06.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.531]                   ...future.rng), globalenv = if (FALSE) 
[16:11:06.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:06.531]                     ...future.globalenv.names))
[16:11:06.531]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:06.531]         }, condition = base::local({
[16:11:06.531]             c <- base::c
[16:11:06.531]             inherits <- base::inherits
[16:11:06.531]             invokeRestart <- base::invokeRestart
[16:11:06.531]             length <- base::length
[16:11:06.531]             list <- base::list
[16:11:06.531]             seq.int <- base::seq.int
[16:11:06.531]             signalCondition <- base::signalCondition
[16:11:06.531]             sys.calls <- base::sys.calls
[16:11:06.531]             `[[` <- base::`[[`
[16:11:06.531]             `+` <- base::`+`
[16:11:06.531]             `<<-` <- base::`<<-`
[16:11:06.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:06.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:06.531]                   3L)]
[16:11:06.531]             }
[16:11:06.531]             function(cond) {
[16:11:06.531]                 is_error <- inherits(cond, "error")
[16:11:06.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:06.531]                   NULL)
[16:11:06.531]                 if (is_error) {
[16:11:06.531]                   sessionInformation <- function() {
[16:11:06.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:06.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:06.531]                       search = base::search(), system = base::Sys.info())
[16:11:06.531]                   }
[16:11:06.531]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:06.531]                     cond$call), session = sessionInformation(), 
[16:11:06.531]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:06.531]                   signalCondition(cond)
[16:11:06.531]                 }
[16:11:06.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:06.531]                 "immediateCondition"))) {
[16:11:06.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:06.531]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:06.531]                   if (TRUE && !signal) {
[16:11:06.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.531]                     {
[16:11:06.531]                       inherits <- base::inherits
[16:11:06.531]                       invokeRestart <- base::invokeRestart
[16:11:06.531]                       is.null <- base::is.null
[16:11:06.531]                       muffled <- FALSE
[16:11:06.531]                       if (inherits(cond, "message")) {
[16:11:06.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.531]                         if (muffled) 
[16:11:06.531]                           invokeRestart("muffleMessage")
[16:11:06.531]                       }
[16:11:06.531]                       else if (inherits(cond, "warning")) {
[16:11:06.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.531]                         if (muffled) 
[16:11:06.531]                           invokeRestart("muffleWarning")
[16:11:06.531]                       }
[16:11:06.531]                       else if (inherits(cond, "condition")) {
[16:11:06.531]                         if (!is.null(pattern)) {
[16:11:06.531]                           computeRestarts <- base::computeRestarts
[16:11:06.531]                           grepl <- base::grepl
[16:11:06.531]                           restarts <- computeRestarts(cond)
[16:11:06.531]                           for (restart in restarts) {
[16:11:06.531]                             name <- restart$name
[16:11:06.531]                             if (is.null(name)) 
[16:11:06.531]                               next
[16:11:06.531]                             if (!grepl(pattern, name)) 
[16:11:06.531]                               next
[16:11:06.531]                             invokeRestart(restart)
[16:11:06.531]                             muffled <- TRUE
[16:11:06.531]                             break
[16:11:06.531]                           }
[16:11:06.531]                         }
[16:11:06.531]                       }
[16:11:06.531]                       invisible(muffled)
[16:11:06.531]                     }
[16:11:06.531]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.531]                   }
[16:11:06.531]                 }
[16:11:06.531]                 else {
[16:11:06.531]                   if (TRUE) {
[16:11:06.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.531]                     {
[16:11:06.531]                       inherits <- base::inherits
[16:11:06.531]                       invokeRestart <- base::invokeRestart
[16:11:06.531]                       is.null <- base::is.null
[16:11:06.531]                       muffled <- FALSE
[16:11:06.531]                       if (inherits(cond, "message")) {
[16:11:06.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.531]                         if (muffled) 
[16:11:06.531]                           invokeRestart("muffleMessage")
[16:11:06.531]                       }
[16:11:06.531]                       else if (inherits(cond, "warning")) {
[16:11:06.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.531]                         if (muffled) 
[16:11:06.531]                           invokeRestart("muffleWarning")
[16:11:06.531]                       }
[16:11:06.531]                       else if (inherits(cond, "condition")) {
[16:11:06.531]                         if (!is.null(pattern)) {
[16:11:06.531]                           computeRestarts <- base::computeRestarts
[16:11:06.531]                           grepl <- base::grepl
[16:11:06.531]                           restarts <- computeRestarts(cond)
[16:11:06.531]                           for (restart in restarts) {
[16:11:06.531]                             name <- restart$name
[16:11:06.531]                             if (is.null(name)) 
[16:11:06.531]                               next
[16:11:06.531]                             if (!grepl(pattern, name)) 
[16:11:06.531]                               next
[16:11:06.531]                             invokeRestart(restart)
[16:11:06.531]                             muffled <- TRUE
[16:11:06.531]                             break
[16:11:06.531]                           }
[16:11:06.531]                         }
[16:11:06.531]                       }
[16:11:06.531]                       invisible(muffled)
[16:11:06.531]                     }
[16:11:06.531]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.531]                   }
[16:11:06.531]                 }
[16:11:06.531]             }
[16:11:06.531]         }))
[16:11:06.531]     }, error = function(ex) {
[16:11:06.531]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:06.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.531]                 ...future.rng), started = ...future.startTime, 
[16:11:06.531]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:06.531]             version = "1.8"), class = "FutureResult")
[16:11:06.531]     }, finally = {
[16:11:06.531]         if (!identical(...future.workdir, getwd())) 
[16:11:06.531]             setwd(...future.workdir)
[16:11:06.531]         {
[16:11:06.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:06.531]                 ...future.oldOptions$nwarnings <- NULL
[16:11:06.531]             }
[16:11:06.531]             base::options(...future.oldOptions)
[16:11:06.531]             if (.Platform$OS.type == "windows") {
[16:11:06.531]                 old_names <- names(...future.oldEnvVars)
[16:11:06.531]                 envs <- base::Sys.getenv()
[16:11:06.531]                 names <- names(envs)
[16:11:06.531]                 common <- intersect(names, old_names)
[16:11:06.531]                 added <- setdiff(names, old_names)
[16:11:06.531]                 removed <- setdiff(old_names, names)
[16:11:06.531]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:06.531]                   envs[common]]
[16:11:06.531]                 NAMES <- toupper(changed)
[16:11:06.531]                 args <- list()
[16:11:06.531]                 for (kk in seq_along(NAMES)) {
[16:11:06.531]                   name <- changed[[kk]]
[16:11:06.531]                   NAME <- NAMES[[kk]]
[16:11:06.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.531]                     next
[16:11:06.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.531]                 }
[16:11:06.531]                 NAMES <- toupper(added)
[16:11:06.531]                 for (kk in seq_along(NAMES)) {
[16:11:06.531]                   name <- added[[kk]]
[16:11:06.531]                   NAME <- NAMES[[kk]]
[16:11:06.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.531]                     next
[16:11:06.531]                   args[[name]] <- ""
[16:11:06.531]                 }
[16:11:06.531]                 NAMES <- toupper(removed)
[16:11:06.531]                 for (kk in seq_along(NAMES)) {
[16:11:06.531]                   name <- removed[[kk]]
[16:11:06.531]                   NAME <- NAMES[[kk]]
[16:11:06.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.531]                     next
[16:11:06.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.531]                 }
[16:11:06.531]                 if (length(args) > 0) 
[16:11:06.531]                   base::do.call(base::Sys.setenv, args = args)
[16:11:06.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:06.531]             }
[16:11:06.531]             else {
[16:11:06.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:06.531]             }
[16:11:06.531]             {
[16:11:06.531]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:06.531]                   0L) {
[16:11:06.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:06.531]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:06.531]                   base::options(opts)
[16:11:06.531]                 }
[16:11:06.531]                 {
[16:11:06.531]                   {
[16:11:06.531]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:06.531]                     NULL
[16:11:06.531]                   }
[16:11:06.531]                   options(future.plan = NULL)
[16:11:06.531]                   if (is.na(NA_character_)) 
[16:11:06.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:06.531]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:06.531]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:06.531]                     envir = parent.frame()) 
[16:11:06.531]                   {
[16:11:06.531]                     if (is.function(workers)) 
[16:11:06.531]                       workers <- workers()
[16:11:06.531]                     workers <- structure(as.integer(workers), 
[16:11:06.531]                       class = class(workers))
[16:11:06.531]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:06.531]                       workers >= 1)
[16:11:06.531]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:06.531]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:06.531]                     }
[16:11:06.531]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:06.531]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:06.531]                       envir = envir)
[16:11:06.531]                     if (!future$lazy) 
[16:11:06.531]                       future <- run(future)
[16:11:06.531]                     invisible(future)
[16:11:06.531]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:06.531]                 }
[16:11:06.531]             }
[16:11:06.531]         }
[16:11:06.531]     })
[16:11:06.531]     if (TRUE) {
[16:11:06.531]         base::sink(type = "output", split = FALSE)
[16:11:06.531]         if (TRUE) {
[16:11:06.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:06.531]         }
[16:11:06.531]         else {
[16:11:06.531]             ...future.result["stdout"] <- base::list(NULL)
[16:11:06.531]         }
[16:11:06.531]         base::close(...future.stdout)
[16:11:06.531]         ...future.stdout <- NULL
[16:11:06.531]     }
[16:11:06.531]     ...future.result$conditions <- ...future.conditions
[16:11:06.531]     ...future.result$finished <- base::Sys.time()
[16:11:06.531]     ...future.result
[16:11:06.531] }
[16:11:06.534] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[16:11:06.534] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:06.576] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:06.576] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[16:11:06.577] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[16:11:06.577] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:06.577] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:06.578] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:06.620] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:06.620] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:06.664] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:06.664] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:11:06.664] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:11:06.664] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:06.665] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:06.665] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:06.665] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:06.666] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[16:11:06.666] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[16:11:06.666] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:06.666] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:06.666] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:06.667] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:06.667] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[16:11:06.667] MultisessionFuture started
[16:11:06.668] - Launch lazy future ... done
[16:11:06.668] run() for ‘MultisessionFuture’ ... done
[16:11:06.668] Created future:
[16:11:06.668] MultisessionFuture:
[16:11:06.668] Label: ‘future_vapply-2’
[16:11:06.668] Expression:
[16:11:06.668] {
[16:11:06.668]     do.call(function(...) {
[16:11:06.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.668]             on.exit(options(oopts), add = TRUE)
[16:11:06.668]         }
[16:11:06.668]         {
[16:11:06.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.668]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.668]             })
[16:11:06.668]         }
[16:11:06.668]     }, args = future.call.arguments)
[16:11:06.668] }
[16:11:06.668] Lazy evaluation: FALSE
[16:11:06.668] Asynchronous evaluation: TRUE
[16:11:06.668] Local evaluation: TRUE
[16:11:06.668] Environment: R_GlobalEnv
[16:11:06.668] Capture standard output: TRUE
[16:11:06.668] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:06.668] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:06.668] Packages: 1 packages (‘future.apply’)
[16:11:06.668] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:06.668] Resolved: FALSE
[16:11:06.668] Value: <not collected>
[16:11:06.668] Conditions captured: <none>
[16:11:06.668] Early signaling: FALSE
[16:11:06.668] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:06.668] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.680] Chunk #2 of 2 ... DONE
[16:11:06.680] Launching 2 futures (chunks) ... DONE
[16:11:06.680] Resolving 2 futures (chunks) ...
[16:11:06.680] resolve() on list ...
[16:11:06.680]  recursive: 0
[16:11:06.680]  length: 2
[16:11:06.680] 
[16:11:06.681] receiveMessageFromWorker() for ClusterFuture ...
[16:11:06.681] - Validating connection of MultisessionFuture
[16:11:06.681] - received message: FutureResult
[16:11:06.681] - Received FutureResult
[16:11:06.681] - Erased future from FutureRegistry
[16:11:06.682] result() for ClusterFuture ...
[16:11:06.682] - result already collected: FutureResult
[16:11:06.682] result() for ClusterFuture ... done
[16:11:06.682] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:06.682] Future #1
[16:11:06.682] result() for ClusterFuture ...
[16:11:06.682] - result already collected: FutureResult
[16:11:06.682] result() for ClusterFuture ... done
[16:11:06.682] result() for ClusterFuture ...
[16:11:06.682] - result already collected: FutureResult
[16:11:06.682] result() for ClusterFuture ... done
[16:11:06.683] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:06.683] - nx: 2
[16:11:06.683] - relay: TRUE
[16:11:06.683] - stdout: TRUE
[16:11:06.683] - signal: TRUE
[16:11:06.683] - resignal: FALSE
[16:11:06.683] - force: TRUE
[16:11:06.683] - relayed: [n=2] FALSE, FALSE
[16:11:06.683] - queued futures: [n=2] FALSE, FALSE
[16:11:06.683]  - until=1
[16:11:06.683]  - relaying element #1
[16:11:06.683] result() for ClusterFuture ...
[16:11:06.684] - result already collected: FutureResult
[16:11:06.684] result() for ClusterFuture ... done
[16:11:06.684] result() for ClusterFuture ...
[16:11:06.684] - result already collected: FutureResult
[16:11:06.684] result() for ClusterFuture ... done
[16:11:06.684] result() for ClusterFuture ...
[16:11:06.684] - result already collected: FutureResult
[16:11:06.684] result() for ClusterFuture ... done
[16:11:06.684] result() for ClusterFuture ...
[16:11:06.684] - result already collected: FutureResult
[16:11:06.684] result() for ClusterFuture ... done
[16:11:06.685] - relayed: [n=2] TRUE, FALSE
[16:11:06.685] - queued futures: [n=2] TRUE, FALSE
[16:11:06.685] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:06.685]  length: 1 (resolved future 1)
[16:11:06.713] receiveMessageFromWorker() for ClusterFuture ...
[16:11:06.713] - Validating connection of MultisessionFuture
[16:11:06.713] - received message: FutureResult
[16:11:06.713] - Received FutureResult
[16:11:06.714] - Erased future from FutureRegistry
[16:11:06.714] result() for ClusterFuture ...
[16:11:06.714] - result already collected: FutureResult
[16:11:06.714] result() for ClusterFuture ... done
[16:11:06.714] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:06.714] Future #2
[16:11:06.714] result() for ClusterFuture ...
[16:11:06.714] - result already collected: FutureResult
[16:11:06.714] result() for ClusterFuture ... done
[16:11:06.714] result() for ClusterFuture ...
[16:11:06.714] - result already collected: FutureResult
[16:11:06.715] result() for ClusterFuture ... done
[16:11:06.715] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:06.715] - nx: 2
[16:11:06.715] - relay: TRUE
[16:11:06.715] - stdout: TRUE
[16:11:06.715] - signal: TRUE
[16:11:06.715] - resignal: FALSE
[16:11:06.715] - force: TRUE
[16:11:06.715] - relayed: [n=2] TRUE, FALSE
[16:11:06.715] - queued futures: [n=2] TRUE, FALSE
[16:11:06.715]  - until=2
[16:11:06.716]  - relaying element #2
[16:11:06.716] result() for ClusterFuture ...
[16:11:06.716] - result already collected: FutureResult
[16:11:06.716] result() for ClusterFuture ... done
[16:11:06.716] result() for ClusterFuture ...
[16:11:06.716] - result already collected: FutureResult
[16:11:06.716] result() for ClusterFuture ... done
[16:11:06.716] result() for ClusterFuture ...
[16:11:06.716] - result already collected: FutureResult
[16:11:06.716] result() for ClusterFuture ... done
[16:11:06.716] result() for ClusterFuture ...
[16:11:06.717] - result already collected: FutureResult
[16:11:06.717] result() for ClusterFuture ... done
[16:11:06.717] - relayed: [n=2] TRUE, TRUE
[16:11:06.717] - queued futures: [n=2] TRUE, TRUE
[16:11:06.717] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:06.717]  length: 0 (resolved future 2)
[16:11:06.717] Relaying remaining futures
[16:11:06.717] signalConditionsASAP(NULL, pos=0) ...
[16:11:06.717] - nx: 2
[16:11:06.717] - relay: TRUE
[16:11:06.717] - stdout: TRUE
[16:11:06.718] - signal: TRUE
[16:11:06.718] - resignal: FALSE
[16:11:06.718] - force: TRUE
[16:11:06.718] - relayed: [n=2] TRUE, TRUE
[16:11:06.718] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:06.718] - relayed: [n=2] TRUE, TRUE
[16:11:06.718] - queued futures: [n=2] TRUE, TRUE
[16:11:06.718] signalConditionsASAP(NULL, pos=0) ... done
[16:11:06.718] resolve() on list ... DONE
[16:11:06.718] result() for ClusterFuture ...
[16:11:06.718] - result already collected: FutureResult
[16:11:06.718] result() for ClusterFuture ... done
[16:11:06.719] result() for ClusterFuture ...
[16:11:06.719] - result already collected: FutureResult
[16:11:06.719] result() for ClusterFuture ... done
[16:11:06.719] result() for ClusterFuture ...
[16:11:06.719] - result already collected: FutureResult
[16:11:06.719] result() for ClusterFuture ... done
[16:11:06.719] result() for ClusterFuture ...
[16:11:06.719] - result already collected: FutureResult
[16:11:06.719] result() for ClusterFuture ... done
[16:11:06.719]  - Number of value chunks collected: 2
[16:11:06.719] Resolving 2 futures (chunks) ... DONE
[16:11:06.720] Reducing values from 2 chunks ...
[16:11:06.720]  - Number of values collected after concatenation: 10
[16:11:06.720]  - Number of values expected: 10
[16:11:06.720] Reducing values from 2 chunks ... DONE
[16:11:06.720] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[16:11:06.722] future_lapply() ...
[16:11:06.728] Number of chunks: 2
[16:11:06.728] getGlobalsAndPackagesXApply() ...
[16:11:06.728]  - future.globals: TRUE
[16:11:06.728] getGlobalsAndPackages() ...
[16:11:06.728] Searching for globals...
[16:11:06.731] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[16:11:06.731] Searching for globals ... DONE
[16:11:06.732] Resolving globals: FALSE
[16:11:06.732] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[16:11:06.733] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:06.733] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:06.733] - packages: [2] ‘stats’, ‘future.apply’
[16:11:06.733] getGlobalsAndPackages() ... DONE
[16:11:06.733]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:06.733]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:11:06.734] Finding globals ... DONE
[16:11:06.734]  - use_args: TRUE
[16:11:06.734]  - Getting '...' globals ...
[16:11:06.734] resolve() on list ...
[16:11:06.734]  recursive: 0
[16:11:06.734]  length: 1
[16:11:06.734]  elements: ‘...’
[16:11:06.734]  length: 0 (resolved future 1)
[16:11:06.734] resolve() on list ... DONE
[16:11:06.735]    - '...' content: [n=0] 
[16:11:06.735] List of 1
[16:11:06.735]  $ ...: list()
[16:11:06.735]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:06.735]  - attr(*, "where")=List of 1
[16:11:06.735]   ..$ ...:<environment: 0x561e8b463e18> 
[16:11:06.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:06.735]  - attr(*, "resolved")= logi TRUE
[16:11:06.735]  - attr(*, "total_size")= num NA
[16:11:06.737]  - Getting '...' globals ... DONE
[16:11:06.737] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:06.737] List of 8
[16:11:06.737]  $ ...future.FUN:function (x, ...)  
[16:11:06.737]  $ x_FUN        :function (x, ...)  
[16:11:06.737]  $ times        : int 5
[16:11:06.737]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:06.737]  $ stop_if_not  :function (...)  
[16:11:06.737]  $ dim          : NULL
[16:11:06.737]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:06.737]  $ ...          : list()
[16:11:06.737]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:06.737]  - attr(*, "where")=List of 8
[16:11:06.737]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:06.737]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:06.737]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:06.737]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:06.737]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:06.737]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:06.737]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:06.737]   ..$ ...          :<environment: 0x561e8b463e18> 
[16:11:06.737]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:06.737]  - attr(*, "resolved")= logi FALSE
[16:11:06.737]  - attr(*, "total_size")= num 95528
[16:11:06.743] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:11:06.743] getGlobalsAndPackagesXApply() ... DONE
[16:11:06.743] Number of futures (= number of chunks): 2
[16:11:06.743] Launching 2 futures (chunks) ...
[16:11:06.743] Chunk #1 of 2 ...
[16:11:06.743]  - Finding globals in 'X' for chunk #1 ...
[16:11:06.743] getGlobalsAndPackages() ...
[16:11:06.744] Searching for globals...
[16:11:06.744] 
[16:11:06.744] Searching for globals ... DONE
[16:11:06.744] - globals: [0] <none>
[16:11:06.744] getGlobalsAndPackages() ... DONE
[16:11:06.744]    + additional globals found: [n=0] 
[16:11:06.744]    + additional namespaces needed: [n=0] 
[16:11:06.744]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:06.744]  - seeds: <none>
[16:11:06.745] getGlobalsAndPackages() ...
[16:11:06.745] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.745] Resolving globals: FALSE
[16:11:06.745] Tweak future expression to call with '...' arguments ...
[16:11:06.745] {
[16:11:06.745]     do.call(function(...) {
[16:11:06.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.745]             on.exit(options(oopts), add = TRUE)
[16:11:06.745]         }
[16:11:06.745]         {
[16:11:06.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.745]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.745]             })
[16:11:06.745]         }
[16:11:06.745]     }, args = future.call.arguments)
[16:11:06.745] }
[16:11:06.745] Tweak future expression to call with '...' arguments ... DONE
[16:11:06.746] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.746] - packages: [2] ‘stats’, ‘future.apply’
[16:11:06.746] getGlobalsAndPackages() ... DONE
[16:11:06.746] run() for ‘Future’ ...
[16:11:06.746] - state: ‘created’
[16:11:06.746] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:06.761] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:06.761]   - Field: ‘node’
[16:11:06.761]   - Field: ‘label’
[16:11:06.762]   - Field: ‘local’
[16:11:06.762]   - Field: ‘owner’
[16:11:06.762]   - Field: ‘envir’
[16:11:06.762]   - Field: ‘workers’
[16:11:06.762]   - Field: ‘packages’
[16:11:06.762]   - Field: ‘gc’
[16:11:06.762]   - Field: ‘conditions’
[16:11:06.762]   - Field: ‘persistent’
[16:11:06.762]   - Field: ‘expr’
[16:11:06.762]   - Field: ‘uuid’
[16:11:06.762]   - Field: ‘seed’
[16:11:06.763]   - Field: ‘version’
[16:11:06.763]   - Field: ‘result’
[16:11:06.763]   - Field: ‘asynchronous’
[16:11:06.763]   - Field: ‘calls’
[16:11:06.763]   - Field: ‘globals’
[16:11:06.763]   - Field: ‘stdout’
[16:11:06.763]   - Field: ‘earlySignal’
[16:11:06.763]   - Field: ‘lazy’
[16:11:06.763]   - Field: ‘state’
[16:11:06.763] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:06.763] - Launch lazy future ...
[16:11:06.771] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:06.771] Packages needed by future strategies (n = 0): <none>
[16:11:06.772] {
[16:11:06.772]     {
[16:11:06.772]         {
[16:11:06.772]             ...future.startTime <- base::Sys.time()
[16:11:06.772]             {
[16:11:06.772]                 {
[16:11:06.772]                   {
[16:11:06.772]                     {
[16:11:06.772]                       {
[16:11:06.772]                         base::local({
[16:11:06.772]                           has_future <- base::requireNamespace("future", 
[16:11:06.772]                             quietly = TRUE)
[16:11:06.772]                           if (has_future) {
[16:11:06.772]                             ns <- base::getNamespace("future")
[16:11:06.772]                             version <- ns[[".package"]][["version"]]
[16:11:06.772]                             if (is.null(version)) 
[16:11:06.772]                               version <- utils::packageVersion("future")
[16:11:06.772]                           }
[16:11:06.772]                           else {
[16:11:06.772]                             version <- NULL
[16:11:06.772]                           }
[16:11:06.772]                           if (!has_future || version < "1.8.0") {
[16:11:06.772]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:06.772]                               "", base::R.version$version.string), 
[16:11:06.772]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:06.772]                                 base::R.version$platform, 8 * 
[16:11:06.772]                                   base::.Machine$sizeof.pointer), 
[16:11:06.772]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:06.772]                                 "release", "version")], collapse = " "), 
[16:11:06.772]                               hostname = base::Sys.info()[["nodename"]])
[16:11:06.772]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:06.772]                               info)
[16:11:06.772]                             info <- base::paste(info, collapse = "; ")
[16:11:06.772]                             if (!has_future) {
[16:11:06.772]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:06.772]                                 info)
[16:11:06.772]                             }
[16:11:06.772]                             else {
[16:11:06.772]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:06.772]                                 info, version)
[16:11:06.772]                             }
[16:11:06.772]                             base::stop(msg)
[16:11:06.772]                           }
[16:11:06.772]                         })
[16:11:06.772]                       }
[16:11:06.772]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:06.772]                       base::options(mc.cores = 1L)
[16:11:06.772]                     }
[16:11:06.772]                     base::local({
[16:11:06.772]                       for (pkg in c("stats", "future.apply")) {
[16:11:06.772]                         base::loadNamespace(pkg)
[16:11:06.772]                         base::library(pkg, character.only = TRUE)
[16:11:06.772]                       }
[16:11:06.772]                     })
[16:11:06.772]                   }
[16:11:06.772]                   options(future.plan = NULL)
[16:11:06.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:06.772]                 }
[16:11:06.772]                 ...future.workdir <- getwd()
[16:11:06.772]             }
[16:11:06.772]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:06.772]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:06.772]         }
[16:11:06.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:06.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:06.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:06.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:06.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:06.772]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:06.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:06.772]             base::names(...future.oldOptions))
[16:11:06.772]     }
[16:11:06.772]     if (FALSE) {
[16:11:06.772]     }
[16:11:06.772]     else {
[16:11:06.772]         if (TRUE) {
[16:11:06.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:06.772]                 open = "w")
[16:11:06.772]         }
[16:11:06.772]         else {
[16:11:06.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:06.772]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:06.772]         }
[16:11:06.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:06.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:06.772]             base::sink(type = "output", split = FALSE)
[16:11:06.772]             base::close(...future.stdout)
[16:11:06.772]         }, add = TRUE)
[16:11:06.772]     }
[16:11:06.772]     ...future.frame <- base::sys.nframe()
[16:11:06.772]     ...future.conditions <- base::list()
[16:11:06.772]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:06.772]     if (FALSE) {
[16:11:06.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:06.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:06.772]     }
[16:11:06.772]     ...future.result <- base::tryCatch({
[16:11:06.772]         base::withCallingHandlers({
[16:11:06.772]             ...future.value <- base::withVisible(base::local({
[16:11:06.772]                 ...future.makeSendCondition <- local({
[16:11:06.772]                   sendCondition <- NULL
[16:11:06.772]                   function(frame = 1L) {
[16:11:06.772]                     if (is.function(sendCondition)) 
[16:11:06.772]                       return(sendCondition)
[16:11:06.772]                     ns <- getNamespace("parallel")
[16:11:06.772]                     if (exists("sendData", mode = "function", 
[16:11:06.772]                       envir = ns)) {
[16:11:06.772]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:06.772]                         envir = ns)
[16:11:06.772]                       envir <- sys.frame(frame)
[16:11:06.772]                       master <- NULL
[16:11:06.772]                       while (!identical(envir, .GlobalEnv) && 
[16:11:06.772]                         !identical(envir, emptyenv())) {
[16:11:06.772]                         if (exists("master", mode = "list", envir = envir, 
[16:11:06.772]                           inherits = FALSE)) {
[16:11:06.772]                           master <- get("master", mode = "list", 
[16:11:06.772]                             envir = envir, inherits = FALSE)
[16:11:06.772]                           if (inherits(master, c("SOCKnode", 
[16:11:06.772]                             "SOCK0node"))) {
[16:11:06.772]                             sendCondition <<- function(cond) {
[16:11:06.772]                               data <- list(type = "VALUE", value = cond, 
[16:11:06.772]                                 success = TRUE)
[16:11:06.772]                               parallel_sendData(master, data)
[16:11:06.772]                             }
[16:11:06.772]                             return(sendCondition)
[16:11:06.772]                           }
[16:11:06.772]                         }
[16:11:06.772]                         frame <- frame + 1L
[16:11:06.772]                         envir <- sys.frame(frame)
[16:11:06.772]                       }
[16:11:06.772]                     }
[16:11:06.772]                     sendCondition <<- function(cond) NULL
[16:11:06.772]                   }
[16:11:06.772]                 })
[16:11:06.772]                 withCallingHandlers({
[16:11:06.772]                   {
[16:11:06.772]                     do.call(function(...) {
[16:11:06.772]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.772]                       if (!identical(...future.globals.maxSize.org, 
[16:11:06.772]                         ...future.globals.maxSize)) {
[16:11:06.772]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.772]                         on.exit(options(oopts), add = TRUE)
[16:11:06.772]                       }
[16:11:06.772]                       {
[16:11:06.772]                         lapply(seq_along(...future.elements_ii), 
[16:11:06.772]                           FUN = function(jj) {
[16:11:06.772]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.772]                             ...future.FUN(...future.X_jj, ...)
[16:11:06.772]                           })
[16:11:06.772]                       }
[16:11:06.772]                     }, args = future.call.arguments)
[16:11:06.772]                   }
[16:11:06.772]                 }, immediateCondition = function(cond) {
[16:11:06.772]                   sendCondition <- ...future.makeSendCondition()
[16:11:06.772]                   sendCondition(cond)
[16:11:06.772]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.772]                   {
[16:11:06.772]                     inherits <- base::inherits
[16:11:06.772]                     invokeRestart <- base::invokeRestart
[16:11:06.772]                     is.null <- base::is.null
[16:11:06.772]                     muffled <- FALSE
[16:11:06.772]                     if (inherits(cond, "message")) {
[16:11:06.772]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:06.772]                       if (muffled) 
[16:11:06.772]                         invokeRestart("muffleMessage")
[16:11:06.772]                     }
[16:11:06.772]                     else if (inherits(cond, "warning")) {
[16:11:06.772]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:06.772]                       if (muffled) 
[16:11:06.772]                         invokeRestart("muffleWarning")
[16:11:06.772]                     }
[16:11:06.772]                     else if (inherits(cond, "condition")) {
[16:11:06.772]                       if (!is.null(pattern)) {
[16:11:06.772]                         computeRestarts <- base::computeRestarts
[16:11:06.772]                         grepl <- base::grepl
[16:11:06.772]                         restarts <- computeRestarts(cond)
[16:11:06.772]                         for (restart in restarts) {
[16:11:06.772]                           name <- restart$name
[16:11:06.772]                           if (is.null(name)) 
[16:11:06.772]                             next
[16:11:06.772]                           if (!grepl(pattern, name)) 
[16:11:06.772]                             next
[16:11:06.772]                           invokeRestart(restart)
[16:11:06.772]                           muffled <- TRUE
[16:11:06.772]                           break
[16:11:06.772]                         }
[16:11:06.772]                       }
[16:11:06.772]                     }
[16:11:06.772]                     invisible(muffled)
[16:11:06.772]                   }
[16:11:06.772]                   muffleCondition(cond)
[16:11:06.772]                 })
[16:11:06.772]             }))
[16:11:06.772]             future::FutureResult(value = ...future.value$value, 
[16:11:06.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.772]                   ...future.rng), globalenv = if (FALSE) 
[16:11:06.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:06.772]                     ...future.globalenv.names))
[16:11:06.772]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:06.772]         }, condition = base::local({
[16:11:06.772]             c <- base::c
[16:11:06.772]             inherits <- base::inherits
[16:11:06.772]             invokeRestart <- base::invokeRestart
[16:11:06.772]             length <- base::length
[16:11:06.772]             list <- base::list
[16:11:06.772]             seq.int <- base::seq.int
[16:11:06.772]             signalCondition <- base::signalCondition
[16:11:06.772]             sys.calls <- base::sys.calls
[16:11:06.772]             `[[` <- base::`[[`
[16:11:06.772]             `+` <- base::`+`
[16:11:06.772]             `<<-` <- base::`<<-`
[16:11:06.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:06.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:06.772]                   3L)]
[16:11:06.772]             }
[16:11:06.772]             function(cond) {
[16:11:06.772]                 is_error <- inherits(cond, "error")
[16:11:06.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:06.772]                   NULL)
[16:11:06.772]                 if (is_error) {
[16:11:06.772]                   sessionInformation <- function() {
[16:11:06.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:06.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:06.772]                       search = base::search(), system = base::Sys.info())
[16:11:06.772]                   }
[16:11:06.772]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:06.772]                     cond$call), session = sessionInformation(), 
[16:11:06.772]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:06.772]                   signalCondition(cond)
[16:11:06.772]                 }
[16:11:06.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:06.772]                 "immediateCondition"))) {
[16:11:06.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:06.772]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:06.772]                   if (TRUE && !signal) {
[16:11:06.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.772]                     {
[16:11:06.772]                       inherits <- base::inherits
[16:11:06.772]                       invokeRestart <- base::invokeRestart
[16:11:06.772]                       is.null <- base::is.null
[16:11:06.772]                       muffled <- FALSE
[16:11:06.772]                       if (inherits(cond, "message")) {
[16:11:06.772]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.772]                         if (muffled) 
[16:11:06.772]                           invokeRestart("muffleMessage")
[16:11:06.772]                       }
[16:11:06.772]                       else if (inherits(cond, "warning")) {
[16:11:06.772]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.772]                         if (muffled) 
[16:11:06.772]                           invokeRestart("muffleWarning")
[16:11:06.772]                       }
[16:11:06.772]                       else if (inherits(cond, "condition")) {
[16:11:06.772]                         if (!is.null(pattern)) {
[16:11:06.772]                           computeRestarts <- base::computeRestarts
[16:11:06.772]                           grepl <- base::grepl
[16:11:06.772]                           restarts <- computeRestarts(cond)
[16:11:06.772]                           for (restart in restarts) {
[16:11:06.772]                             name <- restart$name
[16:11:06.772]                             if (is.null(name)) 
[16:11:06.772]                               next
[16:11:06.772]                             if (!grepl(pattern, name)) 
[16:11:06.772]                               next
[16:11:06.772]                             invokeRestart(restart)
[16:11:06.772]                             muffled <- TRUE
[16:11:06.772]                             break
[16:11:06.772]                           }
[16:11:06.772]                         }
[16:11:06.772]                       }
[16:11:06.772]                       invisible(muffled)
[16:11:06.772]                     }
[16:11:06.772]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.772]                   }
[16:11:06.772]                 }
[16:11:06.772]                 else {
[16:11:06.772]                   if (TRUE) {
[16:11:06.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.772]                     {
[16:11:06.772]                       inherits <- base::inherits
[16:11:06.772]                       invokeRestart <- base::invokeRestart
[16:11:06.772]                       is.null <- base::is.null
[16:11:06.772]                       muffled <- FALSE
[16:11:06.772]                       if (inherits(cond, "message")) {
[16:11:06.772]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.772]                         if (muffled) 
[16:11:06.772]                           invokeRestart("muffleMessage")
[16:11:06.772]                       }
[16:11:06.772]                       else if (inherits(cond, "warning")) {
[16:11:06.772]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.772]                         if (muffled) 
[16:11:06.772]                           invokeRestart("muffleWarning")
[16:11:06.772]                       }
[16:11:06.772]                       else if (inherits(cond, "condition")) {
[16:11:06.772]                         if (!is.null(pattern)) {
[16:11:06.772]                           computeRestarts <- base::computeRestarts
[16:11:06.772]                           grepl <- base::grepl
[16:11:06.772]                           restarts <- computeRestarts(cond)
[16:11:06.772]                           for (restart in restarts) {
[16:11:06.772]                             name <- restart$name
[16:11:06.772]                             if (is.null(name)) 
[16:11:06.772]                               next
[16:11:06.772]                             if (!grepl(pattern, name)) 
[16:11:06.772]                               next
[16:11:06.772]                             invokeRestart(restart)
[16:11:06.772]                             muffled <- TRUE
[16:11:06.772]                             break
[16:11:06.772]                           }
[16:11:06.772]                         }
[16:11:06.772]                       }
[16:11:06.772]                       invisible(muffled)
[16:11:06.772]                     }
[16:11:06.772]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.772]                   }
[16:11:06.772]                 }
[16:11:06.772]             }
[16:11:06.772]         }))
[16:11:06.772]     }, error = function(ex) {
[16:11:06.772]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:06.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.772]                 ...future.rng), started = ...future.startTime, 
[16:11:06.772]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:06.772]             version = "1.8"), class = "FutureResult")
[16:11:06.772]     }, finally = {
[16:11:06.772]         if (!identical(...future.workdir, getwd())) 
[16:11:06.772]             setwd(...future.workdir)
[16:11:06.772]         {
[16:11:06.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:06.772]                 ...future.oldOptions$nwarnings <- NULL
[16:11:06.772]             }
[16:11:06.772]             base::options(...future.oldOptions)
[16:11:06.772]             if (.Platform$OS.type == "windows") {
[16:11:06.772]                 old_names <- names(...future.oldEnvVars)
[16:11:06.772]                 envs <- base::Sys.getenv()
[16:11:06.772]                 names <- names(envs)
[16:11:06.772]                 common <- intersect(names, old_names)
[16:11:06.772]                 added <- setdiff(names, old_names)
[16:11:06.772]                 removed <- setdiff(old_names, names)
[16:11:06.772]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:06.772]                   envs[common]]
[16:11:06.772]                 NAMES <- toupper(changed)
[16:11:06.772]                 args <- list()
[16:11:06.772]                 for (kk in seq_along(NAMES)) {
[16:11:06.772]                   name <- changed[[kk]]
[16:11:06.772]                   NAME <- NAMES[[kk]]
[16:11:06.772]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.772]                     next
[16:11:06.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.772]                 }
[16:11:06.772]                 NAMES <- toupper(added)
[16:11:06.772]                 for (kk in seq_along(NAMES)) {
[16:11:06.772]                   name <- added[[kk]]
[16:11:06.772]                   NAME <- NAMES[[kk]]
[16:11:06.772]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.772]                     next
[16:11:06.772]                   args[[name]] <- ""
[16:11:06.772]                 }
[16:11:06.772]                 NAMES <- toupper(removed)
[16:11:06.772]                 for (kk in seq_along(NAMES)) {
[16:11:06.772]                   name <- removed[[kk]]
[16:11:06.772]                   NAME <- NAMES[[kk]]
[16:11:06.772]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.772]                     next
[16:11:06.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.772]                 }
[16:11:06.772]                 if (length(args) > 0) 
[16:11:06.772]                   base::do.call(base::Sys.setenv, args = args)
[16:11:06.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:06.772]             }
[16:11:06.772]             else {
[16:11:06.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:06.772]             }
[16:11:06.772]             {
[16:11:06.772]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:06.772]                   0L) {
[16:11:06.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:06.772]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:06.772]                   base::options(opts)
[16:11:06.772]                 }
[16:11:06.772]                 {
[16:11:06.772]                   {
[16:11:06.772]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:06.772]                     NULL
[16:11:06.772]                   }
[16:11:06.772]                   options(future.plan = NULL)
[16:11:06.772]                   if (is.na(NA_character_)) 
[16:11:06.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:06.772]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:06.772]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:06.772]                     envir = parent.frame()) 
[16:11:06.772]                   {
[16:11:06.772]                     if (is.function(workers)) 
[16:11:06.772]                       workers <- workers()
[16:11:06.772]                     workers <- structure(as.integer(workers), 
[16:11:06.772]                       class = class(workers))
[16:11:06.772]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:06.772]                       workers >= 1)
[16:11:06.772]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:06.772]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:06.772]                     }
[16:11:06.772]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:06.772]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:06.772]                       envir = envir)
[16:11:06.772]                     if (!future$lazy) 
[16:11:06.772]                       future <- run(future)
[16:11:06.772]                     invisible(future)
[16:11:06.772]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:06.772]                 }
[16:11:06.772]             }
[16:11:06.772]         }
[16:11:06.772]     })
[16:11:06.772]     if (TRUE) {
[16:11:06.772]         base::sink(type = "output", split = FALSE)
[16:11:06.772]         if (TRUE) {
[16:11:06.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:06.772]         }
[16:11:06.772]         else {
[16:11:06.772]             ...future.result["stdout"] <- base::list(NULL)
[16:11:06.772]         }
[16:11:06.772]         base::close(...future.stdout)
[16:11:06.772]         ...future.stdout <- NULL
[16:11:06.772]     }
[16:11:06.772]     ...future.result$conditions <- ...future.conditions
[16:11:06.772]     ...future.result$finished <- base::Sys.time()
[16:11:06.772]     ...future.result
[16:11:06.772] }
[16:11:06.775] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[16:11:06.775] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:06.816] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:06.816] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[16:11:06.817] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:11:06.817] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:06.817] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:06.817] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:06.860] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:06.860] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:06.904] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:06.904] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:06.905] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.905] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:06.905] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:06.905] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:06.906] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.906] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[16:11:06.906] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[16:11:06.907] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:06.907] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.907] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:06.907] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:06.908] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[16:11:06.908] MultisessionFuture started
[16:11:06.908] - Launch lazy future ... done
[16:11:06.909] run() for ‘MultisessionFuture’ ... done
[16:11:06.909] Created future:
[16:11:06.909] MultisessionFuture:
[16:11:06.909] Label: ‘future_vapply-1’
[16:11:06.909] Expression:
[16:11:06.909] {
[16:11:06.909]     do.call(function(...) {
[16:11:06.909]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.909]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.909]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.909]             on.exit(options(oopts), add = TRUE)
[16:11:06.909]         }
[16:11:06.909]         {
[16:11:06.909]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.909]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.909]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.909]             })
[16:11:06.909]         }
[16:11:06.909]     }, args = future.call.arguments)
[16:11:06.909] }
[16:11:06.909] Lazy evaluation: FALSE
[16:11:06.909] Asynchronous evaluation: TRUE
[16:11:06.909] Local evaluation: TRUE
[16:11:06.909] Environment: R_GlobalEnv
[16:11:06.909] Capture standard output: TRUE
[16:11:06.909] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:06.909] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:06.909] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:06.909] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:06.909] Resolved: FALSE
[16:11:06.909] Value: <not collected>
[16:11:06.909] Conditions captured: <none>
[16:11:06.909] Early signaling: FALSE
[16:11:06.909] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:06.909] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.921] Chunk #1 of 2 ... DONE
[16:11:06.921] Chunk #2 of 2 ...
[16:11:06.921]  - Finding globals in 'X' for chunk #2 ...
[16:11:06.921] getGlobalsAndPackages() ...
[16:11:06.921] Searching for globals...
[16:11:06.921] 
[16:11:06.922] Searching for globals ... DONE
[16:11:06.922] - globals: [0] <none>
[16:11:06.922] getGlobalsAndPackages() ... DONE
[16:11:06.922]    + additional globals found: [n=0] 
[16:11:06.922]    + additional namespaces needed: [n=0] 
[16:11:06.922]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:06.922]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:06.922]  - seeds: <none>
[16:11:06.922] getGlobalsAndPackages() ...
[16:11:06.922] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.923] Resolving globals: FALSE
[16:11:06.923] Tweak future expression to call with '...' arguments ...
[16:11:06.923] {
[16:11:06.923]     do.call(function(...) {
[16:11:06.923]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.923]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:06.923]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.923]             on.exit(options(oopts), add = TRUE)
[16:11:06.923]         }
[16:11:06.923]         {
[16:11:06.923]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:06.923]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.923]                 ...future.FUN(...future.X_jj, ...)
[16:11:06.923]             })
[16:11:06.923]         }
[16:11:06.923]     }, args = future.call.arguments)
[16:11:06.923] }
[16:11:06.923] Tweak future expression to call with '...' arguments ... DONE
[16:11:06.924] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:06.924] - packages: [2] ‘stats’, ‘future.apply’
[16:11:06.924] getGlobalsAndPackages() ... DONE
[16:11:06.924] run() for ‘Future’ ...
[16:11:06.924] - state: ‘created’
[16:11:06.925] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:06.939] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:06.939] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:06.939]   - Field: ‘node’
[16:11:06.939]   - Field: ‘label’
[16:11:06.939]   - Field: ‘local’
[16:11:06.939]   - Field: ‘owner’
[16:11:06.940]   - Field: ‘envir’
[16:11:06.940]   - Field: ‘workers’
[16:11:06.940]   - Field: ‘packages’
[16:11:06.940]   - Field: ‘gc’
[16:11:06.940]   - Field: ‘conditions’
[16:11:06.940]   - Field: ‘persistent’
[16:11:06.940]   - Field: ‘expr’
[16:11:06.940]   - Field: ‘uuid’
[16:11:06.940]   - Field: ‘seed’
[16:11:06.940]   - Field: ‘version’
[16:11:06.940]   - Field: ‘result’
[16:11:06.941]   - Field: ‘asynchronous’
[16:11:06.941]   - Field: ‘calls’
[16:11:06.941]   - Field: ‘globals’
[16:11:06.941]   - Field: ‘stdout’
[16:11:06.941]   - Field: ‘earlySignal’
[16:11:06.941]   - Field: ‘lazy’
[16:11:06.941]   - Field: ‘state’
[16:11:06.941] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:06.941] - Launch lazy future ...
[16:11:06.942] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:06.942] Packages needed by future strategies (n = 0): <none>
[16:11:06.942] {
[16:11:06.942]     {
[16:11:06.942]         {
[16:11:06.942]             ...future.startTime <- base::Sys.time()
[16:11:06.942]             {
[16:11:06.942]                 {
[16:11:06.942]                   {
[16:11:06.942]                     {
[16:11:06.942]                       {
[16:11:06.942]                         base::local({
[16:11:06.942]                           has_future <- base::requireNamespace("future", 
[16:11:06.942]                             quietly = TRUE)
[16:11:06.942]                           if (has_future) {
[16:11:06.942]                             ns <- base::getNamespace("future")
[16:11:06.942]                             version <- ns[[".package"]][["version"]]
[16:11:06.942]                             if (is.null(version)) 
[16:11:06.942]                               version <- utils::packageVersion("future")
[16:11:06.942]                           }
[16:11:06.942]                           else {
[16:11:06.942]                             version <- NULL
[16:11:06.942]                           }
[16:11:06.942]                           if (!has_future || version < "1.8.0") {
[16:11:06.942]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:06.942]                               "", base::R.version$version.string), 
[16:11:06.942]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:06.942]                                 base::R.version$platform, 8 * 
[16:11:06.942]                                   base::.Machine$sizeof.pointer), 
[16:11:06.942]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:06.942]                                 "release", "version")], collapse = " "), 
[16:11:06.942]                               hostname = base::Sys.info()[["nodename"]])
[16:11:06.942]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:06.942]                               info)
[16:11:06.942]                             info <- base::paste(info, collapse = "; ")
[16:11:06.942]                             if (!has_future) {
[16:11:06.942]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:06.942]                                 info)
[16:11:06.942]                             }
[16:11:06.942]                             else {
[16:11:06.942]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:06.942]                                 info, version)
[16:11:06.942]                             }
[16:11:06.942]                             base::stop(msg)
[16:11:06.942]                           }
[16:11:06.942]                         })
[16:11:06.942]                       }
[16:11:06.942]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:06.942]                       base::options(mc.cores = 1L)
[16:11:06.942]                     }
[16:11:06.942]                     base::local({
[16:11:06.942]                       for (pkg in c("stats", "future.apply")) {
[16:11:06.942]                         base::loadNamespace(pkg)
[16:11:06.942]                         base::library(pkg, character.only = TRUE)
[16:11:06.942]                       }
[16:11:06.942]                     })
[16:11:06.942]                   }
[16:11:06.942]                   options(future.plan = NULL)
[16:11:06.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:06.942]                 }
[16:11:06.942]                 ...future.workdir <- getwd()
[16:11:06.942]             }
[16:11:06.942]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:06.942]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:06.942]         }
[16:11:06.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:06.942]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:06.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:06.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:06.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:06.942]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:06.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:06.942]             base::names(...future.oldOptions))
[16:11:06.942]     }
[16:11:06.942]     if (FALSE) {
[16:11:06.942]     }
[16:11:06.942]     else {
[16:11:06.942]         if (TRUE) {
[16:11:06.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:06.942]                 open = "w")
[16:11:06.942]         }
[16:11:06.942]         else {
[16:11:06.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:06.942]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:06.942]         }
[16:11:06.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:06.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:06.942]             base::sink(type = "output", split = FALSE)
[16:11:06.942]             base::close(...future.stdout)
[16:11:06.942]         }, add = TRUE)
[16:11:06.942]     }
[16:11:06.942]     ...future.frame <- base::sys.nframe()
[16:11:06.942]     ...future.conditions <- base::list()
[16:11:06.942]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:06.942]     if (FALSE) {
[16:11:06.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:06.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:06.942]     }
[16:11:06.942]     ...future.result <- base::tryCatch({
[16:11:06.942]         base::withCallingHandlers({
[16:11:06.942]             ...future.value <- base::withVisible(base::local({
[16:11:06.942]                 ...future.makeSendCondition <- local({
[16:11:06.942]                   sendCondition <- NULL
[16:11:06.942]                   function(frame = 1L) {
[16:11:06.942]                     if (is.function(sendCondition)) 
[16:11:06.942]                       return(sendCondition)
[16:11:06.942]                     ns <- getNamespace("parallel")
[16:11:06.942]                     if (exists("sendData", mode = "function", 
[16:11:06.942]                       envir = ns)) {
[16:11:06.942]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:06.942]                         envir = ns)
[16:11:06.942]                       envir <- sys.frame(frame)
[16:11:06.942]                       master <- NULL
[16:11:06.942]                       while (!identical(envir, .GlobalEnv) && 
[16:11:06.942]                         !identical(envir, emptyenv())) {
[16:11:06.942]                         if (exists("master", mode = "list", envir = envir, 
[16:11:06.942]                           inherits = FALSE)) {
[16:11:06.942]                           master <- get("master", mode = "list", 
[16:11:06.942]                             envir = envir, inherits = FALSE)
[16:11:06.942]                           if (inherits(master, c("SOCKnode", 
[16:11:06.942]                             "SOCK0node"))) {
[16:11:06.942]                             sendCondition <<- function(cond) {
[16:11:06.942]                               data <- list(type = "VALUE", value = cond, 
[16:11:06.942]                                 success = TRUE)
[16:11:06.942]                               parallel_sendData(master, data)
[16:11:06.942]                             }
[16:11:06.942]                             return(sendCondition)
[16:11:06.942]                           }
[16:11:06.942]                         }
[16:11:06.942]                         frame <- frame + 1L
[16:11:06.942]                         envir <- sys.frame(frame)
[16:11:06.942]                       }
[16:11:06.942]                     }
[16:11:06.942]                     sendCondition <<- function(cond) NULL
[16:11:06.942]                   }
[16:11:06.942]                 })
[16:11:06.942]                 withCallingHandlers({
[16:11:06.942]                   {
[16:11:06.942]                     do.call(function(...) {
[16:11:06.942]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:06.942]                       if (!identical(...future.globals.maxSize.org, 
[16:11:06.942]                         ...future.globals.maxSize)) {
[16:11:06.942]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:06.942]                         on.exit(options(oopts), add = TRUE)
[16:11:06.942]                       }
[16:11:06.942]                       {
[16:11:06.942]                         lapply(seq_along(...future.elements_ii), 
[16:11:06.942]                           FUN = function(jj) {
[16:11:06.942]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:06.942]                             ...future.FUN(...future.X_jj, ...)
[16:11:06.942]                           })
[16:11:06.942]                       }
[16:11:06.942]                     }, args = future.call.arguments)
[16:11:06.942]                   }
[16:11:06.942]                 }, immediateCondition = function(cond) {
[16:11:06.942]                   sendCondition <- ...future.makeSendCondition()
[16:11:06.942]                   sendCondition(cond)
[16:11:06.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.942]                   {
[16:11:06.942]                     inherits <- base::inherits
[16:11:06.942]                     invokeRestart <- base::invokeRestart
[16:11:06.942]                     is.null <- base::is.null
[16:11:06.942]                     muffled <- FALSE
[16:11:06.942]                     if (inherits(cond, "message")) {
[16:11:06.942]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:06.942]                       if (muffled) 
[16:11:06.942]                         invokeRestart("muffleMessage")
[16:11:06.942]                     }
[16:11:06.942]                     else if (inherits(cond, "warning")) {
[16:11:06.942]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:06.942]                       if (muffled) 
[16:11:06.942]                         invokeRestart("muffleWarning")
[16:11:06.942]                     }
[16:11:06.942]                     else if (inherits(cond, "condition")) {
[16:11:06.942]                       if (!is.null(pattern)) {
[16:11:06.942]                         computeRestarts <- base::computeRestarts
[16:11:06.942]                         grepl <- base::grepl
[16:11:06.942]                         restarts <- computeRestarts(cond)
[16:11:06.942]                         for (restart in restarts) {
[16:11:06.942]                           name <- restart$name
[16:11:06.942]                           if (is.null(name)) 
[16:11:06.942]                             next
[16:11:06.942]                           if (!grepl(pattern, name)) 
[16:11:06.942]                             next
[16:11:06.942]                           invokeRestart(restart)
[16:11:06.942]                           muffled <- TRUE
[16:11:06.942]                           break
[16:11:06.942]                         }
[16:11:06.942]                       }
[16:11:06.942]                     }
[16:11:06.942]                     invisible(muffled)
[16:11:06.942]                   }
[16:11:06.942]                   muffleCondition(cond)
[16:11:06.942]                 })
[16:11:06.942]             }))
[16:11:06.942]             future::FutureResult(value = ...future.value$value, 
[16:11:06.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.942]                   ...future.rng), globalenv = if (FALSE) 
[16:11:06.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:06.942]                     ...future.globalenv.names))
[16:11:06.942]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:06.942]         }, condition = base::local({
[16:11:06.942]             c <- base::c
[16:11:06.942]             inherits <- base::inherits
[16:11:06.942]             invokeRestart <- base::invokeRestart
[16:11:06.942]             length <- base::length
[16:11:06.942]             list <- base::list
[16:11:06.942]             seq.int <- base::seq.int
[16:11:06.942]             signalCondition <- base::signalCondition
[16:11:06.942]             sys.calls <- base::sys.calls
[16:11:06.942]             `[[` <- base::`[[`
[16:11:06.942]             `+` <- base::`+`
[16:11:06.942]             `<<-` <- base::`<<-`
[16:11:06.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:06.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:06.942]                   3L)]
[16:11:06.942]             }
[16:11:06.942]             function(cond) {
[16:11:06.942]                 is_error <- inherits(cond, "error")
[16:11:06.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:06.942]                   NULL)
[16:11:06.942]                 if (is_error) {
[16:11:06.942]                   sessionInformation <- function() {
[16:11:06.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:06.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:06.942]                       search = base::search(), system = base::Sys.info())
[16:11:06.942]                   }
[16:11:06.942]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:06.942]                     cond$call), session = sessionInformation(), 
[16:11:06.942]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:06.942]                   signalCondition(cond)
[16:11:06.942]                 }
[16:11:06.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:06.942]                 "immediateCondition"))) {
[16:11:06.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:06.942]                   ...future.conditions[[length(...future.conditions) + 
[16:11:06.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:06.942]                   if (TRUE && !signal) {
[16:11:06.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.942]                     {
[16:11:06.942]                       inherits <- base::inherits
[16:11:06.942]                       invokeRestart <- base::invokeRestart
[16:11:06.942]                       is.null <- base::is.null
[16:11:06.942]                       muffled <- FALSE
[16:11:06.942]                       if (inherits(cond, "message")) {
[16:11:06.942]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.942]                         if (muffled) 
[16:11:06.942]                           invokeRestart("muffleMessage")
[16:11:06.942]                       }
[16:11:06.942]                       else if (inherits(cond, "warning")) {
[16:11:06.942]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.942]                         if (muffled) 
[16:11:06.942]                           invokeRestart("muffleWarning")
[16:11:06.942]                       }
[16:11:06.942]                       else if (inherits(cond, "condition")) {
[16:11:06.942]                         if (!is.null(pattern)) {
[16:11:06.942]                           computeRestarts <- base::computeRestarts
[16:11:06.942]                           grepl <- base::grepl
[16:11:06.942]                           restarts <- computeRestarts(cond)
[16:11:06.942]                           for (restart in restarts) {
[16:11:06.942]                             name <- restart$name
[16:11:06.942]                             if (is.null(name)) 
[16:11:06.942]                               next
[16:11:06.942]                             if (!grepl(pattern, name)) 
[16:11:06.942]                               next
[16:11:06.942]                             invokeRestart(restart)
[16:11:06.942]                             muffled <- TRUE
[16:11:06.942]                             break
[16:11:06.942]                           }
[16:11:06.942]                         }
[16:11:06.942]                       }
[16:11:06.942]                       invisible(muffled)
[16:11:06.942]                     }
[16:11:06.942]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.942]                   }
[16:11:06.942]                 }
[16:11:06.942]                 else {
[16:11:06.942]                   if (TRUE) {
[16:11:06.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:06.942]                     {
[16:11:06.942]                       inherits <- base::inherits
[16:11:06.942]                       invokeRestart <- base::invokeRestart
[16:11:06.942]                       is.null <- base::is.null
[16:11:06.942]                       muffled <- FALSE
[16:11:06.942]                       if (inherits(cond, "message")) {
[16:11:06.942]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:06.942]                         if (muffled) 
[16:11:06.942]                           invokeRestart("muffleMessage")
[16:11:06.942]                       }
[16:11:06.942]                       else if (inherits(cond, "warning")) {
[16:11:06.942]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:06.942]                         if (muffled) 
[16:11:06.942]                           invokeRestart("muffleWarning")
[16:11:06.942]                       }
[16:11:06.942]                       else if (inherits(cond, "condition")) {
[16:11:06.942]                         if (!is.null(pattern)) {
[16:11:06.942]                           computeRestarts <- base::computeRestarts
[16:11:06.942]                           grepl <- base::grepl
[16:11:06.942]                           restarts <- computeRestarts(cond)
[16:11:06.942]                           for (restart in restarts) {
[16:11:06.942]                             name <- restart$name
[16:11:06.942]                             if (is.null(name)) 
[16:11:06.942]                               next
[16:11:06.942]                             if (!grepl(pattern, name)) 
[16:11:06.942]                               next
[16:11:06.942]                             invokeRestart(restart)
[16:11:06.942]                             muffled <- TRUE
[16:11:06.942]                             break
[16:11:06.942]                           }
[16:11:06.942]                         }
[16:11:06.942]                       }
[16:11:06.942]                       invisible(muffled)
[16:11:06.942]                     }
[16:11:06.942]                     muffleCondition(cond, pattern = "^muffle")
[16:11:06.942]                   }
[16:11:06.942]                 }
[16:11:06.942]             }
[16:11:06.942]         }))
[16:11:06.942]     }, error = function(ex) {
[16:11:06.942]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:06.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:06.942]                 ...future.rng), started = ...future.startTime, 
[16:11:06.942]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:06.942]             version = "1.8"), class = "FutureResult")
[16:11:06.942]     }, finally = {
[16:11:06.942]         if (!identical(...future.workdir, getwd())) 
[16:11:06.942]             setwd(...future.workdir)
[16:11:06.942]         {
[16:11:06.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:06.942]                 ...future.oldOptions$nwarnings <- NULL
[16:11:06.942]             }
[16:11:06.942]             base::options(...future.oldOptions)
[16:11:06.942]             if (.Platform$OS.type == "windows") {
[16:11:06.942]                 old_names <- names(...future.oldEnvVars)
[16:11:06.942]                 envs <- base::Sys.getenv()
[16:11:06.942]                 names <- names(envs)
[16:11:06.942]                 common <- intersect(names, old_names)
[16:11:06.942]                 added <- setdiff(names, old_names)
[16:11:06.942]                 removed <- setdiff(old_names, names)
[16:11:06.942]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:06.942]                   envs[common]]
[16:11:06.942]                 NAMES <- toupper(changed)
[16:11:06.942]                 args <- list()
[16:11:06.942]                 for (kk in seq_along(NAMES)) {
[16:11:06.942]                   name <- changed[[kk]]
[16:11:06.942]                   NAME <- NAMES[[kk]]
[16:11:06.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.942]                     next
[16:11:06.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.942]                 }
[16:11:06.942]                 NAMES <- toupper(added)
[16:11:06.942]                 for (kk in seq_along(NAMES)) {
[16:11:06.942]                   name <- added[[kk]]
[16:11:06.942]                   NAME <- NAMES[[kk]]
[16:11:06.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.942]                     next
[16:11:06.942]                   args[[name]] <- ""
[16:11:06.942]                 }
[16:11:06.942]                 NAMES <- toupper(removed)
[16:11:06.942]                 for (kk in seq_along(NAMES)) {
[16:11:06.942]                   name <- removed[[kk]]
[16:11:06.942]                   NAME <- NAMES[[kk]]
[16:11:06.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:06.942]                     next
[16:11:06.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:06.942]                 }
[16:11:06.942]                 if (length(args) > 0) 
[16:11:06.942]                   base::do.call(base::Sys.setenv, args = args)
[16:11:06.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:06.942]             }
[16:11:06.942]             else {
[16:11:06.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:06.942]             }
[16:11:06.942]             {
[16:11:06.942]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:06.942]                   0L) {
[16:11:06.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:06.942]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:06.942]                   base::options(opts)
[16:11:06.942]                 }
[16:11:06.942]                 {
[16:11:06.942]                   {
[16:11:06.942]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:06.942]                     NULL
[16:11:06.942]                   }
[16:11:06.942]                   options(future.plan = NULL)
[16:11:06.942]                   if (is.na(NA_character_)) 
[16:11:06.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:06.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:06.942]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:06.942]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:06.942]                     envir = parent.frame()) 
[16:11:06.942]                   {
[16:11:06.942]                     if (is.function(workers)) 
[16:11:06.942]                       workers <- workers()
[16:11:06.942]                     workers <- structure(as.integer(workers), 
[16:11:06.942]                       class = class(workers))
[16:11:06.942]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:06.942]                       workers >= 1)
[16:11:06.942]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:06.942]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:06.942]                     }
[16:11:06.942]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:06.942]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:06.942]                       envir = envir)
[16:11:06.942]                     if (!future$lazy) 
[16:11:06.942]                       future <- run(future)
[16:11:06.942]                     invisible(future)
[16:11:06.942]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:06.942]                 }
[16:11:06.942]             }
[16:11:06.942]         }
[16:11:06.942]     })
[16:11:06.942]     if (TRUE) {
[16:11:06.942]         base::sink(type = "output", split = FALSE)
[16:11:06.942]         if (TRUE) {
[16:11:06.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:06.942]         }
[16:11:06.942]         else {
[16:11:06.942]             ...future.result["stdout"] <- base::list(NULL)
[16:11:06.942]         }
[16:11:06.942]         base::close(...future.stdout)
[16:11:06.942]         ...future.stdout <- NULL
[16:11:06.942]     }
[16:11:06.942]     ...future.result$conditions <- ...future.conditions
[16:11:06.942]     ...future.result$finished <- base::Sys.time()
[16:11:06.942]     ...future.result
[16:11:06.942] }
[16:11:06.945] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[16:11:06.945] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:06.988] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:06.988] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[16:11:06.989] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:11:06.989] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:06.989] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:06.989] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:07.032] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:07.032] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:07.076] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:07.076] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:07.077] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.077] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:07.077] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:07.078] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:07.078] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.078] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[16:11:07.079] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[16:11:07.079] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:07.079] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.079] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:07.080] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.080] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[16:11:07.080] MultisessionFuture started
[16:11:07.080] - Launch lazy future ... done
[16:11:07.081] run() for ‘MultisessionFuture’ ... done
[16:11:07.081] Created future:
[16:11:07.081] MultisessionFuture:
[16:11:07.081] Label: ‘future_vapply-2’
[16:11:07.081] Expression:
[16:11:07.081] {
[16:11:07.081]     do.call(function(...) {
[16:11:07.081]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.081]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.081]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.081]             on.exit(options(oopts), add = TRUE)
[16:11:07.081]         }
[16:11:07.081]         {
[16:11:07.081]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.081]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.081]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.081]             })
[16:11:07.081]         }
[16:11:07.081]     }, args = future.call.arguments)
[16:11:07.081] }
[16:11:07.081] Lazy evaluation: FALSE
[16:11:07.081] Asynchronous evaluation: TRUE
[16:11:07.081] Local evaluation: TRUE
[16:11:07.081] Environment: R_GlobalEnv
[16:11:07.081] Capture standard output: TRUE
[16:11:07.081] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:07.081] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:07.081] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:07.081] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:07.081] Resolved: FALSE
[16:11:07.081] Value: <not collected>
[16:11:07.081] Conditions captured: <none>
[16:11:07.081] Early signaling: FALSE
[16:11:07.081] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:07.081] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.093] Chunk #2 of 2 ... DONE
[16:11:07.093] Launching 2 futures (chunks) ... DONE
[16:11:07.093] Resolving 2 futures (chunks) ...
[16:11:07.093] resolve() on list ...
[16:11:07.093]  recursive: 0
[16:11:07.093]  length: 2
[16:11:07.093] 
[16:11:07.094] receiveMessageFromWorker() for ClusterFuture ...
[16:11:07.094] - Validating connection of MultisessionFuture
[16:11:07.094] - received message: FutureResult
[16:11:07.094] - Received FutureResult
[16:11:07.094] - Erased future from FutureRegistry
[16:11:07.095] result() for ClusterFuture ...
[16:11:07.095] - result already collected: FutureResult
[16:11:07.095] result() for ClusterFuture ... done
[16:11:07.095] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:07.095] Future #1
[16:11:07.095] result() for ClusterFuture ...
[16:11:07.095] - result already collected: FutureResult
[16:11:07.095] result() for ClusterFuture ... done
[16:11:07.095] result() for ClusterFuture ...
[16:11:07.095] - result already collected: FutureResult
[16:11:07.095] result() for ClusterFuture ... done
[16:11:07.096] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:07.096] - nx: 2
[16:11:07.096] - relay: TRUE
[16:11:07.096] - stdout: TRUE
[16:11:07.096] - signal: TRUE
[16:11:07.096] - resignal: FALSE
[16:11:07.096] - force: TRUE
[16:11:07.096] - relayed: [n=2] FALSE, FALSE
[16:11:07.096] - queued futures: [n=2] FALSE, FALSE
[16:11:07.096]  - until=1
[16:11:07.096]  - relaying element #1
[16:11:07.097] result() for ClusterFuture ...
[16:11:07.097] - result already collected: FutureResult
[16:11:07.097] result() for ClusterFuture ... done
[16:11:07.097] result() for ClusterFuture ...
[16:11:07.097] - result already collected: FutureResult
[16:11:07.097] result() for ClusterFuture ... done
[16:11:07.097] result() for ClusterFuture ...
[16:11:07.097] - result already collected: FutureResult
[16:11:07.097] result() for ClusterFuture ... done
[16:11:07.097] result() for ClusterFuture ...
[16:11:07.097] - result already collected: FutureResult
[16:11:07.098] result() for ClusterFuture ... done
[16:11:07.098] - relayed: [n=2] TRUE, FALSE
[16:11:07.098] - queued futures: [n=2] TRUE, FALSE
[16:11:07.098] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:07.098]  length: 1 (resolved future 1)
[16:11:07.140] receiveMessageFromWorker() for ClusterFuture ...
[16:11:07.140] - Validating connection of MultisessionFuture
[16:11:07.140] - received message: FutureResult
[16:11:07.140] - Received FutureResult
[16:11:07.140] - Erased future from FutureRegistry
[16:11:07.140] result() for ClusterFuture ...
[16:11:07.140] - result already collected: FutureResult
[16:11:07.141] result() for ClusterFuture ... done
[16:11:07.141] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:07.141] Future #2
[16:11:07.141] result() for ClusterFuture ...
[16:11:07.141] - result already collected: FutureResult
[16:11:07.141] result() for ClusterFuture ... done
[16:11:07.141] result() for ClusterFuture ...
[16:11:07.141] - result already collected: FutureResult
[16:11:07.141] result() for ClusterFuture ... done
[16:11:07.141] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:07.141] - nx: 2
[16:11:07.142] - relay: TRUE
[16:11:07.142] - stdout: TRUE
[16:11:07.142] - signal: TRUE
[16:11:07.142] - resignal: FALSE
[16:11:07.142] - force: TRUE
[16:11:07.142] - relayed: [n=2] TRUE, FALSE
[16:11:07.142] - queued futures: [n=2] TRUE, FALSE
[16:11:07.142]  - until=2
[16:11:07.142]  - relaying element #2
[16:11:07.142] result() for ClusterFuture ...
[16:11:07.142] - result already collected: FutureResult
[16:11:07.143] result() for ClusterFuture ... done
[16:11:07.143] result() for ClusterFuture ...
[16:11:07.143] - result already collected: FutureResult
[16:11:07.143] result() for ClusterFuture ... done
[16:11:07.143] result() for ClusterFuture ...
[16:11:07.143] - result already collected: FutureResult
[16:11:07.143] result() for ClusterFuture ... done
[16:11:07.143] result() for ClusterFuture ...
[16:11:07.143] - result already collected: FutureResult
[16:11:07.143] result() for ClusterFuture ... done
[16:11:07.143] - relayed: [n=2] TRUE, TRUE
[16:11:07.143] - queued futures: [n=2] TRUE, TRUE
[16:11:07.144] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:07.144]  length: 0 (resolved future 2)
[16:11:07.144] Relaying remaining futures
[16:11:07.144] signalConditionsASAP(NULL, pos=0) ...
[16:11:07.144] - nx: 2
[16:11:07.144] - relay: TRUE
[16:11:07.144] - stdout: TRUE
[16:11:07.144] - signal: TRUE
[16:11:07.144] - resignal: FALSE
[16:11:07.144] - force: TRUE
[16:11:07.145] - relayed: [n=2] TRUE, TRUE
[16:11:07.145] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:07.145] - relayed: [n=2] TRUE, TRUE
[16:11:07.145] - queued futures: [n=2] TRUE, TRUE
[16:11:07.145] signalConditionsASAP(NULL, pos=0) ... done
[16:11:07.145] resolve() on list ... DONE
[16:11:07.145] result() for ClusterFuture ...
[16:11:07.145] - result already collected: FutureResult
[16:11:07.145] result() for ClusterFuture ... done
[16:11:07.145] result() for ClusterFuture ...
[16:11:07.145] - result already collected: FutureResult
[16:11:07.146] result() for ClusterFuture ... done
[16:11:07.146] result() for ClusterFuture ...
[16:11:07.146] - result already collected: FutureResult
[16:11:07.146] result() for ClusterFuture ... done
[16:11:07.146] result() for ClusterFuture ...
[16:11:07.146] - result already collected: FutureResult
[16:11:07.146] result() for ClusterFuture ... done
[16:11:07.146]  - Number of value chunks collected: 2
[16:11:07.146] Resolving 2 futures (chunks) ... DONE
[16:11:07.146] Reducing values from 2 chunks ...
[16:11:07.146]  - Number of values collected after concatenation: 3
[16:11:07.147]  - Number of values expected: 3
[16:11:07.147] Reducing values from 2 chunks ... DONE
[16:11:07.147] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[16:11:07.149] future_lapply() ...
[16:11:07.156] Number of chunks: 2
[16:11:07.156] getGlobalsAndPackagesXApply() ...
[16:11:07.156]  - future.globals: TRUE
[16:11:07.156] getGlobalsAndPackages() ...
[16:11:07.157] Searching for globals...
[16:11:07.162] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:11:07.162] Searching for globals ... DONE
[16:11:07.162] Resolving globals: FALSE
[16:11:07.163] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[16:11:07.163] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[16:11:07.163] - globals: [1] ‘FUN’
[16:11:07.163] - packages: [1] ‘stats’
[16:11:07.163] getGlobalsAndPackages() ... DONE
[16:11:07.163]  - globals found/used: [n=1] ‘FUN’
[16:11:07.164]  - needed namespaces: [n=1] ‘stats’
[16:11:07.164] Finding globals ... DONE
[16:11:07.164]  - use_args: TRUE
[16:11:07.164]  - Getting '...' globals ...
[16:11:07.164] resolve() on list ...
[16:11:07.164]  recursive: 0
[16:11:07.164]  length: 1
[16:11:07.164]  elements: ‘...’
[16:11:07.165]  length: 0 (resolved future 1)
[16:11:07.165] resolve() on list ... DONE
[16:11:07.165]    - '...' content: [n=0] 
[16:11:07.165] List of 1
[16:11:07.165]  $ ...: list()
[16:11:07.165]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:07.165]  - attr(*, "where")=List of 1
[16:11:07.165]   ..$ ...:<environment: 0x561e8b4e9a10> 
[16:11:07.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:07.165]  - attr(*, "resolved")= logi TRUE
[16:11:07.165]  - attr(*, "total_size")= num NA
[16:11:07.167]  - Getting '...' globals ... DONE
[16:11:07.168] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:07.168] List of 2
[16:11:07.168]  $ ...future.FUN:function (x, na.rm = TRUE)  
[16:11:07.168]  $ ...          : list()
[16:11:07.168]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:07.168]  - attr(*, "where")=List of 2
[16:11:07.168]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:07.168]   ..$ ...          :<environment: 0x561e8b4e9a10> 
[16:11:07.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:07.168]  - attr(*, "resolved")= logi FALSE
[16:11:07.168]  - attr(*, "total_size")= num 46960
[16:11:07.170] Packages to be attached in all futures: [n=1] ‘stats’
[16:11:07.171] getGlobalsAndPackagesXApply() ... DONE
[16:11:07.171] Number of futures (= number of chunks): 2
[16:11:07.171] Launching 2 futures (chunks) ...
[16:11:07.171] Chunk #1 of 2 ...
[16:11:07.171]  - Finding globals in 'X' for chunk #1 ...
[16:11:07.171] getGlobalsAndPackages() ...
[16:11:07.171] Searching for globals...
[16:11:07.171] 
[16:11:07.172] Searching for globals ... DONE
[16:11:07.172] - globals: [0] <none>
[16:11:07.172] getGlobalsAndPackages() ... DONE
[16:11:07.172]    + additional globals found: [n=0] 
[16:11:07.172]    + additional namespaces needed: [n=0] 
[16:11:07.172]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:07.172]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[16:11:07.172]  - seeds: <none>
[16:11:07.172] getGlobalsAndPackages() ...
[16:11:07.172] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.173] Resolving globals: FALSE
[16:11:07.173] Tweak future expression to call with '...' arguments ...
[16:11:07.173] {
[16:11:07.173]     do.call(function(...) {
[16:11:07.173]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.173]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.173]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.173]             on.exit(options(oopts), add = TRUE)
[16:11:07.173]         }
[16:11:07.173]         {
[16:11:07.173]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.173]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.173]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.173]             })
[16:11:07.173]         }
[16:11:07.173]     }, args = future.call.arguments)
[16:11:07.173] }
[16:11:07.173] Tweak future expression to call with '...' arguments ... DONE
[16:11:07.173] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.174] - packages: [1] ‘stats’
[16:11:07.174] getGlobalsAndPackages() ... DONE
[16:11:07.174] run() for ‘Future’ ...
[16:11:07.174] - state: ‘created’
[16:11:07.174] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:07.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:07.189]   - Field: ‘node’
[16:11:07.189]   - Field: ‘label’
[16:11:07.189]   - Field: ‘local’
[16:11:07.192]   - Field: ‘owner’
[16:11:07.192]   - Field: ‘envir’
[16:11:07.192]   - Field: ‘workers’
[16:11:07.192]   - Field: ‘packages’
[16:11:07.192]   - Field: ‘gc’
[16:11:07.192]   - Field: ‘conditions’
[16:11:07.192]   - Field: ‘persistent’
[16:11:07.192]   - Field: ‘expr’
[16:11:07.193]   - Field: ‘uuid’
[16:11:07.193]   - Field: ‘seed’
[16:11:07.193]   - Field: ‘version’
[16:11:07.193]   - Field: ‘result’
[16:11:07.193]   - Field: ‘asynchronous’
[16:11:07.193]   - Field: ‘calls’
[16:11:07.193]   - Field: ‘globals’
[16:11:07.193]   - Field: ‘stdout’
[16:11:07.193]   - Field: ‘earlySignal’
[16:11:07.193]   - Field: ‘lazy’
[16:11:07.194]   - Field: ‘state’
[16:11:07.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:07.194] - Launch lazy future ...
[16:11:07.194] Packages needed by the future expression (n = 1): ‘stats’
[16:11:07.194] Packages needed by future strategies (n = 0): <none>
[16:11:07.195] {
[16:11:07.195]     {
[16:11:07.195]         {
[16:11:07.195]             ...future.startTime <- base::Sys.time()
[16:11:07.195]             {
[16:11:07.195]                 {
[16:11:07.195]                   {
[16:11:07.195]                     {
[16:11:07.195]                       {
[16:11:07.195]                         base::local({
[16:11:07.195]                           has_future <- base::requireNamespace("future", 
[16:11:07.195]                             quietly = TRUE)
[16:11:07.195]                           if (has_future) {
[16:11:07.195]                             ns <- base::getNamespace("future")
[16:11:07.195]                             version <- ns[[".package"]][["version"]]
[16:11:07.195]                             if (is.null(version)) 
[16:11:07.195]                               version <- utils::packageVersion("future")
[16:11:07.195]                           }
[16:11:07.195]                           else {
[16:11:07.195]                             version <- NULL
[16:11:07.195]                           }
[16:11:07.195]                           if (!has_future || version < "1.8.0") {
[16:11:07.195]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:07.195]                               "", base::R.version$version.string), 
[16:11:07.195]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:07.195]                                 base::R.version$platform, 8 * 
[16:11:07.195]                                   base::.Machine$sizeof.pointer), 
[16:11:07.195]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:07.195]                                 "release", "version")], collapse = " "), 
[16:11:07.195]                               hostname = base::Sys.info()[["nodename"]])
[16:11:07.195]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:07.195]                               info)
[16:11:07.195]                             info <- base::paste(info, collapse = "; ")
[16:11:07.195]                             if (!has_future) {
[16:11:07.195]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:07.195]                                 info)
[16:11:07.195]                             }
[16:11:07.195]                             else {
[16:11:07.195]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:07.195]                                 info, version)
[16:11:07.195]                             }
[16:11:07.195]                             base::stop(msg)
[16:11:07.195]                           }
[16:11:07.195]                         })
[16:11:07.195]                       }
[16:11:07.195]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:07.195]                       base::options(mc.cores = 1L)
[16:11:07.195]                     }
[16:11:07.195]                     base::local({
[16:11:07.195]                       for (pkg in "stats") {
[16:11:07.195]                         base::loadNamespace(pkg)
[16:11:07.195]                         base::library(pkg, character.only = TRUE)
[16:11:07.195]                       }
[16:11:07.195]                     })
[16:11:07.195]                   }
[16:11:07.195]                   options(future.plan = NULL)
[16:11:07.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:07.195]                 }
[16:11:07.195]                 ...future.workdir <- getwd()
[16:11:07.195]             }
[16:11:07.195]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:07.195]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:07.195]         }
[16:11:07.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:07.195]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[16:11:07.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:07.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:07.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:07.195]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:07.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:07.195]             base::names(...future.oldOptions))
[16:11:07.195]     }
[16:11:07.195]     if (FALSE) {
[16:11:07.195]     }
[16:11:07.195]     else {
[16:11:07.195]         if (TRUE) {
[16:11:07.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:07.195]                 open = "w")
[16:11:07.195]         }
[16:11:07.195]         else {
[16:11:07.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:07.195]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:07.195]         }
[16:11:07.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:07.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:07.195]             base::sink(type = "output", split = FALSE)
[16:11:07.195]             base::close(...future.stdout)
[16:11:07.195]         }, add = TRUE)
[16:11:07.195]     }
[16:11:07.195]     ...future.frame <- base::sys.nframe()
[16:11:07.195]     ...future.conditions <- base::list()
[16:11:07.195]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:07.195]     if (FALSE) {
[16:11:07.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:07.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:07.195]     }
[16:11:07.195]     ...future.result <- base::tryCatch({
[16:11:07.195]         base::withCallingHandlers({
[16:11:07.195]             ...future.value <- base::withVisible(base::local({
[16:11:07.195]                 ...future.makeSendCondition <- local({
[16:11:07.195]                   sendCondition <- NULL
[16:11:07.195]                   function(frame = 1L) {
[16:11:07.195]                     if (is.function(sendCondition)) 
[16:11:07.195]                       return(sendCondition)
[16:11:07.195]                     ns <- getNamespace("parallel")
[16:11:07.195]                     if (exists("sendData", mode = "function", 
[16:11:07.195]                       envir = ns)) {
[16:11:07.195]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:07.195]                         envir = ns)
[16:11:07.195]                       envir <- sys.frame(frame)
[16:11:07.195]                       master <- NULL
[16:11:07.195]                       while (!identical(envir, .GlobalEnv) && 
[16:11:07.195]                         !identical(envir, emptyenv())) {
[16:11:07.195]                         if (exists("master", mode = "list", envir = envir, 
[16:11:07.195]                           inherits = FALSE)) {
[16:11:07.195]                           master <- get("master", mode = "list", 
[16:11:07.195]                             envir = envir, inherits = FALSE)
[16:11:07.195]                           if (inherits(master, c("SOCKnode", 
[16:11:07.195]                             "SOCK0node"))) {
[16:11:07.195]                             sendCondition <<- function(cond) {
[16:11:07.195]                               data <- list(type = "VALUE", value = cond, 
[16:11:07.195]                                 success = TRUE)
[16:11:07.195]                               parallel_sendData(master, data)
[16:11:07.195]                             }
[16:11:07.195]                             return(sendCondition)
[16:11:07.195]                           }
[16:11:07.195]                         }
[16:11:07.195]                         frame <- frame + 1L
[16:11:07.195]                         envir <- sys.frame(frame)
[16:11:07.195]                       }
[16:11:07.195]                     }
[16:11:07.195]                     sendCondition <<- function(cond) NULL
[16:11:07.195]                   }
[16:11:07.195]                 })
[16:11:07.195]                 withCallingHandlers({
[16:11:07.195]                   {
[16:11:07.195]                     do.call(function(...) {
[16:11:07.195]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.195]                       if (!identical(...future.globals.maxSize.org, 
[16:11:07.195]                         ...future.globals.maxSize)) {
[16:11:07.195]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.195]                         on.exit(options(oopts), add = TRUE)
[16:11:07.195]                       }
[16:11:07.195]                       {
[16:11:07.195]                         lapply(seq_along(...future.elements_ii), 
[16:11:07.195]                           FUN = function(jj) {
[16:11:07.195]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.195]                             ...future.FUN(...future.X_jj, ...)
[16:11:07.195]                           })
[16:11:07.195]                       }
[16:11:07.195]                     }, args = future.call.arguments)
[16:11:07.195]                   }
[16:11:07.195]                 }, immediateCondition = function(cond) {
[16:11:07.195]                   sendCondition <- ...future.makeSendCondition()
[16:11:07.195]                   sendCondition(cond)
[16:11:07.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.195]                   {
[16:11:07.195]                     inherits <- base::inherits
[16:11:07.195]                     invokeRestart <- base::invokeRestart
[16:11:07.195]                     is.null <- base::is.null
[16:11:07.195]                     muffled <- FALSE
[16:11:07.195]                     if (inherits(cond, "message")) {
[16:11:07.195]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:07.195]                       if (muffled) 
[16:11:07.195]                         invokeRestart("muffleMessage")
[16:11:07.195]                     }
[16:11:07.195]                     else if (inherits(cond, "warning")) {
[16:11:07.195]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:07.195]                       if (muffled) 
[16:11:07.195]                         invokeRestart("muffleWarning")
[16:11:07.195]                     }
[16:11:07.195]                     else if (inherits(cond, "condition")) {
[16:11:07.195]                       if (!is.null(pattern)) {
[16:11:07.195]                         computeRestarts <- base::computeRestarts
[16:11:07.195]                         grepl <- base::grepl
[16:11:07.195]                         restarts <- computeRestarts(cond)
[16:11:07.195]                         for (restart in restarts) {
[16:11:07.195]                           name <- restart$name
[16:11:07.195]                           if (is.null(name)) 
[16:11:07.195]                             next
[16:11:07.195]                           if (!grepl(pattern, name)) 
[16:11:07.195]                             next
[16:11:07.195]                           invokeRestart(restart)
[16:11:07.195]                           muffled <- TRUE
[16:11:07.195]                           break
[16:11:07.195]                         }
[16:11:07.195]                       }
[16:11:07.195]                     }
[16:11:07.195]                     invisible(muffled)
[16:11:07.195]                   }
[16:11:07.195]                   muffleCondition(cond)
[16:11:07.195]                 })
[16:11:07.195]             }))
[16:11:07.195]             future::FutureResult(value = ...future.value$value, 
[16:11:07.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.195]                   ...future.rng), globalenv = if (FALSE) 
[16:11:07.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:07.195]                     ...future.globalenv.names))
[16:11:07.195]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:07.195]         }, condition = base::local({
[16:11:07.195]             c <- base::c
[16:11:07.195]             inherits <- base::inherits
[16:11:07.195]             invokeRestart <- base::invokeRestart
[16:11:07.195]             length <- base::length
[16:11:07.195]             list <- base::list
[16:11:07.195]             seq.int <- base::seq.int
[16:11:07.195]             signalCondition <- base::signalCondition
[16:11:07.195]             sys.calls <- base::sys.calls
[16:11:07.195]             `[[` <- base::`[[`
[16:11:07.195]             `+` <- base::`+`
[16:11:07.195]             `<<-` <- base::`<<-`
[16:11:07.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:07.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:07.195]                   3L)]
[16:11:07.195]             }
[16:11:07.195]             function(cond) {
[16:11:07.195]                 is_error <- inherits(cond, "error")
[16:11:07.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:07.195]                   NULL)
[16:11:07.195]                 if (is_error) {
[16:11:07.195]                   sessionInformation <- function() {
[16:11:07.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:07.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:07.195]                       search = base::search(), system = base::Sys.info())
[16:11:07.195]                   }
[16:11:07.195]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:07.195]                     cond$call), session = sessionInformation(), 
[16:11:07.195]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:07.195]                   signalCondition(cond)
[16:11:07.195]                 }
[16:11:07.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:07.195]                 "immediateCondition"))) {
[16:11:07.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:07.195]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:07.195]                   if (TRUE && !signal) {
[16:11:07.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.195]                     {
[16:11:07.195]                       inherits <- base::inherits
[16:11:07.195]                       invokeRestart <- base::invokeRestart
[16:11:07.195]                       is.null <- base::is.null
[16:11:07.195]                       muffled <- FALSE
[16:11:07.195]                       if (inherits(cond, "message")) {
[16:11:07.195]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.195]                         if (muffled) 
[16:11:07.195]                           invokeRestart("muffleMessage")
[16:11:07.195]                       }
[16:11:07.195]                       else if (inherits(cond, "warning")) {
[16:11:07.195]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.195]                         if (muffled) 
[16:11:07.195]                           invokeRestart("muffleWarning")
[16:11:07.195]                       }
[16:11:07.195]                       else if (inherits(cond, "condition")) {
[16:11:07.195]                         if (!is.null(pattern)) {
[16:11:07.195]                           computeRestarts <- base::computeRestarts
[16:11:07.195]                           grepl <- base::grepl
[16:11:07.195]                           restarts <- computeRestarts(cond)
[16:11:07.195]                           for (restart in restarts) {
[16:11:07.195]                             name <- restart$name
[16:11:07.195]                             if (is.null(name)) 
[16:11:07.195]                               next
[16:11:07.195]                             if (!grepl(pattern, name)) 
[16:11:07.195]                               next
[16:11:07.195]                             invokeRestart(restart)
[16:11:07.195]                             muffled <- TRUE
[16:11:07.195]                             break
[16:11:07.195]                           }
[16:11:07.195]                         }
[16:11:07.195]                       }
[16:11:07.195]                       invisible(muffled)
[16:11:07.195]                     }
[16:11:07.195]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.195]                   }
[16:11:07.195]                 }
[16:11:07.195]                 else {
[16:11:07.195]                   if (TRUE) {
[16:11:07.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.195]                     {
[16:11:07.195]                       inherits <- base::inherits
[16:11:07.195]                       invokeRestart <- base::invokeRestart
[16:11:07.195]                       is.null <- base::is.null
[16:11:07.195]                       muffled <- FALSE
[16:11:07.195]                       if (inherits(cond, "message")) {
[16:11:07.195]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.195]                         if (muffled) 
[16:11:07.195]                           invokeRestart("muffleMessage")
[16:11:07.195]                       }
[16:11:07.195]                       else if (inherits(cond, "warning")) {
[16:11:07.195]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.195]                         if (muffled) 
[16:11:07.195]                           invokeRestart("muffleWarning")
[16:11:07.195]                       }
[16:11:07.195]                       else if (inherits(cond, "condition")) {
[16:11:07.195]                         if (!is.null(pattern)) {
[16:11:07.195]                           computeRestarts <- base::computeRestarts
[16:11:07.195]                           grepl <- base::grepl
[16:11:07.195]                           restarts <- computeRestarts(cond)
[16:11:07.195]                           for (restart in restarts) {
[16:11:07.195]                             name <- restart$name
[16:11:07.195]                             if (is.null(name)) 
[16:11:07.195]                               next
[16:11:07.195]                             if (!grepl(pattern, name)) 
[16:11:07.195]                               next
[16:11:07.195]                             invokeRestart(restart)
[16:11:07.195]                             muffled <- TRUE
[16:11:07.195]                             break
[16:11:07.195]                           }
[16:11:07.195]                         }
[16:11:07.195]                       }
[16:11:07.195]                       invisible(muffled)
[16:11:07.195]                     }
[16:11:07.195]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.195]                   }
[16:11:07.195]                 }
[16:11:07.195]             }
[16:11:07.195]         }))
[16:11:07.195]     }, error = function(ex) {
[16:11:07.195]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:07.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.195]                 ...future.rng), started = ...future.startTime, 
[16:11:07.195]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:07.195]             version = "1.8"), class = "FutureResult")
[16:11:07.195]     }, finally = {
[16:11:07.195]         if (!identical(...future.workdir, getwd())) 
[16:11:07.195]             setwd(...future.workdir)
[16:11:07.195]         {
[16:11:07.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:07.195]                 ...future.oldOptions$nwarnings <- NULL
[16:11:07.195]             }
[16:11:07.195]             base::options(...future.oldOptions)
[16:11:07.195]             if (.Platform$OS.type == "windows") {
[16:11:07.195]                 old_names <- names(...future.oldEnvVars)
[16:11:07.195]                 envs <- base::Sys.getenv()
[16:11:07.195]                 names <- names(envs)
[16:11:07.195]                 common <- intersect(names, old_names)
[16:11:07.195]                 added <- setdiff(names, old_names)
[16:11:07.195]                 removed <- setdiff(old_names, names)
[16:11:07.195]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:07.195]                   envs[common]]
[16:11:07.195]                 NAMES <- toupper(changed)
[16:11:07.195]                 args <- list()
[16:11:07.195]                 for (kk in seq_along(NAMES)) {
[16:11:07.195]                   name <- changed[[kk]]
[16:11:07.195]                   NAME <- NAMES[[kk]]
[16:11:07.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.195]                     next
[16:11:07.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.195]                 }
[16:11:07.195]                 NAMES <- toupper(added)
[16:11:07.195]                 for (kk in seq_along(NAMES)) {
[16:11:07.195]                   name <- added[[kk]]
[16:11:07.195]                   NAME <- NAMES[[kk]]
[16:11:07.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.195]                     next
[16:11:07.195]                   args[[name]] <- ""
[16:11:07.195]                 }
[16:11:07.195]                 NAMES <- toupper(removed)
[16:11:07.195]                 for (kk in seq_along(NAMES)) {
[16:11:07.195]                   name <- removed[[kk]]
[16:11:07.195]                   NAME <- NAMES[[kk]]
[16:11:07.195]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.195]                     next
[16:11:07.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.195]                 }
[16:11:07.195]                 if (length(args) > 0) 
[16:11:07.195]                   base::do.call(base::Sys.setenv, args = args)
[16:11:07.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:07.195]             }
[16:11:07.195]             else {
[16:11:07.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:07.195]             }
[16:11:07.195]             {
[16:11:07.195]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:07.195]                   0L) {
[16:11:07.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:07.195]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:07.195]                   base::options(opts)
[16:11:07.195]                 }
[16:11:07.195]                 {
[16:11:07.195]                   {
[16:11:07.195]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:07.195]                     NULL
[16:11:07.195]                   }
[16:11:07.195]                   options(future.plan = NULL)
[16:11:07.195]                   if (is.na(NA_character_)) 
[16:11:07.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:07.195]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:07.195]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:07.195]                     envir = parent.frame()) 
[16:11:07.195]                   {
[16:11:07.195]                     if (is.function(workers)) 
[16:11:07.195]                       workers <- workers()
[16:11:07.195]                     workers <- structure(as.integer(workers), 
[16:11:07.195]                       class = class(workers))
[16:11:07.195]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:07.195]                       workers >= 1)
[16:11:07.195]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:07.195]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:07.195]                     }
[16:11:07.195]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:07.195]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:07.195]                       envir = envir)
[16:11:07.195]                     if (!future$lazy) 
[16:11:07.195]                       future <- run(future)
[16:11:07.195]                     invisible(future)
[16:11:07.195]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:07.195]                 }
[16:11:07.195]             }
[16:11:07.195]         }
[16:11:07.195]     })
[16:11:07.195]     if (TRUE) {
[16:11:07.195]         base::sink(type = "output", split = FALSE)
[16:11:07.195]         if (TRUE) {
[16:11:07.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:07.195]         }
[16:11:07.195]         else {
[16:11:07.195]             ...future.result["stdout"] <- base::list(NULL)
[16:11:07.195]         }
[16:11:07.195]         base::close(...future.stdout)
[16:11:07.195]         ...future.stdout <- NULL
[16:11:07.195]     }
[16:11:07.195]     ...future.result$conditions <- ...future.conditions
[16:11:07.195]     ...future.result$finished <- base::Sys.time()
[16:11:07.195]     ...future.result
[16:11:07.195] }
[16:11:07.198] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[16:11:07.198] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[16:11:07.240] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[16:11:07.240] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:07.241] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.241] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[16:11:07.241] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[16:11:07.241] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:07.242] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.242] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:07.242] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.242] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[16:11:07.243] MultisessionFuture started
[16:11:07.243] - Launch lazy future ... done
[16:11:07.243] run() for ‘MultisessionFuture’ ... done
[16:11:07.243] Created future:
[16:11:07.243] MultisessionFuture:
[16:11:07.243] Label: ‘future_sapply-1’
[16:11:07.243] Expression:
[16:11:07.243] {
[16:11:07.243]     do.call(function(...) {
[16:11:07.243]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.243]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.243]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.243]             on.exit(options(oopts), add = TRUE)
[16:11:07.243]         }
[16:11:07.243]         {
[16:11:07.243]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.243]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.243]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.243]             })
[16:11:07.243]         }
[16:11:07.243]     }, args = future.call.arguments)
[16:11:07.243] }
[16:11:07.243] Lazy evaluation: FALSE
[16:11:07.243] Asynchronous evaluation: TRUE
[16:11:07.243] Local evaluation: TRUE
[16:11:07.243] Environment: R_GlobalEnv
[16:11:07.243] Capture standard output: TRUE
[16:11:07.243] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:07.243] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:07.243] Packages: 1 packages (‘stats’)
[16:11:07.243] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:07.243] Resolved: FALSE
[16:11:07.243] Value: <not collected>
[16:11:07.243] Conditions captured: <none>
[16:11:07.243] Early signaling: FALSE
[16:11:07.243] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:07.243] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.255] Chunk #1 of 2 ... DONE
[16:11:07.255] Chunk #2 of 2 ...
[16:11:07.255]  - Finding globals in 'X' for chunk #2 ...
[16:11:07.255] getGlobalsAndPackages() ...
[16:11:07.255] Searching for globals...
[16:11:07.256] 
[16:11:07.256] Searching for globals ... DONE
[16:11:07.256] - globals: [0] <none>
[16:11:07.256] getGlobalsAndPackages() ... DONE
[16:11:07.256]    + additional globals found: [n=0] 
[16:11:07.256]    + additional namespaces needed: [n=0] 
[16:11:07.256]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:07.256]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:11:07.257]  - seeds: <none>
[16:11:07.257] getGlobalsAndPackages() ...
[16:11:07.257] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.257] Resolving globals: FALSE
[16:11:07.257] Tweak future expression to call with '...' arguments ...
[16:11:07.257] {
[16:11:07.257]     do.call(function(...) {
[16:11:07.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.257]             on.exit(options(oopts), add = TRUE)
[16:11:07.257]         }
[16:11:07.257]         {
[16:11:07.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.257]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.257]             })
[16:11:07.257]         }
[16:11:07.257]     }, args = future.call.arguments)
[16:11:07.257] }
[16:11:07.257] Tweak future expression to call with '...' arguments ... DONE
[16:11:07.258] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.258] - packages: [1] ‘stats’
[16:11:07.258] getGlobalsAndPackages() ... DONE
[16:11:07.258] run() for ‘Future’ ...
[16:11:07.258] - state: ‘created’
[16:11:07.258] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:07.273] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:07.274]   - Field: ‘node’
[16:11:07.274]   - Field: ‘label’
[16:11:07.274]   - Field: ‘local’
[16:11:07.274]   - Field: ‘owner’
[16:11:07.274]   - Field: ‘envir’
[16:11:07.274]   - Field: ‘workers’
[16:11:07.274]   - Field: ‘packages’
[16:11:07.274]   - Field: ‘gc’
[16:11:07.275]   - Field: ‘conditions’
[16:11:07.275]   - Field: ‘persistent’
[16:11:07.275]   - Field: ‘expr’
[16:11:07.275]   - Field: ‘uuid’
[16:11:07.275]   - Field: ‘seed’
[16:11:07.275]   - Field: ‘version’
[16:11:07.275]   - Field: ‘result’
[16:11:07.275]   - Field: ‘asynchronous’
[16:11:07.275]   - Field: ‘calls’
[16:11:07.275]   - Field: ‘globals’
[16:11:07.275]   - Field: ‘stdout’
[16:11:07.276]   - Field: ‘earlySignal’
[16:11:07.276]   - Field: ‘lazy’
[16:11:07.276]   - Field: ‘state’
[16:11:07.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:07.276] - Launch lazy future ...
[16:11:07.276] Packages needed by the future expression (n = 1): ‘stats’
[16:11:07.276] Packages needed by future strategies (n = 0): <none>
[16:11:07.277] {
[16:11:07.277]     {
[16:11:07.277]         {
[16:11:07.277]             ...future.startTime <- base::Sys.time()
[16:11:07.277]             {
[16:11:07.277]                 {
[16:11:07.277]                   {
[16:11:07.277]                     {
[16:11:07.277]                       {
[16:11:07.277]                         base::local({
[16:11:07.277]                           has_future <- base::requireNamespace("future", 
[16:11:07.277]                             quietly = TRUE)
[16:11:07.277]                           if (has_future) {
[16:11:07.277]                             ns <- base::getNamespace("future")
[16:11:07.277]                             version <- ns[[".package"]][["version"]]
[16:11:07.277]                             if (is.null(version)) 
[16:11:07.277]                               version <- utils::packageVersion("future")
[16:11:07.277]                           }
[16:11:07.277]                           else {
[16:11:07.277]                             version <- NULL
[16:11:07.277]                           }
[16:11:07.277]                           if (!has_future || version < "1.8.0") {
[16:11:07.277]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:07.277]                               "", base::R.version$version.string), 
[16:11:07.277]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:07.277]                                 base::R.version$platform, 8 * 
[16:11:07.277]                                   base::.Machine$sizeof.pointer), 
[16:11:07.277]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:07.277]                                 "release", "version")], collapse = " "), 
[16:11:07.277]                               hostname = base::Sys.info()[["nodename"]])
[16:11:07.277]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:07.277]                               info)
[16:11:07.277]                             info <- base::paste(info, collapse = "; ")
[16:11:07.277]                             if (!has_future) {
[16:11:07.277]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:07.277]                                 info)
[16:11:07.277]                             }
[16:11:07.277]                             else {
[16:11:07.277]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:07.277]                                 info, version)
[16:11:07.277]                             }
[16:11:07.277]                             base::stop(msg)
[16:11:07.277]                           }
[16:11:07.277]                         })
[16:11:07.277]                       }
[16:11:07.277]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:07.277]                       base::options(mc.cores = 1L)
[16:11:07.277]                     }
[16:11:07.277]                     base::local({
[16:11:07.277]                       for (pkg in "stats") {
[16:11:07.277]                         base::loadNamespace(pkg)
[16:11:07.277]                         base::library(pkg, character.only = TRUE)
[16:11:07.277]                       }
[16:11:07.277]                     })
[16:11:07.277]                   }
[16:11:07.277]                   options(future.plan = NULL)
[16:11:07.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:07.277]                 }
[16:11:07.277]                 ...future.workdir <- getwd()
[16:11:07.277]             }
[16:11:07.277]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:07.277]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:07.277]         }
[16:11:07.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:07.277]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:11:07.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:07.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:07.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:07.277]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:07.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:07.277]             base::names(...future.oldOptions))
[16:11:07.277]     }
[16:11:07.277]     if (FALSE) {
[16:11:07.277]     }
[16:11:07.277]     else {
[16:11:07.277]         if (TRUE) {
[16:11:07.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:07.277]                 open = "w")
[16:11:07.277]         }
[16:11:07.277]         else {
[16:11:07.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:07.277]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:07.277]         }
[16:11:07.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:07.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:07.277]             base::sink(type = "output", split = FALSE)
[16:11:07.277]             base::close(...future.stdout)
[16:11:07.277]         }, add = TRUE)
[16:11:07.277]     }
[16:11:07.277]     ...future.frame <- base::sys.nframe()
[16:11:07.277]     ...future.conditions <- base::list()
[16:11:07.277]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:07.277]     if (FALSE) {
[16:11:07.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:07.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:07.277]     }
[16:11:07.277]     ...future.result <- base::tryCatch({
[16:11:07.277]         base::withCallingHandlers({
[16:11:07.277]             ...future.value <- base::withVisible(base::local({
[16:11:07.277]                 ...future.makeSendCondition <- local({
[16:11:07.277]                   sendCondition <- NULL
[16:11:07.277]                   function(frame = 1L) {
[16:11:07.277]                     if (is.function(sendCondition)) 
[16:11:07.277]                       return(sendCondition)
[16:11:07.277]                     ns <- getNamespace("parallel")
[16:11:07.277]                     if (exists("sendData", mode = "function", 
[16:11:07.277]                       envir = ns)) {
[16:11:07.277]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:07.277]                         envir = ns)
[16:11:07.277]                       envir <- sys.frame(frame)
[16:11:07.277]                       master <- NULL
[16:11:07.277]                       while (!identical(envir, .GlobalEnv) && 
[16:11:07.277]                         !identical(envir, emptyenv())) {
[16:11:07.277]                         if (exists("master", mode = "list", envir = envir, 
[16:11:07.277]                           inherits = FALSE)) {
[16:11:07.277]                           master <- get("master", mode = "list", 
[16:11:07.277]                             envir = envir, inherits = FALSE)
[16:11:07.277]                           if (inherits(master, c("SOCKnode", 
[16:11:07.277]                             "SOCK0node"))) {
[16:11:07.277]                             sendCondition <<- function(cond) {
[16:11:07.277]                               data <- list(type = "VALUE", value = cond, 
[16:11:07.277]                                 success = TRUE)
[16:11:07.277]                               parallel_sendData(master, data)
[16:11:07.277]                             }
[16:11:07.277]                             return(sendCondition)
[16:11:07.277]                           }
[16:11:07.277]                         }
[16:11:07.277]                         frame <- frame + 1L
[16:11:07.277]                         envir <- sys.frame(frame)
[16:11:07.277]                       }
[16:11:07.277]                     }
[16:11:07.277]                     sendCondition <<- function(cond) NULL
[16:11:07.277]                   }
[16:11:07.277]                 })
[16:11:07.277]                 withCallingHandlers({
[16:11:07.277]                   {
[16:11:07.277]                     do.call(function(...) {
[16:11:07.277]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.277]                       if (!identical(...future.globals.maxSize.org, 
[16:11:07.277]                         ...future.globals.maxSize)) {
[16:11:07.277]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.277]                         on.exit(options(oopts), add = TRUE)
[16:11:07.277]                       }
[16:11:07.277]                       {
[16:11:07.277]                         lapply(seq_along(...future.elements_ii), 
[16:11:07.277]                           FUN = function(jj) {
[16:11:07.277]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.277]                             ...future.FUN(...future.X_jj, ...)
[16:11:07.277]                           })
[16:11:07.277]                       }
[16:11:07.277]                     }, args = future.call.arguments)
[16:11:07.277]                   }
[16:11:07.277]                 }, immediateCondition = function(cond) {
[16:11:07.277]                   sendCondition <- ...future.makeSendCondition()
[16:11:07.277]                   sendCondition(cond)
[16:11:07.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.277]                   {
[16:11:07.277]                     inherits <- base::inherits
[16:11:07.277]                     invokeRestart <- base::invokeRestart
[16:11:07.277]                     is.null <- base::is.null
[16:11:07.277]                     muffled <- FALSE
[16:11:07.277]                     if (inherits(cond, "message")) {
[16:11:07.277]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:07.277]                       if (muffled) 
[16:11:07.277]                         invokeRestart("muffleMessage")
[16:11:07.277]                     }
[16:11:07.277]                     else if (inherits(cond, "warning")) {
[16:11:07.277]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:07.277]                       if (muffled) 
[16:11:07.277]                         invokeRestart("muffleWarning")
[16:11:07.277]                     }
[16:11:07.277]                     else if (inherits(cond, "condition")) {
[16:11:07.277]                       if (!is.null(pattern)) {
[16:11:07.277]                         computeRestarts <- base::computeRestarts
[16:11:07.277]                         grepl <- base::grepl
[16:11:07.277]                         restarts <- computeRestarts(cond)
[16:11:07.277]                         for (restart in restarts) {
[16:11:07.277]                           name <- restart$name
[16:11:07.277]                           if (is.null(name)) 
[16:11:07.277]                             next
[16:11:07.277]                           if (!grepl(pattern, name)) 
[16:11:07.277]                             next
[16:11:07.277]                           invokeRestart(restart)
[16:11:07.277]                           muffled <- TRUE
[16:11:07.277]                           break
[16:11:07.277]                         }
[16:11:07.277]                       }
[16:11:07.277]                     }
[16:11:07.277]                     invisible(muffled)
[16:11:07.277]                   }
[16:11:07.277]                   muffleCondition(cond)
[16:11:07.277]                 })
[16:11:07.277]             }))
[16:11:07.277]             future::FutureResult(value = ...future.value$value, 
[16:11:07.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.277]                   ...future.rng), globalenv = if (FALSE) 
[16:11:07.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:07.277]                     ...future.globalenv.names))
[16:11:07.277]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:07.277]         }, condition = base::local({
[16:11:07.277]             c <- base::c
[16:11:07.277]             inherits <- base::inherits
[16:11:07.277]             invokeRestart <- base::invokeRestart
[16:11:07.277]             length <- base::length
[16:11:07.277]             list <- base::list
[16:11:07.277]             seq.int <- base::seq.int
[16:11:07.277]             signalCondition <- base::signalCondition
[16:11:07.277]             sys.calls <- base::sys.calls
[16:11:07.277]             `[[` <- base::`[[`
[16:11:07.277]             `+` <- base::`+`
[16:11:07.277]             `<<-` <- base::`<<-`
[16:11:07.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:07.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:07.277]                   3L)]
[16:11:07.277]             }
[16:11:07.277]             function(cond) {
[16:11:07.277]                 is_error <- inherits(cond, "error")
[16:11:07.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:07.277]                   NULL)
[16:11:07.277]                 if (is_error) {
[16:11:07.277]                   sessionInformation <- function() {
[16:11:07.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:07.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:07.277]                       search = base::search(), system = base::Sys.info())
[16:11:07.277]                   }
[16:11:07.277]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:07.277]                     cond$call), session = sessionInformation(), 
[16:11:07.277]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:07.277]                   signalCondition(cond)
[16:11:07.277]                 }
[16:11:07.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:07.277]                 "immediateCondition"))) {
[16:11:07.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:07.277]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:07.277]                   if (TRUE && !signal) {
[16:11:07.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.277]                     {
[16:11:07.277]                       inherits <- base::inherits
[16:11:07.277]                       invokeRestart <- base::invokeRestart
[16:11:07.277]                       is.null <- base::is.null
[16:11:07.277]                       muffled <- FALSE
[16:11:07.277]                       if (inherits(cond, "message")) {
[16:11:07.277]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.277]                         if (muffled) 
[16:11:07.277]                           invokeRestart("muffleMessage")
[16:11:07.277]                       }
[16:11:07.277]                       else if (inherits(cond, "warning")) {
[16:11:07.277]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.277]                         if (muffled) 
[16:11:07.277]                           invokeRestart("muffleWarning")
[16:11:07.277]                       }
[16:11:07.277]                       else if (inherits(cond, "condition")) {
[16:11:07.277]                         if (!is.null(pattern)) {
[16:11:07.277]                           computeRestarts <- base::computeRestarts
[16:11:07.277]                           grepl <- base::grepl
[16:11:07.277]                           restarts <- computeRestarts(cond)
[16:11:07.277]                           for (restart in restarts) {
[16:11:07.277]                             name <- restart$name
[16:11:07.277]                             if (is.null(name)) 
[16:11:07.277]                               next
[16:11:07.277]                             if (!grepl(pattern, name)) 
[16:11:07.277]                               next
[16:11:07.277]                             invokeRestart(restart)
[16:11:07.277]                             muffled <- TRUE
[16:11:07.277]                             break
[16:11:07.277]                           }
[16:11:07.277]                         }
[16:11:07.277]                       }
[16:11:07.277]                       invisible(muffled)
[16:11:07.277]                     }
[16:11:07.277]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.277]                   }
[16:11:07.277]                 }
[16:11:07.277]                 else {
[16:11:07.277]                   if (TRUE) {
[16:11:07.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.277]                     {
[16:11:07.277]                       inherits <- base::inherits
[16:11:07.277]                       invokeRestart <- base::invokeRestart
[16:11:07.277]                       is.null <- base::is.null
[16:11:07.277]                       muffled <- FALSE
[16:11:07.277]                       if (inherits(cond, "message")) {
[16:11:07.277]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.277]                         if (muffled) 
[16:11:07.277]                           invokeRestart("muffleMessage")
[16:11:07.277]                       }
[16:11:07.277]                       else if (inherits(cond, "warning")) {
[16:11:07.277]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.277]                         if (muffled) 
[16:11:07.277]                           invokeRestart("muffleWarning")
[16:11:07.277]                       }
[16:11:07.277]                       else if (inherits(cond, "condition")) {
[16:11:07.277]                         if (!is.null(pattern)) {
[16:11:07.277]                           computeRestarts <- base::computeRestarts
[16:11:07.277]                           grepl <- base::grepl
[16:11:07.277]                           restarts <- computeRestarts(cond)
[16:11:07.277]                           for (restart in restarts) {
[16:11:07.277]                             name <- restart$name
[16:11:07.277]                             if (is.null(name)) 
[16:11:07.277]                               next
[16:11:07.277]                             if (!grepl(pattern, name)) 
[16:11:07.277]                               next
[16:11:07.277]                             invokeRestart(restart)
[16:11:07.277]                             muffled <- TRUE
[16:11:07.277]                             break
[16:11:07.277]                           }
[16:11:07.277]                         }
[16:11:07.277]                       }
[16:11:07.277]                       invisible(muffled)
[16:11:07.277]                     }
[16:11:07.277]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.277]                   }
[16:11:07.277]                 }
[16:11:07.277]             }
[16:11:07.277]         }))
[16:11:07.277]     }, error = function(ex) {
[16:11:07.277]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:07.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.277]                 ...future.rng), started = ...future.startTime, 
[16:11:07.277]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:07.277]             version = "1.8"), class = "FutureResult")
[16:11:07.277]     }, finally = {
[16:11:07.277]         if (!identical(...future.workdir, getwd())) 
[16:11:07.277]             setwd(...future.workdir)
[16:11:07.277]         {
[16:11:07.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:07.277]                 ...future.oldOptions$nwarnings <- NULL
[16:11:07.277]             }
[16:11:07.277]             base::options(...future.oldOptions)
[16:11:07.277]             if (.Platform$OS.type == "windows") {
[16:11:07.277]                 old_names <- names(...future.oldEnvVars)
[16:11:07.277]                 envs <- base::Sys.getenv()
[16:11:07.277]                 names <- names(envs)
[16:11:07.277]                 common <- intersect(names, old_names)
[16:11:07.277]                 added <- setdiff(names, old_names)
[16:11:07.277]                 removed <- setdiff(old_names, names)
[16:11:07.277]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:07.277]                   envs[common]]
[16:11:07.277]                 NAMES <- toupper(changed)
[16:11:07.277]                 args <- list()
[16:11:07.277]                 for (kk in seq_along(NAMES)) {
[16:11:07.277]                   name <- changed[[kk]]
[16:11:07.277]                   NAME <- NAMES[[kk]]
[16:11:07.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.277]                     next
[16:11:07.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.277]                 }
[16:11:07.277]                 NAMES <- toupper(added)
[16:11:07.277]                 for (kk in seq_along(NAMES)) {
[16:11:07.277]                   name <- added[[kk]]
[16:11:07.277]                   NAME <- NAMES[[kk]]
[16:11:07.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.277]                     next
[16:11:07.277]                   args[[name]] <- ""
[16:11:07.277]                 }
[16:11:07.277]                 NAMES <- toupper(removed)
[16:11:07.277]                 for (kk in seq_along(NAMES)) {
[16:11:07.277]                   name <- removed[[kk]]
[16:11:07.277]                   NAME <- NAMES[[kk]]
[16:11:07.277]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.277]                     next
[16:11:07.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.277]                 }
[16:11:07.277]                 if (length(args) > 0) 
[16:11:07.277]                   base::do.call(base::Sys.setenv, args = args)
[16:11:07.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:07.277]             }
[16:11:07.277]             else {
[16:11:07.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:07.277]             }
[16:11:07.277]             {
[16:11:07.277]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:07.277]                   0L) {
[16:11:07.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:07.277]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:07.277]                   base::options(opts)
[16:11:07.277]                 }
[16:11:07.277]                 {
[16:11:07.277]                   {
[16:11:07.277]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:07.277]                     NULL
[16:11:07.277]                   }
[16:11:07.277]                   options(future.plan = NULL)
[16:11:07.277]                   if (is.na(NA_character_)) 
[16:11:07.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:07.277]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:07.277]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:07.277]                     envir = parent.frame()) 
[16:11:07.277]                   {
[16:11:07.277]                     if (is.function(workers)) 
[16:11:07.277]                       workers <- workers()
[16:11:07.277]                     workers <- structure(as.integer(workers), 
[16:11:07.277]                       class = class(workers))
[16:11:07.277]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:07.277]                       workers >= 1)
[16:11:07.277]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:07.277]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:07.277]                     }
[16:11:07.277]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:07.277]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:07.277]                       envir = envir)
[16:11:07.277]                     if (!future$lazy) 
[16:11:07.277]                       future <- run(future)
[16:11:07.277]                     invisible(future)
[16:11:07.277]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:07.277]                 }
[16:11:07.277]             }
[16:11:07.277]         }
[16:11:07.277]     })
[16:11:07.277]     if (TRUE) {
[16:11:07.277]         base::sink(type = "output", split = FALSE)
[16:11:07.277]         if (TRUE) {
[16:11:07.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:07.277]         }
[16:11:07.277]         else {
[16:11:07.277]             ...future.result["stdout"] <- base::list(NULL)
[16:11:07.277]         }
[16:11:07.277]         base::close(...future.stdout)
[16:11:07.277]         ...future.stdout <- NULL
[16:11:07.277]     }
[16:11:07.277]     ...future.result$conditions <- ...future.conditions
[16:11:07.277]     ...future.result$finished <- base::Sys.time()
[16:11:07.277]     ...future.result
[16:11:07.277] }
[16:11:07.280] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[16:11:07.280] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[16:11:07.324] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[16:11:07.325] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:07.325] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.325] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[16:11:07.326] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[16:11:07.326] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:07.326] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.326] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:07.327] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.327] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[16:11:07.327] MultisessionFuture started
[16:11:07.327] - Launch lazy future ... done
[16:11:07.328] run() for ‘MultisessionFuture’ ... done
[16:11:07.328] Created future:
[16:11:07.328] MultisessionFuture:
[16:11:07.328] Label: ‘future_sapply-2’
[16:11:07.328] Expression:
[16:11:07.328] {
[16:11:07.328]     do.call(function(...) {
[16:11:07.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.328]             on.exit(options(oopts), add = TRUE)
[16:11:07.328]         }
[16:11:07.328]         {
[16:11:07.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.328]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.328]             })
[16:11:07.328]         }
[16:11:07.328]     }, args = future.call.arguments)
[16:11:07.328] }
[16:11:07.328] Lazy evaluation: FALSE
[16:11:07.328] Asynchronous evaluation: TRUE
[16:11:07.328] Local evaluation: TRUE
[16:11:07.328] Environment: R_GlobalEnv
[16:11:07.328] Capture standard output: TRUE
[16:11:07.328] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:07.328] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:07.328] Packages: 1 packages (‘stats’)
[16:11:07.328] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:07.328] Resolved: FALSE
[16:11:07.328] Value: <not collected>
[16:11:07.328] Conditions captured: <none>
[16:11:07.328] Early signaling: FALSE
[16:11:07.328] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:07.328] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.340] Chunk #2 of 2 ... DONE
[16:11:07.340] Launching 2 futures (chunks) ... DONE
[16:11:07.340] Resolving 2 futures (chunks) ...
[16:11:07.340] resolve() on list ...
[16:11:07.340]  recursive: 0
[16:11:07.341]  length: 2
[16:11:07.341] 
[16:11:07.341] receiveMessageFromWorker() for ClusterFuture ...
[16:11:07.341] - Validating connection of MultisessionFuture
[16:11:07.342] - received message: FutureResult
[16:11:07.342] - Received FutureResult
[16:11:07.342] - Erased future from FutureRegistry
[16:11:07.342] result() for ClusterFuture ...
[16:11:07.342] - result already collected: FutureResult
[16:11:07.342] result() for ClusterFuture ... done
[16:11:07.342] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:07.342] Future #1
[16:11:07.343] result() for ClusterFuture ...
[16:11:07.343] - result already collected: FutureResult
[16:11:07.343] result() for ClusterFuture ... done
[16:11:07.343] result() for ClusterFuture ...
[16:11:07.343] - result already collected: FutureResult
[16:11:07.343] result() for ClusterFuture ... done
[16:11:07.343] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:07.343] - nx: 2
[16:11:07.343] - relay: TRUE
[16:11:07.343] - stdout: TRUE
[16:11:07.343] - signal: TRUE
[16:11:07.344] - resignal: FALSE
[16:11:07.344] - force: TRUE
[16:11:07.344] - relayed: [n=2] FALSE, FALSE
[16:11:07.344] - queued futures: [n=2] FALSE, FALSE
[16:11:07.344]  - until=1
[16:11:07.344]  - relaying element #1
[16:11:07.344] result() for ClusterFuture ...
[16:11:07.344] - result already collected: FutureResult
[16:11:07.344] result() for ClusterFuture ... done
[16:11:07.344] result() for ClusterFuture ...
[16:11:07.344] - result already collected: FutureResult
[16:11:07.345] result() for ClusterFuture ... done
[16:11:07.345] result() for ClusterFuture ...
[16:11:07.345] - result already collected: FutureResult
[16:11:07.345] result() for ClusterFuture ... done
[16:11:07.345] result() for ClusterFuture ...
[16:11:07.345] - result already collected: FutureResult
[16:11:07.345] result() for ClusterFuture ... done
[16:11:07.345] - relayed: [n=2] TRUE, FALSE
[16:11:07.345] - queued futures: [n=2] TRUE, FALSE
[16:11:07.345] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:07.346]  length: 1 (resolved future 1)
[16:11:07.373] receiveMessageFromWorker() for ClusterFuture ...
[16:11:07.374] - Validating connection of MultisessionFuture
[16:11:07.374] - received message: FutureResult
[16:11:07.374] - Received FutureResult
[16:11:07.374] - Erased future from FutureRegistry
[16:11:07.374] result() for ClusterFuture ...
[16:11:07.374] - result already collected: FutureResult
[16:11:07.374] result() for ClusterFuture ... done
[16:11:07.374] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:07.375] Future #2
[16:11:07.375] result() for ClusterFuture ...
[16:11:07.375] - result already collected: FutureResult
[16:11:07.375] result() for ClusterFuture ... done
[16:11:07.375] result() for ClusterFuture ...
[16:11:07.375] - result already collected: FutureResult
[16:11:07.375] result() for ClusterFuture ... done
[16:11:07.375] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:07.375] - nx: 2
[16:11:07.375] - relay: TRUE
[16:11:07.375] - stdout: TRUE
[16:11:07.376] - signal: TRUE
[16:11:07.376] - resignal: FALSE
[16:11:07.376] - force: TRUE
[16:11:07.376] - relayed: [n=2] TRUE, FALSE
[16:11:07.376] - queued futures: [n=2] TRUE, FALSE
[16:11:07.376]  - until=2
[16:11:07.376]  - relaying element #2
[16:11:07.376] result() for ClusterFuture ...
[16:11:07.376] - result already collected: FutureResult
[16:11:07.376] result() for ClusterFuture ... done
[16:11:07.377] result() for ClusterFuture ...
[16:11:07.377] - result already collected: FutureResult
[16:11:07.377] result() for ClusterFuture ... done
[16:11:07.377] result() for ClusterFuture ...
[16:11:07.377] - result already collected: FutureResult
[16:11:07.377] result() for ClusterFuture ... done
[16:11:07.377] result() for ClusterFuture ...
[16:11:07.377] - result already collected: FutureResult
[16:11:07.377] result() for ClusterFuture ... done
[16:11:07.377] - relayed: [n=2] TRUE, TRUE
[16:11:07.377] - queued futures: [n=2] TRUE, TRUE
[16:11:07.378] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:07.378]  length: 0 (resolved future 2)
[16:11:07.378] Relaying remaining futures
[16:11:07.378] signalConditionsASAP(NULL, pos=0) ...
[16:11:07.378] - nx: 2
[16:11:07.378] - relay: TRUE
[16:11:07.378] - stdout: TRUE
[16:11:07.378] - signal: TRUE
[16:11:07.378] - resignal: FALSE
[16:11:07.378] - force: TRUE
[16:11:07.378] - relayed: [n=2] TRUE, TRUE
[16:11:07.378] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:07.379] - relayed: [n=2] TRUE, TRUE
[16:11:07.379] - queued futures: [n=2] TRUE, TRUE
[16:11:07.379] signalConditionsASAP(NULL, pos=0) ... done
[16:11:07.379] resolve() on list ... DONE
[16:11:07.379] result() for ClusterFuture ...
[16:11:07.379] - result already collected: FutureResult
[16:11:07.379] result() for ClusterFuture ... done
[16:11:07.379] result() for ClusterFuture ...
[16:11:07.379] - result already collected: FutureResult
[16:11:07.379] result() for ClusterFuture ... done
[16:11:07.380] result() for ClusterFuture ...
[16:11:07.380] - result already collected: FutureResult
[16:11:07.380] result() for ClusterFuture ... done
[16:11:07.380] result() for ClusterFuture ...
[16:11:07.380] - result already collected: FutureResult
[16:11:07.380] result() for ClusterFuture ... done
[16:11:07.380]  - Number of value chunks collected: 2
[16:11:07.380] Resolving 2 futures (chunks) ... DONE
[16:11:07.380] Reducing values from 2 chunks ...
[16:11:07.380]  - Number of values collected after concatenation: 7
[16:11:07.381]  - Number of values expected: 7
[16:11:07.381] Reducing values from 2 chunks ... DONE
[16:11:07.381] future_lapply() ... DONE
[16:11:07.381] future_lapply() ...
[16:11:07.387] Number of chunks: 2
[16:11:07.387] getGlobalsAndPackagesXApply() ...
[16:11:07.387]  - future.globals: TRUE
[16:11:07.387] getGlobalsAndPackages() ...
[16:11:07.387] Searching for globals...
[16:11:07.394] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[16:11:07.395] Searching for globals ... DONE
[16:11:07.395] Resolving globals: FALSE
[16:11:07.396] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[16:11:07.396] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[16:11:07.396] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:07.397] - packages: [2] ‘stats’, ‘future.apply’
[16:11:07.397] getGlobalsAndPackages() ... DONE
[16:11:07.397]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:07.397]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[16:11:07.397] Finding globals ... DONE
[16:11:07.397]  - use_args: TRUE
[16:11:07.397]  - Getting '...' globals ...
[16:11:07.398] resolve() on list ...
[16:11:07.398]  recursive: 0
[16:11:07.398]  length: 1
[16:11:07.398]  elements: ‘...’
[16:11:07.398]  length: 0 (resolved future 1)
[16:11:07.398] resolve() on list ... DONE
[16:11:07.398]    - '...' content: [n=0] 
[16:11:07.398] List of 1
[16:11:07.398]  $ ...: list()
[16:11:07.398]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:07.398]  - attr(*, "where")=List of 1
[16:11:07.398]   ..$ ...:<environment: 0x561e8b8c0cf8> 
[16:11:07.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:07.398]  - attr(*, "resolved")= logi TRUE
[16:11:07.398]  - attr(*, "total_size")= num NA
[16:11:07.401]  - Getting '...' globals ... DONE
[16:11:07.401] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:07.401] List of 8
[16:11:07.401]  $ ...future.FUN:function (x, ...)  
[16:11:07.401]  $ x_FUN        :function (x, na.rm = TRUE)  
[16:11:07.401]  $ times        : int 5
[16:11:07.401]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:07.401]  $ stop_if_not  :function (...)  
[16:11:07.401]  $ dim          : NULL
[16:11:07.401]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:07.401]  $ ...          : list()
[16:11:07.401]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:07.401]  - attr(*, "where")=List of 8
[16:11:07.401]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:07.401]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:07.401]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:07.401]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:07.401]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:07.401]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:07.401]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:07.401]   ..$ ...          :<environment: 0x561e8b8c0cf8> 
[16:11:07.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:07.401]  - attr(*, "resolved")= logi FALSE
[16:11:07.401]  - attr(*, "total_size")= num 141240
[16:11:07.406] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[16:11:07.407] getGlobalsAndPackagesXApply() ... DONE
[16:11:07.407] Number of futures (= number of chunks): 2
[16:11:07.407] Launching 2 futures (chunks) ...
[16:11:07.407] Chunk #1 of 2 ...
[16:11:07.407]  - Finding globals in 'X' for chunk #1 ...
[16:11:07.407] getGlobalsAndPackages() ...
[16:11:07.407] Searching for globals...
[16:11:07.407] 
[16:11:07.408] Searching for globals ... DONE
[16:11:07.408] - globals: [0] <none>
[16:11:07.408] getGlobalsAndPackages() ... DONE
[16:11:07.408]    + additional globals found: [n=0] 
[16:11:07.408]    + additional namespaces needed: [n=0] 
[16:11:07.408]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:07.408]  - Adjusted option 'future.globals.maxSize': 524288000 -> 4 * 524288000 = 2097152000 (bytes)
[16:11:07.408]  - seeds: <none>
[16:11:07.408] getGlobalsAndPackages() ...
[16:11:07.408] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.409] Resolving globals: FALSE
[16:11:07.409] Tweak future expression to call with '...' arguments ...
[16:11:07.409] {
[16:11:07.409]     do.call(function(...) {
[16:11:07.409]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.409]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.409]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.409]             on.exit(options(oopts), add = TRUE)
[16:11:07.409]         }
[16:11:07.409]         {
[16:11:07.409]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.409]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.409]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.409]             })
[16:11:07.409]         }
[16:11:07.409]     }, args = future.call.arguments)
[16:11:07.409] }
[16:11:07.409] Tweak future expression to call with '...' arguments ... DONE
[16:11:07.410] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.410] - packages: [2] ‘stats’, ‘future.apply’
[16:11:07.410] getGlobalsAndPackages() ... DONE
[16:11:07.410] run() for ‘Future’ ...
[16:11:07.410] - state: ‘created’
[16:11:07.410] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:07.432] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:07.433]   - Field: ‘node’
[16:11:07.433]   - Field: ‘label’
[16:11:07.433]   - Field: ‘local’
[16:11:07.433]   - Field: ‘owner’
[16:11:07.433]   - Field: ‘envir’
[16:11:07.433]   - Field: ‘workers’
[16:11:07.433]   - Field: ‘packages’
[16:11:07.433]   - Field: ‘gc’
[16:11:07.433]   - Field: ‘conditions’
[16:11:07.433]   - Field: ‘persistent’
[16:11:07.434]   - Field: ‘expr’
[16:11:07.434]   - Field: ‘uuid’
[16:11:07.434]   - Field: ‘seed’
[16:11:07.434]   - Field: ‘version’
[16:11:07.434]   - Field: ‘result’
[16:11:07.434]   - Field: ‘asynchronous’
[16:11:07.434]   - Field: ‘calls’
[16:11:07.434]   - Field: ‘globals’
[16:11:07.434]   - Field: ‘stdout’
[16:11:07.434]   - Field: ‘earlySignal’
[16:11:07.434]   - Field: ‘lazy’
[16:11:07.435]   - Field: ‘state’
[16:11:07.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:07.435] - Launch lazy future ...
[16:11:07.435] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:07.435] Packages needed by future strategies (n = 0): <none>
[16:11:07.436] {
[16:11:07.436]     {
[16:11:07.436]         {
[16:11:07.436]             ...future.startTime <- base::Sys.time()
[16:11:07.436]             {
[16:11:07.436]                 {
[16:11:07.436]                   {
[16:11:07.436]                     {
[16:11:07.436]                       {
[16:11:07.436]                         base::local({
[16:11:07.436]                           has_future <- base::requireNamespace("future", 
[16:11:07.436]                             quietly = TRUE)
[16:11:07.436]                           if (has_future) {
[16:11:07.436]                             ns <- base::getNamespace("future")
[16:11:07.436]                             version <- ns[[".package"]][["version"]]
[16:11:07.436]                             if (is.null(version)) 
[16:11:07.436]                               version <- utils::packageVersion("future")
[16:11:07.436]                           }
[16:11:07.436]                           else {
[16:11:07.436]                             version <- NULL
[16:11:07.436]                           }
[16:11:07.436]                           if (!has_future || version < "1.8.0") {
[16:11:07.436]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:07.436]                               "", base::R.version$version.string), 
[16:11:07.436]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:07.436]                                 base::R.version$platform, 8 * 
[16:11:07.436]                                   base::.Machine$sizeof.pointer), 
[16:11:07.436]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:07.436]                                 "release", "version")], collapse = " "), 
[16:11:07.436]                               hostname = base::Sys.info()[["nodename"]])
[16:11:07.436]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:07.436]                               info)
[16:11:07.436]                             info <- base::paste(info, collapse = "; ")
[16:11:07.436]                             if (!has_future) {
[16:11:07.436]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:07.436]                                 info)
[16:11:07.436]                             }
[16:11:07.436]                             else {
[16:11:07.436]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:07.436]                                 info, version)
[16:11:07.436]                             }
[16:11:07.436]                             base::stop(msg)
[16:11:07.436]                           }
[16:11:07.436]                         })
[16:11:07.436]                       }
[16:11:07.436]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:07.436]                       base::options(mc.cores = 1L)
[16:11:07.436]                     }
[16:11:07.436]                     base::local({
[16:11:07.436]                       for (pkg in c("stats", "future.apply")) {
[16:11:07.436]                         base::loadNamespace(pkg)
[16:11:07.436]                         base::library(pkg, character.only = TRUE)
[16:11:07.436]                       }
[16:11:07.436]                     })
[16:11:07.436]                   }
[16:11:07.436]                   options(future.plan = NULL)
[16:11:07.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:07.436]                 }
[16:11:07.436]                 ...future.workdir <- getwd()
[16:11:07.436]             }
[16:11:07.436]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:07.436]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:07.436]         }
[16:11:07.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:07.436]             future.globals.maxSize = 2097152000, future.globals.method = NULL, 
[16:11:07.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:07.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:07.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:07.436]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:07.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:07.436]             base::names(...future.oldOptions))
[16:11:07.436]     }
[16:11:07.436]     if (FALSE) {
[16:11:07.436]     }
[16:11:07.436]     else {
[16:11:07.436]         if (TRUE) {
[16:11:07.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:07.436]                 open = "w")
[16:11:07.436]         }
[16:11:07.436]         else {
[16:11:07.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:07.436]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:07.436]         }
[16:11:07.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:07.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:07.436]             base::sink(type = "output", split = FALSE)
[16:11:07.436]             base::close(...future.stdout)
[16:11:07.436]         }, add = TRUE)
[16:11:07.436]     }
[16:11:07.436]     ...future.frame <- base::sys.nframe()
[16:11:07.436]     ...future.conditions <- base::list()
[16:11:07.436]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:07.436]     if (FALSE) {
[16:11:07.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:07.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:07.436]     }
[16:11:07.436]     ...future.result <- base::tryCatch({
[16:11:07.436]         base::withCallingHandlers({
[16:11:07.436]             ...future.value <- base::withVisible(base::local({
[16:11:07.436]                 ...future.makeSendCondition <- local({
[16:11:07.436]                   sendCondition <- NULL
[16:11:07.436]                   function(frame = 1L) {
[16:11:07.436]                     if (is.function(sendCondition)) 
[16:11:07.436]                       return(sendCondition)
[16:11:07.436]                     ns <- getNamespace("parallel")
[16:11:07.436]                     if (exists("sendData", mode = "function", 
[16:11:07.436]                       envir = ns)) {
[16:11:07.436]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:07.436]                         envir = ns)
[16:11:07.436]                       envir <- sys.frame(frame)
[16:11:07.436]                       master <- NULL
[16:11:07.436]                       while (!identical(envir, .GlobalEnv) && 
[16:11:07.436]                         !identical(envir, emptyenv())) {
[16:11:07.436]                         if (exists("master", mode = "list", envir = envir, 
[16:11:07.436]                           inherits = FALSE)) {
[16:11:07.436]                           master <- get("master", mode = "list", 
[16:11:07.436]                             envir = envir, inherits = FALSE)
[16:11:07.436]                           if (inherits(master, c("SOCKnode", 
[16:11:07.436]                             "SOCK0node"))) {
[16:11:07.436]                             sendCondition <<- function(cond) {
[16:11:07.436]                               data <- list(type = "VALUE", value = cond, 
[16:11:07.436]                                 success = TRUE)
[16:11:07.436]                               parallel_sendData(master, data)
[16:11:07.436]                             }
[16:11:07.436]                             return(sendCondition)
[16:11:07.436]                           }
[16:11:07.436]                         }
[16:11:07.436]                         frame <- frame + 1L
[16:11:07.436]                         envir <- sys.frame(frame)
[16:11:07.436]                       }
[16:11:07.436]                     }
[16:11:07.436]                     sendCondition <<- function(cond) NULL
[16:11:07.436]                   }
[16:11:07.436]                 })
[16:11:07.436]                 withCallingHandlers({
[16:11:07.436]                   {
[16:11:07.436]                     do.call(function(...) {
[16:11:07.436]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.436]                       if (!identical(...future.globals.maxSize.org, 
[16:11:07.436]                         ...future.globals.maxSize)) {
[16:11:07.436]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.436]                         on.exit(options(oopts), add = TRUE)
[16:11:07.436]                       }
[16:11:07.436]                       {
[16:11:07.436]                         lapply(seq_along(...future.elements_ii), 
[16:11:07.436]                           FUN = function(jj) {
[16:11:07.436]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.436]                             ...future.FUN(...future.X_jj, ...)
[16:11:07.436]                           })
[16:11:07.436]                       }
[16:11:07.436]                     }, args = future.call.arguments)
[16:11:07.436]                   }
[16:11:07.436]                 }, immediateCondition = function(cond) {
[16:11:07.436]                   sendCondition <- ...future.makeSendCondition()
[16:11:07.436]                   sendCondition(cond)
[16:11:07.436]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.436]                   {
[16:11:07.436]                     inherits <- base::inherits
[16:11:07.436]                     invokeRestart <- base::invokeRestart
[16:11:07.436]                     is.null <- base::is.null
[16:11:07.436]                     muffled <- FALSE
[16:11:07.436]                     if (inherits(cond, "message")) {
[16:11:07.436]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:07.436]                       if (muffled) 
[16:11:07.436]                         invokeRestart("muffleMessage")
[16:11:07.436]                     }
[16:11:07.436]                     else if (inherits(cond, "warning")) {
[16:11:07.436]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:07.436]                       if (muffled) 
[16:11:07.436]                         invokeRestart("muffleWarning")
[16:11:07.436]                     }
[16:11:07.436]                     else if (inherits(cond, "condition")) {
[16:11:07.436]                       if (!is.null(pattern)) {
[16:11:07.436]                         computeRestarts <- base::computeRestarts
[16:11:07.436]                         grepl <- base::grepl
[16:11:07.436]                         restarts <- computeRestarts(cond)
[16:11:07.436]                         for (restart in restarts) {
[16:11:07.436]                           name <- restart$name
[16:11:07.436]                           if (is.null(name)) 
[16:11:07.436]                             next
[16:11:07.436]                           if (!grepl(pattern, name)) 
[16:11:07.436]                             next
[16:11:07.436]                           invokeRestart(restart)
[16:11:07.436]                           muffled <- TRUE
[16:11:07.436]                           break
[16:11:07.436]                         }
[16:11:07.436]                       }
[16:11:07.436]                     }
[16:11:07.436]                     invisible(muffled)
[16:11:07.436]                   }
[16:11:07.436]                   muffleCondition(cond)
[16:11:07.436]                 })
[16:11:07.436]             }))
[16:11:07.436]             future::FutureResult(value = ...future.value$value, 
[16:11:07.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.436]                   ...future.rng), globalenv = if (FALSE) 
[16:11:07.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:07.436]                     ...future.globalenv.names))
[16:11:07.436]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:07.436]         }, condition = base::local({
[16:11:07.436]             c <- base::c
[16:11:07.436]             inherits <- base::inherits
[16:11:07.436]             invokeRestart <- base::invokeRestart
[16:11:07.436]             length <- base::length
[16:11:07.436]             list <- base::list
[16:11:07.436]             seq.int <- base::seq.int
[16:11:07.436]             signalCondition <- base::signalCondition
[16:11:07.436]             sys.calls <- base::sys.calls
[16:11:07.436]             `[[` <- base::`[[`
[16:11:07.436]             `+` <- base::`+`
[16:11:07.436]             `<<-` <- base::`<<-`
[16:11:07.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:07.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:07.436]                   3L)]
[16:11:07.436]             }
[16:11:07.436]             function(cond) {
[16:11:07.436]                 is_error <- inherits(cond, "error")
[16:11:07.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:07.436]                   NULL)
[16:11:07.436]                 if (is_error) {
[16:11:07.436]                   sessionInformation <- function() {
[16:11:07.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:07.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:07.436]                       search = base::search(), system = base::Sys.info())
[16:11:07.436]                   }
[16:11:07.436]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:07.436]                     cond$call), session = sessionInformation(), 
[16:11:07.436]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:07.436]                   signalCondition(cond)
[16:11:07.436]                 }
[16:11:07.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:07.436]                 "immediateCondition"))) {
[16:11:07.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:07.436]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:07.436]                   if (TRUE && !signal) {
[16:11:07.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.436]                     {
[16:11:07.436]                       inherits <- base::inherits
[16:11:07.436]                       invokeRestart <- base::invokeRestart
[16:11:07.436]                       is.null <- base::is.null
[16:11:07.436]                       muffled <- FALSE
[16:11:07.436]                       if (inherits(cond, "message")) {
[16:11:07.436]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.436]                         if (muffled) 
[16:11:07.436]                           invokeRestart("muffleMessage")
[16:11:07.436]                       }
[16:11:07.436]                       else if (inherits(cond, "warning")) {
[16:11:07.436]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.436]                         if (muffled) 
[16:11:07.436]                           invokeRestart("muffleWarning")
[16:11:07.436]                       }
[16:11:07.436]                       else if (inherits(cond, "condition")) {
[16:11:07.436]                         if (!is.null(pattern)) {
[16:11:07.436]                           computeRestarts <- base::computeRestarts
[16:11:07.436]                           grepl <- base::grepl
[16:11:07.436]                           restarts <- computeRestarts(cond)
[16:11:07.436]                           for (restart in restarts) {
[16:11:07.436]                             name <- restart$name
[16:11:07.436]                             if (is.null(name)) 
[16:11:07.436]                               next
[16:11:07.436]                             if (!grepl(pattern, name)) 
[16:11:07.436]                               next
[16:11:07.436]                             invokeRestart(restart)
[16:11:07.436]                             muffled <- TRUE
[16:11:07.436]                             break
[16:11:07.436]                           }
[16:11:07.436]                         }
[16:11:07.436]                       }
[16:11:07.436]                       invisible(muffled)
[16:11:07.436]                     }
[16:11:07.436]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.436]                   }
[16:11:07.436]                 }
[16:11:07.436]                 else {
[16:11:07.436]                   if (TRUE) {
[16:11:07.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.436]                     {
[16:11:07.436]                       inherits <- base::inherits
[16:11:07.436]                       invokeRestart <- base::invokeRestart
[16:11:07.436]                       is.null <- base::is.null
[16:11:07.436]                       muffled <- FALSE
[16:11:07.436]                       if (inherits(cond, "message")) {
[16:11:07.436]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.436]                         if (muffled) 
[16:11:07.436]                           invokeRestart("muffleMessage")
[16:11:07.436]                       }
[16:11:07.436]                       else if (inherits(cond, "warning")) {
[16:11:07.436]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.436]                         if (muffled) 
[16:11:07.436]                           invokeRestart("muffleWarning")
[16:11:07.436]                       }
[16:11:07.436]                       else if (inherits(cond, "condition")) {
[16:11:07.436]                         if (!is.null(pattern)) {
[16:11:07.436]                           computeRestarts <- base::computeRestarts
[16:11:07.436]                           grepl <- base::grepl
[16:11:07.436]                           restarts <- computeRestarts(cond)
[16:11:07.436]                           for (restart in restarts) {
[16:11:07.436]                             name <- restart$name
[16:11:07.436]                             if (is.null(name)) 
[16:11:07.436]                               next
[16:11:07.436]                             if (!grepl(pattern, name)) 
[16:11:07.436]                               next
[16:11:07.436]                             invokeRestart(restart)
[16:11:07.436]                             muffled <- TRUE
[16:11:07.436]                             break
[16:11:07.436]                           }
[16:11:07.436]                         }
[16:11:07.436]                       }
[16:11:07.436]                       invisible(muffled)
[16:11:07.436]                     }
[16:11:07.436]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.436]                   }
[16:11:07.436]                 }
[16:11:07.436]             }
[16:11:07.436]         }))
[16:11:07.436]     }, error = function(ex) {
[16:11:07.436]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:07.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.436]                 ...future.rng), started = ...future.startTime, 
[16:11:07.436]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:07.436]             version = "1.8"), class = "FutureResult")
[16:11:07.436]     }, finally = {
[16:11:07.436]         if (!identical(...future.workdir, getwd())) 
[16:11:07.436]             setwd(...future.workdir)
[16:11:07.436]         {
[16:11:07.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:07.436]                 ...future.oldOptions$nwarnings <- NULL
[16:11:07.436]             }
[16:11:07.436]             base::options(...future.oldOptions)
[16:11:07.436]             if (.Platform$OS.type == "windows") {
[16:11:07.436]                 old_names <- names(...future.oldEnvVars)
[16:11:07.436]                 envs <- base::Sys.getenv()
[16:11:07.436]                 names <- names(envs)
[16:11:07.436]                 common <- intersect(names, old_names)
[16:11:07.436]                 added <- setdiff(names, old_names)
[16:11:07.436]                 removed <- setdiff(old_names, names)
[16:11:07.436]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:07.436]                   envs[common]]
[16:11:07.436]                 NAMES <- toupper(changed)
[16:11:07.436]                 args <- list()
[16:11:07.436]                 for (kk in seq_along(NAMES)) {
[16:11:07.436]                   name <- changed[[kk]]
[16:11:07.436]                   NAME <- NAMES[[kk]]
[16:11:07.436]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.436]                     next
[16:11:07.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.436]                 }
[16:11:07.436]                 NAMES <- toupper(added)
[16:11:07.436]                 for (kk in seq_along(NAMES)) {
[16:11:07.436]                   name <- added[[kk]]
[16:11:07.436]                   NAME <- NAMES[[kk]]
[16:11:07.436]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.436]                     next
[16:11:07.436]                   args[[name]] <- ""
[16:11:07.436]                 }
[16:11:07.436]                 NAMES <- toupper(removed)
[16:11:07.436]                 for (kk in seq_along(NAMES)) {
[16:11:07.436]                   name <- removed[[kk]]
[16:11:07.436]                   NAME <- NAMES[[kk]]
[16:11:07.436]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.436]                     next
[16:11:07.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.436]                 }
[16:11:07.436]                 if (length(args) > 0) 
[16:11:07.436]                   base::do.call(base::Sys.setenv, args = args)
[16:11:07.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:07.436]             }
[16:11:07.436]             else {
[16:11:07.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:07.436]             }
[16:11:07.436]             {
[16:11:07.436]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:07.436]                   0L) {
[16:11:07.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:07.436]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:07.436]                   base::options(opts)
[16:11:07.436]                 }
[16:11:07.436]                 {
[16:11:07.436]                   {
[16:11:07.436]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:07.436]                     NULL
[16:11:07.436]                   }
[16:11:07.436]                   options(future.plan = NULL)
[16:11:07.436]                   if (is.na(NA_character_)) 
[16:11:07.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:07.436]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:07.436]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:07.436]                     envir = parent.frame()) 
[16:11:07.436]                   {
[16:11:07.436]                     if (is.function(workers)) 
[16:11:07.436]                       workers <- workers()
[16:11:07.436]                     workers <- structure(as.integer(workers), 
[16:11:07.436]                       class = class(workers))
[16:11:07.436]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:07.436]                       workers >= 1)
[16:11:07.436]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:07.436]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:07.436]                     }
[16:11:07.436]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:07.436]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:07.436]                       envir = envir)
[16:11:07.436]                     if (!future$lazy) 
[16:11:07.436]                       future <- run(future)
[16:11:07.436]                     invisible(future)
[16:11:07.436]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:07.436]                 }
[16:11:07.436]             }
[16:11:07.436]         }
[16:11:07.436]     })
[16:11:07.436]     if (TRUE) {
[16:11:07.436]         base::sink(type = "output", split = FALSE)
[16:11:07.436]         if (TRUE) {
[16:11:07.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:07.436]         }
[16:11:07.436]         else {
[16:11:07.436]             ...future.result["stdout"] <- base::list(NULL)
[16:11:07.436]         }
[16:11:07.436]         base::close(...future.stdout)
[16:11:07.436]         ...future.stdout <- NULL
[16:11:07.436]     }
[16:11:07.436]     ...future.result$conditions <- ...future.conditions
[16:11:07.436]     ...future.result$finished <- base::Sys.time()
[16:11:07.436]     ...future.result
[16:11:07.436] }
[16:11:07.439] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[16:11:07.439] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:07.480] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:07.480] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[16:11:07.524] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[16:11:07.524] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:07.525] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:07.525] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:07.568] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:07.568] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:07.612] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:07.612] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:07.613] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.613] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:07.613] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:07.614] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:07.614] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.614] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[16:11:07.615] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[16:11:07.615] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:07.615] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.615] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:07.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.616] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[16:11:07.617] MultisessionFuture started
[16:11:07.617] - Launch lazy future ... done
[16:11:07.617] run() for ‘MultisessionFuture’ ... done
[16:11:07.617] Created future:
[16:11:07.617] MultisessionFuture:
[16:11:07.617] Label: ‘future_vapply-1’
[16:11:07.617] Expression:
[16:11:07.617] {
[16:11:07.617]     do.call(function(...) {
[16:11:07.617]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.617]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.617]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.617]             on.exit(options(oopts), add = TRUE)
[16:11:07.617]         }
[16:11:07.617]         {
[16:11:07.617]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.617]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.617]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.617]             })
[16:11:07.617]         }
[16:11:07.617]     }, args = future.call.arguments)
[16:11:07.617] }
[16:11:07.617] Lazy evaluation: FALSE
[16:11:07.617] Asynchronous evaluation: TRUE
[16:11:07.617] Local evaluation: TRUE
[16:11:07.617] Environment: R_GlobalEnv
[16:11:07.617] Capture standard output: TRUE
[16:11:07.617] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:07.617] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:07.617] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:07.617] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:07.617] Resolved: FALSE
[16:11:07.617] Value: <not collected>
[16:11:07.617] Conditions captured: <none>
[16:11:07.617] Early signaling: FALSE
[16:11:07.617] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:07.617] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.630] Chunk #1 of 2 ... DONE
[16:11:07.630] Chunk #2 of 2 ...
[16:11:07.630]  - Finding globals in 'X' for chunk #2 ...
[16:11:07.630] getGlobalsAndPackages() ...
[16:11:07.630] Searching for globals...
[16:11:07.630] 
[16:11:07.630] Searching for globals ... DONE
[16:11:07.631] - globals: [0] <none>
[16:11:07.631] getGlobalsAndPackages() ... DONE
[16:11:07.631]    + additional globals found: [n=0] 
[16:11:07.631]    + additional namespaces needed: [n=0] 
[16:11:07.631]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:07.631]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[16:11:07.631]  - seeds: <none>
[16:11:07.631] getGlobalsAndPackages() ...
[16:11:07.631] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.631] Resolving globals: FALSE
[16:11:07.632] Tweak future expression to call with '...' arguments ...
[16:11:07.632] {
[16:11:07.632]     do.call(function(...) {
[16:11:07.632]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.632]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.632]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.632]             on.exit(options(oopts), add = TRUE)
[16:11:07.632]         }
[16:11:07.632]         {
[16:11:07.632]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.632]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.632]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.632]             })
[16:11:07.632]         }
[16:11:07.632]     }, args = future.call.arguments)
[16:11:07.632] }
[16:11:07.632] Tweak future expression to call with '...' arguments ... DONE
[16:11:07.633] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.633] - packages: [2] ‘stats’, ‘future.apply’
[16:11:07.633] getGlobalsAndPackages() ... DONE
[16:11:07.633] run() for ‘Future’ ...
[16:11:07.633] - state: ‘created’
[16:11:07.633] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:07.649] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:07.649]   - Field: ‘node’
[16:11:07.649]   - Field: ‘label’
[16:11:07.649]   - Field: ‘local’
[16:11:07.649]   - Field: ‘owner’
[16:11:07.650]   - Field: ‘envir’
[16:11:07.650]   - Field: ‘workers’
[16:11:07.650]   - Field: ‘packages’
[16:11:07.650]   - Field: ‘gc’
[16:11:07.650]   - Field: ‘conditions’
[16:11:07.650]   - Field: ‘persistent’
[16:11:07.650]   - Field: ‘expr’
[16:11:07.650]   - Field: ‘uuid’
[16:11:07.650]   - Field: ‘seed’
[16:11:07.650]   - Field: ‘version’
[16:11:07.650]   - Field: ‘result’
[16:11:07.651]   - Field: ‘asynchronous’
[16:11:07.651]   - Field: ‘calls’
[16:11:07.651]   - Field: ‘globals’
[16:11:07.651]   - Field: ‘stdout’
[16:11:07.651]   - Field: ‘earlySignal’
[16:11:07.651]   - Field: ‘lazy’
[16:11:07.651]   - Field: ‘state’
[16:11:07.651] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:07.651] - Launch lazy future ...
[16:11:07.652] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[16:11:07.652] Packages needed by future strategies (n = 0): <none>
[16:11:07.652] {
[16:11:07.652]     {
[16:11:07.652]         {
[16:11:07.652]             ...future.startTime <- base::Sys.time()
[16:11:07.652]             {
[16:11:07.652]                 {
[16:11:07.652]                   {
[16:11:07.652]                     {
[16:11:07.652]                       {
[16:11:07.652]                         base::local({
[16:11:07.652]                           has_future <- base::requireNamespace("future", 
[16:11:07.652]                             quietly = TRUE)
[16:11:07.652]                           if (has_future) {
[16:11:07.652]                             ns <- base::getNamespace("future")
[16:11:07.652]                             version <- ns[[".package"]][["version"]]
[16:11:07.652]                             if (is.null(version)) 
[16:11:07.652]                               version <- utils::packageVersion("future")
[16:11:07.652]                           }
[16:11:07.652]                           else {
[16:11:07.652]                             version <- NULL
[16:11:07.652]                           }
[16:11:07.652]                           if (!has_future || version < "1.8.0") {
[16:11:07.652]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:07.652]                               "", base::R.version$version.string), 
[16:11:07.652]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:07.652]                                 base::R.version$platform, 8 * 
[16:11:07.652]                                   base::.Machine$sizeof.pointer), 
[16:11:07.652]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:07.652]                                 "release", "version")], collapse = " "), 
[16:11:07.652]                               hostname = base::Sys.info()[["nodename"]])
[16:11:07.652]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:07.652]                               info)
[16:11:07.652]                             info <- base::paste(info, collapse = "; ")
[16:11:07.652]                             if (!has_future) {
[16:11:07.652]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:07.652]                                 info)
[16:11:07.652]                             }
[16:11:07.652]                             else {
[16:11:07.652]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:07.652]                                 info, version)
[16:11:07.652]                             }
[16:11:07.652]                             base::stop(msg)
[16:11:07.652]                           }
[16:11:07.652]                         })
[16:11:07.652]                       }
[16:11:07.652]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:07.652]                       base::options(mc.cores = 1L)
[16:11:07.652]                     }
[16:11:07.652]                     base::local({
[16:11:07.652]                       for (pkg in c("stats", "future.apply")) {
[16:11:07.652]                         base::loadNamespace(pkg)
[16:11:07.652]                         base::library(pkg, character.only = TRUE)
[16:11:07.652]                       }
[16:11:07.652]                     })
[16:11:07.652]                   }
[16:11:07.652]                   options(future.plan = NULL)
[16:11:07.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:07.652]                 }
[16:11:07.652]                 ...future.workdir <- getwd()
[16:11:07.652]             }
[16:11:07.652]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:07.652]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:07.652]         }
[16:11:07.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:07.652]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[16:11:07.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:07.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:07.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:07.652]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:07.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:07.652]             base::names(...future.oldOptions))
[16:11:07.652]     }
[16:11:07.652]     if (FALSE) {
[16:11:07.652]     }
[16:11:07.652]     else {
[16:11:07.652]         if (TRUE) {
[16:11:07.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:07.652]                 open = "w")
[16:11:07.652]         }
[16:11:07.652]         else {
[16:11:07.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:07.652]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:07.652]         }
[16:11:07.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:07.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:07.652]             base::sink(type = "output", split = FALSE)
[16:11:07.652]             base::close(...future.stdout)
[16:11:07.652]         }, add = TRUE)
[16:11:07.652]     }
[16:11:07.652]     ...future.frame <- base::sys.nframe()
[16:11:07.652]     ...future.conditions <- base::list()
[16:11:07.652]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:07.652]     if (FALSE) {
[16:11:07.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:07.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:07.652]     }
[16:11:07.652]     ...future.result <- base::tryCatch({
[16:11:07.652]         base::withCallingHandlers({
[16:11:07.652]             ...future.value <- base::withVisible(base::local({
[16:11:07.652]                 ...future.makeSendCondition <- local({
[16:11:07.652]                   sendCondition <- NULL
[16:11:07.652]                   function(frame = 1L) {
[16:11:07.652]                     if (is.function(sendCondition)) 
[16:11:07.652]                       return(sendCondition)
[16:11:07.652]                     ns <- getNamespace("parallel")
[16:11:07.652]                     if (exists("sendData", mode = "function", 
[16:11:07.652]                       envir = ns)) {
[16:11:07.652]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:07.652]                         envir = ns)
[16:11:07.652]                       envir <- sys.frame(frame)
[16:11:07.652]                       master <- NULL
[16:11:07.652]                       while (!identical(envir, .GlobalEnv) && 
[16:11:07.652]                         !identical(envir, emptyenv())) {
[16:11:07.652]                         if (exists("master", mode = "list", envir = envir, 
[16:11:07.652]                           inherits = FALSE)) {
[16:11:07.652]                           master <- get("master", mode = "list", 
[16:11:07.652]                             envir = envir, inherits = FALSE)
[16:11:07.652]                           if (inherits(master, c("SOCKnode", 
[16:11:07.652]                             "SOCK0node"))) {
[16:11:07.652]                             sendCondition <<- function(cond) {
[16:11:07.652]                               data <- list(type = "VALUE", value = cond, 
[16:11:07.652]                                 success = TRUE)
[16:11:07.652]                               parallel_sendData(master, data)
[16:11:07.652]                             }
[16:11:07.652]                             return(sendCondition)
[16:11:07.652]                           }
[16:11:07.652]                         }
[16:11:07.652]                         frame <- frame + 1L
[16:11:07.652]                         envir <- sys.frame(frame)
[16:11:07.652]                       }
[16:11:07.652]                     }
[16:11:07.652]                     sendCondition <<- function(cond) NULL
[16:11:07.652]                   }
[16:11:07.652]                 })
[16:11:07.652]                 withCallingHandlers({
[16:11:07.652]                   {
[16:11:07.652]                     do.call(function(...) {
[16:11:07.652]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.652]                       if (!identical(...future.globals.maxSize.org, 
[16:11:07.652]                         ...future.globals.maxSize)) {
[16:11:07.652]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.652]                         on.exit(options(oopts), add = TRUE)
[16:11:07.652]                       }
[16:11:07.652]                       {
[16:11:07.652]                         lapply(seq_along(...future.elements_ii), 
[16:11:07.652]                           FUN = function(jj) {
[16:11:07.652]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.652]                             ...future.FUN(...future.X_jj, ...)
[16:11:07.652]                           })
[16:11:07.652]                       }
[16:11:07.652]                     }, args = future.call.arguments)
[16:11:07.652]                   }
[16:11:07.652]                 }, immediateCondition = function(cond) {
[16:11:07.652]                   sendCondition <- ...future.makeSendCondition()
[16:11:07.652]                   sendCondition(cond)
[16:11:07.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.652]                   {
[16:11:07.652]                     inherits <- base::inherits
[16:11:07.652]                     invokeRestart <- base::invokeRestart
[16:11:07.652]                     is.null <- base::is.null
[16:11:07.652]                     muffled <- FALSE
[16:11:07.652]                     if (inherits(cond, "message")) {
[16:11:07.652]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:07.652]                       if (muffled) 
[16:11:07.652]                         invokeRestart("muffleMessage")
[16:11:07.652]                     }
[16:11:07.652]                     else if (inherits(cond, "warning")) {
[16:11:07.652]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:07.652]                       if (muffled) 
[16:11:07.652]                         invokeRestart("muffleWarning")
[16:11:07.652]                     }
[16:11:07.652]                     else if (inherits(cond, "condition")) {
[16:11:07.652]                       if (!is.null(pattern)) {
[16:11:07.652]                         computeRestarts <- base::computeRestarts
[16:11:07.652]                         grepl <- base::grepl
[16:11:07.652]                         restarts <- computeRestarts(cond)
[16:11:07.652]                         for (restart in restarts) {
[16:11:07.652]                           name <- restart$name
[16:11:07.652]                           if (is.null(name)) 
[16:11:07.652]                             next
[16:11:07.652]                           if (!grepl(pattern, name)) 
[16:11:07.652]                             next
[16:11:07.652]                           invokeRestart(restart)
[16:11:07.652]                           muffled <- TRUE
[16:11:07.652]                           break
[16:11:07.652]                         }
[16:11:07.652]                       }
[16:11:07.652]                     }
[16:11:07.652]                     invisible(muffled)
[16:11:07.652]                   }
[16:11:07.652]                   muffleCondition(cond)
[16:11:07.652]                 })
[16:11:07.652]             }))
[16:11:07.652]             future::FutureResult(value = ...future.value$value, 
[16:11:07.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.652]                   ...future.rng), globalenv = if (FALSE) 
[16:11:07.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:07.652]                     ...future.globalenv.names))
[16:11:07.652]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:07.652]         }, condition = base::local({
[16:11:07.652]             c <- base::c
[16:11:07.652]             inherits <- base::inherits
[16:11:07.652]             invokeRestart <- base::invokeRestart
[16:11:07.652]             length <- base::length
[16:11:07.652]             list <- base::list
[16:11:07.652]             seq.int <- base::seq.int
[16:11:07.652]             signalCondition <- base::signalCondition
[16:11:07.652]             sys.calls <- base::sys.calls
[16:11:07.652]             `[[` <- base::`[[`
[16:11:07.652]             `+` <- base::`+`
[16:11:07.652]             `<<-` <- base::`<<-`
[16:11:07.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:07.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:07.652]                   3L)]
[16:11:07.652]             }
[16:11:07.652]             function(cond) {
[16:11:07.652]                 is_error <- inherits(cond, "error")
[16:11:07.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:07.652]                   NULL)
[16:11:07.652]                 if (is_error) {
[16:11:07.652]                   sessionInformation <- function() {
[16:11:07.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:07.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:07.652]                       search = base::search(), system = base::Sys.info())
[16:11:07.652]                   }
[16:11:07.652]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:07.652]                     cond$call), session = sessionInformation(), 
[16:11:07.652]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:07.652]                   signalCondition(cond)
[16:11:07.652]                 }
[16:11:07.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:07.652]                 "immediateCondition"))) {
[16:11:07.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:07.652]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:07.652]                   if (TRUE && !signal) {
[16:11:07.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.652]                     {
[16:11:07.652]                       inherits <- base::inherits
[16:11:07.652]                       invokeRestart <- base::invokeRestart
[16:11:07.652]                       is.null <- base::is.null
[16:11:07.652]                       muffled <- FALSE
[16:11:07.652]                       if (inherits(cond, "message")) {
[16:11:07.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.652]                         if (muffled) 
[16:11:07.652]                           invokeRestart("muffleMessage")
[16:11:07.652]                       }
[16:11:07.652]                       else if (inherits(cond, "warning")) {
[16:11:07.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.652]                         if (muffled) 
[16:11:07.652]                           invokeRestart("muffleWarning")
[16:11:07.652]                       }
[16:11:07.652]                       else if (inherits(cond, "condition")) {
[16:11:07.652]                         if (!is.null(pattern)) {
[16:11:07.652]                           computeRestarts <- base::computeRestarts
[16:11:07.652]                           grepl <- base::grepl
[16:11:07.652]                           restarts <- computeRestarts(cond)
[16:11:07.652]                           for (restart in restarts) {
[16:11:07.652]                             name <- restart$name
[16:11:07.652]                             if (is.null(name)) 
[16:11:07.652]                               next
[16:11:07.652]                             if (!grepl(pattern, name)) 
[16:11:07.652]                               next
[16:11:07.652]                             invokeRestart(restart)
[16:11:07.652]                             muffled <- TRUE
[16:11:07.652]                             break
[16:11:07.652]                           }
[16:11:07.652]                         }
[16:11:07.652]                       }
[16:11:07.652]                       invisible(muffled)
[16:11:07.652]                     }
[16:11:07.652]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.652]                   }
[16:11:07.652]                 }
[16:11:07.652]                 else {
[16:11:07.652]                   if (TRUE) {
[16:11:07.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.652]                     {
[16:11:07.652]                       inherits <- base::inherits
[16:11:07.652]                       invokeRestart <- base::invokeRestart
[16:11:07.652]                       is.null <- base::is.null
[16:11:07.652]                       muffled <- FALSE
[16:11:07.652]                       if (inherits(cond, "message")) {
[16:11:07.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.652]                         if (muffled) 
[16:11:07.652]                           invokeRestart("muffleMessage")
[16:11:07.652]                       }
[16:11:07.652]                       else if (inherits(cond, "warning")) {
[16:11:07.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.652]                         if (muffled) 
[16:11:07.652]                           invokeRestart("muffleWarning")
[16:11:07.652]                       }
[16:11:07.652]                       else if (inherits(cond, "condition")) {
[16:11:07.652]                         if (!is.null(pattern)) {
[16:11:07.652]                           computeRestarts <- base::computeRestarts
[16:11:07.652]                           grepl <- base::grepl
[16:11:07.652]                           restarts <- computeRestarts(cond)
[16:11:07.652]                           for (restart in restarts) {
[16:11:07.652]                             name <- restart$name
[16:11:07.652]                             if (is.null(name)) 
[16:11:07.652]                               next
[16:11:07.652]                             if (!grepl(pattern, name)) 
[16:11:07.652]                               next
[16:11:07.652]                             invokeRestart(restart)
[16:11:07.652]                             muffled <- TRUE
[16:11:07.652]                             break
[16:11:07.652]                           }
[16:11:07.652]                         }
[16:11:07.652]                       }
[16:11:07.652]                       invisible(muffled)
[16:11:07.652]                     }
[16:11:07.652]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.652]                   }
[16:11:07.652]                 }
[16:11:07.652]             }
[16:11:07.652]         }))
[16:11:07.652]     }, error = function(ex) {
[16:11:07.652]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:07.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.652]                 ...future.rng), started = ...future.startTime, 
[16:11:07.652]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:07.652]             version = "1.8"), class = "FutureResult")
[16:11:07.652]     }, finally = {
[16:11:07.652]         if (!identical(...future.workdir, getwd())) 
[16:11:07.652]             setwd(...future.workdir)
[16:11:07.652]         {
[16:11:07.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:07.652]                 ...future.oldOptions$nwarnings <- NULL
[16:11:07.652]             }
[16:11:07.652]             base::options(...future.oldOptions)
[16:11:07.652]             if (.Platform$OS.type == "windows") {
[16:11:07.652]                 old_names <- names(...future.oldEnvVars)
[16:11:07.652]                 envs <- base::Sys.getenv()
[16:11:07.652]                 names <- names(envs)
[16:11:07.652]                 common <- intersect(names, old_names)
[16:11:07.652]                 added <- setdiff(names, old_names)
[16:11:07.652]                 removed <- setdiff(old_names, names)
[16:11:07.652]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:07.652]                   envs[common]]
[16:11:07.652]                 NAMES <- toupper(changed)
[16:11:07.652]                 args <- list()
[16:11:07.652]                 for (kk in seq_along(NAMES)) {
[16:11:07.652]                   name <- changed[[kk]]
[16:11:07.652]                   NAME <- NAMES[[kk]]
[16:11:07.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.652]                     next
[16:11:07.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.652]                 }
[16:11:07.652]                 NAMES <- toupper(added)
[16:11:07.652]                 for (kk in seq_along(NAMES)) {
[16:11:07.652]                   name <- added[[kk]]
[16:11:07.652]                   NAME <- NAMES[[kk]]
[16:11:07.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.652]                     next
[16:11:07.652]                   args[[name]] <- ""
[16:11:07.652]                 }
[16:11:07.652]                 NAMES <- toupper(removed)
[16:11:07.652]                 for (kk in seq_along(NAMES)) {
[16:11:07.652]                   name <- removed[[kk]]
[16:11:07.652]                   NAME <- NAMES[[kk]]
[16:11:07.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.652]                     next
[16:11:07.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.652]                 }
[16:11:07.652]                 if (length(args) > 0) 
[16:11:07.652]                   base::do.call(base::Sys.setenv, args = args)
[16:11:07.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:07.652]             }
[16:11:07.652]             else {
[16:11:07.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:07.652]             }
[16:11:07.652]             {
[16:11:07.652]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:07.652]                   0L) {
[16:11:07.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:07.652]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:07.652]                   base::options(opts)
[16:11:07.652]                 }
[16:11:07.652]                 {
[16:11:07.652]                   {
[16:11:07.652]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:07.652]                     NULL
[16:11:07.652]                   }
[16:11:07.652]                   options(future.plan = NULL)
[16:11:07.652]                   if (is.na(NA_character_)) 
[16:11:07.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:07.652]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:07.652]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:07.652]                     envir = parent.frame()) 
[16:11:07.652]                   {
[16:11:07.652]                     if (is.function(workers)) 
[16:11:07.652]                       workers <- workers()
[16:11:07.652]                     workers <- structure(as.integer(workers), 
[16:11:07.652]                       class = class(workers))
[16:11:07.652]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:07.652]                       workers >= 1)
[16:11:07.652]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:07.652]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:07.652]                     }
[16:11:07.652]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:07.652]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:07.652]                       envir = envir)
[16:11:07.652]                     if (!future$lazy) 
[16:11:07.652]                       future <- run(future)
[16:11:07.652]                     invisible(future)
[16:11:07.652]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:07.652]                 }
[16:11:07.652]             }
[16:11:07.652]         }
[16:11:07.652]     })
[16:11:07.652]     if (TRUE) {
[16:11:07.652]         base::sink(type = "output", split = FALSE)
[16:11:07.652]         if (TRUE) {
[16:11:07.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:07.652]         }
[16:11:07.652]         else {
[16:11:07.652]             ...future.result["stdout"] <- base::list(NULL)
[16:11:07.652]         }
[16:11:07.652]         base::close(...future.stdout)
[16:11:07.652]         ...future.stdout <- NULL
[16:11:07.652]     }
[16:11:07.652]     ...future.result$conditions <- ...future.conditions
[16:11:07.652]     ...future.result$finished <- base::Sys.time()
[16:11:07.652]     ...future.result
[16:11:07.652] }
[16:11:07.655] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[16:11:07.655] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:07.700] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:07.700] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[16:11:07.744] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[16:11:07.744] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:07.745] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:07.745] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:07.788] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:07.788] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:07.832] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:07.832] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:07.833] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.833] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:07.833] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:07.834] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:07.834] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.834] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[16:11:07.835] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[16:11:07.835] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:07.835] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.835] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:07.836] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.836] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[16:11:07.836] MultisessionFuture started
[16:11:07.836] - Launch lazy future ... done
[16:11:07.836] run() for ‘MultisessionFuture’ ... done
[16:11:07.837] Created future:
[16:11:07.837] MultisessionFuture:
[16:11:07.837] Label: ‘future_vapply-2’
[16:11:07.837] Expression:
[16:11:07.837] {
[16:11:07.837]     do.call(function(...) {
[16:11:07.837]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.837]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.837]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.837]             on.exit(options(oopts), add = TRUE)
[16:11:07.837]         }
[16:11:07.837]         {
[16:11:07.837]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.837]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.837]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.837]             })
[16:11:07.837]         }
[16:11:07.837]     }, args = future.call.arguments)
[16:11:07.837] }
[16:11:07.837] Lazy evaluation: FALSE
[16:11:07.837] Asynchronous evaluation: TRUE
[16:11:07.837] Local evaluation: TRUE
[16:11:07.837] Environment: R_GlobalEnv
[16:11:07.837] Capture standard output: TRUE
[16:11:07.837] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:07.837] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:07.837] Packages: 2 packages (‘stats’, ‘future.apply’)
[16:11:07.837] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:07.837] Resolved: FALSE
[16:11:07.837] Value: <not collected>
[16:11:07.837] Conditions captured: <none>
[16:11:07.837] Early signaling: FALSE
[16:11:07.837] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:07.837] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.848] Chunk #2 of 2 ... DONE
[16:11:07.849] Launching 2 futures (chunks) ... DONE
[16:11:07.849] Resolving 2 futures (chunks) ...
[16:11:07.849] resolve() on list ...
[16:11:07.849]  recursive: 0
[16:11:07.849]  length: 2
[16:11:07.849] 
[16:11:07.849] receiveMessageFromWorker() for ClusterFuture ...
[16:11:07.850] - Validating connection of MultisessionFuture
[16:11:07.850] - received message: FutureResult
[16:11:07.850] - Received FutureResult
[16:11:07.850] - Erased future from FutureRegistry
[16:11:07.850] result() for ClusterFuture ...
[16:11:07.850] - result already collected: FutureResult
[16:11:07.850] result() for ClusterFuture ... done
[16:11:07.850] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:07.850] Future #1
[16:11:07.851] result() for ClusterFuture ...
[16:11:07.851] - result already collected: FutureResult
[16:11:07.851] result() for ClusterFuture ... done
[16:11:07.851] result() for ClusterFuture ...
[16:11:07.851] - result already collected: FutureResult
[16:11:07.851] result() for ClusterFuture ... done
[16:11:07.851] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:07.851] - nx: 2
[16:11:07.851] - relay: TRUE
[16:11:07.851] - stdout: TRUE
[16:11:07.851] - signal: TRUE
[16:11:07.852] - resignal: FALSE
[16:11:07.852] - force: TRUE
[16:11:07.852] - relayed: [n=2] FALSE, FALSE
[16:11:07.852] - queued futures: [n=2] FALSE, FALSE
[16:11:07.852]  - until=1
[16:11:07.852]  - relaying element #1
[16:11:07.852] result() for ClusterFuture ...
[16:11:07.852] - result already collected: FutureResult
[16:11:07.852] result() for ClusterFuture ... done
[16:11:07.852] result() for ClusterFuture ...
[16:11:07.852] - result already collected: FutureResult
[16:11:07.853] result() for ClusterFuture ... done
[16:11:07.853] result() for ClusterFuture ...
[16:11:07.853] - result already collected: FutureResult
[16:11:07.853] result() for ClusterFuture ... done
[16:11:07.853] result() for ClusterFuture ...
[16:11:07.853] - result already collected: FutureResult
[16:11:07.853] result() for ClusterFuture ... done
[16:11:07.853] - relayed: [n=2] TRUE, FALSE
[16:11:07.853] - queued futures: [n=2] TRUE, FALSE
[16:11:07.853] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:07.853]  length: 1 (resolved future 1)
[16:11:07.895] receiveMessageFromWorker() for ClusterFuture ...
[16:11:07.895] - Validating connection of MultisessionFuture
[16:11:07.895] - received message: FutureResult
[16:11:07.896] - Received FutureResult
[16:11:07.896] - Erased future from FutureRegistry
[16:11:07.896] result() for ClusterFuture ...
[16:11:07.896] - result already collected: FutureResult
[16:11:07.896] result() for ClusterFuture ... done
[16:11:07.896] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:07.896] Future #2
[16:11:07.896] result() for ClusterFuture ...
[16:11:07.896] - result already collected: FutureResult
[16:11:07.897] result() for ClusterFuture ... done
[16:11:07.897] result() for ClusterFuture ...
[16:11:07.897] - result already collected: FutureResult
[16:11:07.897] result() for ClusterFuture ... done
[16:11:07.897] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:07.897] - nx: 2
[16:11:07.897] - relay: TRUE
[16:11:07.897] - stdout: TRUE
[16:11:07.897] - signal: TRUE
[16:11:07.897] - resignal: FALSE
[16:11:07.897] - force: TRUE
[16:11:07.897] - relayed: [n=2] TRUE, FALSE
[16:11:07.898] - queued futures: [n=2] TRUE, FALSE
[16:11:07.898]  - until=2
[16:11:07.898]  - relaying element #2
[16:11:07.898] result() for ClusterFuture ...
[16:11:07.898] - result already collected: FutureResult
[16:11:07.898] result() for ClusterFuture ... done
[16:11:07.898] result() for ClusterFuture ...
[16:11:07.898] - result already collected: FutureResult
[16:11:07.898] result() for ClusterFuture ... done
[16:11:07.898] result() for ClusterFuture ...
[16:11:07.898] - result already collected: FutureResult
[16:11:07.899] result() for ClusterFuture ... done
[16:11:07.899] result() for ClusterFuture ...
[16:11:07.899] - result already collected: FutureResult
[16:11:07.899] result() for ClusterFuture ... done
[16:11:07.899] - relayed: [n=2] TRUE, TRUE
[16:11:07.899] - queued futures: [n=2] TRUE, TRUE
[16:11:07.899] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:07.899]  length: 0 (resolved future 2)
[16:11:07.899] Relaying remaining futures
[16:11:07.899] signalConditionsASAP(NULL, pos=0) ...
[16:11:07.899] - nx: 2
[16:11:07.900] - relay: TRUE
[16:11:07.900] - stdout: TRUE
[16:11:07.900] - signal: TRUE
[16:11:07.900] - resignal: FALSE
[16:11:07.900] - force: TRUE
[16:11:07.900] - relayed: [n=2] TRUE, TRUE
[16:11:07.900] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:07.900] - relayed: [n=2] TRUE, TRUE
[16:11:07.900] - queued futures: [n=2] TRUE, TRUE
[16:11:07.900] signalConditionsASAP(NULL, pos=0) ... done
[16:11:07.900] resolve() on list ... DONE
[16:11:07.901] result() for ClusterFuture ...
[16:11:07.901] - result already collected: FutureResult
[16:11:07.901] result() for ClusterFuture ... done
[16:11:07.901] result() for ClusterFuture ...
[16:11:07.901] - result already collected: FutureResult
[16:11:07.901] result() for ClusterFuture ... done
[16:11:07.901] result() for ClusterFuture ...
[16:11:07.901] - result already collected: FutureResult
[16:11:07.901] result() for ClusterFuture ... done
[16:11:07.901] result() for ClusterFuture ...
[16:11:07.901] - result already collected: FutureResult
[16:11:07.902] result() for ClusterFuture ... done
[16:11:07.902]  - Number of value chunks collected: 2
[16:11:07.902] Resolving 2 futures (chunks) ... DONE
[16:11:07.902] Reducing values from 2 chunks ...
[16:11:07.902]  - Number of values collected after concatenation: 7
[16:11:07.902]  - Number of values expected: 7
[16:11:07.902] Reducing values from 2 chunks ... DONE
[16:11:07.902] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[16:11:07.904] future_lapply() ...
[16:11:07.908] Number of chunks: 2
[16:11:07.908] getGlobalsAndPackagesXApply() ...
[16:11:07.908]  - future.globals: TRUE
[16:11:07.908] getGlobalsAndPackages() ...
[16:11:07.908] Searching for globals...
[16:11:07.910] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[16:11:07.910] Searching for globals ... DONE
[16:11:07.910] Resolving globals: FALSE
[16:11:07.910] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[16:11:07.911] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[16:11:07.911] - globals: [1] ‘FUN’
[16:11:07.911] 
[16:11:07.911] getGlobalsAndPackages() ... DONE
[16:11:07.911]  - globals found/used: [n=1] ‘FUN’
[16:11:07.911]  - needed namespaces: [n=0] 
[16:11:07.911] Finding globals ... DONE
[16:11:07.911]  - use_args: TRUE
[16:11:07.911]  - Getting '...' globals ...
[16:11:07.912] resolve() on list ...
[16:11:07.912]  recursive: 0
[16:11:07.912]  length: 1
[16:11:07.912]  elements: ‘...’
[16:11:07.912]  length: 0 (resolved future 1)
[16:11:07.912] resolve() on list ... DONE
[16:11:07.912]    - '...' content: [n=1] ‘y’
[16:11:07.912] List of 1
[16:11:07.912]  $ ...:List of 1
[16:11:07.912]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:07.912]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:07.912]  - attr(*, "where")=List of 1
[16:11:07.912]   ..$ ...:<environment: 0x561e8b553358> 
[16:11:07.912]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:07.912]  - attr(*, "resolved")= logi TRUE
[16:11:07.912]  - attr(*, "total_size")= num NA
[16:11:07.915]  - Getting '...' globals ... DONE
[16:11:07.916] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:11:07.916] List of 2
[16:11:07.916]  $ ...future.FUN:function (x, y)  
[16:11:07.916]  $ ...          :List of 1
[16:11:07.916]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:07.916]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:07.916]  - attr(*, "where")=List of 2
[16:11:07.916]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:07.916]   ..$ ...          :<environment: 0x561e8b553358> 
[16:11:07.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:07.916]  - attr(*, "resolved")= logi FALSE
[16:11:07.916]  - attr(*, "total_size")= num 4264
[16:11:07.919] Packages to be attached in all futures: [n=0] 
[16:11:07.919] getGlobalsAndPackagesXApply() ... DONE
[16:11:07.919] Number of futures (= number of chunks): 2
[16:11:07.919] Launching 2 futures (chunks) ...
[16:11:07.919] Chunk #1 of 2 ...
[16:11:07.919]  - Finding globals in 'X' for chunk #1 ...
[16:11:07.920] getGlobalsAndPackages() ...
[16:11:07.920] Searching for globals...
[16:11:07.920] 
[16:11:07.920] Searching for globals ... DONE
[16:11:07.920] - globals: [0] <none>
[16:11:07.920] getGlobalsAndPackages() ... DONE
[16:11:07.920]    + additional globals found: [n=0] 
[16:11:07.920]    + additional namespaces needed: [n=0] 
[16:11:07.920]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:07.921]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:07.921]  - seeds: <none>
[16:11:07.921] getGlobalsAndPackages() ...
[16:11:07.921] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.921] Resolving globals: FALSE
[16:11:07.921] Tweak future expression to call with '...' arguments ...
[16:11:07.921] {
[16:11:07.921]     do.call(function(...) {
[16:11:07.921]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.921]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.921]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.921]             on.exit(options(oopts), add = TRUE)
[16:11:07.921]         }
[16:11:07.921]         {
[16:11:07.921]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.921]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.921]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.921]             })
[16:11:07.921]         }
[16:11:07.921]     }, args = future.call.arguments)
[16:11:07.921] }
[16:11:07.921] Tweak future expression to call with '...' arguments ... DONE
[16:11:07.922] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.922] 
[16:11:07.922] getGlobalsAndPackages() ... DONE
[16:11:07.922] run() for ‘Future’ ...
[16:11:07.922] - state: ‘created’
[16:11:07.923] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:07.937] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:07.938]   - Field: ‘node’
[16:11:07.938]   - Field: ‘label’
[16:11:07.938]   - Field: ‘local’
[16:11:07.938]   - Field: ‘owner’
[16:11:07.938]   - Field: ‘envir’
[16:11:07.938]   - Field: ‘workers’
[16:11:07.938]   - Field: ‘packages’
[16:11:07.938]   - Field: ‘gc’
[16:11:07.938]   - Field: ‘conditions’
[16:11:07.939]   - Field: ‘persistent’
[16:11:07.939]   - Field: ‘expr’
[16:11:07.939]   - Field: ‘uuid’
[16:11:07.939]   - Field: ‘seed’
[16:11:07.939]   - Field: ‘version’
[16:11:07.939]   - Field: ‘result’
[16:11:07.939]   - Field: ‘asynchronous’
[16:11:07.939]   - Field: ‘calls’
[16:11:07.939]   - Field: ‘globals’
[16:11:07.939]   - Field: ‘stdout’
[16:11:07.939]   - Field: ‘earlySignal’
[16:11:07.940]   - Field: ‘lazy’
[16:11:07.940]   - Field: ‘state’
[16:11:07.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:07.940] - Launch lazy future ...
[16:11:07.940] Packages needed by the future expression (n = 0): <none>
[16:11:07.940] Packages needed by future strategies (n = 0): <none>
[16:11:07.941] {
[16:11:07.941]     {
[16:11:07.941]         {
[16:11:07.941]             ...future.startTime <- base::Sys.time()
[16:11:07.941]             {
[16:11:07.941]                 {
[16:11:07.941]                   {
[16:11:07.941]                     {
[16:11:07.941]                       base::local({
[16:11:07.941]                         has_future <- base::requireNamespace("future", 
[16:11:07.941]                           quietly = TRUE)
[16:11:07.941]                         if (has_future) {
[16:11:07.941]                           ns <- base::getNamespace("future")
[16:11:07.941]                           version <- ns[[".package"]][["version"]]
[16:11:07.941]                           if (is.null(version)) 
[16:11:07.941]                             version <- utils::packageVersion("future")
[16:11:07.941]                         }
[16:11:07.941]                         else {
[16:11:07.941]                           version <- NULL
[16:11:07.941]                         }
[16:11:07.941]                         if (!has_future || version < "1.8.0") {
[16:11:07.941]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:07.941]                             "", base::R.version$version.string), 
[16:11:07.941]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:07.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:07.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:07.941]                               "release", "version")], collapse = " "), 
[16:11:07.941]                             hostname = base::Sys.info()[["nodename"]])
[16:11:07.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:07.941]                             info)
[16:11:07.941]                           info <- base::paste(info, collapse = "; ")
[16:11:07.941]                           if (!has_future) {
[16:11:07.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:07.941]                               info)
[16:11:07.941]                           }
[16:11:07.941]                           else {
[16:11:07.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:07.941]                               info, version)
[16:11:07.941]                           }
[16:11:07.941]                           base::stop(msg)
[16:11:07.941]                         }
[16:11:07.941]                       })
[16:11:07.941]                     }
[16:11:07.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:07.941]                     base::options(mc.cores = 1L)
[16:11:07.941]                   }
[16:11:07.941]                   options(future.plan = NULL)
[16:11:07.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:07.941]                 }
[16:11:07.941]                 ...future.workdir <- getwd()
[16:11:07.941]             }
[16:11:07.941]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:07.941]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:07.941]         }
[16:11:07.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:07.941]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:07.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:07.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:07.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:07.941]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:07.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:07.941]             base::names(...future.oldOptions))
[16:11:07.941]     }
[16:11:07.941]     if (FALSE) {
[16:11:07.941]     }
[16:11:07.941]     else {
[16:11:07.941]         if (TRUE) {
[16:11:07.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:07.941]                 open = "w")
[16:11:07.941]         }
[16:11:07.941]         else {
[16:11:07.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:07.941]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:07.941]         }
[16:11:07.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:07.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:07.941]             base::sink(type = "output", split = FALSE)
[16:11:07.941]             base::close(...future.stdout)
[16:11:07.941]         }, add = TRUE)
[16:11:07.941]     }
[16:11:07.941]     ...future.frame <- base::sys.nframe()
[16:11:07.941]     ...future.conditions <- base::list()
[16:11:07.941]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:07.941]     if (FALSE) {
[16:11:07.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:07.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:07.941]     }
[16:11:07.941]     ...future.result <- base::tryCatch({
[16:11:07.941]         base::withCallingHandlers({
[16:11:07.941]             ...future.value <- base::withVisible(base::local({
[16:11:07.941]                 ...future.makeSendCondition <- local({
[16:11:07.941]                   sendCondition <- NULL
[16:11:07.941]                   function(frame = 1L) {
[16:11:07.941]                     if (is.function(sendCondition)) 
[16:11:07.941]                       return(sendCondition)
[16:11:07.941]                     ns <- getNamespace("parallel")
[16:11:07.941]                     if (exists("sendData", mode = "function", 
[16:11:07.941]                       envir = ns)) {
[16:11:07.941]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:07.941]                         envir = ns)
[16:11:07.941]                       envir <- sys.frame(frame)
[16:11:07.941]                       master <- NULL
[16:11:07.941]                       while (!identical(envir, .GlobalEnv) && 
[16:11:07.941]                         !identical(envir, emptyenv())) {
[16:11:07.941]                         if (exists("master", mode = "list", envir = envir, 
[16:11:07.941]                           inherits = FALSE)) {
[16:11:07.941]                           master <- get("master", mode = "list", 
[16:11:07.941]                             envir = envir, inherits = FALSE)
[16:11:07.941]                           if (inherits(master, c("SOCKnode", 
[16:11:07.941]                             "SOCK0node"))) {
[16:11:07.941]                             sendCondition <<- function(cond) {
[16:11:07.941]                               data <- list(type = "VALUE", value = cond, 
[16:11:07.941]                                 success = TRUE)
[16:11:07.941]                               parallel_sendData(master, data)
[16:11:07.941]                             }
[16:11:07.941]                             return(sendCondition)
[16:11:07.941]                           }
[16:11:07.941]                         }
[16:11:07.941]                         frame <- frame + 1L
[16:11:07.941]                         envir <- sys.frame(frame)
[16:11:07.941]                       }
[16:11:07.941]                     }
[16:11:07.941]                     sendCondition <<- function(cond) NULL
[16:11:07.941]                   }
[16:11:07.941]                 })
[16:11:07.941]                 withCallingHandlers({
[16:11:07.941]                   {
[16:11:07.941]                     do.call(function(...) {
[16:11:07.941]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.941]                       if (!identical(...future.globals.maxSize.org, 
[16:11:07.941]                         ...future.globals.maxSize)) {
[16:11:07.941]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.941]                         on.exit(options(oopts), add = TRUE)
[16:11:07.941]                       }
[16:11:07.941]                       {
[16:11:07.941]                         lapply(seq_along(...future.elements_ii), 
[16:11:07.941]                           FUN = function(jj) {
[16:11:07.941]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.941]                             ...future.FUN(...future.X_jj, ...)
[16:11:07.941]                           })
[16:11:07.941]                       }
[16:11:07.941]                     }, args = future.call.arguments)
[16:11:07.941]                   }
[16:11:07.941]                 }, immediateCondition = function(cond) {
[16:11:07.941]                   sendCondition <- ...future.makeSendCondition()
[16:11:07.941]                   sendCondition(cond)
[16:11:07.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.941]                   {
[16:11:07.941]                     inherits <- base::inherits
[16:11:07.941]                     invokeRestart <- base::invokeRestart
[16:11:07.941]                     is.null <- base::is.null
[16:11:07.941]                     muffled <- FALSE
[16:11:07.941]                     if (inherits(cond, "message")) {
[16:11:07.941]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:07.941]                       if (muffled) 
[16:11:07.941]                         invokeRestart("muffleMessage")
[16:11:07.941]                     }
[16:11:07.941]                     else if (inherits(cond, "warning")) {
[16:11:07.941]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:07.941]                       if (muffled) 
[16:11:07.941]                         invokeRestart("muffleWarning")
[16:11:07.941]                     }
[16:11:07.941]                     else if (inherits(cond, "condition")) {
[16:11:07.941]                       if (!is.null(pattern)) {
[16:11:07.941]                         computeRestarts <- base::computeRestarts
[16:11:07.941]                         grepl <- base::grepl
[16:11:07.941]                         restarts <- computeRestarts(cond)
[16:11:07.941]                         for (restart in restarts) {
[16:11:07.941]                           name <- restart$name
[16:11:07.941]                           if (is.null(name)) 
[16:11:07.941]                             next
[16:11:07.941]                           if (!grepl(pattern, name)) 
[16:11:07.941]                             next
[16:11:07.941]                           invokeRestart(restart)
[16:11:07.941]                           muffled <- TRUE
[16:11:07.941]                           break
[16:11:07.941]                         }
[16:11:07.941]                       }
[16:11:07.941]                     }
[16:11:07.941]                     invisible(muffled)
[16:11:07.941]                   }
[16:11:07.941]                   muffleCondition(cond)
[16:11:07.941]                 })
[16:11:07.941]             }))
[16:11:07.941]             future::FutureResult(value = ...future.value$value, 
[16:11:07.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.941]                   ...future.rng), globalenv = if (FALSE) 
[16:11:07.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:07.941]                     ...future.globalenv.names))
[16:11:07.941]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:07.941]         }, condition = base::local({
[16:11:07.941]             c <- base::c
[16:11:07.941]             inherits <- base::inherits
[16:11:07.941]             invokeRestart <- base::invokeRestart
[16:11:07.941]             length <- base::length
[16:11:07.941]             list <- base::list
[16:11:07.941]             seq.int <- base::seq.int
[16:11:07.941]             signalCondition <- base::signalCondition
[16:11:07.941]             sys.calls <- base::sys.calls
[16:11:07.941]             `[[` <- base::`[[`
[16:11:07.941]             `+` <- base::`+`
[16:11:07.941]             `<<-` <- base::`<<-`
[16:11:07.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:07.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:07.941]                   3L)]
[16:11:07.941]             }
[16:11:07.941]             function(cond) {
[16:11:07.941]                 is_error <- inherits(cond, "error")
[16:11:07.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:07.941]                   NULL)
[16:11:07.941]                 if (is_error) {
[16:11:07.941]                   sessionInformation <- function() {
[16:11:07.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:07.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:07.941]                       search = base::search(), system = base::Sys.info())
[16:11:07.941]                   }
[16:11:07.941]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:07.941]                     cond$call), session = sessionInformation(), 
[16:11:07.941]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:07.941]                   signalCondition(cond)
[16:11:07.941]                 }
[16:11:07.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:07.941]                 "immediateCondition"))) {
[16:11:07.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:07.941]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:07.941]                   if (TRUE && !signal) {
[16:11:07.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.941]                     {
[16:11:07.941]                       inherits <- base::inherits
[16:11:07.941]                       invokeRestart <- base::invokeRestart
[16:11:07.941]                       is.null <- base::is.null
[16:11:07.941]                       muffled <- FALSE
[16:11:07.941]                       if (inherits(cond, "message")) {
[16:11:07.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.941]                         if (muffled) 
[16:11:07.941]                           invokeRestart("muffleMessage")
[16:11:07.941]                       }
[16:11:07.941]                       else if (inherits(cond, "warning")) {
[16:11:07.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.941]                         if (muffled) 
[16:11:07.941]                           invokeRestart("muffleWarning")
[16:11:07.941]                       }
[16:11:07.941]                       else if (inherits(cond, "condition")) {
[16:11:07.941]                         if (!is.null(pattern)) {
[16:11:07.941]                           computeRestarts <- base::computeRestarts
[16:11:07.941]                           grepl <- base::grepl
[16:11:07.941]                           restarts <- computeRestarts(cond)
[16:11:07.941]                           for (restart in restarts) {
[16:11:07.941]                             name <- restart$name
[16:11:07.941]                             if (is.null(name)) 
[16:11:07.941]                               next
[16:11:07.941]                             if (!grepl(pattern, name)) 
[16:11:07.941]                               next
[16:11:07.941]                             invokeRestart(restart)
[16:11:07.941]                             muffled <- TRUE
[16:11:07.941]                             break
[16:11:07.941]                           }
[16:11:07.941]                         }
[16:11:07.941]                       }
[16:11:07.941]                       invisible(muffled)
[16:11:07.941]                     }
[16:11:07.941]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.941]                   }
[16:11:07.941]                 }
[16:11:07.941]                 else {
[16:11:07.941]                   if (TRUE) {
[16:11:07.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.941]                     {
[16:11:07.941]                       inherits <- base::inherits
[16:11:07.941]                       invokeRestart <- base::invokeRestart
[16:11:07.941]                       is.null <- base::is.null
[16:11:07.941]                       muffled <- FALSE
[16:11:07.941]                       if (inherits(cond, "message")) {
[16:11:07.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.941]                         if (muffled) 
[16:11:07.941]                           invokeRestart("muffleMessage")
[16:11:07.941]                       }
[16:11:07.941]                       else if (inherits(cond, "warning")) {
[16:11:07.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.941]                         if (muffled) 
[16:11:07.941]                           invokeRestart("muffleWarning")
[16:11:07.941]                       }
[16:11:07.941]                       else if (inherits(cond, "condition")) {
[16:11:07.941]                         if (!is.null(pattern)) {
[16:11:07.941]                           computeRestarts <- base::computeRestarts
[16:11:07.941]                           grepl <- base::grepl
[16:11:07.941]                           restarts <- computeRestarts(cond)
[16:11:07.941]                           for (restart in restarts) {
[16:11:07.941]                             name <- restart$name
[16:11:07.941]                             if (is.null(name)) 
[16:11:07.941]                               next
[16:11:07.941]                             if (!grepl(pattern, name)) 
[16:11:07.941]                               next
[16:11:07.941]                             invokeRestart(restart)
[16:11:07.941]                             muffled <- TRUE
[16:11:07.941]                             break
[16:11:07.941]                           }
[16:11:07.941]                         }
[16:11:07.941]                       }
[16:11:07.941]                       invisible(muffled)
[16:11:07.941]                     }
[16:11:07.941]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.941]                   }
[16:11:07.941]                 }
[16:11:07.941]             }
[16:11:07.941]         }))
[16:11:07.941]     }, error = function(ex) {
[16:11:07.941]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:07.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.941]                 ...future.rng), started = ...future.startTime, 
[16:11:07.941]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:07.941]             version = "1.8"), class = "FutureResult")
[16:11:07.941]     }, finally = {
[16:11:07.941]         if (!identical(...future.workdir, getwd())) 
[16:11:07.941]             setwd(...future.workdir)
[16:11:07.941]         {
[16:11:07.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:07.941]                 ...future.oldOptions$nwarnings <- NULL
[16:11:07.941]             }
[16:11:07.941]             base::options(...future.oldOptions)
[16:11:07.941]             if (.Platform$OS.type == "windows") {
[16:11:07.941]                 old_names <- names(...future.oldEnvVars)
[16:11:07.941]                 envs <- base::Sys.getenv()
[16:11:07.941]                 names <- names(envs)
[16:11:07.941]                 common <- intersect(names, old_names)
[16:11:07.941]                 added <- setdiff(names, old_names)
[16:11:07.941]                 removed <- setdiff(old_names, names)
[16:11:07.941]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:07.941]                   envs[common]]
[16:11:07.941]                 NAMES <- toupper(changed)
[16:11:07.941]                 args <- list()
[16:11:07.941]                 for (kk in seq_along(NAMES)) {
[16:11:07.941]                   name <- changed[[kk]]
[16:11:07.941]                   NAME <- NAMES[[kk]]
[16:11:07.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.941]                     next
[16:11:07.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.941]                 }
[16:11:07.941]                 NAMES <- toupper(added)
[16:11:07.941]                 for (kk in seq_along(NAMES)) {
[16:11:07.941]                   name <- added[[kk]]
[16:11:07.941]                   NAME <- NAMES[[kk]]
[16:11:07.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.941]                     next
[16:11:07.941]                   args[[name]] <- ""
[16:11:07.941]                 }
[16:11:07.941]                 NAMES <- toupper(removed)
[16:11:07.941]                 for (kk in seq_along(NAMES)) {
[16:11:07.941]                   name <- removed[[kk]]
[16:11:07.941]                   NAME <- NAMES[[kk]]
[16:11:07.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.941]                     next
[16:11:07.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.941]                 }
[16:11:07.941]                 if (length(args) > 0) 
[16:11:07.941]                   base::do.call(base::Sys.setenv, args = args)
[16:11:07.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:07.941]             }
[16:11:07.941]             else {
[16:11:07.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:07.941]             }
[16:11:07.941]             {
[16:11:07.941]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:07.941]                   0L) {
[16:11:07.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:07.941]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:07.941]                   base::options(opts)
[16:11:07.941]                 }
[16:11:07.941]                 {
[16:11:07.941]                   {
[16:11:07.941]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:07.941]                     NULL
[16:11:07.941]                   }
[16:11:07.941]                   options(future.plan = NULL)
[16:11:07.941]                   if (is.na(NA_character_)) 
[16:11:07.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:07.941]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:07.941]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:07.941]                     envir = parent.frame()) 
[16:11:07.941]                   {
[16:11:07.941]                     if (is.function(workers)) 
[16:11:07.941]                       workers <- workers()
[16:11:07.941]                     workers <- structure(as.integer(workers), 
[16:11:07.941]                       class = class(workers))
[16:11:07.941]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:07.941]                       workers >= 1)
[16:11:07.941]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:07.941]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:07.941]                     }
[16:11:07.941]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:07.941]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:07.941]                       envir = envir)
[16:11:07.941]                     if (!future$lazy) 
[16:11:07.941]                       future <- run(future)
[16:11:07.941]                     invisible(future)
[16:11:07.941]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:07.941]                 }
[16:11:07.941]             }
[16:11:07.941]         }
[16:11:07.941]     })
[16:11:07.941]     if (TRUE) {
[16:11:07.941]         base::sink(type = "output", split = FALSE)
[16:11:07.941]         if (TRUE) {
[16:11:07.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:07.941]         }
[16:11:07.941]         else {
[16:11:07.941]             ...future.result["stdout"] <- base::list(NULL)
[16:11:07.941]         }
[16:11:07.941]         base::close(...future.stdout)
[16:11:07.941]         ...future.stdout <- NULL
[16:11:07.941]     }
[16:11:07.941]     ...future.result$conditions <- ...future.conditions
[16:11:07.941]     ...future.result$finished <- base::Sys.time()
[16:11:07.941]     ...future.result
[16:11:07.941] }
[16:11:07.944] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[16:11:07.944] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[16:11:07.944] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[16:11:07.945] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[16:11:07.945] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[16:11:07.945] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:11:07.946] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:11:07.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:07.949] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.949] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:07.950] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:07.950] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[16:11:07.951] MultisessionFuture started
[16:11:07.951] - Launch lazy future ... done
[16:11:07.951] run() for ‘MultisessionFuture’ ... done
[16:11:07.951] Created future:
[16:11:07.951] MultisessionFuture:
[16:11:07.951] Label: ‘future_sapply-1’
[16:11:07.951] Expression:
[16:11:07.951] {
[16:11:07.951]     do.call(function(...) {
[16:11:07.951]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.951]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.951]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.951]             on.exit(options(oopts), add = TRUE)
[16:11:07.951]         }
[16:11:07.951]         {
[16:11:07.951]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.951]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.951]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.951]             })
[16:11:07.951]         }
[16:11:07.951]     }, args = future.call.arguments)
[16:11:07.951] }
[16:11:07.951] Lazy evaluation: FALSE
[16:11:07.951] Asynchronous evaluation: TRUE
[16:11:07.951] Local evaluation: TRUE
[16:11:07.951] Environment: R_GlobalEnv
[16:11:07.951] Capture standard output: TRUE
[16:11:07.951] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:07.951] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:07.951] Packages: <none>
[16:11:07.951] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:07.951] Resolved: FALSE
[16:11:07.951] Value: <not collected>
[16:11:07.951] Conditions captured: <none>
[16:11:07.951] Early signaling: FALSE
[16:11:07.951] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:07.951] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.963] Chunk #1 of 2 ... DONE
[16:11:07.963] Chunk #2 of 2 ...
[16:11:07.963]  - Finding globals in 'X' for chunk #2 ...
[16:11:07.963] getGlobalsAndPackages() ...
[16:11:07.963] Searching for globals...
[16:11:07.964] 
[16:11:07.964] Searching for globals ... DONE
[16:11:07.964] - globals: [0] <none>
[16:11:07.964] getGlobalsAndPackages() ... DONE
[16:11:07.964]    + additional globals found: [n=0] 
[16:11:07.964]    + additional namespaces needed: [n=0] 
[16:11:07.964]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:07.964]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:07.964]  - seeds: <none>
[16:11:07.964] getGlobalsAndPackages() ...
[16:11:07.965] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.965] Resolving globals: FALSE
[16:11:07.965] Tweak future expression to call with '...' arguments ...
[16:11:07.965] {
[16:11:07.965]     do.call(function(...) {
[16:11:07.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.965]             on.exit(options(oopts), add = TRUE)
[16:11:07.965]         }
[16:11:07.965]         {
[16:11:07.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.965]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.965]             })
[16:11:07.965]         }
[16:11:07.965]     }, args = future.call.arguments)
[16:11:07.965] }
[16:11:07.965] Tweak future expression to call with '...' arguments ... DONE
[16:11:07.966] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:07.966] 
[16:11:07.966] getGlobalsAndPackages() ... DONE
[16:11:07.966] run() for ‘Future’ ...
[16:11:07.966] - state: ‘created’
[16:11:07.966] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:07.981] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:07.981] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:07.981]   - Field: ‘node’
[16:11:07.981]   - Field: ‘label’
[16:11:07.981]   - Field: ‘local’
[16:11:07.981]   - Field: ‘owner’
[16:11:07.981]   - Field: ‘envir’
[16:11:07.981]   - Field: ‘workers’
[16:11:07.982]   - Field: ‘packages’
[16:11:07.982]   - Field: ‘gc’
[16:11:07.982]   - Field: ‘conditions’
[16:11:07.982]   - Field: ‘persistent’
[16:11:07.982]   - Field: ‘expr’
[16:11:07.982]   - Field: ‘uuid’
[16:11:07.982]   - Field: ‘seed’
[16:11:07.982]   - Field: ‘version’
[16:11:07.982]   - Field: ‘result’
[16:11:07.982]   - Field: ‘asynchronous’
[16:11:07.982]   - Field: ‘calls’
[16:11:07.983]   - Field: ‘globals’
[16:11:07.983]   - Field: ‘stdout’
[16:11:07.983]   - Field: ‘earlySignal’
[16:11:07.983]   - Field: ‘lazy’
[16:11:07.983]   - Field: ‘state’
[16:11:07.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:07.983] - Launch lazy future ...
[16:11:07.983] Packages needed by the future expression (n = 0): <none>
[16:11:07.983] Packages needed by future strategies (n = 0): <none>
[16:11:07.984] {
[16:11:07.984]     {
[16:11:07.984]         {
[16:11:07.984]             ...future.startTime <- base::Sys.time()
[16:11:07.984]             {
[16:11:07.984]                 {
[16:11:07.984]                   {
[16:11:07.984]                     {
[16:11:07.984]                       base::local({
[16:11:07.984]                         has_future <- base::requireNamespace("future", 
[16:11:07.984]                           quietly = TRUE)
[16:11:07.984]                         if (has_future) {
[16:11:07.984]                           ns <- base::getNamespace("future")
[16:11:07.984]                           version <- ns[[".package"]][["version"]]
[16:11:07.984]                           if (is.null(version)) 
[16:11:07.984]                             version <- utils::packageVersion("future")
[16:11:07.984]                         }
[16:11:07.984]                         else {
[16:11:07.984]                           version <- NULL
[16:11:07.984]                         }
[16:11:07.984]                         if (!has_future || version < "1.8.0") {
[16:11:07.984]                           info <- base::c(r_version = base::gsub("R version ", 
[16:11:07.984]                             "", base::R.version$version.string), 
[16:11:07.984]                             platform = base::sprintf("%s (%s-bit)", 
[16:11:07.984]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:11:07.984]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:07.984]                               "release", "version")], collapse = " "), 
[16:11:07.984]                             hostname = base::Sys.info()[["nodename"]])
[16:11:07.984]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:11:07.984]                             info)
[16:11:07.984]                           info <- base::paste(info, collapse = "; ")
[16:11:07.984]                           if (!has_future) {
[16:11:07.984]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:07.984]                               info)
[16:11:07.984]                           }
[16:11:07.984]                           else {
[16:11:07.984]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:07.984]                               info, version)
[16:11:07.984]                           }
[16:11:07.984]                           base::stop(msg)
[16:11:07.984]                         }
[16:11:07.984]                       })
[16:11:07.984]                     }
[16:11:07.984]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:07.984]                     base::options(mc.cores = 1L)
[16:11:07.984]                   }
[16:11:07.984]                   options(future.plan = NULL)
[16:11:07.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:07.984]                 }
[16:11:07.984]                 ...future.workdir <- getwd()
[16:11:07.984]             }
[16:11:07.984]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:07.984]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:07.984]         }
[16:11:07.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:07.984]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:07.984]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:07.984]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:07.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:07.984]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:07.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:07.984]             base::names(...future.oldOptions))
[16:11:07.984]     }
[16:11:07.984]     if (FALSE) {
[16:11:07.984]     }
[16:11:07.984]     else {
[16:11:07.984]         if (TRUE) {
[16:11:07.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:07.984]                 open = "w")
[16:11:07.984]         }
[16:11:07.984]         else {
[16:11:07.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:07.984]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:07.984]         }
[16:11:07.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:07.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:07.984]             base::sink(type = "output", split = FALSE)
[16:11:07.984]             base::close(...future.stdout)
[16:11:07.984]         }, add = TRUE)
[16:11:07.984]     }
[16:11:07.984]     ...future.frame <- base::sys.nframe()
[16:11:07.984]     ...future.conditions <- base::list()
[16:11:07.984]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:07.984]     if (FALSE) {
[16:11:07.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:07.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:07.984]     }
[16:11:07.984]     ...future.result <- base::tryCatch({
[16:11:07.984]         base::withCallingHandlers({
[16:11:07.984]             ...future.value <- base::withVisible(base::local({
[16:11:07.984]                 ...future.makeSendCondition <- local({
[16:11:07.984]                   sendCondition <- NULL
[16:11:07.984]                   function(frame = 1L) {
[16:11:07.984]                     if (is.function(sendCondition)) 
[16:11:07.984]                       return(sendCondition)
[16:11:07.984]                     ns <- getNamespace("parallel")
[16:11:07.984]                     if (exists("sendData", mode = "function", 
[16:11:07.984]                       envir = ns)) {
[16:11:07.984]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:07.984]                         envir = ns)
[16:11:07.984]                       envir <- sys.frame(frame)
[16:11:07.984]                       master <- NULL
[16:11:07.984]                       while (!identical(envir, .GlobalEnv) && 
[16:11:07.984]                         !identical(envir, emptyenv())) {
[16:11:07.984]                         if (exists("master", mode = "list", envir = envir, 
[16:11:07.984]                           inherits = FALSE)) {
[16:11:07.984]                           master <- get("master", mode = "list", 
[16:11:07.984]                             envir = envir, inherits = FALSE)
[16:11:07.984]                           if (inherits(master, c("SOCKnode", 
[16:11:07.984]                             "SOCK0node"))) {
[16:11:07.984]                             sendCondition <<- function(cond) {
[16:11:07.984]                               data <- list(type = "VALUE", value = cond, 
[16:11:07.984]                                 success = TRUE)
[16:11:07.984]                               parallel_sendData(master, data)
[16:11:07.984]                             }
[16:11:07.984]                             return(sendCondition)
[16:11:07.984]                           }
[16:11:07.984]                         }
[16:11:07.984]                         frame <- frame + 1L
[16:11:07.984]                         envir <- sys.frame(frame)
[16:11:07.984]                       }
[16:11:07.984]                     }
[16:11:07.984]                     sendCondition <<- function(cond) NULL
[16:11:07.984]                   }
[16:11:07.984]                 })
[16:11:07.984]                 withCallingHandlers({
[16:11:07.984]                   {
[16:11:07.984]                     do.call(function(...) {
[16:11:07.984]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.984]                       if (!identical(...future.globals.maxSize.org, 
[16:11:07.984]                         ...future.globals.maxSize)) {
[16:11:07.984]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.984]                         on.exit(options(oopts), add = TRUE)
[16:11:07.984]                       }
[16:11:07.984]                       {
[16:11:07.984]                         lapply(seq_along(...future.elements_ii), 
[16:11:07.984]                           FUN = function(jj) {
[16:11:07.984]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.984]                             ...future.FUN(...future.X_jj, ...)
[16:11:07.984]                           })
[16:11:07.984]                       }
[16:11:07.984]                     }, args = future.call.arguments)
[16:11:07.984]                   }
[16:11:07.984]                 }, immediateCondition = function(cond) {
[16:11:07.984]                   sendCondition <- ...future.makeSendCondition()
[16:11:07.984]                   sendCondition(cond)
[16:11:07.984]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.984]                   {
[16:11:07.984]                     inherits <- base::inherits
[16:11:07.984]                     invokeRestart <- base::invokeRestart
[16:11:07.984]                     is.null <- base::is.null
[16:11:07.984]                     muffled <- FALSE
[16:11:07.984]                     if (inherits(cond, "message")) {
[16:11:07.984]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:07.984]                       if (muffled) 
[16:11:07.984]                         invokeRestart("muffleMessage")
[16:11:07.984]                     }
[16:11:07.984]                     else if (inherits(cond, "warning")) {
[16:11:07.984]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:07.984]                       if (muffled) 
[16:11:07.984]                         invokeRestart("muffleWarning")
[16:11:07.984]                     }
[16:11:07.984]                     else if (inherits(cond, "condition")) {
[16:11:07.984]                       if (!is.null(pattern)) {
[16:11:07.984]                         computeRestarts <- base::computeRestarts
[16:11:07.984]                         grepl <- base::grepl
[16:11:07.984]                         restarts <- computeRestarts(cond)
[16:11:07.984]                         for (restart in restarts) {
[16:11:07.984]                           name <- restart$name
[16:11:07.984]                           if (is.null(name)) 
[16:11:07.984]                             next
[16:11:07.984]                           if (!grepl(pattern, name)) 
[16:11:07.984]                             next
[16:11:07.984]                           invokeRestart(restart)
[16:11:07.984]                           muffled <- TRUE
[16:11:07.984]                           break
[16:11:07.984]                         }
[16:11:07.984]                       }
[16:11:07.984]                     }
[16:11:07.984]                     invisible(muffled)
[16:11:07.984]                   }
[16:11:07.984]                   muffleCondition(cond)
[16:11:07.984]                 })
[16:11:07.984]             }))
[16:11:07.984]             future::FutureResult(value = ...future.value$value, 
[16:11:07.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.984]                   ...future.rng), globalenv = if (FALSE) 
[16:11:07.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:07.984]                     ...future.globalenv.names))
[16:11:07.984]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:07.984]         }, condition = base::local({
[16:11:07.984]             c <- base::c
[16:11:07.984]             inherits <- base::inherits
[16:11:07.984]             invokeRestart <- base::invokeRestart
[16:11:07.984]             length <- base::length
[16:11:07.984]             list <- base::list
[16:11:07.984]             seq.int <- base::seq.int
[16:11:07.984]             signalCondition <- base::signalCondition
[16:11:07.984]             sys.calls <- base::sys.calls
[16:11:07.984]             `[[` <- base::`[[`
[16:11:07.984]             `+` <- base::`+`
[16:11:07.984]             `<<-` <- base::`<<-`
[16:11:07.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:07.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:07.984]                   3L)]
[16:11:07.984]             }
[16:11:07.984]             function(cond) {
[16:11:07.984]                 is_error <- inherits(cond, "error")
[16:11:07.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:07.984]                   NULL)
[16:11:07.984]                 if (is_error) {
[16:11:07.984]                   sessionInformation <- function() {
[16:11:07.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:07.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:07.984]                       search = base::search(), system = base::Sys.info())
[16:11:07.984]                   }
[16:11:07.984]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:07.984]                     cond$call), session = sessionInformation(), 
[16:11:07.984]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:07.984]                   signalCondition(cond)
[16:11:07.984]                 }
[16:11:07.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:07.984]                 "immediateCondition"))) {
[16:11:07.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:07.984]                   ...future.conditions[[length(...future.conditions) + 
[16:11:07.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:07.984]                   if (TRUE && !signal) {
[16:11:07.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.984]                     {
[16:11:07.984]                       inherits <- base::inherits
[16:11:07.984]                       invokeRestart <- base::invokeRestart
[16:11:07.984]                       is.null <- base::is.null
[16:11:07.984]                       muffled <- FALSE
[16:11:07.984]                       if (inherits(cond, "message")) {
[16:11:07.984]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.984]                         if (muffled) 
[16:11:07.984]                           invokeRestart("muffleMessage")
[16:11:07.984]                       }
[16:11:07.984]                       else if (inherits(cond, "warning")) {
[16:11:07.984]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.984]                         if (muffled) 
[16:11:07.984]                           invokeRestart("muffleWarning")
[16:11:07.984]                       }
[16:11:07.984]                       else if (inherits(cond, "condition")) {
[16:11:07.984]                         if (!is.null(pattern)) {
[16:11:07.984]                           computeRestarts <- base::computeRestarts
[16:11:07.984]                           grepl <- base::grepl
[16:11:07.984]                           restarts <- computeRestarts(cond)
[16:11:07.984]                           for (restart in restarts) {
[16:11:07.984]                             name <- restart$name
[16:11:07.984]                             if (is.null(name)) 
[16:11:07.984]                               next
[16:11:07.984]                             if (!grepl(pattern, name)) 
[16:11:07.984]                               next
[16:11:07.984]                             invokeRestart(restart)
[16:11:07.984]                             muffled <- TRUE
[16:11:07.984]                             break
[16:11:07.984]                           }
[16:11:07.984]                         }
[16:11:07.984]                       }
[16:11:07.984]                       invisible(muffled)
[16:11:07.984]                     }
[16:11:07.984]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.984]                   }
[16:11:07.984]                 }
[16:11:07.984]                 else {
[16:11:07.984]                   if (TRUE) {
[16:11:07.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:07.984]                     {
[16:11:07.984]                       inherits <- base::inherits
[16:11:07.984]                       invokeRestart <- base::invokeRestart
[16:11:07.984]                       is.null <- base::is.null
[16:11:07.984]                       muffled <- FALSE
[16:11:07.984]                       if (inherits(cond, "message")) {
[16:11:07.984]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:07.984]                         if (muffled) 
[16:11:07.984]                           invokeRestart("muffleMessage")
[16:11:07.984]                       }
[16:11:07.984]                       else if (inherits(cond, "warning")) {
[16:11:07.984]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:07.984]                         if (muffled) 
[16:11:07.984]                           invokeRestart("muffleWarning")
[16:11:07.984]                       }
[16:11:07.984]                       else if (inherits(cond, "condition")) {
[16:11:07.984]                         if (!is.null(pattern)) {
[16:11:07.984]                           computeRestarts <- base::computeRestarts
[16:11:07.984]                           grepl <- base::grepl
[16:11:07.984]                           restarts <- computeRestarts(cond)
[16:11:07.984]                           for (restart in restarts) {
[16:11:07.984]                             name <- restart$name
[16:11:07.984]                             if (is.null(name)) 
[16:11:07.984]                               next
[16:11:07.984]                             if (!grepl(pattern, name)) 
[16:11:07.984]                               next
[16:11:07.984]                             invokeRestart(restart)
[16:11:07.984]                             muffled <- TRUE
[16:11:07.984]                             break
[16:11:07.984]                           }
[16:11:07.984]                         }
[16:11:07.984]                       }
[16:11:07.984]                       invisible(muffled)
[16:11:07.984]                     }
[16:11:07.984]                     muffleCondition(cond, pattern = "^muffle")
[16:11:07.984]                   }
[16:11:07.984]                 }
[16:11:07.984]             }
[16:11:07.984]         }))
[16:11:07.984]     }, error = function(ex) {
[16:11:07.984]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:07.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:07.984]                 ...future.rng), started = ...future.startTime, 
[16:11:07.984]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:07.984]             version = "1.8"), class = "FutureResult")
[16:11:07.984]     }, finally = {
[16:11:07.984]         if (!identical(...future.workdir, getwd())) 
[16:11:07.984]             setwd(...future.workdir)
[16:11:07.984]         {
[16:11:07.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:07.984]                 ...future.oldOptions$nwarnings <- NULL
[16:11:07.984]             }
[16:11:07.984]             base::options(...future.oldOptions)
[16:11:07.984]             if (.Platform$OS.type == "windows") {
[16:11:07.984]                 old_names <- names(...future.oldEnvVars)
[16:11:07.984]                 envs <- base::Sys.getenv()
[16:11:07.984]                 names <- names(envs)
[16:11:07.984]                 common <- intersect(names, old_names)
[16:11:07.984]                 added <- setdiff(names, old_names)
[16:11:07.984]                 removed <- setdiff(old_names, names)
[16:11:07.984]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:07.984]                   envs[common]]
[16:11:07.984]                 NAMES <- toupper(changed)
[16:11:07.984]                 args <- list()
[16:11:07.984]                 for (kk in seq_along(NAMES)) {
[16:11:07.984]                   name <- changed[[kk]]
[16:11:07.984]                   NAME <- NAMES[[kk]]
[16:11:07.984]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.984]                     next
[16:11:07.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.984]                 }
[16:11:07.984]                 NAMES <- toupper(added)
[16:11:07.984]                 for (kk in seq_along(NAMES)) {
[16:11:07.984]                   name <- added[[kk]]
[16:11:07.984]                   NAME <- NAMES[[kk]]
[16:11:07.984]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.984]                     next
[16:11:07.984]                   args[[name]] <- ""
[16:11:07.984]                 }
[16:11:07.984]                 NAMES <- toupper(removed)
[16:11:07.984]                 for (kk in seq_along(NAMES)) {
[16:11:07.984]                   name <- removed[[kk]]
[16:11:07.984]                   NAME <- NAMES[[kk]]
[16:11:07.984]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:07.984]                     next
[16:11:07.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:07.984]                 }
[16:11:07.984]                 if (length(args) > 0) 
[16:11:07.984]                   base::do.call(base::Sys.setenv, args = args)
[16:11:07.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:07.984]             }
[16:11:07.984]             else {
[16:11:07.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:07.984]             }
[16:11:07.984]             {
[16:11:07.984]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:07.984]                   0L) {
[16:11:07.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:07.984]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:07.984]                   base::options(opts)
[16:11:07.984]                 }
[16:11:07.984]                 {
[16:11:07.984]                   {
[16:11:07.984]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:07.984]                     NULL
[16:11:07.984]                   }
[16:11:07.984]                   options(future.plan = NULL)
[16:11:07.984]                   if (is.na(NA_character_)) 
[16:11:07.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:07.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:07.984]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:07.984]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:07.984]                     envir = parent.frame()) 
[16:11:07.984]                   {
[16:11:07.984]                     if (is.function(workers)) 
[16:11:07.984]                       workers <- workers()
[16:11:07.984]                     workers <- structure(as.integer(workers), 
[16:11:07.984]                       class = class(workers))
[16:11:07.984]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:07.984]                       workers >= 1)
[16:11:07.984]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:07.984]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:07.984]                     }
[16:11:07.984]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:07.984]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:07.984]                       envir = envir)
[16:11:07.984]                     if (!future$lazy) 
[16:11:07.984]                       future <- run(future)
[16:11:07.984]                     invisible(future)
[16:11:07.984]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:07.984]                 }
[16:11:07.984]             }
[16:11:07.984]         }
[16:11:07.984]     })
[16:11:07.984]     if (TRUE) {
[16:11:07.984]         base::sink(type = "output", split = FALSE)
[16:11:07.984]         if (TRUE) {
[16:11:07.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:07.984]         }
[16:11:07.984]         else {
[16:11:07.984]             ...future.result["stdout"] <- base::list(NULL)
[16:11:07.984]         }
[16:11:07.984]         base::close(...future.stdout)
[16:11:07.984]         ...future.stdout <- NULL
[16:11:07.984]     }
[16:11:07.984]     ...future.result$conditions <- ...future.conditions
[16:11:07.984]     ...future.result$finished <- base::Sys.time()
[16:11:07.984]     ...future.result
[16:11:07.984] }
[16:11:07.987] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[16:11:07.987] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[16:11:07.987] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[16:11:07.988] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[16:11:07.988] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[16:11:07.988] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:11:07.988] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:11:07.989] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:07.989] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.989] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:07.989] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:07.989] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[16:11:07.990] MultisessionFuture started
[16:11:07.990] - Launch lazy future ... done
[16:11:07.990] run() for ‘MultisessionFuture’ ... done
[16:11:07.990] Created future:
[16:11:07.990] MultisessionFuture:
[16:11:07.990] Label: ‘future_sapply-2’
[16:11:07.990] Expression:
[16:11:07.990] {
[16:11:07.990]     do.call(function(...) {
[16:11:07.990]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:07.990]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:07.990]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:07.990]             on.exit(options(oopts), add = TRUE)
[16:11:07.990]         }
[16:11:07.990]         {
[16:11:07.990]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:07.990]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:07.990]                 ...future.FUN(...future.X_jj, ...)
[16:11:07.990]             })
[16:11:07.990]         }
[16:11:07.990]     }, args = future.call.arguments)
[16:11:07.990] }
[16:11:07.990] Lazy evaluation: FALSE
[16:11:07.990] Asynchronous evaluation: TRUE
[16:11:07.990] Local evaluation: TRUE
[16:11:07.990] Environment: R_GlobalEnv
[16:11:07.990] Capture standard output: TRUE
[16:11:07.990] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:07.990] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:11:07.990] Packages: <none>
[16:11:07.990] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:07.990] Resolved: FALSE
[16:11:07.990] Value: <not collected>
[16:11:07.990] Conditions captured: <none>
[16:11:07.990] Early signaling: FALSE
[16:11:07.990] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:07.990] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.002] Chunk #2 of 2 ... DONE
[16:11:08.002] Launching 2 futures (chunks) ... DONE
[16:11:08.002] Resolving 2 futures (chunks) ...
[16:11:08.002] resolve() on list ...
[16:11:08.002]  recursive: 0
[16:11:08.003]  length: 2
[16:11:08.003] 
[16:11:08.003] receiveMessageFromWorker() for ClusterFuture ...
[16:11:08.003] - Validating connection of MultisessionFuture
[16:11:08.003] - received message: FutureResult
[16:11:08.004] - Received FutureResult
[16:11:08.004] - Erased future from FutureRegistry
[16:11:08.004] result() for ClusterFuture ...
[16:11:08.004] - result already collected: FutureResult
[16:11:08.004] result() for ClusterFuture ... done
[16:11:08.004] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:08.004] Future #1
[16:11:08.004] result() for ClusterFuture ...
[16:11:08.004] - result already collected: FutureResult
[16:11:08.004] result() for ClusterFuture ... done
[16:11:08.005] result() for ClusterFuture ...
[16:11:08.005] - result already collected: FutureResult
[16:11:08.005] result() for ClusterFuture ... done
[16:11:08.005] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:08.005] - nx: 2
[16:11:08.005] - relay: TRUE
[16:11:08.005] - stdout: TRUE
[16:11:08.005] - signal: TRUE
[16:11:08.005] - resignal: FALSE
[16:11:08.005] - force: TRUE
[16:11:08.005] - relayed: [n=2] FALSE, FALSE
[16:11:08.005] - queued futures: [n=2] FALSE, FALSE
[16:11:08.006]  - until=1
[16:11:08.006]  - relaying element #1
[16:11:08.006] result() for ClusterFuture ...
[16:11:08.006] - result already collected: FutureResult
[16:11:08.006] result() for ClusterFuture ... done
[16:11:08.006] result() for ClusterFuture ...
[16:11:08.006] - result already collected: FutureResult
[16:11:08.006] result() for ClusterFuture ... done
[16:11:08.006] result() for ClusterFuture ...
[16:11:08.006] - result already collected: FutureResult
[16:11:08.006] result() for ClusterFuture ... done
[16:11:08.007] result() for ClusterFuture ...
[16:11:08.007] - result already collected: FutureResult
[16:11:08.007] result() for ClusterFuture ... done
[16:11:08.007] - relayed: [n=2] TRUE, FALSE
[16:11:08.007] - queued futures: [n=2] TRUE, FALSE
[16:11:08.007] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:08.007]  length: 1 (resolved future 1)
[16:11:08.037] receiveMessageFromWorker() for ClusterFuture ...
[16:11:08.037] - Validating connection of MultisessionFuture
[16:11:08.037] - received message: FutureResult
[16:11:08.037] - Received FutureResult
[16:11:08.038] - Erased future from FutureRegistry
[16:11:08.038] result() for ClusterFuture ...
[16:11:08.038] - result already collected: FutureResult
[16:11:08.038] result() for ClusterFuture ... done
[16:11:08.038] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:08.038] Future #2
[16:11:08.038] result() for ClusterFuture ...
[16:11:08.038] - result already collected: FutureResult
[16:11:08.038] result() for ClusterFuture ... done
[16:11:08.038] result() for ClusterFuture ...
[16:11:08.038] - result already collected: FutureResult
[16:11:08.039] result() for ClusterFuture ... done
[16:11:08.039] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:08.039] - nx: 2
[16:11:08.039] - relay: TRUE
[16:11:08.039] - stdout: TRUE
[16:11:08.039] - signal: TRUE
[16:11:08.039] - resignal: FALSE
[16:11:08.039] - force: TRUE
[16:11:08.039] - relayed: [n=2] TRUE, FALSE
[16:11:08.039] - queued futures: [n=2] TRUE, FALSE
[16:11:08.039]  - until=2
[16:11:08.039]  - relaying element #2
[16:11:08.040] result() for ClusterFuture ...
[16:11:08.040] - result already collected: FutureResult
[16:11:08.040] result() for ClusterFuture ... done
[16:11:08.040] result() for ClusterFuture ...
[16:11:08.040] - result already collected: FutureResult
[16:11:08.040] result() for ClusterFuture ... done
[16:11:08.040] result() for ClusterFuture ...
[16:11:08.040] - result already collected: FutureResult
[16:11:08.040] result() for ClusterFuture ... done
[16:11:08.040] result() for ClusterFuture ...
[16:11:08.041] - result already collected: FutureResult
[16:11:08.041] result() for ClusterFuture ... done
[16:11:08.041] - relayed: [n=2] TRUE, TRUE
[16:11:08.041] - queued futures: [n=2] TRUE, TRUE
[16:11:08.041] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:08.041]  length: 0 (resolved future 2)
[16:11:08.041] Relaying remaining futures
[16:11:08.041] signalConditionsASAP(NULL, pos=0) ...
[16:11:08.041] - nx: 2
[16:11:08.041] - relay: TRUE
[16:11:08.041] - stdout: TRUE
[16:11:08.042] - signal: TRUE
[16:11:08.042] - resignal: FALSE
[16:11:08.042] - force: TRUE
[16:11:08.042] - relayed: [n=2] TRUE, TRUE
[16:11:08.042] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:08.042] - relayed: [n=2] TRUE, TRUE
[16:11:08.042] - queued futures: [n=2] TRUE, TRUE
[16:11:08.042] signalConditionsASAP(NULL, pos=0) ... done
[16:11:08.042] resolve() on list ... DONE
[16:11:08.042] result() for ClusterFuture ...
[16:11:08.042] - result already collected: FutureResult
[16:11:08.043] result() for ClusterFuture ... done
[16:11:08.043] result() for ClusterFuture ...
[16:11:08.043] - result already collected: FutureResult
[16:11:08.043] result() for ClusterFuture ... done
[16:11:08.043] result() for ClusterFuture ...
[16:11:08.043] - result already collected: FutureResult
[16:11:08.043] result() for ClusterFuture ... done
[16:11:08.043] result() for ClusterFuture ...
[16:11:08.043] - result already collected: FutureResult
[16:11:08.043] result() for ClusterFuture ... done
[16:11:08.043]  - Number of value chunks collected: 2
[16:11:08.044] Resolving 2 futures (chunks) ... DONE
[16:11:08.044] Reducing values from 2 chunks ...
[16:11:08.044]  - Number of values collected after concatenation: 4
[16:11:08.044]  - Number of values expected: 4
[16:11:08.044] Reducing values from 2 chunks ... DONE
[16:11:08.044] future_lapply() ... DONE
[16:11:08.045] future_lapply() ...
[16:11:08.050] Number of chunks: 2
[16:11:08.050] getGlobalsAndPackagesXApply() ...
[16:11:08.050]  - future.globals: TRUE
[16:11:08.050] getGlobalsAndPackages() ...
[16:11:08.050] Searching for globals...
[16:11:08.054] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[16:11:08.054] Searching for globals ... DONE
[16:11:08.054] Resolving globals: FALSE
[16:11:08.055] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[16:11:08.055] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:08.056] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:08.056] - packages: [1] ‘future.apply’
[16:11:08.056] getGlobalsAndPackages() ... DONE
[16:11:08.056]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:08.056]  - needed namespaces: [n=1] ‘future.apply’
[16:11:08.056] Finding globals ... DONE
[16:11:08.056]  - use_args: TRUE
[16:11:08.056]  - Getting '...' globals ...
[16:11:08.057] resolve() on list ...
[16:11:08.057]  recursive: 0
[16:11:08.057]  length: 1
[16:11:08.057]  elements: ‘...’
[16:11:08.057]  length: 0 (resolved future 1)
[16:11:08.057] resolve() on list ... DONE
[16:11:08.057]    - '...' content: [n=1] ‘y’
[16:11:08.057] List of 1
[16:11:08.057]  $ ...:List of 1
[16:11:08.057]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:08.057]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:08.057]  - attr(*, "where")=List of 1
[16:11:08.057]   ..$ ...:<environment: 0x561e880cf858> 
[16:11:08.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:08.057]  - attr(*, "resolved")= logi TRUE
[16:11:08.057]  - attr(*, "total_size")= num NA
[16:11:08.060]  - Getting '...' globals ... DONE
[16:11:08.061] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:08.061] List of 8
[16:11:08.061]  $ ...future.FUN:function (x, ...)  
[16:11:08.061]  $ x_FUN        :function (x, y)  
[16:11:08.061]  $ times        : int 15
[16:11:08.061]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:08.061]  $ stop_if_not  :function (...)  
[16:11:08.061]  $ dim          : int [1:2] 3 5
[16:11:08.061]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:08.061]  $ ...          :List of 1
[16:11:08.061]   ..$ y: num [1:5] 2 4 6 8 10
[16:11:08.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:08.061]  - attr(*, "where")=List of 8
[16:11:08.061]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:08.061]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:08.061]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:08.061]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:08.061]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:08.061]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:08.061]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:08.061]   ..$ ...          :<environment: 0x561e880cf858> 
[16:11:08.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:08.061]  - attr(*, "resolved")= logi FALSE
[16:11:08.061]  - attr(*, "total_size")= num 98600
[16:11:08.067] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:08.067] getGlobalsAndPackagesXApply() ... DONE
[16:11:08.067] Number of futures (= number of chunks): 2
[16:11:08.067] Launching 2 futures (chunks) ...
[16:11:08.067] Chunk #1 of 2 ...
[16:11:08.067]  - Finding globals in 'X' for chunk #1 ...
[16:11:08.067] getGlobalsAndPackages() ...
[16:11:08.067] Searching for globals...
[16:11:08.068] 
[16:11:08.068] Searching for globals ... DONE
[16:11:08.068] - globals: [0] <none>
[16:11:08.068] getGlobalsAndPackages() ... DONE
[16:11:08.068]    + additional globals found: [n=0] 
[16:11:08.068]    + additional namespaces needed: [n=0] 
[16:11:08.068]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:08.069]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:08.069]  - seeds: <none>
[16:11:08.069] getGlobalsAndPackages() ...
[16:11:08.069] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.069] Resolving globals: FALSE
[16:11:08.069] Tweak future expression to call with '...' arguments ...
[16:11:08.069] {
[16:11:08.069]     do.call(function(...) {
[16:11:08.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.069]             on.exit(options(oopts), add = TRUE)
[16:11:08.069]         }
[16:11:08.069]         {
[16:11:08.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.069]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.069]             })
[16:11:08.069]         }
[16:11:08.069]     }, args = future.call.arguments)
[16:11:08.069] }
[16:11:08.069] Tweak future expression to call with '...' arguments ... DONE
[16:11:08.070] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.070] - packages: [1] ‘future.apply’
[16:11:08.070] getGlobalsAndPackages() ... DONE
[16:11:08.070] run() for ‘Future’ ...
[16:11:08.071] - state: ‘created’
[16:11:08.071] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:08.085] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.086] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:08.086]   - Field: ‘node’
[16:11:08.086]   - Field: ‘label’
[16:11:08.086]   - Field: ‘local’
[16:11:08.086]   - Field: ‘owner’
[16:11:08.086]   - Field: ‘envir’
[16:11:08.086]   - Field: ‘workers’
[16:11:08.086]   - Field: ‘packages’
[16:11:08.086]   - Field: ‘gc’
[16:11:08.086]   - Field: ‘conditions’
[16:11:08.087]   - Field: ‘persistent’
[16:11:08.087]   - Field: ‘expr’
[16:11:08.087]   - Field: ‘uuid’
[16:11:08.087]   - Field: ‘seed’
[16:11:08.087]   - Field: ‘version’
[16:11:08.087]   - Field: ‘result’
[16:11:08.087]   - Field: ‘asynchronous’
[16:11:08.087]   - Field: ‘calls’
[16:11:08.087]   - Field: ‘globals’
[16:11:08.087]   - Field: ‘stdout’
[16:11:08.087]   - Field: ‘earlySignal’
[16:11:08.088]   - Field: ‘lazy’
[16:11:08.088]   - Field: ‘state’
[16:11:08.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:08.088] - Launch lazy future ...
[16:11:08.088] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:08.088] Packages needed by future strategies (n = 0): <none>
[16:11:08.089] {
[16:11:08.089]     {
[16:11:08.089]         {
[16:11:08.089]             ...future.startTime <- base::Sys.time()
[16:11:08.089]             {
[16:11:08.089]                 {
[16:11:08.089]                   {
[16:11:08.089]                     {
[16:11:08.089]                       {
[16:11:08.089]                         base::local({
[16:11:08.089]                           has_future <- base::requireNamespace("future", 
[16:11:08.089]                             quietly = TRUE)
[16:11:08.089]                           if (has_future) {
[16:11:08.089]                             ns <- base::getNamespace("future")
[16:11:08.089]                             version <- ns[[".package"]][["version"]]
[16:11:08.089]                             if (is.null(version)) 
[16:11:08.089]                               version <- utils::packageVersion("future")
[16:11:08.089]                           }
[16:11:08.089]                           else {
[16:11:08.089]                             version <- NULL
[16:11:08.089]                           }
[16:11:08.089]                           if (!has_future || version < "1.8.0") {
[16:11:08.089]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:08.089]                               "", base::R.version$version.string), 
[16:11:08.089]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:08.089]                                 base::R.version$platform, 8 * 
[16:11:08.089]                                   base::.Machine$sizeof.pointer), 
[16:11:08.089]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:08.089]                                 "release", "version")], collapse = " "), 
[16:11:08.089]                               hostname = base::Sys.info()[["nodename"]])
[16:11:08.089]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:08.089]                               info)
[16:11:08.089]                             info <- base::paste(info, collapse = "; ")
[16:11:08.089]                             if (!has_future) {
[16:11:08.089]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:08.089]                                 info)
[16:11:08.089]                             }
[16:11:08.089]                             else {
[16:11:08.089]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:08.089]                                 info, version)
[16:11:08.089]                             }
[16:11:08.089]                             base::stop(msg)
[16:11:08.089]                           }
[16:11:08.089]                         })
[16:11:08.089]                       }
[16:11:08.089]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:08.089]                       base::options(mc.cores = 1L)
[16:11:08.089]                     }
[16:11:08.089]                     base::local({
[16:11:08.089]                       for (pkg in "future.apply") {
[16:11:08.089]                         base::loadNamespace(pkg)
[16:11:08.089]                         base::library(pkg, character.only = TRUE)
[16:11:08.089]                       }
[16:11:08.089]                     })
[16:11:08.089]                   }
[16:11:08.089]                   options(future.plan = NULL)
[16:11:08.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:08.089]                 }
[16:11:08.089]                 ...future.workdir <- getwd()
[16:11:08.089]             }
[16:11:08.089]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:08.089]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:08.089]         }
[16:11:08.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:08.089]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:08.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:08.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:08.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:08.089]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:08.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:08.089]             base::names(...future.oldOptions))
[16:11:08.089]     }
[16:11:08.089]     if (FALSE) {
[16:11:08.089]     }
[16:11:08.089]     else {
[16:11:08.089]         if (TRUE) {
[16:11:08.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:08.089]                 open = "w")
[16:11:08.089]         }
[16:11:08.089]         else {
[16:11:08.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:08.089]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:08.089]         }
[16:11:08.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:08.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:08.089]             base::sink(type = "output", split = FALSE)
[16:11:08.089]             base::close(...future.stdout)
[16:11:08.089]         }, add = TRUE)
[16:11:08.089]     }
[16:11:08.089]     ...future.frame <- base::sys.nframe()
[16:11:08.089]     ...future.conditions <- base::list()
[16:11:08.089]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:08.089]     if (FALSE) {
[16:11:08.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:08.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:08.089]     }
[16:11:08.089]     ...future.result <- base::tryCatch({
[16:11:08.089]         base::withCallingHandlers({
[16:11:08.089]             ...future.value <- base::withVisible(base::local({
[16:11:08.089]                 ...future.makeSendCondition <- local({
[16:11:08.089]                   sendCondition <- NULL
[16:11:08.089]                   function(frame = 1L) {
[16:11:08.089]                     if (is.function(sendCondition)) 
[16:11:08.089]                       return(sendCondition)
[16:11:08.089]                     ns <- getNamespace("parallel")
[16:11:08.089]                     if (exists("sendData", mode = "function", 
[16:11:08.089]                       envir = ns)) {
[16:11:08.089]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:08.089]                         envir = ns)
[16:11:08.089]                       envir <- sys.frame(frame)
[16:11:08.089]                       master <- NULL
[16:11:08.089]                       while (!identical(envir, .GlobalEnv) && 
[16:11:08.089]                         !identical(envir, emptyenv())) {
[16:11:08.089]                         if (exists("master", mode = "list", envir = envir, 
[16:11:08.089]                           inherits = FALSE)) {
[16:11:08.089]                           master <- get("master", mode = "list", 
[16:11:08.089]                             envir = envir, inherits = FALSE)
[16:11:08.089]                           if (inherits(master, c("SOCKnode", 
[16:11:08.089]                             "SOCK0node"))) {
[16:11:08.089]                             sendCondition <<- function(cond) {
[16:11:08.089]                               data <- list(type = "VALUE", value = cond, 
[16:11:08.089]                                 success = TRUE)
[16:11:08.089]                               parallel_sendData(master, data)
[16:11:08.089]                             }
[16:11:08.089]                             return(sendCondition)
[16:11:08.089]                           }
[16:11:08.089]                         }
[16:11:08.089]                         frame <- frame + 1L
[16:11:08.089]                         envir <- sys.frame(frame)
[16:11:08.089]                       }
[16:11:08.089]                     }
[16:11:08.089]                     sendCondition <<- function(cond) NULL
[16:11:08.089]                   }
[16:11:08.089]                 })
[16:11:08.089]                 withCallingHandlers({
[16:11:08.089]                   {
[16:11:08.089]                     do.call(function(...) {
[16:11:08.089]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.089]                       if (!identical(...future.globals.maxSize.org, 
[16:11:08.089]                         ...future.globals.maxSize)) {
[16:11:08.089]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.089]                         on.exit(options(oopts), add = TRUE)
[16:11:08.089]                       }
[16:11:08.089]                       {
[16:11:08.089]                         lapply(seq_along(...future.elements_ii), 
[16:11:08.089]                           FUN = function(jj) {
[16:11:08.089]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.089]                             ...future.FUN(...future.X_jj, ...)
[16:11:08.089]                           })
[16:11:08.089]                       }
[16:11:08.089]                     }, args = future.call.arguments)
[16:11:08.089]                   }
[16:11:08.089]                 }, immediateCondition = function(cond) {
[16:11:08.089]                   sendCondition <- ...future.makeSendCondition()
[16:11:08.089]                   sendCondition(cond)
[16:11:08.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.089]                   {
[16:11:08.089]                     inherits <- base::inherits
[16:11:08.089]                     invokeRestart <- base::invokeRestart
[16:11:08.089]                     is.null <- base::is.null
[16:11:08.089]                     muffled <- FALSE
[16:11:08.089]                     if (inherits(cond, "message")) {
[16:11:08.089]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:08.089]                       if (muffled) 
[16:11:08.089]                         invokeRestart("muffleMessage")
[16:11:08.089]                     }
[16:11:08.089]                     else if (inherits(cond, "warning")) {
[16:11:08.089]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:08.089]                       if (muffled) 
[16:11:08.089]                         invokeRestart("muffleWarning")
[16:11:08.089]                     }
[16:11:08.089]                     else if (inherits(cond, "condition")) {
[16:11:08.089]                       if (!is.null(pattern)) {
[16:11:08.089]                         computeRestarts <- base::computeRestarts
[16:11:08.089]                         grepl <- base::grepl
[16:11:08.089]                         restarts <- computeRestarts(cond)
[16:11:08.089]                         for (restart in restarts) {
[16:11:08.089]                           name <- restart$name
[16:11:08.089]                           if (is.null(name)) 
[16:11:08.089]                             next
[16:11:08.089]                           if (!grepl(pattern, name)) 
[16:11:08.089]                             next
[16:11:08.089]                           invokeRestart(restart)
[16:11:08.089]                           muffled <- TRUE
[16:11:08.089]                           break
[16:11:08.089]                         }
[16:11:08.089]                       }
[16:11:08.089]                     }
[16:11:08.089]                     invisible(muffled)
[16:11:08.089]                   }
[16:11:08.089]                   muffleCondition(cond)
[16:11:08.089]                 })
[16:11:08.089]             }))
[16:11:08.089]             future::FutureResult(value = ...future.value$value, 
[16:11:08.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.089]                   ...future.rng), globalenv = if (FALSE) 
[16:11:08.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:08.089]                     ...future.globalenv.names))
[16:11:08.089]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:08.089]         }, condition = base::local({
[16:11:08.089]             c <- base::c
[16:11:08.089]             inherits <- base::inherits
[16:11:08.089]             invokeRestart <- base::invokeRestart
[16:11:08.089]             length <- base::length
[16:11:08.089]             list <- base::list
[16:11:08.089]             seq.int <- base::seq.int
[16:11:08.089]             signalCondition <- base::signalCondition
[16:11:08.089]             sys.calls <- base::sys.calls
[16:11:08.089]             `[[` <- base::`[[`
[16:11:08.089]             `+` <- base::`+`
[16:11:08.089]             `<<-` <- base::`<<-`
[16:11:08.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:08.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:08.089]                   3L)]
[16:11:08.089]             }
[16:11:08.089]             function(cond) {
[16:11:08.089]                 is_error <- inherits(cond, "error")
[16:11:08.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:08.089]                   NULL)
[16:11:08.089]                 if (is_error) {
[16:11:08.089]                   sessionInformation <- function() {
[16:11:08.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:08.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:08.089]                       search = base::search(), system = base::Sys.info())
[16:11:08.089]                   }
[16:11:08.089]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:08.089]                     cond$call), session = sessionInformation(), 
[16:11:08.089]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:08.089]                   signalCondition(cond)
[16:11:08.089]                 }
[16:11:08.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:08.089]                 "immediateCondition"))) {
[16:11:08.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:08.089]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:08.089]                   if (TRUE && !signal) {
[16:11:08.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.089]                     {
[16:11:08.089]                       inherits <- base::inherits
[16:11:08.089]                       invokeRestart <- base::invokeRestart
[16:11:08.089]                       is.null <- base::is.null
[16:11:08.089]                       muffled <- FALSE
[16:11:08.089]                       if (inherits(cond, "message")) {
[16:11:08.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.089]                         if (muffled) 
[16:11:08.089]                           invokeRestart("muffleMessage")
[16:11:08.089]                       }
[16:11:08.089]                       else if (inherits(cond, "warning")) {
[16:11:08.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.089]                         if (muffled) 
[16:11:08.089]                           invokeRestart("muffleWarning")
[16:11:08.089]                       }
[16:11:08.089]                       else if (inherits(cond, "condition")) {
[16:11:08.089]                         if (!is.null(pattern)) {
[16:11:08.089]                           computeRestarts <- base::computeRestarts
[16:11:08.089]                           grepl <- base::grepl
[16:11:08.089]                           restarts <- computeRestarts(cond)
[16:11:08.089]                           for (restart in restarts) {
[16:11:08.089]                             name <- restart$name
[16:11:08.089]                             if (is.null(name)) 
[16:11:08.089]                               next
[16:11:08.089]                             if (!grepl(pattern, name)) 
[16:11:08.089]                               next
[16:11:08.089]                             invokeRestart(restart)
[16:11:08.089]                             muffled <- TRUE
[16:11:08.089]                             break
[16:11:08.089]                           }
[16:11:08.089]                         }
[16:11:08.089]                       }
[16:11:08.089]                       invisible(muffled)
[16:11:08.089]                     }
[16:11:08.089]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.089]                   }
[16:11:08.089]                 }
[16:11:08.089]                 else {
[16:11:08.089]                   if (TRUE) {
[16:11:08.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.089]                     {
[16:11:08.089]                       inherits <- base::inherits
[16:11:08.089]                       invokeRestart <- base::invokeRestart
[16:11:08.089]                       is.null <- base::is.null
[16:11:08.089]                       muffled <- FALSE
[16:11:08.089]                       if (inherits(cond, "message")) {
[16:11:08.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.089]                         if (muffled) 
[16:11:08.089]                           invokeRestart("muffleMessage")
[16:11:08.089]                       }
[16:11:08.089]                       else if (inherits(cond, "warning")) {
[16:11:08.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.089]                         if (muffled) 
[16:11:08.089]                           invokeRestart("muffleWarning")
[16:11:08.089]                       }
[16:11:08.089]                       else if (inherits(cond, "condition")) {
[16:11:08.089]                         if (!is.null(pattern)) {
[16:11:08.089]                           computeRestarts <- base::computeRestarts
[16:11:08.089]                           grepl <- base::grepl
[16:11:08.089]                           restarts <- computeRestarts(cond)
[16:11:08.089]                           for (restart in restarts) {
[16:11:08.089]                             name <- restart$name
[16:11:08.089]                             if (is.null(name)) 
[16:11:08.089]                               next
[16:11:08.089]                             if (!grepl(pattern, name)) 
[16:11:08.089]                               next
[16:11:08.089]                             invokeRestart(restart)
[16:11:08.089]                             muffled <- TRUE
[16:11:08.089]                             break
[16:11:08.089]                           }
[16:11:08.089]                         }
[16:11:08.089]                       }
[16:11:08.089]                       invisible(muffled)
[16:11:08.089]                     }
[16:11:08.089]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.089]                   }
[16:11:08.089]                 }
[16:11:08.089]             }
[16:11:08.089]         }))
[16:11:08.089]     }, error = function(ex) {
[16:11:08.089]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:08.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.089]                 ...future.rng), started = ...future.startTime, 
[16:11:08.089]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:08.089]             version = "1.8"), class = "FutureResult")
[16:11:08.089]     }, finally = {
[16:11:08.089]         if (!identical(...future.workdir, getwd())) 
[16:11:08.089]             setwd(...future.workdir)
[16:11:08.089]         {
[16:11:08.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:08.089]                 ...future.oldOptions$nwarnings <- NULL
[16:11:08.089]             }
[16:11:08.089]             base::options(...future.oldOptions)
[16:11:08.089]             if (.Platform$OS.type == "windows") {
[16:11:08.089]                 old_names <- names(...future.oldEnvVars)
[16:11:08.089]                 envs <- base::Sys.getenv()
[16:11:08.089]                 names <- names(envs)
[16:11:08.089]                 common <- intersect(names, old_names)
[16:11:08.089]                 added <- setdiff(names, old_names)
[16:11:08.089]                 removed <- setdiff(old_names, names)
[16:11:08.089]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:08.089]                   envs[common]]
[16:11:08.089]                 NAMES <- toupper(changed)
[16:11:08.089]                 args <- list()
[16:11:08.089]                 for (kk in seq_along(NAMES)) {
[16:11:08.089]                   name <- changed[[kk]]
[16:11:08.089]                   NAME <- NAMES[[kk]]
[16:11:08.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.089]                     next
[16:11:08.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.089]                 }
[16:11:08.089]                 NAMES <- toupper(added)
[16:11:08.089]                 for (kk in seq_along(NAMES)) {
[16:11:08.089]                   name <- added[[kk]]
[16:11:08.089]                   NAME <- NAMES[[kk]]
[16:11:08.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.089]                     next
[16:11:08.089]                   args[[name]] <- ""
[16:11:08.089]                 }
[16:11:08.089]                 NAMES <- toupper(removed)
[16:11:08.089]                 for (kk in seq_along(NAMES)) {
[16:11:08.089]                   name <- removed[[kk]]
[16:11:08.089]                   NAME <- NAMES[[kk]]
[16:11:08.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.089]                     next
[16:11:08.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.089]                 }
[16:11:08.089]                 if (length(args) > 0) 
[16:11:08.089]                   base::do.call(base::Sys.setenv, args = args)
[16:11:08.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:08.089]             }
[16:11:08.089]             else {
[16:11:08.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:08.089]             }
[16:11:08.089]             {
[16:11:08.089]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:08.089]                   0L) {
[16:11:08.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:08.089]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:08.089]                   base::options(opts)
[16:11:08.089]                 }
[16:11:08.089]                 {
[16:11:08.089]                   {
[16:11:08.089]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:08.089]                     NULL
[16:11:08.089]                   }
[16:11:08.089]                   options(future.plan = NULL)
[16:11:08.089]                   if (is.na(NA_character_)) 
[16:11:08.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:08.089]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:08.089]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:08.089]                     envir = parent.frame()) 
[16:11:08.089]                   {
[16:11:08.089]                     if (is.function(workers)) 
[16:11:08.089]                       workers <- workers()
[16:11:08.089]                     workers <- structure(as.integer(workers), 
[16:11:08.089]                       class = class(workers))
[16:11:08.089]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:08.089]                       workers >= 1)
[16:11:08.089]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:08.089]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:08.089]                     }
[16:11:08.089]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:08.089]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:08.089]                       envir = envir)
[16:11:08.089]                     if (!future$lazy) 
[16:11:08.089]                       future <- run(future)
[16:11:08.089]                     invisible(future)
[16:11:08.089]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:08.089]                 }
[16:11:08.089]             }
[16:11:08.089]         }
[16:11:08.089]     })
[16:11:08.089]     if (TRUE) {
[16:11:08.089]         base::sink(type = "output", split = FALSE)
[16:11:08.089]         if (TRUE) {
[16:11:08.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:08.089]         }
[16:11:08.089]         else {
[16:11:08.089]             ...future.result["stdout"] <- base::list(NULL)
[16:11:08.089]         }
[16:11:08.089]         base::close(...future.stdout)
[16:11:08.089]         ...future.stdout <- NULL
[16:11:08.089]     }
[16:11:08.089]     ...future.result$conditions <- ...future.conditions
[16:11:08.089]     ...future.result$finished <- base::Sys.time()
[16:11:08.089]     ...future.result
[16:11:08.089] }
[16:11:08.092] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[16:11:08.092] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:08.136] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:08.136] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[16:11:08.137] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[16:11:08.137] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:08.137] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:08.137] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:08.180] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:08.180] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:08.224] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:08.224] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[16:11:08.225] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[16:11:08.225] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:08.225] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:08.226] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[16:11:08.226] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[16:11:08.226] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:11:08.227] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:11:08.227] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:08.227] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:08.227] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:08.231] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:08.231] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[16:11:08.231] MultisessionFuture started
[16:11:08.232] - Launch lazy future ... done
[16:11:08.232] run() for ‘MultisessionFuture’ ... done
[16:11:08.232] Created future:
[16:11:08.232] MultisessionFuture:
[16:11:08.232] Label: ‘future_vapply-1’
[16:11:08.232] Expression:
[16:11:08.232] {
[16:11:08.232]     do.call(function(...) {
[16:11:08.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.232]             on.exit(options(oopts), add = TRUE)
[16:11:08.232]         }
[16:11:08.232]         {
[16:11:08.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.232]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.232]             })
[16:11:08.232]         }
[16:11:08.232]     }, args = future.call.arguments)
[16:11:08.232] }
[16:11:08.232] Lazy evaluation: FALSE
[16:11:08.232] Asynchronous evaluation: TRUE
[16:11:08.232] Local evaluation: TRUE
[16:11:08.232] Environment: R_GlobalEnv
[16:11:08.232] Capture standard output: TRUE
[16:11:08.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:08.232] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:08.232] Packages: 1 packages (‘future.apply’)
[16:11:08.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:08.232] Resolved: FALSE
[16:11:08.232] Value: <not collected>
[16:11:08.232] Conditions captured: <none>
[16:11:08.232] Early signaling: FALSE
[16:11:08.232] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:08.232] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.244] Chunk #1 of 2 ... DONE
[16:11:08.244] Chunk #2 of 2 ...
[16:11:08.244]  - Finding globals in 'X' for chunk #2 ...
[16:11:08.244] getGlobalsAndPackages() ...
[16:11:08.244] Searching for globals...
[16:11:08.245] 
[16:11:08.245] Searching for globals ... DONE
[16:11:08.245] - globals: [0] <none>
[16:11:08.245] getGlobalsAndPackages() ... DONE
[16:11:08.245]    + additional globals found: [n=0] 
[16:11:08.245]    + additional namespaces needed: [n=0] 
[16:11:08.245]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:08.245]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:08.246]  - seeds: <none>
[16:11:08.246] getGlobalsAndPackages() ...
[16:11:08.246] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.246] Resolving globals: FALSE
[16:11:08.246] Tweak future expression to call with '...' arguments ...
[16:11:08.246] {
[16:11:08.246]     do.call(function(...) {
[16:11:08.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.246]             on.exit(options(oopts), add = TRUE)
[16:11:08.246]         }
[16:11:08.246]         {
[16:11:08.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.246]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.246]             })
[16:11:08.246]         }
[16:11:08.246]     }, args = future.call.arguments)
[16:11:08.246] }
[16:11:08.246] Tweak future expression to call with '...' arguments ... DONE
[16:11:08.247] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.247] - packages: [1] ‘future.apply’
[16:11:08.247] getGlobalsAndPackages() ... DONE
[16:11:08.248] run() for ‘Future’ ...
[16:11:08.248] - state: ‘created’
[16:11:08.248] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:08.262] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:08.263]   - Field: ‘node’
[16:11:08.263]   - Field: ‘label’
[16:11:08.263]   - Field: ‘local’
[16:11:08.263]   - Field: ‘owner’
[16:11:08.263]   - Field: ‘envir’
[16:11:08.263]   - Field: ‘workers’
[16:11:08.263]   - Field: ‘packages’
[16:11:08.263]   - Field: ‘gc’
[16:11:08.263]   - Field: ‘conditions’
[16:11:08.264]   - Field: ‘persistent’
[16:11:08.264]   - Field: ‘expr’
[16:11:08.264]   - Field: ‘uuid’
[16:11:08.264]   - Field: ‘seed’
[16:11:08.264]   - Field: ‘version’
[16:11:08.264]   - Field: ‘result’
[16:11:08.264]   - Field: ‘asynchronous’
[16:11:08.264]   - Field: ‘calls’
[16:11:08.264]   - Field: ‘globals’
[16:11:08.264]   - Field: ‘stdout’
[16:11:08.264]   - Field: ‘earlySignal’
[16:11:08.265]   - Field: ‘lazy’
[16:11:08.265]   - Field: ‘state’
[16:11:08.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:08.265] - Launch lazy future ...
[16:11:08.265] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:08.265] Packages needed by future strategies (n = 0): <none>
[16:11:08.266] {
[16:11:08.266]     {
[16:11:08.266]         {
[16:11:08.266]             ...future.startTime <- base::Sys.time()
[16:11:08.266]             {
[16:11:08.266]                 {
[16:11:08.266]                   {
[16:11:08.266]                     {
[16:11:08.266]                       {
[16:11:08.266]                         base::local({
[16:11:08.266]                           has_future <- base::requireNamespace("future", 
[16:11:08.266]                             quietly = TRUE)
[16:11:08.266]                           if (has_future) {
[16:11:08.266]                             ns <- base::getNamespace("future")
[16:11:08.266]                             version <- ns[[".package"]][["version"]]
[16:11:08.266]                             if (is.null(version)) 
[16:11:08.266]                               version <- utils::packageVersion("future")
[16:11:08.266]                           }
[16:11:08.266]                           else {
[16:11:08.266]                             version <- NULL
[16:11:08.266]                           }
[16:11:08.266]                           if (!has_future || version < "1.8.0") {
[16:11:08.266]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:08.266]                               "", base::R.version$version.string), 
[16:11:08.266]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:08.266]                                 base::R.version$platform, 8 * 
[16:11:08.266]                                   base::.Machine$sizeof.pointer), 
[16:11:08.266]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:08.266]                                 "release", "version")], collapse = " "), 
[16:11:08.266]                               hostname = base::Sys.info()[["nodename"]])
[16:11:08.266]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:08.266]                               info)
[16:11:08.266]                             info <- base::paste(info, collapse = "; ")
[16:11:08.266]                             if (!has_future) {
[16:11:08.266]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:08.266]                                 info)
[16:11:08.266]                             }
[16:11:08.266]                             else {
[16:11:08.266]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:08.266]                                 info, version)
[16:11:08.266]                             }
[16:11:08.266]                             base::stop(msg)
[16:11:08.266]                           }
[16:11:08.266]                         })
[16:11:08.266]                       }
[16:11:08.266]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:08.266]                       base::options(mc.cores = 1L)
[16:11:08.266]                     }
[16:11:08.266]                     base::local({
[16:11:08.266]                       for (pkg in "future.apply") {
[16:11:08.266]                         base::loadNamespace(pkg)
[16:11:08.266]                         base::library(pkg, character.only = TRUE)
[16:11:08.266]                       }
[16:11:08.266]                     })
[16:11:08.266]                   }
[16:11:08.266]                   options(future.plan = NULL)
[16:11:08.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:08.266]                 }
[16:11:08.266]                 ...future.workdir <- getwd()
[16:11:08.266]             }
[16:11:08.266]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:08.266]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:08.266]         }
[16:11:08.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:08.266]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:08.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:08.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:08.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:08.266]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:08.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:08.266]             base::names(...future.oldOptions))
[16:11:08.266]     }
[16:11:08.266]     if (FALSE) {
[16:11:08.266]     }
[16:11:08.266]     else {
[16:11:08.266]         if (TRUE) {
[16:11:08.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:08.266]                 open = "w")
[16:11:08.266]         }
[16:11:08.266]         else {
[16:11:08.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:08.266]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:08.266]         }
[16:11:08.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:08.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:08.266]             base::sink(type = "output", split = FALSE)
[16:11:08.266]             base::close(...future.stdout)
[16:11:08.266]         }, add = TRUE)
[16:11:08.266]     }
[16:11:08.266]     ...future.frame <- base::sys.nframe()
[16:11:08.266]     ...future.conditions <- base::list()
[16:11:08.266]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:08.266]     if (FALSE) {
[16:11:08.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:08.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:08.266]     }
[16:11:08.266]     ...future.result <- base::tryCatch({
[16:11:08.266]         base::withCallingHandlers({
[16:11:08.266]             ...future.value <- base::withVisible(base::local({
[16:11:08.266]                 ...future.makeSendCondition <- local({
[16:11:08.266]                   sendCondition <- NULL
[16:11:08.266]                   function(frame = 1L) {
[16:11:08.266]                     if (is.function(sendCondition)) 
[16:11:08.266]                       return(sendCondition)
[16:11:08.266]                     ns <- getNamespace("parallel")
[16:11:08.266]                     if (exists("sendData", mode = "function", 
[16:11:08.266]                       envir = ns)) {
[16:11:08.266]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:08.266]                         envir = ns)
[16:11:08.266]                       envir <- sys.frame(frame)
[16:11:08.266]                       master <- NULL
[16:11:08.266]                       while (!identical(envir, .GlobalEnv) && 
[16:11:08.266]                         !identical(envir, emptyenv())) {
[16:11:08.266]                         if (exists("master", mode = "list", envir = envir, 
[16:11:08.266]                           inherits = FALSE)) {
[16:11:08.266]                           master <- get("master", mode = "list", 
[16:11:08.266]                             envir = envir, inherits = FALSE)
[16:11:08.266]                           if (inherits(master, c("SOCKnode", 
[16:11:08.266]                             "SOCK0node"))) {
[16:11:08.266]                             sendCondition <<- function(cond) {
[16:11:08.266]                               data <- list(type = "VALUE", value = cond, 
[16:11:08.266]                                 success = TRUE)
[16:11:08.266]                               parallel_sendData(master, data)
[16:11:08.266]                             }
[16:11:08.266]                             return(sendCondition)
[16:11:08.266]                           }
[16:11:08.266]                         }
[16:11:08.266]                         frame <- frame + 1L
[16:11:08.266]                         envir <- sys.frame(frame)
[16:11:08.266]                       }
[16:11:08.266]                     }
[16:11:08.266]                     sendCondition <<- function(cond) NULL
[16:11:08.266]                   }
[16:11:08.266]                 })
[16:11:08.266]                 withCallingHandlers({
[16:11:08.266]                   {
[16:11:08.266]                     do.call(function(...) {
[16:11:08.266]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.266]                       if (!identical(...future.globals.maxSize.org, 
[16:11:08.266]                         ...future.globals.maxSize)) {
[16:11:08.266]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.266]                         on.exit(options(oopts), add = TRUE)
[16:11:08.266]                       }
[16:11:08.266]                       {
[16:11:08.266]                         lapply(seq_along(...future.elements_ii), 
[16:11:08.266]                           FUN = function(jj) {
[16:11:08.266]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.266]                             ...future.FUN(...future.X_jj, ...)
[16:11:08.266]                           })
[16:11:08.266]                       }
[16:11:08.266]                     }, args = future.call.arguments)
[16:11:08.266]                   }
[16:11:08.266]                 }, immediateCondition = function(cond) {
[16:11:08.266]                   sendCondition <- ...future.makeSendCondition()
[16:11:08.266]                   sendCondition(cond)
[16:11:08.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.266]                   {
[16:11:08.266]                     inherits <- base::inherits
[16:11:08.266]                     invokeRestart <- base::invokeRestart
[16:11:08.266]                     is.null <- base::is.null
[16:11:08.266]                     muffled <- FALSE
[16:11:08.266]                     if (inherits(cond, "message")) {
[16:11:08.266]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:08.266]                       if (muffled) 
[16:11:08.266]                         invokeRestart("muffleMessage")
[16:11:08.266]                     }
[16:11:08.266]                     else if (inherits(cond, "warning")) {
[16:11:08.266]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:08.266]                       if (muffled) 
[16:11:08.266]                         invokeRestart("muffleWarning")
[16:11:08.266]                     }
[16:11:08.266]                     else if (inherits(cond, "condition")) {
[16:11:08.266]                       if (!is.null(pattern)) {
[16:11:08.266]                         computeRestarts <- base::computeRestarts
[16:11:08.266]                         grepl <- base::grepl
[16:11:08.266]                         restarts <- computeRestarts(cond)
[16:11:08.266]                         for (restart in restarts) {
[16:11:08.266]                           name <- restart$name
[16:11:08.266]                           if (is.null(name)) 
[16:11:08.266]                             next
[16:11:08.266]                           if (!grepl(pattern, name)) 
[16:11:08.266]                             next
[16:11:08.266]                           invokeRestart(restart)
[16:11:08.266]                           muffled <- TRUE
[16:11:08.266]                           break
[16:11:08.266]                         }
[16:11:08.266]                       }
[16:11:08.266]                     }
[16:11:08.266]                     invisible(muffled)
[16:11:08.266]                   }
[16:11:08.266]                   muffleCondition(cond)
[16:11:08.266]                 })
[16:11:08.266]             }))
[16:11:08.266]             future::FutureResult(value = ...future.value$value, 
[16:11:08.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.266]                   ...future.rng), globalenv = if (FALSE) 
[16:11:08.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:08.266]                     ...future.globalenv.names))
[16:11:08.266]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:08.266]         }, condition = base::local({
[16:11:08.266]             c <- base::c
[16:11:08.266]             inherits <- base::inherits
[16:11:08.266]             invokeRestart <- base::invokeRestart
[16:11:08.266]             length <- base::length
[16:11:08.266]             list <- base::list
[16:11:08.266]             seq.int <- base::seq.int
[16:11:08.266]             signalCondition <- base::signalCondition
[16:11:08.266]             sys.calls <- base::sys.calls
[16:11:08.266]             `[[` <- base::`[[`
[16:11:08.266]             `+` <- base::`+`
[16:11:08.266]             `<<-` <- base::`<<-`
[16:11:08.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:08.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:08.266]                   3L)]
[16:11:08.266]             }
[16:11:08.266]             function(cond) {
[16:11:08.266]                 is_error <- inherits(cond, "error")
[16:11:08.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:08.266]                   NULL)
[16:11:08.266]                 if (is_error) {
[16:11:08.266]                   sessionInformation <- function() {
[16:11:08.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:08.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:08.266]                       search = base::search(), system = base::Sys.info())
[16:11:08.266]                   }
[16:11:08.266]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:08.266]                     cond$call), session = sessionInformation(), 
[16:11:08.266]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:08.266]                   signalCondition(cond)
[16:11:08.266]                 }
[16:11:08.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:08.266]                 "immediateCondition"))) {
[16:11:08.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:08.266]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:08.266]                   if (TRUE && !signal) {
[16:11:08.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.266]                     {
[16:11:08.266]                       inherits <- base::inherits
[16:11:08.266]                       invokeRestart <- base::invokeRestart
[16:11:08.266]                       is.null <- base::is.null
[16:11:08.266]                       muffled <- FALSE
[16:11:08.266]                       if (inherits(cond, "message")) {
[16:11:08.266]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.266]                         if (muffled) 
[16:11:08.266]                           invokeRestart("muffleMessage")
[16:11:08.266]                       }
[16:11:08.266]                       else if (inherits(cond, "warning")) {
[16:11:08.266]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.266]                         if (muffled) 
[16:11:08.266]                           invokeRestart("muffleWarning")
[16:11:08.266]                       }
[16:11:08.266]                       else if (inherits(cond, "condition")) {
[16:11:08.266]                         if (!is.null(pattern)) {
[16:11:08.266]                           computeRestarts <- base::computeRestarts
[16:11:08.266]                           grepl <- base::grepl
[16:11:08.266]                           restarts <- computeRestarts(cond)
[16:11:08.266]                           for (restart in restarts) {
[16:11:08.266]                             name <- restart$name
[16:11:08.266]                             if (is.null(name)) 
[16:11:08.266]                               next
[16:11:08.266]                             if (!grepl(pattern, name)) 
[16:11:08.266]                               next
[16:11:08.266]                             invokeRestart(restart)
[16:11:08.266]                             muffled <- TRUE
[16:11:08.266]                             break
[16:11:08.266]                           }
[16:11:08.266]                         }
[16:11:08.266]                       }
[16:11:08.266]                       invisible(muffled)
[16:11:08.266]                     }
[16:11:08.266]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.266]                   }
[16:11:08.266]                 }
[16:11:08.266]                 else {
[16:11:08.266]                   if (TRUE) {
[16:11:08.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.266]                     {
[16:11:08.266]                       inherits <- base::inherits
[16:11:08.266]                       invokeRestart <- base::invokeRestart
[16:11:08.266]                       is.null <- base::is.null
[16:11:08.266]                       muffled <- FALSE
[16:11:08.266]                       if (inherits(cond, "message")) {
[16:11:08.266]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.266]                         if (muffled) 
[16:11:08.266]                           invokeRestart("muffleMessage")
[16:11:08.266]                       }
[16:11:08.266]                       else if (inherits(cond, "warning")) {
[16:11:08.266]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.266]                         if (muffled) 
[16:11:08.266]                           invokeRestart("muffleWarning")
[16:11:08.266]                       }
[16:11:08.266]                       else if (inherits(cond, "condition")) {
[16:11:08.266]                         if (!is.null(pattern)) {
[16:11:08.266]                           computeRestarts <- base::computeRestarts
[16:11:08.266]                           grepl <- base::grepl
[16:11:08.266]                           restarts <- computeRestarts(cond)
[16:11:08.266]                           for (restart in restarts) {
[16:11:08.266]                             name <- restart$name
[16:11:08.266]                             if (is.null(name)) 
[16:11:08.266]                               next
[16:11:08.266]                             if (!grepl(pattern, name)) 
[16:11:08.266]                               next
[16:11:08.266]                             invokeRestart(restart)
[16:11:08.266]                             muffled <- TRUE
[16:11:08.266]                             break
[16:11:08.266]                           }
[16:11:08.266]                         }
[16:11:08.266]                       }
[16:11:08.266]                       invisible(muffled)
[16:11:08.266]                     }
[16:11:08.266]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.266]                   }
[16:11:08.266]                 }
[16:11:08.266]             }
[16:11:08.266]         }))
[16:11:08.266]     }, error = function(ex) {
[16:11:08.266]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:08.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.266]                 ...future.rng), started = ...future.startTime, 
[16:11:08.266]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:08.266]             version = "1.8"), class = "FutureResult")
[16:11:08.266]     }, finally = {
[16:11:08.266]         if (!identical(...future.workdir, getwd())) 
[16:11:08.266]             setwd(...future.workdir)
[16:11:08.266]         {
[16:11:08.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:08.266]                 ...future.oldOptions$nwarnings <- NULL
[16:11:08.266]             }
[16:11:08.266]             base::options(...future.oldOptions)
[16:11:08.266]             if (.Platform$OS.type == "windows") {
[16:11:08.266]                 old_names <- names(...future.oldEnvVars)
[16:11:08.266]                 envs <- base::Sys.getenv()
[16:11:08.266]                 names <- names(envs)
[16:11:08.266]                 common <- intersect(names, old_names)
[16:11:08.266]                 added <- setdiff(names, old_names)
[16:11:08.266]                 removed <- setdiff(old_names, names)
[16:11:08.266]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:08.266]                   envs[common]]
[16:11:08.266]                 NAMES <- toupper(changed)
[16:11:08.266]                 args <- list()
[16:11:08.266]                 for (kk in seq_along(NAMES)) {
[16:11:08.266]                   name <- changed[[kk]]
[16:11:08.266]                   NAME <- NAMES[[kk]]
[16:11:08.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.266]                     next
[16:11:08.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.266]                 }
[16:11:08.266]                 NAMES <- toupper(added)
[16:11:08.266]                 for (kk in seq_along(NAMES)) {
[16:11:08.266]                   name <- added[[kk]]
[16:11:08.266]                   NAME <- NAMES[[kk]]
[16:11:08.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.266]                     next
[16:11:08.266]                   args[[name]] <- ""
[16:11:08.266]                 }
[16:11:08.266]                 NAMES <- toupper(removed)
[16:11:08.266]                 for (kk in seq_along(NAMES)) {
[16:11:08.266]                   name <- removed[[kk]]
[16:11:08.266]                   NAME <- NAMES[[kk]]
[16:11:08.266]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.266]                     next
[16:11:08.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.266]                 }
[16:11:08.266]                 if (length(args) > 0) 
[16:11:08.266]                   base::do.call(base::Sys.setenv, args = args)
[16:11:08.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:08.266]             }
[16:11:08.266]             else {
[16:11:08.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:08.266]             }
[16:11:08.266]             {
[16:11:08.266]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:08.266]                   0L) {
[16:11:08.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:08.266]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:08.266]                   base::options(opts)
[16:11:08.266]                 }
[16:11:08.266]                 {
[16:11:08.266]                   {
[16:11:08.266]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:08.266]                     NULL
[16:11:08.266]                   }
[16:11:08.266]                   options(future.plan = NULL)
[16:11:08.266]                   if (is.na(NA_character_)) 
[16:11:08.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:08.266]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:08.266]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:08.266]                     envir = parent.frame()) 
[16:11:08.266]                   {
[16:11:08.266]                     if (is.function(workers)) 
[16:11:08.266]                       workers <- workers()
[16:11:08.266]                     workers <- structure(as.integer(workers), 
[16:11:08.266]                       class = class(workers))
[16:11:08.266]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:08.266]                       workers >= 1)
[16:11:08.266]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:08.266]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:08.266]                     }
[16:11:08.266]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:08.266]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:08.266]                       envir = envir)
[16:11:08.266]                     if (!future$lazy) 
[16:11:08.266]                       future <- run(future)
[16:11:08.266]                     invisible(future)
[16:11:08.266]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:08.266]                 }
[16:11:08.266]             }
[16:11:08.266]         }
[16:11:08.266]     })
[16:11:08.266]     if (TRUE) {
[16:11:08.266]         base::sink(type = "output", split = FALSE)
[16:11:08.266]         if (TRUE) {
[16:11:08.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:08.266]         }
[16:11:08.266]         else {
[16:11:08.266]             ...future.result["stdout"] <- base::list(NULL)
[16:11:08.266]         }
[16:11:08.266]         base::close(...future.stdout)
[16:11:08.266]         ...future.stdout <- NULL
[16:11:08.266]     }
[16:11:08.266]     ...future.result$conditions <- ...future.conditions
[16:11:08.266]     ...future.result$finished <- base::Sys.time()
[16:11:08.266]     ...future.result
[16:11:08.266] }
[16:11:08.269] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[16:11:08.269] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:08.312] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:08.312] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[16:11:08.313] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[16:11:08.313] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:08.313] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:08.314] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:08.356] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:08.356] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:08.400] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:08.400] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[16:11:08.401] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[16:11:08.401] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:08.401] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:08.401] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[16:11:08.402] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[16:11:08.402] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:11:08.402] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:11:08.402] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:08.403] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:08.403] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:08.403] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:08.403] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[16:11:08.404] MultisessionFuture started
[16:11:08.404] - Launch lazy future ... done
[16:11:08.404] run() for ‘MultisessionFuture’ ... done
[16:11:08.405] Created future:
[16:11:08.405] MultisessionFuture:
[16:11:08.405] Label: ‘future_vapply-2’
[16:11:08.405] Expression:
[16:11:08.405] {
[16:11:08.405]     do.call(function(...) {
[16:11:08.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.405]             on.exit(options(oopts), add = TRUE)
[16:11:08.405]         }
[16:11:08.405]         {
[16:11:08.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.405]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.405]             })
[16:11:08.405]         }
[16:11:08.405]     }, args = future.call.arguments)
[16:11:08.405] }
[16:11:08.405] Lazy evaluation: FALSE
[16:11:08.405] Asynchronous evaluation: TRUE
[16:11:08.405] Local evaluation: TRUE
[16:11:08.405] Environment: R_GlobalEnv
[16:11:08.405] Capture standard output: TRUE
[16:11:08.405] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:08.405] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:08.405] Packages: 1 packages (‘future.apply’)
[16:11:08.405] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:08.405] Resolved: FALSE
[16:11:08.405] Value: <not collected>
[16:11:08.405] Conditions captured: <none>
[16:11:08.405] Early signaling: FALSE
[16:11:08.405] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:08.405] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.417] Chunk #2 of 2 ... DONE
[16:11:08.417] Launching 2 futures (chunks) ... DONE
[16:11:08.417] Resolving 2 futures (chunks) ...
[16:11:08.417] resolve() on list ...
[16:11:08.417]  recursive: 0
[16:11:08.417]  length: 2
[16:11:08.417] 
[16:11:08.418] receiveMessageFromWorker() for ClusterFuture ...
[16:11:08.418] - Validating connection of MultisessionFuture
[16:11:08.418] - received message: FutureResult
[16:11:08.418] - Received FutureResult
[16:11:08.418] - Erased future from FutureRegistry
[16:11:08.418] result() for ClusterFuture ...
[16:11:08.418] - result already collected: FutureResult
[16:11:08.419] result() for ClusterFuture ... done
[16:11:08.419] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:08.419] Future #1
[16:11:08.419] result() for ClusterFuture ...
[16:11:08.419] - result already collected: FutureResult
[16:11:08.419] result() for ClusterFuture ... done
[16:11:08.419] result() for ClusterFuture ...
[16:11:08.419] - result already collected: FutureResult
[16:11:08.419] result() for ClusterFuture ... done
[16:11:08.419] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:08.419] - nx: 2
[16:11:08.420] - relay: TRUE
[16:11:08.420] - stdout: TRUE
[16:11:08.420] - signal: TRUE
[16:11:08.420] - resignal: FALSE
[16:11:08.420] - force: TRUE
[16:11:08.420] - relayed: [n=2] FALSE, FALSE
[16:11:08.420] - queued futures: [n=2] FALSE, FALSE
[16:11:08.420]  - until=1
[16:11:08.420]  - relaying element #1
[16:11:08.420] result() for ClusterFuture ...
[16:11:08.420] - result already collected: FutureResult
[16:11:08.421] result() for ClusterFuture ... done
[16:11:08.421] result() for ClusterFuture ...
[16:11:08.421] - result already collected: FutureResult
[16:11:08.421] result() for ClusterFuture ... done
[16:11:08.421] result() for ClusterFuture ...
[16:11:08.421] - result already collected: FutureResult
[16:11:08.421] result() for ClusterFuture ... done
[16:11:08.421] result() for ClusterFuture ...
[16:11:08.421] - result already collected: FutureResult
[16:11:08.421] result() for ClusterFuture ... done
[16:11:08.421] - relayed: [n=2] TRUE, FALSE
[16:11:08.422] - queued futures: [n=2] TRUE, FALSE
[16:11:08.422] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:08.422]  length: 1 (resolved future 1)
[16:11:08.463] receiveMessageFromWorker() for ClusterFuture ...
[16:11:08.464] - Validating connection of MultisessionFuture
[16:11:08.464] - received message: FutureResult
[16:11:08.464] - Received FutureResult
[16:11:08.464] - Erased future from FutureRegistry
[16:11:08.464] result() for ClusterFuture ...
[16:11:08.464] - result already collected: FutureResult
[16:11:08.464] result() for ClusterFuture ... done
[16:11:08.464] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:08.465] Future #2
[16:11:08.465] result() for ClusterFuture ...
[16:11:08.465] - result already collected: FutureResult
[16:11:08.465] result() for ClusterFuture ... done
[16:11:08.465] result() for ClusterFuture ...
[16:11:08.465] - result already collected: FutureResult
[16:11:08.465] result() for ClusterFuture ... done
[16:11:08.465] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:08.465] - nx: 2
[16:11:08.465] - relay: TRUE
[16:11:08.465] - stdout: TRUE
[16:11:08.466] - signal: TRUE
[16:11:08.466] - resignal: FALSE
[16:11:08.466] - force: TRUE
[16:11:08.466] - relayed: [n=2] TRUE, FALSE
[16:11:08.466] - queued futures: [n=2] TRUE, FALSE
[16:11:08.466]  - until=2
[16:11:08.466]  - relaying element #2
[16:11:08.466] result() for ClusterFuture ...
[16:11:08.466] - result already collected: FutureResult
[16:11:08.466] result() for ClusterFuture ... done
[16:11:08.466] result() for ClusterFuture ...
[16:11:08.467] - result already collected: FutureResult
[16:11:08.467] result() for ClusterFuture ... done
[16:11:08.467] result() for ClusterFuture ...
[16:11:08.467] - result already collected: FutureResult
[16:11:08.467] result() for ClusterFuture ... done
[16:11:08.467] result() for ClusterFuture ...
[16:11:08.467] - result already collected: FutureResult
[16:11:08.467] result() for ClusterFuture ... done
[16:11:08.467] - relayed: [n=2] TRUE, TRUE
[16:11:08.467] - queued futures: [n=2] TRUE, TRUE
[16:11:08.467] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:08.468]  length: 0 (resolved future 2)
[16:11:08.468] Relaying remaining futures
[16:11:08.468] signalConditionsASAP(NULL, pos=0) ...
[16:11:08.468] - nx: 2
[16:11:08.468] - relay: TRUE
[16:11:08.468] - stdout: TRUE
[16:11:08.468] - signal: TRUE
[16:11:08.468] - resignal: FALSE
[16:11:08.468] - force: TRUE
[16:11:08.468] - relayed: [n=2] TRUE, TRUE
[16:11:08.468] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:08.469] - relayed: [n=2] TRUE, TRUE
[16:11:08.469] - queued futures: [n=2] TRUE, TRUE
[16:11:08.469] signalConditionsASAP(NULL, pos=0) ... done
[16:11:08.469] resolve() on list ... DONE
[16:11:08.469] result() for ClusterFuture ...
[16:11:08.469] - result already collected: FutureResult
[16:11:08.469] result() for ClusterFuture ... done
[16:11:08.469] result() for ClusterFuture ...
[16:11:08.469] - result already collected: FutureResult
[16:11:08.469] result() for ClusterFuture ... done
[16:11:08.470] result() for ClusterFuture ...
[16:11:08.470] - result already collected: FutureResult
[16:11:08.470] result() for ClusterFuture ... done
[16:11:08.470] result() for ClusterFuture ...
[16:11:08.470] - result already collected: FutureResult
[16:11:08.470] result() for ClusterFuture ... done
[16:11:08.470]  - Number of value chunks collected: 2
[16:11:08.470] Resolving 2 futures (chunks) ... DONE
[16:11:08.470] Reducing values from 2 chunks ...
[16:11:08.470]  - Number of values collected after concatenation: 4
[16:11:08.471]  - Number of values expected: 4
[16:11:08.471] Reducing values from 2 chunks ... DONE
[16:11:08.471] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[16:11:08.472] future_lapply() ...
[16:11:08.478] Number of chunks: 2
[16:11:08.478] getGlobalsAndPackagesXApply() ...
[16:11:08.478]  - future.globals: TRUE
[16:11:08.478] getGlobalsAndPackages() ...
[16:11:08.478] Searching for globals...
[16:11:08.481] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:08.482] Searching for globals ... DONE
[16:11:08.482] Resolving globals: FALSE
[16:11:08.482] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[16:11:08.483] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:08.483] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:08.483] - packages: [1] ‘future.apply’
[16:11:08.483] getGlobalsAndPackages() ... DONE
[16:11:08.483]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:08.483]  - needed namespaces: [n=1] ‘future.apply’
[16:11:08.484] Finding globals ... DONE
[16:11:08.484]  - use_args: TRUE
[16:11:08.484]  - Getting '...' globals ...
[16:11:08.484] resolve() on list ...
[16:11:08.484]  recursive: 0
[16:11:08.484]  length: 1
[16:11:08.484]  elements: ‘...’
[16:11:08.485]  length: 0 (resolved future 1)
[16:11:08.485] resolve() on list ... DONE
[16:11:08.485]    - '...' content: [n=0] 
[16:11:08.485] List of 1
[16:11:08.485]  $ ...: list()
[16:11:08.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:08.485]  - attr(*, "where")=List of 1
[16:11:08.485]   ..$ ...:<environment: 0x561e8c7c7d40> 
[16:11:08.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:08.485]  - attr(*, "resolved")= logi TRUE
[16:11:08.485]  - attr(*, "total_size")= num NA
[16:11:08.487]  - Getting '...' globals ... DONE
[16:11:08.487] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:08.488] List of 8
[16:11:08.488]  $ ...future.FUN:function (x, ...)  
[16:11:08.488]  $ x_FUN        :function (x)  
[16:11:08.488]  $ times        : int 1
[16:11:08.488]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:08.488]  $ stop_if_not  :function (...)  
[16:11:08.488]  $ dim          : NULL
[16:11:08.488]  $ valid_types  : chr "logical"
[16:11:08.488]  $ ...          : list()
[16:11:08.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:08.488]  - attr(*, "where")=List of 8
[16:11:08.488]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:08.488]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:08.488]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:08.488]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:08.488]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:08.488]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:08.488]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:08.488]   ..$ ...          :<environment: 0x561e8c7c7d40> 
[16:11:08.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:08.488]  - attr(*, "resolved")= logi FALSE
[16:11:08.488]  - attr(*, "total_size")= num 94200
[16:11:08.493] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:08.493] getGlobalsAndPackagesXApply() ... DONE
[16:11:08.493] Number of futures (= number of chunks): 2
[16:11:08.493] Launching 2 futures (chunks) ...
[16:11:08.493] Chunk #1 of 2 ...
[16:11:08.494]  - Finding globals in 'X' for chunk #1 ...
[16:11:08.494] getGlobalsAndPackages() ...
[16:11:08.494] Searching for globals...
[16:11:08.494] 
[16:11:08.494] Searching for globals ... DONE
[16:11:08.494] - globals: [0] <none>
[16:11:08.494] getGlobalsAndPackages() ... DONE
[16:11:08.494]    + additional globals found: [n=0] 
[16:11:08.494]    + additional namespaces needed: [n=0] 
[16:11:08.495]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:08.495]  - Adjusted option 'future.globals.maxSize': 524288000 -> 6 * 524288000 = 3145728000 (bytes)
[16:11:08.495]  - seeds: <none>
[16:11:08.495] getGlobalsAndPackages() ...
[16:11:08.495] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.495] Resolving globals: FALSE
[16:11:08.495] Tweak future expression to call with '...' arguments ...
[16:11:08.495] {
[16:11:08.495]     do.call(function(...) {
[16:11:08.495]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.495]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.495]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.495]             on.exit(options(oopts), add = TRUE)
[16:11:08.495]         }
[16:11:08.495]         {
[16:11:08.495]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.495]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.495]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.495]             })
[16:11:08.495]         }
[16:11:08.495]     }, args = future.call.arguments)
[16:11:08.495] }
[16:11:08.496] Tweak future expression to call with '...' arguments ... DONE
[16:11:08.496] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.496] - packages: [1] ‘future.apply’
[16:11:08.496] getGlobalsAndPackages() ... DONE
[16:11:08.497] run() for ‘Future’ ...
[16:11:08.497] - state: ‘created’
[16:11:08.497] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:08.511] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:08.512]   - Field: ‘node’
[16:11:08.512]   - Field: ‘label’
[16:11:08.512]   - Field: ‘local’
[16:11:08.512]   - Field: ‘owner’
[16:11:08.512]   - Field: ‘envir’
[16:11:08.512]   - Field: ‘workers’
[16:11:08.512]   - Field: ‘packages’
[16:11:08.512]   - Field: ‘gc’
[16:11:08.513]   - Field: ‘conditions’
[16:11:08.513]   - Field: ‘persistent’
[16:11:08.513]   - Field: ‘expr’
[16:11:08.513]   - Field: ‘uuid’
[16:11:08.513]   - Field: ‘seed’
[16:11:08.513]   - Field: ‘version’
[16:11:08.513]   - Field: ‘result’
[16:11:08.513]   - Field: ‘asynchronous’
[16:11:08.513]   - Field: ‘calls’
[16:11:08.513]   - Field: ‘globals’
[16:11:08.513]   - Field: ‘stdout’
[16:11:08.514]   - Field: ‘earlySignal’
[16:11:08.514]   - Field: ‘lazy’
[16:11:08.514]   - Field: ‘state’
[16:11:08.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:08.514] - Launch lazy future ...
[16:11:08.514] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:08.514] Packages needed by future strategies (n = 0): <none>
[16:11:08.515] {
[16:11:08.515]     {
[16:11:08.515]         {
[16:11:08.515]             ...future.startTime <- base::Sys.time()
[16:11:08.515]             {
[16:11:08.515]                 {
[16:11:08.515]                   {
[16:11:08.515]                     {
[16:11:08.515]                       {
[16:11:08.515]                         base::local({
[16:11:08.515]                           has_future <- base::requireNamespace("future", 
[16:11:08.515]                             quietly = TRUE)
[16:11:08.515]                           if (has_future) {
[16:11:08.515]                             ns <- base::getNamespace("future")
[16:11:08.515]                             version <- ns[[".package"]][["version"]]
[16:11:08.515]                             if (is.null(version)) 
[16:11:08.515]                               version <- utils::packageVersion("future")
[16:11:08.515]                           }
[16:11:08.515]                           else {
[16:11:08.515]                             version <- NULL
[16:11:08.515]                           }
[16:11:08.515]                           if (!has_future || version < "1.8.0") {
[16:11:08.515]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:08.515]                               "", base::R.version$version.string), 
[16:11:08.515]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:08.515]                                 base::R.version$platform, 8 * 
[16:11:08.515]                                   base::.Machine$sizeof.pointer), 
[16:11:08.515]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:08.515]                                 "release", "version")], collapse = " "), 
[16:11:08.515]                               hostname = base::Sys.info()[["nodename"]])
[16:11:08.515]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:08.515]                               info)
[16:11:08.515]                             info <- base::paste(info, collapse = "; ")
[16:11:08.515]                             if (!has_future) {
[16:11:08.515]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:08.515]                                 info)
[16:11:08.515]                             }
[16:11:08.515]                             else {
[16:11:08.515]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:08.515]                                 info, version)
[16:11:08.515]                             }
[16:11:08.515]                             base::stop(msg)
[16:11:08.515]                           }
[16:11:08.515]                         })
[16:11:08.515]                       }
[16:11:08.515]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:08.515]                       base::options(mc.cores = 1L)
[16:11:08.515]                     }
[16:11:08.515]                     base::local({
[16:11:08.515]                       for (pkg in "future.apply") {
[16:11:08.515]                         base::loadNamespace(pkg)
[16:11:08.515]                         base::library(pkg, character.only = TRUE)
[16:11:08.515]                       }
[16:11:08.515]                     })
[16:11:08.515]                   }
[16:11:08.515]                   options(future.plan = NULL)
[16:11:08.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:08.515]                 }
[16:11:08.515]                 ...future.workdir <- getwd()
[16:11:08.515]             }
[16:11:08.515]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:08.515]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:08.515]         }
[16:11:08.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:08.515]             future.globals.maxSize = 3145728000, future.globals.method = NULL, 
[16:11:08.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:08.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:08.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:08.515]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:08.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:08.515]             base::names(...future.oldOptions))
[16:11:08.515]     }
[16:11:08.515]     if (FALSE) {
[16:11:08.515]     }
[16:11:08.515]     else {
[16:11:08.515]         if (TRUE) {
[16:11:08.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:08.515]                 open = "w")
[16:11:08.515]         }
[16:11:08.515]         else {
[16:11:08.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:08.515]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:08.515]         }
[16:11:08.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:08.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:08.515]             base::sink(type = "output", split = FALSE)
[16:11:08.515]             base::close(...future.stdout)
[16:11:08.515]         }, add = TRUE)
[16:11:08.515]     }
[16:11:08.515]     ...future.frame <- base::sys.nframe()
[16:11:08.515]     ...future.conditions <- base::list()
[16:11:08.515]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:08.515]     if (FALSE) {
[16:11:08.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:08.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:08.515]     }
[16:11:08.515]     ...future.result <- base::tryCatch({
[16:11:08.515]         base::withCallingHandlers({
[16:11:08.515]             ...future.value <- base::withVisible(base::local({
[16:11:08.515]                 ...future.makeSendCondition <- local({
[16:11:08.515]                   sendCondition <- NULL
[16:11:08.515]                   function(frame = 1L) {
[16:11:08.515]                     if (is.function(sendCondition)) 
[16:11:08.515]                       return(sendCondition)
[16:11:08.515]                     ns <- getNamespace("parallel")
[16:11:08.515]                     if (exists("sendData", mode = "function", 
[16:11:08.515]                       envir = ns)) {
[16:11:08.515]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:08.515]                         envir = ns)
[16:11:08.515]                       envir <- sys.frame(frame)
[16:11:08.515]                       master <- NULL
[16:11:08.515]                       while (!identical(envir, .GlobalEnv) && 
[16:11:08.515]                         !identical(envir, emptyenv())) {
[16:11:08.515]                         if (exists("master", mode = "list", envir = envir, 
[16:11:08.515]                           inherits = FALSE)) {
[16:11:08.515]                           master <- get("master", mode = "list", 
[16:11:08.515]                             envir = envir, inherits = FALSE)
[16:11:08.515]                           if (inherits(master, c("SOCKnode", 
[16:11:08.515]                             "SOCK0node"))) {
[16:11:08.515]                             sendCondition <<- function(cond) {
[16:11:08.515]                               data <- list(type = "VALUE", value = cond, 
[16:11:08.515]                                 success = TRUE)
[16:11:08.515]                               parallel_sendData(master, data)
[16:11:08.515]                             }
[16:11:08.515]                             return(sendCondition)
[16:11:08.515]                           }
[16:11:08.515]                         }
[16:11:08.515]                         frame <- frame + 1L
[16:11:08.515]                         envir <- sys.frame(frame)
[16:11:08.515]                       }
[16:11:08.515]                     }
[16:11:08.515]                     sendCondition <<- function(cond) NULL
[16:11:08.515]                   }
[16:11:08.515]                 })
[16:11:08.515]                 withCallingHandlers({
[16:11:08.515]                   {
[16:11:08.515]                     do.call(function(...) {
[16:11:08.515]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.515]                       if (!identical(...future.globals.maxSize.org, 
[16:11:08.515]                         ...future.globals.maxSize)) {
[16:11:08.515]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.515]                         on.exit(options(oopts), add = TRUE)
[16:11:08.515]                       }
[16:11:08.515]                       {
[16:11:08.515]                         lapply(seq_along(...future.elements_ii), 
[16:11:08.515]                           FUN = function(jj) {
[16:11:08.515]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.515]                             ...future.FUN(...future.X_jj, ...)
[16:11:08.515]                           })
[16:11:08.515]                       }
[16:11:08.515]                     }, args = future.call.arguments)
[16:11:08.515]                   }
[16:11:08.515]                 }, immediateCondition = function(cond) {
[16:11:08.515]                   sendCondition <- ...future.makeSendCondition()
[16:11:08.515]                   sendCondition(cond)
[16:11:08.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.515]                   {
[16:11:08.515]                     inherits <- base::inherits
[16:11:08.515]                     invokeRestart <- base::invokeRestart
[16:11:08.515]                     is.null <- base::is.null
[16:11:08.515]                     muffled <- FALSE
[16:11:08.515]                     if (inherits(cond, "message")) {
[16:11:08.515]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:08.515]                       if (muffled) 
[16:11:08.515]                         invokeRestart("muffleMessage")
[16:11:08.515]                     }
[16:11:08.515]                     else if (inherits(cond, "warning")) {
[16:11:08.515]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:08.515]                       if (muffled) 
[16:11:08.515]                         invokeRestart("muffleWarning")
[16:11:08.515]                     }
[16:11:08.515]                     else if (inherits(cond, "condition")) {
[16:11:08.515]                       if (!is.null(pattern)) {
[16:11:08.515]                         computeRestarts <- base::computeRestarts
[16:11:08.515]                         grepl <- base::grepl
[16:11:08.515]                         restarts <- computeRestarts(cond)
[16:11:08.515]                         for (restart in restarts) {
[16:11:08.515]                           name <- restart$name
[16:11:08.515]                           if (is.null(name)) 
[16:11:08.515]                             next
[16:11:08.515]                           if (!grepl(pattern, name)) 
[16:11:08.515]                             next
[16:11:08.515]                           invokeRestart(restart)
[16:11:08.515]                           muffled <- TRUE
[16:11:08.515]                           break
[16:11:08.515]                         }
[16:11:08.515]                       }
[16:11:08.515]                     }
[16:11:08.515]                     invisible(muffled)
[16:11:08.515]                   }
[16:11:08.515]                   muffleCondition(cond)
[16:11:08.515]                 })
[16:11:08.515]             }))
[16:11:08.515]             future::FutureResult(value = ...future.value$value, 
[16:11:08.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.515]                   ...future.rng), globalenv = if (FALSE) 
[16:11:08.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:08.515]                     ...future.globalenv.names))
[16:11:08.515]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:08.515]         }, condition = base::local({
[16:11:08.515]             c <- base::c
[16:11:08.515]             inherits <- base::inherits
[16:11:08.515]             invokeRestart <- base::invokeRestart
[16:11:08.515]             length <- base::length
[16:11:08.515]             list <- base::list
[16:11:08.515]             seq.int <- base::seq.int
[16:11:08.515]             signalCondition <- base::signalCondition
[16:11:08.515]             sys.calls <- base::sys.calls
[16:11:08.515]             `[[` <- base::`[[`
[16:11:08.515]             `+` <- base::`+`
[16:11:08.515]             `<<-` <- base::`<<-`
[16:11:08.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:08.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:08.515]                   3L)]
[16:11:08.515]             }
[16:11:08.515]             function(cond) {
[16:11:08.515]                 is_error <- inherits(cond, "error")
[16:11:08.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:08.515]                   NULL)
[16:11:08.515]                 if (is_error) {
[16:11:08.515]                   sessionInformation <- function() {
[16:11:08.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:08.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:08.515]                       search = base::search(), system = base::Sys.info())
[16:11:08.515]                   }
[16:11:08.515]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:08.515]                     cond$call), session = sessionInformation(), 
[16:11:08.515]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:08.515]                   signalCondition(cond)
[16:11:08.515]                 }
[16:11:08.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:08.515]                 "immediateCondition"))) {
[16:11:08.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:08.515]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:08.515]                   if (TRUE && !signal) {
[16:11:08.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.515]                     {
[16:11:08.515]                       inherits <- base::inherits
[16:11:08.515]                       invokeRestart <- base::invokeRestart
[16:11:08.515]                       is.null <- base::is.null
[16:11:08.515]                       muffled <- FALSE
[16:11:08.515]                       if (inherits(cond, "message")) {
[16:11:08.515]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.515]                         if (muffled) 
[16:11:08.515]                           invokeRestart("muffleMessage")
[16:11:08.515]                       }
[16:11:08.515]                       else if (inherits(cond, "warning")) {
[16:11:08.515]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.515]                         if (muffled) 
[16:11:08.515]                           invokeRestart("muffleWarning")
[16:11:08.515]                       }
[16:11:08.515]                       else if (inherits(cond, "condition")) {
[16:11:08.515]                         if (!is.null(pattern)) {
[16:11:08.515]                           computeRestarts <- base::computeRestarts
[16:11:08.515]                           grepl <- base::grepl
[16:11:08.515]                           restarts <- computeRestarts(cond)
[16:11:08.515]                           for (restart in restarts) {
[16:11:08.515]                             name <- restart$name
[16:11:08.515]                             if (is.null(name)) 
[16:11:08.515]                               next
[16:11:08.515]                             if (!grepl(pattern, name)) 
[16:11:08.515]                               next
[16:11:08.515]                             invokeRestart(restart)
[16:11:08.515]                             muffled <- TRUE
[16:11:08.515]                             break
[16:11:08.515]                           }
[16:11:08.515]                         }
[16:11:08.515]                       }
[16:11:08.515]                       invisible(muffled)
[16:11:08.515]                     }
[16:11:08.515]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.515]                   }
[16:11:08.515]                 }
[16:11:08.515]                 else {
[16:11:08.515]                   if (TRUE) {
[16:11:08.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.515]                     {
[16:11:08.515]                       inherits <- base::inherits
[16:11:08.515]                       invokeRestart <- base::invokeRestart
[16:11:08.515]                       is.null <- base::is.null
[16:11:08.515]                       muffled <- FALSE
[16:11:08.515]                       if (inherits(cond, "message")) {
[16:11:08.515]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.515]                         if (muffled) 
[16:11:08.515]                           invokeRestart("muffleMessage")
[16:11:08.515]                       }
[16:11:08.515]                       else if (inherits(cond, "warning")) {
[16:11:08.515]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.515]                         if (muffled) 
[16:11:08.515]                           invokeRestart("muffleWarning")
[16:11:08.515]                       }
[16:11:08.515]                       else if (inherits(cond, "condition")) {
[16:11:08.515]                         if (!is.null(pattern)) {
[16:11:08.515]                           computeRestarts <- base::computeRestarts
[16:11:08.515]                           grepl <- base::grepl
[16:11:08.515]                           restarts <- computeRestarts(cond)
[16:11:08.515]                           for (restart in restarts) {
[16:11:08.515]                             name <- restart$name
[16:11:08.515]                             if (is.null(name)) 
[16:11:08.515]                               next
[16:11:08.515]                             if (!grepl(pattern, name)) 
[16:11:08.515]                               next
[16:11:08.515]                             invokeRestart(restart)
[16:11:08.515]                             muffled <- TRUE
[16:11:08.515]                             break
[16:11:08.515]                           }
[16:11:08.515]                         }
[16:11:08.515]                       }
[16:11:08.515]                       invisible(muffled)
[16:11:08.515]                     }
[16:11:08.515]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.515]                   }
[16:11:08.515]                 }
[16:11:08.515]             }
[16:11:08.515]         }))
[16:11:08.515]     }, error = function(ex) {
[16:11:08.515]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:08.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.515]                 ...future.rng), started = ...future.startTime, 
[16:11:08.515]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:08.515]             version = "1.8"), class = "FutureResult")
[16:11:08.515]     }, finally = {
[16:11:08.515]         if (!identical(...future.workdir, getwd())) 
[16:11:08.515]             setwd(...future.workdir)
[16:11:08.515]         {
[16:11:08.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:08.515]                 ...future.oldOptions$nwarnings <- NULL
[16:11:08.515]             }
[16:11:08.515]             base::options(...future.oldOptions)
[16:11:08.515]             if (.Platform$OS.type == "windows") {
[16:11:08.515]                 old_names <- names(...future.oldEnvVars)
[16:11:08.515]                 envs <- base::Sys.getenv()
[16:11:08.515]                 names <- names(envs)
[16:11:08.515]                 common <- intersect(names, old_names)
[16:11:08.515]                 added <- setdiff(names, old_names)
[16:11:08.515]                 removed <- setdiff(old_names, names)
[16:11:08.515]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:08.515]                   envs[common]]
[16:11:08.515]                 NAMES <- toupper(changed)
[16:11:08.515]                 args <- list()
[16:11:08.515]                 for (kk in seq_along(NAMES)) {
[16:11:08.515]                   name <- changed[[kk]]
[16:11:08.515]                   NAME <- NAMES[[kk]]
[16:11:08.515]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.515]                     next
[16:11:08.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.515]                 }
[16:11:08.515]                 NAMES <- toupper(added)
[16:11:08.515]                 for (kk in seq_along(NAMES)) {
[16:11:08.515]                   name <- added[[kk]]
[16:11:08.515]                   NAME <- NAMES[[kk]]
[16:11:08.515]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.515]                     next
[16:11:08.515]                   args[[name]] <- ""
[16:11:08.515]                 }
[16:11:08.515]                 NAMES <- toupper(removed)
[16:11:08.515]                 for (kk in seq_along(NAMES)) {
[16:11:08.515]                   name <- removed[[kk]]
[16:11:08.515]                   NAME <- NAMES[[kk]]
[16:11:08.515]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.515]                     next
[16:11:08.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.515]                 }
[16:11:08.515]                 if (length(args) > 0) 
[16:11:08.515]                   base::do.call(base::Sys.setenv, args = args)
[16:11:08.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:08.515]             }
[16:11:08.515]             else {
[16:11:08.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:08.515]             }
[16:11:08.515]             {
[16:11:08.515]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:08.515]                   0L) {
[16:11:08.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:08.515]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:08.515]                   base::options(opts)
[16:11:08.515]                 }
[16:11:08.515]                 {
[16:11:08.515]                   {
[16:11:08.515]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:08.515]                     NULL
[16:11:08.515]                   }
[16:11:08.515]                   options(future.plan = NULL)
[16:11:08.515]                   if (is.na(NA_character_)) 
[16:11:08.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:08.515]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:08.515]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:08.515]                     envir = parent.frame()) 
[16:11:08.515]                   {
[16:11:08.515]                     if (is.function(workers)) 
[16:11:08.515]                       workers <- workers()
[16:11:08.515]                     workers <- structure(as.integer(workers), 
[16:11:08.515]                       class = class(workers))
[16:11:08.515]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:08.515]                       workers >= 1)
[16:11:08.515]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:08.515]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:08.515]                     }
[16:11:08.515]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:08.515]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:08.515]                       envir = envir)
[16:11:08.515]                     if (!future$lazy) 
[16:11:08.515]                       future <- run(future)
[16:11:08.515]                     invisible(future)
[16:11:08.515]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:08.515]                 }
[16:11:08.515]             }
[16:11:08.515]         }
[16:11:08.515]     })
[16:11:08.515]     if (TRUE) {
[16:11:08.515]         base::sink(type = "output", split = FALSE)
[16:11:08.515]         if (TRUE) {
[16:11:08.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:08.515]         }
[16:11:08.515]         else {
[16:11:08.515]             ...future.result["stdout"] <- base::list(NULL)
[16:11:08.515]         }
[16:11:08.515]         base::close(...future.stdout)
[16:11:08.515]         ...future.stdout <- NULL
[16:11:08.515]     }
[16:11:08.515]     ...future.result$conditions <- ...future.conditions
[16:11:08.515]     ...future.result$finished <- base::Sys.time()
[16:11:08.515]     ...future.result
[16:11:08.515] }
[16:11:08.518] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[16:11:08.518] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:08.560] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:08.560] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:11:08.561] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:11:08.561] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:08.561] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:08.561] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:08.604] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:08.607] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:08.648] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:08.648] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:08.648] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:08.649] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[16:11:08.649] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[16:11:08.649] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:08.650] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:08.650] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[16:11:08.650] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[16:11:08.650] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:08.650] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:08.651] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:08.651] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:08.651] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[16:11:08.652] MultisessionFuture started
[16:11:08.652] - Launch lazy future ... done
[16:11:08.652] run() for ‘MultisessionFuture’ ... done
[16:11:08.652] Created future:
[16:11:08.652] MultisessionFuture:
[16:11:08.652] Label: ‘future_vapply-1’
[16:11:08.652] Expression:
[16:11:08.652] {
[16:11:08.652]     do.call(function(...) {
[16:11:08.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.652]             on.exit(options(oopts), add = TRUE)
[16:11:08.652]         }
[16:11:08.652]         {
[16:11:08.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.652]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.652]             })
[16:11:08.652]         }
[16:11:08.652]     }, args = future.call.arguments)
[16:11:08.652] }
[16:11:08.652] Lazy evaluation: FALSE
[16:11:08.652] Asynchronous evaluation: TRUE
[16:11:08.652] Local evaluation: TRUE
[16:11:08.652] Environment: R_GlobalEnv
[16:11:08.652] Capture standard output: TRUE
[16:11:08.652] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:08.652] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:08.652] Packages: 1 packages (‘future.apply’)
[16:11:08.652] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:08.652] Resolved: FALSE
[16:11:08.652] Value: <not collected>
[16:11:08.652] Conditions captured: <none>
[16:11:08.652] Early signaling: FALSE
[16:11:08.652] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:08.652] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.664] Chunk #1 of 2 ... DONE
[16:11:08.664] Chunk #2 of 2 ...
[16:11:08.664]  - Finding globals in 'X' for chunk #2 ...
[16:11:08.664] getGlobalsAndPackages() ...
[16:11:08.664] Searching for globals...
[16:11:08.665] 
[16:11:08.665] Searching for globals ... DONE
[16:11:08.665] - globals: [0] <none>
[16:11:08.665] getGlobalsAndPackages() ... DONE
[16:11:08.665]    + additional globals found: [n=0] 
[16:11:08.665]    + additional namespaces needed: [n=0] 
[16:11:08.665]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:08.665]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[16:11:08.665]  - seeds: <none>
[16:11:08.666] getGlobalsAndPackages() ...
[16:11:08.666] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.666] Resolving globals: FALSE
[16:11:08.666] Tweak future expression to call with '...' arguments ...
[16:11:08.666] {
[16:11:08.666]     do.call(function(...) {
[16:11:08.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.666]             on.exit(options(oopts), add = TRUE)
[16:11:08.666]         }
[16:11:08.666]         {
[16:11:08.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.666]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.666]             })
[16:11:08.666]         }
[16:11:08.666]     }, args = future.call.arguments)
[16:11:08.666] }
[16:11:08.666] Tweak future expression to call with '...' arguments ... DONE
[16:11:08.667] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.667] - packages: [1] ‘future.apply’
[16:11:08.667] getGlobalsAndPackages() ... DONE
[16:11:08.667] run() for ‘Future’ ...
[16:11:08.667] - state: ‘created’
[16:11:08.668] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:08.682] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:08.683]   - Field: ‘node’
[16:11:08.683]   - Field: ‘label’
[16:11:08.683]   - Field: ‘local’
[16:11:08.683]   - Field: ‘owner’
[16:11:08.683]   - Field: ‘envir’
[16:11:08.683]   - Field: ‘workers’
[16:11:08.683]   - Field: ‘packages’
[16:11:08.683]   - Field: ‘gc’
[16:11:08.683]   - Field: ‘conditions’
[16:11:08.683]   - Field: ‘persistent’
[16:11:08.684]   - Field: ‘expr’
[16:11:08.684]   - Field: ‘uuid’
[16:11:08.684]   - Field: ‘seed’
[16:11:08.684]   - Field: ‘version’
[16:11:08.684]   - Field: ‘result’
[16:11:08.684]   - Field: ‘asynchronous’
[16:11:08.684]   - Field: ‘calls’
[16:11:08.684]   - Field: ‘globals’
[16:11:08.684]   - Field: ‘stdout’
[16:11:08.684]   - Field: ‘earlySignal’
[16:11:08.685]   - Field: ‘lazy’
[16:11:08.685]   - Field: ‘state’
[16:11:08.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:08.685] - Launch lazy future ...
[16:11:08.685] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:08.685] Packages needed by future strategies (n = 0): <none>
[16:11:08.686] {
[16:11:08.686]     {
[16:11:08.686]         {
[16:11:08.686]             ...future.startTime <- base::Sys.time()
[16:11:08.686]             {
[16:11:08.686]                 {
[16:11:08.686]                   {
[16:11:08.686]                     {
[16:11:08.686]                       {
[16:11:08.686]                         base::local({
[16:11:08.686]                           has_future <- base::requireNamespace("future", 
[16:11:08.686]                             quietly = TRUE)
[16:11:08.686]                           if (has_future) {
[16:11:08.686]                             ns <- base::getNamespace("future")
[16:11:08.686]                             version <- ns[[".package"]][["version"]]
[16:11:08.686]                             if (is.null(version)) 
[16:11:08.686]                               version <- utils::packageVersion("future")
[16:11:08.686]                           }
[16:11:08.686]                           else {
[16:11:08.686]                             version <- NULL
[16:11:08.686]                           }
[16:11:08.686]                           if (!has_future || version < "1.8.0") {
[16:11:08.686]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:08.686]                               "", base::R.version$version.string), 
[16:11:08.686]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:08.686]                                 base::R.version$platform, 8 * 
[16:11:08.686]                                   base::.Machine$sizeof.pointer), 
[16:11:08.686]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:08.686]                                 "release", "version")], collapse = " "), 
[16:11:08.686]                               hostname = base::Sys.info()[["nodename"]])
[16:11:08.686]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:08.686]                               info)
[16:11:08.686]                             info <- base::paste(info, collapse = "; ")
[16:11:08.686]                             if (!has_future) {
[16:11:08.686]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:08.686]                                 info)
[16:11:08.686]                             }
[16:11:08.686]                             else {
[16:11:08.686]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:08.686]                                 info, version)
[16:11:08.686]                             }
[16:11:08.686]                             base::stop(msg)
[16:11:08.686]                           }
[16:11:08.686]                         })
[16:11:08.686]                       }
[16:11:08.686]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:08.686]                       base::options(mc.cores = 1L)
[16:11:08.686]                     }
[16:11:08.686]                     base::local({
[16:11:08.686]                       for (pkg in "future.apply") {
[16:11:08.686]                         base::loadNamespace(pkg)
[16:11:08.686]                         base::library(pkg, character.only = TRUE)
[16:11:08.686]                       }
[16:11:08.686]                     })
[16:11:08.686]                   }
[16:11:08.686]                   options(future.plan = NULL)
[16:11:08.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:08.686]                 }
[16:11:08.686]                 ...future.workdir <- getwd()
[16:11:08.686]             }
[16:11:08.686]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:08.686]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:08.686]         }
[16:11:08.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:08.686]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[16:11:08.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:08.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:08.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:08.686]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:08.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:08.686]             base::names(...future.oldOptions))
[16:11:08.686]     }
[16:11:08.686]     if (FALSE) {
[16:11:08.686]     }
[16:11:08.686]     else {
[16:11:08.686]         if (TRUE) {
[16:11:08.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:08.686]                 open = "w")
[16:11:08.686]         }
[16:11:08.686]         else {
[16:11:08.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:08.686]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:08.686]         }
[16:11:08.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:08.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:08.686]             base::sink(type = "output", split = FALSE)
[16:11:08.686]             base::close(...future.stdout)
[16:11:08.686]         }, add = TRUE)
[16:11:08.686]     }
[16:11:08.686]     ...future.frame <- base::sys.nframe()
[16:11:08.686]     ...future.conditions <- base::list()
[16:11:08.686]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:08.686]     if (FALSE) {
[16:11:08.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:08.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:08.686]     }
[16:11:08.686]     ...future.result <- base::tryCatch({
[16:11:08.686]         base::withCallingHandlers({
[16:11:08.686]             ...future.value <- base::withVisible(base::local({
[16:11:08.686]                 ...future.makeSendCondition <- local({
[16:11:08.686]                   sendCondition <- NULL
[16:11:08.686]                   function(frame = 1L) {
[16:11:08.686]                     if (is.function(sendCondition)) 
[16:11:08.686]                       return(sendCondition)
[16:11:08.686]                     ns <- getNamespace("parallel")
[16:11:08.686]                     if (exists("sendData", mode = "function", 
[16:11:08.686]                       envir = ns)) {
[16:11:08.686]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:08.686]                         envir = ns)
[16:11:08.686]                       envir <- sys.frame(frame)
[16:11:08.686]                       master <- NULL
[16:11:08.686]                       while (!identical(envir, .GlobalEnv) && 
[16:11:08.686]                         !identical(envir, emptyenv())) {
[16:11:08.686]                         if (exists("master", mode = "list", envir = envir, 
[16:11:08.686]                           inherits = FALSE)) {
[16:11:08.686]                           master <- get("master", mode = "list", 
[16:11:08.686]                             envir = envir, inherits = FALSE)
[16:11:08.686]                           if (inherits(master, c("SOCKnode", 
[16:11:08.686]                             "SOCK0node"))) {
[16:11:08.686]                             sendCondition <<- function(cond) {
[16:11:08.686]                               data <- list(type = "VALUE", value = cond, 
[16:11:08.686]                                 success = TRUE)
[16:11:08.686]                               parallel_sendData(master, data)
[16:11:08.686]                             }
[16:11:08.686]                             return(sendCondition)
[16:11:08.686]                           }
[16:11:08.686]                         }
[16:11:08.686]                         frame <- frame + 1L
[16:11:08.686]                         envir <- sys.frame(frame)
[16:11:08.686]                       }
[16:11:08.686]                     }
[16:11:08.686]                     sendCondition <<- function(cond) NULL
[16:11:08.686]                   }
[16:11:08.686]                 })
[16:11:08.686]                 withCallingHandlers({
[16:11:08.686]                   {
[16:11:08.686]                     do.call(function(...) {
[16:11:08.686]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.686]                       if (!identical(...future.globals.maxSize.org, 
[16:11:08.686]                         ...future.globals.maxSize)) {
[16:11:08.686]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.686]                         on.exit(options(oopts), add = TRUE)
[16:11:08.686]                       }
[16:11:08.686]                       {
[16:11:08.686]                         lapply(seq_along(...future.elements_ii), 
[16:11:08.686]                           FUN = function(jj) {
[16:11:08.686]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.686]                             ...future.FUN(...future.X_jj, ...)
[16:11:08.686]                           })
[16:11:08.686]                       }
[16:11:08.686]                     }, args = future.call.arguments)
[16:11:08.686]                   }
[16:11:08.686]                 }, immediateCondition = function(cond) {
[16:11:08.686]                   sendCondition <- ...future.makeSendCondition()
[16:11:08.686]                   sendCondition(cond)
[16:11:08.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.686]                   {
[16:11:08.686]                     inherits <- base::inherits
[16:11:08.686]                     invokeRestart <- base::invokeRestart
[16:11:08.686]                     is.null <- base::is.null
[16:11:08.686]                     muffled <- FALSE
[16:11:08.686]                     if (inherits(cond, "message")) {
[16:11:08.686]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:08.686]                       if (muffled) 
[16:11:08.686]                         invokeRestart("muffleMessage")
[16:11:08.686]                     }
[16:11:08.686]                     else if (inherits(cond, "warning")) {
[16:11:08.686]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:08.686]                       if (muffled) 
[16:11:08.686]                         invokeRestart("muffleWarning")
[16:11:08.686]                     }
[16:11:08.686]                     else if (inherits(cond, "condition")) {
[16:11:08.686]                       if (!is.null(pattern)) {
[16:11:08.686]                         computeRestarts <- base::computeRestarts
[16:11:08.686]                         grepl <- base::grepl
[16:11:08.686]                         restarts <- computeRestarts(cond)
[16:11:08.686]                         for (restart in restarts) {
[16:11:08.686]                           name <- restart$name
[16:11:08.686]                           if (is.null(name)) 
[16:11:08.686]                             next
[16:11:08.686]                           if (!grepl(pattern, name)) 
[16:11:08.686]                             next
[16:11:08.686]                           invokeRestart(restart)
[16:11:08.686]                           muffled <- TRUE
[16:11:08.686]                           break
[16:11:08.686]                         }
[16:11:08.686]                       }
[16:11:08.686]                     }
[16:11:08.686]                     invisible(muffled)
[16:11:08.686]                   }
[16:11:08.686]                   muffleCondition(cond)
[16:11:08.686]                 })
[16:11:08.686]             }))
[16:11:08.686]             future::FutureResult(value = ...future.value$value, 
[16:11:08.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.686]                   ...future.rng), globalenv = if (FALSE) 
[16:11:08.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:08.686]                     ...future.globalenv.names))
[16:11:08.686]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:08.686]         }, condition = base::local({
[16:11:08.686]             c <- base::c
[16:11:08.686]             inherits <- base::inherits
[16:11:08.686]             invokeRestart <- base::invokeRestart
[16:11:08.686]             length <- base::length
[16:11:08.686]             list <- base::list
[16:11:08.686]             seq.int <- base::seq.int
[16:11:08.686]             signalCondition <- base::signalCondition
[16:11:08.686]             sys.calls <- base::sys.calls
[16:11:08.686]             `[[` <- base::`[[`
[16:11:08.686]             `+` <- base::`+`
[16:11:08.686]             `<<-` <- base::`<<-`
[16:11:08.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:08.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:08.686]                   3L)]
[16:11:08.686]             }
[16:11:08.686]             function(cond) {
[16:11:08.686]                 is_error <- inherits(cond, "error")
[16:11:08.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:08.686]                   NULL)
[16:11:08.686]                 if (is_error) {
[16:11:08.686]                   sessionInformation <- function() {
[16:11:08.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:08.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:08.686]                       search = base::search(), system = base::Sys.info())
[16:11:08.686]                   }
[16:11:08.686]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:08.686]                     cond$call), session = sessionInformation(), 
[16:11:08.686]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:08.686]                   signalCondition(cond)
[16:11:08.686]                 }
[16:11:08.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:08.686]                 "immediateCondition"))) {
[16:11:08.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:08.686]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:08.686]                   if (TRUE && !signal) {
[16:11:08.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.686]                     {
[16:11:08.686]                       inherits <- base::inherits
[16:11:08.686]                       invokeRestart <- base::invokeRestart
[16:11:08.686]                       is.null <- base::is.null
[16:11:08.686]                       muffled <- FALSE
[16:11:08.686]                       if (inherits(cond, "message")) {
[16:11:08.686]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.686]                         if (muffled) 
[16:11:08.686]                           invokeRestart("muffleMessage")
[16:11:08.686]                       }
[16:11:08.686]                       else if (inherits(cond, "warning")) {
[16:11:08.686]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.686]                         if (muffled) 
[16:11:08.686]                           invokeRestart("muffleWarning")
[16:11:08.686]                       }
[16:11:08.686]                       else if (inherits(cond, "condition")) {
[16:11:08.686]                         if (!is.null(pattern)) {
[16:11:08.686]                           computeRestarts <- base::computeRestarts
[16:11:08.686]                           grepl <- base::grepl
[16:11:08.686]                           restarts <- computeRestarts(cond)
[16:11:08.686]                           for (restart in restarts) {
[16:11:08.686]                             name <- restart$name
[16:11:08.686]                             if (is.null(name)) 
[16:11:08.686]                               next
[16:11:08.686]                             if (!grepl(pattern, name)) 
[16:11:08.686]                               next
[16:11:08.686]                             invokeRestart(restart)
[16:11:08.686]                             muffled <- TRUE
[16:11:08.686]                             break
[16:11:08.686]                           }
[16:11:08.686]                         }
[16:11:08.686]                       }
[16:11:08.686]                       invisible(muffled)
[16:11:08.686]                     }
[16:11:08.686]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.686]                   }
[16:11:08.686]                 }
[16:11:08.686]                 else {
[16:11:08.686]                   if (TRUE) {
[16:11:08.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.686]                     {
[16:11:08.686]                       inherits <- base::inherits
[16:11:08.686]                       invokeRestart <- base::invokeRestart
[16:11:08.686]                       is.null <- base::is.null
[16:11:08.686]                       muffled <- FALSE
[16:11:08.686]                       if (inherits(cond, "message")) {
[16:11:08.686]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.686]                         if (muffled) 
[16:11:08.686]                           invokeRestart("muffleMessage")
[16:11:08.686]                       }
[16:11:08.686]                       else if (inherits(cond, "warning")) {
[16:11:08.686]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.686]                         if (muffled) 
[16:11:08.686]                           invokeRestart("muffleWarning")
[16:11:08.686]                       }
[16:11:08.686]                       else if (inherits(cond, "condition")) {
[16:11:08.686]                         if (!is.null(pattern)) {
[16:11:08.686]                           computeRestarts <- base::computeRestarts
[16:11:08.686]                           grepl <- base::grepl
[16:11:08.686]                           restarts <- computeRestarts(cond)
[16:11:08.686]                           for (restart in restarts) {
[16:11:08.686]                             name <- restart$name
[16:11:08.686]                             if (is.null(name)) 
[16:11:08.686]                               next
[16:11:08.686]                             if (!grepl(pattern, name)) 
[16:11:08.686]                               next
[16:11:08.686]                             invokeRestart(restart)
[16:11:08.686]                             muffled <- TRUE
[16:11:08.686]                             break
[16:11:08.686]                           }
[16:11:08.686]                         }
[16:11:08.686]                       }
[16:11:08.686]                       invisible(muffled)
[16:11:08.686]                     }
[16:11:08.686]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.686]                   }
[16:11:08.686]                 }
[16:11:08.686]             }
[16:11:08.686]         }))
[16:11:08.686]     }, error = function(ex) {
[16:11:08.686]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:08.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.686]                 ...future.rng), started = ...future.startTime, 
[16:11:08.686]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:08.686]             version = "1.8"), class = "FutureResult")
[16:11:08.686]     }, finally = {
[16:11:08.686]         if (!identical(...future.workdir, getwd())) 
[16:11:08.686]             setwd(...future.workdir)
[16:11:08.686]         {
[16:11:08.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:08.686]                 ...future.oldOptions$nwarnings <- NULL
[16:11:08.686]             }
[16:11:08.686]             base::options(...future.oldOptions)
[16:11:08.686]             if (.Platform$OS.type == "windows") {
[16:11:08.686]                 old_names <- names(...future.oldEnvVars)
[16:11:08.686]                 envs <- base::Sys.getenv()
[16:11:08.686]                 names <- names(envs)
[16:11:08.686]                 common <- intersect(names, old_names)
[16:11:08.686]                 added <- setdiff(names, old_names)
[16:11:08.686]                 removed <- setdiff(old_names, names)
[16:11:08.686]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:08.686]                   envs[common]]
[16:11:08.686]                 NAMES <- toupper(changed)
[16:11:08.686]                 args <- list()
[16:11:08.686]                 for (kk in seq_along(NAMES)) {
[16:11:08.686]                   name <- changed[[kk]]
[16:11:08.686]                   NAME <- NAMES[[kk]]
[16:11:08.686]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.686]                     next
[16:11:08.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.686]                 }
[16:11:08.686]                 NAMES <- toupper(added)
[16:11:08.686]                 for (kk in seq_along(NAMES)) {
[16:11:08.686]                   name <- added[[kk]]
[16:11:08.686]                   NAME <- NAMES[[kk]]
[16:11:08.686]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.686]                     next
[16:11:08.686]                   args[[name]] <- ""
[16:11:08.686]                 }
[16:11:08.686]                 NAMES <- toupper(removed)
[16:11:08.686]                 for (kk in seq_along(NAMES)) {
[16:11:08.686]                   name <- removed[[kk]]
[16:11:08.686]                   NAME <- NAMES[[kk]]
[16:11:08.686]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.686]                     next
[16:11:08.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.686]                 }
[16:11:08.686]                 if (length(args) > 0) 
[16:11:08.686]                   base::do.call(base::Sys.setenv, args = args)
[16:11:08.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:08.686]             }
[16:11:08.686]             else {
[16:11:08.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:08.686]             }
[16:11:08.686]             {
[16:11:08.686]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:08.686]                   0L) {
[16:11:08.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:08.686]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:08.686]                   base::options(opts)
[16:11:08.686]                 }
[16:11:08.686]                 {
[16:11:08.686]                   {
[16:11:08.686]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:08.686]                     NULL
[16:11:08.686]                   }
[16:11:08.686]                   options(future.plan = NULL)
[16:11:08.686]                   if (is.na(NA_character_)) 
[16:11:08.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:08.686]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:08.686]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:08.686]                     envir = parent.frame()) 
[16:11:08.686]                   {
[16:11:08.686]                     if (is.function(workers)) 
[16:11:08.686]                       workers <- workers()
[16:11:08.686]                     workers <- structure(as.integer(workers), 
[16:11:08.686]                       class = class(workers))
[16:11:08.686]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:08.686]                       workers >= 1)
[16:11:08.686]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:08.686]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:08.686]                     }
[16:11:08.686]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:08.686]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:08.686]                       envir = envir)
[16:11:08.686]                     if (!future$lazy) 
[16:11:08.686]                       future <- run(future)
[16:11:08.686]                     invisible(future)
[16:11:08.686]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:08.686]                 }
[16:11:08.686]             }
[16:11:08.686]         }
[16:11:08.686]     })
[16:11:08.686]     if (TRUE) {
[16:11:08.686]         base::sink(type = "output", split = FALSE)
[16:11:08.686]         if (TRUE) {
[16:11:08.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:08.686]         }
[16:11:08.686]         else {
[16:11:08.686]             ...future.result["stdout"] <- base::list(NULL)
[16:11:08.686]         }
[16:11:08.686]         base::close(...future.stdout)
[16:11:08.686]         ...future.stdout <- NULL
[16:11:08.686]     }
[16:11:08.686]     ...future.result$conditions <- ...future.conditions
[16:11:08.686]     ...future.result$finished <- base::Sys.time()
[16:11:08.686]     ...future.result
[16:11:08.686] }
[16:11:08.689] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[16:11:08.689] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:08.732] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:08.732] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:11:08.733] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:11:08.733] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:08.733] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:08.733] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:08.776] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:08.776] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:08.820] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:08.820] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:08.820] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:08.821] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[16:11:08.821] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[16:11:08.821] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:08.822] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:08.822] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[16:11:08.822] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[16:11:08.822] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:08.823] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:08.823] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:08.823] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:08.823] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[16:11:08.824] MultisessionFuture started
[16:11:08.824] - Launch lazy future ... done
[16:11:08.824] run() for ‘MultisessionFuture’ ... done
[16:11:08.825] Created future:
[16:11:08.825] MultisessionFuture:
[16:11:08.825] Label: ‘future_vapply-2’
[16:11:08.825] Expression:
[16:11:08.825] {
[16:11:08.825]     do.call(function(...) {
[16:11:08.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.825]             on.exit(options(oopts), add = TRUE)
[16:11:08.825]         }
[16:11:08.825]         {
[16:11:08.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.825]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.825]             })
[16:11:08.825]         }
[16:11:08.825]     }, args = future.call.arguments)
[16:11:08.825] }
[16:11:08.825] Lazy evaluation: FALSE
[16:11:08.825] Asynchronous evaluation: TRUE
[16:11:08.825] Local evaluation: TRUE
[16:11:08.825] Environment: R_GlobalEnv
[16:11:08.825] Capture standard output: TRUE
[16:11:08.825] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:08.825] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:08.825] Packages: 1 packages (‘future.apply’)
[16:11:08.825] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:08.825] Resolved: FALSE
[16:11:08.825] Value: <not collected>
[16:11:08.825] Conditions captured: <none>
[16:11:08.825] Early signaling: FALSE
[16:11:08.825] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:08.825] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.836] Chunk #2 of 2 ... DONE
[16:11:08.837] Launching 2 futures (chunks) ... DONE
[16:11:08.837] Resolving 2 futures (chunks) ...
[16:11:08.837] resolve() on list ...
[16:11:08.837]  recursive: 0
[16:11:08.837]  length: 2
[16:11:08.837] 
[16:11:08.838] receiveMessageFromWorker() for ClusterFuture ...
[16:11:08.838] - Validating connection of MultisessionFuture
[16:11:08.838] - received message: FutureResult
[16:11:08.838] - Received FutureResult
[16:11:08.838] - Erased future from FutureRegistry
[16:11:08.838] result() for ClusterFuture ...
[16:11:08.838] - result already collected: FutureResult
[16:11:08.838] result() for ClusterFuture ... done
[16:11:08.838] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:08.839] Future #1
[16:11:08.839] result() for ClusterFuture ...
[16:11:08.839] - result already collected: FutureResult
[16:11:08.839] result() for ClusterFuture ... done
[16:11:08.839] result() for ClusterFuture ...
[16:11:08.839] - result already collected: FutureResult
[16:11:08.839] result() for ClusterFuture ... done
[16:11:08.839] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:08.839] - nx: 2
[16:11:08.839] - relay: TRUE
[16:11:08.839] - stdout: TRUE
[16:11:08.839] - signal: TRUE
[16:11:08.840] - resignal: FALSE
[16:11:08.840] - force: TRUE
[16:11:08.840] - relayed: [n=2] FALSE, FALSE
[16:11:08.840] - queued futures: [n=2] FALSE, FALSE
[16:11:08.840]  - until=1
[16:11:08.840]  - relaying element #1
[16:11:08.840] result() for ClusterFuture ...
[16:11:08.840] - result already collected: FutureResult
[16:11:08.840] result() for ClusterFuture ... done
[16:11:08.840] result() for ClusterFuture ...
[16:11:08.840] - result already collected: FutureResult
[16:11:08.841] result() for ClusterFuture ... done
[16:11:08.841] result() for ClusterFuture ...
[16:11:08.841] - result already collected: FutureResult
[16:11:08.841] result() for ClusterFuture ... done
[16:11:08.841] result() for ClusterFuture ...
[16:11:08.841] - result already collected: FutureResult
[16:11:08.841] result() for ClusterFuture ... done
[16:11:08.841] - relayed: [n=2] TRUE, FALSE
[16:11:08.841] - queued futures: [n=2] TRUE, FALSE
[16:11:08.841] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:08.841]  length: 1 (resolved future 1)
[16:11:08.883] receiveMessageFromWorker() for ClusterFuture ...
[16:11:08.884] - Validating connection of MultisessionFuture
[16:11:08.884] - received message: FutureResult
[16:11:08.884] - Received FutureResult
[16:11:08.884] - Erased future from FutureRegistry
[16:11:08.884] result() for ClusterFuture ...
[16:11:08.884] - result already collected: FutureResult
[16:11:08.884] result() for ClusterFuture ... done
[16:11:08.885] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:08.885] Future #2
[16:11:08.885] result() for ClusterFuture ...
[16:11:08.885] - result already collected: FutureResult
[16:11:08.885] result() for ClusterFuture ... done
[16:11:08.885] result() for ClusterFuture ...
[16:11:08.885] - result already collected: FutureResult
[16:11:08.885] result() for ClusterFuture ... done
[16:11:08.885] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:08.885] - nx: 2
[16:11:08.885] - relay: TRUE
[16:11:08.886] - stdout: TRUE
[16:11:08.886] - signal: TRUE
[16:11:08.886] - resignal: FALSE
[16:11:08.886] - force: TRUE
[16:11:08.886] - relayed: [n=2] TRUE, FALSE
[16:11:08.886] - queued futures: [n=2] TRUE, FALSE
[16:11:08.886]  - until=2
[16:11:08.886]  - relaying element #2
[16:11:08.886] result() for ClusterFuture ...
[16:11:08.886] - result already collected: FutureResult
[16:11:08.886] result() for ClusterFuture ... done
[16:11:08.887] result() for ClusterFuture ...
[16:11:08.887] - result already collected: FutureResult
[16:11:08.887] result() for ClusterFuture ... done
[16:11:08.887] result() for ClusterFuture ...
[16:11:08.887] - result already collected: FutureResult
[16:11:08.887] result() for ClusterFuture ... done
[16:11:08.887] result() for ClusterFuture ...
[16:11:08.887] - result already collected: FutureResult
[16:11:08.887] result() for ClusterFuture ... done
[16:11:08.887] - relayed: [n=2] TRUE, TRUE
[16:11:08.887] - queued futures: [n=2] TRUE, TRUE
[16:11:08.888] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:08.888]  length: 0 (resolved future 2)
[16:11:08.888] Relaying remaining futures
[16:11:08.888] signalConditionsASAP(NULL, pos=0) ...
[16:11:08.888] - nx: 2
[16:11:08.888] - relay: TRUE
[16:11:08.888] - stdout: TRUE
[16:11:08.888] - signal: TRUE
[16:11:08.888] - resignal: FALSE
[16:11:08.888] - force: TRUE
[16:11:08.888] - relayed: [n=2] TRUE, TRUE
[16:11:08.889] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:08.889] - relayed: [n=2] TRUE, TRUE
[16:11:08.889] - queued futures: [n=2] TRUE, TRUE
[16:11:08.889] signalConditionsASAP(NULL, pos=0) ... done
[16:11:08.889] resolve() on list ... DONE
[16:11:08.889] result() for ClusterFuture ...
[16:11:08.889] - result already collected: FutureResult
[16:11:08.889] result() for ClusterFuture ... done
[16:11:08.889] result() for ClusterFuture ...
[16:11:08.889] - result already collected: FutureResult
[16:11:08.890] result() for ClusterFuture ... done
[16:11:08.890] result() for ClusterFuture ...
[16:11:08.890] - result already collected: FutureResult
[16:11:08.890] result() for ClusterFuture ... done
[16:11:08.890] result() for ClusterFuture ...
[16:11:08.890] - result already collected: FutureResult
[16:11:08.890] result() for ClusterFuture ... done
[16:11:08.890]  - Number of value chunks collected: 2
[16:11:08.890] Resolving 2 futures (chunks) ... DONE
[16:11:08.890] Reducing values from 2 chunks ...
[16:11:08.890]  - Number of values collected after concatenation: 11
[16:11:08.891]  - Number of values expected: 11
[16:11:08.891] Reducing values from 2 chunks ... DONE
[16:11:08.891] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[16:11:08.892] future_lapply() ...
[16:11:08.897] Number of chunks: 2
[16:11:08.897] getGlobalsAndPackagesXApply() ...
[16:11:08.898]  - future.globals: TRUE
[16:11:08.898] getGlobalsAndPackages() ...
[16:11:08.898] Searching for globals...
[16:11:08.901] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:08.901] Searching for globals ... DONE
[16:11:08.901] Resolving globals: FALSE
[16:11:08.902] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[16:11:08.902] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:08.903] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:08.903] - packages: [1] ‘future.apply’
[16:11:08.903] getGlobalsAndPackages() ... DONE
[16:11:08.903]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:08.903]  - needed namespaces: [n=1] ‘future.apply’
[16:11:08.903] Finding globals ... DONE
[16:11:08.903]  - use_args: TRUE
[16:11:08.903]  - Getting '...' globals ...
[16:11:08.904] resolve() on list ...
[16:11:08.904]  recursive: 0
[16:11:08.904]  length: 1
[16:11:08.904]  elements: ‘...’
[16:11:08.904]  length: 0 (resolved future 1)
[16:11:08.904] resolve() on list ... DONE
[16:11:08.904]    - '...' content: [n=0] 
[16:11:08.904] List of 1
[16:11:08.904]  $ ...: list()
[16:11:08.904]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:08.904]  - attr(*, "where")=List of 1
[16:11:08.904]   ..$ ...:<environment: 0x561e8b49f280> 
[16:11:08.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:08.904]  - attr(*, "resolved")= logi TRUE
[16:11:08.904]  - attr(*, "total_size")= num NA
[16:11:08.907]  - Getting '...' globals ... DONE
[16:11:08.907] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:08.907] List of 8
[16:11:08.907]  $ ...future.FUN:function (x, ...)  
[16:11:08.907]  $ x_FUN        :function (x)  
[16:11:08.907]  $ times        : int 1
[16:11:08.907]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:08.907]  $ stop_if_not  :function (...)  
[16:11:08.907]  $ dim          : NULL
[16:11:08.907]  $ valid_types  : chr [1:2] "logical" "integer"
[16:11:08.907]  $ ...          : list()
[16:11:08.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:08.907]  - attr(*, "where")=List of 8
[16:11:08.907]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:08.907]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:08.907]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:08.907]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:08.907]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:08.907]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:08.907]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:08.907]   ..$ ...          :<environment: 0x561e8b49f280> 
[16:11:08.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:08.907]  - attr(*, "resolved")= logi FALSE
[16:11:08.907]  - attr(*, "total_size")= num 94264
[16:11:08.913] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:08.913] getGlobalsAndPackagesXApply() ... DONE
[16:11:08.913] Number of futures (= number of chunks): 2
[16:11:08.913] Launching 2 futures (chunks) ...
[16:11:08.913] Chunk #1 of 2 ...
[16:11:08.913]  - Finding globals in 'X' for chunk #1 ...
[16:11:08.914] getGlobalsAndPackages() ...
[16:11:08.914] Searching for globals...
[16:11:08.914] 
[16:11:08.914] Searching for globals ... DONE
[16:11:08.914] - globals: [0] <none>
[16:11:08.914] getGlobalsAndPackages() ... DONE
[16:11:08.914]    + additional globals found: [n=0] 
[16:11:08.914]    + additional namespaces needed: [n=0] 
[16:11:08.914]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:08.915]  - seeds: <none>
[16:11:08.915] getGlobalsAndPackages() ...
[16:11:08.915] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.915] Resolving globals: FALSE
[16:11:08.915] Tweak future expression to call with '...' arguments ...
[16:11:08.915] {
[16:11:08.915]     do.call(function(...) {
[16:11:08.915]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.915]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:08.915]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.915]             on.exit(options(oopts), add = TRUE)
[16:11:08.915]         }
[16:11:08.915]         {
[16:11:08.915]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:08.915]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.915]                 ...future.FUN(...future.X_jj, ...)
[16:11:08.915]             })
[16:11:08.915]         }
[16:11:08.915]     }, args = future.call.arguments)
[16:11:08.915] }
[16:11:08.915] Tweak future expression to call with '...' arguments ... DONE
[16:11:08.916] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:08.916] - packages: [1] ‘future.apply’
[16:11:08.916] getGlobalsAndPackages() ... DONE
[16:11:08.917] run() for ‘Future’ ...
[16:11:08.917] - state: ‘created’
[16:11:08.917] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:08.931] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:08.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:08.932]   - Field: ‘node’
[16:11:08.932]   - Field: ‘label’
[16:11:08.932]   - Field: ‘local’
[16:11:08.932]   - Field: ‘owner’
[16:11:08.932]   - Field: ‘envir’
[16:11:08.932]   - Field: ‘workers’
[16:11:08.932]   - Field: ‘packages’
[16:11:08.932]   - Field: ‘gc’
[16:11:08.932]   - Field: ‘conditions’
[16:11:08.933]   - Field: ‘persistent’
[16:11:08.933]   - Field: ‘expr’
[16:11:08.933]   - Field: ‘uuid’
[16:11:08.933]   - Field: ‘seed’
[16:11:08.933]   - Field: ‘version’
[16:11:08.933]   - Field: ‘result’
[16:11:08.933]   - Field: ‘asynchronous’
[16:11:08.933]   - Field: ‘calls’
[16:11:08.933]   - Field: ‘globals’
[16:11:08.933]   - Field: ‘stdout’
[16:11:08.933]   - Field: ‘earlySignal’
[16:11:08.934]   - Field: ‘lazy’
[16:11:08.934]   - Field: ‘state’
[16:11:08.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:08.934] - Launch lazy future ...
[16:11:08.934] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:08.934] Packages needed by future strategies (n = 0): <none>
[16:11:08.935] {
[16:11:08.935]     {
[16:11:08.935]         {
[16:11:08.935]             ...future.startTime <- base::Sys.time()
[16:11:08.935]             {
[16:11:08.935]                 {
[16:11:08.935]                   {
[16:11:08.935]                     {
[16:11:08.935]                       {
[16:11:08.935]                         base::local({
[16:11:08.935]                           has_future <- base::requireNamespace("future", 
[16:11:08.935]                             quietly = TRUE)
[16:11:08.935]                           if (has_future) {
[16:11:08.935]                             ns <- base::getNamespace("future")
[16:11:08.935]                             version <- ns[[".package"]][["version"]]
[16:11:08.935]                             if (is.null(version)) 
[16:11:08.935]                               version <- utils::packageVersion("future")
[16:11:08.935]                           }
[16:11:08.935]                           else {
[16:11:08.935]                             version <- NULL
[16:11:08.935]                           }
[16:11:08.935]                           if (!has_future || version < "1.8.0") {
[16:11:08.935]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:08.935]                               "", base::R.version$version.string), 
[16:11:08.935]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:08.935]                                 base::R.version$platform, 8 * 
[16:11:08.935]                                   base::.Machine$sizeof.pointer), 
[16:11:08.935]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:08.935]                                 "release", "version")], collapse = " "), 
[16:11:08.935]                               hostname = base::Sys.info()[["nodename"]])
[16:11:08.935]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:08.935]                               info)
[16:11:08.935]                             info <- base::paste(info, collapse = "; ")
[16:11:08.935]                             if (!has_future) {
[16:11:08.935]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:08.935]                                 info)
[16:11:08.935]                             }
[16:11:08.935]                             else {
[16:11:08.935]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:08.935]                                 info, version)
[16:11:08.935]                             }
[16:11:08.935]                             base::stop(msg)
[16:11:08.935]                           }
[16:11:08.935]                         })
[16:11:08.935]                       }
[16:11:08.935]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:08.935]                       base::options(mc.cores = 1L)
[16:11:08.935]                     }
[16:11:08.935]                     base::local({
[16:11:08.935]                       for (pkg in "future.apply") {
[16:11:08.935]                         base::loadNamespace(pkg)
[16:11:08.935]                         base::library(pkg, character.only = TRUE)
[16:11:08.935]                       }
[16:11:08.935]                     })
[16:11:08.935]                   }
[16:11:08.935]                   options(future.plan = NULL)
[16:11:08.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:08.935]                 }
[16:11:08.935]                 ...future.workdir <- getwd()
[16:11:08.935]             }
[16:11:08.935]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:08.935]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:08.935]         }
[16:11:08.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:08.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:08.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:08.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:08.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:08.935]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:08.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:08.935]             base::names(...future.oldOptions))
[16:11:08.935]     }
[16:11:08.935]     if (FALSE) {
[16:11:08.935]     }
[16:11:08.935]     else {
[16:11:08.935]         if (TRUE) {
[16:11:08.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:08.935]                 open = "w")
[16:11:08.935]         }
[16:11:08.935]         else {
[16:11:08.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:08.935]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:08.935]         }
[16:11:08.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:08.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:08.935]             base::sink(type = "output", split = FALSE)
[16:11:08.935]             base::close(...future.stdout)
[16:11:08.935]         }, add = TRUE)
[16:11:08.935]     }
[16:11:08.935]     ...future.frame <- base::sys.nframe()
[16:11:08.935]     ...future.conditions <- base::list()
[16:11:08.935]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:08.935]     if (FALSE) {
[16:11:08.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:08.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:08.935]     }
[16:11:08.935]     ...future.result <- base::tryCatch({
[16:11:08.935]         base::withCallingHandlers({
[16:11:08.935]             ...future.value <- base::withVisible(base::local({
[16:11:08.935]                 ...future.makeSendCondition <- local({
[16:11:08.935]                   sendCondition <- NULL
[16:11:08.935]                   function(frame = 1L) {
[16:11:08.935]                     if (is.function(sendCondition)) 
[16:11:08.935]                       return(sendCondition)
[16:11:08.935]                     ns <- getNamespace("parallel")
[16:11:08.935]                     if (exists("sendData", mode = "function", 
[16:11:08.935]                       envir = ns)) {
[16:11:08.935]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:08.935]                         envir = ns)
[16:11:08.935]                       envir <- sys.frame(frame)
[16:11:08.935]                       master <- NULL
[16:11:08.935]                       while (!identical(envir, .GlobalEnv) && 
[16:11:08.935]                         !identical(envir, emptyenv())) {
[16:11:08.935]                         if (exists("master", mode = "list", envir = envir, 
[16:11:08.935]                           inherits = FALSE)) {
[16:11:08.935]                           master <- get("master", mode = "list", 
[16:11:08.935]                             envir = envir, inherits = FALSE)
[16:11:08.935]                           if (inherits(master, c("SOCKnode", 
[16:11:08.935]                             "SOCK0node"))) {
[16:11:08.935]                             sendCondition <<- function(cond) {
[16:11:08.935]                               data <- list(type = "VALUE", value = cond, 
[16:11:08.935]                                 success = TRUE)
[16:11:08.935]                               parallel_sendData(master, data)
[16:11:08.935]                             }
[16:11:08.935]                             return(sendCondition)
[16:11:08.935]                           }
[16:11:08.935]                         }
[16:11:08.935]                         frame <- frame + 1L
[16:11:08.935]                         envir <- sys.frame(frame)
[16:11:08.935]                       }
[16:11:08.935]                     }
[16:11:08.935]                     sendCondition <<- function(cond) NULL
[16:11:08.935]                   }
[16:11:08.935]                 })
[16:11:08.935]                 withCallingHandlers({
[16:11:08.935]                   {
[16:11:08.935]                     do.call(function(...) {
[16:11:08.935]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:08.935]                       if (!identical(...future.globals.maxSize.org, 
[16:11:08.935]                         ...future.globals.maxSize)) {
[16:11:08.935]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:08.935]                         on.exit(options(oopts), add = TRUE)
[16:11:08.935]                       }
[16:11:08.935]                       {
[16:11:08.935]                         lapply(seq_along(...future.elements_ii), 
[16:11:08.935]                           FUN = function(jj) {
[16:11:08.935]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:08.935]                             ...future.FUN(...future.X_jj, ...)
[16:11:08.935]                           })
[16:11:08.935]                       }
[16:11:08.935]                     }, args = future.call.arguments)
[16:11:08.935]                   }
[16:11:08.935]                 }, immediateCondition = function(cond) {
[16:11:08.935]                   sendCondition <- ...future.makeSendCondition()
[16:11:08.935]                   sendCondition(cond)
[16:11:08.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.935]                   {
[16:11:08.935]                     inherits <- base::inherits
[16:11:08.935]                     invokeRestart <- base::invokeRestart
[16:11:08.935]                     is.null <- base::is.null
[16:11:08.935]                     muffled <- FALSE
[16:11:08.935]                     if (inherits(cond, "message")) {
[16:11:08.935]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:08.935]                       if (muffled) 
[16:11:08.935]                         invokeRestart("muffleMessage")
[16:11:08.935]                     }
[16:11:08.935]                     else if (inherits(cond, "warning")) {
[16:11:08.935]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:08.935]                       if (muffled) 
[16:11:08.935]                         invokeRestart("muffleWarning")
[16:11:08.935]                     }
[16:11:08.935]                     else if (inherits(cond, "condition")) {
[16:11:08.935]                       if (!is.null(pattern)) {
[16:11:08.935]                         computeRestarts <- base::computeRestarts
[16:11:08.935]                         grepl <- base::grepl
[16:11:08.935]                         restarts <- computeRestarts(cond)
[16:11:08.935]                         for (restart in restarts) {
[16:11:08.935]                           name <- restart$name
[16:11:08.935]                           if (is.null(name)) 
[16:11:08.935]                             next
[16:11:08.935]                           if (!grepl(pattern, name)) 
[16:11:08.935]                             next
[16:11:08.935]                           invokeRestart(restart)
[16:11:08.935]                           muffled <- TRUE
[16:11:08.935]                           break
[16:11:08.935]                         }
[16:11:08.935]                       }
[16:11:08.935]                     }
[16:11:08.935]                     invisible(muffled)
[16:11:08.935]                   }
[16:11:08.935]                   muffleCondition(cond)
[16:11:08.935]                 })
[16:11:08.935]             }))
[16:11:08.935]             future::FutureResult(value = ...future.value$value, 
[16:11:08.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.935]                   ...future.rng), globalenv = if (FALSE) 
[16:11:08.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:08.935]                     ...future.globalenv.names))
[16:11:08.935]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:08.935]         }, condition = base::local({
[16:11:08.935]             c <- base::c
[16:11:08.935]             inherits <- base::inherits
[16:11:08.935]             invokeRestart <- base::invokeRestart
[16:11:08.935]             length <- base::length
[16:11:08.935]             list <- base::list
[16:11:08.935]             seq.int <- base::seq.int
[16:11:08.935]             signalCondition <- base::signalCondition
[16:11:08.935]             sys.calls <- base::sys.calls
[16:11:08.935]             `[[` <- base::`[[`
[16:11:08.935]             `+` <- base::`+`
[16:11:08.935]             `<<-` <- base::`<<-`
[16:11:08.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:08.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:08.935]                   3L)]
[16:11:08.935]             }
[16:11:08.935]             function(cond) {
[16:11:08.935]                 is_error <- inherits(cond, "error")
[16:11:08.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:08.935]                   NULL)
[16:11:08.935]                 if (is_error) {
[16:11:08.935]                   sessionInformation <- function() {
[16:11:08.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:08.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:08.935]                       search = base::search(), system = base::Sys.info())
[16:11:08.935]                   }
[16:11:08.935]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:08.935]                     cond$call), session = sessionInformation(), 
[16:11:08.935]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:08.935]                   signalCondition(cond)
[16:11:08.935]                 }
[16:11:08.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:08.935]                 "immediateCondition"))) {
[16:11:08.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:08.935]                   ...future.conditions[[length(...future.conditions) + 
[16:11:08.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:08.935]                   if (TRUE && !signal) {
[16:11:08.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.935]                     {
[16:11:08.935]                       inherits <- base::inherits
[16:11:08.935]                       invokeRestart <- base::invokeRestart
[16:11:08.935]                       is.null <- base::is.null
[16:11:08.935]                       muffled <- FALSE
[16:11:08.935]                       if (inherits(cond, "message")) {
[16:11:08.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.935]                         if (muffled) 
[16:11:08.935]                           invokeRestart("muffleMessage")
[16:11:08.935]                       }
[16:11:08.935]                       else if (inherits(cond, "warning")) {
[16:11:08.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.935]                         if (muffled) 
[16:11:08.935]                           invokeRestart("muffleWarning")
[16:11:08.935]                       }
[16:11:08.935]                       else if (inherits(cond, "condition")) {
[16:11:08.935]                         if (!is.null(pattern)) {
[16:11:08.935]                           computeRestarts <- base::computeRestarts
[16:11:08.935]                           grepl <- base::grepl
[16:11:08.935]                           restarts <- computeRestarts(cond)
[16:11:08.935]                           for (restart in restarts) {
[16:11:08.935]                             name <- restart$name
[16:11:08.935]                             if (is.null(name)) 
[16:11:08.935]                               next
[16:11:08.935]                             if (!grepl(pattern, name)) 
[16:11:08.935]                               next
[16:11:08.935]                             invokeRestart(restart)
[16:11:08.935]                             muffled <- TRUE
[16:11:08.935]                             break
[16:11:08.935]                           }
[16:11:08.935]                         }
[16:11:08.935]                       }
[16:11:08.935]                       invisible(muffled)
[16:11:08.935]                     }
[16:11:08.935]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.935]                   }
[16:11:08.935]                 }
[16:11:08.935]                 else {
[16:11:08.935]                   if (TRUE) {
[16:11:08.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:08.935]                     {
[16:11:08.935]                       inherits <- base::inherits
[16:11:08.935]                       invokeRestart <- base::invokeRestart
[16:11:08.935]                       is.null <- base::is.null
[16:11:08.935]                       muffled <- FALSE
[16:11:08.935]                       if (inherits(cond, "message")) {
[16:11:08.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:08.935]                         if (muffled) 
[16:11:08.935]                           invokeRestart("muffleMessage")
[16:11:08.935]                       }
[16:11:08.935]                       else if (inherits(cond, "warning")) {
[16:11:08.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:08.935]                         if (muffled) 
[16:11:08.935]                           invokeRestart("muffleWarning")
[16:11:08.935]                       }
[16:11:08.935]                       else if (inherits(cond, "condition")) {
[16:11:08.935]                         if (!is.null(pattern)) {
[16:11:08.935]                           computeRestarts <- base::computeRestarts
[16:11:08.935]                           grepl <- base::grepl
[16:11:08.935]                           restarts <- computeRestarts(cond)
[16:11:08.935]                           for (restart in restarts) {
[16:11:08.935]                             name <- restart$name
[16:11:08.935]                             if (is.null(name)) 
[16:11:08.935]                               next
[16:11:08.935]                             if (!grepl(pattern, name)) 
[16:11:08.935]                               next
[16:11:08.935]                             invokeRestart(restart)
[16:11:08.935]                             muffled <- TRUE
[16:11:08.935]                             break
[16:11:08.935]                           }
[16:11:08.935]                         }
[16:11:08.935]                       }
[16:11:08.935]                       invisible(muffled)
[16:11:08.935]                     }
[16:11:08.935]                     muffleCondition(cond, pattern = "^muffle")
[16:11:08.935]                   }
[16:11:08.935]                 }
[16:11:08.935]             }
[16:11:08.935]         }))
[16:11:08.935]     }, error = function(ex) {
[16:11:08.935]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:08.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:08.935]                 ...future.rng), started = ...future.startTime, 
[16:11:08.935]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:08.935]             version = "1.8"), class = "FutureResult")
[16:11:08.935]     }, finally = {
[16:11:08.935]         if (!identical(...future.workdir, getwd())) 
[16:11:08.935]             setwd(...future.workdir)
[16:11:08.935]         {
[16:11:08.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:08.935]                 ...future.oldOptions$nwarnings <- NULL
[16:11:08.935]             }
[16:11:08.935]             base::options(...future.oldOptions)
[16:11:08.935]             if (.Platform$OS.type == "windows") {
[16:11:08.935]                 old_names <- names(...future.oldEnvVars)
[16:11:08.935]                 envs <- base::Sys.getenv()
[16:11:08.935]                 names <- names(envs)
[16:11:08.935]                 common <- intersect(names, old_names)
[16:11:08.935]                 added <- setdiff(names, old_names)
[16:11:08.935]                 removed <- setdiff(old_names, names)
[16:11:08.935]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:08.935]                   envs[common]]
[16:11:08.935]                 NAMES <- toupper(changed)
[16:11:08.935]                 args <- list()
[16:11:08.935]                 for (kk in seq_along(NAMES)) {
[16:11:08.935]                   name <- changed[[kk]]
[16:11:08.935]                   NAME <- NAMES[[kk]]
[16:11:08.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.935]                     next
[16:11:08.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.935]                 }
[16:11:08.935]                 NAMES <- toupper(added)
[16:11:08.935]                 for (kk in seq_along(NAMES)) {
[16:11:08.935]                   name <- added[[kk]]
[16:11:08.935]                   NAME <- NAMES[[kk]]
[16:11:08.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.935]                     next
[16:11:08.935]                   args[[name]] <- ""
[16:11:08.935]                 }
[16:11:08.935]                 NAMES <- toupper(removed)
[16:11:08.935]                 for (kk in seq_along(NAMES)) {
[16:11:08.935]                   name <- removed[[kk]]
[16:11:08.935]                   NAME <- NAMES[[kk]]
[16:11:08.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:08.935]                     next
[16:11:08.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:08.935]                 }
[16:11:08.935]                 if (length(args) > 0) 
[16:11:08.935]                   base::do.call(base::Sys.setenv, args = args)
[16:11:08.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:08.935]             }
[16:11:08.935]             else {
[16:11:08.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:08.935]             }
[16:11:08.935]             {
[16:11:08.935]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:08.935]                   0L) {
[16:11:08.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:08.935]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:08.935]                   base::options(opts)
[16:11:08.935]                 }
[16:11:08.935]                 {
[16:11:08.935]                   {
[16:11:08.935]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:08.935]                     NULL
[16:11:08.935]                   }
[16:11:08.935]                   options(future.plan = NULL)
[16:11:08.935]                   if (is.na(NA_character_)) 
[16:11:08.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:08.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:08.935]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:08.935]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:08.935]                     envir = parent.frame()) 
[16:11:08.935]                   {
[16:11:08.935]                     if (is.function(workers)) 
[16:11:08.935]                       workers <- workers()
[16:11:08.935]                     workers <- structure(as.integer(workers), 
[16:11:08.935]                       class = class(workers))
[16:11:08.935]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:08.935]                       workers >= 1)
[16:11:08.935]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:08.935]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:08.935]                     }
[16:11:08.935]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:08.935]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:08.935]                       envir = envir)
[16:11:08.935]                     if (!future$lazy) 
[16:11:08.935]                       future <- run(future)
[16:11:08.935]                     invisible(future)
[16:11:08.935]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:08.935]                 }
[16:11:08.935]             }
[16:11:08.935]         }
[16:11:08.935]     })
[16:11:08.935]     if (TRUE) {
[16:11:08.935]         base::sink(type = "output", split = FALSE)
[16:11:08.935]         if (TRUE) {
[16:11:08.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:08.935]         }
[16:11:08.935]         else {
[16:11:08.935]             ...future.result["stdout"] <- base::list(NULL)
[16:11:08.935]         }
[16:11:08.935]         base::close(...future.stdout)
[16:11:08.935]         ...future.stdout <- NULL
[16:11:08.935]     }
[16:11:08.935]     ...future.result$conditions <- ...future.conditions
[16:11:08.935]     ...future.result$finished <- base::Sys.time()
[16:11:08.935]     ...future.result
[16:11:08.935] }
[16:11:08.941] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[16:11:08.941] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:08.984] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:08.984] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[16:11:08.985] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[16:11:08.985] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:08.985] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:08.985] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:09.028] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:09.028] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:09.072] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:09.072] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:09.072] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:09.073] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[16:11:09.073] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[16:11:09.073] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:09.074] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:09.074] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:11:09.074] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:11:09.074] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:09.074] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:09.075] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:09.075] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:09.075] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[16:11:09.076] MultisessionFuture started
[16:11:09.076] - Launch lazy future ... done
[16:11:09.076] run() for ‘MultisessionFuture’ ... done
[16:11:09.076] Created future:
[16:11:09.076] MultisessionFuture:
[16:11:09.076] Label: ‘future_vapply-1’
[16:11:09.076] Expression:
[16:11:09.076] {
[16:11:09.076]     do.call(function(...) {
[16:11:09.076]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.076]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:09.076]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.076]             on.exit(options(oopts), add = TRUE)
[16:11:09.076]         }
[16:11:09.076]         {
[16:11:09.076]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:09.076]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.076]                 ...future.FUN(...future.X_jj, ...)
[16:11:09.076]             })
[16:11:09.076]         }
[16:11:09.076]     }, args = future.call.arguments)
[16:11:09.076] }
[16:11:09.076] Lazy evaluation: FALSE
[16:11:09.076] Asynchronous evaluation: TRUE
[16:11:09.076] Local evaluation: TRUE
[16:11:09.076] Environment: R_GlobalEnv
[16:11:09.076] Capture standard output: TRUE
[16:11:09.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:09.076] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:09.076] Packages: 1 packages (‘future.apply’)
[16:11:09.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:09.076] Resolved: FALSE
[16:11:09.076] Value: <not collected>
[16:11:09.076] Conditions captured: <none>
[16:11:09.076] Early signaling: FALSE
[16:11:09.076] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:09.076] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:09.088] Chunk #1 of 2 ... DONE
[16:11:09.088] Chunk #2 of 2 ...
[16:11:09.088]  - Finding globals in 'X' for chunk #2 ...
[16:11:09.088] getGlobalsAndPackages() ...
[16:11:09.088] Searching for globals...
[16:11:09.089] 
[16:11:09.089] Searching for globals ... DONE
[16:11:09.089] - globals: [0] <none>
[16:11:09.089] getGlobalsAndPackages() ... DONE
[16:11:09.089]    + additional globals found: [n=0] 
[16:11:09.089]    + additional namespaces needed: [n=0] 
[16:11:09.089]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:09.089]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:09.089]  - seeds: <none>
[16:11:09.089] getGlobalsAndPackages() ...
[16:11:09.090] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:09.090] Resolving globals: FALSE
[16:11:09.090] Tweak future expression to call with '...' arguments ...
[16:11:09.090] {
[16:11:09.090]     do.call(function(...) {
[16:11:09.090]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.090]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:09.090]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.090]             on.exit(options(oopts), add = TRUE)
[16:11:09.090]         }
[16:11:09.090]         {
[16:11:09.090]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:09.090]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.090]                 ...future.FUN(...future.X_jj, ...)
[16:11:09.090]             })
[16:11:09.090]         }
[16:11:09.090]     }, args = future.call.arguments)
[16:11:09.090] }
[16:11:09.090] Tweak future expression to call with '...' arguments ... DONE
[16:11:09.091] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:09.091] - packages: [1] ‘future.apply’
[16:11:09.091] getGlobalsAndPackages() ... DONE
[16:11:09.091] run() for ‘Future’ ...
[16:11:09.091] - state: ‘created’
[16:11:09.091] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:09.106] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:09.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:09.106]   - Field: ‘node’
[16:11:09.106]   - Field: ‘label’
[16:11:09.106]   - Field: ‘local’
[16:11:09.107]   - Field: ‘owner’
[16:11:09.107]   - Field: ‘envir’
[16:11:09.107]   - Field: ‘workers’
[16:11:09.107]   - Field: ‘packages’
[16:11:09.107]   - Field: ‘gc’
[16:11:09.107]   - Field: ‘conditions’
[16:11:09.107]   - Field: ‘persistent’
[16:11:09.107]   - Field: ‘expr’
[16:11:09.107]   - Field: ‘uuid’
[16:11:09.107]   - Field: ‘seed’
[16:11:09.107]   - Field: ‘version’
[16:11:09.108]   - Field: ‘result’
[16:11:09.108]   - Field: ‘asynchronous’
[16:11:09.108]   - Field: ‘calls’
[16:11:09.108]   - Field: ‘globals’
[16:11:09.108]   - Field: ‘stdout’
[16:11:09.108]   - Field: ‘earlySignal’
[16:11:09.108]   - Field: ‘lazy’
[16:11:09.108]   - Field: ‘state’
[16:11:09.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:09.108] - Launch lazy future ...
[16:11:09.109] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:09.109] Packages needed by future strategies (n = 0): <none>
[16:11:09.109] {
[16:11:09.109]     {
[16:11:09.109]         {
[16:11:09.109]             ...future.startTime <- base::Sys.time()
[16:11:09.109]             {
[16:11:09.109]                 {
[16:11:09.109]                   {
[16:11:09.109]                     {
[16:11:09.109]                       {
[16:11:09.109]                         base::local({
[16:11:09.109]                           has_future <- base::requireNamespace("future", 
[16:11:09.109]                             quietly = TRUE)
[16:11:09.109]                           if (has_future) {
[16:11:09.109]                             ns <- base::getNamespace("future")
[16:11:09.109]                             version <- ns[[".package"]][["version"]]
[16:11:09.109]                             if (is.null(version)) 
[16:11:09.109]                               version <- utils::packageVersion("future")
[16:11:09.109]                           }
[16:11:09.109]                           else {
[16:11:09.109]                             version <- NULL
[16:11:09.109]                           }
[16:11:09.109]                           if (!has_future || version < "1.8.0") {
[16:11:09.109]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:09.109]                               "", base::R.version$version.string), 
[16:11:09.109]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:09.109]                                 base::R.version$platform, 8 * 
[16:11:09.109]                                   base::.Machine$sizeof.pointer), 
[16:11:09.109]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:09.109]                                 "release", "version")], collapse = " "), 
[16:11:09.109]                               hostname = base::Sys.info()[["nodename"]])
[16:11:09.109]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:09.109]                               info)
[16:11:09.109]                             info <- base::paste(info, collapse = "; ")
[16:11:09.109]                             if (!has_future) {
[16:11:09.109]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:09.109]                                 info)
[16:11:09.109]                             }
[16:11:09.109]                             else {
[16:11:09.109]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:09.109]                                 info, version)
[16:11:09.109]                             }
[16:11:09.109]                             base::stop(msg)
[16:11:09.109]                           }
[16:11:09.109]                         })
[16:11:09.109]                       }
[16:11:09.109]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:09.109]                       base::options(mc.cores = 1L)
[16:11:09.109]                     }
[16:11:09.109]                     base::local({
[16:11:09.109]                       for (pkg in "future.apply") {
[16:11:09.109]                         base::loadNamespace(pkg)
[16:11:09.109]                         base::library(pkg, character.only = TRUE)
[16:11:09.109]                       }
[16:11:09.109]                     })
[16:11:09.109]                   }
[16:11:09.109]                   options(future.plan = NULL)
[16:11:09.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:09.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:09.109]                 }
[16:11:09.109]                 ...future.workdir <- getwd()
[16:11:09.109]             }
[16:11:09.109]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:09.109]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:09.109]         }
[16:11:09.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:09.109]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:09.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:09.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:09.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:09.109]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:09.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:09.109]             base::names(...future.oldOptions))
[16:11:09.109]     }
[16:11:09.109]     if (FALSE) {
[16:11:09.109]     }
[16:11:09.109]     else {
[16:11:09.109]         if (TRUE) {
[16:11:09.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:09.109]                 open = "w")
[16:11:09.109]         }
[16:11:09.109]         else {
[16:11:09.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:09.109]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:09.109]         }
[16:11:09.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:09.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:09.109]             base::sink(type = "output", split = FALSE)
[16:11:09.109]             base::close(...future.stdout)
[16:11:09.109]         }, add = TRUE)
[16:11:09.109]     }
[16:11:09.109]     ...future.frame <- base::sys.nframe()
[16:11:09.109]     ...future.conditions <- base::list()
[16:11:09.109]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:09.109]     if (FALSE) {
[16:11:09.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:09.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:09.109]     }
[16:11:09.109]     ...future.result <- base::tryCatch({
[16:11:09.109]         base::withCallingHandlers({
[16:11:09.109]             ...future.value <- base::withVisible(base::local({
[16:11:09.109]                 ...future.makeSendCondition <- local({
[16:11:09.109]                   sendCondition <- NULL
[16:11:09.109]                   function(frame = 1L) {
[16:11:09.109]                     if (is.function(sendCondition)) 
[16:11:09.109]                       return(sendCondition)
[16:11:09.109]                     ns <- getNamespace("parallel")
[16:11:09.109]                     if (exists("sendData", mode = "function", 
[16:11:09.109]                       envir = ns)) {
[16:11:09.109]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:09.109]                         envir = ns)
[16:11:09.109]                       envir <- sys.frame(frame)
[16:11:09.109]                       master <- NULL
[16:11:09.109]                       while (!identical(envir, .GlobalEnv) && 
[16:11:09.109]                         !identical(envir, emptyenv())) {
[16:11:09.109]                         if (exists("master", mode = "list", envir = envir, 
[16:11:09.109]                           inherits = FALSE)) {
[16:11:09.109]                           master <- get("master", mode = "list", 
[16:11:09.109]                             envir = envir, inherits = FALSE)
[16:11:09.109]                           if (inherits(master, c("SOCKnode", 
[16:11:09.109]                             "SOCK0node"))) {
[16:11:09.109]                             sendCondition <<- function(cond) {
[16:11:09.109]                               data <- list(type = "VALUE", value = cond, 
[16:11:09.109]                                 success = TRUE)
[16:11:09.109]                               parallel_sendData(master, data)
[16:11:09.109]                             }
[16:11:09.109]                             return(sendCondition)
[16:11:09.109]                           }
[16:11:09.109]                         }
[16:11:09.109]                         frame <- frame + 1L
[16:11:09.109]                         envir <- sys.frame(frame)
[16:11:09.109]                       }
[16:11:09.109]                     }
[16:11:09.109]                     sendCondition <<- function(cond) NULL
[16:11:09.109]                   }
[16:11:09.109]                 })
[16:11:09.109]                 withCallingHandlers({
[16:11:09.109]                   {
[16:11:09.109]                     do.call(function(...) {
[16:11:09.109]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.109]                       if (!identical(...future.globals.maxSize.org, 
[16:11:09.109]                         ...future.globals.maxSize)) {
[16:11:09.109]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.109]                         on.exit(options(oopts), add = TRUE)
[16:11:09.109]                       }
[16:11:09.109]                       {
[16:11:09.109]                         lapply(seq_along(...future.elements_ii), 
[16:11:09.109]                           FUN = function(jj) {
[16:11:09.109]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.109]                             ...future.FUN(...future.X_jj, ...)
[16:11:09.109]                           })
[16:11:09.109]                       }
[16:11:09.109]                     }, args = future.call.arguments)
[16:11:09.109]                   }
[16:11:09.109]                 }, immediateCondition = function(cond) {
[16:11:09.109]                   sendCondition <- ...future.makeSendCondition()
[16:11:09.109]                   sendCondition(cond)
[16:11:09.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.109]                   {
[16:11:09.109]                     inherits <- base::inherits
[16:11:09.109]                     invokeRestart <- base::invokeRestart
[16:11:09.109]                     is.null <- base::is.null
[16:11:09.109]                     muffled <- FALSE
[16:11:09.109]                     if (inherits(cond, "message")) {
[16:11:09.109]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:09.109]                       if (muffled) 
[16:11:09.109]                         invokeRestart("muffleMessage")
[16:11:09.109]                     }
[16:11:09.109]                     else if (inherits(cond, "warning")) {
[16:11:09.109]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:09.109]                       if (muffled) 
[16:11:09.109]                         invokeRestart("muffleWarning")
[16:11:09.109]                     }
[16:11:09.109]                     else if (inherits(cond, "condition")) {
[16:11:09.109]                       if (!is.null(pattern)) {
[16:11:09.109]                         computeRestarts <- base::computeRestarts
[16:11:09.109]                         grepl <- base::grepl
[16:11:09.109]                         restarts <- computeRestarts(cond)
[16:11:09.109]                         for (restart in restarts) {
[16:11:09.109]                           name <- restart$name
[16:11:09.109]                           if (is.null(name)) 
[16:11:09.109]                             next
[16:11:09.109]                           if (!grepl(pattern, name)) 
[16:11:09.109]                             next
[16:11:09.109]                           invokeRestart(restart)
[16:11:09.109]                           muffled <- TRUE
[16:11:09.109]                           break
[16:11:09.109]                         }
[16:11:09.109]                       }
[16:11:09.109]                     }
[16:11:09.109]                     invisible(muffled)
[16:11:09.109]                   }
[16:11:09.109]                   muffleCondition(cond)
[16:11:09.109]                 })
[16:11:09.109]             }))
[16:11:09.109]             future::FutureResult(value = ...future.value$value, 
[16:11:09.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:09.109]                   ...future.rng), globalenv = if (FALSE) 
[16:11:09.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:09.109]                     ...future.globalenv.names))
[16:11:09.109]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:09.109]         }, condition = base::local({
[16:11:09.109]             c <- base::c
[16:11:09.109]             inherits <- base::inherits
[16:11:09.109]             invokeRestart <- base::invokeRestart
[16:11:09.109]             length <- base::length
[16:11:09.109]             list <- base::list
[16:11:09.109]             seq.int <- base::seq.int
[16:11:09.109]             signalCondition <- base::signalCondition
[16:11:09.109]             sys.calls <- base::sys.calls
[16:11:09.109]             `[[` <- base::`[[`
[16:11:09.109]             `+` <- base::`+`
[16:11:09.109]             `<<-` <- base::`<<-`
[16:11:09.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:09.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:09.109]                   3L)]
[16:11:09.109]             }
[16:11:09.109]             function(cond) {
[16:11:09.109]                 is_error <- inherits(cond, "error")
[16:11:09.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:09.109]                   NULL)
[16:11:09.109]                 if (is_error) {
[16:11:09.109]                   sessionInformation <- function() {
[16:11:09.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:09.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:09.109]                       search = base::search(), system = base::Sys.info())
[16:11:09.109]                   }
[16:11:09.109]                   ...future.conditions[[length(...future.conditions) + 
[16:11:09.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:09.109]                     cond$call), session = sessionInformation(), 
[16:11:09.109]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:09.109]                   signalCondition(cond)
[16:11:09.109]                 }
[16:11:09.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:09.109]                 "immediateCondition"))) {
[16:11:09.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:09.109]                   ...future.conditions[[length(...future.conditions) + 
[16:11:09.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:09.109]                   if (TRUE && !signal) {
[16:11:09.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.109]                     {
[16:11:09.109]                       inherits <- base::inherits
[16:11:09.109]                       invokeRestart <- base::invokeRestart
[16:11:09.109]                       is.null <- base::is.null
[16:11:09.109]                       muffled <- FALSE
[16:11:09.109]                       if (inherits(cond, "message")) {
[16:11:09.109]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:09.109]                         if (muffled) 
[16:11:09.109]                           invokeRestart("muffleMessage")
[16:11:09.109]                       }
[16:11:09.109]                       else if (inherits(cond, "warning")) {
[16:11:09.109]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:09.109]                         if (muffled) 
[16:11:09.109]                           invokeRestart("muffleWarning")
[16:11:09.109]                       }
[16:11:09.109]                       else if (inherits(cond, "condition")) {
[16:11:09.109]                         if (!is.null(pattern)) {
[16:11:09.109]                           computeRestarts <- base::computeRestarts
[16:11:09.109]                           grepl <- base::grepl
[16:11:09.109]                           restarts <- computeRestarts(cond)
[16:11:09.109]                           for (restart in restarts) {
[16:11:09.109]                             name <- restart$name
[16:11:09.109]                             if (is.null(name)) 
[16:11:09.109]                               next
[16:11:09.109]                             if (!grepl(pattern, name)) 
[16:11:09.109]                               next
[16:11:09.109]                             invokeRestart(restart)
[16:11:09.109]                             muffled <- TRUE
[16:11:09.109]                             break
[16:11:09.109]                           }
[16:11:09.109]                         }
[16:11:09.109]                       }
[16:11:09.109]                       invisible(muffled)
[16:11:09.109]                     }
[16:11:09.109]                     muffleCondition(cond, pattern = "^muffle")
[16:11:09.109]                   }
[16:11:09.109]                 }
[16:11:09.109]                 else {
[16:11:09.109]                   if (TRUE) {
[16:11:09.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.109]                     {
[16:11:09.109]                       inherits <- base::inherits
[16:11:09.109]                       invokeRestart <- base::invokeRestart
[16:11:09.109]                       is.null <- base::is.null
[16:11:09.109]                       muffled <- FALSE
[16:11:09.109]                       if (inherits(cond, "message")) {
[16:11:09.109]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:09.109]                         if (muffled) 
[16:11:09.109]                           invokeRestart("muffleMessage")
[16:11:09.109]                       }
[16:11:09.109]                       else if (inherits(cond, "warning")) {
[16:11:09.109]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:09.109]                         if (muffled) 
[16:11:09.109]                           invokeRestart("muffleWarning")
[16:11:09.109]                       }
[16:11:09.109]                       else if (inherits(cond, "condition")) {
[16:11:09.109]                         if (!is.null(pattern)) {
[16:11:09.109]                           computeRestarts <- base::computeRestarts
[16:11:09.109]                           grepl <- base::grepl
[16:11:09.109]                           restarts <- computeRestarts(cond)
[16:11:09.109]                           for (restart in restarts) {
[16:11:09.109]                             name <- restart$name
[16:11:09.109]                             if (is.null(name)) 
[16:11:09.109]                               next
[16:11:09.109]                             if (!grepl(pattern, name)) 
[16:11:09.109]                               next
[16:11:09.109]                             invokeRestart(restart)
[16:11:09.109]                             muffled <- TRUE
[16:11:09.109]                             break
[16:11:09.109]                           }
[16:11:09.109]                         }
[16:11:09.109]                       }
[16:11:09.109]                       invisible(muffled)
[16:11:09.109]                     }
[16:11:09.109]                     muffleCondition(cond, pattern = "^muffle")
[16:11:09.109]                   }
[16:11:09.109]                 }
[16:11:09.109]             }
[16:11:09.109]         }))
[16:11:09.109]     }, error = function(ex) {
[16:11:09.109]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:09.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:09.109]                 ...future.rng), started = ...future.startTime, 
[16:11:09.109]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:09.109]             version = "1.8"), class = "FutureResult")
[16:11:09.109]     }, finally = {
[16:11:09.109]         if (!identical(...future.workdir, getwd())) 
[16:11:09.109]             setwd(...future.workdir)
[16:11:09.109]         {
[16:11:09.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:09.109]                 ...future.oldOptions$nwarnings <- NULL
[16:11:09.109]             }
[16:11:09.109]             base::options(...future.oldOptions)
[16:11:09.109]             if (.Platform$OS.type == "windows") {
[16:11:09.109]                 old_names <- names(...future.oldEnvVars)
[16:11:09.109]                 envs <- base::Sys.getenv()
[16:11:09.109]                 names <- names(envs)
[16:11:09.109]                 common <- intersect(names, old_names)
[16:11:09.109]                 added <- setdiff(names, old_names)
[16:11:09.109]                 removed <- setdiff(old_names, names)
[16:11:09.109]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:09.109]                   envs[common]]
[16:11:09.109]                 NAMES <- toupper(changed)
[16:11:09.109]                 args <- list()
[16:11:09.109]                 for (kk in seq_along(NAMES)) {
[16:11:09.109]                   name <- changed[[kk]]
[16:11:09.109]                   NAME <- NAMES[[kk]]
[16:11:09.109]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.109]                     next
[16:11:09.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:09.109]                 }
[16:11:09.109]                 NAMES <- toupper(added)
[16:11:09.109]                 for (kk in seq_along(NAMES)) {
[16:11:09.109]                   name <- added[[kk]]
[16:11:09.109]                   NAME <- NAMES[[kk]]
[16:11:09.109]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.109]                     next
[16:11:09.109]                   args[[name]] <- ""
[16:11:09.109]                 }
[16:11:09.109]                 NAMES <- toupper(removed)
[16:11:09.109]                 for (kk in seq_along(NAMES)) {
[16:11:09.109]                   name <- removed[[kk]]
[16:11:09.109]                   NAME <- NAMES[[kk]]
[16:11:09.109]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.109]                     next
[16:11:09.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:09.109]                 }
[16:11:09.109]                 if (length(args) > 0) 
[16:11:09.109]                   base::do.call(base::Sys.setenv, args = args)
[16:11:09.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:09.109]             }
[16:11:09.109]             else {
[16:11:09.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:09.109]             }
[16:11:09.109]             {
[16:11:09.109]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:09.109]                   0L) {
[16:11:09.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:09.109]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:09.109]                   base::options(opts)
[16:11:09.109]                 }
[16:11:09.109]                 {
[16:11:09.109]                   {
[16:11:09.109]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:09.109]                     NULL
[16:11:09.109]                   }
[16:11:09.109]                   options(future.plan = NULL)
[16:11:09.109]                   if (is.na(NA_character_)) 
[16:11:09.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:09.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:09.109]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:09.109]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:09.109]                     envir = parent.frame()) 
[16:11:09.109]                   {
[16:11:09.109]                     if (is.function(workers)) 
[16:11:09.109]                       workers <- workers()
[16:11:09.109]                     workers <- structure(as.integer(workers), 
[16:11:09.109]                       class = class(workers))
[16:11:09.109]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:09.109]                       workers >= 1)
[16:11:09.109]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:09.109]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:09.109]                     }
[16:11:09.109]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:09.109]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:09.109]                       envir = envir)
[16:11:09.109]                     if (!future$lazy) 
[16:11:09.109]                       future <- run(future)
[16:11:09.109]                     invisible(future)
[16:11:09.109]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:09.109]                 }
[16:11:09.109]             }
[16:11:09.109]         }
[16:11:09.109]     })
[16:11:09.109]     if (TRUE) {
[16:11:09.109]         base::sink(type = "output", split = FALSE)
[16:11:09.109]         if (TRUE) {
[16:11:09.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:09.109]         }
[16:11:09.109]         else {
[16:11:09.109]             ...future.result["stdout"] <- base::list(NULL)
[16:11:09.109]         }
[16:11:09.109]         base::close(...future.stdout)
[16:11:09.109]         ...future.stdout <- NULL
[16:11:09.109]     }
[16:11:09.109]     ...future.result$conditions <- ...future.conditions
[16:11:09.109]     ...future.result$finished <- base::Sys.time()
[16:11:09.109]     ...future.result
[16:11:09.109] }
[16:11:09.112] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[16:11:09.112] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:09.156] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:09.156] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[16:11:09.157] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[16:11:09.157] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:09.157] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:09.157] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:09.200] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:09.200] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:09.244] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:09.244] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:09.244] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:09.245] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[16:11:09.245] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[16:11:09.245] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:09.246] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:09.246] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:11:09.246] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:11:09.246] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:09.247] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:09.247] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:09.247] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:09.247] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[16:11:09.248] MultisessionFuture started
[16:11:09.248] - Launch lazy future ... done
[16:11:09.248] run() for ‘MultisessionFuture’ ... done
[16:11:09.248] Created future:
[16:11:09.248] MultisessionFuture:
[16:11:09.248] Label: ‘future_vapply-2’
[16:11:09.248] Expression:
[16:11:09.248] {
[16:11:09.248]     do.call(function(...) {
[16:11:09.248]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.248]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:09.248]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.248]             on.exit(options(oopts), add = TRUE)
[16:11:09.248]         }
[16:11:09.248]         {
[16:11:09.248]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:09.248]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.248]                 ...future.FUN(...future.X_jj, ...)
[16:11:09.248]             })
[16:11:09.248]         }
[16:11:09.248]     }, args = future.call.arguments)
[16:11:09.248] }
[16:11:09.248] Lazy evaluation: FALSE
[16:11:09.248] Asynchronous evaluation: TRUE
[16:11:09.248] Local evaluation: TRUE
[16:11:09.248] Environment: R_GlobalEnv
[16:11:09.248] Capture standard output: TRUE
[16:11:09.248] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:09.248] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:09.248] Packages: 1 packages (‘future.apply’)
[16:11:09.248] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:09.248] Resolved: FALSE
[16:11:09.248] Value: <not collected>
[16:11:09.248] Conditions captured: <none>
[16:11:09.248] Early signaling: FALSE
[16:11:09.248] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:09.248] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:09.260] Chunk #2 of 2 ... DONE
[16:11:09.260] Launching 2 futures (chunks) ... DONE
[16:11:09.260] Resolving 2 futures (chunks) ...
[16:11:09.260] resolve() on list ...
[16:11:09.260]  recursive: 0
[16:11:09.261]  length: 2
[16:11:09.261] 
[16:11:09.261] receiveMessageFromWorker() for ClusterFuture ...
[16:11:09.261] - Validating connection of MultisessionFuture
[16:11:09.261] - received message: FutureResult
[16:11:09.262] - Received FutureResult
[16:11:09.262] - Erased future from FutureRegistry
[16:11:09.262] result() for ClusterFuture ...
[16:11:09.262] - result already collected: FutureResult
[16:11:09.262] result() for ClusterFuture ... done
[16:11:09.262] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:09.262] Future #1
[16:11:09.262] result() for ClusterFuture ...
[16:11:09.262] - result already collected: FutureResult
[16:11:09.262] result() for ClusterFuture ... done
[16:11:09.262] result() for ClusterFuture ...
[16:11:09.263] - result already collected: FutureResult
[16:11:09.263] result() for ClusterFuture ... done
[16:11:09.263] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:09.263] - nx: 2
[16:11:09.263] - relay: TRUE
[16:11:09.263] - stdout: TRUE
[16:11:09.263] - signal: TRUE
[16:11:09.263] - resignal: FALSE
[16:11:09.263] - force: TRUE
[16:11:09.263] - relayed: [n=2] FALSE, FALSE
[16:11:09.263] - queued futures: [n=2] FALSE, FALSE
[16:11:09.263]  - until=1
[16:11:09.264]  - relaying element #1
[16:11:09.264] result() for ClusterFuture ...
[16:11:09.264] - result already collected: FutureResult
[16:11:09.264] result() for ClusterFuture ... done
[16:11:09.264] result() for ClusterFuture ...
[16:11:09.264] - result already collected: FutureResult
[16:11:09.264] result() for ClusterFuture ... done
[16:11:09.264] result() for ClusterFuture ...
[16:11:09.264] - result already collected: FutureResult
[16:11:09.264] result() for ClusterFuture ... done
[16:11:09.265] result() for ClusterFuture ...
[16:11:09.265] - result already collected: FutureResult
[16:11:09.265] result() for ClusterFuture ... done
[16:11:09.265] - relayed: [n=2] TRUE, FALSE
[16:11:09.265] - queued futures: [n=2] TRUE, FALSE
[16:11:09.265] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:09.265]  length: 1 (resolved future 1)
[16:11:09.307] receiveMessageFromWorker() for ClusterFuture ...
[16:11:09.307] - Validating connection of MultisessionFuture
[16:11:09.307] - received message: FutureResult
[16:11:09.307] - Received FutureResult
[16:11:09.307] - Erased future from FutureRegistry
[16:11:09.308] result() for ClusterFuture ...
[16:11:09.308] - result already collected: FutureResult
[16:11:09.308] result() for ClusterFuture ... done
[16:11:09.308] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:09.308] Future #2
[16:11:09.308] result() for ClusterFuture ...
[16:11:09.308] - result already collected: FutureResult
[16:11:09.308] result() for ClusterFuture ... done
[16:11:09.308] result() for ClusterFuture ...
[16:11:09.308] - result already collected: FutureResult
[16:11:09.309] result() for ClusterFuture ... done
[16:11:09.309] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:11:09.309] - nx: 2
[16:11:09.309] - relay: TRUE
[16:11:09.309] - stdout: TRUE
[16:11:09.309] - signal: TRUE
[16:11:09.309] - resignal: FALSE
[16:11:09.309] - force: TRUE
[16:11:09.309] - relayed: [n=2] TRUE, FALSE
[16:11:09.309] - queued futures: [n=2] TRUE, FALSE
[16:11:09.309]  - until=2
[16:11:09.309]  - relaying element #2
[16:11:09.310] result() for ClusterFuture ...
[16:11:09.310] - result already collected: FutureResult
[16:11:09.310] result() for ClusterFuture ... done
[16:11:09.310] result() for ClusterFuture ...
[16:11:09.310] - result already collected: FutureResult
[16:11:09.310] result() for ClusterFuture ... done
[16:11:09.310] result() for ClusterFuture ...
[16:11:09.310] - result already collected: FutureResult
[16:11:09.310] result() for ClusterFuture ... done
[16:11:09.310] result() for ClusterFuture ...
[16:11:09.310] - result already collected: FutureResult
[16:11:09.311] result() for ClusterFuture ... done
[16:11:09.311] - relayed: [n=2] TRUE, TRUE
[16:11:09.311] - queued futures: [n=2] TRUE, TRUE
[16:11:09.311] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:11:09.311]  length: 0 (resolved future 2)
[16:11:09.311] Relaying remaining futures
[16:11:09.311] signalConditionsASAP(NULL, pos=0) ...
[16:11:09.311] - nx: 2
[16:11:09.311] - relay: TRUE
[16:11:09.311] - stdout: TRUE
[16:11:09.311] - signal: TRUE
[16:11:09.312] - resignal: FALSE
[16:11:09.312] - force: TRUE
[16:11:09.312] - relayed: [n=2] TRUE, TRUE
[16:11:09.312] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:11:09.312] - relayed: [n=2] TRUE, TRUE
[16:11:09.312] - queued futures: [n=2] TRUE, TRUE
[16:11:09.312] signalConditionsASAP(NULL, pos=0) ... done
[16:11:09.312] resolve() on list ... DONE
[16:11:09.312] result() for ClusterFuture ...
[16:11:09.312] - result already collected: FutureResult
[16:11:09.312] result() for ClusterFuture ... done
[16:11:09.313] result() for ClusterFuture ...
[16:11:09.313] - result already collected: FutureResult
[16:11:09.313] result() for ClusterFuture ... done
[16:11:09.313] result() for ClusterFuture ...
[16:11:09.313] - result already collected: FutureResult
[16:11:09.313] result() for ClusterFuture ... done
[16:11:09.313] result() for ClusterFuture ...
[16:11:09.313] - result already collected: FutureResult
[16:11:09.313] result() for ClusterFuture ... done
[16:11:09.313]  - Number of value chunks collected: 2
[16:11:09.313] Resolving 2 futures (chunks) ... DONE
[16:11:09.314] Reducing values from 2 chunks ...
[16:11:09.314]  - Number of values collected after concatenation: 3
[16:11:09.314]  - Number of values expected: 3
[16:11:09.314] Reducing values from 2 chunks ... DONE
[16:11:09.314] future_lapply() ... DONE
- exceptions ...
[16:11:09.314] future_lapply() ...
[16:11:09.319] Number of chunks: 2
[16:11:09.319] getGlobalsAndPackagesXApply() ...
[16:11:09.320]  - future.globals: TRUE
[16:11:09.320] getGlobalsAndPackages() ...
[16:11:09.320] Searching for globals...
[16:11:09.323] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[16:11:09.323] Searching for globals ... DONE
[16:11:09.323] Resolving globals: FALSE
[16:11:09.324] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[16:11:09.325] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[16:11:09.325] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:09.325] - packages: [1] ‘future.apply’
[16:11:09.325] getGlobalsAndPackages() ... DONE
[16:11:09.325]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[16:11:09.325]  - needed namespaces: [n=1] ‘future.apply’
[16:11:09.325] Finding globals ... DONE
[16:11:09.325]  - use_args: TRUE
[16:11:09.326]  - Getting '...' globals ...
[16:11:09.326] resolve() on list ...
[16:11:09.326]  recursive: 0
[16:11:09.326]  length: 1
[16:11:09.326]  elements: ‘...’
[16:11:09.326]  length: 0 (resolved future 1)
[16:11:09.326] resolve() on list ... DONE
[16:11:09.326]    - '...' content: [n=0] 
[16:11:09.327] List of 1
[16:11:09.327]  $ ...: list()
[16:11:09.327]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:09.327]  - attr(*, "where")=List of 1
[16:11:09.327]   ..$ ...:<environment: 0x561e8c726d48> 
[16:11:09.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:09.327]  - attr(*, "resolved")= logi TRUE
[16:11:09.327]  - attr(*, "total_size")= num NA
[16:11:09.329]  - Getting '...' globals ... DONE
[16:11:09.329] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[16:11:09.329] List of 8
[16:11:09.329]  $ ...future.FUN:function (x, ...)  
[16:11:09.329]  $ x_FUN        :function (x)  
[16:11:09.329]  $ times        : int 2
[16:11:09.329]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[16:11:09.329]  $ stop_if_not  :function (...)  
[16:11:09.329]  $ dim          : NULL
[16:11:09.329]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[16:11:09.329]  $ ...          : list()
[16:11:09.329]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:11:09.329]  - attr(*, "where")=List of 8
[16:11:09.329]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:11:09.329]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[16:11:09.329]   ..$ times        :<environment: R_EmptyEnv> 
[16:11:09.329]   ..$ stopf        :<environment: R_EmptyEnv> 
[16:11:09.329]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[16:11:09.329]   ..$ dim          :<environment: R_EmptyEnv> 
[16:11:09.329]   ..$ valid_types  :<environment: R_EmptyEnv> 
[16:11:09.329]   ..$ ...          :<environment: 0x561e8c726d48> 
[16:11:09.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:11:09.329]  - attr(*, "resolved")= logi FALSE
[16:11:09.329]  - attr(*, "total_size")= num 95128
[16:11:09.335] Packages to be attached in all futures: [n=1] ‘future.apply’
[16:11:09.335] getGlobalsAndPackagesXApply() ... DONE
[16:11:09.335] Number of futures (= number of chunks): 2
[16:11:09.335] Launching 2 futures (chunks) ...
[16:11:09.335] Chunk #1 of 2 ...
[16:11:09.335]  - Finding globals in 'X' for chunk #1 ...
[16:11:09.335] getGlobalsAndPackages() ...
[16:11:09.336] Searching for globals...
[16:11:09.336] 
[16:11:09.336] Searching for globals ... DONE
[16:11:09.336] - globals: [0] <none>
[16:11:09.336] getGlobalsAndPackages() ... DONE
[16:11:09.336]    + additional globals found: [n=0] 
[16:11:09.336]    + additional namespaces needed: [n=0] 
[16:11:09.336]  - Finding globals in 'X' for chunk #1 ... DONE
[16:11:09.336]  - seeds: <none>
[16:11:09.337] getGlobalsAndPackages() ...
[16:11:09.337] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:09.337] Resolving globals: FALSE
[16:11:09.337] Tweak future expression to call with '...' arguments ...
[16:11:09.337] {
[16:11:09.337]     do.call(function(...) {
[16:11:09.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:09.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.337]             on.exit(options(oopts), add = TRUE)
[16:11:09.337]         }
[16:11:09.337]         {
[16:11:09.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:09.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.337]                 ...future.FUN(...future.X_jj, ...)
[16:11:09.337]             })
[16:11:09.337]         }
[16:11:09.337]     }, args = future.call.arguments)
[16:11:09.337] }
[16:11:09.337] Tweak future expression to call with '...' arguments ... DONE
[16:11:09.338] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:09.338] - packages: [1] ‘future.apply’
[16:11:09.338] getGlobalsAndPackages() ... DONE
[16:11:09.338] run() for ‘Future’ ...
[16:11:09.338] - state: ‘created’
[16:11:09.339] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:09.353] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:09.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:09.353]   - Field: ‘node’
[16:11:09.354]   - Field: ‘label’
[16:11:09.354]   - Field: ‘local’
[16:11:09.354]   - Field: ‘owner’
[16:11:09.354]   - Field: ‘envir’
[16:11:09.354]   - Field: ‘workers’
[16:11:09.354]   - Field: ‘packages’
[16:11:09.354]   - Field: ‘gc’
[16:11:09.354]   - Field: ‘conditions’
[16:11:09.354]   - Field: ‘persistent’
[16:11:09.354]   - Field: ‘expr’
[16:11:09.355]   - Field: ‘uuid’
[16:11:09.355]   - Field: ‘seed’
[16:11:09.355]   - Field: ‘version’
[16:11:09.355]   - Field: ‘result’
[16:11:09.355]   - Field: ‘asynchronous’
[16:11:09.355]   - Field: ‘calls’
[16:11:09.355]   - Field: ‘globals’
[16:11:09.355]   - Field: ‘stdout’
[16:11:09.355]   - Field: ‘earlySignal’
[16:11:09.358]   - Field: ‘lazy’
[16:11:09.358]   - Field: ‘state’
[16:11:09.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:09.359] - Launch lazy future ...
[16:11:09.359] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:09.359] Packages needed by future strategies (n = 0): <none>
[16:11:09.360] {
[16:11:09.360]     {
[16:11:09.360]         {
[16:11:09.360]             ...future.startTime <- base::Sys.time()
[16:11:09.360]             {
[16:11:09.360]                 {
[16:11:09.360]                   {
[16:11:09.360]                     {
[16:11:09.360]                       {
[16:11:09.360]                         base::local({
[16:11:09.360]                           has_future <- base::requireNamespace("future", 
[16:11:09.360]                             quietly = TRUE)
[16:11:09.360]                           if (has_future) {
[16:11:09.360]                             ns <- base::getNamespace("future")
[16:11:09.360]                             version <- ns[[".package"]][["version"]]
[16:11:09.360]                             if (is.null(version)) 
[16:11:09.360]                               version <- utils::packageVersion("future")
[16:11:09.360]                           }
[16:11:09.360]                           else {
[16:11:09.360]                             version <- NULL
[16:11:09.360]                           }
[16:11:09.360]                           if (!has_future || version < "1.8.0") {
[16:11:09.360]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:09.360]                               "", base::R.version$version.string), 
[16:11:09.360]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:09.360]                                 base::R.version$platform, 8 * 
[16:11:09.360]                                   base::.Machine$sizeof.pointer), 
[16:11:09.360]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:09.360]                                 "release", "version")], collapse = " "), 
[16:11:09.360]                               hostname = base::Sys.info()[["nodename"]])
[16:11:09.360]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:09.360]                               info)
[16:11:09.360]                             info <- base::paste(info, collapse = "; ")
[16:11:09.360]                             if (!has_future) {
[16:11:09.360]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:09.360]                                 info)
[16:11:09.360]                             }
[16:11:09.360]                             else {
[16:11:09.360]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:09.360]                                 info, version)
[16:11:09.360]                             }
[16:11:09.360]                             base::stop(msg)
[16:11:09.360]                           }
[16:11:09.360]                         })
[16:11:09.360]                       }
[16:11:09.360]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:09.360]                       base::options(mc.cores = 1L)
[16:11:09.360]                     }
[16:11:09.360]                     base::local({
[16:11:09.360]                       for (pkg in "future.apply") {
[16:11:09.360]                         base::loadNamespace(pkg)
[16:11:09.360]                         base::library(pkg, character.only = TRUE)
[16:11:09.360]                       }
[16:11:09.360]                     })
[16:11:09.360]                   }
[16:11:09.360]                   options(future.plan = NULL)
[16:11:09.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:09.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:09.360]                 }
[16:11:09.360]                 ...future.workdir <- getwd()
[16:11:09.360]             }
[16:11:09.360]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:09.360]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:09.360]         }
[16:11:09.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:09.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:11:09.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:09.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:09.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:09.360]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:09.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:09.360]             base::names(...future.oldOptions))
[16:11:09.360]     }
[16:11:09.360]     if (FALSE) {
[16:11:09.360]     }
[16:11:09.360]     else {
[16:11:09.360]         if (TRUE) {
[16:11:09.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:09.360]                 open = "w")
[16:11:09.360]         }
[16:11:09.360]         else {
[16:11:09.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:09.360]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:09.360]         }
[16:11:09.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:09.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:09.360]             base::sink(type = "output", split = FALSE)
[16:11:09.360]             base::close(...future.stdout)
[16:11:09.360]         }, add = TRUE)
[16:11:09.360]     }
[16:11:09.360]     ...future.frame <- base::sys.nframe()
[16:11:09.360]     ...future.conditions <- base::list()
[16:11:09.360]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:09.360]     if (FALSE) {
[16:11:09.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:09.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:09.360]     }
[16:11:09.360]     ...future.result <- base::tryCatch({
[16:11:09.360]         base::withCallingHandlers({
[16:11:09.360]             ...future.value <- base::withVisible(base::local({
[16:11:09.360]                 ...future.makeSendCondition <- local({
[16:11:09.360]                   sendCondition <- NULL
[16:11:09.360]                   function(frame = 1L) {
[16:11:09.360]                     if (is.function(sendCondition)) 
[16:11:09.360]                       return(sendCondition)
[16:11:09.360]                     ns <- getNamespace("parallel")
[16:11:09.360]                     if (exists("sendData", mode = "function", 
[16:11:09.360]                       envir = ns)) {
[16:11:09.360]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:09.360]                         envir = ns)
[16:11:09.360]                       envir <- sys.frame(frame)
[16:11:09.360]                       master <- NULL
[16:11:09.360]                       while (!identical(envir, .GlobalEnv) && 
[16:11:09.360]                         !identical(envir, emptyenv())) {
[16:11:09.360]                         if (exists("master", mode = "list", envir = envir, 
[16:11:09.360]                           inherits = FALSE)) {
[16:11:09.360]                           master <- get("master", mode = "list", 
[16:11:09.360]                             envir = envir, inherits = FALSE)
[16:11:09.360]                           if (inherits(master, c("SOCKnode", 
[16:11:09.360]                             "SOCK0node"))) {
[16:11:09.360]                             sendCondition <<- function(cond) {
[16:11:09.360]                               data <- list(type = "VALUE", value = cond, 
[16:11:09.360]                                 success = TRUE)
[16:11:09.360]                               parallel_sendData(master, data)
[16:11:09.360]                             }
[16:11:09.360]                             return(sendCondition)
[16:11:09.360]                           }
[16:11:09.360]                         }
[16:11:09.360]                         frame <- frame + 1L
[16:11:09.360]                         envir <- sys.frame(frame)
[16:11:09.360]                       }
[16:11:09.360]                     }
[16:11:09.360]                     sendCondition <<- function(cond) NULL
[16:11:09.360]                   }
[16:11:09.360]                 })
[16:11:09.360]                 withCallingHandlers({
[16:11:09.360]                   {
[16:11:09.360]                     do.call(function(...) {
[16:11:09.360]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.360]                       if (!identical(...future.globals.maxSize.org, 
[16:11:09.360]                         ...future.globals.maxSize)) {
[16:11:09.360]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.360]                         on.exit(options(oopts), add = TRUE)
[16:11:09.360]                       }
[16:11:09.360]                       {
[16:11:09.360]                         lapply(seq_along(...future.elements_ii), 
[16:11:09.360]                           FUN = function(jj) {
[16:11:09.360]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.360]                             ...future.FUN(...future.X_jj, ...)
[16:11:09.360]                           })
[16:11:09.360]                       }
[16:11:09.360]                     }, args = future.call.arguments)
[16:11:09.360]                   }
[16:11:09.360]                 }, immediateCondition = function(cond) {
[16:11:09.360]                   sendCondition <- ...future.makeSendCondition()
[16:11:09.360]                   sendCondition(cond)
[16:11:09.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.360]                   {
[16:11:09.360]                     inherits <- base::inherits
[16:11:09.360]                     invokeRestart <- base::invokeRestart
[16:11:09.360]                     is.null <- base::is.null
[16:11:09.360]                     muffled <- FALSE
[16:11:09.360]                     if (inherits(cond, "message")) {
[16:11:09.360]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:09.360]                       if (muffled) 
[16:11:09.360]                         invokeRestart("muffleMessage")
[16:11:09.360]                     }
[16:11:09.360]                     else if (inherits(cond, "warning")) {
[16:11:09.360]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:09.360]                       if (muffled) 
[16:11:09.360]                         invokeRestart("muffleWarning")
[16:11:09.360]                     }
[16:11:09.360]                     else if (inherits(cond, "condition")) {
[16:11:09.360]                       if (!is.null(pattern)) {
[16:11:09.360]                         computeRestarts <- base::computeRestarts
[16:11:09.360]                         grepl <- base::grepl
[16:11:09.360]                         restarts <- computeRestarts(cond)
[16:11:09.360]                         for (restart in restarts) {
[16:11:09.360]                           name <- restart$name
[16:11:09.360]                           if (is.null(name)) 
[16:11:09.360]                             next
[16:11:09.360]                           if (!grepl(pattern, name)) 
[16:11:09.360]                             next
[16:11:09.360]                           invokeRestart(restart)
[16:11:09.360]                           muffled <- TRUE
[16:11:09.360]                           break
[16:11:09.360]                         }
[16:11:09.360]                       }
[16:11:09.360]                     }
[16:11:09.360]                     invisible(muffled)
[16:11:09.360]                   }
[16:11:09.360]                   muffleCondition(cond)
[16:11:09.360]                 })
[16:11:09.360]             }))
[16:11:09.360]             future::FutureResult(value = ...future.value$value, 
[16:11:09.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:09.360]                   ...future.rng), globalenv = if (FALSE) 
[16:11:09.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:09.360]                     ...future.globalenv.names))
[16:11:09.360]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:09.360]         }, condition = base::local({
[16:11:09.360]             c <- base::c
[16:11:09.360]             inherits <- base::inherits
[16:11:09.360]             invokeRestart <- base::invokeRestart
[16:11:09.360]             length <- base::length
[16:11:09.360]             list <- base::list
[16:11:09.360]             seq.int <- base::seq.int
[16:11:09.360]             signalCondition <- base::signalCondition
[16:11:09.360]             sys.calls <- base::sys.calls
[16:11:09.360]             `[[` <- base::`[[`
[16:11:09.360]             `+` <- base::`+`
[16:11:09.360]             `<<-` <- base::`<<-`
[16:11:09.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:09.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:09.360]                   3L)]
[16:11:09.360]             }
[16:11:09.360]             function(cond) {
[16:11:09.360]                 is_error <- inherits(cond, "error")
[16:11:09.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:09.360]                   NULL)
[16:11:09.360]                 if (is_error) {
[16:11:09.360]                   sessionInformation <- function() {
[16:11:09.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:09.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:09.360]                       search = base::search(), system = base::Sys.info())
[16:11:09.360]                   }
[16:11:09.360]                   ...future.conditions[[length(...future.conditions) + 
[16:11:09.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:09.360]                     cond$call), session = sessionInformation(), 
[16:11:09.360]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:09.360]                   signalCondition(cond)
[16:11:09.360]                 }
[16:11:09.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:09.360]                 "immediateCondition"))) {
[16:11:09.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:09.360]                   ...future.conditions[[length(...future.conditions) + 
[16:11:09.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:09.360]                   if (TRUE && !signal) {
[16:11:09.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.360]                     {
[16:11:09.360]                       inherits <- base::inherits
[16:11:09.360]                       invokeRestart <- base::invokeRestart
[16:11:09.360]                       is.null <- base::is.null
[16:11:09.360]                       muffled <- FALSE
[16:11:09.360]                       if (inherits(cond, "message")) {
[16:11:09.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:09.360]                         if (muffled) 
[16:11:09.360]                           invokeRestart("muffleMessage")
[16:11:09.360]                       }
[16:11:09.360]                       else if (inherits(cond, "warning")) {
[16:11:09.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:09.360]                         if (muffled) 
[16:11:09.360]                           invokeRestart("muffleWarning")
[16:11:09.360]                       }
[16:11:09.360]                       else if (inherits(cond, "condition")) {
[16:11:09.360]                         if (!is.null(pattern)) {
[16:11:09.360]                           computeRestarts <- base::computeRestarts
[16:11:09.360]                           grepl <- base::grepl
[16:11:09.360]                           restarts <- computeRestarts(cond)
[16:11:09.360]                           for (restart in restarts) {
[16:11:09.360]                             name <- restart$name
[16:11:09.360]                             if (is.null(name)) 
[16:11:09.360]                               next
[16:11:09.360]                             if (!grepl(pattern, name)) 
[16:11:09.360]                               next
[16:11:09.360]                             invokeRestart(restart)
[16:11:09.360]                             muffled <- TRUE
[16:11:09.360]                             break
[16:11:09.360]                           }
[16:11:09.360]                         }
[16:11:09.360]                       }
[16:11:09.360]                       invisible(muffled)
[16:11:09.360]                     }
[16:11:09.360]                     muffleCondition(cond, pattern = "^muffle")
[16:11:09.360]                   }
[16:11:09.360]                 }
[16:11:09.360]                 else {
[16:11:09.360]                   if (TRUE) {
[16:11:09.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.360]                     {
[16:11:09.360]                       inherits <- base::inherits
[16:11:09.360]                       invokeRestart <- base::invokeRestart
[16:11:09.360]                       is.null <- base::is.null
[16:11:09.360]                       muffled <- FALSE
[16:11:09.360]                       if (inherits(cond, "message")) {
[16:11:09.360]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:09.360]                         if (muffled) 
[16:11:09.360]                           invokeRestart("muffleMessage")
[16:11:09.360]                       }
[16:11:09.360]                       else if (inherits(cond, "warning")) {
[16:11:09.360]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:09.360]                         if (muffled) 
[16:11:09.360]                           invokeRestart("muffleWarning")
[16:11:09.360]                       }
[16:11:09.360]                       else if (inherits(cond, "condition")) {
[16:11:09.360]                         if (!is.null(pattern)) {
[16:11:09.360]                           computeRestarts <- base::computeRestarts
[16:11:09.360]                           grepl <- base::grepl
[16:11:09.360]                           restarts <- computeRestarts(cond)
[16:11:09.360]                           for (restart in restarts) {
[16:11:09.360]                             name <- restart$name
[16:11:09.360]                             if (is.null(name)) 
[16:11:09.360]                               next
[16:11:09.360]                             if (!grepl(pattern, name)) 
[16:11:09.360]                               next
[16:11:09.360]                             invokeRestart(restart)
[16:11:09.360]                             muffled <- TRUE
[16:11:09.360]                             break
[16:11:09.360]                           }
[16:11:09.360]                         }
[16:11:09.360]                       }
[16:11:09.360]                       invisible(muffled)
[16:11:09.360]                     }
[16:11:09.360]                     muffleCondition(cond, pattern = "^muffle")
[16:11:09.360]                   }
[16:11:09.360]                 }
[16:11:09.360]             }
[16:11:09.360]         }))
[16:11:09.360]     }, error = function(ex) {
[16:11:09.360]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:09.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:09.360]                 ...future.rng), started = ...future.startTime, 
[16:11:09.360]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:09.360]             version = "1.8"), class = "FutureResult")
[16:11:09.360]     }, finally = {
[16:11:09.360]         if (!identical(...future.workdir, getwd())) 
[16:11:09.360]             setwd(...future.workdir)
[16:11:09.360]         {
[16:11:09.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:09.360]                 ...future.oldOptions$nwarnings <- NULL
[16:11:09.360]             }
[16:11:09.360]             base::options(...future.oldOptions)
[16:11:09.360]             if (.Platform$OS.type == "windows") {
[16:11:09.360]                 old_names <- names(...future.oldEnvVars)
[16:11:09.360]                 envs <- base::Sys.getenv()
[16:11:09.360]                 names <- names(envs)
[16:11:09.360]                 common <- intersect(names, old_names)
[16:11:09.360]                 added <- setdiff(names, old_names)
[16:11:09.360]                 removed <- setdiff(old_names, names)
[16:11:09.360]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:09.360]                   envs[common]]
[16:11:09.360]                 NAMES <- toupper(changed)
[16:11:09.360]                 args <- list()
[16:11:09.360]                 for (kk in seq_along(NAMES)) {
[16:11:09.360]                   name <- changed[[kk]]
[16:11:09.360]                   NAME <- NAMES[[kk]]
[16:11:09.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.360]                     next
[16:11:09.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:09.360]                 }
[16:11:09.360]                 NAMES <- toupper(added)
[16:11:09.360]                 for (kk in seq_along(NAMES)) {
[16:11:09.360]                   name <- added[[kk]]
[16:11:09.360]                   NAME <- NAMES[[kk]]
[16:11:09.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.360]                     next
[16:11:09.360]                   args[[name]] <- ""
[16:11:09.360]                 }
[16:11:09.360]                 NAMES <- toupper(removed)
[16:11:09.360]                 for (kk in seq_along(NAMES)) {
[16:11:09.360]                   name <- removed[[kk]]
[16:11:09.360]                   NAME <- NAMES[[kk]]
[16:11:09.360]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.360]                     next
[16:11:09.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:09.360]                 }
[16:11:09.360]                 if (length(args) > 0) 
[16:11:09.360]                   base::do.call(base::Sys.setenv, args = args)
[16:11:09.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:09.360]             }
[16:11:09.360]             else {
[16:11:09.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:09.360]             }
[16:11:09.360]             {
[16:11:09.360]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:09.360]                   0L) {
[16:11:09.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:09.360]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:09.360]                   base::options(opts)
[16:11:09.360]                 }
[16:11:09.360]                 {
[16:11:09.360]                   {
[16:11:09.360]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:09.360]                     NULL
[16:11:09.360]                   }
[16:11:09.360]                   options(future.plan = NULL)
[16:11:09.360]                   if (is.na(NA_character_)) 
[16:11:09.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:09.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:09.360]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:09.360]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:09.360]                     envir = parent.frame()) 
[16:11:09.360]                   {
[16:11:09.360]                     if (is.function(workers)) 
[16:11:09.360]                       workers <- workers()
[16:11:09.360]                     workers <- structure(as.integer(workers), 
[16:11:09.360]                       class = class(workers))
[16:11:09.360]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:09.360]                       workers >= 1)
[16:11:09.360]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:09.360]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:09.360]                     }
[16:11:09.360]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:09.360]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:09.360]                       envir = envir)
[16:11:09.360]                     if (!future$lazy) 
[16:11:09.360]                       future <- run(future)
[16:11:09.360]                     invisible(future)
[16:11:09.360]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:09.360]                 }
[16:11:09.360]             }
[16:11:09.360]         }
[16:11:09.360]     })
[16:11:09.360]     if (TRUE) {
[16:11:09.360]         base::sink(type = "output", split = FALSE)
[16:11:09.360]         if (TRUE) {
[16:11:09.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:09.360]         }
[16:11:09.360]         else {
[16:11:09.360]             ...future.result["stdout"] <- base::list(NULL)
[16:11:09.360]         }
[16:11:09.360]         base::close(...future.stdout)
[16:11:09.360]         ...future.stdout <- NULL
[16:11:09.360]     }
[16:11:09.360]     ...future.result$conditions <- ...future.conditions
[16:11:09.360]     ...future.result$finished <- base::Sys.time()
[16:11:09.360]     ...future.result
[16:11:09.360] }
[16:11:09.363] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[16:11:09.363] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[16:11:09.404] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[16:11:09.404] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[16:11:09.404] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[16:11:09.405] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[16:11:09.405] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[16:11:09.405] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[16:11:09.448] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[16:11:09.448] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[16:11:09.492] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[16:11:09.492] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[16:11:09.493] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[16:11:09.493] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[16:11:09.493] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[16:11:09.493] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:11:09.494] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:11:09.494] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:11:09.494] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:11:09.494] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:11:09.495] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:11:09.495] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:11:09.495] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:11:09.495] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[16:11:09.496] MultisessionFuture started
[16:11:09.496] - Launch lazy future ... done
[16:11:09.496] run() for ‘MultisessionFuture’ ... done
[16:11:09.497] Created future:
[16:11:09.497] MultisessionFuture:
[16:11:09.497] Label: ‘future_vapply-1’
[16:11:09.497] Expression:
[16:11:09.497] {
[16:11:09.497]     do.call(function(...) {
[16:11:09.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:09.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.497]             on.exit(options(oopts), add = TRUE)
[16:11:09.497]         }
[16:11:09.497]         {
[16:11:09.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:09.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.497]                 ...future.FUN(...future.X_jj, ...)
[16:11:09.497]             })
[16:11:09.497]         }
[16:11:09.497]     }, args = future.call.arguments)
[16:11:09.497] }
[16:11:09.497] Lazy evaluation: FALSE
[16:11:09.497] Asynchronous evaluation: TRUE
[16:11:09.497] Local evaluation: TRUE
[16:11:09.497] Environment: R_GlobalEnv
[16:11:09.497] Capture standard output: TRUE
[16:11:09.497] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:09.497] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:09.497] Packages: 1 packages (‘future.apply’)
[16:11:09.497] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:09.497] Resolved: FALSE
[16:11:09.497] Value: <not collected>
[16:11:09.497] Conditions captured: <none>
[16:11:09.497] Early signaling: FALSE
[16:11:09.497] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:09.497] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:09.509] Chunk #1 of 2 ... DONE
[16:11:09.509] Chunk #2 of 2 ...
[16:11:09.509]  - Finding globals in 'X' for chunk #2 ...
[16:11:09.509] getGlobalsAndPackages() ...
[16:11:09.509] Searching for globals...
[16:11:09.510] 
[16:11:09.510] Searching for globals ... DONE
[16:11:09.510] - globals: [0] <none>
[16:11:09.510] getGlobalsAndPackages() ... DONE
[16:11:09.510]    + additional globals found: [n=0] 
[16:11:09.510]    + additional namespaces needed: [n=0] 
[16:11:09.510]  - Finding globals in 'X' for chunk #2 ... DONE
[16:11:09.510]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:11:09.510]  - seeds: <none>
[16:11:09.510] getGlobalsAndPackages() ...
[16:11:09.511] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:09.511] Resolving globals: FALSE
[16:11:09.511] Tweak future expression to call with '...' arguments ...
[16:11:09.511] {
[16:11:09.511]     do.call(function(...) {
[16:11:09.511]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.511]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:09.511]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.511]             on.exit(options(oopts), add = TRUE)
[16:11:09.511]         }
[16:11:09.511]         {
[16:11:09.511]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:09.511]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.511]                 ...future.FUN(...future.X_jj, ...)
[16:11:09.511]             })
[16:11:09.511]         }
[16:11:09.511]     }, args = future.call.arguments)
[16:11:09.511] }
[16:11:09.511] Tweak future expression to call with '...' arguments ... DONE
[16:11:09.512] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:11:09.512] - packages: [1] ‘future.apply’
[16:11:09.512] getGlobalsAndPackages() ... DONE
[16:11:09.512] run() for ‘Future’ ...
[16:11:09.513] - state: ‘created’
[16:11:09.513] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:11:09.527] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:09.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:11:09.528]   - Field: ‘node’
[16:11:09.528]   - Field: ‘label’
[16:11:09.528]   - Field: ‘local’
[16:11:09.528]   - Field: ‘owner’
[16:11:09.528]   - Field: ‘envir’
[16:11:09.528]   - Field: ‘workers’
[16:11:09.528]   - Field: ‘packages’
[16:11:09.528]   - Field: ‘gc’
[16:11:09.529]   - Field: ‘conditions’
[16:11:09.529]   - Field: ‘persistent’
[16:11:09.529]   - Field: ‘expr’
[16:11:09.529]   - Field: ‘uuid’
[16:11:09.529]   - Field: ‘seed’
[16:11:09.529]   - Field: ‘version’
[16:11:09.529]   - Field: ‘result’
[16:11:09.529]   - Field: ‘asynchronous’
[16:11:09.529]   - Field: ‘calls’
[16:11:09.529]   - Field: ‘globals’
[16:11:09.529]   - Field: ‘stdout’
[16:11:09.530]   - Field: ‘earlySignal’
[16:11:09.530]   - Field: ‘lazy’
[16:11:09.530]   - Field: ‘state’
[16:11:09.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:11:09.530] - Launch lazy future ...
[16:11:09.530] Packages needed by the future expression (n = 1): ‘future.apply’
[16:11:09.530] Packages needed by future strategies (n = 0): <none>
[16:11:09.531] {
[16:11:09.531]     {
[16:11:09.531]         {
[16:11:09.531]             ...future.startTime <- base::Sys.time()
[16:11:09.531]             {
[16:11:09.531]                 {
[16:11:09.531]                   {
[16:11:09.531]                     {
[16:11:09.531]                       {
[16:11:09.531]                         base::local({
[16:11:09.531]                           has_future <- base::requireNamespace("future", 
[16:11:09.531]                             quietly = TRUE)
[16:11:09.531]                           if (has_future) {
[16:11:09.531]                             ns <- base::getNamespace("future")
[16:11:09.531]                             version <- ns[[".package"]][["version"]]
[16:11:09.531]                             if (is.null(version)) 
[16:11:09.531]                               version <- utils::packageVersion("future")
[16:11:09.531]                           }
[16:11:09.531]                           else {
[16:11:09.531]                             version <- NULL
[16:11:09.531]                           }
[16:11:09.531]                           if (!has_future || version < "1.8.0") {
[16:11:09.531]                             info <- base::c(r_version = base::gsub("R version ", 
[16:11:09.531]                               "", base::R.version$version.string), 
[16:11:09.531]                               platform = base::sprintf("%s (%s-bit)", 
[16:11:09.531]                                 base::R.version$platform, 8 * 
[16:11:09.531]                                   base::.Machine$sizeof.pointer), 
[16:11:09.531]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:11:09.531]                                 "release", "version")], collapse = " "), 
[16:11:09.531]                               hostname = base::Sys.info()[["nodename"]])
[16:11:09.531]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:11:09.531]                               info)
[16:11:09.531]                             info <- base::paste(info, collapse = "; ")
[16:11:09.531]                             if (!has_future) {
[16:11:09.531]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:11:09.531]                                 info)
[16:11:09.531]                             }
[16:11:09.531]                             else {
[16:11:09.531]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:11:09.531]                                 info, version)
[16:11:09.531]                             }
[16:11:09.531]                             base::stop(msg)
[16:11:09.531]                           }
[16:11:09.531]                         })
[16:11:09.531]                       }
[16:11:09.531]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:11:09.531]                       base::options(mc.cores = 1L)
[16:11:09.531]                     }
[16:11:09.531]                     base::local({
[16:11:09.531]                       for (pkg in "future.apply") {
[16:11:09.531]                         base::loadNamespace(pkg)
[16:11:09.531]                         base::library(pkg, character.only = TRUE)
[16:11:09.531]                       }
[16:11:09.531]                     })
[16:11:09.531]                   }
[16:11:09.531]                   options(future.plan = NULL)
[16:11:09.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:11:09.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:11:09.531]                 }
[16:11:09.531]                 ...future.workdir <- getwd()
[16:11:09.531]             }
[16:11:09.531]             ...future.oldOptions <- base::as.list(base::.Options)
[16:11:09.531]             ...future.oldEnvVars <- base::Sys.getenv()
[16:11:09.531]         }
[16:11:09.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:11:09.531]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:11:09.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:11:09.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:11:09.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:11:09.531]             future.stdout.windows.reencode = NULL, width = 80L)
[16:11:09.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:11:09.531]             base::names(...future.oldOptions))
[16:11:09.531]     }
[16:11:09.531]     if (FALSE) {
[16:11:09.531]     }
[16:11:09.531]     else {
[16:11:09.531]         if (TRUE) {
[16:11:09.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:11:09.531]                 open = "w")
[16:11:09.531]         }
[16:11:09.531]         else {
[16:11:09.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:11:09.531]                 windows = "NUL", "/dev/null"), open = "w")
[16:11:09.531]         }
[16:11:09.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:11:09.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:11:09.531]             base::sink(type = "output", split = FALSE)
[16:11:09.531]             base::close(...future.stdout)
[16:11:09.531]         }, add = TRUE)
[16:11:09.531]     }
[16:11:09.531]     ...future.frame <- base::sys.nframe()
[16:11:09.531]     ...future.conditions <- base::list()
[16:11:09.531]     ...future.rng <- base::globalenv()$.Random.seed
[16:11:09.531]     if (FALSE) {
[16:11:09.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:11:09.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:11:09.531]     }
[16:11:09.531]     ...future.result <- base::tryCatch({
[16:11:09.531]         base::withCallingHandlers({
[16:11:09.531]             ...future.value <- base::withVisible(base::local({
[16:11:09.531]                 ...future.makeSendCondition <- local({
[16:11:09.531]                   sendCondition <- NULL
[16:11:09.531]                   function(frame = 1L) {
[16:11:09.531]                     if (is.function(sendCondition)) 
[16:11:09.531]                       return(sendCondition)
[16:11:09.531]                     ns <- getNamespace("parallel")
[16:11:09.531]                     if (exists("sendData", mode = "function", 
[16:11:09.531]                       envir = ns)) {
[16:11:09.531]                       parallel_sendData <- get("sendData", mode = "function", 
[16:11:09.531]                         envir = ns)
[16:11:09.531]                       envir <- sys.frame(frame)
[16:11:09.531]                       master <- NULL
[16:11:09.531]                       while (!identical(envir, .GlobalEnv) && 
[16:11:09.531]                         !identical(envir, emptyenv())) {
[16:11:09.531]                         if (exists("master", mode = "list", envir = envir, 
[16:11:09.531]                           inherits = FALSE)) {
[16:11:09.531]                           master <- get("master", mode = "list", 
[16:11:09.531]                             envir = envir, inherits = FALSE)
[16:11:09.531]                           if (inherits(master, c("SOCKnode", 
[16:11:09.531]                             "SOCK0node"))) {
[16:11:09.531]                             sendCondition <<- function(cond) {
[16:11:09.531]                               data <- list(type = "VALUE", value = cond, 
[16:11:09.531]                                 success = TRUE)
[16:11:09.531]                               parallel_sendData(master, data)
[16:11:09.531]                             }
[16:11:09.531]                             return(sendCondition)
[16:11:09.531]                           }
[16:11:09.531]                         }
[16:11:09.531]                         frame <- frame + 1L
[16:11:09.531]                         envir <- sys.frame(frame)
[16:11:09.531]                       }
[16:11:09.531]                     }
[16:11:09.531]                     sendCondition <<- function(cond) NULL
[16:11:09.531]                   }
[16:11:09.531]                 })
[16:11:09.531]                 withCallingHandlers({
[16:11:09.531]                   {
[16:11:09.531]                     do.call(function(...) {
[16:11:09.531]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.531]                       if (!identical(...future.globals.maxSize.org, 
[16:11:09.531]                         ...future.globals.maxSize)) {
[16:11:09.531]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.531]                         on.exit(options(oopts), add = TRUE)
[16:11:09.531]                       }
[16:11:09.531]                       {
[16:11:09.531]                         lapply(seq_along(...future.elements_ii), 
[16:11:09.531]                           FUN = function(jj) {
[16:11:09.531]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.531]                             ...future.FUN(...future.X_jj, ...)
[16:11:09.531]                           })
[16:11:09.531]                       }
[16:11:09.531]                     }, args = future.call.arguments)
[16:11:09.531]                   }
[16:11:09.531]                 }, immediateCondition = function(cond) {
[16:11:09.531]                   sendCondition <- ...future.makeSendCondition()
[16:11:09.531]                   sendCondition(cond)
[16:11:09.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.531]                   {
[16:11:09.531]                     inherits <- base::inherits
[16:11:09.531]                     invokeRestart <- base::invokeRestart
[16:11:09.531]                     is.null <- base::is.null
[16:11:09.531]                     muffled <- FALSE
[16:11:09.531]                     if (inherits(cond, "message")) {
[16:11:09.531]                       muffled <- grepl(pattern, "muffleMessage")
[16:11:09.531]                       if (muffled) 
[16:11:09.531]                         invokeRestart("muffleMessage")
[16:11:09.531]                     }
[16:11:09.531]                     else if (inherits(cond, "warning")) {
[16:11:09.531]                       muffled <- grepl(pattern, "muffleWarning")
[16:11:09.531]                       if (muffled) 
[16:11:09.531]                         invokeRestart("muffleWarning")
[16:11:09.531]                     }
[16:11:09.531]                     else if (inherits(cond, "condition")) {
[16:11:09.531]                       if (!is.null(pattern)) {
[16:11:09.531]                         computeRestarts <- base::computeRestarts
[16:11:09.531]                         grepl <- base::grepl
[16:11:09.531]                         restarts <- computeRestarts(cond)
[16:11:09.531]                         for (restart in restarts) {
[16:11:09.531]                           name <- restart$name
[16:11:09.531]                           if (is.null(name)) 
[16:11:09.531]                             next
[16:11:09.531]                           if (!grepl(pattern, name)) 
[16:11:09.531]                             next
[16:11:09.531]                           invokeRestart(restart)
[16:11:09.531]                           muffled <- TRUE
[16:11:09.531]                           break
[16:11:09.531]                         }
[16:11:09.531]                       }
[16:11:09.531]                     }
[16:11:09.531]                     invisible(muffled)
[16:11:09.531]                   }
[16:11:09.531]                   muffleCondition(cond)
[16:11:09.531]                 })
[16:11:09.531]             }))
[16:11:09.531]             future::FutureResult(value = ...future.value$value, 
[16:11:09.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:09.531]                   ...future.rng), globalenv = if (FALSE) 
[16:11:09.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:11:09.531]                     ...future.globalenv.names))
[16:11:09.531]                 else NULL, started = ...future.startTime, version = "1.8")
[16:11:09.531]         }, condition = base::local({
[16:11:09.531]             c <- base::c
[16:11:09.531]             inherits <- base::inherits
[16:11:09.531]             invokeRestart <- base::invokeRestart
[16:11:09.531]             length <- base::length
[16:11:09.531]             list <- base::list
[16:11:09.531]             seq.int <- base::seq.int
[16:11:09.531]             signalCondition <- base::signalCondition
[16:11:09.531]             sys.calls <- base::sys.calls
[16:11:09.531]             `[[` <- base::`[[`
[16:11:09.531]             `+` <- base::`+`
[16:11:09.531]             `<<-` <- base::`<<-`
[16:11:09.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:11:09.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:11:09.531]                   3L)]
[16:11:09.531]             }
[16:11:09.531]             function(cond) {
[16:11:09.531]                 is_error <- inherits(cond, "error")
[16:11:09.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:11:09.531]                   NULL)
[16:11:09.531]                 if (is_error) {
[16:11:09.531]                   sessionInformation <- function() {
[16:11:09.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:11:09.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:11:09.531]                       search = base::search(), system = base::Sys.info())
[16:11:09.531]                   }
[16:11:09.531]                   ...future.conditions[[length(...future.conditions) + 
[16:11:09.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:11:09.531]                     cond$call), session = sessionInformation(), 
[16:11:09.531]                     timestamp = base::Sys.time(), signaled = 0L)
[16:11:09.531]                   signalCondition(cond)
[16:11:09.531]                 }
[16:11:09.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:11:09.531]                 "immediateCondition"))) {
[16:11:09.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:11:09.531]                   ...future.conditions[[length(...future.conditions) + 
[16:11:09.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:11:09.531]                   if (TRUE && !signal) {
[16:11:09.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.531]                     {
[16:11:09.531]                       inherits <- base::inherits
[16:11:09.531]                       invokeRestart <- base::invokeRestart
[16:11:09.531]                       is.null <- base::is.null
[16:11:09.531]                       muffled <- FALSE
[16:11:09.531]                       if (inherits(cond, "message")) {
[16:11:09.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:09.531]                         if (muffled) 
[16:11:09.531]                           invokeRestart("muffleMessage")
[16:11:09.531]                       }
[16:11:09.531]                       else if (inherits(cond, "warning")) {
[16:11:09.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:09.531]                         if (muffled) 
[16:11:09.531]                           invokeRestart("muffleWarning")
[16:11:09.531]                       }
[16:11:09.531]                       else if (inherits(cond, "condition")) {
[16:11:09.531]                         if (!is.null(pattern)) {
[16:11:09.531]                           computeRestarts <- base::computeRestarts
[16:11:09.531]                           grepl <- base::grepl
[16:11:09.531]                           restarts <- computeRestarts(cond)
[16:11:09.531]                           for (restart in restarts) {
[16:11:09.531]                             name <- restart$name
[16:11:09.531]                             if (is.null(name)) 
[16:11:09.531]                               next
[16:11:09.531]                             if (!grepl(pattern, name)) 
[16:11:09.531]                               next
[16:11:09.531]                             invokeRestart(restart)
[16:11:09.531]                             muffled <- TRUE
[16:11:09.531]                             break
[16:11:09.531]                           }
[16:11:09.531]                         }
[16:11:09.531]                       }
[16:11:09.531]                       invisible(muffled)
[16:11:09.531]                     }
[16:11:09.531]                     muffleCondition(cond, pattern = "^muffle")
[16:11:09.531]                   }
[16:11:09.531]                 }
[16:11:09.531]                 else {
[16:11:09.531]                   if (TRUE) {
[16:11:09.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:11:09.531]                     {
[16:11:09.531]                       inherits <- base::inherits
[16:11:09.531]                       invokeRestart <- base::invokeRestart
[16:11:09.531]                       is.null <- base::is.null
[16:11:09.531]                       muffled <- FALSE
[16:11:09.531]                       if (inherits(cond, "message")) {
[16:11:09.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:11:09.531]                         if (muffled) 
[16:11:09.531]                           invokeRestart("muffleMessage")
[16:11:09.531]                       }
[16:11:09.531]                       else if (inherits(cond, "warning")) {
[16:11:09.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:11:09.531]                         if (muffled) 
[16:11:09.531]                           invokeRestart("muffleWarning")
[16:11:09.531]                       }
[16:11:09.531]                       else if (inherits(cond, "condition")) {
[16:11:09.531]                         if (!is.null(pattern)) {
[16:11:09.531]                           computeRestarts <- base::computeRestarts
[16:11:09.531]                           grepl <- base::grepl
[16:11:09.531]                           restarts <- computeRestarts(cond)
[16:11:09.531]                           for (restart in restarts) {
[16:11:09.531]                             name <- restart$name
[16:11:09.531]                             if (is.null(name)) 
[16:11:09.531]                               next
[16:11:09.531]                             if (!grepl(pattern, name)) 
[16:11:09.531]                               next
[16:11:09.531]                             invokeRestart(restart)
[16:11:09.531]                             muffled <- TRUE
[16:11:09.531]                             break
[16:11:09.531]                           }
[16:11:09.531]                         }
[16:11:09.531]                       }
[16:11:09.531]                       invisible(muffled)
[16:11:09.531]                     }
[16:11:09.531]                     muffleCondition(cond, pattern = "^muffle")
[16:11:09.531]                   }
[16:11:09.531]                 }
[16:11:09.531]             }
[16:11:09.531]         }))
[16:11:09.531]     }, error = function(ex) {
[16:11:09.531]         base::structure(base::list(value = NULL, visible = NULL, 
[16:11:09.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:11:09.531]                 ...future.rng), started = ...future.startTime, 
[16:11:09.531]             finished = Sys.time(), session_uuid = NA_character_, 
[16:11:09.531]             version = "1.8"), class = "FutureResult")
[16:11:09.531]     }, finally = {
[16:11:09.531]         if (!identical(...future.workdir, getwd())) 
[16:11:09.531]             setwd(...future.workdir)
[16:11:09.531]         {
[16:11:09.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:11:09.531]                 ...future.oldOptions$nwarnings <- NULL
[16:11:09.531]             }
[16:11:09.531]             base::options(...future.oldOptions)
[16:11:09.531]             if (.Platform$OS.type == "windows") {
[16:11:09.531]                 old_names <- names(...future.oldEnvVars)
[16:11:09.531]                 envs <- base::Sys.getenv()
[16:11:09.531]                 names <- names(envs)
[16:11:09.531]                 common <- intersect(names, old_names)
[16:11:09.531]                 added <- setdiff(names, old_names)
[16:11:09.531]                 removed <- setdiff(old_names, names)
[16:11:09.531]                 changed <- common[...future.oldEnvVars[common] != 
[16:11:09.531]                   envs[common]]
[16:11:09.531]                 NAMES <- toupper(changed)
[16:11:09.531]                 args <- list()
[16:11:09.531]                 for (kk in seq_along(NAMES)) {
[16:11:09.531]                   name <- changed[[kk]]
[16:11:09.531]                   NAME <- NAMES[[kk]]
[16:11:09.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.531]                     next
[16:11:09.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:09.531]                 }
[16:11:09.531]                 NAMES <- toupper(added)
[16:11:09.531]                 for (kk in seq_along(NAMES)) {
[16:11:09.531]                   name <- added[[kk]]
[16:11:09.531]                   NAME <- NAMES[[kk]]
[16:11:09.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.531]                     next
[16:11:09.531]                   args[[name]] <- ""
[16:11:09.531]                 }
[16:11:09.531]                 NAMES <- toupper(removed)
[16:11:09.531]                 for (kk in seq_along(NAMES)) {
[16:11:09.531]                   name <- removed[[kk]]
[16:11:09.531]                   NAME <- NAMES[[kk]]
[16:11:09.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:11:09.531]                     next
[16:11:09.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:11:09.531]                 }
[16:11:09.531]                 if (length(args) > 0) 
[16:11:09.531]                   base::do.call(base::Sys.setenv, args = args)
[16:11:09.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:11:09.531]             }
[16:11:09.531]             else {
[16:11:09.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:11:09.531]             }
[16:11:09.531]             {
[16:11:09.531]                 if (base::length(...future.futureOptionsAdded) > 
[16:11:09.531]                   0L) {
[16:11:09.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:11:09.531]                   base::names(opts) <- ...future.futureOptionsAdded
[16:11:09.531]                   base::options(opts)
[16:11:09.531]                 }
[16:11:09.531]                 {
[16:11:09.531]                   {
[16:11:09.531]                     base::options(mc.cores = ...future.mc.cores.old)
[16:11:09.531]                     NULL
[16:11:09.531]                   }
[16:11:09.531]                   options(future.plan = NULL)
[16:11:09.531]                   if (is.na(NA_character_)) 
[16:11:09.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:11:09.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:11:09.531]                   future::plan(list(function (..., workers = availableCores(), 
[16:11:09.531]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:11:09.531]                     envir = parent.frame()) 
[16:11:09.531]                   {
[16:11:09.531]                     if (is.function(workers)) 
[16:11:09.531]                       workers <- workers()
[16:11:09.531]                     workers <- structure(as.integer(workers), 
[16:11:09.531]                       class = class(workers))
[16:11:09.531]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:11:09.531]                       workers >= 1)
[16:11:09.531]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:11:09.531]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:11:09.531]                     }
[16:11:09.531]                     future <- MultisessionFuture(..., workers = workers, 
[16:11:09.531]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:11:09.531]                       envir = envir)
[16:11:09.531]                     if (!future$lazy) 
[16:11:09.531]                       future <- run(future)
[16:11:09.531]                     invisible(future)
[16:11:09.531]                   }), .cleanup = FALSE, .init = FALSE)
[16:11:09.531]                 }
[16:11:09.531]             }
[16:11:09.531]         }
[16:11:09.531]     })
[16:11:09.531]     if (TRUE) {
[16:11:09.531]         base::sink(type = "output", split = FALSE)
[16:11:09.531]         if (TRUE) {
[16:11:09.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:11:09.531]         }
[16:11:09.531]         else {
[16:11:09.531]             ...future.result["stdout"] <- base::list(NULL)
[16:11:09.531]         }
[16:11:09.531]         base::close(...future.stdout)
[16:11:09.531]         ...future.stdout <- NULL
[16:11:09.531]     }
[16:11:09.531]     ...future.result$conditions <- ...future.conditions
[16:11:09.531]     ...future.result$finished <- base::Sys.time()
[16:11:09.531]     ...future.result
[16:11:09.531] }
[16:11:09.534] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[16:11:09.534] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[16:11:09.576] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[16:11:09.576] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[16:11:09.577] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[16:11:09.577] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[16:11:09.577] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[16:11:09.577] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[16:11:09.620] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[16:11:09.620] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[16:11:09.668] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[16:11:09.668] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[16:11:09.669] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[16:11:09.669] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[16:11:09.669] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[16:11:09.670] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:11:09.670] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:11:09.670] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:11:09.670] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:11:09.671] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:11:09.671] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:11:09.671] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:11:09.671] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:11:09.671] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[16:11:09.672] MultisessionFuture started
[16:11:09.672] - Launch lazy future ... done
[16:11:09.672] run() for ‘MultisessionFuture’ ... done
[16:11:09.672] Created future:
[16:11:09.672] MultisessionFuture:
[16:11:09.672] Label: ‘future_vapply-2’
[16:11:09.672] Expression:
[16:11:09.672] {
[16:11:09.672]     do.call(function(...) {
[16:11:09.672]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:11:09.672]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:11:09.672]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:11:09.672]             on.exit(options(oopts), add = TRUE)
[16:11:09.672]         }
[16:11:09.672]         {
[16:11:09.672]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:11:09.672]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:11:09.672]                 ...future.FUN(...future.X_jj, ...)
[16:11:09.672]             })
[16:11:09.672]         }
[16:11:09.672]     }, args = future.call.arguments)
[16:11:09.672] }
[16:11:09.672] Lazy evaluation: FALSE
[16:11:09.672] Asynchronous evaluation: TRUE
[16:11:09.672] Local evaluation: TRUE
[16:11:09.672] Environment: R_GlobalEnv
[16:11:09.672] Capture standard output: TRUE
[16:11:09.672] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:11:09.672] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[16:11:09.672] Packages: 1 packages (‘future.apply’)
[16:11:09.672] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:11:09.672] Resolved: FALSE
[16:11:09.672] Value: <not collected>
[16:11:09.672] Conditions captured: <none>
[16:11:09.672] Early signaling: FALSE
[16:11:09.672] Owner process: 2342c8be-d12a-4016-4024-1577f3d8d584
[16:11:09.672] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:11:09.684] Chunk #2 of 2 ... DONE
[16:11:09.684] Launching 2 futures (chunks) ... DONE
[16:11:09.684] Resolving 2 futures (chunks) ...
[16:11:09.685] resolve() on list ...
[16:11:09.685]  recursive: 0
[16:11:09.685]  length: 2
[16:11:09.685] 
[16:11:09.685] receiveMessageFromWorker() for ClusterFuture ...
[16:11:09.686] - Validating connection of MultisessionFuture
[16:11:09.686] - received message: FutureResult
[16:11:09.686] - Received FutureResult
[16:11:09.686] - Erased future from FutureRegistry
[16:11:09.686] result() for ClusterFuture ...
[16:11:09.686] - result already collected: FutureResult
[16:11:09.686] result() for ClusterFuture ... done
[16:11:09.687] signalConditions() ...
[16:11:09.687]  - include = ‘immediateCondition’
[16:11:09.687]  - exclude = 
[16:11:09.687]  - resignal = FALSE
[16:11:09.687]  - Number of conditions: 1
[16:11:09.687] signalConditions() ... done
[16:11:09.687] receiveMessageFromWorker() for ClusterFuture ... done
[16:11:09.687] Future #1
[16:11:09.687] result() for ClusterFuture ...
[16:11:09.687] - result already collected: FutureResult
[16:11:09.687] result() for ClusterFuture ... done
[16:11:09.688] result() for ClusterFuture ...
[16:11:09.688] - result already collected: FutureResult
[16:11:09.688] result() for ClusterFuture ... done
[16:11:09.688] signalConditions() ...
[16:11:09.688]  - include = ‘immediateCondition’
[16:11:09.688]  - exclude = 
[16:11:09.688]  - resignal = FALSE
[16:11:09.688]  - Number of conditions: 1
[16:11:09.688] signalConditions() ... done
[16:11:09.688] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:11:09.688] - nx: 2
[16:11:09.689] - relay: TRUE
[16:11:09.689] - stdout: TRUE
[16:11:09.689] - signal: TRUE
[16:11:09.689] - resignal: FALSE
[16:11:09.689] - force: TRUE
[16:11:09.689] - relayed: [n=2] FALSE, FALSE
[16:11:09.689] - queued futures: [n=2] FALSE, FALSE
[16:11:09.689]  - until=1
[16:11:09.689]  - relaying element #1
[16:11:09.689] result() for ClusterFuture ...
[16:11:09.689] - result already collected: FutureResult
[16:11:09.690] result() for ClusterFuture ... done
[16:11:09.690] result() for ClusterFuture ...
[16:11:09.690] - result already collected: FutureResult
[16:11:09.690] result() for ClusterFuture ... done
[16:11:09.690] signalConditions() ...
[16:11:09.690]  - include = ‘immediateCondition’
[16:11:09.690]  - exclude = 
[16:11:09.690]  - resignal = FALSE
[16:11:09.690]  - Number of conditions: 1
[16:11:09.690] signalConditions() ... done
[16:11:09.690] result() for ClusterFuture ...
[16:11:09.691] - result already collected: FutureResult
[16:11:09.691] result() for ClusterFuture ... done
[16:11:09.691] signalConditions() ...
[16:11:09.691]  - include = ‘immediateCondition’
[16:11:09.691]  - exclude = 
[16:11:09.691]  - resignal = FALSE
[16:11:09.691]  - Number of conditions: 1
[16:11:09.691] signalConditions() ... done
[16:11:09.691] result() for ClusterFuture ...
[16:11:09.691] - result already collected: FutureResult
[16:11:09.691] result() for ClusterFuture ... done
[16:11:09.692] signalConditions() ...
[16:11:09.692]  - include = ‘condition’
[16:11:09.692]  - exclude = ‘immediateCondition’
[16:11:09.692]  - resignal = TRUE
[16:11:09.692]  - Number of conditions: 1
[16:11:09.692]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:11:09.692] signalConditions() ... done
[16:11:09.692] - relayed: [n=2] FALSE, FALSE
[16:11:09.692] - queued futures: [n=2] TRUE, FALSE
[16:11:09.692] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:11:09.693] plan(): Setting new future strategy stack:
[16:11:09.693] List of future strategies:
[16:11:09.693] 1. sequential:
[16:11:09.693]    - args: function (..., envir = parent.frame())
[16:11:09.693]    - tweaked: FALSE
[16:11:09.693]    - call: plan(sequential)
[16:11:09.693] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[16:11:09.694] plan(): Setting new future strategy stack:
[16:11:09.695] List of future strategies:
[16:11:09.695] 1. FutureStrategy:
[16:11:09.695]    - args: function (..., envir = parent.frame())
[16:11:09.695]    - tweaked: FALSE
[16:11:09.695]    - call: future::plan(oplan)
[16:11:09.695] plan(): nbrOfWorkers() = 1
> 
